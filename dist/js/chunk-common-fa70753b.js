(self["webpackChunkfacilio_web"]=self["webpackChunkfacilio_web"]||[]).push([[49081],{
/***/96333:
/***/function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";
/* harmony export */function getNodeName(element){return element?(element.nodeName||"").toLowerCase():null}
/***/__webpack_require__.d(__webpack_exports__,{
/* harmony export */Z:function(){/* binding */return getNodeName}
/* harmony export */})},
/***/762057:
/***/function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";
/* harmony export */function getWindow(node){if(null==node)return window;if("[object Window]"!==node.toString()){var ownerDocument=node.ownerDocument;return ownerDocument&&ownerDocument.defaultView||window}return node}
/***/__webpack_require__.d(__webpack_exports__,{
/* harmony export */Z:function(){/* binding */return getWindow}
/* harmony export */})},
/***/162556:
/***/function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";
/* harmony export */__webpack_require__.d(__webpack_exports__,{
/* harmony export */Re:function(){/* binding */return isHTMLElement},
/* harmony export */Zq:function(){/* binding */return isShadowRoot},
/* harmony export */kK:function(){/* binding */return isElement}
/* harmony export */});
/* harmony import */var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(762057);function isElement(node){var OwnElement=(0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */.Z)(node).Element;return node instanceof OwnElement||node instanceof Element}function isHTMLElement(node){var OwnElement=(0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */.Z)(node).HTMLElement;return node instanceof OwnElement||node instanceof HTMLElement}function isShadowRoot(node){
// IE 11 has no ShadowRoot
if("undefined"===typeof ShadowRoot)return!1;var OwnElement=(0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */.Z)(node).ShadowRoot;return node instanceof OwnElement||node instanceof ShadowRoot}
/***/},
/***/817824:
/***/function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";
/* harmony import */var _dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(96333),_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(162556);
/* harmony import */
// This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow
function applyStyles(_ref){var state=_ref.state;Object.keys(state.elements).forEach((function(name){var style=state.styles[name]||{},attributes=state.attributes[name]||{},element=state.elements[name];// arrow is optional + virtual elements
(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__/* .isHTMLElement */.Re)(element)&&(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */.Z)(element)&&(// Flow doesn't support to extend this property, but it's the most
// effective way to apply styles to an HTMLElement
// $FlowFixMe[cannot-write]
Object.assign(element.style,style),Object.keys(attributes).forEach((function(name){var value=attributes[name];!1===value?element.removeAttribute(name):element.setAttribute(name,!0===value?"":value)})))}))}function effect(_ref2){var state=_ref2.state,initialStyles={popper:{position:state.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};return Object.assign(state.elements.popper.style,initialStyles.popper),state.styles=initialStyles,state.elements.arrow&&Object.assign(state.elements.arrow.style,initialStyles.arrow),function(){Object.keys(state.elements).forEach((function(name){var element=state.elements[name],attributes=state.attributes[name]||{},styleProperties=Object.keys(state.styles.hasOwnProperty(name)?state.styles[name]:initialStyles[name]),style=styleProperties.reduce((function(style,property){return style[property]="",style}),{});// arrow is optional + virtual elements
(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__/* .isHTMLElement */.Re)(element)&&(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */.Z)(element)&&(Object.assign(element.style,style),Object.keys(attributes).forEach((function(attribute){element.removeAttribute(attribute)})))}))}}// eslint-disable-next-line import/no-unused-modules
/* harmony default export */__webpack_exports__.Z={name:"applyStyles",enabled:!0,phase:"write",fn:applyStyles,effect:effect,requires:["computeStyles"]}},
/***/430212:
/***/function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";
// EXPORTS
__webpack_require__.d(__webpack_exports__,{fi:function(){/* binding */return popper_createPopper}});
// UNUSED EXPORTS: applyStyles, arrow, computeStyles, createPopperLite, defaultModifiers, detectOverflow, eventListeners, flip, hide, offset, popperGenerator, popperOffsets, preventOverflow
// EXTERNAL MODULE: ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
var instanceOf=__webpack_require__(162556),math_max=Math.max,math_min=Math.min,round=Math.round,getWindow=__webpack_require__(762057);// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString(){var uaData=navigator.userAgentData;return null!=uaData&&uaData.brands&&Array.isArray(uaData.brands)?uaData.brands.map((function(item){return item.brand+"/"+item.version})).join(" "):navigator.userAgent}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport(){return!/^((?!chrome|android).)*safari/i.test(getUAString())}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element,includeScale,isFixedStrategy){void 0===includeScale&&(includeScale=!1),void 0===isFixedStrategy&&(isFixedStrategy=!1);var clientRect=element.getBoundingClientRect(),scaleX=1,scaleY=1;includeScale&&(0,instanceOf/* isHTMLElement */.Re)(element)&&(scaleX=element.offsetWidth>0&&round(clientRect.width)/element.offsetWidth||1,scaleY=element.offsetHeight>0&&round(clientRect.height)/element.offsetHeight||1);var _ref=(0,instanceOf/* isElement */.kK)(element)?(0,getWindow/* default */.Z)(element):window,visualViewport=_ref.visualViewport,addVisualOffsets=!isLayoutViewport()&&isFixedStrategy,x=(clientRect.left+(addVisualOffsets&&visualViewport?visualViewport.offsetLeft:0))/scaleX,y=(clientRect.top+(addVisualOffsets&&visualViewport?visualViewport.offsetTop:0))/scaleY,width=clientRect.width/scaleX,height=clientRect.height/scaleY;return{width:width,height:height,top:y,right:x+width,bottom:y+height,left:x,x:x,y:y}}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node){var win=(0,getWindow/* default */.Z)(node),scrollLeft=win.pageXOffset,scrollTop=win.pageYOffset;return{scrollLeft:scrollLeft,scrollTop:scrollTop}}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element){return{scrollLeft:element.scrollLeft,scrollTop:element.scrollTop}}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node){return node!==(0,getWindow/* default */.Z)(node)&&(0,instanceOf/* isHTMLElement */.Re)(node)?getHTMLElementScroll(node):getWindowScroll(node)}
// EXTERNAL MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
var getNodeName=__webpack_require__(96333);// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element){
// $FlowFixMe[incompatible-return]: assume body is always available
return(((0,instanceOf/* isElement */.kK)(element)?element.ownerDocument:// $FlowFixMe[prop-missing]
element.document)||window.document).documentElement}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element){
// If <html> has a CSS width greater than the viewport, then this will be
// incorrect for RTL.
// Popper 1 is broken in this case and never had a bug report so let's assume
// it's not an issue. I don't think anyone ever specifies width on <html>
// anyway.
// Browsers where the left scrollbar doesn't cause an issue report `0` for
// this (e.g. Edge 2019, IE11, Safari)
return getBoundingClientRect(getDocumentElement(element)).left+getWindowScroll(element).scrollLeft}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element){return(0,getWindow/* default */.Z)(element).getComputedStyle(element)}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element){
// Firefox wants us to check `-x` and `-y` variations as well
var _getComputedStyle=getComputedStyle(element),overflow=_getComputedStyle.overflow,overflowX=_getComputedStyle.overflowX,overflowY=_getComputedStyle.overflowY;return/auto|scroll|overlay|hidden/.test(overflow+overflowY+overflowX)}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element){var rect=element.getBoundingClientRect(),scaleX=round(rect.width)/element.offsetWidth||1,scaleY=round(rect.height)/element.offsetHeight||1;return 1!==scaleX||1!==scaleY}// Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.
function getCompositeRect(elementOrVirtualElement,offsetParent,isFixed){void 0===isFixed&&(isFixed=!1);var isOffsetParentAnElement=(0,instanceOf/* isHTMLElement */.Re)(offsetParent),offsetParentIsScaled=(0,instanceOf/* isHTMLElement */.Re)(offsetParent)&&isElementScaled(offsetParent),documentElement=getDocumentElement(offsetParent),rect=getBoundingClientRect(elementOrVirtualElement,offsetParentIsScaled,isFixed),scroll={scrollLeft:0,scrollTop:0},offsets={x:0,y:0};return(isOffsetParentAnElement||!isOffsetParentAnElement&&!isFixed)&&(("body"!==(0,getNodeName/* default */.Z)(offsetParent)||// https://github.com/popperjs/popper-core/issues/1078
isScrollParent(documentElement))&&(scroll=getNodeScroll(offsetParent)),(0,instanceOf/* isHTMLElement */.Re)(offsetParent)?(offsets=getBoundingClientRect(offsetParent,!0),offsets.x+=offsetParent.clientLeft,offsets.y+=offsetParent.clientTop):documentElement&&(offsets.x=getWindowScrollBarX(documentElement))),{x:rect.left+scroll.scrollLeft-offsets.x,y:rect.top+scroll.scrollTop-offsets.y,width:rect.width,height:rect.height}}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
// Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.
function getLayoutRect(element){var clientRect=getBoundingClientRect(element),width=element.offsetWidth,height=element.offsetHeight;// Use the clientRect sizes if it's not been transformed.
// Fixes https://github.com/popperjs/popper-core/issues/1223
return Math.abs(clientRect.width-width)<=1&&(width=clientRect.width),Math.abs(clientRect.height-height)<=1&&(height=clientRect.height),{x:element.offsetLeft,y:element.offsetTop,width:width,height:height}}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element){return"html"===(0,getNodeName/* default */.Z)(element)?element:// this is a quicker (but less type safe) way to save quite some bytes from the bundle
// $FlowFixMe[incompatible-return]
// $FlowFixMe[prop-missing]
element.assignedSlot||// step into the shadow DOM of the parent of a slotted node
element.parentNode||(// DOM Element detected
(0,instanceOf/* isShadowRoot */.Zq)(element)?element.host:null)||// ShadowRoot detected
// $FlowFixMe[incompatible-call]: HTMLElement is a Node
getDocumentElement(element)}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node){return["html","body","#document"].indexOf((0,getNodeName/* default */.Z)(node))>=0?node.ownerDocument.body:(0,instanceOf/* isHTMLElement */.Re)(node)&&isScrollParent(node)?node:getScrollParent(getParentNode(node))}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/
function listScrollParents(element,list){var _element$ownerDocumen;void 0===list&&(list=[]);var scrollParent=getScrollParent(element),isBody=scrollParent===(null==(_element$ownerDocumen=element.ownerDocument)?void 0:_element$ownerDocumen.body),win=(0,getWindow/* default */.Z)(scrollParent),target=isBody?[win].concat(win.visualViewport||[],isScrollParent(scrollParent)?scrollParent:[]):scrollParent,updatedList=list.concat(target);return isBody?updatedList:// $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
updatedList.concat(listScrollParents(getParentNode(target)))}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element){return["table","td","th"].indexOf((0,getNodeName/* default */.Z)(element))>=0}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element){return(0,instanceOf/* isHTMLElement */.Re)(element)&&// https://github.com/popperjs/popper-core/issues/837
"fixed"!==getComputedStyle(element).position?element.offsetParent:null}// `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block
function getContainingBlock(element){var isFirefox=/firefox/i.test(getUAString()),isIE=/Trident/i.test(getUAString());if(isIE&&(0,instanceOf/* isHTMLElement */.Re)(element)){
// In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
var elementCss=getComputedStyle(element);if("fixed"===elementCss.position)return null}var currentNode=getParentNode(element);(0,instanceOf/* isShadowRoot */.Zq)(currentNode)&&(currentNode=currentNode.host);while((0,instanceOf/* isHTMLElement */.Re)(currentNode)&&["html","body"].indexOf((0,getNodeName/* default */.Z)(currentNode))<0){var css=getComputedStyle(currentNode);// This is non-exhaustive but covers the most common CSS properties that
// create a containing block.
// https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
if("none"!==css.transform||"none"!==css.perspective||"paint"===css.contain||-1!==["transform","perspective"].indexOf(css.willChange)||isFirefox&&"filter"===css.willChange||isFirefox&&css.filter&&"none"!==css.filter)return currentNode;currentNode=currentNode.parentNode}return null}// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element){var window=(0,getWindow/* default */.Z)(element),offsetParent=getTrueOffsetParent(element);while(offsetParent&&isTableElement(offsetParent)&&"static"===getComputedStyle(offsetParent).position)offsetParent=getTrueOffsetParent(offsetParent);return offsetParent&&("html"===(0,getNodeName/* default */.Z)(offsetParent)||"body"===(0,getNodeName/* default */.Z)(offsetParent)&&"static"===getComputedStyle(offsetParent).position)?window:offsetParent||getContainingBlock(element)||window}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/enums.js
var enums_top="top",bottom="bottom",right="right",left="left",auto="auto",basePlacements=[enums_top,bottom,right,left],start="start",end="end",clippingParents="clippingParents",viewport="viewport",popper="popper",reference="reference",variationPlacements=basePlacements.reduce((function(acc,placement){return acc.concat([placement+"-"+start,placement+"-"+end])}),[]),enums_placements=[].concat(basePlacements,[auto]).reduce((function(acc,placement){return acc.concat([placement,placement+"-"+start,placement+"-"+end])}),[]),beforeRead="beforeRead",read="read",afterRead="afterRead",beforeMain="beforeMain",main="main",afterMain="afterMain",beforeWrite="beforeWrite",write="write",afterWrite="afterWrite",modifierPhases=[beforeRead,read,afterRead,beforeMain,main,afterMain,beforeWrite,write,afterWrite];// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/orderModifiers.js
// source: https://stackoverflow.com/questions/49875255
function order(modifiers){var map=new Map,visited=new Set,result=[];// On visiting object, check for its dependencies and visit them recursively
function sort(modifier){visited.add(modifier.name);var requires=[].concat(modifier.requires||[],modifier.requiresIfExists||[]);requires.forEach((function(dep){if(!visited.has(dep)){var depModifier=map.get(dep);depModifier&&sort(depModifier)}})),result.push(modifier)}return modifiers.forEach((function(modifier){map.set(modifier.name,modifier)})),modifiers.forEach((function(modifier){visited.has(modifier.name)||
// check for visited object
sort(modifier)})),result}function orderModifiers(modifiers){
// order based on dependencies
var orderedModifiers=order(modifiers);// order based on phase
return modifierPhases.reduce((function(acc,phase){return acc.concat(orderedModifiers.filter((function(modifier){return modifier.phase===phase})))}),[])}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn){var pending;return function(){return pending||(pending=new Promise((function(resolve){Promise.resolve().then((function(){pending=void 0,resolve(fn())}))}))),pending}}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers){var merged=modifiers.reduce((function(merged,current){var existing=merged[current.name];return merged[current.name]=existing?Object.assign({},existing,current,{options:Object.assign({},existing.options,current.options),data:Object.assign({},existing.data,current.data)}):current,merged}),{});// IE11 does not support Object.values
return Object.keys(merged).map((function(key){return merged[key]}))}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS={placement:"bottom",modifiers:[],strategy:"absolute"};function areValidElements(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];return!args.some((function(element){return!(element&&"function"===typeof element.getBoundingClientRect)}))}function popperGenerator(generatorOptions){void 0===generatorOptions&&(generatorOptions={});var _generatorOptions=generatorOptions,_generatorOptions$def=_generatorOptions.defaultModifiers,defaultModifiers=void 0===_generatorOptions$def?[]:_generatorOptions$def,_generatorOptions$def2=_generatorOptions.defaultOptions,defaultOptions=void 0===_generatorOptions$def2?DEFAULT_OPTIONS:_generatorOptions$def2;return function(reference,popper,options){void 0===options&&(options=defaultOptions);var state={placement:"bottom",orderedModifiers:[],options:Object.assign({},DEFAULT_OPTIONS,defaultOptions),modifiersData:{},elements:{reference:reference,popper:popper},attributes:{},styles:{}},effectCleanupFns=[],isDestroyed=!1,instance={state:state,setOptions:function(setOptionsAction){var options="function"===typeof setOptionsAction?setOptionsAction(state.options):setOptionsAction;cleanupModifierEffects(),state.options=Object.assign({},defaultOptions,state.options,options),state.scrollParents={reference:(0,instanceOf/* isElement */.kK)(reference)?listScrollParents(reference):reference.contextElement?listScrollParents(reference.contextElement):[],popper:listScrollParents(popper)};// Orders the modifiers based on their dependencies and `phase`
// properties
var orderedModifiers=orderModifiers(mergeByName([].concat(defaultModifiers,state.options.modifiers)));// Strip out disabled modifiers
return state.orderedModifiers=orderedModifiers.filter((function(m){return m.enabled})),runModifierEffects(),instance.update()},
// Sync update – it will always be executed, even if not necessary. This
// is useful for low frequency updates where sync behavior simplifies the
// logic.
// For high frequency updates (e.g. `resize` and `scroll` events), always
// prefer the async Popper#update method
forceUpdate:function(){if(!isDestroyed){var _state$elements=state.elements,reference=_state$elements.reference,popper=_state$elements.popper;// Don't proceed if `reference` or `popper` are not valid elements
// anymore
if(areValidElements(reference,popper)){// Store the reference and popper rects to be read by modifiers
state.rects={reference:getCompositeRect(reference,getOffsetParent(popper),"fixed"===state.options.strategy),popper:getLayoutRect(popper)},// Modifiers have the ability to reset the current update cycle. The
// most common use case for this is the `flip` modifier changing the
// placement, which then needs to re-run all the modifiers, because the
// logic was previously ran for the previous placement and is therefore
// stale/incorrect
state.reset=!1,state.placement=state.options.placement,// On each update cycle, the `modifiersData` property for each modifier
// is filled with the initial data specified by the modifier. This means
// it doesn't persist and is fresh on each update.
// To ensure persistent data, use `${name}#persistent`
state.orderedModifiers.forEach((function(modifier){return state.modifiersData[modifier.name]=Object.assign({},modifier.data)}));for(var index=0;index<state.orderedModifiers.length;index++)if(!0!==state.reset){var _state$orderedModifie=state.orderedModifiers[index],fn=_state$orderedModifie.fn,_state$orderedModifie2=_state$orderedModifie.options,_options=void 0===_state$orderedModifie2?{}:_state$orderedModifie2,name=_state$orderedModifie.name;"function"===typeof fn&&(state=fn({state:state,options:_options,name:name,instance:instance})||state)}else state.reset=!1,index=-1}}},
// Async and optimistically optimized update – it will not be executed if
// not necessary (debounced to run at most once-per-tick)
update:debounce((function(){return new Promise((function(resolve){instance.forceUpdate(),resolve(state)}))})),destroy:function(){cleanupModifierEffects(),isDestroyed=!0}};if(!areValidElements(reference,popper))return instance;// Modifiers have the ability to execute arbitrary code before the first
// update cycle runs. They will be executed in the same order as the update
// cycle. This is useful when a modifier adds some persistent data that
// other modifiers need to use, but the modifier is run after the dependent
// one.
function runModifierEffects(){state.orderedModifiers.forEach((function(_ref){var name=_ref.name,_ref$options=_ref.options,options=void 0===_ref$options?{}:_ref$options,effect=_ref.effect;if("function"===typeof effect){var cleanupFn=effect({state:state,name:name,instance:instance,options:options}),noopFn=function(){};effectCleanupFns.push(cleanupFn||noopFn)}}))}function cleanupModifierEffects(){effectCleanupFns.forEach((function(fn){return fn()})),effectCleanupFns=[]}return instance.setOptions(options).then((function(state){!isDestroyed&&options.onFirstUpdate&&options.onFirstUpdate(state)})),instance}}var passive={passive:!0};// eslint-disable-next-line import/no-unused-modules
function effect(_ref){var state=_ref.state,instance=_ref.instance,options=_ref.options,_options$scroll=options.scroll,scroll=void 0===_options$scroll||_options$scroll,_options$resize=options.resize,resize=void 0===_options$resize||_options$resize,window=(0,getWindow/* default */.Z)(state.elements.popper),scrollParents=[].concat(state.scrollParents.reference,state.scrollParents.popper);return scroll&&scrollParents.forEach((function(scrollParent){scrollParent.addEventListener("scroll",instance.update,passive)})),resize&&window.addEventListener("resize",instance.update,passive),function(){scroll&&scrollParents.forEach((function(scrollParent){scrollParent.removeEventListener("scroll",instance.update,passive)})),resize&&window.removeEventListener("resize",instance.update,passive)}}// eslint-disable-next-line import/no-unused-modules
/* harmony default export */var eventListeners={name:"eventListeners",enabled:!0,phase:"write",fn:function(){},effect:effect,data:{}};// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement){return placement.split("-")[0]}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement){return placement.split("-")[1]}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement){return["top","bottom"].indexOf(placement)>=0?"x":"y"}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref){var offsets,reference=_ref.reference,element=_ref.element,placement=_ref.placement,basePlacement=placement?getBasePlacement(placement):null,variation=placement?getVariation(placement):null,commonX=reference.x+reference.width/2-element.width/2,commonY=reference.y+reference.height/2-element.height/2;switch(basePlacement){case enums_top:offsets={x:commonX,y:reference.y-element.height};break;case bottom:offsets={x:commonX,y:reference.y+reference.height};break;case right:offsets={x:reference.x+reference.width,y:commonY};break;case left:offsets={x:reference.x-element.width,y:commonY};break;default:offsets={x:reference.x,y:reference.y}}var mainAxis=basePlacement?getMainAxisFromPlacement(basePlacement):null;if(null!=mainAxis){var len="y"===mainAxis?"height":"width";switch(variation){case start:offsets[mainAxis]=offsets[mainAxis]-(reference[len]/2-element[len]/2);break;case end:offsets[mainAxis]=offsets[mainAxis]+(reference[len]/2-element[len]/2);break;default:}}return offsets}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref){var state=_ref.state,name=_ref.name;
// Offsets are the actual position the popper needs to have to be
// properly positioned near its reference element
// This is the most basic placement, and will be adjusted by
// the modifiers in the next step
state.modifiersData[name]=computeOffsets({reference:state.rects.reference,element:state.rects.popper,strategy:"absolute",placement:state.placement})}// eslint-disable-next-line import/no-unused-modules
/* harmony default export */var modifiers_popperOffsets={name:"popperOffsets",enabled:!0,phase:"read",fn:popperOffsets,data:{}},unsetSides={top:"auto",right:"auto",bottom:"auto",left:"auto"};// Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.
function roundOffsetsByDPR(_ref,win){var x=_ref.x,y=_ref.y,dpr=win.devicePixelRatio||1;return{x:round(x*dpr)/dpr||0,y:round(y*dpr)/dpr||0}}function mapToStyles(_ref2){var _Object$assign2,popper=_ref2.popper,popperRect=_ref2.popperRect,placement=_ref2.placement,variation=_ref2.variation,offsets=_ref2.offsets,position=_ref2.position,gpuAcceleration=_ref2.gpuAcceleration,adaptive=_ref2.adaptive,roundOffsets=_ref2.roundOffsets,isFixed=_ref2.isFixed,_offsets$x=offsets.x,x=void 0===_offsets$x?0:_offsets$x,_offsets$y=offsets.y,y=void 0===_offsets$y?0:_offsets$y,_ref3="function"===typeof roundOffsets?roundOffsets({x:x,y:y}):{x:x,y:y};x=_ref3.x,y=_ref3.y;var hasX=offsets.hasOwnProperty("x"),hasY=offsets.hasOwnProperty("y"),sideX=left,sideY=enums_top,win=window;if(adaptive){var offsetParent=getOffsetParent(popper),heightProp="clientHeight",widthProp="clientWidth";if(offsetParent===(0,getWindow/* default */.Z)(popper)&&(offsetParent=getDocumentElement(popper),"static"!==getComputedStyle(offsetParent).position&&"absolute"===position&&(heightProp="scrollHeight",widthProp="scrollWidth")),placement===enums_top||(placement===left||placement===right)&&variation===end){sideY=bottom;var offsetY=isFixed&&offsetParent===win&&win.visualViewport?win.visualViewport.height:// $FlowFixMe[prop-missing]
offsetParent[heightProp];y-=offsetY-popperRect.height,y*=gpuAcceleration?1:-1}if(placement===left||(placement===enums_top||placement===bottom)&&variation===end){sideX=right;var offsetX=isFixed&&offsetParent===win&&win.visualViewport?win.visualViewport.width:// $FlowFixMe[prop-missing]
offsetParent[widthProp];x-=offsetX-popperRect.width,x*=gpuAcceleration?1:-1}}var _Object$assign,commonStyles=Object.assign({position:position},adaptive&&unsetSides),_ref4=!0===roundOffsets?roundOffsetsByDPR({x:x,y:y},(0,getWindow/* default */.Z)(popper)):{x:x,y:y};return x=_ref4.x,y=_ref4.y,gpuAcceleration?Object.assign({},commonStyles,(_Object$assign={},_Object$assign[sideY]=hasY?"0":"",_Object$assign[sideX]=hasX?"0":"",_Object$assign.transform=(win.devicePixelRatio||1)<=1?"translate("+x+"px, "+y+"px)":"translate3d("+x+"px, "+y+"px, 0)",_Object$assign)):Object.assign({},commonStyles,(_Object$assign2={},_Object$assign2[sideY]=hasY?y+"px":"",_Object$assign2[sideX]=hasX?x+"px":"",_Object$assign2.transform="",_Object$assign2))}function computeStyles(_ref5){var state=_ref5.state,options=_ref5.options,_options$gpuAccelerat=options.gpuAcceleration,gpuAcceleration=void 0===_options$gpuAccelerat||_options$gpuAccelerat,_options$adaptive=options.adaptive,adaptive=void 0===_options$adaptive||_options$adaptive,_options$roundOffsets=options.roundOffsets,roundOffsets=void 0===_options$roundOffsets||_options$roundOffsets,commonStyles={placement:getBasePlacement(state.placement),variation:getVariation(state.placement),popper:state.elements.popper,popperRect:state.rects.popper,gpuAcceleration:gpuAcceleration,isFixed:"fixed"===state.options.strategy};null!=state.modifiersData.popperOffsets&&(state.styles.popper=Object.assign({},state.styles.popper,mapToStyles(Object.assign({},commonStyles,{offsets:state.modifiersData.popperOffsets,position:state.options.strategy,adaptive:adaptive,roundOffsets:roundOffsets})))),null!=state.modifiersData.arrow&&(state.styles.arrow=Object.assign({},state.styles.arrow,mapToStyles(Object.assign({},commonStyles,{offsets:state.modifiersData.arrow,position:"absolute",adaptive:!1,roundOffsets:roundOffsets})))),state.attributes.popper=Object.assign({},state.attributes.popper,{"data-popper-placement":state.placement})}// eslint-disable-next-line import/no-unused-modules
/* harmony default export */var modifiers_computeStyles={name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:computeStyles,data:{}},applyStyles=__webpack_require__(817824);
// EXTERNAL MODULE: ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js
// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/offset.js
// eslint-disable-next-line import/no-unused-modules
function distanceAndSkiddingToXY(placement,rects,offset){var basePlacement=getBasePlacement(placement),invertDistance=[left,enums_top].indexOf(basePlacement)>=0?-1:1,_ref="function"===typeof offset?offset(Object.assign({},rects,{placement:placement})):offset,skidding=_ref[0],distance=_ref[1];return skidding=skidding||0,distance=(distance||0)*invertDistance,[left,right].indexOf(basePlacement)>=0?{x:distance,y:skidding}:{x:skidding,y:distance}}function offset(_ref2){var state=_ref2.state,options=_ref2.options,name=_ref2.name,_options$offset=options.offset,offset=void 0===_options$offset?[0,0]:_options$offset,data=enums_placements.reduce((function(acc,placement){return acc[placement]=distanceAndSkiddingToXY(placement,state.rects,offset),acc}),{}),_data$state$placement=data[state.placement],x=_data$state$placement.x,y=_data$state$placement.y;null!=state.modifiersData.popperOffsets&&(state.modifiersData.popperOffsets.x+=x,state.modifiersData.popperOffsets.y+=y),state.modifiersData[name]=data}// eslint-disable-next-line import/no-unused-modules
/* harmony default export */var modifiers_offset={name:"offset",enabled:!0,phase:"main",requires:["popperOffsets"],fn:offset},hash={left:"right",right:"left",bottom:"top",top:"bottom"};function getOppositePlacement(placement){return placement.replace(/left|right|bottom|top/g,(function(matched){return hash[matched]}))}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var getOppositeVariationPlacement_hash={start:"end",end:"start"};function getOppositeVariationPlacement(placement){return placement.replace(/start|end/g,(function(matched){return getOppositeVariationPlacement_hash[matched]}))}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element,strategy){var win=(0,getWindow/* default */.Z)(element),html=getDocumentElement(element),visualViewport=win.visualViewport,width=html.clientWidth,height=html.clientHeight,x=0,y=0;if(visualViewport){width=visualViewport.width,height=visualViewport.height;var layoutViewport=isLayoutViewport();(layoutViewport||!layoutViewport&&"fixed"===strategy)&&(x=visualViewport.offsetLeft,y=visualViewport.offsetTop)}return{width:width,height:height,x:x+getWindowScrollBarX(element),y:y}}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable
function getDocumentRect(element){var _element$ownerDocumen,html=getDocumentElement(element),winScroll=getWindowScroll(element),body=null==(_element$ownerDocumen=element.ownerDocument)?void 0:_element$ownerDocumen.body,width=math_max(html.scrollWidth,html.clientWidth,body?body.scrollWidth:0,body?body.clientWidth:0),height=math_max(html.scrollHeight,html.clientHeight,body?body.scrollHeight:0,body?body.clientHeight:0),x=-winScroll.scrollLeft+getWindowScrollBarX(element),y=-winScroll.scrollTop;return"rtl"===getComputedStyle(body||html).direction&&(x+=math_max(html.clientWidth,body?body.clientWidth:0)-width),{width:width,height:height,x:x,y:y}}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent,child){var rootNode=child.getRootNode&&child.getRootNode();// First, attempt with faster native method
if(parent.contains(child))return!0;// Give up, the result is false
if(rootNode&&(0,instanceOf/* isShadowRoot */.Zq)(rootNode)){var next=child;do{if(next&&parent.isSameNode(next))return!0;// $FlowFixMe[prop-missing]: need a better way to handle this...
next=next.parentNode||next.host}while(next)}return!1}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect){return Object.assign({},rect,{left:rect.x,top:rect.y,right:rect.x+rect.width,bottom:rect.y+rect.height})}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element,strategy){var rect=getBoundingClientRect(element,!1,"fixed"===strategy);return rect.top=rect.top+element.clientTop,rect.left=rect.left+element.clientLeft,rect.bottom=rect.top+element.clientHeight,rect.right=rect.left+element.clientWidth,rect.width=element.clientWidth,rect.height=element.clientHeight,rect.x=rect.left,rect.y=rect.top,rect}function getClientRectFromMixedType(element,clippingParent,strategy){return clippingParent===viewport?rectToClientRect(getViewportRect(element,strategy)):(0,instanceOf/* isElement */.kK)(clippingParent)?getInnerBoundingClientRect(clippingParent,strategy):rectToClientRect(getDocumentRect(getDocumentElement(element)))}// A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`
function getClippingParents(element){var clippingParents=listScrollParents(getParentNode(element)),canEscapeClipping=["absolute","fixed"].indexOf(getComputedStyle(element).position)>=0,clipperElement=canEscapeClipping&&(0,instanceOf/* isHTMLElement */.Re)(element)?getOffsetParent(element):element;return(0,instanceOf/* isElement */.kK)(clipperElement)?clippingParents.filter((function(clippingParent){return(0,instanceOf/* isElement */.kK)(clippingParent)&&contains(clippingParent,clipperElement)&&"body"!==(0,getNodeName/* default */.Z)(clippingParent)})):[];// $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414
}// Gets the maximum area that the element is visible in due to any number of
// clipping parents
function getClippingRect(element,boundary,rootBoundary,strategy){var mainClippingParents="clippingParents"===boundary?getClippingParents(element):[].concat(boundary),clippingParents=[].concat(mainClippingParents,[rootBoundary]),firstClippingParent=clippingParents[0],clippingRect=clippingParents.reduce((function(accRect,clippingParent){var rect=getClientRectFromMixedType(element,clippingParent,strategy);return accRect.top=math_max(rect.top,accRect.top),accRect.right=math_min(rect.right,accRect.right),accRect.bottom=math_min(rect.bottom,accRect.bottom),accRect.left=math_max(rect.left,accRect.left),accRect}),getClientRectFromMixedType(element,firstClippingParent,strategy));return clippingRect.width=clippingRect.right-clippingRect.left,clippingRect.height=clippingRect.bottom-clippingRect.top,clippingRect.x=clippingRect.left,clippingRect.y=clippingRect.top,clippingRect}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject(){return{top:0,right:0,bottom:0,left:0}}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject){return Object.assign({},getFreshSideObject(),paddingObject)}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value,keys){return keys.reduce((function(hashMap,key){return hashMap[key]=value,hashMap}),{})}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/detectOverflow.js
// eslint-disable-next-line import/no-unused-modules
function detectOverflow(state,options){void 0===options&&(options={});var _options=options,_options$placement=_options.placement,placement=void 0===_options$placement?state.placement:_options$placement,_options$strategy=_options.strategy,strategy=void 0===_options$strategy?state.strategy:_options$strategy,_options$boundary=_options.boundary,boundary=void 0===_options$boundary?clippingParents:_options$boundary,_options$rootBoundary=_options.rootBoundary,rootBoundary=void 0===_options$rootBoundary?viewport:_options$rootBoundary,_options$elementConte=_options.elementContext,elementContext=void 0===_options$elementConte?popper:_options$elementConte,_options$altBoundary=_options.altBoundary,altBoundary=void 0!==_options$altBoundary&&_options$altBoundary,_options$padding=_options.padding,padding=void 0===_options$padding?0:_options$padding,paddingObject=mergePaddingObject("number"!==typeof padding?padding:expandToHashMap(padding,basePlacements)),altContext=elementContext===popper?reference:popper,popperRect=state.rects.popper,element=state.elements[altBoundary?altContext:elementContext],clippingClientRect=getClippingRect((0,instanceOf/* isElement */.kK)(element)?element:element.contextElement||getDocumentElement(state.elements.popper),boundary,rootBoundary,strategy),referenceClientRect=getBoundingClientRect(state.elements.reference),popperOffsets=computeOffsets({reference:referenceClientRect,element:popperRect,strategy:"absolute",placement:placement}),popperClientRect=rectToClientRect(Object.assign({},popperRect,popperOffsets)),elementClientRect=elementContext===popper?popperClientRect:referenceClientRect,overflowOffsets={top:clippingClientRect.top-elementClientRect.top+paddingObject.top,bottom:elementClientRect.bottom-clippingClientRect.bottom+paddingObject.bottom,left:clippingClientRect.left-elementClientRect.left+paddingObject.left,right:elementClientRect.right-clippingClientRect.right+paddingObject.right},offsetData=state.modifiersData.offset;// Offsets can be applied only to the popper element
if(elementContext===popper&&offsetData){var offset=offsetData[placement];Object.keys(overflowOffsets).forEach((function(key){var multiply=[right,bottom].indexOf(key)>=0?1:-1,axis=[enums_top,bottom].indexOf(key)>=0?"y":"x";overflowOffsets[key]+=offset[axis]*multiply}))}return overflowOffsets}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state,options){void 0===options&&(options={});var _options=options,placement=_options.placement,boundary=_options.boundary,rootBoundary=_options.rootBoundary,padding=_options.padding,flipVariations=_options.flipVariations,_options$allowedAutoP=_options.allowedAutoPlacements,allowedAutoPlacements=void 0===_options$allowedAutoP?enums_placements:_options$allowedAutoP,variation=getVariation(placement),placements=variation?flipVariations?variationPlacements:variationPlacements.filter((function(placement){return getVariation(placement)===variation})):basePlacements,allowedPlacements=placements.filter((function(placement){return allowedAutoPlacements.indexOf(placement)>=0}));0===allowedPlacements.length&&(allowedPlacements=placements);// $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...
var overflows=allowedPlacements.reduce((function(acc,placement){return acc[placement]=detectOverflow(state,{placement:placement,boundary:boundary,rootBoundary:rootBoundary,padding:padding})[getBasePlacement(placement)],acc}),{});return Object.keys(overflows).sort((function(a,b){return overflows[a]-overflows[b]}))}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/flip.js
// eslint-disable-next-line import/no-unused-modules
function getExpandedFallbackPlacements(placement){if(getBasePlacement(placement)===auto)return[];var oppositePlacement=getOppositePlacement(placement);return[getOppositeVariationPlacement(placement),oppositePlacement,getOppositeVariationPlacement(oppositePlacement)]}function flip(_ref){var state=_ref.state,options=_ref.options,name=_ref.name;if(!state.modifiersData[name]._skip){for(var _options$mainAxis=options.mainAxis,checkMainAxis=void 0===_options$mainAxis||_options$mainAxis,_options$altAxis=options.altAxis,checkAltAxis=void 0===_options$altAxis||_options$altAxis,specifiedFallbackPlacements=options.fallbackPlacements,padding=options.padding,boundary=options.boundary,rootBoundary=options.rootBoundary,altBoundary=options.altBoundary,_options$flipVariatio=options.flipVariations,flipVariations=void 0===_options$flipVariatio||_options$flipVariatio,allowedAutoPlacements=options.allowedAutoPlacements,preferredPlacement=state.options.placement,basePlacement=getBasePlacement(preferredPlacement),isBasePlacement=basePlacement===preferredPlacement,fallbackPlacements=specifiedFallbackPlacements||(isBasePlacement||!flipVariations?[getOppositePlacement(preferredPlacement)]:getExpandedFallbackPlacements(preferredPlacement)),placements=[preferredPlacement].concat(fallbackPlacements).reduce((function(acc,placement){return acc.concat(getBasePlacement(placement)===auto?computeAutoPlacement(state,{placement:placement,boundary:boundary,rootBoundary:rootBoundary,padding:padding,flipVariations:flipVariations,allowedAutoPlacements:allowedAutoPlacements}):placement)}),[]),referenceRect=state.rects.reference,popperRect=state.rects.popper,checksMap=new Map,makeFallbackChecks=!0,firstFittingPlacement=placements[0],i=0;i<placements.length;i++){var placement=placements[i],_basePlacement=getBasePlacement(placement),isStartVariation=getVariation(placement)===start,isVertical=[enums_top,bottom].indexOf(_basePlacement)>=0,len=isVertical?"width":"height",overflow=detectOverflow(state,{placement:placement,boundary:boundary,rootBoundary:rootBoundary,altBoundary:altBoundary,padding:padding}),mainVariationSide=isVertical?isStartVariation?right:left:isStartVariation?bottom:enums_top;referenceRect[len]>popperRect[len]&&(mainVariationSide=getOppositePlacement(mainVariationSide));var altVariationSide=getOppositePlacement(mainVariationSide),checks=[];if(checkMainAxis&&checks.push(overflow[_basePlacement]<=0),checkAltAxis&&checks.push(overflow[mainVariationSide]<=0,overflow[altVariationSide]<=0),checks.every((function(check){return check}))){firstFittingPlacement=placement,makeFallbackChecks=!1;break}checksMap.set(placement,checks)}if(makeFallbackChecks)for(
// `2` may be desired in some cases – research later
var numberOfChecks=flipVariations?3:1,_loop=function(_i){var fittingPlacement=placements.find((function(placement){var checks=checksMap.get(placement);if(checks)return checks.slice(0,_i).every((function(check){return check}))}));if(fittingPlacement)return firstFittingPlacement=fittingPlacement,"break"},_i=numberOfChecks;_i>0;_i--){var _ret=_loop(_i);if("break"===_ret)break}state.placement!==firstFittingPlacement&&(state.modifiersData[name]._skip=!0,state.placement=firstFittingPlacement,state.reset=!0)}}// eslint-disable-next-line import/no-unused-modules
/* harmony default export */var modifiers_flip={name:"flip",enabled:!0,phase:"main",fn:flip,requiresIfExists:["offset"],data:{_skip:!1}};// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis){return"x"===axis?"y":"x"}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/within.js
function within(min,value,max){return math_max(min,math_min(value,max))}function withinMaxClamp(min,value,max){var v=within(min,value,max);return v>max?max:v}// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref){var state=_ref.state,options=_ref.options,name=_ref.name,_options$mainAxis=options.mainAxis,checkMainAxis=void 0===_options$mainAxis||_options$mainAxis,_options$altAxis=options.altAxis,checkAltAxis=void 0!==_options$altAxis&&_options$altAxis,boundary=options.boundary,rootBoundary=options.rootBoundary,altBoundary=options.altBoundary,padding=options.padding,_options$tether=options.tether,tether=void 0===_options$tether||_options$tether,_options$tetherOffset=options.tetherOffset,tetherOffset=void 0===_options$tetherOffset?0:_options$tetherOffset,overflow=detectOverflow(state,{boundary:boundary,rootBoundary:rootBoundary,padding:padding,altBoundary:altBoundary}),basePlacement=getBasePlacement(state.placement),variation=getVariation(state.placement),isBasePlacement=!variation,mainAxis=getMainAxisFromPlacement(basePlacement),altAxis=getAltAxis(mainAxis),popperOffsets=state.modifiersData.popperOffsets,referenceRect=state.rects.reference,popperRect=state.rects.popper,tetherOffsetValue="function"===typeof tetherOffset?tetherOffset(Object.assign({},state.rects,{placement:state.placement})):tetherOffset,normalizedTetherOffsetValue="number"===typeof tetherOffsetValue?{mainAxis:tetherOffsetValue,altAxis:tetherOffsetValue}:Object.assign({mainAxis:0,altAxis:0},tetherOffsetValue),offsetModifierState=state.modifiersData.offset?state.modifiersData.offset[state.placement]:null,data={x:0,y:0};if(popperOffsets){if(checkMainAxis){var _offsetModifierState$,mainSide="y"===mainAxis?enums_top:left,altSide="y"===mainAxis?bottom:right,len="y"===mainAxis?"height":"width",offset=popperOffsets[mainAxis],min=offset+overflow[mainSide],max=offset-overflow[altSide],additive=tether?-popperRect[len]/2:0,minLen=variation===start?referenceRect[len]:popperRect[len],maxLen=variation===start?-popperRect[len]:-referenceRect[len],arrowElement=state.elements.arrow,arrowRect=tether&&arrowElement?getLayoutRect(arrowElement):{width:0,height:0},arrowPaddingObject=state.modifiersData["arrow#persistent"]?state.modifiersData["arrow#persistent"].padding:getFreshSideObject(),arrowPaddingMin=arrowPaddingObject[mainSide],arrowPaddingMax=arrowPaddingObject[altSide],arrowLen=within(0,referenceRect[len],arrowRect[len]),minOffset=isBasePlacement?referenceRect[len]/2-additive-arrowLen-arrowPaddingMin-normalizedTetherOffsetValue.mainAxis:minLen-arrowLen-arrowPaddingMin-normalizedTetherOffsetValue.mainAxis,maxOffset=isBasePlacement?-referenceRect[len]/2+additive+arrowLen+arrowPaddingMax+normalizedTetherOffsetValue.mainAxis:maxLen+arrowLen+arrowPaddingMax+normalizedTetherOffsetValue.mainAxis,arrowOffsetParent=state.elements.arrow&&getOffsetParent(state.elements.arrow),clientOffset=arrowOffsetParent?"y"===mainAxis?arrowOffsetParent.clientTop||0:arrowOffsetParent.clientLeft||0:0,offsetModifierValue=null!=(_offsetModifierState$=null==offsetModifierState?void 0:offsetModifierState[mainAxis])?_offsetModifierState$:0,tetherMin=offset+minOffset-offsetModifierValue-clientOffset,tetherMax=offset+maxOffset-offsetModifierValue,preventedOffset=within(tether?math_min(min,tetherMin):min,offset,tether?math_max(max,tetherMax):max);popperOffsets[mainAxis]=preventedOffset,data[mainAxis]=preventedOffset-offset}if(checkAltAxis){var _offsetModifierState$2,_mainSide="x"===mainAxis?enums_top:left,_altSide="x"===mainAxis?bottom:right,_offset=popperOffsets[altAxis],_len="y"===altAxis?"height":"width",_min=_offset+overflow[_mainSide],_max=_offset-overflow[_altSide],isOriginSide=-1!==[enums_top,left].indexOf(basePlacement),_offsetModifierValue=null!=(_offsetModifierState$2=null==offsetModifierState?void 0:offsetModifierState[altAxis])?_offsetModifierState$2:0,_tetherMin=isOriginSide?_min:_offset-referenceRect[_len]-popperRect[_len]-_offsetModifierValue+normalizedTetherOffsetValue.altAxis,_tetherMax=isOriginSide?_offset+referenceRect[_len]+popperRect[_len]-_offsetModifierValue-normalizedTetherOffsetValue.altAxis:_max,_preventedOffset=tether&&isOriginSide?withinMaxClamp(_tetherMin,_offset,_tetherMax):within(tether?_tetherMin:_min,_offset,tether?_tetherMax:_max);popperOffsets[altAxis]=_preventedOffset,data[altAxis]=_preventedOffset-_offset}state.modifiersData[name]=data}}// eslint-disable-next-line import/no-unused-modules
/* harmony default export */var modifiers_preventOverflow={name:"preventOverflow",enabled:!0,phase:"main",fn:preventOverflow,requiresIfExists:["offset"]},toPaddingObject=function(padding,state){return padding="function"===typeof padding?padding(Object.assign({},state.rects,{placement:state.placement})):padding,mergePaddingObject("number"!==typeof padding?padding:expandToHashMap(padding,basePlacements))};function arrow(_ref){var _state$modifiersData$,state=_ref.state,name=_ref.name,options=_ref.options,arrowElement=state.elements.arrow,popperOffsets=state.modifiersData.popperOffsets,basePlacement=getBasePlacement(state.placement),axis=getMainAxisFromPlacement(basePlacement),isVertical=[left,right].indexOf(basePlacement)>=0,len=isVertical?"height":"width";if(arrowElement&&popperOffsets){var paddingObject=toPaddingObject(options.padding,state),arrowRect=getLayoutRect(arrowElement),minProp="y"===axis?enums_top:left,maxProp="y"===axis?bottom:right,endDiff=state.rects.reference[len]+state.rects.reference[axis]-popperOffsets[axis]-state.rects.popper[len],startDiff=popperOffsets[axis]-state.rects.reference[axis],arrowOffsetParent=getOffsetParent(arrowElement),clientSize=arrowOffsetParent?"y"===axis?arrowOffsetParent.clientHeight||0:arrowOffsetParent.clientWidth||0:0,centerToReference=endDiff/2-startDiff/2,min=paddingObject[minProp],max=clientSize-arrowRect[len]-paddingObject[maxProp],center=clientSize/2-arrowRect[len]/2+centerToReference,offset=within(min,center,max),axisProp=axis;state.modifiersData[name]=(_state$modifiersData$={},_state$modifiersData$[axisProp]=offset,_state$modifiersData$.centerOffset=offset-center,_state$modifiersData$)}}function arrow_effect(_ref2){var state=_ref2.state,options=_ref2.options,_options$element=options.element,arrowElement=void 0===_options$element?"[data-popper-arrow]":_options$element;null!=arrowElement&&("string"!==typeof arrowElement||(arrowElement=state.elements.popper.querySelector(arrowElement),arrowElement))&&contains(state.elements.popper,arrowElement)&&(state.elements.arrow=arrowElement);// CSS selector
}// eslint-disable-next-line import/no-unused-modules
/* harmony default export */var modifiers_arrow={name:"arrow",enabled:!0,phase:"main",fn:arrow,effect:arrow_effect,requires:["popperOffsets"],requiresIfExists:["preventOverflow"]};// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow,rect,preventedOffsets){return void 0===preventedOffsets&&(preventedOffsets={x:0,y:0}),{top:overflow.top-rect.height-preventedOffsets.y,right:overflow.right-rect.width+preventedOffsets.x,bottom:overflow.bottom-rect.height+preventedOffsets.y,left:overflow.left-rect.width-preventedOffsets.x}}function isAnySideFullyClipped(overflow){return[enums_top,right,bottom,left].some((function(side){return overflow[side]>=0}))}function hide(_ref){var state=_ref.state,name=_ref.name,referenceRect=state.rects.reference,popperRect=state.rects.popper,preventedOffsets=state.modifiersData.preventOverflow,referenceOverflow=detectOverflow(state,{elementContext:"reference"}),popperAltOverflow=detectOverflow(state,{altBoundary:!0}),referenceClippingOffsets=getSideOffsets(referenceOverflow,referenceRect),popperEscapeOffsets=getSideOffsets(popperAltOverflow,popperRect,preventedOffsets),isReferenceHidden=isAnySideFullyClipped(referenceClippingOffsets),hasPopperEscaped=isAnySideFullyClipped(popperEscapeOffsets);state.modifiersData[name]={referenceClippingOffsets:referenceClippingOffsets,popperEscapeOffsets:popperEscapeOffsets,isReferenceHidden:isReferenceHidden,hasPopperEscaped:hasPopperEscaped},state.attributes.popper=Object.assign({},state.attributes.popper,{"data-popper-reference-hidden":isReferenceHidden,"data-popper-escaped":hasPopperEscaped})}// eslint-disable-next-line import/no-unused-modules
/* harmony default export */var modifiers_hide={name:"hide",enabled:!0,phase:"main",requiresIfExists:["preventOverflow"],fn:hide},defaultModifiers=[eventListeners,modifiers_popperOffsets,modifiers_computeStyles,applyStyles/* default */.Z,modifiers_offset,modifiers_flip,modifiers_preventOverflow,modifiers_arrow,modifiers_hide],popper_createPopper=popperGenerator({defaultModifiers:defaultModifiers})},
/***/928981:
/***/function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__);
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser="undefined"!==typeof window&&"undefined"!==typeof document&&"undefined"!==typeof navigator,timeoutDuration=function(){for(var longerTimeoutBrowsers=["Edge","Trident","Firefox"],i=0;i<longerTimeoutBrowsers.length;i+=1)if(isBrowser&&navigator.userAgent.indexOf(longerTimeoutBrowsers[i])>=0)return 1;return 0}();function microtaskDebounce(fn){var called=!1;return function(){called||(called=!0,window.Promise.resolve().then((function(){called=!1,fn()})))}}function taskDebounce(fn){var scheduled=!1;return function(){scheduled||(scheduled=!0,setTimeout((function(){scheduled=!1,fn()}),timeoutDuration))}}var supportsMicroTasks=isBrowser&&window.Promise,debounce=supportsMicroTasks?microtaskDebounce:taskDebounce;
/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck){var getType={};return functionToCheck&&"[object Function]"===getType.toString.call(functionToCheck)}
/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */function getStyleComputedProperty(element,property){if(1!==element.nodeType)return[];
// NOTE: 1 DOM access here
var window=element.ownerDocument.defaultView,css=window.getComputedStyle(element,null);return property?css[property]:css}
/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */function getParentNode(element){return"HTML"===element.nodeName?element:element.parentNode||element.host}
/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */function getScrollParent(element){
// Return body, `getScroll` will take care to get the correct `scrollTop` from it
if(!element)return document.body;switch(element.nodeName){case"HTML":case"BODY":return element.ownerDocument.body;case"#document":return element.body}
// Firefox want us to check `-x` and `-y` variations as well
var _getStyleComputedProp=getStyleComputedProperty(element),overflow=_getStyleComputedProp.overflow,overflowX=_getStyleComputedProp.overflowX,overflowY=_getStyleComputedProp.overflowY;return/(auto|scroll|overlay)/.test(overflow+overflowY+overflowX)?element:getScrollParent(getParentNode(element))}
/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */function getReferenceNode(reference){return reference&&reference.referenceNode?reference.referenceNode:reference}var isIE11=isBrowser&&!(!window.MSInputMethodContext||!document.documentMode),isIE10=isBrowser&&/MSIE 10/.test(navigator.userAgent);
/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version){return 11===version?isIE11:10===version?isIE10:isIE11||isIE10}
/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */function getOffsetParent(element){if(!element)return document.documentElement;var noOffsetParent=isIE(10)?document.body:null,offsetParent=element.offsetParent||null;
// NOTE: 1 DOM access here
// Skip hidden elements which don't have an offsetParent
while(offsetParent===noOffsetParent&&element.nextElementSibling)offsetParent=(element=element.nextElementSibling).offsetParent;var nodeName=offsetParent&&offsetParent.nodeName;return nodeName&&"BODY"!==nodeName&&"HTML"!==nodeName?
// .offsetParent will return the closest TH, TD or TABLE in case
// no offsetParent is present, I hate this job...
-1!==["TH","TD","TABLE"].indexOf(offsetParent.nodeName)&&"static"===getStyleComputedProperty(offsetParent,"position")?getOffsetParent(offsetParent):offsetParent:element?element.ownerDocument.documentElement:document.documentElement}function isOffsetContainer(element){var nodeName=element.nodeName;return"BODY"!==nodeName&&("HTML"===nodeName||getOffsetParent(element.firstElementChild)===element)}
/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */function getRoot(node){return null!==node.parentNode?getRoot(node.parentNode):node}
/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */function findCommonOffsetParent(element1,element2){
// This check is needed to avoid errors in case one of the elements isn't defined for any reason
if(!element1||!element1.nodeType||!element2||!element2.nodeType)return document.documentElement;
// Here we make sure to give as "start" the element that comes first in the DOM
var order=element1.compareDocumentPosition(element2)&Node.DOCUMENT_POSITION_FOLLOWING,start=order?element1:element2,end=order?element2:element1,range=document.createRange();range.setStart(start,0),range.setEnd(end,0);var commonAncestorContainer=range.commonAncestorContainer;
// Both nodes are inside #document
if(element1!==commonAncestorContainer&&element2!==commonAncestorContainer||start.contains(end))return isOffsetContainer(commonAncestorContainer)?commonAncestorContainer:getOffsetParent(commonAncestorContainer);
// one of the nodes is inside shadowDOM, find which one
var element1root=getRoot(element1);return element1root.host?findCommonOffsetParent(element1root.host,element2):findCommonOffsetParent(element1,getRoot(element2).host)}
/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */function getScroll(element){var side=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"top",upperSide="top"===side?"scrollTop":"scrollLeft",nodeName=element.nodeName;if("BODY"===nodeName||"HTML"===nodeName){var html=element.ownerDocument.documentElement,scrollingElement=element.ownerDocument.scrollingElement||html;return scrollingElement[upperSide]}return element[upperSide]}
/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */function includeScroll(rect,element){var subtract=arguments.length>2&&void 0!==arguments[2]&&arguments[2],scrollTop=getScroll(element,"top"),scrollLeft=getScroll(element,"left"),modifier=subtract?-1:1;return rect.top+=scrollTop*modifier,rect.bottom+=scrollTop*modifier,rect.left+=scrollLeft*modifier,rect.right+=scrollLeft*modifier,rect}
/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */function getBordersSize(styles,axis){var sideA="x"===axis?"Left":"Top",sideB="Left"===sideA?"Right":"Bottom";return parseFloat(styles["border"+sideA+"Width"])+parseFloat(styles["border"+sideB+"Width"])}function getSize(axis,body,html,computedStyle){return Math.max(body["offset"+axis],body["scroll"+axis],html["client"+axis],html["offset"+axis],html["scroll"+axis],isIE(10)?parseInt(html["offset"+axis])+parseInt(computedStyle["margin"+("Height"===axis?"Top":"Left")])+parseInt(computedStyle["margin"+("Height"===axis?"Bottom":"Right")]):0)}function getWindowSizes(document){var body=document.body,html=document.documentElement,computedStyle=isIE(10)&&getComputedStyle(html);return{height:getSize("Height",body,html,computedStyle),width:getSize("Width",body,html,computedStyle)}}var classCallCheck=function(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")},createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),defineProperty=function(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj},_extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target};
/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets){return _extends({},offsets,{right:offsets.left+offsets.width,bottom:offsets.top+offsets.height})}
/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */function getBoundingClientRect(element){var rect={};
// IE10 10 FIX: Please, don't ask, the element isn't
// considered in DOM in some circumstances...
// This isn't reproducible in IE10 compatibility mode of IE11
try{if(isIE(10)){rect=element.getBoundingClientRect();var scrollTop=getScroll(element,"top"),scrollLeft=getScroll(element,"left");rect.top+=scrollTop,rect.left+=scrollLeft,rect.bottom+=scrollTop,rect.right+=scrollLeft}else rect=element.getBoundingClientRect()}catch(e){}var result={left:rect.left,top:rect.top,width:rect.right-rect.left,height:rect.bottom-rect.top},sizes="HTML"===element.nodeName?getWindowSizes(element.ownerDocument):{},width=sizes.width||element.clientWidth||result.width,height=sizes.height||element.clientHeight||result.height,horizScrollbar=element.offsetWidth-width,vertScrollbar=element.offsetHeight-height;
// subtract scrollbar size from sizes
// if an hypothetical scrollbar is detected, we must be sure it's not a `border`
// we make this check conditional for performance reasons
if(horizScrollbar||vertScrollbar){var styles=getStyleComputedProperty(element);horizScrollbar-=getBordersSize(styles,"x"),vertScrollbar-=getBordersSize(styles,"y"),result.width-=horizScrollbar,result.height-=vertScrollbar}return getClientRect(result)}function getOffsetRectRelativeToArbitraryNode(children,parent){var fixedPosition=arguments.length>2&&void 0!==arguments[2]&&arguments[2],isIE10=isIE(10),isHTML="HTML"===parent.nodeName,childrenRect=getBoundingClientRect(children),parentRect=getBoundingClientRect(parent),scrollParent=getScrollParent(children),styles=getStyleComputedProperty(parent),borderTopWidth=parseFloat(styles.borderTopWidth),borderLeftWidth=parseFloat(styles.borderLeftWidth);
// In cases where the parent is fixed, we must ignore negative scroll in offset calc
fixedPosition&&isHTML&&(parentRect.top=Math.max(parentRect.top,0),parentRect.left=Math.max(parentRect.left,0));var offsets=getClientRect({top:childrenRect.top-parentRect.top-borderTopWidth,left:childrenRect.left-parentRect.left-borderLeftWidth,width:childrenRect.width,height:childrenRect.height});
// Subtract margins of documentElement in case it's being used as parent
// we do this only on HTML because it's the only element that behaves
// differently when margins are applied to it. The margins are included in
// the box of the documentElement, in the other cases not.
if(offsets.marginTop=0,offsets.marginLeft=0,!isIE10&&isHTML){var marginTop=parseFloat(styles.marginTop),marginLeft=parseFloat(styles.marginLeft);offsets.top-=borderTopWidth-marginTop,offsets.bottom-=borderTopWidth-marginTop,offsets.left-=borderLeftWidth-marginLeft,offsets.right-=borderLeftWidth-marginLeft,
// Attach marginTop and marginLeft because in some circumstances we may need them
offsets.marginTop=marginTop,offsets.marginLeft=marginLeft}return(isIE10&&!fixedPosition?parent.contains(scrollParent):parent===scrollParent&&"BODY"!==scrollParent.nodeName)&&(offsets=includeScroll(offsets,parent)),offsets}function getViewportOffsetRectRelativeToArtbitraryNode(element){var excludeScroll=arguments.length>1&&void 0!==arguments[1]&&arguments[1],html=element.ownerDocument.documentElement,relativeOffset=getOffsetRectRelativeToArbitraryNode(element,html),width=Math.max(html.clientWidth,window.innerWidth||0),height=Math.max(html.clientHeight,window.innerHeight||0),scrollTop=excludeScroll?0:getScroll(html),scrollLeft=excludeScroll?0:getScroll(html,"left"),offset={top:scrollTop-relativeOffset.top+relativeOffset.marginTop,left:scrollLeft-relativeOffset.left+relativeOffset.marginLeft,width:width,height:height};return getClientRect(offset)}
/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */function isFixed(element){var nodeName=element.nodeName;if("BODY"===nodeName||"HTML"===nodeName)return!1;if("fixed"===getStyleComputedProperty(element,"position"))return!0;var parentNode=getParentNode(element);return!!parentNode&&isFixed(parentNode)}
/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */function getFixedPositionOffsetParent(element){
// This check is needed to avoid errors in case one of the elements isn't defined for any reason
if(!element||!element.parentElement||isIE())return document.documentElement;var el=element.parentElement;while(el&&"none"===getStyleComputedProperty(el,"transform"))el=el.parentElement;return el||document.documentElement}
/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */function getBoundaries(popper,reference,padding,boundariesElement){var fixedPosition=arguments.length>4&&void 0!==arguments[4]&&arguments[4],boundaries={top:0,left:0},offsetParent=fixedPosition?getFixedPositionOffsetParent(popper):findCommonOffsetParent(popper,getReferenceNode(reference));
// NOTE: 1 DOM access here
// Handle viewport case
if("viewport"===boundariesElement)boundaries=getViewportOffsetRectRelativeToArtbitraryNode(offsetParent,fixedPosition);else{
// Handle other cases based on DOM element used as boundaries
var boundariesNode=void 0;"scrollParent"===boundariesElement?(boundariesNode=getScrollParent(getParentNode(reference)),"BODY"===boundariesNode.nodeName&&(boundariesNode=popper.ownerDocument.documentElement)):boundariesNode="window"===boundariesElement?popper.ownerDocument.documentElement:boundariesElement;var offsets=getOffsetRectRelativeToArbitraryNode(boundariesNode,offsetParent,fixedPosition);
// In case of HTML, we need a different computation
if("HTML"!==boundariesNode.nodeName||isFixed(offsetParent))
// for all the other DOM elements, this one is good
boundaries=offsets;else{var _getWindowSizes=getWindowSizes(popper.ownerDocument),height=_getWindowSizes.height,width=_getWindowSizes.width;boundaries.top+=offsets.top-offsets.marginTop,boundaries.bottom=height+offsets.top,boundaries.left+=offsets.left-offsets.marginLeft,boundaries.right=width+offsets.left}}
// Add paddings
padding=padding||0;var isPaddingNumber="number"===typeof padding;return boundaries.left+=isPaddingNumber?padding:padding.left||0,boundaries.top+=isPaddingNumber?padding:padding.top||0,boundaries.right-=isPaddingNumber?padding:padding.right||0,boundaries.bottom-=isPaddingNumber?padding:padding.bottom||0,boundaries}function getArea(_ref){var width=_ref.width,height=_ref.height;return width*height}
/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function computeAutoPlacement(placement,refRect,popper,reference,boundariesElement){var padding=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(-1===placement.indexOf("auto"))return placement;var boundaries=getBoundaries(popper,reference,padding,boundariesElement),rects={top:{width:boundaries.width,height:refRect.top-boundaries.top},right:{width:boundaries.right-refRect.right,height:boundaries.height},bottom:{width:boundaries.width,height:boundaries.bottom-refRect.bottom},left:{width:refRect.left-boundaries.left,height:boundaries.height}},sortedAreas=Object.keys(rects).map((function(key){return _extends({key:key},rects[key],{area:getArea(rects[key])})})).sort((function(a,b){return b.area-a.area})),filteredAreas=sortedAreas.filter((function(_ref2){var width=_ref2.width,height=_ref2.height;return width>=popper.clientWidth&&height>=popper.clientHeight})),computedPlacement=filteredAreas.length>0?filteredAreas[0].key:sortedAreas[0].key,variation=placement.split("-")[1];return computedPlacement+(variation?"-"+variation:"")}
/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */function getReferenceOffsets(state,popper,reference){var fixedPosition=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,commonOffsetParent=fixedPosition?getFixedPositionOffsetParent(popper):findCommonOffsetParent(popper,getReferenceNode(reference));return getOffsetRectRelativeToArbitraryNode(reference,commonOffsetParent,fixedPosition)}
/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */function getOuterSizes(element){var window=element.ownerDocument.defaultView,styles=window.getComputedStyle(element),x=parseFloat(styles.marginTop||0)+parseFloat(styles.marginBottom||0),y=parseFloat(styles.marginLeft||0)+parseFloat(styles.marginRight||0),result={width:element.offsetWidth+y,height:element.offsetHeight+x};return result}
/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */function getOppositePlacement(placement){var hash={left:"right",right:"left",bottom:"top",top:"bottom"};return placement.replace(/left|right|bottom|top/g,(function(matched){return hash[matched]}))}
/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */function getPopperOffsets(popper,referenceOffsets,placement){placement=placement.split("-")[0];
// Get popper node sizes
var popperRect=getOuterSizes(popper),popperOffsets={width:popperRect.width,height:popperRect.height},isHoriz=-1!==["right","left"].indexOf(placement),mainSide=isHoriz?"top":"left",secondarySide=isHoriz?"left":"top",measurement=isHoriz?"height":"width",secondaryMeasurement=isHoriz?"width":"height";
// Add position, width and height to our offsets object
return popperOffsets[mainSide]=referenceOffsets[mainSide]+referenceOffsets[measurement]/2-popperRect[measurement]/2,popperOffsets[secondarySide]=placement===secondarySide?referenceOffsets[secondarySide]-popperRect[secondaryMeasurement]:referenceOffsets[getOppositePlacement(secondarySide)],popperOffsets}
/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */function find(arr,check){
// use native find if supported
return Array.prototype.find?arr.find(check):arr.filter(check)[0];
// use `filter` to obtain the same behavior of `find`
}
/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */function findIndex(arr,prop,value){
// use native findIndex if supported
if(Array.prototype.findIndex)return arr.findIndex((function(cur){return cur[prop]===value}));
// use `find` + `indexOf` if `findIndex` isn't supported
var match=find(arr,(function(obj){return obj[prop]===value}));return arr.indexOf(match)}
/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */function runModifiers(modifiers,data,ends){var modifiersToRun=void 0===ends?modifiers:modifiers.slice(0,findIndex(modifiers,"name",ends));return modifiersToRun.forEach((function(modifier){modifier["function"];var fn=modifier["function"]||modifier.fn;// eslint-disable-line dot-notation
modifier.enabled&&isFunction(fn)&&(
// Add properties to offsets to make them a complete clientRect object
// we do this before each modifier to make sure the previous one doesn't
// mess with these values
data.offsets.popper=getClientRect(data.offsets.popper),data.offsets.reference=getClientRect(data.offsets.reference),data=fn(data,modifier))})),data}
/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */function update(){
// if popper is destroyed, don't perform any further update
if(!this.state.isDestroyed){var data={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};
// compute reference element offsets
data.offsets.reference=getReferenceOffsets(this.state,this.popper,this.reference,this.options.positionFixed),
// compute auto placement, store placement inside the data object,
// modifiers will be able to edit `placement` if needed
// and refer to originalPlacement to know the original value
data.placement=computeAutoPlacement(this.options.placement,data.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),
// store the computed placement inside `originalPlacement`
data.originalPlacement=data.placement,data.positionFixed=this.options.positionFixed,
// compute the popper offsets
data.offsets.popper=getPopperOffsets(this.popper,data.offsets.reference,data.placement),data.offsets.popper.position=this.options.positionFixed?"fixed":"absolute",
// run the modifiers
data=runModifiers(this.modifiers,data),
// the first `update` will call `onCreate` callback
// the other ones will call `onUpdate` callback
this.state.isCreated?this.options.onUpdate(data):(this.state.isCreated=!0,this.options.onCreate(data))}}
/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */function isModifierEnabled(modifiers,modifierName){return modifiers.some((function(_ref){var name=_ref.name,enabled=_ref.enabled;return enabled&&name===modifierName}))}
/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */function getSupportedPropertyName(property){for(var prefixes=[!1,"ms","Webkit","Moz","O"],upperProp=property.charAt(0).toUpperCase()+property.slice(1),i=0;i<prefixes.length;i++){var prefix=prefixes[i],toCheck=prefix?""+prefix+upperProp:property;if("undefined"!==typeof document.body.style[toCheck])return toCheck}return null}
/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */function destroy(){return this.state.isDestroyed=!0,
// touch DOM only if `applyStyle` modifier is enabled
isModifierEnabled(this.modifiers,"applyStyle")&&(this.popper.removeAttribute("x-placement"),this.popper.style.position="",this.popper.style.top="",this.popper.style.left="",this.popper.style.right="",this.popper.style.bottom="",this.popper.style.willChange="",this.popper.style[getSupportedPropertyName("transform")]=""),this.disableEventListeners(),
// remove the popper if user explicitly asked for the deletion on destroy
// do not use `remove` because IE11 doesn't support it
this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}
/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */function getWindow(element){var ownerDocument=element.ownerDocument;return ownerDocument?ownerDocument.defaultView:window}function attachToScrollParents(scrollParent,event,callback,scrollParents){var isBody="BODY"===scrollParent.nodeName,target=isBody?scrollParent.ownerDocument.defaultView:scrollParent;target.addEventListener(event,callback,{passive:!0}),isBody||attachToScrollParents(getScrollParent(target.parentNode),event,callback,scrollParents),scrollParents.push(target)}
/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */function setupEventListeners(reference,options,state,updateBound){
// Resize event listener on window
state.updateBound=updateBound,getWindow(reference).addEventListener("resize",state.updateBound,{passive:!0});
// Scroll event listener on scroll parents
var scrollElement=getScrollParent(reference);return attachToScrollParents(scrollElement,"scroll",state.updateBound,state.scrollParents),state.scrollElement=scrollElement,state.eventsEnabled=!0,state}
/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */function enableEventListeners(){this.state.eventsEnabled||(this.state=setupEventListeners(this.reference,this.options,this.state,this.scheduleUpdate))}
/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */function removeEventListeners(reference,state){
// Remove resize event listener on window
return getWindow(reference).removeEventListener("resize",state.updateBound),
// Remove scroll event listener on scroll parents
state.scrollParents.forEach((function(target){target.removeEventListener("scroll",state.updateBound)})),
// Reset state
state.updateBound=null,state.scrollParents=[],state.scrollElement=null,state.eventsEnabled=!1,state}
/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */function disableEventListeners(){this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=removeEventListeners(this.reference,this.state))}
/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */function isNumeric(n){return""!==n&&!isNaN(parseFloat(n))&&isFinite(n)}
/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */function setStyles(element,styles){Object.keys(styles).forEach((function(prop){var unit="";
// add unit if the value is numeric and is one of the following
-1!==["width","height","top","right","bottom","left"].indexOf(prop)&&isNumeric(styles[prop])&&(unit="px"),element.style[prop]=styles[prop]+unit}))}
/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */function setAttributes(element,attributes){Object.keys(attributes).forEach((function(prop){var value=attributes[prop];!1!==value?element.setAttribute(prop,attributes[prop]):element.removeAttribute(prop)}))}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */function applyStyle(data){
// any property present in `data.styles` will be applied to the popper,
// in this way we can make the 3rd party modifiers add custom styles to it
// Be aware, modifiers could override the properties defined in the previous
// lines of this modifier!
return setStyles(data.instance.popper,data.styles),
// any property present in `data.attributes` will be applied to the popper,
// they will be set as HTML attributes of the element
setAttributes(data.instance.popper,data.attributes),
// if arrowElement is defined and arrowStyles has some properties
data.arrowElement&&Object.keys(data.arrowStyles).length&&setStyles(data.arrowElement,data.arrowStyles),data}
/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */function applyStyleOnLoad(reference,popper,options,modifierOptions,state){
// compute reference element offsets
var referenceOffsets=getReferenceOffsets(state,popper,reference,options.positionFixed),placement=computeAutoPlacement(options.placement,referenceOffsets,popper,reference,options.modifiers.flip.boundariesElement,options.modifiers.flip.padding);
// compute auto placement, store placement inside the data object,
// modifiers will be able to edit `placement` if needed
// and refer to originalPlacement to know the original value
return popper.setAttribute("x-placement",placement),
// Apply `position` to popper before anything else because
// without the position applied we can't guarantee correct computations
setStyles(popper,{position:options.positionFixed?"fixed":"absolute"}),options}
/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */function getRoundedOffsets(data,shouldRound){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,round=Math.round,floor=Math.floor,noRound=function(v){return v},referenceWidth=round(reference.width),popperWidth=round(popper.width),isVertical=-1!==["left","right"].indexOf(data.placement),isVariation=-1!==data.placement.indexOf("-"),sameWidthParity=referenceWidth%2===popperWidth%2,bothOddWidth=referenceWidth%2===1&&popperWidth%2===1,horizontalToInteger=shouldRound?isVertical||isVariation||sameWidthParity?round:floor:noRound,verticalToInteger=shouldRound?round:noRound;return{left:horizontalToInteger(bothOddWidth&&!isVariation&&shouldRound?popper.left-1:popper.left),top:verticalToInteger(popper.top),bottom:verticalToInteger(popper.bottom),right:horizontalToInteger(popper.right)}}var isFirefox=isBrowser&&/Firefox/i.test(navigator.userAgent);
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function computeStyle(data,options){var x=options.x,y=options.y,popper=data.offsets.popper,legacyGpuAccelerationOption=find(data.instance.modifiers,(function(modifier){return"applyStyle"===modifier.name})).gpuAcceleration,gpuAcceleration=void 0!==legacyGpuAccelerationOption?legacyGpuAccelerationOption:options.gpuAcceleration,offsetParent=getOffsetParent(data.instance.popper),offsetParentRect=getBoundingClientRect(offsetParent),styles={position:popper.position},offsets=getRoundedOffsets(data,window.devicePixelRatio<2||!isFirefox),sideA="bottom"===x?"top":"bottom",sideB="right"===y?"left":"right",prefixedProperty=getSupportedPropertyName("transform"),left=void 0,top=void 0;if(top="bottom"===sideA?
// when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
// and not the bottom of the html element
"HTML"===offsetParent.nodeName?-offsetParent.clientHeight+offsets.bottom:-offsetParentRect.height+offsets.bottom:offsets.top,left="right"===sideB?"HTML"===offsetParent.nodeName?-offsetParent.clientWidth+offsets.right:-offsetParentRect.width+offsets.right:offsets.left,gpuAcceleration&&prefixedProperty)styles[prefixedProperty]="translate3d("+left+"px, "+top+"px, 0)",styles[sideA]=0,styles[sideB]=0,styles.willChange="transform";else{
// othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
var invertTop="bottom"===sideA?-1:1,invertLeft="right"===sideB?-1:1;styles[sideA]=top*invertTop,styles[sideB]=left*invertLeft,styles.willChange=sideA+", "+sideB}
// Attributes
var attributes={"x-placement":data.placement};
// Update `data` attributes, styles and arrowStyles
return data.attributes=_extends({},attributes,data.attributes),data.styles=_extends({},styles,data.styles),data.arrowStyles=_extends({},data.offsets.arrow,data.arrowStyles),data}
/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */function isModifierRequired(modifiers,requestingName,requestedName){var requesting=find(modifiers,(function(_ref){var name=_ref.name;return name===requestingName})),isRequired=!!requesting&&modifiers.some((function(modifier){return modifier.name===requestedName&&modifier.enabled&&modifier.order<requesting.order}));if(!isRequired);return isRequired}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function arrow(data,options){var _data$offsets$arrow;
// arrow depends on keepTogether in order to work
if(!isModifierRequired(data.instance.modifiers,"arrow","keepTogether"))return data;var arrowElement=options.element;
// if arrowElement is a string, suppose it's a CSS selector
if("string"===typeof arrowElement){
// if arrowElement is not found, don't run the modifier
if(arrowElement=data.instance.popper.querySelector(arrowElement),!arrowElement)return data}else
// if the arrowElement isn't a query selector we must check that the
// provided DOM node is child of its popper node
if(!data.instance.popper.contains(arrowElement))return data;var placement=data.placement.split("-")[0],_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,isVertical=-1!==["left","right"].indexOf(placement),len=isVertical?"height":"width",sideCapitalized=isVertical?"Top":"Left",side=sideCapitalized.toLowerCase(),altSide=isVertical?"left":"top",opSide=isVertical?"bottom":"right",arrowElementSize=getOuterSizes(arrowElement)[len];
// extends keepTogether behavior making sure the popper and its
// reference have enough pixels in conjunction
// top/left side
reference[opSide]-arrowElementSize<popper[side]&&(data.offsets.popper[side]-=popper[side]-(reference[opSide]-arrowElementSize)),
// bottom/right side
reference[side]+arrowElementSize>popper[opSide]&&(data.offsets.popper[side]+=reference[side]+arrowElementSize-popper[opSide]),data.offsets.popper=getClientRect(data.offsets.popper);
// compute center of the popper
var center=reference[side]+reference[len]/2-arrowElementSize/2,css=getStyleComputedProperty(data.instance.popper),popperMarginSide=parseFloat(css["margin"+sideCapitalized]),popperBorderSide=parseFloat(css["border"+sideCapitalized+"Width"]),sideValue=center-data.offsets.popper[side]-popperMarginSide-popperBorderSide;
// Compute the sideValue using the updated popper offsets
// take popper margin in account because we don't have this info available
// prevent arrowElement from being placed not contiguously to its popper
return sideValue=Math.max(Math.min(popper[len]-arrowElementSize,sideValue),0),data.arrowElement=arrowElement,data.offsets.arrow=(_data$offsets$arrow={},defineProperty(_data$offsets$arrow,side,Math.round(sideValue)),defineProperty(_data$offsets$arrow,altSide,""),_data$offsets$arrow),data}
/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */function getOppositeVariation(variation){return"end"===variation?"start":"start"===variation?"end":variation}
/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */var placements=["auto-start","auto","auto-end","top-start","top","top-end","right-start","right","right-end","bottom-end","bottom","bottom-start","left-end","left","left-start"],validPlacements=placements.slice(3);
// Get rid of `auto` `auto-start` and `auto-end`
/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement){var counter=arguments.length>1&&void 0!==arguments[1]&&arguments[1],index=validPlacements.indexOf(placement),arr=validPlacements.slice(index+1).concat(validPlacements.slice(0,index));return counter?arr.reverse():arr}var BEHAVIORS={FLIP:"flip",CLOCKWISE:"clockwise",COUNTERCLOCKWISE:"counterclockwise"};
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function flip(data,options){
// if `inner` modifier is enabled, we can't use the `flip` modifier
if(isModifierEnabled(data.instance.modifiers,"inner"))return data;if(data.flipped&&data.placement===data.originalPlacement)
// seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
return data;var boundaries=getBoundaries(data.instance.popper,data.instance.reference,options.padding,options.boundariesElement,data.positionFixed),placement=data.placement.split("-")[0],placementOpposite=getOppositePlacement(placement),variation=data.placement.split("-")[1]||"",flipOrder=[];switch(options.behavior){case BEHAVIORS.FLIP:flipOrder=[placement,placementOpposite];break;case BEHAVIORS.CLOCKWISE:flipOrder=clockwise(placement);break;case BEHAVIORS.COUNTERCLOCKWISE:flipOrder=clockwise(placement,!0);break;default:flipOrder=options.behavior}return flipOrder.forEach((function(step,index){if(placement!==step||flipOrder.length===index+1)return data;placement=data.placement.split("-")[0],placementOpposite=getOppositePlacement(placement);var popperOffsets=data.offsets.popper,refOffsets=data.offsets.reference,floor=Math.floor,overlapsRef="left"===placement&&floor(popperOffsets.right)>floor(refOffsets.left)||"right"===placement&&floor(popperOffsets.left)<floor(refOffsets.right)||"top"===placement&&floor(popperOffsets.bottom)>floor(refOffsets.top)||"bottom"===placement&&floor(popperOffsets.top)<floor(refOffsets.bottom),overflowsLeft=floor(popperOffsets.left)<floor(boundaries.left),overflowsRight=floor(popperOffsets.right)>floor(boundaries.right),overflowsTop=floor(popperOffsets.top)<floor(boundaries.top),overflowsBottom=floor(popperOffsets.bottom)>floor(boundaries.bottom),overflowsBoundaries="left"===placement&&overflowsLeft||"right"===placement&&overflowsRight||"top"===placement&&overflowsTop||"bottom"===placement&&overflowsBottom,isVertical=-1!==["top","bottom"].indexOf(placement),flippedVariationByRef=!!options.flipVariations&&(isVertical&&"start"===variation&&overflowsLeft||isVertical&&"end"===variation&&overflowsRight||!isVertical&&"start"===variation&&overflowsTop||!isVertical&&"end"===variation&&overflowsBottom),flippedVariationByContent=!!options.flipVariationsByContent&&(isVertical&&"start"===variation&&overflowsRight||isVertical&&"end"===variation&&overflowsLeft||!isVertical&&"start"===variation&&overflowsBottom||!isVertical&&"end"===variation&&overflowsTop),flippedVariation=flippedVariationByRef||flippedVariationByContent;(overlapsRef||overflowsBoundaries||flippedVariation)&&(
// this boolean to detect any flip loop
data.flipped=!0,(overlapsRef||overflowsBoundaries)&&(placement=flipOrder[index+1]),flippedVariation&&(variation=getOppositeVariation(variation)),data.placement=placement+(variation?"-"+variation:""),
// this object contains `position`, we want to preserve it along with
// any additional property we may add in the future
data.offsets.popper=_extends({},data.offsets.popper,getPopperOffsets(data.instance.popper,data.offsets.reference,data.placement)),data=runModifiers(data.instance.modifiers,data,"flip"))})),data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function keepTogether(data){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,placement=data.placement.split("-")[0],floor=Math.floor,isVertical=-1!==["top","bottom"].indexOf(placement),side=isVertical?"right":"bottom",opSide=isVertical?"left":"top",measurement=isVertical?"width":"height";return popper[side]<floor(reference[opSide])&&(data.offsets.popper[opSide]=floor(reference[opSide])-popper[measurement]),popper[opSide]>floor(reference[side])&&(data.offsets.popper[opSide]=floor(reference[side])),data}
/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */function toValue(str,measurement,popperOffsets,referenceOffsets){
// separate value from unit
var split=str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),value=+split[1],unit=split[2];
// If it's not a number it's an operator, I guess
if(!value)return str;if(0===unit.indexOf("%")){var element=void 0;switch(unit){case"%p":element=popperOffsets;break;case"%":case"%r":default:element=referenceOffsets}var rect=getClientRect(element);return rect[measurement]/100*value}if("vh"===unit||"vw"===unit){
// if is a vh or vw, we calculate the size based on the viewport
var size=void 0;return size="vh"===unit?Math.max(document.documentElement.clientHeight,window.innerHeight||0):Math.max(document.documentElement.clientWidth,window.innerWidth||0),size/100*value}
// if is an explicit pixel unit, we get rid of the unit and keep the value
// if is an implicit unit, it's px, and we return just the value
return value}
/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */function parseOffset(offset,popperOffsets,referenceOffsets,basePlacement){var offsets=[0,0],useHeight=-1!==["right","left"].indexOf(basePlacement),fragments=offset.split(/(\+|\-)/).map((function(frag){return frag.trim()})),divider=fragments.indexOf(find(fragments,(function(frag){return-1!==frag.search(/,|\s/)})));
// Use height if placement is left or right and index is 0 otherwise use width
// in this way the first offset will use an axis and the second one
// will use the other one
fragments[divider]&&fragments[divider].indexOf(",");
// If divider is found, we divide the list of values and operands to divide
// them by ofset X and Y.
var splitRegex=/\s*,\s*|\s+/,ops=-1!==divider?[fragments.slice(0,divider).concat([fragments[divider].split(splitRegex)[0]]),[fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider+1))]:[fragments];
// Convert the values with units to absolute pixels to allow our computations
return ops=ops.map((function(op,index){
// Most of the units rely on the orientation of the popper
var measurement=(1===index?!useHeight:useHeight)?"height":"width",mergeWithPrevious=!1;return op.reduce((function(a,b){return""===a[a.length-1]&&-1!==["+","-"].indexOf(b)?(a[a.length-1]=b,mergeWithPrevious=!0,a):mergeWithPrevious?(a[a.length-1]+=b,mergeWithPrevious=!1,a):a.concat(b)}),[]).map((function(str){return toValue(str,measurement,popperOffsets,referenceOffsets)}))})),
// Loop trough the offsets arrays and execute the operations
ops.forEach((function(op,index){op.forEach((function(frag,index2){isNumeric(frag)&&(offsets[index]+=frag*("-"===op[index2-1]?-1:1))}))})),offsets}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */function offset(data,_ref){var offset=_ref.offset,placement=data.placement,_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,basePlacement=placement.split("-")[0],offsets=void 0;return offsets=isNumeric(+offset)?[+offset,0]:parseOffset(offset,popper,reference,basePlacement),"left"===basePlacement?(popper.top+=offsets[0],popper.left-=offsets[1]):"right"===basePlacement?(popper.top+=offsets[0],popper.left+=offsets[1]):"top"===basePlacement?(popper.left+=offsets[0],popper.top-=offsets[1]):"bottom"===basePlacement&&(popper.left+=offsets[0],popper.top+=offsets[1]),data.popper=popper,data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function preventOverflow(data,options){var boundariesElement=options.boundariesElement||getOffsetParent(data.instance.popper);
// If offsetParent is the reference element, we really want to
// go one step up and use the next offsetParent as reference to
// avoid to make this modifier completely useless and look like broken
data.instance.reference===boundariesElement&&(boundariesElement=getOffsetParent(boundariesElement));
// NOTE: DOM access here
// resets the popper's position so that the document size can be calculated excluding
// the size of the popper element itself
var transformProp=getSupportedPropertyName("transform"),popperStyles=data.instance.popper.style,top=popperStyles.top,left=popperStyles.left,transform=popperStyles[transformProp];popperStyles.top="",popperStyles.left="",popperStyles[transformProp]="";var boundaries=getBoundaries(data.instance.popper,data.instance.reference,options.padding,boundariesElement,data.positionFixed);
// NOTE: DOM access here
// restores the original style properties after the offsets have been computed
popperStyles.top=top,popperStyles.left=left,popperStyles[transformProp]=transform,options.boundaries=boundaries;var order=options.priority,popper=data.offsets.popper,check={primary:function(placement){var value=popper[placement];return popper[placement]<boundaries[placement]&&!options.escapeWithReference&&(value=Math.max(popper[placement],boundaries[placement])),defineProperty({},placement,value)},secondary:function(placement){var mainSide="right"===placement?"left":"top",value=popper[mainSide];return popper[placement]>boundaries[placement]&&!options.escapeWithReference&&(value=Math.min(popper[mainSide],boundaries[placement]-("right"===placement?popper.width:popper.height))),defineProperty({},mainSide,value)}};return order.forEach((function(placement){var side=-1!==["left","top"].indexOf(placement)?"primary":"secondary";popper=_extends({},popper,check[side](placement))})),data.offsets.popper=popper,data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function shift(data){var placement=data.placement,basePlacement=placement.split("-")[0],shiftvariation=placement.split("-")[1];
// if shift shiftvariation is specified, run the modifier
if(shiftvariation){var _data$offsets=data.offsets,reference=_data$offsets.reference,popper=_data$offsets.popper,isVertical=-1!==["bottom","top"].indexOf(basePlacement),side=isVertical?"left":"top",measurement=isVertical?"width":"height",shiftOffsets={start:defineProperty({},side,reference[side]),end:defineProperty({},side,reference[side]+reference[measurement]-popper[measurement])};data.offsets.popper=_extends({},popper,shiftOffsets[shiftvariation])}return data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function hide(data){if(!isModifierRequired(data.instance.modifiers,"hide","preventOverflow"))return data;var refRect=data.offsets.reference,bound=find(data.instance.modifiers,(function(modifier){return"preventOverflow"===modifier.name})).boundaries;if(refRect.bottom<bound.top||refRect.left>bound.right||refRect.top>bound.bottom||refRect.right<bound.left){
// Avoid unnecessary DOM access if visibility hasn't changed
if(!0===data.hide)return data;data.hide=!0,data.attributes["x-out-of-boundaries"]=""}else{
// Avoid unnecessary DOM access if visibility hasn't changed
if(!1===data.hide)return data;data.hide=!1,data.attributes["x-out-of-boundaries"]=!1}return data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function inner(data){var placement=data.placement,basePlacement=placement.split("-")[0],_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,isHoriz=-1!==["left","right"].indexOf(basePlacement),subtractLength=-1===["top","left"].indexOf(basePlacement);return popper[isHoriz?"left":"top"]=reference[basePlacement]-(subtractLength?popper[isHoriz?"width":"height"]:0),data.placement=getOppositePlacement(placement),data.offsets.popper=getClientRect(popper),data}
/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */
/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */var modifiers={
/**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
shift:{
/** @prop {number} order=100 - Index used to define the order of execution */
order:100,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:shift},
/**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
offset:{
/** @prop {number} order=200 - Index used to define the order of execution */
order:200,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:offset,
/** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
offset:0},
/**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
preventOverflow:{
/** @prop {number} order=300 - Index used to define the order of execution */
order:300,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:preventOverflow,
/**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
priority:["left","right","top","bottom"],
/**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
padding:5,
/**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
boundariesElement:"scrollParent"},
/**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
keepTogether:{
/** @prop {number} order=400 - Index used to define the order of execution */
order:400,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:keepTogether},
/**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
arrow:{
/** @prop {number} order=500 - Index used to define the order of execution */
order:500,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:arrow,
/** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
element:"[x-arrow]"},
/**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
flip:{
/** @prop {number} order=600 - Index used to define the order of execution */
order:600,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:flip,
/**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
behavior:"flip",
/**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
padding:5,
/**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
boundariesElement:"viewport",
/**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
flipVariations:!1,
/**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
flipVariationsByContent:!1},
/**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
inner:{
/** @prop {number} order=700 - Index used to define the order of execution */
order:700,
/** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
enabled:!1,
/** @prop {ModifierFn} */
fn:inner},
/**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
hide:{
/** @prop {number} order=800 - Index used to define the order of execution */
order:800,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:hide},
/**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
computeStyle:{
/** @prop {number} order=850 - Index used to define the order of execution */
order:850,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:computeStyle,
/**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
gpuAcceleration:!0,
/**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
x:"bottom",
/**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
y:"right"},
/**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
applyStyle:{
/** @prop {number} order=900 - Index used to define the order of execution */
order:900,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:applyStyle,
/** @prop {Function} */
onLoad:applyStyleOnLoad,
/**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
gpuAcceleration:void 0}},Defaults={
/**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
placement:"bottom",
/**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
positionFixed:!1,
/**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
eventsEnabled:!0,
/**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
removeOnDestroy:!1,
/**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
onCreate:function(){},
/**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
onUpdate:function(){},
/**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
modifiers:modifiers},Popper=function(){
/**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
function Popper(reference,popper){var _this=this,options=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};classCallCheck(this,Popper),this.scheduleUpdate=function(){return requestAnimationFrame(_this.update)},
// make update() debounced, so that it only runs at most once-per-tick
this.update=debounce(this.update.bind(this)),
// with {} we create a new object with the options inside it
this.options=_extends({},Popper.Defaults,options),
// init state
this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},
// get reference and popper elements (allow jQuery wrappers)
this.reference=reference&&reference.jquery?reference[0]:reference,this.popper=popper&&popper.jquery?popper[0]:popper,
// Deep merge modifiers options
this.options.modifiers={},Object.keys(_extends({},Popper.Defaults.modifiers,options.modifiers)).forEach((function(name){_this.options.modifiers[name]=_extends({},Popper.Defaults.modifiers[name]||{},options.modifiers?options.modifiers[name]:{})})),
// Refactoring modifiers' list (Object => Array)
this.modifiers=Object.keys(this.options.modifiers).map((function(name){return _extends({name:name},_this.options.modifiers[name])})).sort((function(a,b){return a.order-b.order})),
// modifiers have the ability to execute arbitrary code when Popper.js get inited
// such code is executed in the same order of its modifier
// they could add new properties to their options configuration
// BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
this.modifiers.forEach((function(modifierOptions){modifierOptions.enabled&&isFunction(modifierOptions.onLoad)&&modifierOptions.onLoad(_this.reference,_this.popper,_this.options,modifierOptions,_this.state)})),
// fire the first update to position the popper in the right place
this.update();var eventsEnabled=this.options.eventsEnabled;eventsEnabled&&
// setup event listeners, they will take care of update the position in specific situations
this.enableEventListeners(),this.state.eventsEnabled=eventsEnabled}
// We can't use class properties because they don't get listed in the
// class prototype and break stuff like Sinon stubs
return createClass(Popper,[{key:"update",value:function(){return update.call(this)}},{key:"destroy",value:function(){return destroy.call(this)}},{key:"enableEventListeners",value:function(){return enableEventListeners.call(this)}},{key:"disableEventListeners",value:function(){return disableEventListeners.call(this)}
/**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */
/**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */}]),Popper}();
/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */
/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */
Popper.Utils=("undefined"!==typeof window?window:__webpack_require__.g).PopperUtils,Popper.placements=placements,Popper.Defaults=Defaults,
/* harmony default export */__webpack_exports__["default"]=Popper},
/***/754123:
/***/function(module,__unused_webpack_exports,__webpack_require__){"use strict";var _os=__webpack_require__(892729),stringTimesN=function(n,char){return Array(n+1).join(char)};
// Adapted from https://gist.github.com/sente/1083506
function prettifyXml(xmlInput){var options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_options$indent=options.indent,indentOption=void 0===_options$indent?2:_options$indent,_options$newline=options.newline,newlineOption=void 0===_options$newline?_os.EOL:_options$newline,indentString=stringTimesN(indentOption," "),formatted="",regex=/(>)(<)(\/*)/g,xml=xmlInput.replace(regex,"$1"+newlineOption+"$2$3"),pad=0;return xml.split(/\r?\n/).forEach((function(l){var line=l.trim(),indent=0;line.match(/.+<\/\w[^>]*>$/)?indent=0:line.match(/^<\/\w/)?
// Somehow istanbul doesn't see the else case as covered, although it is. Skip it.
/* istanbul ignore else  */
0!==pad&&(pad-=1):indent=line.match(/^<\w([^>]*[^\/])?>.*$/)?1:0;var padding=stringTimesN(pad,indentString);formatted+=padding+line+newlineOption,// eslint-disable-line prefer-template
pad+=indent})),formatted.trim()}
// For non-es2015 usage
module.exports=prettifyXml},
/***/74971:
/***/function(module,exports,__webpack_require__){var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
/* module decorator */module=__webpack_require__.nmd(module),function(root){
/** Detect free variables */
exports&&exports.nodeType,module&&module.nodeType;var freeGlobal="object"==typeof __webpack_require__.g&&__webpack_require__.g;freeGlobal.global!==freeGlobal&&freeGlobal.window!==freeGlobal&&freeGlobal.self;
/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */var punycode,
/** Highest positive signed 32-bit float value */
maxInt=2147483647,// aka. 0x7FFFFFFF or 2^31-1
/** Bootstring parameters */
base=36,tMin=1,tMax=26,skew=38,damp=700,initialBias=72,initialN=128,// 0x80
delimiter="-",// '\x2D'
/** Regular expressions */
regexPunycode=/^xn--/,regexNonASCII=/[^\x20-\x7E]/,// unprintable ASCII chars + non-ASCII chars
regexSeparators=/[\x2E\u3002\uFF0E\uFF61]/g,// RFC 3490 separators
/** Error messages */
errors={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},
/** Convenience shortcuts */
baseMinusTMin=base-tMin,floor=Math.floor,stringFromCharCode=String.fromCharCode;
/*--------------------------------------------------------------------------*/
/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */function error(type){throw new RangeError(errors[type])}
/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */function map(array,fn){var length=array.length,result=[];while(length--)result[length]=fn(array[length]);return result}
/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */function mapDomain(string,fn){var parts=string.split("@"),result="";parts.length>1&&(
// In email addresses, only the domain name should be punycoded. Leave
// the local part (i.e. everything up to `@`) intact.
result=parts[0]+"@",string=parts[1]),
// Avoid `split(regex)` for IE8 compatibility. See #17.
string=string.replace(regexSeparators,".");var labels=string.split("."),encoded=map(labels,fn).join(".");return result+encoded}
/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */function ucs2decode(string){var value,extra,output=[],counter=0,length=string.length;while(counter<length)value=string.charCodeAt(counter++),value>=55296&&value<=56319&&counter<length?(
// high surrogate, and there is a next character
extra=string.charCodeAt(counter++),56320==(64512&extra)?// low surrogate
output.push(((1023&value)<<10)+(1023&extra)+65536):(
// unmatched surrogate; only append this code unit, in case the next
// code unit is the high surrogate of a surrogate pair
output.push(value),counter--)):output.push(value);return output}
/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */function ucs2encode(array){return map(array,(function(value){var output="";return value>65535&&(value-=65536,output+=stringFromCharCode(value>>>10&1023|55296),value=56320|1023&value),output+=stringFromCharCode(value),output})).join("")}
/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */function basicToDigit(codePoint){return codePoint-48<10?codePoint-22:codePoint-65<26?codePoint-65:codePoint-97<26?codePoint-97:base}
/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */function digitToBasic(digit,flag){
//  0..25 map to ASCII a..z or A..Z
// 26..35 map to ASCII 0..9
return digit+22+75*(digit<26)-((0!=flag)<<5)}
/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */function adapt(delta,numPoints,firstTime){var k=0;for(delta=firstTime?floor(delta/damp):delta>>1,delta+=floor(delta/numPoints);delta>baseMinusTMin*tMax>>1;k+=base)delta=floor(delta/baseMinusTMin);return floor(k+(baseMinusTMin+1)*delta/(delta+skew))}
/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */function decode(input){
// Don't use UCS-2
var out,basic,j,index,oldi,w,k,digit,t,
/** Cached calculation results */
baseMinusT,output=[],inputLength=input.length,i=0,n=initialN,bias=initialBias;
// Handle the basic code points: let `basic` be the number of input code
// points before the last delimiter, or `0` if there is none, then copy
// the first basic code points to the output.
for(basic=input.lastIndexOf(delimiter),basic<0&&(basic=0),j=0;j<basic;++j)
// if it's not a basic code point
input.charCodeAt(j)>=128&&error("not-basic"),output.push(input.charCodeAt(j));
// Main decoding loop: start just after the last delimiter if any basic code
// points were copied; start at the beginning otherwise.
for(index=basic>0?basic+1:0;index<inputLength;){
// `index` is the index of the next character to be consumed.
// Decode a generalized variable-length integer into `delta`,
// which gets added to `i`. The overflow checking is easier
// if we increase `i` as we go, then subtract off its starting
// value at the end to obtain `delta`.
for(oldi=i,w=1,k=base;;k+=base){if(index>=inputLength&&error("invalid-input"),digit=basicToDigit(input.charCodeAt(index++)),(digit>=base||digit>floor((maxInt-i)/w))&&error("overflow"),i+=digit*w,t=k<=bias?tMin:k>=bias+tMax?tMax:k-bias,digit<t)break;baseMinusT=base-t,w>floor(maxInt/baseMinusT)&&error("overflow"),w*=baseMinusT}out=output.length+1,bias=adapt(i-oldi,out,0==oldi),
// `i` was supposed to wrap around from `out` to `0`,
// incrementing `n` each time, so we'll fix that now:
floor(i/out)>maxInt-n&&error("overflow"),n+=floor(i/out),i%=out,
// Insert `n` at position `i` of the output
output.splice(i++,0,n)}return ucs2encode(output)}
/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */function encode(input){var n,delta,handledCPCount,basicLength,bias,j,m,q,k,t,currentValue,
/** `inputLength` will hold the number of code points in `input`. */
inputLength,
/** Cached calculation results */
handledCPCountPlusOne,baseMinusT,qMinusT,output=[];
// Convert the input in UCS-2 to Unicode
// Handle the basic code points
for(input=ucs2decode(input),
// Cache the length
inputLength=input.length,
// Initialize the state
n=initialN,delta=0,bias=initialBias,j=0;j<inputLength;++j)currentValue=input[j],currentValue<128&&output.push(stringFromCharCode(currentValue));handledCPCount=basicLength=output.length,
// `handledCPCount` is the number of code points that have been handled;
// `basicLength` is the number of basic code points.
// Finish the basic string - if it is not empty - with a delimiter
basicLength&&output.push(delimiter);
// Main encoding loop:
while(handledCPCount<inputLength){
// All non-basic code points < n have been handled already. Find the next
// larger one:
for(m=maxInt,j=0;j<inputLength;++j)currentValue=input[j],currentValue>=n&&currentValue<m&&(m=currentValue);
// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
// but guard against overflow
for(handledCPCountPlusOne=handledCPCount+1,m-n>floor((maxInt-delta)/handledCPCountPlusOne)&&error("overflow"),delta+=(m-n)*handledCPCountPlusOne,n=m,j=0;j<inputLength;++j)if(currentValue=input[j],currentValue<n&&++delta>maxInt&&error("overflow"),currentValue==n){
// Represent delta as a generalized variable-length integer
for(q=delta,k=base;;k+=base){if(t=k<=bias?tMin:k>=bias+tMax?tMax:k-bias,q<t)break;qMinusT=q-t,baseMinusT=base-t,output.push(stringFromCharCode(digitToBasic(t+qMinusT%baseMinusT,0))),q=floor(qMinusT/baseMinusT)}output.push(stringFromCharCode(digitToBasic(q,0))),bias=adapt(delta,handledCPCountPlusOne,handledCPCount==basicLength),delta=0,++handledCPCount}++delta,++n}return output.join("")}
/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */function toUnicode(input){return mapDomain(input,(function(string){return regexPunycode.test(string)?decode(string.slice(4).toLowerCase()):string}))}
/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */function toASCII(input){return mapDomain(input,(function(string){return regexNonASCII.test(string)?"xn--"+encode(string):string}))}
/*--------------------------------------------------------------------------*/
/** Define the public API */punycode={
/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
version:"1.4.1",
/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
ucs2:{decode:ucs2decode,encode:ucs2encode},decode:decode,encode:encode,toASCII:toASCII,toUnicode:toUnicode},__WEBPACK_AMD_DEFINE_RESULT__=function(){return punycode}.call(exports,__webpack_require__,exports,module),void 0===__WEBPACK_AMD_DEFINE_RESULT__||(module.exports=__WEBPACK_AMD_DEFINE_RESULT__)}()},
/***/169574:
/***/function(__unused_webpack_module,__webpack_exports__){"use strict";
/*!
 * qrcode.vue v1.7.0
 * A Vue component to generate QRCode.
 * © 2017-2019 @scopewu(https://github.com/scopewu)
 * MIT License.
 */var mode={MODE_NUMBER:1,MODE_ALPHA_NUM:2,MODE_8BIT_BYTE:4,MODE_KANJI:8};function QR8bitByte(data){this.mode=mode.MODE_8BIT_BYTE,this.data=data}QR8bitByte.prototype={getLength:function(buffer){return this.data.length},write:function(buffer){for(var i=0;i<this.data.length;i++)
// not JIS ...
buffer.put(this.data.charCodeAt(i),8)}};var _8BitByte=QR8bitByte,ErrorCorrectLevel={L:1,M:0,Q:3,H:2};function QRRSBlock(totalCount,dataCount){this.totalCount=totalCount,this.dataCount=dataCount}QRRSBlock.RS_BLOCK_TABLE=[// L
// M
// Q
// H
// 1
[1,26,19],[1,26,16],[1,26,13],[1,26,9],// 2
[1,44,34],[1,44,28],[1,44,22],[1,44,16],// 3
[1,70,55],[1,70,44],[2,35,17],[2,35,13],// 4		
[1,100,80],[2,50,32],[2,50,24],[4,25,9],// 5
[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],// 6
[2,86,68],[4,43,27],[4,43,19],[4,43,15],// 7		
[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],// 8
[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],// 9
[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],// 10		
[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],// 11
[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],// 12
[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],// 13
[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],// 14
[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],// 15
[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12],// 16
[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],// 17
[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],// 18
[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],// 19
[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],// 20
[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],// 21
[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],// 22
[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],// 23
[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],// 24
[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],// 25
[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],// 26
[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],// 27
[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],// 28
[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],// 29
[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],// 30
[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],// 31
[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],// 32
[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],// 33
[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],// 34
[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],// 35
[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],// 36
[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],// 37
[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],// 38
[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],// 39
[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],// 40
[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]],QRRSBlock.getRSBlocks=function(typeNumber,errorCorrectLevel){var rsBlock=QRRSBlock.getRsBlockTable(typeNumber,errorCorrectLevel);if(void 0==rsBlock)throw new Error("bad rs block @ typeNumber:"+typeNumber+"/errorCorrectLevel:"+errorCorrectLevel);for(var length=rsBlock.length/3,list=new Array,i=0;i<length;i++)for(var count=rsBlock[3*i+0],totalCount=rsBlock[3*i+1],dataCount=rsBlock[3*i+2],j=0;j<count;j++)list.push(new QRRSBlock(totalCount,dataCount));return list},QRRSBlock.getRsBlockTable=function(typeNumber,errorCorrectLevel){switch(errorCorrectLevel){case ErrorCorrectLevel.L:return QRRSBlock.RS_BLOCK_TABLE[4*(typeNumber-1)+0];case ErrorCorrectLevel.M:return QRRSBlock.RS_BLOCK_TABLE[4*(typeNumber-1)+1];case ErrorCorrectLevel.Q:return QRRSBlock.RS_BLOCK_TABLE[4*(typeNumber-1)+2];case ErrorCorrectLevel.H:return QRRSBlock.RS_BLOCK_TABLE[4*(typeNumber-1)+3];default:return}};var RSBlock=QRRSBlock;function QRBitBuffer(){this.buffer=new Array,this.length=0}QRBitBuffer.prototype={get:function(index){var bufIndex=Math.floor(index/8);return 1==(this.buffer[bufIndex]>>>7-index%8&1)},put:function(num,length){for(var i=0;i<length;i++)this.putBit(1==(num>>>length-i-1&1))},getLengthInBits:function(){return this.length},putBit:function(bit){var bufIndex=Math.floor(this.length/8);this.buffer.length<=bufIndex&&this.buffer.push(0),bit&&(this.buffer[bufIndex]|=128>>>this.length%8),this.length++}};for(var BitBuffer=QRBitBuffer,QRMath={glog:function(n){if(n<1)throw new Error("glog("+n+")");return QRMath.LOG_TABLE[n]},gexp:function(n){while(n<0)n+=255;while(n>=256)n-=255;return QRMath.EXP_TABLE[n]},EXP_TABLE:new Array(256),LOG_TABLE:new Array(256)},i=0;i<8;i++)QRMath.EXP_TABLE[i]=1<<i;for(i=8;i<256;i++)QRMath.EXP_TABLE[i]=QRMath.EXP_TABLE[i-4]^QRMath.EXP_TABLE[i-5]^QRMath.EXP_TABLE[i-6]^QRMath.EXP_TABLE[i-8];for(i=0;i<255;i++)QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]]=i;var math=QRMath;function QRPolynomial(num,shift){if(void 0==num.length)throw new Error(num.length+"/"+shift);var offset=0;while(offset<num.length&&0==num[offset])offset++;this.num=new Array(num.length-offset+shift);for(var i=0;i<num.length-offset;i++)this.num[i]=num[i+offset]}QRPolynomial.prototype={get:function(index){return this.num[index]},getLength:function(){return this.num.length},multiply:function(e){for(var num=new Array(this.getLength()+e.getLength()-1),i=0;i<this.getLength();i++)for(var j=0;j<e.getLength();j++)num[i+j]^=math.gexp(math.glog(this.get(i))+math.glog(e.get(j)));return new QRPolynomial(num,0)},mod:function(e){if(this.getLength()-e.getLength()<0)return this;for(var ratio=math.glog(this.get(0))-math.glog(e.get(0)),num=new Array(this.getLength()),i=0;i<this.getLength();i++)num[i]=this.get(i);for(i=0;i<e.getLength();i++)num[i]^=math.gexp(math.glog(e.get(i))+ratio);// recursive call
return new QRPolynomial(num,0).mod(e)}};var Polynomial=QRPolynomial,QRMaskPattern={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7},QRUtil={PATTERN_POSITION_TABLE:[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],G15:1335,G18:7973,G15_MASK:21522,getBCHTypeInfo:function(data){var d=data<<10;while(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G15)>=0)d^=QRUtil.G15<<QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G15);return(data<<10|d)^QRUtil.G15_MASK},getBCHTypeNumber:function(data){var d=data<<12;while(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G18)>=0)d^=QRUtil.G18<<QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G18);return data<<12|d},getBCHDigit:function(data){var digit=0;while(0!=data)digit++,data>>>=1;return digit},getPatternPosition:function(typeNumber){return QRUtil.PATTERN_POSITION_TABLE[typeNumber-1]},getMask:function(maskPattern,i,j){switch(maskPattern){case QRMaskPattern.PATTERN000:return(i+j)%2==0;case QRMaskPattern.PATTERN001:return i%2==0;case QRMaskPattern.PATTERN010:return j%3==0;case QRMaskPattern.PATTERN011:return(i+j)%3==0;case QRMaskPattern.PATTERN100:return(Math.floor(i/2)+Math.floor(j/3))%2==0;case QRMaskPattern.PATTERN101:return i*j%2+i*j%3==0;case QRMaskPattern.PATTERN110:return(i*j%2+i*j%3)%2==0;case QRMaskPattern.PATTERN111:return(i*j%3+(i+j)%2)%2==0;default:throw new Error("bad maskPattern:"+maskPattern)}},getErrorCorrectPolynomial:function(errorCorrectLength){for(var a=new Polynomial([1],0),i=0;i<errorCorrectLength;i++)a=a.multiply(new Polynomial([1,math.gexp(i)],0));return a},getLengthInBits:function(mode$1,type){if(1<=type&&type<10)
// 1 - 9
switch(mode$1){case mode.MODE_NUMBER:return 10;case mode.MODE_ALPHA_NUM:return 9;case mode.MODE_8BIT_BYTE:return 8;case mode.MODE_KANJI:return 8;default:throw new Error("mode:"+mode$1)}else if(type<27)
// 10 - 26
switch(mode$1){case mode.MODE_NUMBER:return 12;case mode.MODE_ALPHA_NUM:return 11;case mode.MODE_8BIT_BYTE:return 16;case mode.MODE_KANJI:return 10;default:throw new Error("mode:"+mode$1)}else{if(!(type<41))throw new Error("type:"+type);
// 27 - 40
switch(mode$1){case mode.MODE_NUMBER:return 14;case mode.MODE_ALPHA_NUM:return 13;case mode.MODE_8BIT_BYTE:return 16;case mode.MODE_KANJI:return 12;default:throw new Error("mode:"+mode$1)}}},getLostPoint:function(qrCode){// LEVEL1
for(var moduleCount=qrCode.getModuleCount(),lostPoint=0,row=0;row<moduleCount;row++)for(var col=0;col<moduleCount;col++){for(var sameCount=0,dark=qrCode.isDark(row,col),r=-1;r<=1;r++)if(!(row+r<0||moduleCount<=row+r))for(var c=-1;c<=1;c++)col+c<0||moduleCount<=col+c||0==r&&0==c||dark==qrCode.isDark(row+r,col+c)&&sameCount++;sameCount>5&&(lostPoint+=3+sameCount-5)}// LEVEL2
for(row=0;row<moduleCount-1;row++)for(col=0;col<moduleCount-1;col++){var count=0;qrCode.isDark(row,col)&&count++,qrCode.isDark(row+1,col)&&count++,qrCode.isDark(row,col+1)&&count++,qrCode.isDark(row+1,col+1)&&count++,0!=count&&4!=count||(lostPoint+=3)}// LEVEL3
for(row=0;row<moduleCount;row++)for(col=0;col<moduleCount-6;col++)qrCode.isDark(row,col)&&!qrCode.isDark(row,col+1)&&qrCode.isDark(row,col+2)&&qrCode.isDark(row,col+3)&&qrCode.isDark(row,col+4)&&!qrCode.isDark(row,col+5)&&qrCode.isDark(row,col+6)&&(lostPoint+=40);for(col=0;col<moduleCount;col++)for(row=0;row<moduleCount-6;row++)qrCode.isDark(row,col)&&!qrCode.isDark(row+1,col)&&qrCode.isDark(row+2,col)&&qrCode.isDark(row+3,col)&&qrCode.isDark(row+4,col)&&!qrCode.isDark(row+5,col)&&qrCode.isDark(row+6,col)&&(lostPoint+=40);// LEVEL4
var darkCount=0;for(col=0;col<moduleCount;col++)for(row=0;row<moduleCount;row++)qrCode.isDark(row,col)&&darkCount++;var ratio=Math.abs(100*darkCount/moduleCount/moduleCount-50)/5;return lostPoint+=10*ratio,lostPoint}},util=QRUtil;function QRCode(typeNumber,errorCorrectLevel){this.typeNumber=typeNumber,this.errorCorrectLevel=errorCorrectLevel,this.modules=null,this.moduleCount=0,this.dataCache=null,this.dataList=[]}// for client side minification
var proto=QRCode.prototype;proto.addData=function(data){var newData=new _8BitByte(data);this.dataList.push(newData),this.dataCache=null},proto.isDark=function(row,col){if(row<0||this.moduleCount<=row||col<0||this.moduleCount<=col)throw new Error(row+","+col);return this.modules[row][col]},proto.getModuleCount=function(){return this.moduleCount},proto.make=function(){
// Calculate automatically typeNumber if provided is < 1
if(this.typeNumber<1){var typeNumber=1;for(typeNumber=1;typeNumber<40;typeNumber++){for(var rsBlocks=RSBlock.getRSBlocks(typeNumber,this.errorCorrectLevel),buffer=new BitBuffer,totalDataCount=0,i=0;i<rsBlocks.length;i++)totalDataCount+=rsBlocks[i].dataCount;for(i=0;i<this.dataList.length;i++){var data=this.dataList[i];buffer.put(data.mode,4),buffer.put(data.getLength(),util.getLengthInBits(data.mode,typeNumber)),data.write(buffer)}if(buffer.getLengthInBits()<=8*totalDataCount)break}this.typeNumber=typeNumber}this.makeImpl(!1,this.getBestMaskPattern())},proto.makeImpl=function(test,maskPattern){this.moduleCount=4*this.typeNumber+17,this.modules=new Array(this.moduleCount);for(var row=0;row<this.moduleCount;row++){this.modules[row]=new Array(this.moduleCount);for(var col=0;col<this.moduleCount;col++)this.modules[row][col]=null;//(col + row) % 3;
}this.setupPositionProbePattern(0,0),this.setupPositionProbePattern(this.moduleCount-7,0),this.setupPositionProbePattern(0,this.moduleCount-7),this.setupPositionAdjustPattern(),this.setupTimingPattern(),this.setupTypeInfo(test,maskPattern),this.typeNumber>=7&&this.setupTypeNumber(test),null==this.dataCache&&(this.dataCache=QRCode.createData(this.typeNumber,this.errorCorrectLevel,this.dataList)),this.mapData(this.dataCache,maskPattern)},proto.setupPositionProbePattern=function(row,col){for(var r=-1;r<=7;r++)if(!(row+r<=-1||this.moduleCount<=row+r))for(var c=-1;c<=7;c++)col+c<=-1||this.moduleCount<=col+c||(this.modules[row+r][col+c]=0<=r&&r<=6&&(0==c||6==c)||0<=c&&c<=6&&(0==r||6==r)||2<=r&&r<=4&&2<=c&&c<=4)},proto.getBestMaskPattern=function(){for(var minLostPoint=0,pattern=0,i=0;i<8;i++){this.makeImpl(!0,i);var lostPoint=util.getLostPoint(this);(0==i||minLostPoint>lostPoint)&&(minLostPoint=lostPoint,pattern=i)}return pattern},proto.createMovieClip=function(target_mc,instance_name,depth){var qr_mc=target_mc.createEmptyMovieClip(instance_name,depth),cs=1;this.make();for(var row=0;row<this.modules.length;row++)for(var y=row*cs,col=0;col<this.modules[row].length;col++){var x=col*cs,dark=this.modules[row][col];dark&&(qr_mc.beginFill(0,100),qr_mc.moveTo(x,y),qr_mc.lineTo(x+cs,y),qr_mc.lineTo(x+cs,y+cs),qr_mc.lineTo(x,y+cs),qr_mc.endFill())}return qr_mc},proto.setupTimingPattern=function(){for(var r=8;r<this.moduleCount-8;r++)null==this.modules[r][6]&&(this.modules[r][6]=r%2==0);for(var c=8;c<this.moduleCount-8;c++)null==this.modules[6][c]&&(this.modules[6][c]=c%2==0)},proto.setupPositionAdjustPattern=function(){for(var pos=util.getPatternPosition(this.typeNumber),i=0;i<pos.length;i++)for(var j=0;j<pos.length;j++){var row=pos[i],col=pos[j];if(null==this.modules[row][col])for(var r=-2;r<=2;r++)for(var c=-2;c<=2;c++)this.modules[row+r][col+c]=-2==r||2==r||-2==c||2==c||0==r&&0==c}},proto.setupTypeNumber=function(test){for(var bits=util.getBCHTypeNumber(this.typeNumber),i=0;i<18;i++){var mod=!test&&1==(bits>>i&1);this.modules[Math.floor(i/3)][i%3+this.moduleCount-8-3]=mod}for(i=0;i<18;i++){mod=!test&&1==(bits>>i&1);this.modules[i%3+this.moduleCount-8-3][Math.floor(i/3)]=mod}},proto.setupTypeInfo=function(test,maskPattern){// vertical		
for(var data=this.errorCorrectLevel<<3|maskPattern,bits=util.getBCHTypeInfo(data),i=0;i<15;i++){var mod=!test&&1==(bits>>i&1);i<6?this.modules[i][8]=mod:i<8?this.modules[i+1][8]=mod:this.modules[this.moduleCount-15+i][8]=mod}// horizontal
for(i=0;i<15;i++){mod=!test&&1==(bits>>i&1);i<8?this.modules[8][this.moduleCount-i-1]=mod:i<9?this.modules[8][15-i-1+1]=mod:this.modules[8][15-i-1]=mod}// fixed module
this.modules[this.moduleCount-8][8]=!test},proto.mapData=function(data,maskPattern){for(var inc=-1,row=this.moduleCount-1,bitIndex=7,byteIndex=0,col=this.moduleCount-1;col>0;col-=2){6==col&&col--;while(1){for(var c=0;c<2;c++)if(null==this.modules[row][col-c]){var dark=!1;byteIndex<data.length&&(dark=1==(data[byteIndex]>>>bitIndex&1));var mask=util.getMask(maskPattern,row,col-c);mask&&(dark=!dark),this.modules[row][col-c]=dark,bitIndex--,-1==bitIndex&&(byteIndex++,bitIndex=7)}if(row+=inc,row<0||this.moduleCount<=row){row-=inc,inc=-inc;break}}}},QRCode.PAD0=236,QRCode.PAD1=17,QRCode.createData=function(typeNumber,errorCorrectLevel,dataList){for(var rsBlocks=RSBlock.getRSBlocks(typeNumber,errorCorrectLevel),buffer=new BitBuffer,i=0;i<dataList.length;i++){var data=dataList[i];buffer.put(data.mode,4),buffer.put(data.getLength(),util.getLengthInBits(data.mode,typeNumber)),data.write(buffer)}// calc num max data.
var totalDataCount=0;for(i=0;i<rsBlocks.length;i++)totalDataCount+=rsBlocks[i].dataCount;if(buffer.getLengthInBits()>8*totalDataCount)throw new Error("code length overflow. ("+buffer.getLengthInBits()+">"+8*totalDataCount+")");// end code
buffer.getLengthInBits()+4<=8*totalDataCount&&buffer.put(0,4);// padding
while(buffer.getLengthInBits()%8!=0)buffer.putBit(!1);// padding
while(1){if(buffer.getLengthInBits()>=8*totalDataCount)break;if(buffer.put(QRCode.PAD0,8),buffer.getLengthInBits()>=8*totalDataCount)break;buffer.put(QRCode.PAD1,8)}return QRCode.createBytes(buffer,rsBlocks)},QRCode.createBytes=function(buffer,rsBlocks){for(var offset=0,maxDcCount=0,maxEcCount=0,dcdata=new Array(rsBlocks.length),ecdata=new Array(rsBlocks.length),r=0;r<rsBlocks.length;r++){var dcCount=rsBlocks[r].dataCount,ecCount=rsBlocks[r].totalCount-dcCount;maxDcCount=Math.max(maxDcCount,dcCount),maxEcCount=Math.max(maxEcCount,ecCount),dcdata[r]=new Array(dcCount);for(var i=0;i<dcdata[r].length;i++)dcdata[r][i]=255&buffer.buffer[i+offset];offset+=dcCount;var rsPoly=util.getErrorCorrectPolynomial(ecCount),rawPoly=new Polynomial(dcdata[r],rsPoly.getLength()-1),modPoly=rawPoly.mod(rsPoly);ecdata[r]=new Array(rsPoly.getLength()-1);for(i=0;i<ecdata[r].length;i++){var modIndex=i+modPoly.getLength()-ecdata[r].length;ecdata[r][i]=modIndex>=0?modPoly.get(modIndex):0}}var totalCodeCount=0;for(i=0;i<rsBlocks.length;i++)totalCodeCount+=rsBlocks[i].totalCount;var data=new Array(totalCodeCount),index=0;for(i=0;i<maxDcCount;i++)for(r=0;r<rsBlocks.length;r++)i<dcdata[r].length&&(data[index++]=dcdata[r][i]);for(i=0;i<maxEcCount;i++)for(r=0;r<rsBlocks.length;r++)i<ecdata[r].length&&(data[index++]=ecdata[r][i]);return data};var QRCode_1=QRCode;
/**
 * Encode UTF16 to UTF8.
 * See: http://jonisalonen.com/2012/from-utf-16-to-utf-8-in-javascript/
 * @param str {string}
 * @returns {string}
 */function toUTF8String(str){for(var utf8Str="",i=0;i<str.length;i++){var charCode=str.charCodeAt(i);charCode<128?utf8Str+=String.fromCharCode(charCode):charCode<2048?(utf8Str+=String.fromCharCode(192|charCode>>6),utf8Str+=String.fromCharCode(128|63&charCode)):charCode<55296||charCode>=57344?(utf8Str+=String.fromCharCode(224|charCode>>12),utf8Str+=String.fromCharCode(128|charCode>>6&63),utf8Str+=String.fromCharCode(128|63&charCode)):(
// surrogate pair
i++,// UTF-16 encodes 0x10000-0x10FFFF by
// subtracting 0x10000 and splitting the
// 20 bits of 0x0-0xFFFFF into two halves
charCode=65536+((1023&charCode)<<10|1023&str.charCodeAt(i)),utf8Str+=String.fromCharCode(240|charCode>>18),utf8Str+=String.fromCharCode(128|charCode>>12&63),utf8Str+=String.fromCharCode(128|charCode>>6&63),utf8Str+=String.fromCharCode(128|63&charCode))}return utf8Str}function generatePath(modules){var margin=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,ops=[];return modules.forEach((function(row,y){var start=null;row.forEach((function(cell,x){if(!cell&&null!==start)
// M0 0h7v1H0z injects the space with the move and drops the comma,
// saving a char per operation
return ops.push("M".concat(start+margin," ").concat(y+margin,"h").concat(x-start,"v1H").concat(start+margin,"z")),void(start=null);// end of row, clean up or skip
if(x!==row.length-1)cell&&null===start&&(start=x);else{if(!cell)
// We would have closed the op above already so this can only mean
// 2+ light modules in a row.
return;null===start?
// Just a single dark module.
ops.push("M".concat(x+margin,",").concat(y+margin," h1v1H").concat(x+margin,"z")):
// Otherwise finish the current line.
ops.push("M".concat(start+margin,",").concat(y+margin," h").concat(x+1-start,"v1H").concat(start+margin,"z"))}}))})),ops.join("")}// @vue/component
var QrcodeVue={props:{value:{type:String,required:!0,default:""},className:{type:String,default:""},size:{type:[Number,String],default:100,validator:function(s){return!0!==isNaN(Number(s))}},level:{type:String,default:"L",validator:function(l){return["L","Q","M","H"].indexOf(l)>-1}},background:{type:String,default:"#fff"},foreground:{type:String,default:"#000"},renderAs:{type:String,required:!1,default:"canvas",validator:function(as){return["canvas","svg"].indexOf(as)>-1}}},data:function(){return{numCells:0,fgPath:""}},updated:function(){this.render()},mounted:function(){this.render()},methods:{render:function(){var value=this.value,size=this.size,level=this.level,background=this.background,foreground=this.foreground,renderAs=this.renderAs,_size=size>>>0,qrCode=new QRCode_1(-1,ErrorCorrectLevel[level]);qrCode.addData(toUTF8String(value)),qrCode.make();var cells=qrCode.modules,tileW=_size/cells.length,tileH=_size/cells.length,scale=window.devicePixelRatio||1;if("svg"===renderAs)this.numCells=cells.length,// Drawing strategy: instead of a rect per module, we're going to create a
// single path for the dark modules and layer that on top of a light rect,
// for a total of 2 DOM nodes. We pay a bit more in string concat but that's
// way faster than DOM ops.
// For level 1, 441 nodes -> 2
// For level 40, 31329 -> 2
this.fgPath=generatePath(cells);else{var canvas=this.$refs["qrcode-vue"],ctx=canvas.getContext("2d");canvas.height=canvas.width=_size*scale,ctx.scale(scale,scale),cells.forEach((function(row,rdx){row.forEach((function(cell,cdx){ctx.fillStyle=cell?foreground:background;var w=Math.ceil((cdx+1)*tileW)-Math.floor(cdx*tileW),h=Math.ceil((rdx+1)*tileH)-Math.floor(rdx*tileH);ctx.fillRect(Math.round(cdx*tileW),Math.round(rdx*tileH),w,h)}))}))}}},render:function(createElement){var className=this.className,value=this.value,level=this.level,background=this.background,foreground=this.foreground,size=this.size,renderAs=this.renderAs,numCells=this.numCells,fgPath=this.fgPath;return createElement("div",{class:this.class||className,attrs:{value:value,level:level,background:background,foreground:foreground}},["svg"===renderAs?createElement("svg",{attrs:{height:size,width:size,shapeRendering:"crispEdges",viewBox:"0 0 ".concat(numCells," ").concat(numCells)},style:{width:size+"px",height:size+"px"}},[createElement("path",{attrs:{fill:background,d:"M0,0 h".concat(numCells,"v").concat(numCells,"H0z")}}),createElement("path",{attrs:{fill:foreground,d:fgPath}})]):createElement("canvas",{attrs:{height:size,width:size},style:{width:size+"px",height:size+"px"},ref:"qrcode-vue"},[])])}};
/* harmony default export */__webpack_exports__.Z=QrcodeVue},
/***/422331:
/***/function(module){
/*
 * QRious v4.0.2
 * Copyright (C) 2017 Alasdair Mercer
 * Copyright (C) 2010 Tom Zerucha
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
(function(global,factory){module.exports=factory()})(0,(function(){"use strict";
/*
   * Copyright (C) 2017 Alasdair Mercer, !ninja
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
/**
   * A bare-bones constructor for surrogate prototype swapping.
   *
   * @private
   * @constructor
   */var Constructor=/* istanbul ignore next */function(){},hasOwnProperty=Object.prototype.hasOwnProperty,slice=Array.prototype.slice;
/**
   * A reference to <code>Object.prototype.hasOwnProperty</code>.
   *
   * @private
   * @type {Function}
   */
/**
   * Creates an object which inherits the given <code>prototype</code>.
   *
   * Optionally, the created object can be extended further with the specified <code>properties</code>.
   *
   * @param {Object} prototype - the prototype to be inherited by the created object
   * @param {Object} [properties] - the optional properties to be extended by the created object
   * @return {Object} The newly created object.
   * @private
   */
function createObject(prototype,properties){var result;
/* istanbul ignore next */return"function"===typeof Object.create?result=Object.create(prototype):(Constructor.prototype=prototype,result=new Constructor,Constructor.prototype=null),properties&&extendObject(!0,result,properties),result}
/**
   * Extends the constructor to which this method is associated with the <code>prototype</code> and/or
   * <code>statics</code> provided.
   *
   * If <code>name</code> is provided, it will be used as the class name and can be accessed via a special
   * <code>class_</code> property on the child constructor, otherwise the class name of the super constructor will be used
   * instead. The class name may also be used string representation for instances of the child constructor (via
   * <code>toString</code>), but this is not applicable to the <i>lite</i> version of Nevis.
   *
   * If <code>constructor</code> is provided, it will be used as the constructor for the child, otherwise a simple
   * constructor which only calls the super constructor will be used instead.
   *
   * The super constructor can be accessed via a special <code>super_</code> property on the child constructor.
   *
   * @param {string} [name=this.class_] - the class name to be used for the child constructor
   * @param {Function} [constructor] - the constructor for the child
   * @param {Object} [prototype] - the prototype properties to be defined for the child
   * @param {Object} [statics] - the static properties to be defined for the child
   * @return {Function} The child <code>constructor</code> provided or the one created if none was given.
   * @public
   */function extend(name,constructor,prototype,statics){var superConstructor=this;return"string"!==typeof name&&(statics=prototype,prototype=constructor,constructor=name,name=null),"function"!==typeof constructor&&(statics=prototype,prototype=constructor,constructor=function(){return superConstructor.apply(this,arguments)}),extendObject(!1,constructor,superConstructor,statics),constructor.prototype=createObject(superConstructor.prototype,prototype),constructor.prototype.constructor=constructor,constructor.class_=name||superConstructor.class_,constructor.super_=superConstructor,constructor}
/**
   * Extends the specified <code>target</code> object with the properties in each of the <code>sources</code> provided.
   *
   * if any source is <code>null</code> it will be ignored.
   *
   * @param {boolean} own - <code>true</code> to only copy <b>own</b> properties from <code>sources</code> onto
   * <code>target</code>; otherwise <code>false</code>
   * @param {Object} target - the target object which should be extended
   * @param {...Object} [sources] - the source objects whose properties are to be copied onto <code>target</code>
   * @return {void}
   * @private
   */function extendObject(own,target,sources){var property,source;sources=slice.call(arguments,2);for(var i=0,length=sources.length;i<length;i++)for(property in source=sources[i],source)own&&!hasOwnProperty.call(source,property)||(target[property]=source[property])}var extend_1=extend;
/**
   * The base class from which all others should extend.
   *
   * @public
   * @constructor
   */function Nevis(){}Nevis.class_="Nevis",Nevis.super_=Object,
/**
   * Extends the constructor to which this method is associated with the <code>prototype</code> and/or
   * <code>statics</code> provided.
   *
   * If <code>name</code> is provided, it will be used as the class name and can be accessed via a special
   * <code>class_</code> property on the child constructor, otherwise the class name of the super constructor will be used
   * instead. The class name may also be used string representation for instances of the child constructor (via
   * <code>toString</code>), but this is not applicable to the <i>lite</i> version of Nevis.
   *
   * If <code>constructor</code> is provided, it will be used as the constructor for the child, otherwise a simple
   * constructor which only calls the super constructor will be used instead.
   *
   * The super constructor can be accessed via a special <code>super_</code> property on the child constructor.
   *
   * @param {string} [name=this.class_] - the class name to be used for the child constructor
   * @param {Function} [constructor] - the constructor for the child
   * @param {Object} [prototype] - the prototype properties to be defined for the child
   * @param {Object} [statics] - the static properties to be defined for the child
   * @return {Function} The child <code>constructor</code> provided or the one created if none was given.
   * @public
   * @static
   * @memberof Nevis
   */
Nevis.extend=extend_1;var nevis=Nevis,lite=nevis,Renderer=lite.extend((function(qrious,element,enabled){
/**
     * The {@link QRious} instance.
     *
     * @protected
     * @type {QRious}
     * @memberof Renderer#
     */
this.qrious=qrious,
/**
     * The element onto which this {@link Renderer} is rendering the QR code.
     *
     * @protected
     * @type {*}
     * @memberof Renderer#
     */
this.element=element,this.element.qrious=qrious,
/**
     * Whether this {@link Renderer} is enabled.
     *
     * @protected
     * @type {boolean}
     * @memberof Renderer#
     */
this.enabled=Boolean(enabled)}),{
/**
     * Draws the specified QR code <code>frame</code> on the underlying element.
     *
     * Implementations of {@link Renderer} <b>must</b> override this method with their own specific logic.
     *
     * @param {Frame} frame - the {@link Frame} to be drawn
     * @return {void}
     * @protected
     * @abstract
     * @memberof Renderer#
     */
draw:function(frame){},
/**
     * Returns the element onto which this {@link Renderer} is rendering the QR code.
     *
     * If this method is called while this {@link Renderer} is disabled, it will be immediately enabled and rendered
     * before the element is returned.
     *
     * @return {*} The element.
     * @public
     * @memberof Renderer#
     */
getElement:function(){return this.enabled||(this.enabled=!0,this.render()),this.element},
/**
     * Calculates the size (in pixel units) to represent an individual module within the QR code based on the
     * <code>frame</code> provided.
     *
     * Any configured padding will be excluded from the returned size.
     *
     * The returned value will be at least one, even in cases where the size of the QR code does not fit its contents.
     * This is done so that the inevitable clipping is handled more gracefully since this way at least something is
     * displayed instead of just a blank space filled by the background color.
     *
     * @param {Frame} frame - the {@link Frame} from which the module size is to be derived
     * @return {number} The pixel size for each module in the QR code which will be no less than one.
     * @protected
     * @memberof Renderer#
     */
getModuleSize:function(frame){var qrious=this.qrious,padding=qrious.padding||0,pixels=Math.floor((qrious.size-2*padding)/frame.width);return Math.max(1,pixels)},
/**
     * Calculates the offset/padding (in pixel units) to be inserted before the QR code based on the <code>frame</code>
     * provided.
     *
     * The returned value will be zero if there is no available offset or if the size of the QR code does not fit its
     * contents. It will never be a negative value. This is done so that the inevitable clipping appears more naturally
     * and it is not clipped from all directions.
     *
     * @param {Frame} frame - the {@link Frame} from which the offset is to be derived
     * @return {number} The pixel offset for the QR code which will be no less than zero.
     * @protected
     * @memberof Renderer#
     */
getOffset:function(frame){var qrious=this.qrious,padding=qrious.padding;if(null!=padding)return padding;var moduleSize=this.getModuleSize(frame),offset=Math.floor((qrious.size-moduleSize*frame.width)/2);return Math.max(0,offset)},
/**
     * Renders a QR code on the underlying element based on the <code>frame</code> provided.
     *
     * @param {Frame} frame - the {@link Frame} to be rendered
     * @return {void}
     * @public
     * @memberof Renderer#
     */
render:function(frame){this.enabled&&(this.resize(),this.reset(),this.draw(frame))},
/**
     * Resets the underlying element, effectively clearing any previously rendered QR code.
     *
     * Implementations of {@link Renderer} <b>must</b> override this method with their own specific logic.
     *
     * @return {void}
     * @protected
     * @abstract
     * @memberof Renderer#
     */
reset:function(){},
/**
     * Ensures that the size of the underlying element matches that defined on the associated {@link QRious} instance.
     *
     * Implementations of {@link Renderer} <b>must</b> override this method with their own specific logic.
     *
     * @return {void}
     * @protected
     * @abstract
     * @memberof Renderer#
     */
resize:function(){}}),Renderer_1=Renderer,CanvasRenderer=Renderer_1.extend({
/**
     * @override
     */
draw:function(frame){var i,j,qrious=this.qrious,moduleSize=this.getModuleSize(frame),offset=this.getOffset(frame),context=this.element.getContext("2d");for(context.fillStyle=qrious.foreground,context.globalAlpha=qrious.foregroundAlpha,i=0;i<frame.width;i++)for(j=0;j<frame.width;j++)frame.buffer[j*frame.width+i]&&context.fillRect(moduleSize*i+offset,moduleSize*j+offset,moduleSize,moduleSize)},
/**
     * @override
     */
reset:function(){var qrious=this.qrious,context=this.element.getContext("2d"),size=qrious.size;context.lineWidth=1,context.clearRect(0,0,size,size),context.fillStyle=qrious.background,context.globalAlpha=qrious.backgroundAlpha,context.fillRect(0,0,size,size)},
/**
     * @override
     */
resize:function(){var element=this.element;element.width=element.height=this.qrious.size}}),CanvasRenderer_1=CanvasRenderer,Alignment=lite.extend(null,{
/**
     * The alignment pattern block.
     *
     * @public
     * @static
     * @type {number[]}
     * @memberof Alignment
     */
BLOCK:[0,11,15,19,23,27,31,16,18,20,22,24,26,28,20,22,24,24,26,28,28,22,24,24,26,26,28,28,24,24,26,26,26,28,28,24,26,26,26,28,28]}),Alignment_1=Alignment,ErrorCorrection=lite.extend(null,{
/**
     * The error correction blocks.
     *
     * There are four elements per version. The first two indicate the number of blocks, then the data width, and finally
     * the ECC width.
     *
     * @public
     * @static
     * @type {number[]}
     * @memberof ErrorCorrection
     */
BLOCKS:[1,0,19,7,1,0,16,10,1,0,13,13,1,0,9,17,1,0,34,10,1,0,28,16,1,0,22,22,1,0,16,28,1,0,55,15,1,0,44,26,2,0,17,18,2,0,13,22,1,0,80,20,2,0,32,18,2,0,24,26,4,0,9,16,1,0,108,26,2,0,43,24,2,2,15,18,2,2,11,22,2,0,68,18,4,0,27,16,4,0,19,24,4,0,15,28,2,0,78,20,4,0,31,18,2,4,14,18,4,1,13,26,2,0,97,24,2,2,38,22,4,2,18,22,4,2,14,26,2,0,116,30,3,2,36,22,4,4,16,20,4,4,12,24,2,2,68,18,4,1,43,26,6,2,19,24,6,2,15,28,4,0,81,20,1,4,50,30,4,4,22,28,3,8,12,24,2,2,92,24,6,2,36,22,4,6,20,26,7,4,14,28,4,0,107,26,8,1,37,22,8,4,20,24,12,4,11,22,3,1,115,30,4,5,40,24,11,5,16,20,11,5,12,24,5,1,87,22,5,5,41,24,5,7,24,30,11,7,12,24,5,1,98,24,7,3,45,28,15,2,19,24,3,13,15,30,1,5,107,28,10,1,46,28,1,15,22,28,2,17,14,28,5,1,120,30,9,4,43,26,17,1,22,28,2,19,14,28,3,4,113,28,3,11,44,26,17,4,21,26,9,16,13,26,3,5,107,28,3,13,41,26,15,5,24,30,15,10,15,28,4,4,116,28,17,0,42,26,17,6,22,28,19,6,16,30,2,7,111,28,17,0,46,28,7,16,24,30,34,0,13,24,4,5,121,30,4,14,47,28,11,14,24,30,16,14,15,30,6,4,117,30,6,14,45,28,11,16,24,30,30,2,16,30,8,4,106,26,8,13,47,28,7,22,24,30,22,13,15,30,10,2,114,28,19,4,46,28,28,6,22,28,33,4,16,30,8,4,122,30,22,3,45,28,8,26,23,30,12,28,15,30,3,10,117,30,3,23,45,28,4,31,24,30,11,31,15,30,7,7,116,30,21,7,45,28,1,37,23,30,19,26,15,30,5,10,115,30,19,10,47,28,15,25,24,30,23,25,15,30,13,3,115,30,2,29,46,28,42,1,24,30,23,28,15,30,17,0,115,30,10,23,46,28,10,35,24,30,19,35,15,30,17,1,115,30,14,21,46,28,29,19,24,30,11,46,15,30,13,6,115,30,14,23,46,28,44,7,24,30,59,1,16,30,12,7,121,30,12,26,47,28,39,14,24,30,22,41,15,30,6,14,121,30,6,34,47,28,46,10,24,30,2,64,15,30,17,4,122,30,29,14,46,28,49,10,24,30,24,46,15,30,4,18,122,30,13,32,46,28,48,14,24,30,42,32,15,30,20,4,117,30,40,7,47,28,43,22,24,30,10,67,15,30,19,6,118,30,18,31,47,28,34,34,24,30,20,61,15,30],
/**
     * The final format bits with mask (level << 3 | mask).
     *
     * @public
     * @static
     * @type {number[]}
     * @memberof ErrorCorrection
     */
FINAL_FORMAT:[
// L
30660,29427,32170,30877,26159,25368,27713,26998,
// M
21522,20773,24188,23371,17913,16590,20375,19104,
// Q
13663,12392,16177,14854,9396,8579,11994,11245,
// H
5769,5054,7399,6608,1890,597,3340,2107],
/**
     * A map of human-readable ECC levels.
     *
     * @public
     * @static
     * @type {Object.<string, number>}
     * @memberof ErrorCorrection
     */
LEVELS:{L:1,M:2,Q:3,H:4}}),ErrorCorrection_1=ErrorCorrection,Galois=lite.extend(null,{
/**
     * The Galois field exponent table.
     *
     * @public
     * @static
     * @type {number[]}
     * @memberof Galois
     */
EXPONENT:[1,2,4,8,16,32,64,128,29,58,116,232,205,135,19,38,76,152,45,90,180,117,234,201,143,3,6,12,24,48,96,192,157,39,78,156,37,74,148,53,106,212,181,119,238,193,159,35,70,140,5,10,20,40,80,160,93,186,105,210,185,111,222,161,95,190,97,194,153,47,94,188,101,202,137,15,30,60,120,240,253,231,211,187,107,214,177,127,254,225,223,163,91,182,113,226,217,175,67,134,17,34,68,136,13,26,52,104,208,189,103,206,129,31,62,124,248,237,199,147,59,118,236,197,151,51,102,204,133,23,46,92,184,109,218,169,79,158,33,66,132,21,42,84,168,77,154,41,82,164,85,170,73,146,57,114,228,213,183,115,230,209,191,99,198,145,63,126,252,229,215,179,123,246,241,255,227,219,171,75,150,49,98,196,149,55,110,220,165,87,174,65,130,25,50,100,200,141,7,14,28,56,112,224,221,167,83,166,81,162,89,178,121,242,249,239,195,155,43,86,172,69,138,9,18,36,72,144,61,122,244,245,247,243,251,235,203,139,11,22,44,88,176,125,250,233,207,131,27,54,108,216,173,71,142,0],
/**
     * The Galois field log table.
     *
     * @public
     * @static
     * @type {number[]}
     * @memberof Galois
     */
LOG:[255,0,1,25,2,50,26,198,3,223,51,238,27,104,199,75,4,100,224,14,52,141,239,129,28,193,105,248,200,8,76,113,5,138,101,47,225,36,15,33,53,147,142,218,240,18,130,69,29,181,194,125,106,39,249,185,201,154,9,120,77,228,114,166,6,191,139,98,102,221,48,253,226,152,37,179,16,145,34,136,54,208,148,206,143,150,219,189,241,210,19,92,131,56,70,64,30,66,182,163,195,72,126,110,107,58,40,84,250,133,186,61,202,94,155,159,10,21,121,43,78,212,229,172,115,243,167,87,7,112,192,247,140,128,99,13,103,74,222,237,49,197,254,24,227,165,153,119,38,184,180,124,17,68,146,217,35,32,137,46,55,63,209,91,149,188,207,205,144,135,151,178,220,252,190,97,242,86,211,171,20,42,93,158,132,60,57,83,71,109,65,162,31,45,67,216,183,123,164,118,196,23,73,236,127,12,111,246,108,161,59,82,41,157,85,170,251,96,134,177,187,204,62,90,203,89,95,176,156,169,160,81,11,245,22,235,122,117,44,215,79,174,213,233,230,231,173,232,116,214,244,234,168,80,88,175]}),Galois_1=Galois,Version=lite.extend(null,{
/**
     * The version pattern block.
     *
     * @public
     * @static
     * @type {number[]}
     * @memberof Version
     */
BLOCK:[3220,1468,2713,1235,3062,1890,2119,1549,2344,2936,1117,2583,1330,2470,1667,2249,2028,3780,481,4011,142,3098,831,3445,592,2517,1776,2234,1951,2827,1070,2660,1345,3177]}),Version_1=Version,Frame=lite.extend((function(options){var dataBlock,eccBlock,index,neccBlock1,neccBlock2,valueLength=options.value.length;this._badness=[],this._level=ErrorCorrection_1.LEVELS[options.level],this._polynomial=[],this._value=options.value,this._version=0,this._stringBuffer=[];while(this._version<40)if(this._version++,index=4*(this._level-1)+16*(this._version-1),neccBlock1=ErrorCorrection_1.BLOCKS[index++],neccBlock2=ErrorCorrection_1.BLOCKS[index++],dataBlock=ErrorCorrection_1.BLOCKS[index++],eccBlock=ErrorCorrection_1.BLOCKS[index],index=dataBlock*(neccBlock1+neccBlock2)+neccBlock2-3+(this._version<=9),valueLength<=index)break;this._dataBlock=dataBlock,this._eccBlock=eccBlock,this._neccBlock1=neccBlock1,this._neccBlock2=neccBlock2;
/**
     * The data width is based on version.
     *
     * @public
     * @type {number}
     * @memberof Frame#
     */
// FIXME: Ensure that it fits instead of being truncated.
var width=this.width=17+4*this._version;
/**
     * The image buffer.
     *
     * @public
     * @type {number[]}
     * @memberof Frame#
     */this.buffer=Frame._createArray(width*width),this._ecc=Frame._createArray(dataBlock+(dataBlock+eccBlock)*(neccBlock1+neccBlock2)+neccBlock2),this._mask=Frame._createArray((width*(width+1)+1)/2),this._insertFinders(),this._insertAlignments(),
// Insert single foreground cell.
this.buffer[8+width*(width-8)]=1,this._insertTimingGap(),this._reverseMask(),this._insertTimingRowAndColumn(),this._insertVersion(),this._syncMask(),this._convertBitStream(valueLength),this._calculatePolynomial(),this._appendEccToData(),this._interleaveBlocks(),this._pack(),this._finish()}),{_addAlignment:function(x,y){var i,buffer=this.buffer,width=this.width;for(buffer[x+width*y]=1,i=-2;i<2;i++)buffer[x+i+width*(y-2)]=1,buffer[x-2+width*(y+i+1)]=1,buffer[x+2+width*(y+i)]=1,buffer[x+i+1+width*(y+2)]=1;for(i=0;i<2;i++)this._setMask(x-1,y+i),this._setMask(x+1,y-i),this._setMask(x-i,y-1),this._setMask(x+i,y+1)},_appendData:function(data,dataLength,ecc,eccLength){var bit,i,j,polynomial=this._polynomial,stringBuffer=this._stringBuffer;for(i=0;i<eccLength;i++)stringBuffer[ecc+i]=0;for(i=0;i<dataLength;i++){if(bit=Galois_1.LOG[stringBuffer[data+i]^stringBuffer[ecc]],255!==bit)for(j=1;j<eccLength;j++)stringBuffer[ecc+j-1]=stringBuffer[ecc+j]^Galois_1.EXPONENT[Frame._modN(bit+polynomial[eccLength-j])];else for(j=ecc;j<ecc+eccLength;j++)stringBuffer[j]=stringBuffer[j+1];stringBuffer[ecc+eccLength-1]=255===bit?0:Galois_1.EXPONENT[Frame._modN(bit+polynomial[0])]}},_appendEccToData:function(){var i,data=0,dataBlock=this._dataBlock,ecc=this._calculateMaxLength(),eccBlock=this._eccBlock;for(i=0;i<this._neccBlock1;i++)this._appendData(data,dataBlock,ecc,eccBlock),data+=dataBlock,ecc+=eccBlock;for(i=0;i<this._neccBlock2;i++)this._appendData(data,dataBlock+1,ecc,eccBlock),data+=dataBlock+1,ecc+=eccBlock},_applyMask:function(mask){var r3x,r3y,x,y,buffer=this.buffer,width=this.width;switch(mask){case 0:for(y=0;y<width;y++)for(x=0;x<width;x++)x+y&1||this._isMasked(x,y)||(buffer[x+y*width]^=1);break;case 1:for(y=0;y<width;y++)for(x=0;x<width;x++)1&y||this._isMasked(x,y)||(buffer[x+y*width]^=1);break;case 2:for(y=0;y<width;y++)for(r3x=0,x=0;x<width;x++,r3x++)3===r3x&&(r3x=0),r3x||this._isMasked(x,y)||(buffer[x+y*width]^=1);break;case 3:for(r3y=0,y=0;y<width;y++,r3y++)for(3===r3y&&(r3y=0),r3x=r3y,x=0;x<width;x++,r3x++)3===r3x&&(r3x=0),r3x||this._isMasked(x,y)||(buffer[x+y*width]^=1);break;case 4:for(y=0;y<width;y++)for(r3x=0,r3y=y>>1&1,x=0;x<width;x++,r3x++)3===r3x&&(r3x=0,r3y=!r3y),r3y||this._isMasked(x,y)||(buffer[x+y*width]^=1);break;case 5:for(r3y=0,y=0;y<width;y++,r3y++)for(3===r3y&&(r3y=0),r3x=0,x=0;x<width;x++,r3x++)3===r3x&&(r3x=0),(x&y&1)+!(!r3x|!r3y)||this._isMasked(x,y)||(buffer[x+y*width]^=1);break;case 6:for(r3y=0,y=0;y<width;y++,r3y++)for(3===r3y&&(r3y=0),r3x=0,x=0;x<width;x++,r3x++)3===r3x&&(r3x=0),(x&y&1)+(r3x&&r3x===r3y)&1||this._isMasked(x,y)||(buffer[x+y*width]^=1);break;case 7:for(r3y=0,y=0;y<width;y++,r3y++)for(3===r3y&&(r3y=0),r3x=0,x=0;x<width;x++,r3x++)3===r3x&&(r3x=0),(r3x&&r3x===r3y)+(x+y&1)&1||this._isMasked(x,y)||(buffer[x+y*width]^=1);break}},_calculateMaxLength:function(){return this._dataBlock*(this._neccBlock1+this._neccBlock2)+this._neccBlock2},_calculatePolynomial:function(){var i,j,eccBlock=this._eccBlock,polynomial=this._polynomial;for(polynomial[0]=1,i=0;i<eccBlock;i++){for(polynomial[i+1]=1,j=i;j>0;j--)polynomial[j]=polynomial[j]?polynomial[j-1]^Galois_1.EXPONENT[Frame._modN(Galois_1.LOG[polynomial[j]]+i)]:polynomial[j-1];polynomial[0]=Galois_1.EXPONENT[Frame._modN(Galois_1.LOG[polynomial[0]]+i)]}
// Use logs for generator polynomial to save calculation step.
for(i=0;i<=eccBlock;i++)polynomial[i]=Galois_1.LOG[polynomial[i]]},_checkBadness:function(){var b,b1,h,x,y,bad=0,badness=this._badness,buffer=this.buffer,width=this.width;
// Blocks of same colour.
for(y=0;y<width-1;y++)for(x=0;x<width-1;x++)
// All foreground colour.
(buffer[x+width*y]&&buffer[x+1+width*y]&&buffer[x+width*(y+1)]&&buffer[x+1+width*(y+1)]||
// All background colour.
!(buffer[x+width*y]||buffer[x+1+width*y]||buffer[x+width*(y+1)]||buffer[x+1+width*(y+1)]))&&(bad+=Frame.N2);var bw=0;
// X runs.
for(y=0;y<width;y++){for(h=0,badness[0]=0,b=0,x=0;x<width;x++)b1=buffer[x+width*y],b===b1?badness[h]++:badness[++h]=1,b=b1,bw+=b?1:-1;bad+=this._getBadness(h)}bw<0&&(bw=-bw);var count=0,big=bw;big+=big<<2,big<<=1;while(big>width*width)big-=width*width,count++;
// Y runs.
for(bad+=count*Frame.N4,x=0;x<width;x++){for(h=0,badness[0]=0,b=0,y=0;y<width;y++)b1=buffer[x+width*y],b===b1?badness[h]++:badness[++h]=1,b=b1;bad+=this._getBadness(h)}return bad},_convertBitStream:function(length){var bit,i,ecc=this._ecc,version=this._version;
// Convert string to bit stream. 8-bit data to QR-coded 8-bit data (numeric, alphanumeric, or kanji not supported).
for(i=0;i<length;i++)ecc[i]=this._value.charCodeAt(i);var stringBuffer=this._stringBuffer=ecc.slice(),maxLength=this._calculateMaxLength();length>=maxLength-2&&(length=maxLength-2,version>9&&length--);
// Shift and re-pack to insert length prefix.
var index=length;if(version>9){stringBuffer[index+2]=0,stringBuffer[index+3]=0;while(index--)bit=stringBuffer[index],stringBuffer[index+3]|=255&bit<<4,stringBuffer[index+2]=bit>>4;stringBuffer[2]|=255&length<<4,stringBuffer[1]=length>>4,stringBuffer[0]=64|length>>12}else{stringBuffer[index+1]=0,stringBuffer[index+2]=0;while(index--)bit=stringBuffer[index],stringBuffer[index+2]|=255&bit<<4,stringBuffer[index+1]=bit>>4;stringBuffer[1]|=255&length<<4,stringBuffer[0]=64|length>>4}
// Fill to end with pad pattern.
index=length+3-(version<10);while(index<maxLength)stringBuffer[index++]=236,stringBuffer[index++]=17},_getBadness:function(length){var i,badRuns=0,badness=this._badness;for(i=0;i<=length;i++)badness[i]>=5&&(badRuns+=Frame.N1+badness[i]-5);
// FBFFFBF as in finder.
for(i=3;i<length-1;i+=2)badness[i-2]===badness[i+2]&&badness[i+2]===badness[i-1]&&badness[i-1]===badness[i+1]&&3*badness[i-1]===badness[i]&&(
// Background around the foreground pattern? Not part of the specs.
0===badness[i-3]||i+3>length||3*badness[i-3]>=4*badness[i]||3*badness[i+3]>=4*badness[i])&&(badRuns+=Frame.N3);return badRuns},_finish:function(){var currentMask,i;
// Save pre-mask copy of frame.
this._stringBuffer=this.buffer.slice();var bit=0,mask=3e4;
/*
       * Using for instead of while since in original Arduino code if an early mask was "good enough" it wouldn't try for
       * a better one since they get more complex and take longer.
       */
for(i=0;i<8;i++){
// Don't increment "i" to a void redoing mask.
if(
// Returns foreground-background imbalance.
this._applyMask(i),currentMask=this._checkBadness(),
// Is current mask better than previous best?
currentMask<mask&&(mask=currentMask,bit=i),7===bit)break;
// Reset for next pass.
this.buffer=this._stringBuffer.slice()}
// Redo best mask as none were "good enough" (i.e. last wasn't bit).
bit!==i&&this._applyMask(bit),
// Add in final mask/ECC level bytes.
mask=ErrorCorrection_1.FINAL_FORMAT[bit+(this._level-1<<3)];var buffer=this.buffer,width=this.width;
// Low byte.
for(i=0;i<8;i++,mask>>=1)1&mask&&(buffer[width-1-i+8*width]=1,i<6?buffer[8+width*i]=1:buffer[8+width*(i+1)]=1);
// High byte.
for(i=0;i<7;i++,mask>>=1)1&mask&&(buffer[8+width*(width-7+i)]=1,i?buffer[6-i+8*width]=1:buffer[7+8*width]=1)},_interleaveBlocks:function(){var i,j,dataBlock=this._dataBlock,ecc=this._ecc,eccBlock=this._eccBlock,k=0,maxLength=this._calculateMaxLength(),neccBlock1=this._neccBlock1,neccBlock2=this._neccBlock2,stringBuffer=this._stringBuffer;for(i=0;i<dataBlock;i++){for(j=0;j<neccBlock1;j++)ecc[k++]=stringBuffer[i+j*dataBlock];for(j=0;j<neccBlock2;j++)ecc[k++]=stringBuffer[neccBlock1*dataBlock+i+j*(dataBlock+1)]}for(j=0;j<neccBlock2;j++)ecc[k++]=stringBuffer[neccBlock1*dataBlock+i+j*(dataBlock+1)];for(i=0;i<eccBlock;i++)for(j=0;j<neccBlock1+neccBlock2;j++)ecc[k++]=stringBuffer[maxLength+i+j*eccBlock];this._stringBuffer=ecc},_insertAlignments:function(){var i,x,y,version=this._version,width=this.width;if(version>1)for(i=Alignment_1.BLOCK[version],y=width-7;;){x=width-7;while(x>i-3){if(this._addAlignment(x,y),x<i)break;x-=i}if(y<=i+9)break;y-=i,this._addAlignment(6,y),this._addAlignment(y,6)}},_insertFinders:function(){var i,j,x,y,buffer=this.buffer,width=this.width;for(i=0;i<3;i++){for(j=0,y=0,1===i&&(j=width-7),2===i&&(y=width-7),buffer[y+3+width*(j+3)]=1,x=0;x<6;x++)buffer[y+x+width*j]=1,buffer[y+width*(j+x+1)]=1,buffer[y+6+width*(j+x)]=1,buffer[y+x+1+width*(j+6)]=1;for(x=1;x<5;x++)this._setMask(y+x,j+1),this._setMask(y+1,j+x+1),this._setMask(y+5,j+x),this._setMask(y+x+1,j+5);for(x=2;x<4;x++)buffer[y+x+width*(j+2)]=1,buffer[y+2+width*(j+x+1)]=1,buffer[y+4+width*(j+x)]=1,buffer[y+x+1+width*(j+4)]=1}},_insertTimingGap:function(){var x,y,width=this.width;for(y=0;y<7;y++)this._setMask(7,y),this._setMask(width-8,y),this._setMask(7,y+width-7);for(x=0;x<8;x++)this._setMask(x,7),this._setMask(x+width-8,7),this._setMask(x,width-8)},_insertTimingRowAndColumn:function(){var x,buffer=this.buffer,width=this.width;for(x=0;x<width-14;x++)1&x?(this._setMask(8+x,6),this._setMask(6,8+x)):(buffer[8+x+6*width]=1,buffer[6+width*(8+x)]=1)},_insertVersion:function(){var i,j,x,y,buffer=this.buffer,version=this._version,width=this.width;if(version>6)for(i=Version_1.BLOCK[version-7],j=17,x=0;x<6;x++)for(y=0;y<3;y++,j--)1&(j>11?version>>j-12:i>>j)?(buffer[5-x+width*(2-y+width-11)]=1,buffer[2-y+width-11+width*(5-x)]=1):(this._setMask(5-x,2-y+width-11),this._setMask(2-y+width-11,5-x))},_isMasked:function(x,y){var bit=Frame._getMaskBit(x,y);return 1===this._mask[bit]},_pack:function(){var bit,i,j,k=1,v=1,width=this.width,x=width-1,y=width-1,length=(this._dataBlock+this._eccBlock)*(this._neccBlock1+this._neccBlock2)+this._neccBlock2;for(i=0;i<length;i++)for(bit=this._stringBuffer[i],j=0;j<8;j++,bit<<=1){128&bit&&(this.buffer[x+width*y]=1);
// Find next fill position.
do{v?x--:(x++,k?0!==y?y--:(x-=2,k=!k,6===x&&(x--,y=9)):y!==width-1?y++:(x-=2,k=!k,6===x&&(x--,y-=8))),v=!v}while(this._isMasked(x,y))}},_reverseMask:function(){var x,y,width=this.width;for(x=0;x<9;x++)this._setMask(x,8);for(x=0;x<8;x++)this._setMask(x+width-8,8),this._setMask(8,x);for(y=0;y<7;y++)this._setMask(8,y+width-7)},_setMask:function(x,y){var bit=Frame._getMaskBit(x,y);this._mask[bit]=1},_syncMask:function(){var x,y,width=this.width;for(y=0;y<width;y++)for(x=0;x<=y;x++)this.buffer[x+width*y]&&this._setMask(x,y)}},{_createArray:function(length){var i,array=[];for(i=0;i<length;i++)array[i]=0;return array},_getMaskBit:function(x,y){var bit;return x>y&&(bit=x,x=y,y=bit),bit=y,bit+=y*y,bit>>=1,bit+=x,bit},_modN:function(x){while(x>=255)x-=255,x=(x>>8)+(255&x);return x},
// *Badness* coefficients.
N1:3,N2:3,N3:40,N4:10}),Frame_1=Frame,ImageRenderer=Renderer_1.extend({
/**
     * @override
     */
draw:function(){this.element.src=this.qrious.toDataURL()},
/**
     * @override
     */
reset:function(){this.element.src=""},
/**
     * @override
     */
resize:function(){var element=this.element;element.width=element.height=this.qrious.size}}),ImageRenderer_1=ImageRenderer,Option=lite.extend((function(name,modifiable,defaultValue,valueTransformer){
/**
     * The name for this {@link Option}.
     *
     * @public
     * @type {string}
     * @memberof Option#
     */
this.name=name,
/**
     * Whether a setter should be included on the property defined on target objects for this {@link Option}.
     *
     * @public
     * @type {boolean}
     * @memberof Option#
     */
this.modifiable=Boolean(modifiable),
/**
     * The default value for this {@link Option}.
     *
     * @public
     * @type {*}
     * @memberof Option#
     */
this.defaultValue=defaultValue,this._valueTransformer=valueTransformer}),{
/**
     * Transforms the specified <code>value</code> so that it can be applied for this {@link Option}.
     *
     * If a value transformer has been specified for this {@link Option}, it will be called upon to transform
     * <code>value</code>. Otherwise, <code>value</code> will be returned directly.
     *
     * @param {*} value - the value to be transformed
     * @return {*} The transformed value or <code>value</code> if no value transformer is specified.
     * @public
     * @memberof Option#
     */
transform:function(value){var transformer=this._valueTransformer;return"function"===typeof transformer?transformer(value,this):value}}),Option_1=Option,Utilities=lite.extend(null,{
/**
     * Returns the absolute value of a given number.
     *
     * This method is simply a convenient shorthand for <code>Math.abs</code> while ensuring that nulls are returned as
     * <code>null</code> instead of zero.
     *
     * @param {number} value - the number whose absolute value is to be returned
     * @return {number} The absolute value of <code>value</code> or <code>null</code> if <code>value</code> is
     * <code>null</code>.
     * @public
     * @static
     * @memberof Utilities
     */
abs:function(value){return null!=value?Math.abs(value):null},
/**
     * Returns whether the specified <code>object</code> has a property with the specified <code>name</code> as an own
     * (not inherited) property.
     *
     * @param {Object} object - the object on which the property is to be checked
     * @param {string} name - the name of the property to be checked
     * @return {boolean} <code>true</code> if <code>object</code> has an own property with <code>name</code>.
     * @public
     * @static
     * @memberof Utilities
     */
hasOwn:function(object,name){return Object.prototype.hasOwnProperty.call(object,name)},
/**
     * A non-operation method that does absolutely nothing.
     *
     * @return {void}
     * @public
     * @static
     * @memberof Utilities
     */
noop:function(){},
/**
     * Transforms the specified <code>string</code> to upper case while remaining null-safe.
     *
     * @param {string} string - the string to be transformed to upper case
     * @return {string} <code>string</code> transformed to upper case if <code>string</code> is not <code>null</code>.
     * @public
     * @static
     * @memberof Utilities
     */
toUpperCase:function(string){return null!=string?string.toUpperCase():null}}),Utilities_1=Utilities,OptionManager=lite.extend((function(options){
/**
     * The available options for this {@link OptionManager}.
     *
     * @public
     * @type {Object.<string, Option>}
     * @memberof OptionManager#
     */
this.options={},options.forEach((function(option){this.options[option.name]=option}),this)}),{
/**
     * Returns whether an option with the specified <code>name</code> is available.
     *
     * @param {string} name - the name of the {@link Option} whose existence is to be checked
     * @return {boolean} <code>true</code> if an {@link Option} exists with <code>name</code>; otherwise
     * <code>false</code>.
     * @public
     * @memberof OptionManager#
     */
exists:function(name){return null!=this.options[name]},
/**
     * Returns the value of the option with the specified <code>name</code> on the <code>target</code> object provided.
     *
     * @param {string} name - the name of the {@link Option} whose value on <code>target</code> is to be returned
     * @param {Object} target - the object from which the value of the named {@link Option} is to be returned
     * @return {*} The value of the {@link Option} with <code>name</code> on <code>target</code>.
     * @public
     * @memberof OptionManager#
     */
get:function(name,target){return OptionManager._get(this.options[name],target)},
/**
     * Returns a copy of all of the available options on the <code>target</code> object provided.
     *
     * @param {Object} target - the object from which the option name/value pairs are to be returned
     * @return {Object.<string, *>} A hash containing the name/value pairs of all options on <code>target</code>.
     * @public
     * @memberof OptionManager#
     */
getAll:function(target){var name,options=this.options,result={};for(name in options)Utilities_1.hasOwn(options,name)&&(result[name]=OptionManager._get(options[name],target));return result},
/**
     * Initializes the available options for the <code>target</code> object provided and then applies the initial values
     * within the speciifed <code>options</code>.
     *
     * This method will throw an error if any of the names within <code>options</code> does not match an available option.
     *
     * This involves setting the default values and defining properties for all of the available options on
     * <code>target</code> before finally calling {@link OptionMananger#setAll} with <code>options</code> and
     * <code>target</code>. Any options that are configured to be modifiable will have a setter included in their defined
     * property that will allow its corresponding value to be modified.
     *
     * If a change handler is specified, it will be called whenever the value changes on <code>target</code> for a
     * modifiable option, but only when done so via the defined property's setter.
     *
     * @param {Object.<string, *>} options - the name/value pairs of the initial options to be set
     * @param {Object} target - the object on which the options are to be initialized
     * @param {Function} [changeHandler] - the function to be called whenever the value of an modifiable option changes on
     * <code>target</code>
     * @return {void}
     * @throws {Error} If <code>options</code> contains an invalid option name.
     * @public
     * @memberof OptionManager#
     */
init:function(options,target,changeHandler){var name,option;for(name in"function"!==typeof changeHandler&&(changeHandler=Utilities_1.noop),this.options)Utilities_1.hasOwn(this.options,name)&&(option=this.options[name],OptionManager._set(option,option.defaultValue,target),OptionManager._createAccessor(option,target,changeHandler));this._setAll(options,target,!0)},
/**
     * Sets the value of the option with the specified <code>name</code> on the <code>target</code> object provided to
     * <code>value</code>.
     *
     * This method will throw an error if <code>name</code> does not match an available option or matches an option that
     * cannot be modified.
     *
     * If <code>value</code> is <code>null</code> and the {@link Option} has a default value configured, then that default
     * value will be used instead. If the {@link Option} also has a value transformer configured, it will be used to
     * transform whichever value was determined to be used.
     *
     * This method returns whether the value of the underlying field on <code>target</code> was changed as a result.
     *
     * @param {string} name - the name of the {@link Option} whose value is to be set
     * @param {*} value - the value to be set for the named {@link Option} on <code>target</code>
     * @param {Object} target - the object on which <code>value</code> is to be set for the named {@link Option}
     * @return {boolean} <code>true</code> if the underlying field on <code>target</code> was changed; otherwise
     * <code>false</code>.
     * @throws {Error} If <code>name</code> is invalid or is for an option that cannot be modified.
     * @public
     * @memberof OptionManager#
     */
set:function(name,value,target){return this._set(name,value,target)},
/**
     * Sets all of the specified <code>options</code> on the <code>target</code> object provided to their corresponding
     * values.
     *
     * This method will throw an error if any of the names within <code>options</code> does not match an available option
     * or matches an option that cannot be modified.
     *
     * If any value within <code>options</code> is <code>null</code> and the corresponding {@link Option} has a default
     * value configured, then that default value will be used instead. If an {@link Option} also has a value transformer
     * configured, it will be used to transform whichever value was determined to be used.
     *
     * This method returns whether the value for any of the underlying fields on <code>target</code> were changed as a
     * result.
     *
     * @param {Object.<string, *>} options - the name/value pairs of options to be set
     * @param {Object} target - the object on which the options are to be set
     * @return {boolean} <code>true</code> if any of the underlying fields on <code>target</code> were changed; otherwise
     * <code>false</code>.
     * @throws {Error} If <code>options</code> contains an invalid option name or an option that cannot be modiifed.
     * @public
     * @memberof OptionManager#
     */
setAll:function(options,target){return this._setAll(options,target)},_set:function(name,value,target,allowUnmodifiable){var option=this.options[name];if(!option)throw new Error("Invalid option: "+name);if(!option.modifiable&&!allowUnmodifiable)throw new Error("Option cannot be modified: "+name);return OptionManager._set(option,value,target)},_setAll:function(options,target,allowUnmodifiable){if(!options)return!1;var name,changed=!1;for(name in options)Utilities_1.hasOwn(options,name)&&this._set(name,options[name],target,allowUnmodifiable)&&(changed=!0);return changed}},{_createAccessor:function(option,target,changeHandler){var descriptor={get:function(){return OptionManager._get(option,target)}};option.modifiable&&(descriptor.set=function(value){OptionManager._set(option,value,target)&&changeHandler(value,option)}),Object.defineProperty(target,option.name,descriptor)},_get:function(option,target){return target["_"+option.name]},_set:function(option,value,target){var fieldName="_"+option.name,oldValue=target[fieldName],newValue=option.transform(null!=value?value:option.defaultValue);return target[fieldName]=newValue,newValue!==oldValue}}),OptionManager_1=OptionManager,ServiceManager=lite.extend((function(){this._services={}}),{
/**
     * Returns the {@link Service} being managed with the specified <code>name</code>.
     *
     * @param {string} name - the name of the {@link Service} to be returned
     * @return {Service} The {@link Service} is being managed with <code>name</code>.
     * @throws {Error} If no {@link Service} is being managed with <code>name</code>.
     * @public
     * @memberof ServiceManager#
     */
getService:function(name){var service=this._services[name];if(!service)throw new Error("Service is not being managed with name: "+name);return service},
/**
     * Sets the {@link Service} implementation to be managed for the specified <code>name</code> to the
     * <code>service</code> provided.
     *
     * @param {string} name - the name of the {@link Service} to be managed with <code>name</code>
     * @param {Service} service - the {@link Service} implementation to be managed
     * @return {void}
     * @throws {Error} If a {@link Service} is already being managed with the same <code>name</code>.
     * @public
     * @memberof ServiceManager#
     */
setService:function(name,service){if(this._services[name])throw new Error("Service is already managed with name: "+name);service&&(this._services[name]=service)}}),ServiceManager_1=ServiceManager,optionManager=new OptionManager_1([new Option_1("background",!0,"white"),new Option_1("backgroundAlpha",!0,1,Utilities_1.abs),new Option_1("element"),new Option_1("foreground",!0,"black"),new Option_1("foregroundAlpha",!0,1,Utilities_1.abs),new Option_1("level",!0,"L",Utilities_1.toUpperCase),new Option_1("mime",!0,"image/png"),new Option_1("padding",!0,null,Utilities_1.abs),new Option_1("size",!0,100,Utilities_1.abs),new Option_1("value",!0,"")]),serviceManager=new ServiceManager_1,QRious=lite.extend((function(options){optionManager.init(options,this,this.update.bind(this));var element=optionManager.get("element",this),elementService=serviceManager.getService("element"),canvas=element&&elementService.isCanvas(element)?element:elementService.createCanvas(),image=element&&elementService.isImage(element)?element:elementService.createImage();this._canvasRenderer=new CanvasRenderer_1(this,canvas,!0),this._imageRenderer=new ImageRenderer_1(this,image,image===element),this.update()}),{
/**
     * Returns all of the options configured for this {@link QRious}.
     *
     * Any changes made to the returned object will not be reflected in the options themselves or their corresponding
     * underlying fields.
     *
     * @return {Object.<string, *>} A copy of the applied options.
     * @public
     * @memberof QRious#
     */
get:function(){return optionManager.getAll(this)},
/**
     * Sets all of the specified <code>options</code> and automatically updates this {@link QRious} if any of the
     * underlying fields are changed as a result.
     *
     * This is the preferred method for updating multiple options at one time to avoid unnecessary updates between
     * changes.
     *
     * @param {QRious~Options} options - the options to be set
     * @return {void}
     * @throws {Error} If any <code>options</code> are invalid or cannot be modified.
     * @public
     * @memberof QRious#
     */
set:function(options){optionManager.setAll(options,this)&&this.update()},
/**
     * Returns the image data URI for the generated QR code using the <code>mime</code> provided.
     *
     * @param {string} [mime] - the MIME type for the image
     * @return {string} The image data URI for the QR code.
     * @public
     * @memberof QRious#
     */
toDataURL:function(mime){return this.canvas.toDataURL(mime||this.mime)},
/**
     * Updates this {@link QRious} by generating a new {@link Frame} and re-rendering the QR code.
     *
     * @return {void}
     * @protected
     * @memberof QRious#
     */
update:function(){var frame=new Frame_1({level:this.level,value:this.value});this._canvasRenderer.render(frame),this._imageRenderer.render(frame)}},{
/**
     * Configures the <code>service</code> provided to be used by all {@link QRious} instances.
     *
     * @param {Service} service - the {@link Service} to be configured
     * @return {void}
     * @throws {Error} If a {@link Service} has already been configured with the same name.
     * @public
     * @static
     * @memberof QRious
     */
use:function(service){serviceManager.setService(service.getName(),service)}});Object.defineProperties(QRious.prototype,{canvas:{
/**
       * Returns the <code>canvas</code> element being used to render the QR code for this {@link QRious}.
       *
       * @return {*} The <code>canvas</code> element.
       * @public
       * @memberof QRious#
       * @alias canvas
       */
get:function(){return this._canvasRenderer.getElement()}},image:{
/**
       * Returns the <code>img</code> element being used to render the QR code for this {@link QRious}.
       *
       * @return {*} The <code>img</code> element.
       * @public
       * @memberof QRious#
       * @alias image
       */
get:function(){return this._imageRenderer.getElement()}}});var QRious_1$2=QRious,index=QRious_1$2,Service=lite.extend({
/**
     * Returns the name of this {@link Service}.
     *
     * @return {string} The service name.
     * @public
     * @abstract
     * @memberof Service#
     */
getName:function(){}}),Service_1=Service,ElementService=Service_1.extend({
/**
     * Creates an instance of a canvas element.
     *
     * Implementations of {@link ElementService} <b>must</b> override this method with their own specific logic.
     *
     * @return {*} The newly created canvas element.
     * @public
     * @abstract
     * @memberof ElementService#
     */
createCanvas:function(){},
/**
     * Creates an instance of a image element.
     *
     * Implementations of {@link ElementService} <b>must</b> override this method with their own specific logic.
     *
     * @return {*} The newly created image element.
     * @public
     * @abstract
     * @memberof ElementService#
     */
createImage:function(){},
/**
     * @override
     */
getName:function(){return"element"},
/**
     * Returns whether the specified <code>element</code> is a canvas.
     *
     * Implementations of {@link ElementService} <b>must</b> override this method with their own specific logic.
     *
     * @param {*} element - the element to be checked
     * @return {boolean} <code>true</code> if <code>element</code> is a canvas; otherwise <code>false</code>.
     * @public
     * @abstract
     * @memberof ElementService#
     */
isCanvas:function(element){},
/**
     * Returns whether the specified <code>element</code> is an image.
     *
     * Implementations of {@link ElementService} <b>must</b> override this method with their own specific logic.
     *
     * @param {*} element - the element to be checked
     * @return {boolean} <code>true</code> if <code>element</code> is an image; otherwise <code>false</code>.
     * @public
     * @abstract
     * @memberof ElementService#
     */
isImage:function(element){}}),ElementService_1=ElementService,BrowserElementService=ElementService_1.extend({
/**
     * @override
     */
createCanvas:function(){return document.createElement("canvas")},
/**
     * @override
     */
createImage:function(){return document.createElement("img")},
/**
     * @override
     */
isCanvas:function(element){return element instanceof HTMLCanvasElement},
/**
     * @override
     */
isImage:function(element){return element instanceof HTMLImageElement}}),BrowserElementService_1=BrowserElementService;
/**
   * The options used by {@link QRious}.
   *
   * @typedef {Object} QRious~Options
   * @property {string} [background="white"] - The background color to be applied to the QR code.
   * @property {number} [backgroundAlpha=1] - The background alpha to be applied to the QR code.
   * @property {*} [element] - The element to be used to render the QR code which may either be an <code>canvas</code> or
   * <code>img</code>. The element(s) will be created if needed.
   * @property {string} [foreground="black"] - The foreground color to be applied to the QR code.
   * @property {number} [foregroundAlpha=1] - The foreground alpha to be applied to the QR code.
   * @property {string} [level="L"] - The error correction level to be applied to the QR code.
   * @property {string} [mime="image/png"] - The MIME type to be used to render the image for the QR code.
   * @property {number} [padding] - The padding for the QR code in pixels.
   * @property {number} [size=100] - The size of the QR code in pixels.
   * @property {string} [value=""] - The value to be encoded within the QR code.
   */index.use(new BrowserElementService_1);var QRious_1=index;return QRious_1}));
//# sourceMappingURL=qrious.js.map
/***/},
/***/676095:
/***/function(module){
/*!
 * Quill Editor v1.3.7
 * https://quilljs.com/
 * Copyright (c) 2014, Jason Chen
 * Copyright (c) 2013, salesforce.com
 */
(function(root,factory){module.exports=factory()})("undefined"!==typeof self&&self,(function(){/******/
return function(modules){// webpackBootstrap
/******/ // The module cache
/******/var installedModules={};
/******/
/******/ // The require function
/******/function __nested_webpack_require_697__(moduleId){
/******/
/******/ // Check if module is in cache
/******/if(installedModules[moduleId])
/******/return installedModules[moduleId].exports;
/******/
/******/ // Create a new module (and put it into the cache)
/******/var module=installedModules[moduleId]={
/******/i:moduleId,
/******/l:!1,
/******/exports:{}
/******/};
/******/
/******/ // Execute the module function
/******/
/******/
/******/ // Return the exports of the module
/******/return modules[moduleId].call(module.exports,module,module.exports,__nested_webpack_require_697__),
/******/
/******/ // Flag the module as loaded
/******/module.l=!0,module.exports;
/******/}
/******/
/******/
/******/ // expose the modules object (__webpack_modules__)
/******/
/******/
/******/ // Load entry module and return exports
/******/return __nested_webpack_require_697__.m=modules,
/******/
/******/ // expose the module cache
/******/__nested_webpack_require_697__.c=installedModules,
/******/
/******/ // define getter function for harmony exports
/******/__nested_webpack_require_697__.d=function(exports,name,getter){
/******/__nested_webpack_require_697__.o(exports,name)||
/******/Object.defineProperty(exports,name,{
/******/configurable:!1,
/******/enumerable:!0,
/******/get:getter
/******/})
/******/},
/******/
/******/ // getDefaultExport function for compatibility with non-harmony modules
/******/__nested_webpack_require_697__.n=function(module){
/******/var getter=module&&module.__esModule?
/******/function(){return module["default"]}:
/******/function(){return module};
/******/
/******/return __nested_webpack_require_697__.d(getter,"a",getter),getter;
/******/},
/******/
/******/ // Object.prototype.hasOwnProperty.call
/******/__nested_webpack_require_697__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property)},
/******/
/******/ // __webpack_public_path__
/******/__nested_webpack_require_697__.p="",__nested_webpack_require_697__(__nested_webpack_require_697__.s=109);
/******/}
/************************************************************************/
/******/([
/* 0 */
/***/function(module,exports,__nested_webpack_require_2976__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var container_1=__nested_webpack_require_2976__(17),format_1=__nested_webpack_require_2976__(18),leaf_1=__nested_webpack_require_2976__(19),scroll_1=__nested_webpack_require_2976__(45),inline_1=__nested_webpack_require_2976__(46),block_1=__nested_webpack_require_2976__(47),embed_1=__nested_webpack_require_2976__(48),text_1=__nested_webpack_require_2976__(49),attributor_1=__nested_webpack_require_2976__(12),class_1=__nested_webpack_require_2976__(32),style_1=__nested_webpack_require_2976__(33),store_1=__nested_webpack_require_2976__(31),Registry=__nested_webpack_require_2976__(1),Parchment={Scope:Registry.Scope,create:Registry.create,find:Registry.find,query:Registry.query,register:Registry.register,Container:container_1.default,Format:format_1.default,Leaf:leaf_1.default,Embed:embed_1.default,Scroll:scroll_1.default,Block:block_1.default,Inline:inline_1.default,Text:text_1.default,Attributor:{Attribute:attributor_1.default,Class:class_1.default,Style:style_1.default,Store:store_1.default}};exports.default=Parchment},
/* 1 */
/***/function(module,exports,__webpack_require__){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p])};return function(d,b){function __(){this.constructor=d}extendStatics(d,b),d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:!0});var ParchmentError=/** @class */function(_super){function ParchmentError(message){var _this=this;return message="[Parchment] "+message,_this=_super.call(this,message)||this,_this.message=message,_this.name=_this.constructor.name,_this}return __extends(ParchmentError,_super),ParchmentError}(Error);exports.ParchmentError=ParchmentError;var Scope,attributes={},classes={},tags={},types={};function create(input,value){var match=query(input);if(null==match)throw new ParchmentError("Unable to create "+input+" blot");var BlotClass=match,node=
// @ts-ignore
input instanceof Node||input["nodeType"]===Node.TEXT_NODE?input:BlotClass.create(value);return new BlotClass(node,value)}function find(node,bubble){return void 0===bubble&&(bubble=!1),null==node?null:
// @ts-ignore
null!=node[exports.DATA_KEY]?node[exports.DATA_KEY].blot:bubble?find(node.parentNode,bubble):null}function query(query,scope){var match;if(void 0===scope&&(scope=Scope.ANY),"string"===typeof query)match=types[query]||attributes[query];
// @ts-ignore
else if(query instanceof Text||query["nodeType"]===Node.TEXT_NODE)match=types["text"];else if("number"===typeof query)query&Scope.LEVEL&Scope.BLOCK?match=types["block"]:query&Scope.LEVEL&Scope.INLINE&&(match=types["inline"]);else if(query instanceof HTMLElement){var names=(query.getAttribute("class")||"").split(/\s+/);for(var i in names)if(match=classes[names[i]],match)break;match=match||tags[query.tagName]}return null==match?null:
// @ts-ignore
scope&Scope.LEVEL&match.scope&&scope&Scope.TYPE&match.scope?match:null}function register(){for(var Definitions=[],_i=0;_i<arguments.length;_i++)Definitions[_i]=arguments[_i];if(Definitions.length>1)return Definitions.map((function(d){return register(d)}));var Definition=Definitions[0];if("string"!==typeof Definition.blotName&&"string"!==typeof Definition.attrName)throw new ParchmentError("Invalid definition");if("abstract"===Definition.blotName)throw new ParchmentError("Cannot register abstract class");if(types[Definition.blotName||Definition.attrName]=Definition,"string"===typeof Definition.keyName)attributes[Definition.keyName]=Definition;else if(null!=Definition.className&&(classes[Definition.className]=Definition),null!=Definition.tagName){Array.isArray(Definition.tagName)?Definition.tagName=Definition.tagName.map((function(tagName){return tagName.toUpperCase()})):Definition.tagName=Definition.tagName.toUpperCase();var tagNames=Array.isArray(Definition.tagName)?Definition.tagName:[Definition.tagName];tagNames.forEach((function(tag){null!=tags[tag]&&null!=Definition.className||(tags[tag]=Definition)}))}return Definition}exports.DATA_KEY="__blot",function(Scope){Scope[Scope["TYPE"]=3]="TYPE",Scope[Scope["LEVEL"]=12]="LEVEL",Scope[Scope["ATTRIBUTE"]=13]="ATTRIBUTE",Scope[Scope["BLOT"]=14]="BLOT",Scope[Scope["INLINE"]=7]="INLINE",Scope[Scope["BLOCK"]=11]="BLOCK",Scope[Scope["BLOCK_BLOT"]=10]="BLOCK_BLOT",Scope[Scope["INLINE_BLOT"]=6]="INLINE_BLOT",Scope[Scope["BLOCK_ATTRIBUTE"]=9]="BLOCK_ATTRIBUTE",Scope[Scope["INLINE_ATTRIBUTE"]=5]="INLINE_ATTRIBUTE",Scope[Scope["ANY"]=15]="ANY"}(Scope=exports.Scope||(exports.Scope={})),exports.create=create,exports.find=find,exports.query=query,exports.register=register},
/* 2 */
/***/function(module,exports,__nested_webpack_require_9445__){var diff=__nested_webpack_require_9445__(51),equal=__nested_webpack_require_9445__(11),extend=__nested_webpack_require_9445__(3),op=__nested_webpack_require_9445__(20),NULL_CHARACTER=String.fromCharCode(0),Delta=function(ops){
// Assume we are given a well formed ops
Array.isArray(ops)?this.ops=ops:null!=ops&&Array.isArray(ops.ops)?this.ops=ops.ops:this.ops=[]};Delta.prototype.insert=function(text,attributes){var newOp={};return 0===text.length?this:(newOp.insert=text,null!=attributes&&"object"===typeof attributes&&Object.keys(attributes).length>0&&(newOp.attributes=attributes),this.push(newOp))},Delta.prototype["delete"]=function(length){return length<=0?this:this.push({delete:length})},Delta.prototype.retain=function(length,attributes){if(length<=0)return this;var newOp={retain:length};return null!=attributes&&"object"===typeof attributes&&Object.keys(attributes).length>0&&(newOp.attributes=attributes),this.push(newOp)},Delta.prototype.push=function(newOp){var index=this.ops.length,lastOp=this.ops[index-1];if(newOp=extend(!0,{},newOp),"object"===typeof lastOp){if("number"===typeof newOp["delete"]&&"number"===typeof lastOp["delete"])return this.ops[index-1]={delete:lastOp["delete"]+newOp["delete"]},this;
// Since it does not matter if we insert before or after deleting at the same index,
// always prefer to insert first
if("number"===typeof lastOp["delete"]&&null!=newOp.insert&&(index-=1,lastOp=this.ops[index-1],"object"!==typeof lastOp))return this.ops.unshift(newOp),this;if(equal(newOp.attributes,lastOp.attributes)){if("string"===typeof newOp.insert&&"string"===typeof lastOp.insert)return this.ops[index-1]={insert:lastOp.insert+newOp.insert},"object"===typeof newOp.attributes&&(this.ops[index-1].attributes=newOp.attributes),this;if("number"===typeof newOp.retain&&"number"===typeof lastOp.retain)return this.ops[index-1]={retain:lastOp.retain+newOp.retain},"object"===typeof newOp.attributes&&(this.ops[index-1].attributes=newOp.attributes),this}}return index===this.ops.length?this.ops.push(newOp):this.ops.splice(index,0,newOp),this},Delta.prototype.chop=function(){var lastOp=this.ops[this.ops.length-1];return lastOp&&lastOp.retain&&!lastOp.attributes&&this.ops.pop(),this},Delta.prototype.filter=function(predicate){return this.ops.filter(predicate)},Delta.prototype.forEach=function(predicate){this.ops.forEach(predicate)},Delta.prototype.map=function(predicate){return this.ops.map(predicate)},Delta.prototype.partition=function(predicate){var passed=[],failed=[];return this.forEach((function(op){var target=predicate(op)?passed:failed;target.push(op)})),[passed,failed]},Delta.prototype.reduce=function(predicate,initial){return this.ops.reduce(predicate,initial)},Delta.prototype.changeLength=function(){return this.reduce((function(length,elem){return elem.insert?length+op.length(elem):elem.delete?length-elem.delete:length}),0)},Delta.prototype.length=function(){return this.reduce((function(length,elem){return length+op.length(elem)}),0)},Delta.prototype.slice=function(start,end){start=start||0,"number"!==typeof end&&(end=1/0);var ops=[],iter=op.iterator(this.ops),index=0;while(index<end&&iter.hasNext()){var nextOp;index<start?nextOp=iter.next(start-index):(nextOp=iter.next(end-index),ops.push(nextOp)),index+=op.length(nextOp)}return new Delta(ops)},Delta.prototype.compose=function(other){var thisIter=op.iterator(this.ops),otherIter=op.iterator(other.ops),ops=[],firstOther=otherIter.peek();if(null!=firstOther&&"number"===typeof firstOther.retain&&null==firstOther.attributes){var firstLeft=firstOther.retain;while("insert"===thisIter.peekType()&&thisIter.peekLength()<=firstLeft)firstLeft-=thisIter.peekLength(),ops.push(thisIter.next());firstOther.retain-firstLeft>0&&otherIter.next(firstOther.retain-firstLeft)}var delta=new Delta(ops);while(thisIter.hasNext()||otherIter.hasNext())if("insert"===otherIter.peekType())delta.push(otherIter.next());else if("delete"===thisIter.peekType())delta.push(thisIter.next());else{var length=Math.min(thisIter.peekLength(),otherIter.peekLength()),thisOp=thisIter.next(length),otherOp=otherIter.next(length);if("number"===typeof otherOp.retain){var newOp={};"number"===typeof thisOp.retain?newOp.retain=length:newOp.insert=thisOp.insert;
// Preserve null when composing with a retain, otherwise remove it for inserts
var attributes=op.attributes.compose(thisOp.attributes,otherOp.attributes,"number"===typeof thisOp.retain);
// Optimization if rest of other is just retain
if(attributes&&(newOp.attributes=attributes),delta.push(newOp),!otherIter.hasNext()&&equal(delta.ops[delta.ops.length-1],newOp)){var rest=new Delta(thisIter.rest());return delta.concat(rest).chop()}
// Other op should be delete, we could be an insert or retain
// Insert + delete cancels out
}else"number"===typeof otherOp["delete"]&&"number"===typeof thisOp.retain&&delta.push(otherOp)}return delta.chop()},Delta.prototype.concat=function(other){var delta=new Delta(this.ops.slice());return other.ops.length>0&&(delta.push(other.ops[0]),delta.ops=delta.ops.concat(other.ops.slice(1))),delta},Delta.prototype.diff=function(other,index){if(this.ops===other.ops)return new Delta;var strings=[this,other].map((function(delta){return delta.map((function(op){if(null!=op.insert)return"string"===typeof op.insert?op.insert:NULL_CHARACTER;var prep=delta===other?"on":"with";throw new Error("diff() called "+prep+" non-document")})).join("")})),delta=new Delta,diffResult=diff(strings[0],strings[1],index),thisIter=op.iterator(this.ops),otherIter=op.iterator(other.ops);return diffResult.forEach((function(component){var length=component[1].length;while(length>0){var opLength=0;switch(component[0]){case diff.INSERT:opLength=Math.min(otherIter.peekLength(),length),delta.push(otherIter.next(opLength));break;case diff.DELETE:opLength=Math.min(length,thisIter.peekLength()),thisIter.next(opLength),delta["delete"](opLength);break;case diff.EQUAL:opLength=Math.min(thisIter.peekLength(),otherIter.peekLength(),length);var thisOp=thisIter.next(opLength),otherOp=otherIter.next(opLength);equal(thisOp.insert,otherOp.insert)?delta.retain(opLength,op.attributes.diff(thisOp.attributes,otherOp.attributes)):delta.push(otherOp)["delete"](opLength);break}length-=opLength}})),delta.chop()},Delta.prototype.eachLine=function(predicate,newline){newline=newline||"\n";var iter=op.iterator(this.ops),line=new Delta,i=0;while(iter.hasNext()){if("insert"!==iter.peekType())return;var thisOp=iter.peek(),start=op.length(thisOp)-iter.peekLength(),index="string"===typeof thisOp.insert?thisOp.insert.indexOf(newline,start)-start:-1;if(index<0)line.push(iter.next());else if(index>0)line.push(iter.next(index));else{if(!1===predicate(line,iter.next(1).attributes||{},i))return;i+=1,line=new Delta}}line.length()>0&&predicate(line,{},i)},Delta.prototype.transform=function(other,priority){if(priority=!!priority,"number"===typeof other)return this.transformPosition(other,priority);var thisIter=op.iterator(this.ops),otherIter=op.iterator(other.ops),delta=new Delta;while(thisIter.hasNext()||otherIter.hasNext())if("insert"!==thisIter.peekType()||!priority&&"insert"===otherIter.peekType())if("insert"===otherIter.peekType())delta.push(otherIter.next());else{var length=Math.min(thisIter.peekLength(),otherIter.peekLength()),thisOp=thisIter.next(length),otherOp=otherIter.next(length);if(thisOp["delete"])
// Our delete either makes their delete redundant or removes their retain
continue;otherOp["delete"]?delta.push(otherOp):
// We retain either their retain or insert
delta.retain(length,op.attributes.transform(thisOp.attributes,otherOp.attributes,priority))}else delta.retain(op.length(thisIter.next()));return delta.chop()},Delta.prototype.transformPosition=function(index,priority){priority=!!priority;var thisIter=op.iterator(this.ops),offset=0;while(thisIter.hasNext()&&offset<=index){var length=thisIter.peekLength(),nextType=thisIter.peekType();thisIter.next(),"delete"!==nextType?("insert"===nextType&&(offset<index||!priority)&&(index+=length),offset+=length):index-=Math.min(length,index-offset)}return index},module.exports=Delta},
/* 3 */
/***/function(module,exports){"use strict";var hasOwn=Object.prototype.hasOwnProperty,toStr=Object.prototype.toString,defineProperty=Object.defineProperty,gOPD=Object.getOwnPropertyDescriptor,isArray=function(arr){return"function"===typeof Array.isArray?Array.isArray(arr):"[object Array]"===toStr.call(arr)},isPlainObject=function(obj){if(!obj||"[object Object]"!==toStr.call(obj))return!1;var key,hasOwnConstructor=hasOwn.call(obj,"constructor"),hasIsPrototypeOf=obj.constructor&&obj.constructor.prototype&&hasOwn.call(obj.constructor.prototype,"isPrototypeOf");
// Not own constructor property must be Object
if(obj.constructor&&!hasOwnConstructor&&!hasIsPrototypeOf)return!1;
// Own properties are enumerated firstly, so to speed up,
// if last one is own, then all properties are own.
for(key in obj);return"undefined"===typeof key||hasOwn.call(obj,key)},setProperty=function(target,options){defineProperty&&"__proto__"===options.name?defineProperty(target,options.name,{enumerable:!0,configurable:!0,value:options.newValue,writable:!0}):target[options.name]=options.newValue},getProperty=function(obj,name){if("__proto__"===name){if(!hasOwn.call(obj,name))return;if(gOPD)
// In early versions of node, obj['__proto__'] is buggy when obj has
// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
return gOPD(obj,name).value}return obj[name]};module.exports=function extend(){var options,name,src,copy,copyIsArray,clone,target=arguments[0],i=1,length=arguments.length,deep=!1;for(
// Handle a deep copy situation
"boolean"===typeof target&&(deep=target,target=arguments[1]||{},
// skip the boolean and the target
i=2),(null==target||"object"!==typeof target&&"function"!==typeof target)&&(target={});i<length;++i)
// Only deal with non-null/undefined values
if(options=arguments[i],null!=options)
// Extend the base object
for(name in options)src=getProperty(target,name),copy=getProperty(options,name),
// Prevent never-ending loop
target!==copy&&(
// Recurse if we're merging plain objects or arrays
deep&&copy&&(isPlainObject(copy)||(copyIsArray=isArray(copy)))?(copyIsArray?(copyIsArray=!1,clone=src&&isArray(src)?src:[]):clone=src&&isPlainObject(src)?src:{},
// Never move original objects, clone them
setProperty(target,{name:name,newValue:extend(deep,clone,copy)})):"undefined"!==typeof copy&&setProperty(target,{name:name,newValue:copy}));
// Return the modified object
return target}},
/* 4 */
/***/function(module,exports,__nested_webpack_require_23616__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.BlockEmbed=exports.bubbleFormats=void 0;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_extend=__nested_webpack_require_23616__(3),_extend2=_interopRequireDefault(_extend),_quillDelta=__nested_webpack_require_23616__(2),_quillDelta2=_interopRequireDefault(_quillDelta),_parchment=__nested_webpack_require_23616__(0),_parchment2=_interopRequireDefault(_parchment),_break=__nested_webpack_require_23616__(16),_break2=_interopRequireDefault(_break),_inline=__nested_webpack_require_23616__(6),_inline2=_interopRequireDefault(_inline),_text=__nested_webpack_require_23616__(7),_text2=_interopRequireDefault(_text);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var NEWLINE_LENGTH=1,BlockEmbed=function(_Parchment$Embed){function BlockEmbed(){return _classCallCheck(this,BlockEmbed),_possibleConstructorReturn(this,(BlockEmbed.__proto__||Object.getPrototypeOf(BlockEmbed)).apply(this,arguments))}return _inherits(BlockEmbed,_Parchment$Embed),_createClass(BlockEmbed,[{key:"attach",value:function(){_get(BlockEmbed.prototype.__proto__||Object.getPrototypeOf(BlockEmbed.prototype),"attach",this).call(this),this.attributes=new _parchment2.default.Attributor.Store(this.domNode)}},{key:"delta",value:function(){return(new _quillDelta2.default).insert(this.value(),(0,_extend2.default)(this.formats(),this.attributes.values()))}},{key:"format",value:function(name,value){var attribute=_parchment2.default.query(name,_parchment2.default.Scope.BLOCK_ATTRIBUTE);null!=attribute&&this.attributes.attribute(attribute,value)}},{key:"formatAt",value:function(index,length,name,value){this.format(name,value)}},{key:"insertAt",value:function(index,value,def){if("string"===typeof value&&value.endsWith("\n")){var block=_parchment2.default.create(Block.blotName);this.parent.insertBefore(block,0===index?this:this.next),block.insertAt(0,value.slice(0,-1))}else _get(BlockEmbed.prototype.__proto__||Object.getPrototypeOf(BlockEmbed.prototype),"insertAt",this).call(this,index,value,def)}}]),BlockEmbed}(_parchment2.default.Embed);BlockEmbed.scope=_parchment2.default.Scope.BLOCK_BLOT;
// It is important for cursor behavior BlockEmbeds use tags that are block level elements
var Block=function(_Parchment$Block){function Block(domNode){_classCallCheck(this,Block);var _this2=_possibleConstructorReturn(this,(Block.__proto__||Object.getPrototypeOf(Block)).call(this,domNode));return _this2.cache={},_this2}return _inherits(Block,_Parchment$Block),_createClass(Block,[{key:"delta",value:function(){return null==this.cache.delta&&(this.cache.delta=this.descendants(_parchment2.default.Leaf).reduce((function(delta,leaf){return 0===leaf.length()?delta:delta.insert(leaf.value(),bubbleFormats(leaf))}),new _quillDelta2.default).insert("\n",bubbleFormats(this))),this.cache.delta}},{key:"deleteAt",value:function(index,length){_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),"deleteAt",this).call(this,index,length),this.cache={}}},{key:"formatAt",value:function(index,length,name,value){length<=0||(_parchment2.default.query(name,_parchment2.default.Scope.BLOCK)?index+length===this.length()&&this.format(name,value):_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),"formatAt",this).call(this,index,Math.min(length,this.length()-index-1),name,value),this.cache={})}},{key:"insertAt",value:function(index,value,def){if(null!=def)return _get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),"insertAt",this).call(this,index,value,def);if(0!==value.length){var lines=value.split("\n"),text=lines.shift();text.length>0&&(index<this.length()-1||null==this.children.tail?_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),"insertAt",this).call(this,Math.min(index,this.length()-1),text):this.children.tail.insertAt(this.children.tail.length(),text),this.cache={});var block=this;lines.reduce((function(index,line){return block=block.split(index,!0),block.insertAt(0,line),line.length}),index+text.length)}}},{key:"insertBefore",value:function(blot,ref){var head=this.children.head;_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),"insertBefore",this).call(this,blot,ref),head instanceof _break2.default&&head.remove(),this.cache={}}},{key:"length",value:function(){return null==this.cache.length&&(this.cache.length=_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),"length",this).call(this)+NEWLINE_LENGTH),this.cache.length}},{key:"moveChildren",value:function(target,ref){_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),"moveChildren",this).call(this,target,ref),this.cache={}}},{key:"optimize",value:function(context){_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),"optimize",this).call(this,context),this.cache={}}},{key:"path",value:function(index){return _get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),"path",this).call(this,index,!0)}},{key:"removeChild",value:function(child){_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),"removeChild",this).call(this,child),this.cache={}}},{key:"split",value:function(index){var force=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(force&&(0===index||index>=this.length()-NEWLINE_LENGTH)){var clone=this.clone();return 0===index?(this.parent.insertBefore(clone,this),this):(this.parent.insertBefore(clone,this.next),clone)}var next=_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),"split",this).call(this,index,force);return this.cache={},next}}]),Block}(_parchment2.default.Block);function bubbleFormats(blot){var formats=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==blot?formats:("function"===typeof blot.formats&&(formats=(0,_extend2.default)(formats,blot.formats())),null==blot.parent||"scroll"==blot.parent.blotName||blot.parent.statics.scope!==blot.statics.scope?formats:bubbleFormats(blot.parent,formats))}Block.blotName="block",Block.tagName="P",Block.defaultChild="break",Block.allowedChildren=[_inline2.default,_parchment2.default.Embed,_text2.default],exports.bubbleFormats=bubbleFormats,exports.BlockEmbed=BlockEmbed,exports.default=Block},
/* 5 */
/***/function(module,exports,__nested_webpack_require_33760__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.overload=exports.expandConfig=void 0;var _typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_slicedToArray=function(){function sliceIterator(arr,i){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done);_n=!0)if(_arr.push(_s.value),i&&_arr.length===i)break}catch(err){_d=!0,_e=err}finally{try{!_n&&_i["return"]&&_i["return"]()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr))return arr;if(Symbol.iterator in Object(arr))return sliceIterator(arr,i);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}();__nested_webpack_require_33760__(50);var _quillDelta=__nested_webpack_require_33760__(2),_quillDelta2=_interopRequireDefault(_quillDelta),_editor=__nested_webpack_require_33760__(14),_editor2=_interopRequireDefault(_editor),_emitter3=__nested_webpack_require_33760__(8),_emitter4=_interopRequireDefault(_emitter3),_module=__nested_webpack_require_33760__(9),_module2=_interopRequireDefault(_module),_parchment=__nested_webpack_require_33760__(0),_parchment2=_interopRequireDefault(_parchment),_selection=__nested_webpack_require_33760__(15),_selection2=_interopRequireDefault(_selection),_extend=__nested_webpack_require_33760__(3),_extend2=_interopRequireDefault(_extend),_logger=__nested_webpack_require_33760__(10),_logger2=_interopRequireDefault(_logger),_theme=__nested_webpack_require_33760__(34),_theme2=_interopRequireDefault(_theme);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}var debug=(0,_logger2.default)("quill"),Quill=function(){function Quill(container){var _this2=this,options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(_classCallCheck(this,Quill),this.options=expandConfig(container,options),this.container=this.options.container,null==this.container)return debug.error("Invalid Quill container",container);this.options.debug&&Quill.debug(this.options.debug);var html=this.container.innerHTML.trim();this.container.classList.add("ql-container"),this.container.innerHTML="",this.container.__quill=this,this.root=this.addContainer("ql-editor"),this.root.classList.add("ql-blank"),this.root.setAttribute("data-gramm",!1),this.scrollingContainer=this.options.scrollingContainer||this.root,this.emitter=new _emitter4.default,this.scroll=_parchment2.default.create(this.root,{emitter:this.emitter,whitelist:this.options.formats}),this.editor=new _editor2.default(this.scroll),this.selection=new _selection2.default(this.scroll,this.emitter),this.theme=new this.options.theme(this,this.options),this.keyboard=this.theme.addModule("keyboard"),this.clipboard=this.theme.addModule("clipboard"),this.history=this.theme.addModule("history"),this.theme.init(),this.emitter.on(_emitter4.default.events.EDITOR_CHANGE,(function(type){type===_emitter4.default.events.TEXT_CHANGE&&_this2.root.classList.toggle("ql-blank",_this2.editor.isBlank())})),this.emitter.on(_emitter4.default.events.SCROLL_UPDATE,(function(source,mutations){var range=_this2.selection.lastRange,index=range&&0===range.length?range.index:void 0;modify.call(_this2,(function(){return _this2.editor.update(null,mutations,index)}),source)}));var contents=this.clipboard.convert("<div class='ql-editor' style=\"white-space: normal;\">"+html+"<p><br></p></div>");this.setContents(contents),this.history.clear(),this.options.placeholder&&this.root.setAttribute("data-placeholder",this.options.placeholder),this.options.readOnly&&this.disable()}return _createClass(Quill,null,[{key:"debug",value:function(limit){!0===limit&&(limit="log"),_logger2.default.level(limit)}},{key:"find",value:function(node){return node.__quill||_parchment2.default.find(node)}},{key:"import",value:function(name){return null==this.imports[name]&&debug.error("Cannot import "+name+". Are you sure it was registered?"),this.imports[name]}},{key:"register",value:function(path,target){var _this=this,overwrite=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if("string"!==typeof path){var name=path.attrName||path.blotName;"string"===typeof name?
// register(Blot | Attributor, overwrite)
this.register("formats/"+name,path,target):Object.keys(path).forEach((function(key){_this.register(key,path[key],target)}))}else null==this.imports[path]||overwrite||debug.warn("Overwriting "+path+" with",target),this.imports[path]=target,(path.startsWith("blots/")||path.startsWith("formats/"))&&"abstract"!==target.blotName?_parchment2.default.register(target):path.startsWith("modules")&&"function"===typeof target.register&&target.register()}}]),_createClass(Quill,[{key:"addContainer",value:function(container){var refNode=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if("string"===typeof container){var className=container;container=document.createElement("div"),container.classList.add(className)}return this.container.insertBefore(container,refNode),container}},{key:"blur",value:function(){this.selection.setRange(null)}},{key:"deleteText",value:function(index,length,source){var _this3=this,_overload=overload(index,length,source),_overload2=_slicedToArray(_overload,4);return index=_overload2[0],length=_overload2[1],source=_overload2[3],modify.call(this,(function(){return _this3.editor.deleteText(index,length)}),source,index,-1*length)}},{key:"disable",value:function(){this.enable(!1)}},{key:"enable",value:function(){var enabled=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.scroll.enable(enabled),this.container.classList.toggle("ql-disabled",!enabled)}},{key:"focus",value:function(){var scrollTop=this.scrollingContainer.scrollTop;this.selection.focus(),this.scrollingContainer.scrollTop=scrollTop,this.scrollIntoView()}},{key:"format",value:function(name,value){var _this4=this,source=arguments.length>2&&void 0!==arguments[2]?arguments[2]:_emitter4.default.sources.API;return modify.call(this,(function(){var range=_this4.getSelection(!0),change=new _quillDelta2.default;if(null==range)return change;if(_parchment2.default.query(name,_parchment2.default.Scope.BLOCK))change=_this4.editor.formatLine(range.index,range.length,_defineProperty({},name,value));else{if(0===range.length)return _this4.selection.format(name,value),change;change=_this4.editor.formatText(range.index,range.length,_defineProperty({},name,value))}return _this4.setSelection(range,_emitter4.default.sources.SILENT),change}),source)}},{key:"formatLine",value:function(index,length,name,value,source){var _this5=this,formats=void 0,_overload3=overload(index,length,name,value,source),_overload4=_slicedToArray(_overload3,4);return index=_overload4[0],length=_overload4[1],formats=_overload4[2],source=_overload4[3],modify.call(this,(function(){return _this5.editor.formatLine(index,length,formats)}),source,index,0)}},{key:"formatText",value:function(index,length,name,value,source){var _this6=this,formats=void 0,_overload5=overload(index,length,name,value,source),_overload6=_slicedToArray(_overload5,4);return index=_overload6[0],length=_overload6[1],formats=_overload6[2],source=_overload6[3],modify.call(this,(function(){return _this6.editor.formatText(index,length,formats)}),source,index,0)}},{key:"getBounds",value:function(index){var length=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,bounds=void 0;bounds="number"===typeof index?this.selection.getBounds(index,length):this.selection.getBounds(index.index,index.length);var containerBounds=this.container.getBoundingClientRect();return{bottom:bounds.bottom-containerBounds.top,height:bounds.height,left:bounds.left-containerBounds.left,right:bounds.right-containerBounds.left,top:bounds.top-containerBounds.top,width:bounds.width}}},{key:"getContents",value:function(){var index=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,length=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.getLength()-index,_overload7=overload(index,length),_overload8=_slicedToArray(_overload7,2);return index=_overload8[0],length=_overload8[1],this.editor.getContents(index,length)}},{key:"getFormat",value:function(){var index=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.getSelection(!0),length=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return"number"===typeof index?this.editor.getFormat(index,length):this.editor.getFormat(index.index,index.length)}},{key:"getIndex",value:function(blot){return blot.offset(this.scroll)}},{key:"getLength",value:function(){return this.scroll.length()}},{key:"getLeaf",value:function(index){return this.scroll.leaf(index)}},{key:"getLine",value:function(index){return this.scroll.line(index)}},{key:"getLines",value:function(){var index=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,length=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Number.MAX_VALUE;return"number"!==typeof index?this.scroll.lines(index.index,index.length):this.scroll.lines(index,length)}},{key:"getModule",value:function(name){return this.theme.modules[name]}},{key:"getSelection",value:function(){var focus=arguments.length>0&&void 0!==arguments[0]&&arguments[0];// Make sure we access getRange with editor in consistent state
return focus&&this.focus(),this.update(),this.selection.getRange()[0]}},{key:"getText",value:function(){var index=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,length=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.getLength()-index,_overload9=overload(index,length),_overload10=_slicedToArray(_overload9,2);return index=_overload10[0],length=_overload10[1],this.editor.getText(index,length)}},{key:"hasFocus",value:function(){return this.selection.hasFocus()}},{key:"insertEmbed",value:function(index,embed,value){var _this7=this,source=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Quill.sources.API;return modify.call(this,(function(){return _this7.editor.insertEmbed(index,embed,value)}),source,index)}},{key:"insertText",value:function(index,text,name,value,source){var _this8=this,formats=void 0,_overload11=overload(index,0,name,value,source),_overload12=_slicedToArray(_overload11,4);return index=_overload12[0],formats=_overload12[2],source=_overload12[3],modify.call(this,(function(){return _this8.editor.insertText(index,text,formats)}),source,index,text.length)}},{key:"isEnabled",value:function(){return!this.container.classList.contains("ql-disabled")}},{key:"off",value:function(){return this.emitter.off.apply(this.emitter,arguments)}},{key:"on",value:function(){return this.emitter.on.apply(this.emitter,arguments)}},{key:"once",value:function(){return this.emitter.once.apply(this.emitter,arguments)}},{key:"pasteHTML",value:function(index,html,source){this.clipboard.dangerouslyPasteHTML(index,html,source)}},{key:"removeFormat",value:function(index,length,source){var _this9=this,_overload13=overload(index,length,source),_overload14=_slicedToArray(_overload13,4);return index=_overload14[0],length=_overload14[1],source=_overload14[3],modify.call(this,(function(){return _this9.editor.removeFormat(index,length)}),source,index)}},{key:"scrollIntoView",value:function(){this.selection.scrollIntoView(this.scrollingContainer)}},{key:"setContents",value:function(delta){var _this10=this,source=arguments.length>1&&void 0!==arguments[1]?arguments[1]:_emitter4.default.sources.API;return modify.call(this,(function(){delta=new _quillDelta2.default(delta);var length=_this10.getLength(),deleted=_this10.editor.deleteText(0,length),applied=_this10.editor.applyDelta(delta),lastOp=applied.ops[applied.ops.length-1];null!=lastOp&&"string"===typeof lastOp.insert&&"\n"===lastOp.insert[lastOp.insert.length-1]&&(_this10.editor.deleteText(_this10.getLength()-1,1),applied.delete(1));var ret=deleted.compose(applied);return ret}),source)}},{key:"setSelection",value:function(index,length,source){if(null==index)this.selection.setRange(null,length||Quill.sources.API);else{var _overload15=overload(index,length,source),_overload16=_slicedToArray(_overload15,4);index=_overload16[0],length=_overload16[1],source=_overload16[3],this.selection.setRange(new _selection.Range(index,length),source),source!==_emitter4.default.sources.SILENT&&this.selection.scrollIntoView(this.scrollingContainer)}}},{key:"setText",value:function(text){var source=arguments.length>1&&void 0!==arguments[1]?arguments[1]:_emitter4.default.sources.API,delta=(new _quillDelta2.default).insert(text);return this.setContents(delta,source)}},{key:"update",value:function(){var source=arguments.length>0&&void 0!==arguments[0]?arguments[0]:_emitter4.default.sources.USER,change=this.scroll.update(source);// Will update selection before selection.update() does if text changes
return this.selection.update(source),change}},{key:"updateContents",value:function(delta){var _this11=this,source=arguments.length>1&&void 0!==arguments[1]?arguments[1]:_emitter4.default.sources.API;return modify.call(this,(function(){return delta=new _quillDelta2.default(delta),_this11.editor.applyDelta(delta,source)}),source,!0)}}]),Quill}();function expandConfig(container,userConfig){if(userConfig=(0,_extend2.default)(!0,{container:container,modules:{clipboard:!0,keyboard:!0,history:!0}},userConfig),userConfig.theme&&userConfig.theme!==Quill.DEFAULTS.theme){if(userConfig.theme=Quill.import("themes/"+userConfig.theme),null==userConfig.theme)throw new Error("Invalid theme "+userConfig.theme+". Did you register it?")}else userConfig.theme=_theme2.default;var themeConfig=(0,_extend2.default)(!0,{},userConfig.theme.DEFAULTS);[themeConfig,userConfig].forEach((function(config){config.modules=config.modules||{},Object.keys(config.modules).forEach((function(module){!0===config.modules[module]&&(config.modules[module]={})}))}));var moduleNames=Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules)),moduleConfig=moduleNames.reduce((function(config,name){var moduleClass=Quill.import("modules/"+name);return null==moduleClass?debug.error("Cannot load "+name+" module. Are you sure you registered it?"):config[name]=moduleClass.DEFAULTS||{},config}),{});
// Special case toolbar shorthand
return null!=userConfig.modules&&userConfig.modules.toolbar&&userConfig.modules.toolbar.constructor!==Object&&(userConfig.modules.toolbar={container:userConfig.modules.toolbar}),userConfig=(0,_extend2.default)(!0,{},Quill.DEFAULTS,{modules:moduleConfig},themeConfig,userConfig),["bounds","container","scrollingContainer"].forEach((function(key){"string"===typeof userConfig[key]&&(userConfig[key]=document.querySelector(userConfig[key]))})),userConfig.modules=Object.keys(userConfig.modules).reduce((function(config,name){return userConfig.modules[name]&&(config[name]=userConfig.modules[name]),config}),{}),userConfig}
// Handle selection preservation and TEXT_CHANGE emission
// common to modification APIs
function modify(modifier,source,index,shift){if(this.options.strict&&!this.isEnabled()&&source===_emitter4.default.sources.USER)return new _quillDelta2.default;var range=null==index?null:this.getSelection(),oldDelta=this.editor.delta,change=modifier();if(null!=range&&(!0===index&&(index=range.index),null==shift?range=shiftRange(range,change,source):0!==shift&&(range=shiftRange(range,index,shift,source)),this.setSelection(range,_emitter4.default.sources.SILENT)),change.length()>0){var _emitter,_emitter2,args=[_emitter4.default.events.TEXT_CHANGE,change,oldDelta,source];if((_emitter=this.emitter).emit.apply(_emitter,[_emitter4.default.events.EDITOR_CHANGE].concat(args)),source!==_emitter4.default.sources.SILENT)(_emitter2=this.emitter).emit.apply(_emitter2,args)}return change}function overload(index,length,name,value,source){var formats={};return"number"===typeof index.index&&"number"===typeof index.length?
// Allow for throwaway end (used by insertText/insertEmbed)
"number"!==typeof length?(source=value,value=name,name=length,length=index.length,index=index.index):(length=index.length,index=index.index):"number"!==typeof length&&(source=value,value=name,name=length,length=0),
// Handle format being object, two format name/value strings or excluded
"object"===("undefined"===typeof name?"undefined":_typeof(name))?(formats=name,source=value):"string"===typeof name&&(null!=value?formats[name]=value:source=name),
// Handle optional source
source=source||_emitter4.default.sources.API,[index,length,formats,source]}function shiftRange(range,index,length,source){if(null==range)return null;var start=void 0,end=void 0;if(index instanceof _quillDelta2.default){var _map=[range.index,range.index+range.length].map((function(pos){return index.transformPosition(pos,source!==_emitter4.default.sources.USER)})),_map2=_slicedToArray(_map,2);start=_map2[0],end=_map2[1]}else{var _map3=[range.index,range.index+range.length].map((function(pos){return pos<index||pos===index&&source===_emitter4.default.sources.USER?pos:length>=0?pos+length:Math.max(index,pos+length)})),_map4=_slicedToArray(_map3,2);start=_map4[0],end=_map4[1]}return new _selection.Range(start,end-start)}Quill.DEFAULTS={bounds:null,formats:null,modules:{},placeholder:"",readOnly:!1,scrollingContainer:null,strict:!0,theme:"default"},Quill.events=_emitter4.default.events,Quill.sources=_emitter4.default.sources,
// eslint-disable-next-line no-undef
Quill.version="1.3.7",Quill.imports={delta:_quillDelta2.default,parchment:_parchment2.default,"core/module":_module2.default,"core/theme":_theme2.default},exports.expandConfig=expandConfig,exports.overload=overload,exports.default=Quill},
/* 6 */
/***/function(module,exports,__nested_webpack_require_58401__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_text=__nested_webpack_require_58401__(7),_text2=_interopRequireDefault(_text),_parchment=__nested_webpack_require_58401__(0),_parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var Inline=function(_Parchment$Inline){function Inline(){return _classCallCheck(this,Inline),_possibleConstructorReturn(this,(Inline.__proto__||Object.getPrototypeOf(Inline)).apply(this,arguments))}return _inherits(Inline,_Parchment$Inline),_createClass(Inline,[{key:"formatAt",value:function(index,length,name,value){if(Inline.compare(this.statics.blotName,name)<0&&_parchment2.default.query(name,_parchment2.default.Scope.BLOT)){var blot=this.isolate(index,length);value&&blot.wrap(name,value)}else _get(Inline.prototype.__proto__||Object.getPrototypeOf(Inline.prototype),"formatAt",this).call(this,index,length,name,value)}},{key:"optimize",value:function(context){if(_get(Inline.prototype.__proto__||Object.getPrototypeOf(Inline.prototype),"optimize",this).call(this,context),this.parent instanceof Inline&&Inline.compare(this.statics.blotName,this.parent.statics.blotName)>0){var parent=this.parent.isolate(this.offset(),this.length());this.moveChildren(parent),parent.wrap(this)}}}],[{key:"compare",value:function(self,other){var selfIndex=Inline.order.indexOf(self),otherIndex=Inline.order.indexOf(other);return selfIndex>=0||otherIndex>=0?selfIndex-otherIndex:self===other?0:self<other?-1:1}}]),Inline}(_parchment2.default.Inline);Inline.allowedChildren=[Inline,_parchment2.default.Embed,_text2.default],
// Lower index means deeper in the DOM tree, since not found (-1) is for embeds
Inline.order=["cursor","inline",// Must be lower
"underline","strike","italic","bold","script","link","code"],exports.default=Inline},
/* 7 */
/***/function(module,exports,__nested_webpack_require_62823__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _parchment=__nested_webpack_require_62823__(0),_parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var TextBlot=function(_Parchment$Text){function TextBlot(){return _classCallCheck(this,TextBlot),_possibleConstructorReturn(this,(TextBlot.__proto__||Object.getPrototypeOf(TextBlot)).apply(this,arguments))}return _inherits(TextBlot,_Parchment$Text),TextBlot}(_parchment2.default.Text);exports.default=TextBlot},
/* 8 */
/***/function(module,exports,__nested_webpack_require_64422__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_eventemitter=__nested_webpack_require_64422__(54),_eventemitter2=_interopRequireDefault(_eventemitter),_logger=__nested_webpack_require_64422__(10),_logger2=_interopRequireDefault(_logger);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var debug=(0,_logger2.default)("quill:events"),EVENTS=["selectionchange","mousedown","mouseup","click"];EVENTS.forEach((function(eventName){document.addEventListener(eventName,(function(){for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];[].slice.call(document.querySelectorAll(".ql-container")).forEach((function(node){var _node$__quill$emitter;
// TODO use WeakMap
node.__quill&&node.__quill.emitter&&(_node$__quill$emitter=node.__quill.emitter).handleDOM.apply(_node$__quill$emitter,args)}))}))}));var Emitter=function(_EventEmitter){function Emitter(){_classCallCheck(this,Emitter);var _this=_possibleConstructorReturn(this,(Emitter.__proto__||Object.getPrototypeOf(Emitter)).call(this));return _this.listeners={},_this.on("error",debug.error),_this}return _inherits(Emitter,_EventEmitter),_createClass(Emitter,[{key:"emit",value:function(){debug.log.apply(debug,arguments),_get(Emitter.prototype.__proto__||Object.getPrototypeOf(Emitter.prototype),"emit",this).apply(this,arguments)}},{key:"handleDOM",value:function(event){for(var _len2=arguments.length,args=Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++)args[_key2-1]=arguments[_key2];(this.listeners[event.type]||[]).forEach((function(_ref){var node=_ref.node,handler=_ref.handler;(event.target===node||node.contains(event.target))&&handler.apply(void 0,[event].concat(args))}))}},{key:"listenDOM",value:function(eventName,node,handler){this.listeners[eventName]||(this.listeners[eventName]=[]),this.listeners[eventName].push({node:node,handler:handler})}}]),Emitter}(_eventemitter2.default);Emitter.events={EDITOR_CHANGE:"editor-change",SCROLL_BEFORE_UPDATE:"scroll-before-update",SCROLL_OPTIMIZE:"scroll-optimize",SCROLL_UPDATE:"scroll-update",SELECTION_CHANGE:"selection-change",TEXT_CHANGE:"text-change"},Emitter.sources={API:"api",SILENT:"silent",USER:"user"},exports.default=Emitter},
/* 9 */
/***/function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var Module=function Module(quill){var options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};_classCallCheck(this,Module),this.quill=quill,this.options=options};Module.DEFAULTS={},exports.default=Module},
/* 10 */
/***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var levels=["error","warn","log","info"],level="warn";function debug(method){if(levels.indexOf(method)<=levels.indexOf(level)){for(var _console,_len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];(_console=console)[method].apply(_console,args)}}function namespace(ns){return levels.reduce((function(logger,method){return logger[method]=debug.bind(console,method,ns),logger}),{})}debug.level=namespace.level=function(newLevel){level=newLevel},exports.default=namespace},
/* 11 */
/***/function(module,exports,__nested_webpack_require_70685__){var pSlice=Array.prototype.slice,objectKeys=__nested_webpack_require_70685__(52),isArguments=__nested_webpack_require_70685__(53),deepEqual=module.exports=function(actual,expected,opts){
// 7.1. All identical values are equivalent, as determined by ===.
return opts||(opts={}),actual===expected||(actual instanceof Date&&expected instanceof Date?actual.getTime()===expected.getTime():!actual||!expected||"object"!=typeof actual&&"object"!=typeof expected?opts.strict?actual===expected:actual==expected:objEquiv(actual,expected,opts))};function isUndefinedOrNull(value){return null===value||void 0===value}function isBuffer(x){return!(!x||"object"!==typeof x||"number"!==typeof x.length)&&("function"===typeof x.copy&&"function"===typeof x.slice&&!(x.length>0&&"number"!==typeof x[0]))}function objEquiv(a,b,opts){var i,key;if(isUndefinedOrNull(a)||isUndefinedOrNull(b))return!1;
// an identical 'prototype' property.
if(a.prototype!==b.prototype)return!1;
//~~~I've managed to break Object.keys through screwy arguments passing.
//   Converting to array solves the problem.
if(isArguments(a))return!!isArguments(b)&&(a=pSlice.call(a),b=pSlice.call(b),deepEqual(a,b,opts));if(isBuffer(a)){if(!isBuffer(b))return!1;if(a.length!==b.length)return!1;for(i=0;i<a.length;i++)if(a[i]!==b[i])return!1;return!0}try{var ka=objectKeys(a),kb=objectKeys(b)}catch(e){//happens when one is a string literal and the other isn't
return!1}
// having the same number of owned properties (keys incorporates
// hasOwnProperty)
if(ka.length!=kb.length)return!1;
//the same set of keys (although not necessarily the same order),
//~~~cheap key test
for(ka.sort(),kb.sort(),i=ka.length-1;i>=0;i--)if(ka[i]!=kb[i])return!1;
//equivalent values for every corresponding key, and
//~~~possibly expensive deep test
for(i=ka.length-1;i>=0;i--)if(key=ka[i],!deepEqual(a[key],b[key],opts))return!1;return typeof a===typeof b}
/***/},
/* 12 */
/***/function(module,exports,__nested_webpack_require_73804__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var Registry=__nested_webpack_require_73804__(1),Attributor=/** @class */function(){function Attributor(attrName,keyName,options){void 0===options&&(options={}),this.attrName=attrName,this.keyName=keyName;var attributeBit=Registry.Scope.TYPE&Registry.Scope.ATTRIBUTE;null!=options.scope?
// Ignore type bits, force attribute bit
this.scope=options.scope&Registry.Scope.LEVEL|attributeBit:this.scope=Registry.Scope.ATTRIBUTE,null!=options.whitelist&&(this.whitelist=options.whitelist)}return Attributor.keys=function(node){return[].map.call(node.attributes,(function(item){return item.name}))},Attributor.prototype.add=function(node,value){return!!this.canAdd(node,value)&&(node.setAttribute(this.keyName,value),!0)},Attributor.prototype.canAdd=function(node,value){var match=Registry.query(node,Registry.Scope.BLOT&(this.scope|Registry.Scope.TYPE));return null!=match&&(null==this.whitelist||("string"===typeof value?this.whitelist.indexOf(value.replace(/["']/g,""))>-1:this.whitelist.indexOf(value)>-1))},Attributor.prototype.remove=function(node){node.removeAttribute(this.keyName)},Attributor.prototype.value=function(node){var value=node.getAttribute(this.keyName);return this.canAdd(node,value)&&value?value:""},Attributor}();exports.default=Attributor},
/* 13 */
/***/function(module,exports,__nested_webpack_require_75851__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.Code=void 0;var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done);_n=!0)if(_arr.push(_s.value),i&&_arr.length===i)break}catch(err){_d=!0,_e=err}finally{try{!_n&&_i["return"]&&_i["return"]()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr))return arr;if(Symbol.iterator in Object(arr))return sliceIterator(arr,i);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_quillDelta=__nested_webpack_require_75851__(2),_quillDelta2=_interopRequireDefault(_quillDelta),_parchment=__nested_webpack_require_75851__(0),_parchment2=_interopRequireDefault(_parchment),_block=__nested_webpack_require_75851__(4),_block2=_interopRequireDefault(_block),_inline=__nested_webpack_require_75851__(6),_inline2=_interopRequireDefault(_inline),_text=__nested_webpack_require_75851__(7),_text2=_interopRequireDefault(_text);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var Code=function(_Inline){function Code(){return _classCallCheck(this,Code),_possibleConstructorReturn(this,(Code.__proto__||Object.getPrototypeOf(Code)).apply(this,arguments))}return _inherits(Code,_Inline),Code}(_inline2.default);Code.blotName="code",Code.tagName="CODE";var CodeBlock=function(_Block){function CodeBlock(){return _classCallCheck(this,CodeBlock),_possibleConstructorReturn(this,(CodeBlock.__proto__||Object.getPrototypeOf(CodeBlock)).apply(this,arguments))}return _inherits(CodeBlock,_Block),_createClass(CodeBlock,[{key:"delta",value:function(){var _this3=this,text=this.domNode.textContent;return text.endsWith("\n")&&(
// Should always be true
text=text.slice(0,-1)),text.split("\n").reduce((function(delta,frag){return delta.insert(frag).insert("\n",_this3.formats())}),new _quillDelta2.default)}},{key:"format",value:function(name,value){if(name!==this.statics.blotName||!value){var _descendant=this.descendant(_text2.default,this.length()-1),_descendant2=_slicedToArray(_descendant,1),text=_descendant2[0];null!=text&&text.deleteAt(text.length()-1,1),_get(CodeBlock.prototype.__proto__||Object.getPrototypeOf(CodeBlock.prototype),"format",this).call(this,name,value)}}},{key:"formatAt",value:function(index,length,name,value){if(0!==length&&null!=_parchment2.default.query(name,_parchment2.default.Scope.BLOCK)&&(name!==this.statics.blotName||value!==this.statics.formats(this.domNode))){var nextNewline=this.newlineIndex(index);if(!(nextNewline<0||nextNewline>=index+length)){var prevNewline=this.newlineIndex(index,!0)+1,isolateLength=nextNewline-prevNewline+1,blot=this.isolate(prevNewline,isolateLength),next=blot.next;blot.format(name,value),next instanceof CodeBlock&&next.formatAt(0,index-prevNewline+length-isolateLength,name,value)}}}},{key:"insertAt",value:function(index,value,def){if(null==def){var _descendant3=this.descendant(_text2.default,index),_descendant4=_slicedToArray(_descendant3,2),text=_descendant4[0],offset=_descendant4[1];text.insertAt(offset,value)}}},{key:"length",value:function(){var length=this.domNode.textContent.length;return this.domNode.textContent.endsWith("\n")?length:length+1}},{key:"newlineIndex",value:function(searchIndex){var reverse=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(reverse)return this.domNode.textContent.slice(0,searchIndex).lastIndexOf("\n");var offset=this.domNode.textContent.slice(searchIndex).indexOf("\n");return offset>-1?searchIndex+offset:-1}},{key:"optimize",value:function(context){this.domNode.textContent.endsWith("\n")||this.appendChild(_parchment2.default.create("text","\n")),_get(CodeBlock.prototype.__proto__||Object.getPrototypeOf(CodeBlock.prototype),"optimize",this).call(this,context);var next=this.next;null!=next&&next.prev===this&&next.statics.blotName===this.statics.blotName&&this.statics.formats(this.domNode)===next.statics.formats(next.domNode)&&(next.optimize(context),next.moveChildren(this),next.remove())}},{key:"replace",value:function(target){_get(CodeBlock.prototype.__proto__||Object.getPrototypeOf(CodeBlock.prototype),"replace",this).call(this,target),[].slice.call(this.domNode.querySelectorAll("*")).forEach((function(node){var blot=_parchment2.default.find(node);null==blot?node.parentNode.removeChild(node):blot instanceof _parchment2.default.Embed?blot.remove():blot.unwrap()}))}}],[{key:"create",value:function(value){var domNode=_get(CodeBlock.__proto__||Object.getPrototypeOf(CodeBlock),"create",this).call(this,value);return domNode.setAttribute("spellcheck",!1),domNode}},{key:"formats",value:function(){return!0}}]),CodeBlock}(_block2.default);CodeBlock.blotName="code-block",CodeBlock.tagName="PRE",CodeBlock.TAB="  ",exports.Code=Code,exports.default=CodeBlock},
/* 14 */
/***/function(module,exports,__nested_webpack_require_84272__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_slicedToArray=function(){function sliceIterator(arr,i){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done);_n=!0)if(_arr.push(_s.value),i&&_arr.length===i)break}catch(err){_d=!0,_e=err}finally{try{!_n&&_i["return"]&&_i["return"]()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr))return arr;if(Symbol.iterator in Object(arr))return sliceIterator(arr,i);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_quillDelta=__nested_webpack_require_84272__(2),_quillDelta2=_interopRequireDefault(_quillDelta),_op=__nested_webpack_require_84272__(20),_op2=_interopRequireDefault(_op),_parchment=__nested_webpack_require_84272__(0),_parchment2=_interopRequireDefault(_parchment),_code=__nested_webpack_require_84272__(13),_code2=_interopRequireDefault(_code),_cursor=__nested_webpack_require_84272__(24),_cursor2=_interopRequireDefault(_cursor),_block=__nested_webpack_require_84272__(4),_block2=_interopRequireDefault(_block),_break=__nested_webpack_require_84272__(16),_break2=_interopRequireDefault(_break),_clone=__nested_webpack_require_84272__(21),_clone2=_interopRequireDefault(_clone),_deepEqual=__nested_webpack_require_84272__(11),_deepEqual2=_interopRequireDefault(_deepEqual),_extend=__nested_webpack_require_84272__(3),_extend2=_interopRequireDefault(_extend);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}var ASCII=/^[ -~]*$/,Editor=function(){function Editor(scroll){_classCallCheck(this,Editor),this.scroll=scroll,this.delta=this.getDelta()}return _createClass(Editor,[{key:"applyDelta",value:function(delta){var _this=this,consumeNextNewline=!1;this.scroll.update();var scrollLength=this.scroll.length();return this.scroll.batchStart(),delta=normalizeDelta(delta),delta.reduce((function(index,op){var length=op.retain||op.delete||op.insert.length||1,attributes=op.attributes||{};if(null!=op.insert){if("string"===typeof op.insert){var text=op.insert;text.endsWith("\n")&&consumeNextNewline&&(consumeNextNewline=!1,text=text.slice(0,-1)),index>=scrollLength&&!text.endsWith("\n")&&(consumeNextNewline=!0),_this.scroll.insertAt(index,text);var _scroll$line=_this.scroll.line(index),_scroll$line2=_slicedToArray(_scroll$line,2),line=_scroll$line2[0],offset=_scroll$line2[1],formats=(0,_extend2.default)({},(0,_block.bubbleFormats)(line));if(line instanceof _block2.default){var _line$descendant=line.descendant(_parchment2.default.Leaf,offset),_line$descendant2=_slicedToArray(_line$descendant,1),leaf=_line$descendant2[0];formats=(0,_extend2.default)(formats,(0,_block.bubbleFormats)(leaf))}attributes=_op2.default.attributes.diff(formats,attributes)||{}}else if("object"===_typeof(op.insert)){var key=Object.keys(op.insert)[0];// There should only be one key
if(null==key)return index;_this.scroll.insertAt(index,key,op.insert[key])}scrollLength+=length}return Object.keys(attributes).forEach((function(name){_this.scroll.formatAt(index,length,name,attributes[name])})),index+length}),0),delta.reduce((function(index,op){return"number"===typeof op.delete?(_this.scroll.deleteAt(index,op.delete),index):index+(op.retain||op.insert.length||1)}),0),this.scroll.batchEnd(),this.update(delta)}},{key:"deleteText",value:function(index,length){return this.scroll.deleteAt(index,length),this.update((new _quillDelta2.default).retain(index).delete(length))}},{key:"formatLine",value:function(index,length){var _this2=this,formats=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this.scroll.update(),Object.keys(formats).forEach((function(format){if(null==_this2.scroll.whitelist||_this2.scroll.whitelist[format]){var lines=_this2.scroll.lines(index,Math.max(length,1)),lengthRemaining=length;lines.forEach((function(line){var lineLength=line.length();if(line instanceof _code2.default){var codeIndex=index-line.offset(_this2.scroll),codeLength=line.newlineIndex(codeIndex+lengthRemaining)-codeIndex+1;line.formatAt(codeIndex,codeLength,format,formats[format])}else line.format(format,formats[format]);lengthRemaining-=lineLength}))}})),this.scroll.optimize(),this.update((new _quillDelta2.default).retain(index).retain(length,(0,_clone2.default)(formats)))}},{key:"formatText",value:function(index,length){var _this3=this,formats=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return Object.keys(formats).forEach((function(format){_this3.scroll.formatAt(index,length,format,formats[format])})),this.update((new _quillDelta2.default).retain(index).retain(length,(0,_clone2.default)(formats)))}},{key:"getContents",value:function(index,length){return this.delta.slice(index,index+length)}},{key:"getDelta",value:function(){return this.scroll.lines().reduce((function(delta,line){return delta.concat(line.delta())}),new _quillDelta2.default)}},{key:"getFormat",value:function(index){var length=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,lines=[],leaves=[];0===length?this.scroll.path(index).forEach((function(path){var _path=_slicedToArray(path,1),blot=_path[0];blot instanceof _block2.default?lines.push(blot):blot instanceof _parchment2.default.Leaf&&leaves.push(blot)})):(lines=this.scroll.lines(index,length),leaves=this.scroll.descendants(_parchment2.default.Leaf,index,length));var formatsArr=[lines,leaves].map((function(blots){if(0===blots.length)return{};var formats=(0,_block.bubbleFormats)(blots.shift());while(Object.keys(formats).length>0){var blot=blots.shift();if(null==blot)return formats;formats=combineFormats((0,_block.bubbleFormats)(blot),formats)}return formats}));return _extend2.default.apply(_extend2.default,formatsArr)}},{key:"getText",value:function(index,length){return this.getContents(index,length).filter((function(op){return"string"===typeof op.insert})).map((function(op){return op.insert})).join("")}},{key:"insertEmbed",value:function(index,embed,value){return this.scroll.insertAt(index,embed,value),this.update((new _quillDelta2.default).retain(index).insert(_defineProperty({},embed,value)))}},{key:"insertText",value:function(index,text){var _this4=this,formats=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return text=text.replace(/\r\n/g,"\n").replace(/\r/g,"\n"),this.scroll.insertAt(index,text),Object.keys(formats).forEach((function(format){_this4.scroll.formatAt(index,text.length,format,formats[format])})),this.update((new _quillDelta2.default).retain(index).insert(text,(0,_clone2.default)(formats)))}},{key:"isBlank",value:function(){if(0==this.scroll.children.length)return!0;if(this.scroll.children.length>1)return!1;var block=this.scroll.children.head;return block.statics.blotName===_block2.default.blotName&&(!(block.children.length>1)&&block.children.head instanceof _break2.default)}},{key:"removeFormat",value:function(index,length){var text=this.getText(index,length),_scroll$line3=this.scroll.line(index+length),_scroll$line4=_slicedToArray(_scroll$line3,2),line=_scroll$line4[0],offset=_scroll$line4[1],suffixLength=0,suffix=new _quillDelta2.default;null!=line&&(suffixLength=line instanceof _code2.default?line.newlineIndex(offset)-offset+1:line.length()-offset,suffix=line.delta().slice(offset,offset+suffixLength-1).insert("\n"));var contents=this.getContents(index,length+suffixLength),diff=contents.diff((new _quillDelta2.default).insert(text).concat(suffix)),delta=(new _quillDelta2.default).retain(index).concat(diff);return this.applyDelta(delta)}},{key:"update",value:function(change){var mutations=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],cursorIndex=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,oldDelta=this.delta;if(1===mutations.length&&"characterData"===mutations[0].type&&mutations[0].target.data.match(ASCII)&&_parchment2.default.find(mutations[0].target)){
// Optimization for character changes
var textBlot=_parchment2.default.find(mutations[0].target),formats=(0,_block.bubbleFormats)(textBlot),index=textBlot.offset(this.scroll),oldValue=mutations[0].oldValue.replace(_cursor2.default.CONTENTS,""),oldText=(new _quillDelta2.default).insert(oldValue),newText=(new _quillDelta2.default).insert(textBlot.value()),diffDelta=(new _quillDelta2.default).retain(index).concat(oldText.diff(newText,cursorIndex));change=diffDelta.reduce((function(delta,op){return op.insert?delta.insert(op.insert,formats):delta.push(op)}),new _quillDelta2.default),this.delta=oldDelta.compose(change)}else this.delta=this.getDelta(),change&&(0,_deepEqual2.default)(oldDelta.compose(change),this.delta)||(change=oldDelta.diff(this.delta,cursorIndex));return change}}]),Editor}();function combineFormats(formats,combined){return Object.keys(combined).reduce((function(merged,name){return null==formats[name]||(combined[name]===formats[name]?merged[name]=combined[name]:Array.isArray(combined[name])?combined[name].indexOf(formats[name])<0&&(merged[name]=combined[name].concat([formats[name]])):merged[name]=[combined[name],formats[name]]),merged}),{})}function normalizeDelta(delta){return delta.reduce((function(delta,op){if(1===op.insert){var attributes=(0,_clone2.default)(op.attributes);return delete attributes["image"],delta.insert({image:op.attributes.image},attributes)}if(null==op.attributes||!0!==op.attributes.list&&!0!==op.attributes.bullet||(op=(0,_clone2.default)(op),op.attributes.list?op.attributes.list="ordered":(op.attributes.list="bullet",delete op.attributes.bullet)),"string"===typeof op.insert){var text=op.insert.replace(/\r\n/g,"\n").replace(/\r/g,"\n");return delta.insert(text,op.attributes)}return delta.push(op)}),new _quillDelta2.default)}exports.default=Editor},
/* 15 */
/***/function(module,exports,__nested_webpack_require_98688__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.Range=void 0;var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done);_n=!0)if(_arr.push(_s.value),i&&_arr.length===i)break}catch(err){_d=!0,_e=err}finally{try{!_n&&_i["return"]&&_i["return"]()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr))return arr;if(Symbol.iterator in Object(arr))return sliceIterator(arr,i);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_parchment=__nested_webpack_require_98688__(0),_parchment2=_interopRequireDefault(_parchment),_clone=__nested_webpack_require_98688__(21),_clone2=_interopRequireDefault(_clone),_deepEqual=__nested_webpack_require_98688__(11),_deepEqual2=_interopRequireDefault(_deepEqual),_emitter3=__nested_webpack_require_98688__(8),_emitter4=_interopRequireDefault(_emitter3),_logger=__nested_webpack_require_98688__(10),_logger2=_interopRequireDefault(_logger);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++)arr2[i]=arr[i];return arr2}return Array.from(arr)}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}var debug=(0,_logger2.default)("quill:selection"),Range=function Range(index){var length=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;_classCallCheck(this,Range),this.index=index,this.length=length},Selection=function(){function Selection(scroll,emitter){var _this=this;_classCallCheck(this,Selection),this.emitter=emitter,this.scroll=scroll,this.composing=!1,this.mouseDown=!1,this.root=this.scroll.domNode,this.cursor=_parchment2.default.create("cursor",this),
// savedRange is last non-null range
this.lastRange=this.savedRange=new Range(0,0),this.handleComposition(),this.handleDragging(),this.emitter.listenDOM("selectionchange",document,(function(){_this.mouseDown||setTimeout(_this.update.bind(_this,_emitter4.default.sources.USER),1)})),this.emitter.on(_emitter4.default.events.EDITOR_CHANGE,(function(type,delta){type===_emitter4.default.events.TEXT_CHANGE&&delta.length()>0&&_this.update(_emitter4.default.sources.SILENT)})),this.emitter.on(_emitter4.default.events.SCROLL_BEFORE_UPDATE,(function(){if(_this.hasFocus()){var native=_this.getNativeRange();null!=native&&native.start.node!==_this.cursor.textNode&&// cursor.restore() will handle
// TODO unclear if this has negative side effects
_this.emitter.once(_emitter4.default.events.SCROLL_UPDATE,(function(){try{_this.setNativeRange(native.start.node,native.start.offset,native.end.node,native.end.offset)}catch(ignored){}}))}})),this.emitter.on(_emitter4.default.events.SCROLL_OPTIMIZE,(function(mutations,context){if(context.range){var _context$range=context.range,startNode=_context$range.startNode,startOffset=_context$range.startOffset,endNode=_context$range.endNode,endOffset=_context$range.endOffset;_this.setNativeRange(startNode,startOffset,endNode,endOffset)}})),this.update(_emitter4.default.sources.SILENT)}return _createClass(Selection,[{key:"handleComposition",value:function(){var _this2=this;this.root.addEventListener("compositionstart",(function(){_this2.composing=!0})),this.root.addEventListener("compositionend",(function(){if(_this2.composing=!1,_this2.cursor.parent){var range=_this2.cursor.restore();if(!range)return;setTimeout((function(){_this2.setNativeRange(range.startNode,range.startOffset,range.endNode,range.endOffset)}),1)}}))}},{key:"handleDragging",value:function(){var _this3=this;this.emitter.listenDOM("mousedown",document.body,(function(){_this3.mouseDown=!0})),this.emitter.listenDOM("mouseup",document.body,(function(){_this3.mouseDown=!1,_this3.update(_emitter4.default.sources.USER)}))}},{key:"focus",value:function(){this.hasFocus()||(this.root.focus(),this.setRange(this.savedRange))}},{key:"format",value:function(_format,value){if(null==this.scroll.whitelist||this.scroll.whitelist[_format]){this.scroll.update();var nativeRange=this.getNativeRange();if(null!=nativeRange&&nativeRange.native.collapsed&&!_parchment2.default.query(_format,_parchment2.default.Scope.BLOCK)){if(nativeRange.start.node!==this.cursor.textNode){var blot=_parchment2.default.find(nativeRange.start.node,!1);if(null==blot)return;
// TODO Give blot ability to not split
if(blot instanceof _parchment2.default.Leaf){var after=blot.split(nativeRange.start.offset);blot.parent.insertBefore(this.cursor,after)}else blot.insertBefore(this.cursor,nativeRange.start.node);// Should never happen
this.cursor.attach()}this.cursor.format(_format,value),this.scroll.optimize(),this.setNativeRange(this.cursor.textNode,this.cursor.textNode.data.length),this.update()}}}},{key:"getBounds",value:function(index){var length=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,scrollLength=this.scroll.length();index=Math.min(index,scrollLength-1),length=Math.min(index+length,scrollLength-1)-index;var node=void 0,_scroll$leaf=this.scroll.leaf(index),_scroll$leaf2=_slicedToArray(_scroll$leaf,2),leaf=_scroll$leaf2[0],offset=_scroll$leaf2[1];if(null==leaf)return null;var _leaf$position=leaf.position(offset,!0),_leaf$position2=_slicedToArray(_leaf$position,2);node=_leaf$position2[0],offset=_leaf$position2[1];var range=document.createRange();if(length>0){range.setStart(node,offset);var _scroll$leaf3=this.scroll.leaf(index+length),_scroll$leaf4=_slicedToArray(_scroll$leaf3,2);if(leaf=_scroll$leaf4[0],offset=_scroll$leaf4[1],null==leaf)return null;var _leaf$position3=leaf.position(offset,!0),_leaf$position4=_slicedToArray(_leaf$position3,2);return node=_leaf$position4[0],offset=_leaf$position4[1],range.setEnd(node,offset),range.getBoundingClientRect()}var side="left",rect=void 0;return node instanceof Text?(offset<node.data.length?(range.setStart(node,offset),range.setEnd(node,offset+1)):(range.setStart(node,offset-1),range.setEnd(node,offset),side="right"),rect=range.getBoundingClientRect()):(rect=leaf.domNode.getBoundingClientRect(),offset>0&&(side="right")),{bottom:rect.top+rect.height,height:rect.height,left:rect[side],right:rect[side],top:rect.top,width:0}}},{key:"getNativeRange",value:function(){var selection=document.getSelection();if(null==selection||selection.rangeCount<=0)return null;var nativeRange=selection.getRangeAt(0);if(null==nativeRange)return null;var range=this.normalizeNative(nativeRange);return debug.info("getNativeRange",range),range}},{key:"getRange",value:function(){var normalized=this.getNativeRange();if(null==normalized)return[null,null];var range=this.normalizedToRange(normalized);return[range,normalized]}},{key:"hasFocus",value:function(){return document.activeElement===this.root}},{key:"normalizedToRange",value:function(range){var _this4=this,positions=[[range.start.node,range.start.offset]];range.native.collapsed||positions.push([range.end.node,range.end.offset]);var indexes=positions.map((function(position){var _position=_slicedToArray(position,2),node=_position[0],offset=_position[1],blot=_parchment2.default.find(node,!0),index=blot.offset(_this4.scroll);return 0===offset?index:blot instanceof _parchment2.default.Container?index+blot.length():index+blot.index(node,offset)})),end=Math.min(Math.max.apply(Math,_toConsumableArray(indexes)),this.scroll.length()-1),start=Math.min.apply(Math,[end].concat(_toConsumableArray(indexes)));return new Range(start,end-start)}},{key:"normalizeNative",value:function(nativeRange){if(!contains(this.root,nativeRange.startContainer)||!nativeRange.collapsed&&!contains(this.root,nativeRange.endContainer))return null;var range={start:{node:nativeRange.startContainer,offset:nativeRange.startOffset},end:{node:nativeRange.endContainer,offset:nativeRange.endOffset},native:nativeRange};return[range.start,range.end].forEach((function(position){var node=position.node,offset=position.offset;while(!(node instanceof Text)&&node.childNodes.length>0)if(node.childNodes.length>offset)node=node.childNodes[offset],offset=0;else{if(node.childNodes.length!==offset)break;node=node.lastChild,offset=node instanceof Text?node.data.length:node.childNodes.length+1}position.node=node,position.offset=offset})),range}},{key:"rangeToNative",value:function(range){var _this5=this,indexes=range.collapsed?[range.index]:[range.index,range.index+range.length],args=[],scrollLength=this.scroll.length();return indexes.forEach((function(index,i){index=Math.min(scrollLength-1,index);var node=void 0,_scroll$leaf5=_this5.scroll.leaf(index),_scroll$leaf6=_slicedToArray(_scroll$leaf5,2),leaf=_scroll$leaf6[0],offset=_scroll$leaf6[1],_leaf$position5=leaf.position(offset,0!==i),_leaf$position6=_slicedToArray(_leaf$position5,2);node=_leaf$position6[0],offset=_leaf$position6[1],args.push(node,offset)})),args.length<2&&(args=args.concat(args)),args}},{key:"scrollIntoView",value:function(scrollingContainer){var range=this.lastRange;if(null!=range){var bounds=this.getBounds(range.index,range.length);if(null!=bounds){var limit=this.scroll.length()-1,_scroll$line=this.scroll.line(Math.min(range.index,limit)),_scroll$line2=_slicedToArray(_scroll$line,1),first=_scroll$line2[0],last=first;if(range.length>0){var _scroll$line3=this.scroll.line(Math.min(range.index+range.length,limit)),_scroll$line4=_slicedToArray(_scroll$line3,1);last=_scroll$line4[0]}if(null!=first&&null!=last){var scrollBounds=scrollingContainer.getBoundingClientRect();bounds.top<scrollBounds.top?scrollingContainer.scrollTop-=scrollBounds.top-bounds.top:bounds.bottom>scrollBounds.bottom&&(scrollingContainer.scrollTop+=bounds.bottom-scrollBounds.bottom)}}}}},{key:"setNativeRange",value:function(startNode,startOffset){var endNode=arguments.length>2&&void 0!==arguments[2]?arguments[2]:startNode,endOffset=arguments.length>3&&void 0!==arguments[3]?arguments[3]:startOffset,force=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(debug.info("setNativeRange",startNode,startOffset,endNode,endOffset),null==startNode||null!=this.root.parentNode&&null!=startNode.parentNode&&null!=endNode.parentNode){var selection=document.getSelection();if(null!=selection)if(null!=startNode){this.hasFocus()||this.root.focus();var native=(this.getNativeRange()||{}).native;if(null==native||force||startNode!==native.startContainer||startOffset!==native.startOffset||endNode!==native.endContainer||endOffset!==native.endOffset){"BR"==startNode.tagName&&(startOffset=[].indexOf.call(startNode.parentNode.childNodes,startNode),startNode=startNode.parentNode),"BR"==endNode.tagName&&(endOffset=[].indexOf.call(endNode.parentNode.childNodes,endNode),endNode=endNode.parentNode);var range=document.createRange();range.setStart(startNode,startOffset),range.setEnd(endNode,endOffset),selection.removeAllRanges(),selection.addRange(range)}}else selection.removeAllRanges(),this.root.blur(),document.body.focus()}}},{key:"setRange",value:function(range){var force=arguments.length>1&&void 0!==arguments[1]&&arguments[1],source=arguments.length>2&&void 0!==arguments[2]?arguments[2]:_emitter4.default.sources.API;if("string"===typeof force&&(source=force,force=!1),debug.info("setRange",range),null!=range){var args=this.rangeToNative(range);this.setNativeRange.apply(this,_toConsumableArray(args).concat([force]))}else this.setNativeRange(null);this.update(source)}},{key:"update",value:function(){var source=arguments.length>0&&void 0!==arguments[0]?arguments[0]:_emitter4.default.sources.USER,oldRange=this.lastRange,_getRange=this.getRange(),_getRange2=_slicedToArray(_getRange,2),lastRange=_getRange2[0],nativeRange=_getRange2[1];if(this.lastRange=lastRange,null!=this.lastRange&&(this.savedRange=this.lastRange),!(0,_deepEqual2.default)(oldRange,this.lastRange)){var _emitter;!this.composing&&null!=nativeRange&&nativeRange.native.collapsed&&nativeRange.start.node!==this.cursor.textNode&&this.cursor.restore();var _emitter2,args=[_emitter4.default.events.SELECTION_CHANGE,(0,_clone2.default)(this.lastRange),(0,_clone2.default)(oldRange),source];if((_emitter=this.emitter).emit.apply(_emitter,[_emitter4.default.events.EDITOR_CHANGE].concat(args)),source!==_emitter4.default.sources.SILENT)(_emitter2=this.emitter).emit.apply(_emitter2,args)}}}]),Selection}();function contains(parent,descendant){try{
// Firefox inserts inaccessible nodes around video elements
descendant.parentNode}catch(e){return!1}
// IE11 has bug with Text nodes
// https://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect
return descendant instanceof Text&&(descendant=descendant.parentNode),parent.contains(descendant)}exports.Range=Range,exports.default=Selection},
/* 16 */
/***/function(module,exports,__nested_webpack_require_116908__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_parchment=__nested_webpack_require_116908__(0),_parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var Break=function(_Parchment$Embed){function Break(){return _classCallCheck(this,Break),_possibleConstructorReturn(this,(Break.__proto__||Object.getPrototypeOf(Break)).apply(this,arguments))}return _inherits(Break,_Parchment$Embed),_createClass(Break,[{key:"insertInto",value:function(parent,ref){0===parent.children.length?_get(Break.prototype.__proto__||Object.getPrototypeOf(Break.prototype),"insertInto",this).call(this,parent,ref):this.remove()}},{key:"length",value:function(){return 0}},{key:"value",value:function(){return""}}],[{key:"value",value:function(){}}]),Break}(_parchment2.default.Embed);Break.blotName="break",Break.tagName="BR",exports.default=Break},
/* 17 */
/***/function(module,exports,__nested_webpack_require_120162__){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p])};return function(d,b){function __(){this.constructor=d}extendStatics(d,b),d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:!0});var linked_list_1=__nested_webpack_require_120162__(44),shadow_1=__nested_webpack_require_120162__(30),Registry=__nested_webpack_require_120162__(1),ContainerBlot=/** @class */function(_super){function ContainerBlot(domNode){var _this=_super.call(this,domNode)||this;return _this.build(),_this}return __extends(ContainerBlot,_super),ContainerBlot.prototype.appendChild=function(other){this.insertBefore(other)},ContainerBlot.prototype.attach=function(){_super.prototype.attach.call(this),this.children.forEach((function(child){child.attach()}))},ContainerBlot.prototype.build=function(){var _this=this;this.children=new linked_list_1.default,
// Need to be reversed for if DOM nodes already in order
[].slice.call(this.domNode.childNodes).reverse().forEach((function(node){try{var child=makeBlot(node);_this.insertBefore(child,_this.children.head||void 0)}catch(err){if(err instanceof Registry.ParchmentError)return;throw err}}))},ContainerBlot.prototype.deleteAt=function(index,length){if(0===index&&length===this.length())return this.remove();this.children.forEachAt(index,length,(function(child,offset,length){child.deleteAt(offset,length)}))},ContainerBlot.prototype.descendant=function(criteria,index){var _a=this.children.find(index),child=_a[0],offset=_a[1];return null==criteria.blotName&&criteria(child)||null!=criteria.blotName&&child instanceof criteria?[child,offset]:child instanceof ContainerBlot?child.descendant(criteria,offset):[null,-1]},ContainerBlot.prototype.descendants=function(criteria,index,length){void 0===index&&(index=0),void 0===length&&(length=Number.MAX_VALUE);var descendants=[],lengthLeft=length;return this.children.forEachAt(index,length,(function(child,index,length){(null==criteria.blotName&&criteria(child)||null!=criteria.blotName&&child instanceof criteria)&&descendants.push(child),child instanceof ContainerBlot&&(descendants=descendants.concat(child.descendants(criteria,index,lengthLeft))),lengthLeft-=length})),descendants},ContainerBlot.prototype.detach=function(){this.children.forEach((function(child){child.detach()})),_super.prototype.detach.call(this)},ContainerBlot.prototype.formatAt=function(index,length,name,value){this.children.forEachAt(index,length,(function(child,offset,length){child.formatAt(offset,length,name,value)}))},ContainerBlot.prototype.insertAt=function(index,value,def){var _a=this.children.find(index),child=_a[0],offset=_a[1];if(child)child.insertAt(offset,value,def);else{var blot=null==def?Registry.create("text",value):Registry.create(value,def);this.appendChild(blot)}},ContainerBlot.prototype.insertBefore=function(childBlot,refBlot){if(null!=this.statics.allowedChildren&&!this.statics.allowedChildren.some((function(child){return childBlot instanceof child})))throw new Registry.ParchmentError("Cannot insert "+childBlot.statics.blotName+" into "+this.statics.blotName);childBlot.insertInto(this,refBlot)},ContainerBlot.prototype.length=function(){return this.children.reduce((function(memo,child){return memo+child.length()}),0)},ContainerBlot.prototype.moveChildren=function(targetParent,refNode){this.children.forEach((function(child){targetParent.insertBefore(child,refNode)}))},ContainerBlot.prototype.optimize=function(context){if(_super.prototype.optimize.call(this,context),0===this.children.length)if(null!=this.statics.defaultChild){var child=Registry.create(this.statics.defaultChild);this.appendChild(child),child.optimize(context)}else this.remove()},ContainerBlot.prototype.path=function(index,inclusive){void 0===inclusive&&(inclusive=!1);var _a=this.children.find(index,inclusive),child=_a[0],offset=_a[1],position=[[this,index]];return child instanceof ContainerBlot?position.concat(child.path(offset,inclusive)):(null!=child&&position.push([child,offset]),position)},ContainerBlot.prototype.removeChild=function(child){this.children.remove(child)},ContainerBlot.prototype.replace=function(target){target instanceof ContainerBlot&&target.moveChildren(this),_super.prototype.replace.call(this,target)},ContainerBlot.prototype.split=function(index,force){if(void 0===force&&(force=!1),!force){if(0===index)return this;if(index===this.length())return this.next}var after=this.clone();return this.parent.insertBefore(after,this.next),this.children.forEachAt(index,this.length(),(function(child,offset,length){child=child.split(offset,force),after.appendChild(child)})),after},ContainerBlot.prototype.unwrap=function(){this.moveChildren(this.parent,this.next),this.remove()},ContainerBlot.prototype.update=function(mutations,context){var _this=this,addedNodes=[],removedNodes=[];mutations.forEach((function(mutation){mutation.target===_this.domNode&&"childList"===mutation.type&&(addedNodes.push.apply(addedNodes,mutation.addedNodes),removedNodes.push.apply(removedNodes,mutation.removedNodes))})),removedNodes.forEach((function(node){
// Check node has actually been removed
// One exception is Chrome does not immediately remove IFRAMEs
// from DOM but MutationRecord is correct in its reported removal
if(!(null!=node.parentNode&&
// @ts-ignore
"IFRAME"!==node.tagName&&document.body.compareDocumentPosition(node)&Node.DOCUMENT_POSITION_CONTAINED_BY)){var blot=Registry.find(node);null!=blot&&(null!=blot.domNode.parentNode&&blot.domNode.parentNode!==_this.domNode||blot.detach())}})),addedNodes.filter((function(node){return node.parentNode==_this.domNode})).sort((function(a,b){return a===b?0:a.compareDocumentPosition(b)&Node.DOCUMENT_POSITION_FOLLOWING?1:-1})).forEach((function(node){var refBlot=null;null!=node.nextSibling&&(refBlot=Registry.find(node.nextSibling));var blot=makeBlot(node);blot.next==refBlot&&null!=blot.next||(null!=blot.parent&&blot.parent.removeChild(_this),_this.insertBefore(blot,refBlot||void 0))}))},ContainerBlot}(shadow_1.default);function makeBlot(node){var blot=Registry.find(node);if(null==blot)try{blot=Registry.create(node)}catch(e){blot=Registry.create(Registry.Scope.INLINE),[].slice.call(node.childNodes).forEach((function(child){
// @ts-ignore
blot.domNode.appendChild(child)})),node.parentNode&&node.parentNode.replaceChild(blot.domNode,node),blot.attach()}return blot}exports.default=ContainerBlot},
/* 18 */
/***/function(module,exports,__nested_webpack_require_130088__){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p])};return function(d,b){function __(){this.constructor=d}extendStatics(d,b),d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:!0});var attributor_1=__nested_webpack_require_130088__(12),store_1=__nested_webpack_require_130088__(31),container_1=__nested_webpack_require_130088__(17),Registry=__nested_webpack_require_130088__(1),FormatBlot=/** @class */function(_super){function FormatBlot(domNode){var _this=_super.call(this,domNode)||this;return _this.attributes=new store_1.default(_this.domNode),_this}return __extends(FormatBlot,_super),FormatBlot.formats=function(domNode){return"string"===typeof this.tagName||(Array.isArray(this.tagName)?domNode.tagName.toLowerCase():void 0)},FormatBlot.prototype.format=function(name,value){var format=Registry.query(name);format instanceof attributor_1.default?this.attributes.attribute(format,value):value&&(null==format||name===this.statics.blotName&&this.formats()[name]===value||this.replaceWith(name,value))},FormatBlot.prototype.formats=function(){var formats=this.attributes.values(),format=this.statics.formats(this.domNode);return null!=format&&(formats[this.statics.blotName]=format),formats},FormatBlot.prototype.replaceWith=function(name,value){var replacement=_super.prototype.replaceWith.call(this,name,value);return this.attributes.copy(replacement),replacement},FormatBlot.prototype.update=function(mutations,context){var _this=this;_super.prototype.update.call(this,mutations,context),mutations.some((function(mutation){return mutation.target===_this.domNode&&"attributes"===mutation.type}))&&this.attributes.build()},FormatBlot.prototype.wrap=function(name,value){var wrapper=_super.prototype.wrap.call(this,name,value);return wrapper instanceof FormatBlot&&wrapper.statics.scope===this.statics.scope&&this.attributes.move(wrapper),wrapper},FormatBlot}(container_1.default);exports.default=FormatBlot},
/* 19 */
/***/function(module,exports,__nested_webpack_require_133111__){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p])};return function(d,b){function __(){this.constructor=d}extendStatics(d,b),d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:!0});var shadow_1=__nested_webpack_require_133111__(30),Registry=__nested_webpack_require_133111__(1),LeafBlot=/** @class */function(_super){function LeafBlot(){return null!==_super&&_super.apply(this,arguments)||this}return __extends(LeafBlot,_super),LeafBlot.value=function(domNode){return!0},LeafBlot.prototype.index=function(node,offset){return this.domNode===node||this.domNode.compareDocumentPosition(node)&Node.DOCUMENT_POSITION_CONTAINED_BY?Math.min(offset,1):-1},LeafBlot.prototype.position=function(index,inclusive){var offset=[].indexOf.call(this.parent.domNode.childNodes,this.domNode);return index>0&&(offset+=1),[this.parent.domNode,offset]},LeafBlot.prototype.value=function(){var _a;return _a={},_a[this.statics.blotName]=this.statics.value(this.domNode)||!0,_a},LeafBlot.scope=Registry.Scope.INLINE_BLOT,LeafBlot}(shadow_1.default);exports.default=LeafBlot},
/* 20 */
/***/function(module,exports,__nested_webpack_require_134898__){var equal=__nested_webpack_require_134898__(11),extend=__nested_webpack_require_134898__(3),lib={attributes:{compose:function(a,b,keepNull){"object"!==typeof a&&(a={}),"object"!==typeof b&&(b={});var attributes=extend(!0,{},b);for(var key in keepNull||(attributes=Object.keys(attributes).reduce((function(copy,key){return null!=attributes[key]&&(copy[key]=attributes[key]),copy}),{})),a)void 0!==a[key]&&void 0===b[key]&&(attributes[key]=a[key]);return Object.keys(attributes).length>0?attributes:void 0},diff:function(a,b){"object"!==typeof a&&(a={}),"object"!==typeof b&&(b={});var attributes=Object.keys(a).concat(Object.keys(b)).reduce((function(attributes,key){return equal(a[key],b[key])||(attributes[key]=void 0===b[key]?null:b[key]),attributes}),{});return Object.keys(attributes).length>0?attributes:void 0},transform:function(a,b,priority){if("object"!==typeof a)return b;if("object"===typeof b){if(!priority)return b;// b simply overwrites us without priority
var attributes=Object.keys(b).reduce((function(attributes,key){// null is a valid value
return void 0===a[key]&&(attributes[key]=b[key]),attributes}),{});return Object.keys(attributes).length>0?attributes:void 0}}},iterator:function(ops){return new Iterator(ops)},length:function(op){return"number"===typeof op["delete"]?op["delete"]:"number"===typeof op.retain?op.retain:"string"===typeof op.insert?op.insert.length:1}};function Iterator(ops){this.ops=ops,this.index=0,this.offset=0}Iterator.prototype.hasNext=function(){return this.peekLength()<1/0},Iterator.prototype.next=function(length){length||(length=1/0);var nextOp=this.ops[this.index];if(nextOp){var offset=this.offset,opLength=lib.length(nextOp);if(length>=opLength-offset?(length=opLength-offset,this.index+=1,this.offset=0):this.offset+=length,"number"===typeof nextOp["delete"])return{delete:length};var retOp={};return nextOp.attributes&&(retOp.attributes=nextOp.attributes),"number"===typeof nextOp.retain?retOp.retain=length:"string"===typeof nextOp.insert?retOp.insert=nextOp.insert.substr(offset,length):
// offset should === 0, length should === 1
retOp.insert=nextOp.insert,retOp}return{retain:1/0}},Iterator.prototype.peek=function(){return this.ops[this.index]},Iterator.prototype.peekLength=function(){return this.ops[this.index]?lib.length(this.ops[this.index])-this.offset:1/0},Iterator.prototype.peekType=function(){return this.ops[this.index]?"number"===typeof this.ops[this.index]["delete"]?"delete":"number"===typeof this.ops[this.index].retain?"retain":"insert":"retain"},Iterator.prototype.rest=function(){if(this.hasNext()){if(0===this.offset)return this.ops.slice(this.index);var offset=this.offset,index=this.index,next=this.next(),rest=this.ops.slice(this.index);return this.offset=offset,this.index=index,[next].concat(rest)}return[]},module.exports=lib},
/* 21 */
/***/function(module,exports){var clone=function(){"use strict";function _instanceof(obj,type){return null!=type&&obj instanceof type}var nativeMap,nativeSet,nativePromise;try{nativeMap=Map}catch(_){
// maybe a reference error because no `Map`. Give it a dummy value that no
// value will ever be an instanceof.
nativeMap=function(){}}try{nativeSet=Set}catch(_){nativeSet=function(){}}try{nativePromise=Promise}catch(_){nativePromise=function(){}}
/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
 *    should be cloned as well. Non-enumerable properties on the prototype
 *    chain will be ignored. (optional - false by default)
*/function clone(parent,circular,depth,prototype,includeNonEnumerable){"object"===typeof circular&&(depth=circular.depth,prototype=circular.prototype,includeNonEnumerable=circular.includeNonEnumerable,circular=circular.circular);
// maintain two arrays for circular references, where corresponding parents
// and children have the same index
var allParents=[],allChildren=[],useBuffer="undefined"!=typeof Buffer;
// recurse this function so we don't reset allParents and allChildren
function _clone(parent,depth){
// cloning null always returns null
if(null===parent)return null;if(0===depth)return parent;var child,proto;if("object"!=typeof parent)return parent;if(_instanceof(parent,nativeMap))child=new nativeMap;else if(_instanceof(parent,nativeSet))child=new nativeSet;else if(_instanceof(parent,nativePromise))child=new nativePromise((function(resolve,reject){parent.then((function(value){resolve(_clone(value,depth-1))}),(function(err){reject(_clone(err,depth-1))}))}));else if(clone.__isArray(parent))child=[];else if(clone.__isRegExp(parent))child=new RegExp(parent.source,__getRegExpFlags(parent)),parent.lastIndex&&(child.lastIndex=parent.lastIndex);else if(clone.__isDate(parent))child=new Date(parent.getTime());else{if(useBuffer&&Buffer.isBuffer(parent))
// Node.js >= 4.5.0
return child=Buffer.allocUnsafe?Buffer.allocUnsafe(parent.length):new Buffer(parent.length),parent.copy(child),child;_instanceof(parent,Error)?child=Object.create(parent):"undefined"==typeof prototype?(proto=Object.getPrototypeOf(parent),child=Object.create(proto)):(child=Object.create(prototype),proto=prototype)}if(circular){var index=allParents.indexOf(parent);if(-1!=index)return allChildren[index];allParents.push(parent),allChildren.push(child)}for(var i in _instanceof(parent,nativeMap)&&parent.forEach((function(value,key){var keyChild=_clone(key,depth-1),valueChild=_clone(value,depth-1);child.set(keyChild,valueChild)})),_instanceof(parent,nativeSet)&&parent.forEach((function(value){var entryChild=_clone(value,depth-1);child.add(entryChild)})),parent){var attrs;proto&&(attrs=Object.getOwnPropertyDescriptor(proto,i)),attrs&&null==attrs.set||(child[i]=_clone(parent[i],depth-1))}if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(parent);for(i=0;i<symbols.length;i++){
// Don't need to worry about cloning a symbol because it is a primitive,
// like a number or string.
var symbol=symbols[i],descriptor=Object.getOwnPropertyDescriptor(parent,symbol);(!descriptor||descriptor.enumerable||includeNonEnumerable)&&(child[symbol]=_clone(parent[symbol],depth-1),descriptor.enumerable||Object.defineProperty(child,symbol,{enumerable:!1}))}}if(includeNonEnumerable){var allPropertyNames=Object.getOwnPropertyNames(parent);for(i=0;i<allPropertyNames.length;i++){var propertyName=allPropertyNames[i];descriptor=Object.getOwnPropertyDescriptor(parent,propertyName);descriptor&&descriptor.enumerable||(child[propertyName]=_clone(parent[propertyName],depth-1),Object.defineProperty(child,propertyName,{enumerable:!1}))}}return child}return"undefined"==typeof circular&&(circular=!0),"undefined"==typeof depth&&(depth=1/0),_clone(parent,depth)}
/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
// private utility functions
function __objToStr(o){return Object.prototype.toString.call(o)}function __isDate(o){return"object"===typeof o&&"[object Date]"===__objToStr(o)}function __isArray(o){return"object"===typeof o&&"[object Array]"===__objToStr(o)}function __isRegExp(o){return"object"===typeof o&&"[object RegExp]"===__objToStr(o)}function __getRegExpFlags(re){var flags="";return re.global&&(flags+="g"),re.ignoreCase&&(flags+="i"),re.multiline&&(flags+="m"),flags}return clone.clonePrototype=function(parent){if(null===parent)return null;var c=function(){};return c.prototype=parent,new c},clone.__objToStr=__objToStr,clone.__isDate=__isDate,clone.__isArray=__isArray,clone.__isRegExp=__isRegExp,clone.__getRegExpFlags=__getRegExpFlags,clone}();"object"===typeof module&&module.exports&&(module.exports=clone)
/***/},
/* 22 */
/***/function(module,exports,__nested_webpack_require_146497__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done);_n=!0)if(_arr.push(_s.value),i&&_arr.length===i)break}catch(err){_d=!0,_e=err}finally{try{!_n&&_i["return"]&&_i["return"]()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr))return arr;if(Symbol.iterator in Object(arr))return sliceIterator(arr,i);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_parchment=__nested_webpack_require_146497__(0),_parchment2=_interopRequireDefault(_parchment),_emitter=__nested_webpack_require_146497__(8),_emitter2=_interopRequireDefault(_emitter),_block=__nested_webpack_require_146497__(4),_block2=_interopRequireDefault(_block),_break=__nested_webpack_require_146497__(16),_break2=_interopRequireDefault(_break),_code=__nested_webpack_require_146497__(13),_code2=_interopRequireDefault(_code),_container=__nested_webpack_require_146497__(25),_container2=_interopRequireDefault(_container);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}function isLine(blot){return blot instanceof _block2.default||blot instanceof _block.BlockEmbed}var Scroll=function(_Parchment$Scroll){function Scroll(domNode,config){_classCallCheck(this,Scroll);var _this=_possibleConstructorReturn(this,(Scroll.__proto__||Object.getPrototypeOf(Scroll)).call(this,domNode));return _this.emitter=config.emitter,Array.isArray(config.whitelist)&&(_this.whitelist=config.whitelist.reduce((function(whitelist,format){return whitelist[format]=!0,whitelist}),{})),
// Some reason fixes composition issues with character languages in Windows/Chrome, Safari
_this.domNode.addEventListener("DOMNodeInserted",(function(){})),_this.optimize(),_this.enable(),_this}return _inherits(Scroll,_Parchment$Scroll),_createClass(Scroll,[{key:"batchStart",value:function(){this.batch=!0}},{key:"batchEnd",value:function(){this.batch=!1,this.optimize()}},{key:"deleteAt",value:function(index,length){var _line=this.line(index),_line2=_slicedToArray(_line,2),first=_line2[0],offset=_line2[1],_line3=this.line(index+length),_line4=_slicedToArray(_line3,1),last=_line4[0];if(_get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),"deleteAt",this).call(this,index,length),null!=last&&first!==last&&offset>0){if(first instanceof _block.BlockEmbed||last instanceof _block.BlockEmbed)return void this.optimize();if(first instanceof _code2.default){var newlineIndex=first.newlineIndex(first.length(),!0);if(newlineIndex>-1&&(first=first.split(newlineIndex+1),first===last))return void this.optimize()}else if(last instanceof _code2.default){var _newlineIndex=last.newlineIndex(0);_newlineIndex>-1&&last.split(_newlineIndex+1)}var ref=last.children.head instanceof _break2.default?null:last.children.head;first.moveChildren(last,ref),first.remove()}this.optimize()}},{key:"enable",value:function(){var enabled=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.domNode.setAttribute("contenteditable",enabled)}},{key:"formatAt",value:function(index,length,format,value){(null==this.whitelist||this.whitelist[format])&&(_get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),"formatAt",this).call(this,index,length,format,value),this.optimize())}},{key:"insertAt",value:function(index,value,def){if(null==def||null==this.whitelist||this.whitelist[value]){if(index>=this.length())if(null==def||null==_parchment2.default.query(value,_parchment2.default.Scope.BLOCK)){var blot=_parchment2.default.create(this.statics.defaultChild);this.appendChild(blot),null==def&&value.endsWith("\n")&&(value=value.slice(0,-1)),blot.insertAt(0,value,def)}else{var embed=_parchment2.default.create(value,def);this.appendChild(embed)}else _get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),"insertAt",this).call(this,index,value,def);this.optimize()}}},{key:"insertBefore",value:function(blot,ref){if(blot.statics.scope===_parchment2.default.Scope.INLINE_BLOT){var wrapper=_parchment2.default.create(this.statics.defaultChild);wrapper.appendChild(blot),blot=wrapper}_get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),"insertBefore",this).call(this,blot,ref)}},{key:"leaf",value:function(index){return this.path(index).pop()||[null,-1]}},{key:"line",value:function(index){return index===this.length()?this.line(index-1):this.descendant(isLine,index)}},{key:"lines",value:function(){var index=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,length=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Number.MAX_VALUE,getLines=function getLines(blot,index,length){var lines=[],lengthLeft=length;return blot.children.forEachAt(index,length,(function(child,index,length){isLine(child)?lines.push(child):child instanceof _parchment2.default.Container&&(lines=lines.concat(getLines(child,index,lengthLeft))),lengthLeft-=length})),lines};return getLines(this,index,length)}},{key:"optimize",value:function(){var mutations=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],context=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};!0!==this.batch&&(_get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),"optimize",this).call(this,mutations,context),mutations.length>0&&this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE,mutations,context))}},{key:"path",value:function(index){return _get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),"path",this).call(this,index).slice(1);// Exclude self
}},{key:"update",value:function(mutations){if(!0!==this.batch){var source=_emitter2.default.sources.USER;"string"===typeof mutations&&(source=mutations),Array.isArray(mutations)||(mutations=this.observer.takeRecords()),mutations.length>0&&this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE,source,mutations),_get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),"update",this).call(this,mutations.concat([])),// pass copy
mutations.length>0&&this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE,source,mutations)}}}]),Scroll}(_parchment2.default.Scroll);Scroll.blotName="scroll",Scroll.className="ql-editor",Scroll.tagName="DIV",Scroll.defaultChild="block",Scroll.allowedChildren=[_block2.default,_block.BlockEmbed,_container2.default],exports.default=Scroll},
/* 23 */
/***/function(module,exports,__nested_webpack_require_157111__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SHORTKEY=exports.default=void 0;var _typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_slicedToArray=function(){function sliceIterator(arr,i){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done);_n=!0)if(_arr.push(_s.value),i&&_arr.length===i)break}catch(err){_d=!0,_e=err}finally{try{!_n&&_i["return"]&&_i["return"]()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr))return arr;if(Symbol.iterator in Object(arr))return sliceIterator(arr,i);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_clone=__nested_webpack_require_157111__(21),_clone2=_interopRequireDefault(_clone),_deepEqual=__nested_webpack_require_157111__(11),_deepEqual2=_interopRequireDefault(_deepEqual),_extend=__nested_webpack_require_157111__(3),_extend2=_interopRequireDefault(_extend),_quillDelta=__nested_webpack_require_157111__(2),_quillDelta2=_interopRequireDefault(_quillDelta),_op=__nested_webpack_require_157111__(20),_op2=_interopRequireDefault(_op),_parchment=__nested_webpack_require_157111__(0),_parchment2=_interopRequireDefault(_parchment),_quill=__nested_webpack_require_157111__(5),_quill2=_interopRequireDefault(_quill),_logger=__nested_webpack_require_157111__(10),_logger2=_interopRequireDefault(_logger),_module=__nested_webpack_require_157111__(9),_module2=_interopRequireDefault(_module);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var debug=(0,_logger2.default)("quill:keyboard"),SHORTKEY=/Mac/i.test(navigator.platform)?"metaKey":"ctrlKey",Keyboard=function(_Module){function Keyboard(quill,options){_classCallCheck(this,Keyboard);var _this=_possibleConstructorReturn(this,(Keyboard.__proto__||Object.getPrototypeOf(Keyboard)).call(this,quill,options));return _this.bindings={},Object.keys(_this.options.bindings).forEach((function(name){("list autofill"!==name||null==quill.scroll.whitelist||quill.scroll.whitelist["list"])&&_this.options.bindings[name]&&_this.addBinding(_this.options.bindings[name])})),_this.addBinding({key:Keyboard.keys.ENTER,shiftKey:null},handleEnter),_this.addBinding({key:Keyboard.keys.ENTER,metaKey:null,ctrlKey:null,altKey:null},(function(){})),/Firefox/i.test(navigator.userAgent)?(
// Need to handle delete and backspace for Firefox in the general case #1171
_this.addBinding({key:Keyboard.keys.BACKSPACE},{collapsed:!0},handleBackspace),_this.addBinding({key:Keyboard.keys.DELETE},{collapsed:!0},handleDelete)):(_this.addBinding({key:Keyboard.keys.BACKSPACE},{collapsed:!0,prefix:/^.?$/},handleBackspace),_this.addBinding({key:Keyboard.keys.DELETE},{collapsed:!0,suffix:/^.?$/},handleDelete)),_this.addBinding({key:Keyboard.keys.BACKSPACE},{collapsed:!1},handleDeleteRange),_this.addBinding({key:Keyboard.keys.DELETE},{collapsed:!1},handleDeleteRange),_this.addBinding({key:Keyboard.keys.BACKSPACE,altKey:null,ctrlKey:null,metaKey:null,shiftKey:null},{collapsed:!0,offset:0},handleBackspace),_this.listen(),_this}return _inherits(Keyboard,_Module),_createClass(Keyboard,null,[{key:"match",value:function(evt,binding){return binding=normalize(binding),!["altKey","ctrlKey","metaKey","shiftKey"].some((function(key){return!!binding[key]!==evt[key]&&null!==binding[key]}))&&binding.key===(evt.which||evt.keyCode)}}]),_createClass(Keyboard,[{key:"addBinding",value:function(key){var context=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},handler=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},binding=normalize(key);if(null==binding||null==binding.key)return debug.warn("Attempted to add invalid keyboard binding",binding);"function"===typeof context&&(context={handler:context}),"function"===typeof handler&&(handler={handler:handler}),binding=(0,_extend2.default)(binding,context,handler),this.bindings[binding.key]=this.bindings[binding.key]||[],this.bindings[binding.key].push(binding)}},{key:"listen",value:function(){var _this2=this;this.quill.root.addEventListener("keydown",(function(evt){if(!evt.defaultPrevented){var which=evt.which||evt.keyCode,bindings=(_this2.bindings[which]||[]).filter((function(binding){return Keyboard.match(evt,binding)}));if(0!==bindings.length){var range=_this2.quill.getSelection();if(null!=range&&_this2.quill.hasFocus()){var _quill$getLine=_this2.quill.getLine(range.index),_quill$getLine2=_slicedToArray(_quill$getLine,2),line=_quill$getLine2[0],offset=_quill$getLine2[1],_quill$getLeaf=_this2.quill.getLeaf(range.index),_quill$getLeaf2=_slicedToArray(_quill$getLeaf,2),leafStart=_quill$getLeaf2[0],offsetStart=_quill$getLeaf2[1],_ref=0===range.length?[leafStart,offsetStart]:_this2.quill.getLeaf(range.index+range.length),_ref2=_slicedToArray(_ref,2),leafEnd=_ref2[0],offsetEnd=_ref2[1],prefixText=leafStart instanceof _parchment2.default.Text?leafStart.value().slice(0,offsetStart):"",suffixText=leafEnd instanceof _parchment2.default.Text?leafEnd.value().slice(offsetEnd):"",curContext={collapsed:0===range.length,empty:0===range.length&&line.length()<=1,format:_this2.quill.getFormat(range),offset:offset,prefix:prefixText,suffix:suffixText},prevented=bindings.some((function(binding){if(null!=binding.collapsed&&binding.collapsed!==curContext.collapsed)return!1;if(null!=binding.empty&&binding.empty!==curContext.empty)return!1;if(null!=binding.offset&&binding.offset!==curContext.offset)return!1;if(Array.isArray(binding.format)){
// any format is present
if(binding.format.every((function(name){return null==curContext.format[name]})))return!1}else if("object"===_typeof(binding.format)&&!Object.keys(binding.format).every((function(name){return!0===binding.format[name]?null!=curContext.format[name]:!1===binding.format[name]?null==curContext.format[name]:(0,_deepEqual2.default)(binding.format[name],curContext.format[name])})))return!1;return!(null!=binding.prefix&&!binding.prefix.test(curContext.prefix))&&(!(null!=binding.suffix&&!binding.suffix.test(curContext.suffix))&&!0!==binding.handler.call(_this2,range,curContext))}));prevented&&evt.preventDefault()}}}}))}}]),Keyboard}(_module2.default);function makeEmbedArrowHandler(key,shiftKey){var _ref3,where=key===Keyboard.keys.LEFT?"prefix":"suffix";return _ref3={key:key,shiftKey:shiftKey,altKey:null},_defineProperty(_ref3,where,/^$/),_defineProperty(_ref3,"handler",(function(range){var index=range.index;key===Keyboard.keys.RIGHT&&(index+=range.length+1);var _quill$getLeaf3=this.quill.getLeaf(index),_quill$getLeaf4=_slicedToArray(_quill$getLeaf3,1),leaf=_quill$getLeaf4[0];return!(leaf instanceof _parchment2.default.Embed)||(key===Keyboard.keys.LEFT?shiftKey?this.quill.setSelection(range.index-1,range.length+1,_quill2.default.sources.USER):this.quill.setSelection(range.index-1,_quill2.default.sources.USER):shiftKey?this.quill.setSelection(range.index,range.length+1,_quill2.default.sources.USER):this.quill.setSelection(range.index+range.length+1,_quill2.default.sources.USER),!1)})),_ref3}function handleBackspace(range,context){if(!(0===range.index||this.quill.getLength()<=1)){var _quill$getLine11=this.quill.getLine(range.index),_quill$getLine12=_slicedToArray(_quill$getLine11,1),line=_quill$getLine12[0],formats={};if(0===context.offset){var _quill$getLine13=this.quill.getLine(range.index-1),_quill$getLine14=_slicedToArray(_quill$getLine13,1),prev=_quill$getLine14[0];if(null!=prev&&prev.length()>1){var curFormats=line.formats(),prevFormats=this.quill.getFormat(range.index-1,1);formats=_op2.default.attributes.diff(curFormats,prevFormats)||{}}}
// Check for astral symbols
var length=/[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context.prefix)?2:1;this.quill.deleteText(range.index-length,length,_quill2.default.sources.USER),Object.keys(formats).length>0&&this.quill.formatLine(range.index-length,length,formats,_quill2.default.sources.USER),this.quill.focus()}}function handleDelete(range,context){
// Check for astral symbols
var length=/^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context.suffix)?2:1;if(!(range.index>=this.quill.getLength()-length)){var formats={},nextLength=0,_quill$getLine15=this.quill.getLine(range.index),_quill$getLine16=_slicedToArray(_quill$getLine15,1),line=_quill$getLine16[0];if(context.offset>=line.length()-1){var _quill$getLine17=this.quill.getLine(range.index+1),_quill$getLine18=_slicedToArray(_quill$getLine17,1),next=_quill$getLine18[0];if(next){var curFormats=line.formats(),nextFormats=this.quill.getFormat(range.index,1);formats=_op2.default.attributes.diff(curFormats,nextFormats)||{},nextLength=next.length()}}this.quill.deleteText(range.index,length,_quill2.default.sources.USER),Object.keys(formats).length>0&&this.quill.formatLine(range.index+nextLength-1,length,formats,_quill2.default.sources.USER)}}function handleDeleteRange(range){var lines=this.quill.getLines(range),formats={};if(lines.length>1){var firstFormats=lines[0].formats(),lastFormats=lines[lines.length-1].formats();formats=_op2.default.attributes.diff(lastFormats,firstFormats)||{}}this.quill.deleteText(range,_quill2.default.sources.USER),Object.keys(formats).length>0&&this.quill.formatLine(range.index,1,formats,_quill2.default.sources.USER),this.quill.setSelection(range.index,_quill2.default.sources.SILENT),this.quill.focus()}function handleEnter(range,context){var _this3=this;range.length>0&&this.quill.scroll.deleteAt(range.index,range.length);var lineFormats=Object.keys(context.format).reduce((function(lineFormats,format){return _parchment2.default.query(format,_parchment2.default.Scope.BLOCK)&&!Array.isArray(context.format[format])&&(lineFormats[format]=context.format[format]),lineFormats}),{});this.quill.insertText(range.index,"\n",lineFormats,_quill2.default.sources.USER),
// Earlier scroll.deleteAt might have messed up our selection,
// so insertText's built in selection preservation is not reliable
this.quill.setSelection(range.index+1,_quill2.default.sources.SILENT),this.quill.focus(),Object.keys(context.format).forEach((function(name){null==lineFormats[name]&&(Array.isArray(context.format[name])||"link"!==name&&_this3.quill.format(name,context.format[name],_quill2.default.sources.USER))}))}function makeCodeBlockHandler(indent){return{key:Keyboard.keys.TAB,shiftKey:!indent,format:{"code-block":!0},handler:function(range){var CodeBlock=_parchment2.default.query("code-block"),index=range.index,length=range.length,_quill$scroll$descend=this.quill.scroll.descendant(CodeBlock,index),_quill$scroll$descend2=_slicedToArray(_quill$scroll$descend,2),block=_quill$scroll$descend2[0],offset=_quill$scroll$descend2[1];if(null!=block){var scrollIndex=this.quill.getIndex(block),start=block.newlineIndex(offset,!0)+1,end=block.newlineIndex(scrollIndex+offset+length),lines=block.domNode.textContent.slice(start,end).split("\n");offset=0,lines.forEach((function(line,i){indent?(block.insertAt(start+offset,CodeBlock.TAB),offset+=CodeBlock.TAB.length,0===i?index+=CodeBlock.TAB.length:length+=CodeBlock.TAB.length):line.startsWith(CodeBlock.TAB)&&(block.deleteAt(start+offset,CodeBlock.TAB.length),offset-=CodeBlock.TAB.length,0===i?index-=CodeBlock.TAB.length:length-=CodeBlock.TAB.length),offset+=line.length+1})),this.quill.update(_quill2.default.sources.USER),this.quill.setSelection(index,length,_quill2.default.sources.SILENT)}}}}function makeFormatHandler(format){return{key:format[0].toUpperCase(),shortKey:!0,handler:function(range,context){this.quill.format(format,!context.format[format],_quill2.default.sources.USER)}}}function normalize(binding){if("string"===typeof binding||"number"===typeof binding)return normalize({key:binding});if("object"===("undefined"===typeof binding?"undefined":_typeof(binding))&&(binding=(0,_clone2.default)(binding,!1)),"string"===typeof binding.key)if(null!=Keyboard.keys[binding.key.toUpperCase()])binding.key=Keyboard.keys[binding.key.toUpperCase()];else{if(1!==binding.key.length)return null;binding.key=binding.key.toUpperCase().charCodeAt(0)}return binding.shortKey&&(binding[SHORTKEY]=binding.shortKey,delete binding.shortKey),binding}Keyboard.keys={BACKSPACE:8,TAB:9,ENTER:13,ESCAPE:27,LEFT:37,UP:38,RIGHT:39,DOWN:40,DELETE:46},Keyboard.DEFAULTS={bindings:{bold:makeFormatHandler("bold"),italic:makeFormatHandler("italic"),underline:makeFormatHandler("underline"),indent:{
// highlight tab or tab at beginning of list, indent or blockquote
key:Keyboard.keys.TAB,format:["blockquote","indent","list"],handler:function(range,context){if(context.collapsed&&0!==context.offset)return!0;this.quill.format("indent","+1",_quill2.default.sources.USER)}},outdent:{key:Keyboard.keys.TAB,shiftKey:!0,format:["blockquote","indent","list"],
// highlight tab or tab at beginning of list, indent or blockquote
handler:function(range,context){if(context.collapsed&&0!==context.offset)return!0;this.quill.format("indent","-1",_quill2.default.sources.USER)}},"outdent backspace":{key:Keyboard.keys.BACKSPACE,collapsed:!0,shiftKey:null,metaKey:null,ctrlKey:null,altKey:null,format:["indent","list"],offset:0,handler:function(range,context){null!=context.format.indent?this.quill.format("indent","-1",_quill2.default.sources.USER):null!=context.format.list&&this.quill.format("list",!1,_quill2.default.sources.USER)}},"indent code-block":makeCodeBlockHandler(!0),"outdent code-block":makeCodeBlockHandler(!1),"remove tab":{key:Keyboard.keys.TAB,shiftKey:!0,collapsed:!0,prefix:/\t$/,handler:function(range){this.quill.deleteText(range.index-1,1,_quill2.default.sources.USER)}},tab:{key:Keyboard.keys.TAB,handler:function(range){this.quill.history.cutoff();var delta=(new _quillDelta2.default).retain(range.index).delete(range.length).insert("\t");this.quill.updateContents(delta,_quill2.default.sources.USER),this.quill.history.cutoff(),this.quill.setSelection(range.index+1,_quill2.default.sources.SILENT)}},"list empty enter":{key:Keyboard.keys.ENTER,collapsed:!0,format:["list"],empty:!0,handler:function(range,context){this.quill.format("list",!1,_quill2.default.sources.USER),context.format.indent&&this.quill.format("indent",!1,_quill2.default.sources.USER)}},"checklist enter":{key:Keyboard.keys.ENTER,collapsed:!0,format:{list:"checked"},handler:function(range){var _quill$getLine3=this.quill.getLine(range.index),_quill$getLine4=_slicedToArray(_quill$getLine3,2),line=_quill$getLine4[0],offset=_quill$getLine4[1],formats=(0,_extend2.default)({},line.formats(),{list:"checked"}),delta=(new _quillDelta2.default).retain(range.index).insert("\n",formats).retain(line.length()-offset-1).retain(1,{list:"unchecked"});this.quill.updateContents(delta,_quill2.default.sources.USER),this.quill.setSelection(range.index+1,_quill2.default.sources.SILENT),this.quill.scrollIntoView()}},"header enter":{key:Keyboard.keys.ENTER,collapsed:!0,format:["header"],suffix:/^$/,handler:function(range,context){var _quill$getLine5=this.quill.getLine(range.index),_quill$getLine6=_slicedToArray(_quill$getLine5,2),line=_quill$getLine6[0],offset=_quill$getLine6[1],delta=(new _quillDelta2.default).retain(range.index).insert("\n",context.format).retain(line.length()-offset-1).retain(1,{header:null});this.quill.updateContents(delta,_quill2.default.sources.USER),this.quill.setSelection(range.index+1,_quill2.default.sources.SILENT),this.quill.scrollIntoView()}},"list autofill":{key:" ",collapsed:!0,format:{list:!1},prefix:/^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,handler:function(range,context){var length=context.prefix.length,_quill$getLine7=this.quill.getLine(range.index),_quill$getLine8=_slicedToArray(_quill$getLine7,2),line=_quill$getLine8[0],offset=_quill$getLine8[1];if(offset>length)return!0;var value=void 0;switch(context.prefix.trim()){case"[]":case"[ ]":value="unchecked";break;case"[x]":value="checked";break;case"-":case"*":value="bullet";break;default:value="ordered"}this.quill.insertText(range.index," ",_quill2.default.sources.USER),this.quill.history.cutoff();var delta=(new _quillDelta2.default).retain(range.index-offset).delete(length+1).retain(line.length()-2-offset).retain(1,{list:value});this.quill.updateContents(delta,_quill2.default.sources.USER),this.quill.history.cutoff(),this.quill.setSelection(range.index-length,_quill2.default.sources.SILENT)}},"code exit":{key:Keyboard.keys.ENTER,collapsed:!0,format:["code-block"],prefix:/\n\n$/,suffix:/^\s+$/,handler:function(range){var _quill$getLine9=this.quill.getLine(range.index),_quill$getLine10=_slicedToArray(_quill$getLine9,2),line=_quill$getLine10[0],offset=_quill$getLine10[1],delta=(new _quillDelta2.default).retain(range.index+line.length()-offset-2).retain(1,{"code-block":null}).delete(1);this.quill.updateContents(delta,_quill2.default.sources.USER)}},"embed left":makeEmbedArrowHandler(Keyboard.keys.LEFT,!1),"embed left shift":makeEmbedArrowHandler(Keyboard.keys.LEFT,!0),"embed right":makeEmbedArrowHandler(Keyboard.keys.RIGHT,!1),"embed right shift":makeEmbedArrowHandler(Keyboard.keys.RIGHT,!0)}},exports.default=Keyboard,exports.SHORTKEY=SHORTKEY},
/* 24 */
/***/function(module,exports,__nested_webpack_require_181454__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done);_n=!0)if(_arr.push(_s.value),i&&_arr.length===i)break}catch(err){_d=!0,_e=err}finally{try{!_n&&_i["return"]&&_i["return"]()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr))return arr;if(Symbol.iterator in Object(arr))return sliceIterator(arr,i);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_parchment=__nested_webpack_require_181454__(0),_parchment2=_interopRequireDefault(_parchment),_text=__nested_webpack_require_181454__(7),_text2=_interopRequireDefault(_text);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var Cursor=function(_Parchment$Embed){function Cursor(domNode,selection){_classCallCheck(this,Cursor);var _this=_possibleConstructorReturn(this,(Cursor.__proto__||Object.getPrototypeOf(Cursor)).call(this,domNode));return _this.selection=selection,_this.textNode=document.createTextNode(Cursor.CONTENTS),_this.domNode.appendChild(_this.textNode),_this._length=0,_this}return _inherits(Cursor,_Parchment$Embed),_createClass(Cursor,null,[{key:"value",value:function(){}}]),_createClass(Cursor,[{key:"detach",value:function(){
// super.detach() will also clear domNode.__blot
null!=this.parent&&this.parent.removeChild(this)}},{key:"format",value:function(name,value){if(0!==this._length)return _get(Cursor.prototype.__proto__||Object.getPrototypeOf(Cursor.prototype),"format",this).call(this,name,value);var target=this,index=0;while(null!=target&&target.statics.scope!==_parchment2.default.Scope.BLOCK_BLOT)index+=target.offset(target.parent),target=target.parent;null!=target&&(this._length=Cursor.CONTENTS.length,target.optimize(),target.formatAt(index,Cursor.CONTENTS.length,name,value),this._length=0)}},{key:"index",value:function(node,offset){return node===this.textNode?0:_get(Cursor.prototype.__proto__||Object.getPrototypeOf(Cursor.prototype),"index",this).call(this,node,offset)}},{key:"length",value:function(){return this._length}},{key:"position",value:function(){return[this.textNode,this.textNode.data.length]}},{key:"remove",value:function(){_get(Cursor.prototype.__proto__||Object.getPrototypeOf(Cursor.prototype),"remove",this).call(this),this.parent=null}},{key:"restore",value:function(){if(!this.selection.composing&&null!=this.parent){var textNode=this.textNode,range=this.selection.getNativeRange(),restoreText=void 0,start=void 0,end=void 0;if(null!=range&&range.start.node===textNode&&range.end.node===textNode){var _ref=[textNode,range.start.offset,range.end.offset];restoreText=_ref[0],start=_ref[1],end=_ref[2]}
// Link format will insert text outside of anchor tag
while(null!=this.domNode.lastChild&&this.domNode.lastChild!==this.textNode)this.domNode.parentNode.insertBefore(this.domNode.lastChild,this.domNode);if(this.textNode.data!==Cursor.CONTENTS){var text=this.textNode.data.split(Cursor.CONTENTS).join("");this.next instanceof _text2.default?(restoreText=this.next.domNode,this.next.insertAt(0,text),this.textNode.data=Cursor.CONTENTS):(this.textNode.data=text,this.parent.insertBefore(_parchment2.default.create(this.textNode),this),this.textNode=document.createTextNode(Cursor.CONTENTS),this.domNode.appendChild(this.textNode))}if(this.remove(),null!=start){var _map=[start,end].map((function(offset){return Math.max(0,Math.min(restoreText.data.length,offset-1))})),_map2=_slicedToArray(_map,2);return start=_map2[0],end=_map2[1],{startNode:restoreText,startOffset:start,endNode:restoreText,endOffset:end}}}}},{key:"update",value:function(mutations,context){var _this2=this;if(mutations.some((function(mutation){return"characterData"===mutation.type&&mutation.target===_this2.textNode}))){var range=this.restore();range&&(context.range=range)}}},{key:"value",value:function(){return""}}]),Cursor}(_parchment2.default.Embed);Cursor.blotName="cursor",Cursor.className="ql-cursor",Cursor.tagName="span",Cursor.CONTENTS="\ufeff",// Zero width no break space
exports.default=Cursor},
/* 25 */
/***/function(module,exports,__nested_webpack_require_189100__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _parchment=__nested_webpack_require_189100__(0),_parchment2=_interopRequireDefault(_parchment),_block=__nested_webpack_require_189100__(4),_block2=_interopRequireDefault(_block);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var Container=function(_Parchment$Container){function Container(){return _classCallCheck(this,Container),_possibleConstructorReturn(this,(Container.__proto__||Object.getPrototypeOf(Container)).apply(this,arguments))}return _inherits(Container,_Parchment$Container),Container}(_parchment2.default.Container);Container.allowedChildren=[_block2.default,_block.BlockEmbed,Container],exports.default=Container},
/* 26 */
/***/function(module,exports,__nested_webpack_require_190886__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ColorStyle=exports.ColorClass=exports.ColorAttributor=void 0;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_parchment=__nested_webpack_require_190886__(0),_parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var ColorAttributor=function(_Parchment$Attributor){function ColorAttributor(){return _classCallCheck(this,ColorAttributor),_possibleConstructorReturn(this,(ColorAttributor.__proto__||Object.getPrototypeOf(ColorAttributor)).apply(this,arguments))}return _inherits(ColorAttributor,_Parchment$Attributor),_createClass(ColorAttributor,[{key:"value",value:function(domNode){var value=_get(ColorAttributor.prototype.__proto__||Object.getPrototypeOf(ColorAttributor.prototype),"value",this).call(this,domNode);return value.startsWith("rgb(")?(value=value.replace(/^[^\d]+/,"").replace(/[^\d]+$/,""),"#"+value.split(",").map((function(component){return("00"+parseInt(component).toString(16)).slice(-2)})).join("")):value}}]),ColorAttributor}(_parchment2.default.Attributor.Style),ColorClass=new _parchment2.default.Attributor.Class("color","ql-color",{scope:_parchment2.default.Scope.INLINE}),ColorStyle=new ColorAttributor("color","color",{scope:_parchment2.default.Scope.INLINE});exports.ColorAttributor=ColorAttributor,exports.ColorClass=ColorClass,exports.ColorStyle=ColorStyle},
/* 27 */
/***/function(module,exports,__nested_webpack_require_194529__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sanitize=exports.default=void 0;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_inline=__nested_webpack_require_194529__(6),_inline2=_interopRequireDefault(_inline);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var Link=function(_Inline){function Link(){return _classCallCheck(this,Link),_possibleConstructorReturn(this,(Link.__proto__||Object.getPrototypeOf(Link)).apply(this,arguments))}return _inherits(Link,_Inline),_createClass(Link,[{key:"format",value:function(name,value){if(name!==this.statics.blotName||!value)return _get(Link.prototype.__proto__||Object.getPrototypeOf(Link.prototype),"format",this).call(this,name,value);value=this.constructor.sanitize(value),this.domNode.setAttribute("href",value)}}],[{key:"create",value:function(value){var node=_get(Link.__proto__||Object.getPrototypeOf(Link),"create",this).call(this,value);return value=this.sanitize(value),node.setAttribute("href",value),node.setAttribute("rel","noopener noreferrer"),node.setAttribute("target","_blank"),node}},{key:"formats",value:function(domNode){return domNode.getAttribute("href")}},{key:"sanitize",value:function(url){return _sanitize(url,this.PROTOCOL_WHITELIST)?url:this.SANITIZED_URL}}]),Link}(_inline2.default);function _sanitize(url,protocols){var anchor=document.createElement("a");anchor.href=url;var protocol=anchor.href.slice(0,anchor.href.indexOf(":"));return protocols.indexOf(protocol)>-1}Link.blotName="link",Link.tagName="A",Link.SANITIZED_URL="about:blank",Link.PROTOCOL_WHITELIST=["http","https","mailto","tel"],exports.default=Link,exports.sanitize=_sanitize},
/* 28 */
/***/function(module,exports,__nested_webpack_require_198559__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_keyboard=__nested_webpack_require_198559__(23),_keyboard2=_interopRequireDefault(_keyboard),_dropdown=__nested_webpack_require_198559__(107),_dropdown2=_interopRequireDefault(_dropdown);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}var optionsCounter=0;function toggleAriaAttribute(element,attribute){element.setAttribute(attribute,!("true"===element.getAttribute(attribute)))}var Picker=function(){function Picker(select){var _this=this;_classCallCheck(this,Picker),this.select=select,this.container=document.createElement("span"),this.buildPicker(),this.select.style.display="none",this.select.parentNode.insertBefore(this.container,this.select),this.label.addEventListener("mousedown",(function(){_this.togglePicker()})),this.label.addEventListener("keydown",(function(event){switch(event.keyCode){
// Allows the "Enter" key to open the picker
case _keyboard2.default.keys.ENTER:_this.togglePicker();break;
// Allows the "Escape" key to close the picker
case _keyboard2.default.keys.ESCAPE:_this.escape(),event.preventDefault();break;default:}})),this.select.addEventListener("change",this.update.bind(this))}return _createClass(Picker,[{key:"togglePicker",value:function(){this.container.classList.toggle("ql-expanded"),
// Toggle aria-expanded and aria-hidden to make the picker accessible
toggleAriaAttribute(this.label,"aria-expanded"),toggleAriaAttribute(this.options,"aria-hidden")}},{key:"buildItem",value:function(option){var _this2=this,item=document.createElement("span");return item.tabIndex="0",item.setAttribute("role","button"),item.classList.add("ql-picker-item"),option.hasAttribute("value")&&item.setAttribute("data-value",option.getAttribute("value")),option.textContent&&item.setAttribute("data-label",option.textContent),item.addEventListener("click",(function(){_this2.selectItem(item,!0)})),item.addEventListener("keydown",(function(event){switch(event.keyCode){
// Allows the "Enter" key to select an item
case _keyboard2.default.keys.ENTER:_this2.selectItem(item,!0),event.preventDefault();break;
// Allows the "Escape" key to close the picker
case _keyboard2.default.keys.ESCAPE:_this2.escape(),event.preventDefault();break;default:}})),item}},{key:"buildLabel",value:function(){var label=document.createElement("span");return label.classList.add("ql-picker-label"),label.innerHTML=_dropdown2.default,label.tabIndex="0",label.setAttribute("role","button"),label.setAttribute("aria-expanded","false"),this.container.appendChild(label),label}},{key:"buildOptions",value:function(){var _this3=this,options=document.createElement("span");options.classList.add("ql-picker-options"),
// Don't want screen readers to read this until options are visible
options.setAttribute("aria-hidden","true"),options.tabIndex="-1",
// Need a unique id for aria-controls
options.id="ql-picker-options-"+optionsCounter,optionsCounter+=1,this.label.setAttribute("aria-controls",options.id),this.options=options,[].slice.call(this.select.options).forEach((function(option){var item=_this3.buildItem(option);options.appendChild(item),!0===option.selected&&_this3.selectItem(item)})),this.container.appendChild(options)}},{key:"buildPicker",value:function(){var _this4=this;[].slice.call(this.select.attributes).forEach((function(item){_this4.container.setAttribute(item.name,item.value)})),this.container.classList.add("ql-picker"),this.label=this.buildLabel(),this.buildOptions()}},{key:"escape",value:function(){var _this5=this;
// Close menu and return focus to trigger label
this.close(),
// Need setTimeout for accessibility to ensure that the browser executes
// focus on the next process thread and after any DOM content changes
setTimeout((function(){return _this5.label.focus()}),1)}},{key:"close",value:function(){this.container.classList.remove("ql-expanded"),this.label.setAttribute("aria-expanded","false"),this.options.setAttribute("aria-hidden","true")}},{key:"selectItem",value:function(item){var trigger=arguments.length>1&&void 0!==arguments[1]&&arguments[1],selected=this.container.querySelector(".ql-selected");if(item!==selected&&(null!=selected&&selected.classList.remove("ql-selected"),null!=item&&(item.classList.add("ql-selected"),this.select.selectedIndex=[].indexOf.call(item.parentNode.children,item),item.hasAttribute("data-value")?this.label.setAttribute("data-value",item.getAttribute("data-value")):this.label.removeAttribute("data-value"),item.hasAttribute("data-label")?this.label.setAttribute("data-label",item.getAttribute("data-label")):this.label.removeAttribute("data-label"),trigger))){if("function"===typeof Event)this.select.dispatchEvent(new Event("change"));else if("object"===("undefined"===typeof Event?"undefined":_typeof(Event))){
// IE11
var event=document.createEvent("Event");event.initEvent("change",!0,!0),this.select.dispatchEvent(event)}this.close()}}},{key:"update",value:function(){var option=void 0;if(this.select.selectedIndex>-1){var item=this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex];option=this.select.options[this.select.selectedIndex],this.selectItem(item)}else this.selectItem(null);var isActive=null!=option&&option!==this.select.querySelector("option[selected]");this.label.classList.toggle("ql-active",isActive)}}]),Picker}();exports.default=Picker},
/* 29 */
/***/function(module,exports,__nested_webpack_require_206753__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _parchment=__nested_webpack_require_206753__(0),_parchment2=_interopRequireDefault(_parchment),_quill=__nested_webpack_require_206753__(5),_quill2=_interopRequireDefault(_quill),_block=__nested_webpack_require_206753__(4),_block2=_interopRequireDefault(_block),_break=__nested_webpack_require_206753__(16),_break2=_interopRequireDefault(_break),_container=__nested_webpack_require_206753__(25),_container2=_interopRequireDefault(_container),_cursor=__nested_webpack_require_206753__(24),_cursor2=_interopRequireDefault(_cursor),_embed=__nested_webpack_require_206753__(35),_embed2=_interopRequireDefault(_embed),_inline=__nested_webpack_require_206753__(6),_inline2=_interopRequireDefault(_inline),_scroll=__nested_webpack_require_206753__(22),_scroll2=_interopRequireDefault(_scroll),_text=__nested_webpack_require_206753__(7),_text2=_interopRequireDefault(_text),_clipboard=__nested_webpack_require_206753__(55),_clipboard2=_interopRequireDefault(_clipboard),_history=__nested_webpack_require_206753__(42),_history2=_interopRequireDefault(_history),_keyboard=__nested_webpack_require_206753__(23),_keyboard2=_interopRequireDefault(_keyboard);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}_quill2.default.register({"blots/block":_block2.default,"blots/block/embed":_block.BlockEmbed,"blots/break":_break2.default,"blots/container":_container2.default,"blots/cursor":_cursor2.default,"blots/embed":_embed2.default,"blots/inline":_inline2.default,"blots/scroll":_scroll2.default,"blots/text":_text2.default,"modules/clipboard":_clipboard2.default,"modules/history":_history2.default,"modules/keyboard":_keyboard2.default}),_parchment2.default.register(_block2.default,_break2.default,_cursor2.default,_inline2.default,_scroll2.default,_text2.default),exports.default=_quill2.default},
/* 30 */
/***/function(module,exports,__nested_webpack_require_208833__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var Registry=__nested_webpack_require_208833__(1),ShadowBlot=/** @class */function(){function ShadowBlot(domNode){this.domNode=domNode,
// @ts-ignore
this.domNode[Registry.DATA_KEY]={blot:this}}return Object.defineProperty(ShadowBlot.prototype,"statics",{
// Hack for accessing inherited static methods
get:function(){return this.constructor},enumerable:!0,configurable:!0}),ShadowBlot.create=function(value){if(null==this.tagName)throw new Registry.ParchmentError("Blot definition missing tagName");var node;return Array.isArray(this.tagName)?("string"===typeof value&&(value=value.toUpperCase(),parseInt(value).toString()===value&&(value=parseInt(value))),node="number"===typeof value?document.createElement(this.tagName[value-1]):this.tagName.indexOf(value)>-1?document.createElement(value):document.createElement(this.tagName[0])):node=document.createElement(this.tagName),this.className&&node.classList.add(this.className),node},ShadowBlot.prototype.attach=function(){null!=this.parent&&(this.scroll=this.parent.scroll)},ShadowBlot.prototype.clone=function(){var domNode=this.domNode.cloneNode(!1);return Registry.create(domNode)},ShadowBlot.prototype.detach=function(){null!=this.parent&&this.parent.removeChild(this),
// @ts-ignore
delete this.domNode[Registry.DATA_KEY]},ShadowBlot.prototype.deleteAt=function(index,length){var blot=this.isolate(index,length);blot.remove()},ShadowBlot.prototype.formatAt=function(index,length,name,value){var blot=this.isolate(index,length);if(null!=Registry.query(name,Registry.Scope.BLOT)&&value)blot.wrap(name,value);else if(null!=Registry.query(name,Registry.Scope.ATTRIBUTE)){var parent=Registry.create(this.statics.scope);blot.wrap(parent),parent.format(name,value)}},ShadowBlot.prototype.insertAt=function(index,value,def){var blot=null==def?Registry.create("text",value):Registry.create(value,def),ref=this.split(index);this.parent.insertBefore(blot,ref)},ShadowBlot.prototype.insertInto=function(parentBlot,refBlot){void 0===refBlot&&(refBlot=null),null!=this.parent&&this.parent.children.remove(this);var refDomNode=null;parentBlot.children.insertBefore(this,refBlot),null!=refBlot&&(refDomNode=refBlot.domNode),this.domNode.parentNode==parentBlot.domNode&&this.domNode.nextSibling==refDomNode||parentBlot.domNode.insertBefore(this.domNode,refDomNode),this.parent=parentBlot,this.attach()},ShadowBlot.prototype.isolate=function(index,length){var target=this.split(index);return target.split(length),target},ShadowBlot.prototype.length=function(){return 1},ShadowBlot.prototype.offset=function(root){return void 0===root&&(root=this.parent),null==this.parent||this==root?0:this.parent.children.offset(this)+this.parent.offset(root)},ShadowBlot.prototype.optimize=function(context){
// TODO clean up once we use WeakMap
// @ts-ignore
null!=this.domNode[Registry.DATA_KEY]&&
// @ts-ignore
delete this.domNode[Registry.DATA_KEY].mutations},ShadowBlot.prototype.remove=function(){null!=this.domNode.parentNode&&this.domNode.parentNode.removeChild(this.domNode),this.detach()},ShadowBlot.prototype.replace=function(target){null!=target.parent&&(target.parent.insertBefore(this,target.next),target.remove())},ShadowBlot.prototype.replaceWith=function(name,value){var replacement="string"===typeof name?Registry.create(name,value):name;return replacement.replace(this),replacement},ShadowBlot.prototype.split=function(index,force){return 0===index?this:this.next},ShadowBlot.prototype.update=function(mutations,context){
// Nothing to do by default
},ShadowBlot.prototype.wrap=function(name,value){var wrapper="string"===typeof name?Registry.create(name,value):name;return null!=this.parent&&this.parent.insertBefore(wrapper,this.next),wrapper.appendChild(this),wrapper},ShadowBlot.blotName="abstract",ShadowBlot}();exports.default=ShadowBlot},
/* 31 */
/***/function(module,exports,__nested_webpack_require_214530__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var attributor_1=__nested_webpack_require_214530__(12),class_1=__nested_webpack_require_214530__(32),style_1=__nested_webpack_require_214530__(33),Registry=__nested_webpack_require_214530__(1),AttributorStore=/** @class */function(){function AttributorStore(domNode){this.attributes={},this.domNode=domNode,this.build()}return AttributorStore.prototype.attribute=function(attribute,value){
// verb
value?attribute.add(this.domNode,value)&&(null!=attribute.value(this.domNode)?this.attributes[attribute.attrName]=attribute:delete this.attributes[attribute.attrName]):(attribute.remove(this.domNode),delete this.attributes[attribute.attrName])},AttributorStore.prototype.build=function(){var _this=this;this.attributes={};var attributes=attributor_1.default.keys(this.domNode),classes=class_1.default.keys(this.domNode),styles=style_1.default.keys(this.domNode);attributes.concat(classes).concat(styles).forEach((function(name){var attr=Registry.query(name,Registry.Scope.ATTRIBUTE);attr instanceof attributor_1.default&&(_this.attributes[attr.attrName]=attr)}))},AttributorStore.prototype.copy=function(target){var _this=this;Object.keys(this.attributes).forEach((function(key){var value=_this.attributes[key].value(_this.domNode);target.format(key,value)}))},AttributorStore.prototype.move=function(target){var _this=this;this.copy(target),Object.keys(this.attributes).forEach((function(key){_this.attributes[key].remove(_this.domNode)})),this.attributes={}},AttributorStore.prototype.values=function(){var _this=this;return Object.keys(this.attributes).reduce((function(attributes,name){return attributes[name]=_this.attributes[name].value(_this.domNode),attributes}),{})},AttributorStore}();exports.default=AttributorStore},
/* 32 */
/***/function(module,exports,__nested_webpack_require_217128__){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p])};return function(d,b){function __(){this.constructor=d}extendStatics(d,b),d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:!0});var attributor_1=__nested_webpack_require_217128__(12);function match(node,prefix){var className=node.getAttribute("class")||"";return className.split(/\s+/).filter((function(name){return 0===name.indexOf(prefix+"-")}))}var ClassAttributor=/** @class */function(_super){function ClassAttributor(){return null!==_super&&_super.apply(this,arguments)||this}return __extends(ClassAttributor,_super),ClassAttributor.keys=function(node){return(node.getAttribute("class")||"").split(/\s+/).map((function(name){return name.split("-").slice(0,-1).join("-")}))},ClassAttributor.prototype.add=function(node,value){return!!this.canAdd(node,value)&&(this.remove(node),node.classList.add(this.keyName+"-"+value),!0)},ClassAttributor.prototype.remove=function(node){var matches=match(node,this.keyName);matches.forEach((function(name){node.classList.remove(name)})),0===node.classList.length&&node.removeAttribute("class")},ClassAttributor.prototype.value=function(node){var result=match(node,this.keyName)[0]||"",value=result.slice(this.keyName.length+1);// +1 for hyphen
return this.canAdd(node,value)?value:""},ClassAttributor}(attributor_1.default);exports.default=ClassAttributor},
/* 33 */
/***/function(module,exports,__nested_webpack_require_219372__){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p])};return function(d,b){function __(){this.constructor=d}extendStatics(d,b),d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:!0});var attributor_1=__nested_webpack_require_219372__(12);function camelize(name){var parts=name.split("-"),rest=parts.slice(1).map((function(part){return part[0].toUpperCase()+part.slice(1)})).join("");return parts[0]+rest}var StyleAttributor=/** @class */function(_super){function StyleAttributor(){return null!==_super&&_super.apply(this,arguments)||this}return __extends(StyleAttributor,_super),StyleAttributor.keys=function(node){return(node.getAttribute("style")||"").split(";").map((function(value){var arr=value.split(":");return arr[0].trim()}))},StyleAttributor.prototype.add=function(node,value){return!!this.canAdd(node,value)&&(
// @ts-ignore
node.style[camelize(this.keyName)]=value,!0)},StyleAttributor.prototype.remove=function(node){
// @ts-ignore
node.style[camelize(this.keyName)]="",node.getAttribute("style")||node.removeAttribute("style")},StyleAttributor.prototype.value=function(node){
// @ts-ignore
var value=node.style[camelize(this.keyName)];return this.canAdd(node,value)?value:""},StyleAttributor}(attributor_1.default);exports.default=StyleAttributor},
/* 34 */
/***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}var Theme=function(){function Theme(quill,options){_classCallCheck(this,Theme),this.quill=quill,this.options=options,this.modules={}}return _createClass(Theme,[{key:"init",value:function(){var _this=this;Object.keys(this.options.modules).forEach((function(name){null==_this.modules[name]&&_this.addModule(name)}))}},{key:"addModule",value:function(name){var moduleClass=this.quill.constructor.import("modules/"+name);return this.modules[name]=new moduleClass(this.quill,this.options.modules[name]||{}),this.modules[name]}}]),Theme}();Theme.DEFAULTS={modules:{}},Theme.themes={default:Theme},exports.default=Theme},
/* 35 */
/***/function(module,exports,__nested_webpack_require_223199__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_parchment=__nested_webpack_require_223199__(0),_parchment2=_interopRequireDefault(_parchment),_text=__nested_webpack_require_223199__(7),_text2=_interopRequireDefault(_text);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var GUARD_TEXT="\ufeff",Embed=function(_Parchment$Embed){function Embed(node){_classCallCheck(this,Embed);var _this=_possibleConstructorReturn(this,(Embed.__proto__||Object.getPrototypeOf(Embed)).call(this,node));return _this.contentNode=document.createElement("span"),_this.contentNode.setAttribute("contenteditable",!1),[].slice.call(_this.domNode.childNodes).forEach((function(childNode){_this.contentNode.appendChild(childNode)})),_this.leftGuard=document.createTextNode(GUARD_TEXT),_this.rightGuard=document.createTextNode(GUARD_TEXT),_this.domNode.appendChild(_this.leftGuard),_this.domNode.appendChild(_this.contentNode),_this.domNode.appendChild(_this.rightGuard),_this}return _inherits(Embed,_Parchment$Embed),_createClass(Embed,[{key:"index",value:function(node,offset){return node===this.leftGuard?0:node===this.rightGuard?1:_get(Embed.prototype.__proto__||Object.getPrototypeOf(Embed.prototype),"index",this).call(this,node,offset)}},{key:"restore",value:function(node){var range=void 0,textNode=void 0,text=node.data.split(GUARD_TEXT).join("");if(node===this.leftGuard)if(this.prev instanceof _text2.default){var prevLength=this.prev.length();this.prev.insertAt(prevLength,text),range={startNode:this.prev.domNode,startOffset:prevLength+text.length}}else textNode=document.createTextNode(text),this.parent.insertBefore(_parchment2.default.create(textNode),this),range={startNode:textNode,startOffset:text.length};else node===this.rightGuard&&(this.next instanceof _text2.default?(this.next.insertAt(0,text),range={startNode:this.next.domNode,startOffset:text.length}):(textNode=document.createTextNode(text),this.parent.insertBefore(_parchment2.default.create(textNode),this.next),range={startNode:textNode,startOffset:text.length}));return node.data=GUARD_TEXT,range}},{key:"update",value:function(mutations,context){var _this2=this;mutations.forEach((function(mutation){if("characterData"===mutation.type&&(mutation.target===_this2.leftGuard||mutation.target===_this2.rightGuard)){var range=_this2.restore(mutation.target);range&&(context.range=range)}}))}}]),Embed}(_parchment2.default.Embed);exports.default=Embed},
/* 36 */
/***/function(module,exports,__nested_webpack_require_228527__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.AlignStyle=exports.AlignClass=exports.AlignAttribute=void 0;var _parchment=__nested_webpack_require_228527__(0),_parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}var config={scope:_parchment2.default.Scope.BLOCK,whitelist:["right","center","justify"]},AlignAttribute=new _parchment2.default.Attributor.Attribute("align","align",config),AlignClass=new _parchment2.default.Attributor.Class("align","ql-align",config),AlignStyle=new _parchment2.default.Attributor.Style("align","text-align",config);exports.AlignAttribute=AlignAttribute,exports.AlignClass=AlignClass,exports.AlignStyle=AlignStyle},
/* 37 */
/***/function(module,exports,__nested_webpack_require_229442__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.BackgroundStyle=exports.BackgroundClass=void 0;var _parchment=__nested_webpack_require_229442__(0),_parchment2=_interopRequireDefault(_parchment),_color=__nested_webpack_require_229442__(26);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}var BackgroundClass=new _parchment2.default.Attributor.Class("background","ql-bg",{scope:_parchment2.default.Scope.INLINE}),BackgroundStyle=new _color.ColorAttributor("background","background-color",{scope:_parchment2.default.Scope.INLINE});exports.BackgroundClass=BackgroundClass,exports.BackgroundStyle=BackgroundStyle},
/* 38 */
/***/function(module,exports,__nested_webpack_require_230249__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.DirectionStyle=exports.DirectionClass=exports.DirectionAttribute=void 0;var _parchment=__nested_webpack_require_230249__(0),_parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}var config={scope:_parchment2.default.Scope.BLOCK,whitelist:["rtl"]},DirectionAttribute=new _parchment2.default.Attributor.Attribute("direction","dir",config),DirectionClass=new _parchment2.default.Attributor.Class("direction","ql-direction",config),DirectionStyle=new _parchment2.default.Attributor.Style("direction","direction",config);exports.DirectionAttribute=DirectionAttribute,exports.DirectionClass=DirectionClass,exports.DirectionStyle=DirectionStyle},
/* 39 */
/***/function(module,exports,__nested_webpack_require_231202__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.FontClass=exports.FontStyle=void 0;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_parchment=__nested_webpack_require_231202__(0),_parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var config={scope:_parchment2.default.Scope.INLINE,whitelist:["serif","monospace"]},FontClass=new _parchment2.default.Attributor.Class("font","ql-font",config),FontStyleAttributor=function(_Parchment$Attributor){function FontStyleAttributor(){return _classCallCheck(this,FontStyleAttributor),_possibleConstructorReturn(this,(FontStyleAttributor.__proto__||Object.getPrototypeOf(FontStyleAttributor)).apply(this,arguments))}return _inherits(FontStyleAttributor,_Parchment$Attributor),_createClass(FontStyleAttributor,[{key:"value",value:function(node){return _get(FontStyleAttributor.prototype.__proto__||Object.getPrototypeOf(FontStyleAttributor.prototype),"value",this).call(this,node).replace(/["']/g,"")}}]),FontStyleAttributor}(_parchment2.default.Attributor.Style),FontStyle=new FontStyleAttributor("font","font-family",config);exports.FontStyle=FontStyle,exports.FontClass=FontClass},
/* 40 */
/***/function(module,exports,__nested_webpack_require_234578__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SizeStyle=exports.SizeClass=void 0;var _parchment=__nested_webpack_require_234578__(0),_parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}var SizeClass=new _parchment2.default.Attributor.Class("size","ql-size",{scope:_parchment2.default.Scope.INLINE,whitelist:["small","large","huge"]}),SizeStyle=new _parchment2.default.Attributor.Style("size","font-size",{scope:_parchment2.default.Scope.INLINE,whitelist:["10px","18px","32px"]});exports.SizeClass=SizeClass,exports.SizeStyle=SizeStyle},
/* 41 */
/***/function(module,exports,__nested_webpack_require_235375__){"use strict";module.exports={align:{"":__nested_webpack_require_235375__(76),center:__nested_webpack_require_235375__(77),right:__nested_webpack_require_235375__(78),justify:__nested_webpack_require_235375__(79)},background:__nested_webpack_require_235375__(80),blockquote:__nested_webpack_require_235375__(81),bold:__nested_webpack_require_235375__(82),clean:__nested_webpack_require_235375__(83),code:__nested_webpack_require_235375__(58),"code-block":__nested_webpack_require_235375__(58),color:__nested_webpack_require_235375__(84),direction:{"":__nested_webpack_require_235375__(85),rtl:__nested_webpack_require_235375__(86)},float:{center:__nested_webpack_require_235375__(87),full:__nested_webpack_require_235375__(88),left:__nested_webpack_require_235375__(89),right:__nested_webpack_require_235375__(90)},formula:__nested_webpack_require_235375__(91),header:{1:__nested_webpack_require_235375__(92),2:__nested_webpack_require_235375__(93)},italic:__nested_webpack_require_235375__(94),image:__nested_webpack_require_235375__(95),indent:{"+1":__nested_webpack_require_235375__(96),"-1":__nested_webpack_require_235375__(97)},link:__nested_webpack_require_235375__(98),list:{ordered:__nested_webpack_require_235375__(99),bullet:__nested_webpack_require_235375__(100),check:__nested_webpack_require_235375__(101)},script:{sub:__nested_webpack_require_235375__(102),super:__nested_webpack_require_235375__(103)},strike:__nested_webpack_require_235375__(104),underline:__nested_webpack_require_235375__(105),video:__nested_webpack_require_235375__(106)}},
/* 42 */
/***/function(module,exports,__nested_webpack_require_236844__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getLastChangeIndex=exports.default=void 0;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_parchment=__nested_webpack_require_236844__(0),_parchment2=_interopRequireDefault(_parchment),_quill=__nested_webpack_require_236844__(5),_quill2=_interopRequireDefault(_quill),_module=__nested_webpack_require_236844__(9),_module2=_interopRequireDefault(_module);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var History=function(_Module){function History(quill,options){_classCallCheck(this,History);var _this=_possibleConstructorReturn(this,(History.__proto__||Object.getPrototypeOf(History)).call(this,quill,options));return _this.lastRecorded=0,_this.ignoreChange=!1,_this.clear(),_this.quill.on(_quill2.default.events.EDITOR_CHANGE,(function(eventName,delta,oldDelta,source){eventName!==_quill2.default.events.TEXT_CHANGE||_this.ignoreChange||(_this.options.userOnly&&source!==_quill2.default.sources.USER?_this.transform(delta):_this.record(delta,oldDelta))})),_this.quill.keyboard.addBinding({key:"Z",shortKey:!0},_this.undo.bind(_this)),_this.quill.keyboard.addBinding({key:"Z",shortKey:!0,shiftKey:!0},_this.redo.bind(_this)),/Win/i.test(navigator.platform)&&_this.quill.keyboard.addBinding({key:"Y",shortKey:!0},_this.redo.bind(_this)),_this}return _inherits(History,_Module),_createClass(History,[{key:"change",value:function(source,dest){if(0!==this.stack[source].length){var delta=this.stack[source].pop();this.stack[dest].push(delta),this.lastRecorded=0,this.ignoreChange=!0,this.quill.updateContents(delta[source],_quill2.default.sources.USER),this.ignoreChange=!1;var index=getLastChangeIndex(delta[source]);this.quill.setSelection(index)}}},{key:"clear",value:function(){this.stack={undo:[],redo:[]}}},{key:"cutoff",value:function(){this.lastRecorded=0}},{key:"record",value:function(changeDelta,oldDelta){if(0!==changeDelta.ops.length){this.stack.redo=[];var undoDelta=this.quill.getContents().diff(oldDelta),timestamp=Date.now();if(this.lastRecorded+this.options.delay>timestamp&&this.stack.undo.length>0){var delta=this.stack.undo.pop();undoDelta=undoDelta.compose(delta.undo),changeDelta=delta.redo.compose(changeDelta)}else this.lastRecorded=timestamp;this.stack.undo.push({redo:changeDelta,undo:undoDelta}),this.stack.undo.length>this.options.maxStack&&this.stack.undo.shift()}}},{key:"redo",value:function(){this.change("redo","undo")}},{key:"transform",value:function(delta){this.stack.undo.forEach((function(change){change.undo=delta.transform(change.undo,!0),change.redo=delta.transform(change.redo,!0)})),this.stack.redo.forEach((function(change){change.undo=delta.transform(change.undo,!0),change.redo=delta.transform(change.redo,!0)}))}},{key:"undo",value:function(){this.change("undo","redo")}}]),History}(_module2.default);function endsWithNewlineChange(delta){var lastOp=delta.ops[delta.ops.length-1];return null!=lastOp&&(null!=lastOp.insert?"string"===typeof lastOp.insert&&lastOp.insert.endsWith("\n"):null!=lastOp.attributes&&Object.keys(lastOp.attributes).some((function(attr){return null!=_parchment2.default.query(attr,_parchment2.default.Scope.BLOCK)})))}function getLastChangeIndex(delta){var deleteLength=delta.reduce((function(length,op){return length+=op.delete||0,length}),0),changeIndex=delta.length()-deleteLength;return endsWithNewlineChange(delta)&&(changeIndex-=1),changeIndex}History.DEFAULTS={delay:1e3,maxStack:100,userOnly:!1},exports.default=History,exports.getLastChangeIndex=getLastChangeIndex},
/* 43 */
/***/function(module,exports,__nested_webpack_require_242979__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.BaseTooltip=void 0;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_extend=__nested_webpack_require_242979__(3),_extend2=_interopRequireDefault(_extend),_quillDelta=__nested_webpack_require_242979__(2),_quillDelta2=_interopRequireDefault(_quillDelta),_emitter=__nested_webpack_require_242979__(8),_emitter2=_interopRequireDefault(_emitter),_keyboard=__nested_webpack_require_242979__(23),_keyboard2=_interopRequireDefault(_keyboard),_theme=__nested_webpack_require_242979__(34),_theme2=_interopRequireDefault(_theme),_colorPicker=__nested_webpack_require_242979__(59),_colorPicker2=_interopRequireDefault(_colorPicker),_iconPicker=__nested_webpack_require_242979__(60),_iconPicker2=_interopRequireDefault(_iconPicker),_picker=__nested_webpack_require_242979__(28),_picker2=_interopRequireDefault(_picker),_tooltip=__nested_webpack_require_242979__(61),_tooltip2=_interopRequireDefault(_tooltip);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var ALIGNS=[!1,"center","right","justify"],COLORS=["#000000","#e60000","#ff9900","#ffff00","#008a00","#0066cc","#9933ff","#ffffff","#facccc","#ffebcc","#ffffcc","#cce8cc","#cce0f5","#ebd6ff","#bbbbbb","#f06666","#ffc266","#ffff66","#66b966","#66a3e0","#c285ff","#888888","#a10000","#b26b00","#b2b200","#006100","#0047b2","#6b24b2","#444444","#5c0000","#663d00","#666600","#003700","#002966","#3d1466"],FONTS=[!1,"serif","monospace"],HEADERS=["1","2","3",!1],SIZES=["small",!1,"large","huge"],BaseTheme=function(_Theme){function BaseTheme(quill,options){_classCallCheck(this,BaseTheme);var _this=_possibleConstructorReturn(this,(BaseTheme.__proto__||Object.getPrototypeOf(BaseTheme)).call(this,quill,options)),listener=function listener(e){if(!document.body.contains(quill.root))return document.body.removeEventListener("click",listener);null==_this.tooltip||_this.tooltip.root.contains(e.target)||document.activeElement===_this.tooltip.textbox||_this.quill.hasFocus()||_this.tooltip.hide(),null!=_this.pickers&&_this.pickers.forEach((function(picker){picker.container.contains(e.target)||picker.close()}))};return quill.emitter.listenDOM("click",document.body,listener),_this}return _inherits(BaseTheme,_Theme),_createClass(BaseTheme,[{key:"addModule",value:function(name){var module=_get(BaseTheme.prototype.__proto__||Object.getPrototypeOf(BaseTheme.prototype),"addModule",this).call(this,name);return"toolbar"===name&&this.extendToolbar(module),module}},{key:"buildButtons",value:function(buttons,icons){buttons.forEach((function(button){var className=button.getAttribute("class")||"";className.split(/\s+/).forEach((function(name){if(name.startsWith("ql-")&&(name=name.slice(3),null!=icons[name]))if("direction"===name)button.innerHTML=icons[name][""]+icons[name]["rtl"];else if("string"===typeof icons[name])button.innerHTML=icons[name];else{var value=button.value||"";null!=value&&icons[name][value]&&(button.innerHTML=icons[name][value])}}))}))}},{key:"buildPickers",value:function(selects,icons){var _this2=this;this.pickers=selects.map((function(select){if(select.classList.contains("ql-align"))return null==select.querySelector("option")&&fillSelect(select,ALIGNS),new _iconPicker2.default(select,icons.align);if(select.classList.contains("ql-background")||select.classList.contains("ql-color")){var format=select.classList.contains("ql-background")?"background":"color";return null==select.querySelector("option")&&fillSelect(select,COLORS,"background"===format?"#ffffff":"#000000"),new _colorPicker2.default(select,icons[format])}return null==select.querySelector("option")&&(select.classList.contains("ql-font")?fillSelect(select,FONTS):select.classList.contains("ql-header")?fillSelect(select,HEADERS):select.classList.contains("ql-size")&&fillSelect(select,SIZES)),new _picker2.default(select)}));var update=function(){_this2.pickers.forEach((function(picker){picker.update()}))};this.quill.on(_emitter2.default.events.EDITOR_CHANGE,update)}}]),BaseTheme}(_theme2.default);BaseTheme.DEFAULTS=(0,_extend2.default)(!0,{},_theme2.default.DEFAULTS,{modules:{toolbar:{handlers:{formula:function(){this.quill.theme.tooltip.edit("formula")},image:function(){var _this3=this,fileInput=this.container.querySelector("input.ql-image[type=file]");null==fileInput&&(fileInput=document.createElement("input"),fileInput.setAttribute("type","file"),fileInput.setAttribute("accept","image/png, image/gif, image/jpeg, image/bmp, image/x-icon"),fileInput.classList.add("ql-image"),fileInput.addEventListener("change",(function(){if(null!=fileInput.files&&null!=fileInput.files[0]){var reader=new FileReader;reader.onload=function(e){var range=_this3.quill.getSelection(!0);_this3.quill.updateContents((new _quillDelta2.default).retain(range.index).delete(range.length).insert({image:e.target.result}),_emitter2.default.sources.USER),_this3.quill.setSelection(range.index+1,_emitter2.default.sources.SILENT),fileInput.value=""},reader.readAsDataURL(fileInput.files[0])}})),this.container.appendChild(fileInput)),fileInput.click()},video:function(){this.quill.theme.tooltip.edit("video")}}}}});var BaseTooltip=function(_Tooltip){function BaseTooltip(quill,boundsContainer){_classCallCheck(this,BaseTooltip);var _this4=_possibleConstructorReturn(this,(BaseTooltip.__proto__||Object.getPrototypeOf(BaseTooltip)).call(this,quill,boundsContainer));return _this4.textbox=_this4.root.querySelector('input[type="text"]'),_this4.listen(),_this4}return _inherits(BaseTooltip,_Tooltip),_createClass(BaseTooltip,[{key:"listen",value:function(){var _this5=this;this.textbox.addEventListener("keydown",(function(event){_keyboard2.default.match(event,"enter")?(_this5.save(),event.preventDefault()):_keyboard2.default.match(event,"escape")&&(_this5.cancel(),event.preventDefault())}))}},{key:"cancel",value:function(){this.hide()}},{key:"edit",value:function(){var mode=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"link",preview=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;this.root.classList.remove("ql-hidden"),this.root.classList.add("ql-editing"),null!=preview?this.textbox.value=preview:mode!==this.root.getAttribute("data-mode")&&(this.textbox.value=""),this.position(this.quill.getBounds(this.quill.selection.savedRange)),this.textbox.select(),this.textbox.setAttribute("placeholder",this.textbox.getAttribute("data-"+mode)||""),this.root.setAttribute("data-mode",mode)}},{key:"restoreFocus",value:function(){var scrollTop=this.quill.scrollingContainer.scrollTop;this.quill.focus(),this.quill.scrollingContainer.scrollTop=scrollTop}},{key:"save",value:function(){var value=this.textbox.value;switch(this.root.getAttribute("data-mode")){case"link":var scrollTop=this.quill.root.scrollTop;this.linkRange?(this.quill.formatText(this.linkRange,"link",value,_emitter2.default.sources.USER),delete this.linkRange):(this.restoreFocus(),this.quill.format("link",value,_emitter2.default.sources.USER)),this.quill.root.scrollTop=scrollTop;break;case"video":value=extractVideoUrl(value);// eslint-disable-next-line no-fallthrough
case"formula":if(!value)break;var range=this.quill.getSelection(!0);if(null!=range){var index=range.index+range.length;this.quill.insertEmbed(index,this.root.getAttribute("data-mode"),value,_emitter2.default.sources.USER),"formula"===this.root.getAttribute("data-mode")&&this.quill.insertText(index+1," ",_emitter2.default.sources.USER),this.quill.setSelection(index+2,_emitter2.default.sources.USER)}break;default:}this.textbox.value="",this.hide()}}]),BaseTooltip}(_tooltip2.default);function extractVideoUrl(url){var match=url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/)||url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);return match?(match[1]||"https")+"://www.youtube.com/embed/"+match[2]+"?showinfo=0":(match=url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/))?(match[1]||"https")+"://player.vimeo.com/video/"+match[2]+"/":url}function fillSelect(select,values){var defaultValue=arguments.length>2&&void 0!==arguments[2]&&arguments[2];values.forEach((function(value){var option=document.createElement("option");value===defaultValue?option.setAttribute("selected","selected"):option.setAttribute("value",value),select.appendChild(option)}))}exports.BaseTooltip=BaseTooltip,exports.default=BaseTheme},
/* 44 */
/***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var LinkedList=/** @class */function(){function LinkedList(){this.head=this.tail=null,this.length=0}return LinkedList.prototype.append=function(){for(var nodes=[],_i=0;_i<arguments.length;_i++)nodes[_i]=arguments[_i];this.insertBefore(nodes[0],null),nodes.length>1&&this.append.apply(this,nodes.slice(1))},LinkedList.prototype.contains=function(node){var cur,next=this.iterator();while(cur=next())if(cur===node)return!0;return!1},LinkedList.prototype.insertBefore=function(node,refNode){node&&(node.next=refNode,null!=refNode?(node.prev=refNode.prev,null!=refNode.prev&&(refNode.prev.next=node),refNode.prev=node,refNode===this.head&&(this.head=node)):null!=this.tail?(this.tail.next=node,node.prev=this.tail,this.tail=node):(node.prev=null,this.head=this.tail=node),this.length+=1)},LinkedList.prototype.offset=function(target){var index=0,cur=this.head;while(null!=cur){if(cur===target)return index;index+=cur.length(),cur=cur.next}return-1},LinkedList.prototype.remove=function(node){this.contains(node)&&(null!=node.prev&&(node.prev.next=node.next),null!=node.next&&(node.next.prev=node.prev),node===this.head&&(this.head=node.next),node===this.tail&&(this.tail=node.prev),this.length-=1)},LinkedList.prototype.iterator=function(curNode){
// TODO use yield when we can
return void 0===curNode&&(curNode=this.head),function(){var ret=curNode;return null!=curNode&&(curNode=curNode.next),ret}},LinkedList.prototype.find=function(index,inclusive){void 0===inclusive&&(inclusive=!1);var cur,next=this.iterator();while(cur=next()){var length=cur.length();if(index<length||inclusive&&index===length&&(null==cur.next||0!==cur.next.length()))return[cur,index];index-=length}return[null,0]},LinkedList.prototype.forEach=function(callback){var cur,next=this.iterator();while(cur=next())callback(cur)},LinkedList.prototype.forEachAt=function(index,length,callback){if(!(length<=0)){var cur,_a=this.find(index),startNode=_a[0],offset=_a[1],curIndex=index-offset,next=this.iterator(startNode);while((cur=next())&&curIndex<index+length){var curLength=cur.length();index>curIndex?callback(cur,index-curIndex,Math.min(length,curIndex+curLength-index)):callback(cur,0,Math.min(curLength,index+length-curIndex)),curIndex+=curLength}}},LinkedList.prototype.map=function(callback){return this.reduce((function(memo,cur){return memo.push(callback(cur)),memo}),[])},LinkedList.prototype.reduce=function(callback,memo){var cur,next=this.iterator();while(cur=next())memo=callback(memo,cur);return memo},LinkedList}();exports.default=LinkedList},
/* 45 */
/***/function(module,exports,__nested_webpack_require_260796__){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p])};return function(d,b){function __(){this.constructor=d}extendStatics(d,b),d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:!0});var container_1=__nested_webpack_require_260796__(17),Registry=__nested_webpack_require_260796__(1),OBSERVER_CONFIG={attributes:!0,characterData:!0,characterDataOldValue:!0,childList:!0,subtree:!0},MAX_OPTIMIZE_ITERATIONS=100,ScrollBlot=/** @class */function(_super){function ScrollBlot(node){var _this=_super.call(this,node)||this;return _this.scroll=_this,_this.observer=new MutationObserver((function(mutations){_this.update(mutations)})),_this.observer.observe(_this.domNode,OBSERVER_CONFIG),_this.attach(),_this}return __extends(ScrollBlot,_super),ScrollBlot.prototype.detach=function(){_super.prototype.detach.call(this),this.observer.disconnect()},ScrollBlot.prototype.deleteAt=function(index,length){this.update(),0===index&&length===this.length()?this.children.forEach((function(child){child.remove()})):_super.prototype.deleteAt.call(this,index,length)},ScrollBlot.prototype.formatAt=function(index,length,name,value){this.update(),_super.prototype.formatAt.call(this,index,length,name,value)},ScrollBlot.prototype.insertAt=function(index,value,def){this.update(),_super.prototype.insertAt.call(this,index,value,def)},ScrollBlot.prototype.optimize=function(mutations,context){var _this=this;void 0===mutations&&(mutations=[]),void 0===context&&(context={}),_super.prototype.optimize.call(this,context);
// We must modify mutations directly, cannot make copy and then modify
var records=[].slice.call(this.observer.takeRecords());
// Array.push currently seems to be implemented by a non-tail recursive function
// so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());
while(records.length>0)mutations.push(records.pop());
// TODO use WeakMap
for(var mark=function(blot,markParent){void 0===markParent&&(markParent=!0),null!=blot&&blot!==_this&&null!=blot.domNode.parentNode&&(
// @ts-ignore
null==blot.domNode[Registry.DATA_KEY].mutations&&(
// @ts-ignore
blot.domNode[Registry.DATA_KEY].mutations=[]),markParent&&mark(blot.parent))},optimize=function(blot){
// Post-order traversal
// @ts-ignore
null!=blot.domNode[Registry.DATA_KEY]&&
// @ts-ignore
null!=blot.domNode[Registry.DATA_KEY].mutations&&(blot instanceof container_1.default&&blot.children.forEach(optimize),blot.optimize(context))},remaining=mutations,i=0;remaining.length>0;i+=1){if(i>=MAX_OPTIMIZE_ITERATIONS)throw new Error("[Parchment] Maximum optimize iterations reached");remaining.forEach((function(mutation){var blot=Registry.find(mutation.target,!0);null!=blot&&(blot.domNode===mutation.target&&("childList"===mutation.type?(mark(Registry.find(mutation.previousSibling,!1)),[].forEach.call(mutation.addedNodes,(function(node){var child=Registry.find(node,!1);mark(child,!1),child instanceof container_1.default&&child.children.forEach((function(grandChild){mark(grandChild,!1)}))}))):"attributes"===mutation.type&&mark(blot.prev)),mark(blot))})),this.children.forEach(optimize),remaining=[].slice.call(this.observer.takeRecords()),records=remaining.slice();while(records.length>0)mutations.push(records.pop())}},ScrollBlot.prototype.update=function(mutations,context){var _this=this;void 0===context&&(context={}),mutations=mutations||this.observer.takeRecords(),
// TODO use WeakMap
mutations.map((function(mutation){var blot=Registry.find(mutation.target,!0);return null==blot?null:
// @ts-ignore
null==blot.domNode[Registry.DATA_KEY].mutations?(
// @ts-ignore
blot.domNode[Registry.DATA_KEY].mutations=[mutation],blot):(
// @ts-ignore
blot.domNode[Registry.DATA_KEY].mutations.push(mutation),null)})).forEach((function(blot){null!=blot&&blot!==_this&&
//@ts-ignore
null!=blot.domNode[Registry.DATA_KEY]&&
// @ts-ignore
blot.update(blot.domNode[Registry.DATA_KEY].mutations||[],context)})),
// @ts-ignore
null!=this.domNode[Registry.DATA_KEY].mutations&&
// @ts-ignore
_super.prototype.update.call(this,this.domNode[Registry.DATA_KEY].mutations,context),this.optimize(mutations,context)},ScrollBlot.blotName="scroll",ScrollBlot.defaultChild="block",ScrollBlot.scope=Registry.Scope.BLOCK_BLOT,ScrollBlot.tagName="DIV",ScrollBlot}(container_1.default);exports.default=ScrollBlot},
/* 46 */
/***/function(module,exports,__nested_webpack_require_267910__){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p])};return function(d,b){function __(){this.constructor=d}extendStatics(d,b),d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:!0});var format_1=__nested_webpack_require_267910__(18),Registry=__nested_webpack_require_267910__(1);
// Shallow object comparison
function isEqual(obj1,obj2){if(Object.keys(obj1).length!==Object.keys(obj2).length)return!1;
// @ts-ignore
for(var prop in obj1)
// @ts-ignore
if(obj1[prop]!==obj2[prop])return!1;return!0}var InlineBlot=/** @class */function(_super){function InlineBlot(){return null!==_super&&_super.apply(this,arguments)||this}return __extends(InlineBlot,_super),InlineBlot.formats=function(domNode){if(domNode.tagName!==InlineBlot.tagName)return _super.formats.call(this,domNode)},InlineBlot.prototype.format=function(name,value){var _this=this;name!==this.statics.blotName||value?_super.prototype.format.call(this,name,value):(this.children.forEach((function(child){child instanceof format_1.default||(child=child.wrap(InlineBlot.blotName,!0)),_this.attributes.copy(child)})),this.unwrap())},InlineBlot.prototype.formatAt=function(index,length,name,value){if(null!=this.formats()[name]||Registry.query(name,Registry.Scope.ATTRIBUTE)){var blot=this.isolate(index,length);blot.format(name,value)}else _super.prototype.formatAt.call(this,index,length,name,value)},InlineBlot.prototype.optimize=function(context){_super.prototype.optimize.call(this,context);var formats=this.formats();if(0===Object.keys(formats).length)return this.unwrap();// unformatted span
var next=this.next;next instanceof InlineBlot&&next.prev===this&&isEqual(formats,next.formats())&&(next.moveChildren(this),next.remove())},InlineBlot.blotName="inline",InlineBlot.scope=Registry.Scope.INLINE_BLOT,InlineBlot.tagName="SPAN",InlineBlot}(format_1.default);exports.default=InlineBlot},
/* 47 */
/***/function(module,exports,__nested_webpack_require_270902__){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p])};return function(d,b){function __(){this.constructor=d}extendStatics(d,b),d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:!0});var format_1=__nested_webpack_require_270902__(18),Registry=__nested_webpack_require_270902__(1),BlockBlot=/** @class */function(_super){function BlockBlot(){return null!==_super&&_super.apply(this,arguments)||this}return __extends(BlockBlot,_super),BlockBlot.formats=function(domNode){var tagName=Registry.query(BlockBlot.blotName).tagName;if(domNode.tagName!==tagName)return _super.formats.call(this,domNode)},BlockBlot.prototype.format=function(name,value){null!=Registry.query(name,Registry.Scope.BLOCK)&&(name!==this.statics.blotName||value?_super.prototype.format.call(this,name,value):this.replaceWith(BlockBlot.blotName))},BlockBlot.prototype.formatAt=function(index,length,name,value){null!=Registry.query(name,Registry.Scope.BLOCK)?this.format(name,value):_super.prototype.formatAt.call(this,index,length,name,value)},BlockBlot.prototype.insertAt=function(index,value,def){if(null==def||null!=Registry.query(value,Registry.Scope.INLINE))
// Insert text or inline
_super.prototype.insertAt.call(this,index,value,def);else{var after=this.split(index),blot=Registry.create(value,def);after.parent.insertBefore(blot,after)}},BlockBlot.prototype.update=function(mutations,context){navigator.userAgent.match(/Trident/)?this.build():_super.prototype.update.call(this,mutations,context)},BlockBlot.blotName="block",BlockBlot.scope=Registry.Scope.BLOCK_BLOT,BlockBlot.tagName="P",BlockBlot}(format_1.default);exports.default=BlockBlot},
/* 48 */
/***/function(module,exports,__nested_webpack_require_273610__){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p])};return function(d,b){function __(){this.constructor=d}extendStatics(d,b),d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:!0});var leaf_1=__nested_webpack_require_273610__(19),EmbedBlot=/** @class */function(_super){function EmbedBlot(){return null!==_super&&_super.apply(this,arguments)||this}return __extends(EmbedBlot,_super),EmbedBlot.formats=function(domNode){},EmbedBlot.prototype.format=function(name,value){
// super.formatAt wraps, which is what we want in general,
// but this allows subclasses to overwrite for formats
// that just apply to particular embeds
_super.prototype.formatAt.call(this,0,this.length(),name,value)},EmbedBlot.prototype.formatAt=function(index,length,name,value){0===index&&length===this.length()?this.format(name,value):_super.prototype.formatAt.call(this,index,length,name,value)},EmbedBlot.prototype.formats=function(){return this.statics.formats(this.domNode)},EmbedBlot}(leaf_1.default);exports.default=EmbedBlot},
/* 49 */
/***/function(module,exports,__nested_webpack_require_275351__){"use strict";var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p])};return function(d,b){function __(){this.constructor=d}extendStatics(d,b),d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,"__esModule",{value:!0});var leaf_1=__nested_webpack_require_275351__(19),Registry=__nested_webpack_require_275351__(1),TextBlot=/** @class */function(_super){function TextBlot(node){var _this=_super.call(this,node)||this;return _this.text=_this.statics.value(_this.domNode),_this}return __extends(TextBlot,_super),TextBlot.create=function(value){return document.createTextNode(value)},TextBlot.value=function(domNode){var text=domNode.data;
// @ts-ignore
return text["normalize"]&&(text=text["normalize"]()),text},TextBlot.prototype.deleteAt=function(index,length){this.domNode.data=this.text=this.text.slice(0,index)+this.text.slice(index+length)},TextBlot.prototype.index=function(node,offset){return this.domNode===node?offset:-1},TextBlot.prototype.insertAt=function(index,value,def){null==def?(this.text=this.text.slice(0,index)+value+this.text.slice(index),this.domNode.data=this.text):_super.prototype.insertAt.call(this,index,value,def)},TextBlot.prototype.length=function(){return this.text.length},TextBlot.prototype.optimize=function(context){_super.prototype.optimize.call(this,context),this.text=this.statics.value(this.domNode),0===this.text.length?this.remove():this.next instanceof TextBlot&&this.next.prev===this&&(this.insertAt(this.length(),this.next.value()),this.next.remove())},TextBlot.prototype.position=function(index,inclusive){return void 0===inclusive&&(inclusive=!1),[this.domNode,index]},TextBlot.prototype.split=function(index,force){if(void 0===force&&(force=!1),!force){if(0===index)return this;if(index===this.length())return this.next}var after=Registry.create(this.domNode.splitText(index));return this.parent.insertBefore(after,this.next),this.text=this.statics.value(this.domNode),after},TextBlot.prototype.update=function(mutations,context){var _this=this;mutations.some((function(mutation){return"characterData"===mutation.type&&mutation.target===_this.domNode}))&&(this.text=this.statics.value(this.domNode))},TextBlot.prototype.value=function(){return this.text},TextBlot.blotName="text",TextBlot.scope=Registry.Scope.INLINE_BLOT,TextBlot}(leaf_1.default);exports.default=TextBlot},
/* 50 */
/***/function(module,exports,__webpack_require__){"use strict";var elem=document.createElement("div");if(elem.classList.toggle("test-class",!1),elem.classList.contains("test-class")){var _toggle=DOMTokenList.prototype.toggle;DOMTokenList.prototype.toggle=function(token,force){return arguments.length>1&&!this.contains(token)===!force?force:_toggle.call(this,token)}}String.prototype.startsWith||(String.prototype.startsWith=function(searchString,position){return position=position||0,this.substr(position,searchString.length)===searchString}),String.prototype.endsWith||(String.prototype.endsWith=function(searchString,position){var subjectString=this.toString();("number"!==typeof position||!isFinite(position)||Math.floor(position)!==position||position>subjectString.length)&&(position=subjectString.length),position-=searchString.length;var lastIndex=subjectString.indexOf(searchString,position);return-1!==lastIndex&&lastIndex===position}),Array.prototype.find||Object.defineProperty(Array.prototype,"find",{value:function(predicate){if(null===this)throw new TypeError("Array.prototype.find called on null or undefined");if("function"!==typeof predicate)throw new TypeError("predicate must be a function");for(var value,list=Object(this),length=list.length>>>0,thisArg=arguments[1],i=0;i<length;i++)if(value=list[i],predicate.call(thisArg,value,i,list))return value}}),document.addEventListener("DOMContentLoaded",(function(){
// Disable resizing in Firefox
document.execCommand("enableObjectResizing",!1,!1),
// Disable automatic linkifying in IE11
document.execCommand("autoUrlDetect",!1,!1)}))},
/* 51 */
/***/function(module,exports){
/**
 * This library modifies the diff-patch-match library by Neil Fraser
 * by removing the patch and match functionality and certain advanced
 * options in the diff function. The original license is as follows:
 *
 * ===
 *
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE=-1,DIFF_INSERT=1,DIFF_EQUAL=0;
/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {Int} cursor_pos Expected edit position in text1 (optional)
 * @return {Array} Array of diff tuples.
 */
function diff_main(text1,text2,cursor_pos){
// Check for equality (speedup).
if(text1==text2)return text1?[[DIFF_EQUAL,text1]]:[];
// Check cursor_pos within bounds
(cursor_pos<0||text1.length<cursor_pos)&&(cursor_pos=null);
// Trim off common prefix (speedup).
var commonlength=diff_commonPrefix(text1,text2),commonprefix=text1.substring(0,commonlength);text1=text1.substring(commonlength),text2=text2.substring(commonlength),
// Trim off common suffix (speedup).
commonlength=diff_commonSuffix(text1,text2);var commonsuffix=text1.substring(text1.length-commonlength);text1=text1.substring(0,text1.length-commonlength),text2=text2.substring(0,text2.length-commonlength);
// Compute the diff on the middle block.
var diffs=diff_compute_(text1,text2);
// Restore the prefix and suffix.
return commonprefix&&diffs.unshift([DIFF_EQUAL,commonprefix]),commonsuffix&&diffs.push([DIFF_EQUAL,commonsuffix]),diff_cleanupMerge(diffs),null!=cursor_pos&&(diffs=fix_cursor(diffs,cursor_pos)),diffs=fix_emoji(diffs),diffs}
/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 */
function diff_compute_(text1,text2){var diffs;if(!text1)
// Just add some text (speedup).
return[[DIFF_INSERT,text2]];if(!text2)
// Just delete some text (speedup).
return[[DIFF_DELETE,text1]];var longtext=text1.length>text2.length?text1:text2,shorttext=text1.length>text2.length?text2:text1,i=longtext.indexOf(shorttext);if(-1!=i)
// Shorter text is inside the longer text (speedup).
return diffs=[[DIFF_INSERT,longtext.substring(0,i)],[DIFF_EQUAL,shorttext],[DIFF_INSERT,longtext.substring(i+shorttext.length)]],
// Swap insertions for deletions if diff is reversed.
text1.length>text2.length&&(diffs[0][0]=diffs[2][0]=DIFF_DELETE),diffs;if(1==shorttext.length)
// Single character string.
// After the previous speedup, the character can't be an equality.
return[[DIFF_DELETE,text1],[DIFF_INSERT,text2]];
// Check to see if the problem can be split in two.
var hm=diff_halfMatch_(text1,text2);if(hm){
// A half-match was found, sort out the return data.
var text1_a=hm[0],text1_b=hm[1],text2_a=hm[2],text2_b=hm[3],mid_common=hm[4],diffs_a=diff_main(text1_a,text2_a),diffs_b=diff_main(text1_b,text2_b);
// Merge the results.
return diffs_a.concat([[DIFF_EQUAL,mid_common]],diffs_b)}return diff_bisect_(text1,text2)}
/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 * @private
 */
function diff_bisect_(text1,text2){
// Setting all elements to -1 is faster in Chrome & Firefox than mixing
// integers and undefined.
for(
// Cache the text lengths to prevent multiple calls.
var text1_length=text1.length,text2_length=text2.length,max_d=Math.ceil((text1_length+text2_length)/2),v_offset=max_d,v_length=2*max_d,v1=new Array(v_length),v2=new Array(v_length),x=0;x<v_length;x++)v1[x]=-1,v2[x]=-1;v1[v_offset+1]=0,v2[v_offset+1]=0;for(var delta=text1_length-text2_length,front=delta%2!=0,k1start=0,k1end=0,k2start=0,k2end=0,d=0
// If the total number of characters is odd, then the front path will collide
// with the reverse path.
;d<max_d;d++){
// Walk the front path one step.
for(var k1=-d+k1start;k1<=d-k1end;k1+=2){var k1_offset=v_offset+k1;x1=k1==-d||k1!=d&&v1[k1_offset-1]<v1[k1_offset+1]?v1[k1_offset+1]:v1[k1_offset-1]+1;var y1=x1-k1;while(x1<text1_length&&y1<text2_length&&text1.charAt(x1)==text2.charAt(y1))x1++,y1++;if(v1[k1_offset]=x1,x1>text1_length)
// Ran off the right of the graph.
k1end+=2;else if(y1>text2_length)
// Ran off the bottom of the graph.
k1start+=2;else if(front){var k2_offset=v_offset+delta-k1;if(k2_offset>=0&&k2_offset<v_length&&-1!=v2[k2_offset]){
// Mirror x2 onto top-left coordinate system.
var x2=text1_length-v2[k2_offset];if(x1>=x2)
// Overlap detected.
return diff_bisectSplit_(text1,text2,x1,y1)}}}
// Walk the reverse path one step.
for(var k2=-d+k2start;k2<=d-k2end;k2+=2){k2_offset=v_offset+k2;x2=k2==-d||k2!=d&&v2[k2_offset-1]<v2[k2_offset+1]?v2[k2_offset+1]:v2[k2_offset-1]+1;var y2=x2-k2;while(x2<text1_length&&y2<text2_length&&text1.charAt(text1_length-x2-1)==text2.charAt(text2_length-y2-1))x2++,y2++;if(v2[k2_offset]=x2,x2>text1_length)
// Ran off the left of the graph.
k2end+=2;else if(y2>text2_length)
// Ran off the top of the graph.
k2start+=2;else if(!front){k1_offset=v_offset+delta-k2;if(k1_offset>=0&&k1_offset<v_length&&-1!=v1[k1_offset]){var x1=v1[k1_offset];y1=v_offset+x1-k1_offset;if(
// Mirror x2 onto top-left coordinate system.
x2=text1_length-x2,x1>=x2)
// Overlap detected.
return diff_bisectSplit_(text1,text2,x1,y1)}}}}
// Diff took too long and hit the deadline or
// number of diffs equals number of characters, no commonality at all.
return[[DIFF_DELETE,text1],[DIFF_INSERT,text2]]}
/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @return {Array} Array of diff tuples.
 */
function diff_bisectSplit_(text1,text2,x,y){var text1a=text1.substring(0,x),text2a=text2.substring(0,y),text1b=text1.substring(x),text2b=text2.substring(y),diffs=diff_main(text1a,text2a),diffsb=diff_main(text1b,text2b);return diffs.concat(diffsb)}
/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
function diff_commonPrefix(text1,text2){
// Quick check for common null cases.
if(!text1||!text2||text1.charAt(0)!=text2.charAt(0))return 0;
// Binary search.
// Performance analysis: http://neil.fraser.name/news/2007/10/09/
var pointermin=0,pointermax=Math.min(text1.length,text2.length),pointermid=pointermax,pointerstart=0;while(pointermin<pointermid)text1.substring(pointerstart,pointermid)==text2.substring(pointerstart,pointermid)?(pointermin=pointermid,pointerstart=pointermin):pointermax=pointermid,pointermid=Math.floor((pointermax-pointermin)/2+pointermin);return pointermid}
/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
function diff_commonSuffix(text1,text2){
// Quick check for common null cases.
if(!text1||!text2||text1.charAt(text1.length-1)!=text2.charAt(text2.length-1))return 0;
// Binary search.
// Performance analysis: http://neil.fraser.name/news/2007/10/09/
var pointermin=0,pointermax=Math.min(text1.length,text2.length),pointermid=pointermax,pointerend=0;while(pointermin<pointermid)text1.substring(text1.length-pointermid,text1.length-pointerend)==text2.substring(text2.length-pointermid,text2.length-pointerend)?(pointermin=pointermid,pointerend=pointermin):pointermax=pointermid,pointermid=Math.floor((pointermax-pointermin)/2+pointermin);return pointermid}
/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 */
function diff_halfMatch_(text1,text2){var longtext=text1.length>text2.length?text1:text2,shorttext=text1.length>text2.length?text2:text1;if(longtext.length<4||2*shorttext.length<longtext.length)return null;// Pointless.
/**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */function diff_halfMatchI_(longtext,shorttext,i){
// Start with a 1/4 length substring at position i as a seed.
var best_longtext_a,best_longtext_b,best_shorttext_a,best_shorttext_b,seed=longtext.substring(i,i+Math.floor(longtext.length/4)),j=-1,best_common="";while(-1!=(j=shorttext.indexOf(seed,j+1))){var prefixLength=diff_commonPrefix(longtext.substring(i),shorttext.substring(j)),suffixLength=diff_commonSuffix(longtext.substring(0,i),shorttext.substring(0,j));best_common.length<suffixLength+prefixLength&&(best_common=shorttext.substring(j-suffixLength,j)+shorttext.substring(j,j+prefixLength),best_longtext_a=longtext.substring(0,i-suffixLength),best_longtext_b=longtext.substring(i+prefixLength),best_shorttext_a=shorttext.substring(0,j-suffixLength),best_shorttext_b=shorttext.substring(j+prefixLength))}return 2*best_common.length>=longtext.length?[best_longtext_a,best_longtext_b,best_shorttext_a,best_shorttext_b,best_common]:null}
// First check if the second quarter is the seed for a half-match.
var hm,text1_a,text1_b,text2_a,text2_b,hm1=diff_halfMatchI_(longtext,shorttext,Math.ceil(longtext.length/4)),hm2=diff_halfMatchI_(longtext,shorttext,Math.ceil(longtext.length/2));
// Check again based on the third quarter.
if(!hm1&&!hm2)return null;
// A half-match was found, sort out the return data.
// Both matched.  Select the longest.
hm=hm2?hm1&&hm1[4].length>hm2[4].length?hm1:hm2:hm1,text1.length>text2.length?(text1_a=hm[0],text1_b=hm[1],text2_a=hm[2],text2_b=hm[3]):(text2_a=hm[0],text2_b=hm[1],text1_a=hm[2],text1_b=hm[3]);var mid_common=hm[4];return[text1_a,text1_b,text2_a,text2_b,mid_common]}
/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {Array} diffs Array of diff tuples.
 */
function diff_cleanupMerge(diffs){diffs.push([DIFF_EQUAL,""]);// Add a dummy entry at the end.
var commonlength,pointer=0,count_delete=0,count_insert=0,text_delete="",text_insert="";while(pointer<diffs.length)switch(diffs[pointer][0]){case DIFF_INSERT:count_insert++,text_insert+=diffs[pointer][1],pointer++;break;case DIFF_DELETE:count_delete++,text_delete+=diffs[pointer][1],pointer++;break;case DIFF_EQUAL:
// Upon reaching an equality, check for prior redundancies.
count_delete+count_insert>1?(0!==count_delete&&0!==count_insert&&(
// Factor out any common prefixies.
commonlength=diff_commonPrefix(text_insert,text_delete),0!==commonlength&&(pointer-count_delete-count_insert>0&&diffs[pointer-count_delete-count_insert-1][0]==DIFF_EQUAL?diffs[pointer-count_delete-count_insert-1][1]+=text_insert.substring(0,commonlength):(diffs.splice(0,0,[DIFF_EQUAL,text_insert.substring(0,commonlength)]),pointer++),text_insert=text_insert.substring(commonlength),text_delete=text_delete.substring(commonlength)),
// Factor out any common suffixies.
commonlength=diff_commonSuffix(text_insert,text_delete),0!==commonlength&&(diffs[pointer][1]=text_insert.substring(text_insert.length-commonlength)+diffs[pointer][1],text_insert=text_insert.substring(0,text_insert.length-commonlength),text_delete=text_delete.substring(0,text_delete.length-commonlength))),
// Delete the offending records and add the merged ones.
0===count_delete?diffs.splice(pointer-count_insert,count_delete+count_insert,[DIFF_INSERT,text_insert]):0===count_insert?diffs.splice(pointer-count_delete,count_delete+count_insert,[DIFF_DELETE,text_delete]):diffs.splice(pointer-count_delete-count_insert,count_delete+count_insert,[DIFF_DELETE,text_delete],[DIFF_INSERT,text_insert]),pointer=pointer-count_delete-count_insert+(count_delete?1:0)+(count_insert?1:0)+1):0!==pointer&&diffs[pointer-1][0]==DIFF_EQUAL?(
// Merge this equality with the previous one.
diffs[pointer-1][1]+=diffs[pointer][1],diffs.splice(pointer,1)):pointer++,count_insert=0,count_delete=0,text_delete="",text_insert="";break}""===diffs[diffs.length-1][1]&&diffs.pop();
// Second pass: look for single edits surrounded on both sides by equalities
// which can be shifted sideways to eliminate an equality.
// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
var changes=!1;pointer=1;
// Intentionally ignore the first and last element (don't need checking).
while(pointer<diffs.length-1)diffs[pointer-1][0]==DIFF_EQUAL&&diffs[pointer+1][0]==DIFF_EQUAL&&(
// This is a single edit surrounded by equalities.
diffs[pointer][1].substring(diffs[pointer][1].length-diffs[pointer-1][1].length)==diffs[pointer-1][1]?(
// Shift the edit over the previous equality.
diffs[pointer][1]=diffs[pointer-1][1]+diffs[pointer][1].substring(0,diffs[pointer][1].length-diffs[pointer-1][1].length),diffs[pointer+1][1]=diffs[pointer-1][1]+diffs[pointer+1][1],diffs.splice(pointer-1,1),changes=!0):diffs[pointer][1].substring(0,diffs[pointer+1][1].length)==diffs[pointer+1][1]&&(
// Shift the edit over the next equality.
diffs[pointer-1][1]+=diffs[pointer+1][1],diffs[pointer][1]=diffs[pointer][1].substring(diffs[pointer+1][1].length)+diffs[pointer+1][1],diffs.splice(pointer+1,1),changes=!0)),pointer++;
// If shifts were made, the diff needs reordering and another shift sweep.
changes&&diff_cleanupMerge(diffs)}var diff=diff_main;
/*
 * Modify a diff such that the cursor position points to the start of a change:
 * E.g.
 *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)
 *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]
 *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)
 *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]
 *
 * @param {Array} diffs Array of diff tuples
 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
 * @return {Array} A tuple [cursor location in the modified diff, modified diff]
 */
function cursor_normalize_diff(diffs,cursor_pos){if(0===cursor_pos)return[DIFF_EQUAL,diffs];for(var current_pos=0,i=0;i<diffs.length;i++){var d=diffs[i];if(d[0]===DIFF_DELETE||d[0]===DIFF_EQUAL){var next_pos=current_pos+d[1].length;if(cursor_pos===next_pos)return[i+1,diffs];if(cursor_pos<next_pos){
// copy to prevent side effects
diffs=diffs.slice();
// split d into two diff changes
var split_pos=cursor_pos-current_pos,d_left=[d[0],d[1].slice(0,split_pos)],d_right=[d[0],d[1].slice(split_pos)];return diffs.splice(i,1,d_left,d_right),[i+1,diffs]}current_pos=next_pos}}throw new Error("cursor_pos is out of bounds!")}
/*
 * Modify a diff such that the edit position is "shifted" to the proposed edit location (cursor_position).
 *
 * Case 1)
 *   Check if a naive shift is possible:
 *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)
 *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result
 * Case 2)
 *   Check if the following shifts are possible:
 *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']
 *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']
 *         ^            ^
 *         d          d_next
 *
 * @param {Array} diffs Array of diff tuples
 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
 * @return {Array} Array of diff tuples
 */function fix_cursor(diffs,cursor_pos){var norm=cursor_normalize_diff(diffs,cursor_pos),ndiffs=norm[1],cursor_pointer=norm[0],d=ndiffs[cursor_pointer],d_next=ndiffs[cursor_pointer+1];if(null==d)
// Text was deleted from end of original string,
// cursor is now out of bounds in new string
return diffs;if(d[0]!==DIFF_EQUAL)
// A modification happened at the cursor location.
// This is the expected outcome, so we can return the original diff.
return diffs;if(null!=d_next&&d[1]+d_next[1]===d_next[1]+d[1])
// Case 1)
// It is possible to perform a naive shift
return ndiffs.splice(cursor_pointer,2,d_next,d),merge_tuples(ndiffs,cursor_pointer,2);if(null!=d_next&&0===d_next[1].indexOf(d[1])){
// Case 2)
// d[1] is a prefix of d_next[1]
// We can assume that d_next[0] !== 0, since d[0] === 0
// Shift edit locations..
ndiffs.splice(cursor_pointer,2,[d_next[0],d[1]],[0,d[1]]);var suffix=d_next[1].slice(d[1].length);return suffix.length>0&&ndiffs.splice(cursor_pointer+2,0,[d_next[0],suffix]),merge_tuples(ndiffs,cursor_pointer,3)}
// Not possible to perform any modification
return diffs}
/*
 * Check diff did not split surrogate pairs.
 * Ex. [0, '\uD83D'], [-1, '\uDC36'], [1, '\uDC2F'] -> [-1, '\uD83D\uDC36'], [1, '\uD83D\uDC2F']
 *     '\uD83D\uDC36' === '🐶', '\uD83D\uDC2F' === '🐯'
 *
 * @param {Array} diffs Array of diff tuples
 * @return {Array} Array of diff tuples
 */function fix_emoji(diffs){for(var compact=!1,starts_with_pair_end=function(str){return str.charCodeAt(0)>=56320&&str.charCodeAt(0)<=57343},ends_with_pair_start=function(str){return str.charCodeAt(str.length-1)>=55296&&str.charCodeAt(str.length-1)<=56319},i=2;i<diffs.length;i+=1)diffs[i-2][0]===DIFF_EQUAL&&ends_with_pair_start(diffs[i-2][1])&&diffs[i-1][0]===DIFF_DELETE&&starts_with_pair_end(diffs[i-1][1])&&diffs[i][0]===DIFF_INSERT&&starts_with_pair_end(diffs[i][1])&&(compact=!0,diffs[i-1][1]=diffs[i-2][1].slice(-1)+diffs[i-1][1],diffs[i][1]=diffs[i-2][1].slice(-1)+diffs[i][1],diffs[i-2][1]=diffs[i-2][1].slice(0,-1));if(!compact)return diffs;var fixed_diffs=[];for(i=0;i<diffs.length;i+=1)diffs[i][1].length>0&&fixed_diffs.push(diffs[i]);return fixed_diffs}
/*
 * Try to merge tuples with their neigbors in a given range.
 * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']
 *
 * @param {Array} diffs Array of diff tuples.
 * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).
 * @param {Int} length Number of consecutive elements to check.
 * @return {Array} Array of merged diff tuples.
 */function merge_tuples(diffs,start,length){
// Check from (start-1) to (start+length).
for(var i=start+length-1;i>=0&&i>=start-1;i--)if(i+1<diffs.length){var left_d=diffs[i],right_d=diffs[i+1];left_d[0]===right_d[1]&&diffs.splice(i,2,[left_d[0],left_d[1]+right_d[1]])}return diffs}
/***/diff.INSERT=DIFF_INSERT,diff.DELETE=DIFF_DELETE,diff.EQUAL=DIFF_EQUAL,module.exports=diff},
/* 52 */
/***/function(module,exports){function shim(obj){var keys=[];for(var key in obj)keys.push(key);return keys}
/***/exports=module.exports="function"===typeof Object.keys?Object.keys:shim,exports.shim=shim},
/* 53 */
/***/function(module,exports){var supportsArgumentsClass="[object Arguments]"==function(){return Object.prototype.toString.call(arguments)}();function supported(object){return"[object Arguments]"==Object.prototype.toString.call(object)}function unsupported(object){return object&&"object"==typeof object&&"number"==typeof object.length&&Object.prototype.hasOwnProperty.call(object,"callee")&&!Object.prototype.propertyIsEnumerable.call(object,"callee")||!1}exports=module.exports=supportsArgumentsClass?supported:unsupported,exports.supported=supported,exports.unsupported=unsupported},
/* 54 */
/***/function(module,exports){"use strict";var has=Object.prototype.hasOwnProperty,prefix="~";
/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @api private
 */function Events(){}

// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {Mixed} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @api private
 */
function EE(fn,context,once){this.fn=fn,this.context=context,this.once=once||!1}
/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @api public
 */function EventEmitter(){this._events=new Events,this._eventsCount=0}
/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @api public
 */Object.create&&(Events.prototype=Object.create(null),
// This hack is needed because the `__proto__` property is still inherited in
// some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
(new Events).__proto__||(prefix=!1)),EventEmitter.prototype.eventNames=function(){var events,name,names=[];if(0===this._eventsCount)return names;for(name in events=this._events)has.call(events,name)&&names.push(prefix?name.slice(1):name);return Object.getOwnPropertySymbols?names.concat(Object.getOwnPropertySymbols(events)):names},
/**
 * Return the listeners registered for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Boolean} exists Only check if there are listeners.
 * @returns {Array|Boolean}
 * @api public
 */
EventEmitter.prototype.listeners=function(event,exists){var evt=prefix?prefix+event:event,available=this._events[evt];if(exists)return!!available;if(!available)return[];if(available.fn)return[available.fn];for(var i=0,l=available.length,ee=new Array(l);i<l;i++)ee[i]=available[i].fn;return ee},
/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @api public
 */
EventEmitter.prototype.emit=function(event,a1,a2,a3,a4,a5){var evt=prefix?prefix+event:event;if(!this._events[evt])return!1;var args,i,listeners=this._events[evt],len=arguments.length;if(listeners.fn){switch(listeners.once&&this.removeListener(event,listeners.fn,void 0,!0),len){case 1:return listeners.fn.call(listeners.context),!0;case 2:return listeners.fn.call(listeners.context,a1),!0;case 3:return listeners.fn.call(listeners.context,a1,a2),!0;case 4:return listeners.fn.call(listeners.context,a1,a2,a3),!0;case 5:return listeners.fn.call(listeners.context,a1,a2,a3,a4),!0;case 6:return listeners.fn.call(listeners.context,a1,a2,a3,a4,a5),!0}for(i=1,args=new Array(len-1);i<len;i++)args[i-1]=arguments[i];listeners.fn.apply(listeners.context,args)}else{var j,length=listeners.length;for(i=0;i<length;i++)switch(listeners[i].once&&this.removeListener(event,listeners[i].fn,void 0,!0),len){case 1:listeners[i].fn.call(listeners[i].context);break;case 2:listeners[i].fn.call(listeners[i].context,a1);break;case 3:listeners[i].fn.call(listeners[i].context,a1,a2);break;case 4:listeners[i].fn.call(listeners[i].context,a1,a2,a3);break;default:if(!args)for(j=1,args=new Array(len-1);j<len;j++)args[j-1]=arguments[j];listeners[i].fn.apply(listeners[i].context,args)}}return!0},
/**
 * Add a listener for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Function} fn The listener function.
 * @param {Mixed} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.on=function(event,fn,context){var listener=new EE(fn,context||this),evt=prefix?prefix+event:event;return this._events[evt]?this._events[evt].fn?this._events[evt]=[this._events[evt],listener]:this._events[evt].push(listener):(this._events[evt]=listener,this._eventsCount++),this},
/**
 * Add a one-time listener for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Function} fn The listener function.
 * @param {Mixed} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.once=function(event,fn,context){var listener=new EE(fn,context||this,!0),evt=prefix?prefix+event:event;return this._events[evt]?this._events[evt].fn?this._events[evt]=[this._events[evt],listener]:this._events[evt].push(listener):(this._events[evt]=listener,this._eventsCount++),this},
/**
 * Remove the listeners of a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {Mixed} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.removeListener=function(event,fn,context,once){var evt=prefix?prefix+event:event;if(!this._events[evt])return this;if(!fn)return 0===--this._eventsCount?this._events=new Events:delete this._events[evt],this;var listeners=this._events[evt];if(listeners.fn)listeners.fn!==fn||once&&!listeners.once||context&&listeners.context!==context||(0===--this._eventsCount?this._events=new Events:delete this._events[evt]);else{for(var i=0,events=[],length=listeners.length;i<length;i++)(listeners[i].fn!==fn||once&&!listeners[i].once||context&&listeners[i].context!==context)&&events.push(listeners[i]);

// Reset the array, or remove it completely if we have no more listeners.

events.length?this._events[evt]=1===events.length?events[0]:events:0===--this._eventsCount?this._events=new Events:delete this._events[evt]}return this},
/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {String|Symbol} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.removeAllListeners=function(event){var evt;return event?(evt=prefix?prefix+event:event,this._events[evt]&&(0===--this._eventsCount?this._events=new Events:delete this._events[evt])):(this._events=new Events,this._eventsCount=0),this},
// Alias methods names because people roll like that.
EventEmitter.prototype.off=EventEmitter.prototype.removeListener,EventEmitter.prototype.addListener=EventEmitter.prototype.on,
// This function doesn't apply anymore.
EventEmitter.prototype.setMaxListeners=function(){return this},
// Expose the prefix.
EventEmitter.prefixed=prefix,
// Allow `EventEmitter` to be imported as module namespace.
EventEmitter.EventEmitter=EventEmitter,
// Expose the module.
"undefined"!==typeof module&&(module.exports=EventEmitter)
/***/},
/* 55 */
/***/function(module,exports,__nested_webpack_require_316416__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.matchText=exports.matchSpacing=exports.matchNewline=exports.matchBlot=exports.matchAttributor=exports.default=void 0;var _typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_slicedToArray=function(){function sliceIterator(arr,i){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done);_n=!0)if(_arr.push(_s.value),i&&_arr.length===i)break}catch(err){_d=!0,_e=err}finally{try{!_n&&_i["return"]&&_i["return"]()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr))return arr;if(Symbol.iterator in Object(arr))return sliceIterator(arr,i);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_extend2=__nested_webpack_require_316416__(3),_extend3=_interopRequireDefault(_extend2),_quillDelta=__nested_webpack_require_316416__(2),_quillDelta2=_interopRequireDefault(_quillDelta),_parchment=__nested_webpack_require_316416__(0),_parchment2=_interopRequireDefault(_parchment),_quill=__nested_webpack_require_316416__(5),_quill2=_interopRequireDefault(_quill),_logger=__nested_webpack_require_316416__(10),_logger2=_interopRequireDefault(_logger),_module=__nested_webpack_require_316416__(9),_module2=_interopRequireDefault(_module),_align=__nested_webpack_require_316416__(36),_background=__nested_webpack_require_316416__(37),_code=__nested_webpack_require_316416__(13),_code2=_interopRequireDefault(_code),_color=__nested_webpack_require_316416__(26),_direction=__nested_webpack_require_316416__(38),_font=__nested_webpack_require_316416__(39),_size=__nested_webpack_require_316416__(40);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var debug=(0,_logger2.default)("quill:clipboard"),DOM_KEY="__ql-matcher",CLIPBOARD_CONFIG=[[Node.TEXT_NODE,matchText],[Node.TEXT_NODE,matchNewline],["br",matchBreak],[Node.ELEMENT_NODE,matchNewline],[Node.ELEMENT_NODE,matchBlot],[Node.ELEMENT_NODE,matchSpacing],[Node.ELEMENT_NODE,matchAttributor],[Node.ELEMENT_NODE,matchStyles],["li",matchIndent],["b",matchAlias.bind(matchAlias,"bold")],["i",matchAlias.bind(matchAlias,"italic")],["style",matchIgnore]],ATTRIBUTE_ATTRIBUTORS=[_align.AlignAttribute,_direction.DirectionAttribute].reduce((function(memo,attr){return memo[attr.keyName]=attr,memo}),{}),STYLE_ATTRIBUTORS=[_align.AlignStyle,_background.BackgroundStyle,_color.ColorStyle,_direction.DirectionStyle,_font.FontStyle,_size.SizeStyle].reduce((function(memo,attr){return memo[attr.keyName]=attr,memo}),{}),Clipboard=function(_Module){function Clipboard(quill,options){_classCallCheck(this,Clipboard);var _this=_possibleConstructorReturn(this,(Clipboard.__proto__||Object.getPrototypeOf(Clipboard)).call(this,quill,options));return _this.quill.root.addEventListener("paste",_this.onPaste.bind(_this)),_this.container=_this.quill.addContainer("ql-clipboard"),_this.container.setAttribute("contenteditable",!0),_this.container.setAttribute("tabindex",-1),_this.matchers=[],CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach((function(_ref){var _ref2=_slicedToArray(_ref,2),selector=_ref2[0],matcher=_ref2[1];(options.matchVisual||matcher!==matchSpacing)&&_this.addMatcher(selector,matcher)})),_this}return _inherits(Clipboard,_Module),_createClass(Clipboard,[{key:"addMatcher",value:function(selector,matcher){this.matchers.push([selector,matcher])}},{key:"convert",value:function(html){if("string"===typeof html)// Remove spaces between tags
return this.container.innerHTML=html.replace(/\>\r?\n +\</g,"><"),this.convert();var formats=this.quill.getFormat(this.quill.selection.savedRange.index);if(formats[_code2.default.blotName]){var text=this.container.innerText;return this.container.innerHTML="",(new _quillDelta2.default).insert(text,_defineProperty({},_code2.default.blotName,formats[_code2.default.blotName]))}var _prepareMatching=this.prepareMatching(),_prepareMatching2=_slicedToArray(_prepareMatching,2),elementMatchers=_prepareMatching2[0],textMatchers=_prepareMatching2[1],delta=traverse(this.container,elementMatchers,textMatchers);
// Remove trailing newline
return deltaEndsWith(delta,"\n")&&null==delta.ops[delta.ops.length-1].attributes&&(delta=delta.compose((new _quillDelta2.default).retain(delta.length()-1).delete(1))),debug.log("convert",this.container.innerHTML,delta),this.container.innerHTML="",delta}},{key:"dangerouslyPasteHTML",value:function(index,html){var source=arguments.length>2&&void 0!==arguments[2]?arguments[2]:_quill2.default.sources.API;if("string"===typeof index)this.quill.setContents(this.convert(index),html),this.quill.setSelection(0,_quill2.default.sources.SILENT);else{var paste=this.convert(html);this.quill.updateContents((new _quillDelta2.default).retain(index).concat(paste),source),this.quill.setSelection(index+paste.length(),_quill2.default.sources.SILENT)}}},{key:"onPaste",value:function(e){var _this2=this;if(!e.defaultPrevented&&this.quill.isEnabled()){var range=this.quill.getSelection(),delta=(new _quillDelta2.default).retain(range.index),scrollTop=this.quill.scrollingContainer.scrollTop;this.container.focus(),this.quill.selection.update(_quill2.default.sources.SILENT),setTimeout((function(){delta=delta.concat(_this2.convert()).delete(range.length),_this2.quill.updateContents(delta,_quill2.default.sources.USER),
// range.length contributes to delta.length()
_this2.quill.setSelection(delta.length()-range.length,_quill2.default.sources.SILENT),_this2.quill.scrollingContainer.scrollTop=scrollTop,_this2.quill.focus()}),1)}}},{key:"prepareMatching",value:function(){var _this3=this,elementMatchers=[],textMatchers=[];return this.matchers.forEach((function(pair){var _pair=_slicedToArray(pair,2),selector=_pair[0],matcher=_pair[1];switch(selector){case Node.TEXT_NODE:textMatchers.push(matcher);break;case Node.ELEMENT_NODE:elementMatchers.push(matcher);break;default:[].forEach.call(_this3.container.querySelectorAll(selector),(function(node){
// TODO use weakmap
node[DOM_KEY]=node[DOM_KEY]||[],node[DOM_KEY].push(matcher)}));break}})),[elementMatchers,textMatchers]}}]),Clipboard}(_module2.default);function applyFormat(delta,format,value){return"object"===("undefined"===typeof format?"undefined":_typeof(format))?Object.keys(format).reduce((function(delta,key){return applyFormat(delta,key,format[key])}),delta):delta.reduce((function(delta,op){return op.attributes&&op.attributes[format]?delta.push(op):delta.insert(op.insert,(0,_extend3.default)({},_defineProperty({},format,value),op.attributes))}),new _quillDelta2.default)}function computeStyle(node){if(node.nodeType!==Node.ELEMENT_NODE)return{};var DOM_KEY="__ql-computed-style";return node[DOM_KEY]||(node[DOM_KEY]=window.getComputedStyle(node))}function deltaEndsWith(delta,text){for(var endText="",i=delta.ops.length-1;i>=0&&endText.length<text.length;--i){var op=delta.ops[i];if("string"!==typeof op.insert)break;endText=op.insert+endText}return endText.slice(-1*text.length)===text}function isLine(node){if(0===node.childNodes.length)return!1;// Exclude embed blocks
var style=computeStyle(node);return["block","list-item"].indexOf(style.display)>-1}function traverse(node,elementMatchers,textMatchers){
// Post-order
return node.nodeType===node.TEXT_NODE?textMatchers.reduce((function(delta,matcher){return matcher(node,delta)}),new _quillDelta2.default):node.nodeType===node.ELEMENT_NODE?[].reduce.call(node.childNodes||[],(function(delta,childNode){var childrenDelta=traverse(childNode,elementMatchers,textMatchers);return childNode.nodeType===node.ELEMENT_NODE&&(childrenDelta=elementMatchers.reduce((function(childrenDelta,matcher){return matcher(childNode,childrenDelta)}),childrenDelta),childrenDelta=(childNode[DOM_KEY]||[]).reduce((function(childrenDelta,matcher){return matcher(childNode,childrenDelta)}),childrenDelta)),delta.concat(childrenDelta)}),new _quillDelta2.default):new _quillDelta2.default}function matchAlias(format,node,delta){return applyFormat(delta,format,!0)}function matchAttributor(node,delta){var attributes=_parchment2.default.Attributor.Attribute.keys(node),classes=_parchment2.default.Attributor.Class.keys(node),styles=_parchment2.default.Attributor.Style.keys(node),formats={};return attributes.concat(classes).concat(styles).forEach((function(name){var attr=_parchment2.default.query(name,_parchment2.default.Scope.ATTRIBUTE);null!=attr&&(formats[attr.attrName]=attr.value(node),formats[attr.attrName])||(attr=ATTRIBUTE_ATTRIBUTORS[name],null==attr||attr.attrName!==name&&attr.keyName!==name||(formats[attr.attrName]=attr.value(node)||void 0),attr=STYLE_ATTRIBUTORS[name],null==attr||attr.attrName!==name&&attr.keyName!==name||(attr=STYLE_ATTRIBUTORS[name],formats[attr.attrName]=attr.value(node)||void 0))})),Object.keys(formats).length>0&&(delta=applyFormat(delta,formats)),delta}function matchBlot(node,delta){var match=_parchment2.default.query(node);if(null==match)return delta;if(match.prototype instanceof _parchment2.default.Embed){var embed={},value=match.value(node);null!=value&&(embed[match.blotName]=value,delta=(new _quillDelta2.default).insert(embed,match.formats(node)))}else"function"===typeof match.formats&&(delta=applyFormat(delta,match.blotName,match.formats(node)));return delta}function matchBreak(node,delta){return deltaEndsWith(delta,"\n")||delta.insert("\n"),delta}function matchIgnore(){return new _quillDelta2.default}function matchIndent(node,delta){var match=_parchment2.default.query(node);if(null==match||"list-item"!==match.blotName||!deltaEndsWith(delta,"\n"))return delta;var indent=-1,parent=node.parentNode;while(!parent.classList.contains("ql-clipboard"))"list"===(_parchment2.default.query(parent)||{}).blotName&&(indent+=1),parent=parent.parentNode;return indent<=0?delta:delta.compose((new _quillDelta2.default).retain(delta.length()-1).retain(1,{indent:indent}))}function matchNewline(node,delta){return deltaEndsWith(delta,"\n")||(isLine(node)||delta.length()>0&&node.nextSibling&&isLine(node.nextSibling))&&delta.insert("\n"),delta}function matchSpacing(node,delta){if(isLine(node)&&null!=node.nextElementSibling&&!deltaEndsWith(delta,"\n\n")){var nodeHeight=node.offsetHeight+parseFloat(computeStyle(node).marginTop)+parseFloat(computeStyle(node).marginBottom);node.nextElementSibling.offsetTop>node.offsetTop+1.5*nodeHeight&&delta.insert("\n")}return delta}function matchStyles(node,delta){var formats={},style=node.style||{};return style.fontStyle&&"italic"===computeStyle(node).fontStyle&&(formats.italic=!0),style.fontWeight&&(computeStyle(node).fontWeight.startsWith("bold")||parseInt(computeStyle(node).fontWeight)>=700)&&(formats.bold=!0),Object.keys(formats).length>0&&(delta=applyFormat(delta,formats)),parseFloat(style.textIndent||0)>0&&(
// Could be 0.5in
delta=(new _quillDelta2.default).insert("\t").concat(delta)),delta}function matchText(node,delta){var text=node.data;
// Word represents empty line with <o:p>&nbsp;</o:p>
if("O:P"===node.parentNode.tagName)return delta.insert(text.trim());if(0===text.trim().length&&node.parentNode.classList.contains("ql-clipboard"))return delta;if(!computeStyle(node.parentNode).whiteSpace.startsWith("pre")){
// eslint-disable-next-line func-style
var replacer=function(collapse,match){// \u00a0 is nbsp;
return match=match.replace(/[^\u00a0]/g,""),match.length<1&&collapse?" ":match};text=text.replace(/\r\n/g," ").replace(/\n/g," "),text=text.replace(/\s\s+/g,replacer.bind(replacer,!0)),// collapse whitespace
(null==node.previousSibling&&isLine(node.parentNode)||null!=node.previousSibling&&isLine(node.previousSibling))&&(text=text.replace(/^\s+/,replacer.bind(replacer,!1))),(null==node.nextSibling&&isLine(node.parentNode)||null!=node.nextSibling&&isLine(node.nextSibling))&&(text=text.replace(/\s+$/,replacer.bind(replacer,!1)))}return delta.insert(text)}Clipboard.DEFAULTS={matchers:[],matchVisual:!0},exports.default=Clipboard,exports.matchAttributor=matchAttributor,exports.matchBlot=matchBlot,exports.matchNewline=matchNewline,exports.matchSpacing=matchSpacing,exports.matchText=matchText},
/* 56 */
/***/function(module,exports,__nested_webpack_require_333274__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_inline=__nested_webpack_require_333274__(6),_inline2=_interopRequireDefault(_inline);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var Bold=function(_Inline){function Bold(){return _classCallCheck(this,Bold),_possibleConstructorReturn(this,(Bold.__proto__||Object.getPrototypeOf(Bold)).apply(this,arguments))}return _inherits(Bold,_Inline),_createClass(Bold,[{key:"optimize",value:function(context){_get(Bold.prototype.__proto__||Object.getPrototypeOf(Bold.prototype),"optimize",this).call(this,context),this.domNode.tagName!==this.statics.tagName[0]&&this.replaceWith(this.statics.blotName)}}],[{key:"create",value:function(){return _get(Bold.__proto__||Object.getPrototypeOf(Bold),"create",this).call(this)}},{key:"formats",value:function(){return!0}}]),Bold}(_inline2.default);Bold.blotName="bold",Bold.tagName=["STRONG","B"],exports.default=Bold},
/* 57 */
/***/function(module,exports,__nested_webpack_require_336502__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.addControls=exports.default=void 0;var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done);_n=!0)if(_arr.push(_s.value),i&&_arr.length===i)break}catch(err){_d=!0,_e=err}finally{try{!_n&&_i["return"]&&_i["return"]()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr))return arr;if(Symbol.iterator in Object(arr))return sliceIterator(arr,i);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_quillDelta=__nested_webpack_require_336502__(2),_quillDelta2=_interopRequireDefault(_quillDelta),_parchment=__nested_webpack_require_336502__(0),_parchment2=_interopRequireDefault(_parchment),_quill=__nested_webpack_require_336502__(5),_quill2=_interopRequireDefault(_quill),_logger=__nested_webpack_require_336502__(10),_logger2=_interopRequireDefault(_logger),_module=__nested_webpack_require_336502__(9),_module2=_interopRequireDefault(_module);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var debug=(0,_logger2.default)("quill:toolbar"),Toolbar=function(_Module){function Toolbar(quill,options){_classCallCheck(this,Toolbar);var _ret,_this=_possibleConstructorReturn(this,(Toolbar.__proto__||Object.getPrototypeOf(Toolbar)).call(this,quill,options));if(Array.isArray(_this.options.container)){var container=document.createElement("div");addControls(container,_this.options.container),quill.container.parentNode.insertBefore(container,quill.container),_this.container=container}else"string"===typeof _this.options.container?_this.container=document.querySelector(_this.options.container):_this.container=_this.options.container;return _this.container instanceof HTMLElement?(_this.container.classList.add("ql-toolbar"),_this.controls=[],_this.handlers={},Object.keys(_this.options.handlers).forEach((function(format){_this.addHandler(format,_this.options.handlers[format])})),[].forEach.call(_this.container.querySelectorAll("button, select"),(function(input){_this.attach(input)})),_this.quill.on(_quill2.default.events.EDITOR_CHANGE,(function(type,range){type===_quill2.default.events.SELECTION_CHANGE&&_this.update(range)})),_this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE,(function(){var _this$quill$selection=_this.quill.selection.getRange(),_this$quill$selection2=_slicedToArray(_this$quill$selection,1),range=_this$quill$selection2[0];// quill.getSelection triggers update
_this.update(range)})),_this):(_ret=debug.error("Container required for toolbar",_this.options),_possibleConstructorReturn(_this,_ret))}return _inherits(Toolbar,_Module),_createClass(Toolbar,[{key:"addHandler",value:function(format,handler){this.handlers[format]=handler}},{key:"attach",value:function(input){var _this2=this,format=[].find.call(input.classList,(function(className){return 0===className.indexOf("ql-")}));if(format){if(format=format.slice(3),"BUTTON"===input.tagName&&input.setAttribute("type","button"),null==this.handlers[format]){if(null!=this.quill.scroll.whitelist&&null==this.quill.scroll.whitelist[format])return void debug.warn("ignoring attaching to disabled format",format,input);if(null==_parchment2.default.query(format))return void debug.warn("ignoring attaching to nonexistent format",format,input)}var eventName="SELECT"===input.tagName?"change":"click";input.addEventListener(eventName,(function(e){var value=void 0;if("SELECT"===input.tagName){if(input.selectedIndex<0)return;var selected=input.options[input.selectedIndex];value=!selected.hasAttribute("selected")&&(selected.value||!1)}else value=!input.classList.contains("ql-active")&&(input.value||!input.hasAttribute("value")),e.preventDefault();_this2.quill.focus();var _quill$selection$getR=_this2.quill.selection.getRange(),_quill$selection$getR2=_slicedToArray(_quill$selection$getR,1),range=_quill$selection$getR2[0];if(null!=_this2.handlers[format])_this2.handlers[format].call(_this2,value);else if(_parchment2.default.query(format).prototype instanceof _parchment2.default.Embed){if(value=prompt("Enter "+format),!value)return;_this2.quill.updateContents((new _quillDelta2.default).retain(range.index).delete(range.length).insert(_defineProperty({},format,value)),_quill2.default.sources.USER)}else _this2.quill.format(format,value,_quill2.default.sources.USER);_this2.update(range)})),
// TODO use weakmap
this.controls.push([format,input])}}},{key:"update",value:function(range){var formats=null==range?{}:this.quill.getFormat(range);this.controls.forEach((function(pair){var _pair=_slicedToArray(pair,2),format=_pair[0],input=_pair[1];if("SELECT"===input.tagName){var option=void 0;if(null==range)option=null;else if(null==formats[format])option=input.querySelector("option[selected]");else if(!Array.isArray(formats[format])){var value=formats[format];"string"===typeof value&&(value=value.replace(/\"/g,'\\"')),option=input.querySelector('option[value="'+value+'"]')}null==option?(input.value="",// TODO make configurable?
input.selectedIndex=-1):option.selected=!0}else if(null==range)input.classList.remove("ql-active");else if(input.hasAttribute("value")){
// both being null should match (default values)
// '1' should match with 1 (headers)
var isActive=formats[format]===input.getAttribute("value")||null!=formats[format]&&formats[format].toString()===input.getAttribute("value")||null==formats[format]&&!input.getAttribute("value");input.classList.toggle("ql-active",isActive)}else input.classList.toggle("ql-active",null!=formats[format])}))}}]),Toolbar}(_module2.default);function addButton(container,format,value){var input=document.createElement("button");input.setAttribute("type","button"),input.classList.add("ql-"+format),null!=value&&(input.value=value),container.appendChild(input)}function addControls(container,groups){Array.isArray(groups[0])||(groups=[groups]),groups.forEach((function(controls){var group=document.createElement("span");group.classList.add("ql-formats"),controls.forEach((function(control){if("string"===typeof control)addButton(group,control);else{var format=Object.keys(control)[0],value=control[format];Array.isArray(value)?addSelect(group,format,value):addButton(group,format,value)}})),container.appendChild(group)}))}function addSelect(container,format,values){var input=document.createElement("select");input.classList.add("ql-"+format),values.forEach((function(value){var option=document.createElement("option");!1!==value?option.setAttribute("value",value):option.setAttribute("selected","selected"),input.appendChild(option)})),container.appendChild(input)}Toolbar.DEFAULTS={},Toolbar.DEFAULTS={container:null,handlers:{clean:function(){var _this3=this,range=this.quill.getSelection();if(null!=range)if(0==range.length){var formats=this.quill.getFormat();Object.keys(formats).forEach((function(name){
// Clean functionality in existing apps only clean inline formats
null!=_parchment2.default.query(name,_parchment2.default.Scope.INLINE)&&_this3.quill.format(name,!1)}))}else this.quill.removeFormat(range,_quill2.default.sources.USER)},direction:function(value){var align=this.quill.getFormat()["align"];"rtl"===value&&null==align?this.quill.format("align","right",_quill2.default.sources.USER):value||"right"!==align||this.quill.format("align",!1,_quill2.default.sources.USER),this.quill.format("direction",value,_quill2.default.sources.USER)},indent:function(value){var range=this.quill.getSelection(),formats=this.quill.getFormat(range),indent=parseInt(formats.indent||0);if("+1"===value||"-1"===value){var modifier="+1"===value?1:-1;"rtl"===formats.direction&&(modifier*=-1),this.quill.format("indent",indent+modifier,_quill2.default.sources.USER)}},link:function(value){!0===value&&(value=prompt("Enter link URL:")),this.quill.format("link",value,_quill2.default.sources.USER)},list:function(value){var range=this.quill.getSelection(),formats=this.quill.getFormat(range);"check"===value?"checked"===formats["list"]||"unchecked"===formats["list"]?this.quill.format("list",!1,_quill2.default.sources.USER):this.quill.format("list","unchecked",_quill2.default.sources.USER):this.quill.format("list",value,_quill2.default.sources.USER)}}},exports.default=Toolbar,exports.addControls=addControls},
/* 58 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"></polyline> <polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>';
/***/},
/* 59 */
/***/function(module,exports,__nested_webpack_require_349781__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_picker=__nested_webpack_require_349781__(28),_picker2=_interopRequireDefault(_picker);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var ColorPicker=function(_Picker){function ColorPicker(select,label){_classCallCheck(this,ColorPicker);var _this=_possibleConstructorReturn(this,(ColorPicker.__proto__||Object.getPrototypeOf(ColorPicker)).call(this,select));return _this.label.innerHTML=label,_this.container.classList.add("ql-color-picker"),[].slice.call(_this.container.querySelectorAll(".ql-picker-item"),0,7).forEach((function(item){item.classList.add("ql-primary")})),_this}return _inherits(ColorPicker,_Picker),_createClass(ColorPicker,[{key:"buildItem",value:function(option){var item=_get(ColorPicker.prototype.__proto__||Object.getPrototypeOf(ColorPicker.prototype),"buildItem",this).call(this,option);return item.style.backgroundColor=option.getAttribute("value")||"",item}},{key:"selectItem",value:function(item,trigger){_get(ColorPicker.prototype.__proto__||Object.getPrototypeOf(ColorPicker.prototype),"selectItem",this).call(this,item,trigger);var colorLabel=this.label.querySelector(".ql-color-label"),value=item&&item.getAttribute("data-value")||"";colorLabel&&("line"===colorLabel.tagName?colorLabel.style.stroke=value:colorLabel.style.fill=value)}}]),ColorPicker}(_picker2.default);exports.default=ColorPicker},
/* 60 */
/***/function(module,exports,__nested_webpack_require_353592__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_picker=__nested_webpack_require_353592__(28),_picker2=_interopRequireDefault(_picker);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var IconPicker=function(_Picker){function IconPicker(select,icons){_classCallCheck(this,IconPicker);var _this=_possibleConstructorReturn(this,(IconPicker.__proto__||Object.getPrototypeOf(IconPicker)).call(this,select));return _this.container.classList.add("ql-icon-picker"),[].forEach.call(_this.container.querySelectorAll(".ql-picker-item"),(function(item){item.innerHTML=icons[item.getAttribute("data-value")||""]})),_this.defaultItem=_this.container.querySelector(".ql-selected"),_this.selectItem(_this.defaultItem),_this}return _inherits(IconPicker,_Picker),_createClass(IconPicker,[{key:"selectItem",value:function(item,trigger){_get(IconPicker.prototype.__proto__||Object.getPrototypeOf(IconPicker.prototype),"selectItem",this).call(this,item,trigger),item=item||this.defaultItem,this.label.innerHTML=item.innerHTML}}]),IconPicker}(_picker2.default);exports.default=IconPicker},
/* 61 */
/***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}var Tooltip=function(){function Tooltip(quill,boundsContainer){var _this=this;_classCallCheck(this,Tooltip),this.quill=quill,this.boundsContainer=boundsContainer||document.body,this.root=quill.addContainer("ql-tooltip"),this.root.innerHTML=this.constructor.TEMPLATE,this.quill.root===this.quill.scrollingContainer&&this.quill.root.addEventListener("scroll",(function(){_this.root.style.marginTop=-1*_this.quill.root.scrollTop+"px"})),this.hide()}return _createClass(Tooltip,[{key:"hide",value:function(){this.root.classList.add("ql-hidden")}},{key:"position",value:function(reference){var left=reference.left+reference.width/2-this.root.offsetWidth/2,top=reference.bottom+this.quill.root.scrollTop;
// root.scrollTop should be 0 if scrollContainer !== root
this.root.style.left=left+"px",this.root.style.top=top+"px",this.root.classList.remove("ql-flip");var containerBounds=this.boundsContainer.getBoundingClientRect(),rootBounds=this.root.getBoundingClientRect(),shift=0;if(rootBounds.right>containerBounds.right&&(shift=containerBounds.right-rootBounds.right,this.root.style.left=left+shift+"px"),rootBounds.left<containerBounds.left&&(shift=containerBounds.left-rootBounds.left,this.root.style.left=left+shift+"px"),rootBounds.bottom>containerBounds.bottom){var height=rootBounds.bottom-rootBounds.top,verticalShift=reference.bottom-reference.top+height;this.root.style.top=top-verticalShift+"px",this.root.classList.add("ql-flip")}return shift}},{key:"show",value:function(){this.root.classList.remove("ql-editing"),this.root.classList.remove("ql-hidden")}}]),Tooltip}();exports.default=Tooltip},
/* 62 */
/***/function(module,exports,__nested_webpack_require_359932__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done);_n=!0)if(_arr.push(_s.value),i&&_arr.length===i)break}catch(err){_d=!0,_e=err}finally{try{!_n&&_i["return"]&&_i["return"]()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr))return arr;if(Symbol.iterator in Object(arr))return sliceIterator(arr,i);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_extend=__nested_webpack_require_359932__(3),_extend2=_interopRequireDefault(_extend),_emitter=__nested_webpack_require_359932__(8),_emitter2=_interopRequireDefault(_emitter),_base=__nested_webpack_require_359932__(43),_base2=_interopRequireDefault(_base),_link=__nested_webpack_require_359932__(27),_link2=_interopRequireDefault(_link),_selection=__nested_webpack_require_359932__(15),_icons=__nested_webpack_require_359932__(41),_icons2=_interopRequireDefault(_icons);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var TOOLBAR_CONFIG=[[{header:["1","2","3",!1]}],["bold","italic","underline","link"],[{list:"ordered"},{list:"bullet"}],["clean"]],SnowTheme=function(_BaseTheme){function SnowTheme(quill,options){_classCallCheck(this,SnowTheme),null!=options.modules.toolbar&&null==options.modules.toolbar.container&&(options.modules.toolbar.container=TOOLBAR_CONFIG);var _this=_possibleConstructorReturn(this,(SnowTheme.__proto__||Object.getPrototypeOf(SnowTheme)).call(this,quill,options));return _this.quill.container.classList.add("ql-snow"),_this}return _inherits(SnowTheme,_BaseTheme),_createClass(SnowTheme,[{key:"extendToolbar",value:function(toolbar){toolbar.container.classList.add("ql-snow"),this.buildButtons([].slice.call(toolbar.container.querySelectorAll("button")),_icons2.default),this.buildPickers([].slice.call(toolbar.container.querySelectorAll("select")),_icons2.default),this.tooltip=new SnowTooltip(this.quill,this.options.bounds),toolbar.container.querySelector(".ql-link")&&this.quill.keyboard.addBinding({key:"K",shortKey:!0},(function(range,context){toolbar.handlers["link"].call(toolbar,!context.format.link)}))}}]),SnowTheme}(_base2.default);SnowTheme.DEFAULTS=(0,_extend2.default)(!0,{},_base2.default.DEFAULTS,{modules:{toolbar:{handlers:{link:function(value){if(value){var range=this.quill.getSelection();if(null==range||0==range.length)return;var preview=this.quill.getText(range);/^\S+@\S+\.\S+$/.test(preview)&&0!==preview.indexOf("mailto:")&&(preview="mailto:"+preview);var tooltip=this.quill.theme.tooltip;tooltip.edit("link",preview)}else this.quill.format("link",!1)}}}}});var SnowTooltip=function(_BaseTooltip){function SnowTooltip(quill,bounds){_classCallCheck(this,SnowTooltip);var _this2=_possibleConstructorReturn(this,(SnowTooltip.__proto__||Object.getPrototypeOf(SnowTooltip)).call(this,quill,bounds));return _this2.preview=_this2.root.querySelector("a.ql-preview"),_this2}return _inherits(SnowTooltip,_BaseTooltip),_createClass(SnowTooltip,[{key:"listen",value:function(){var _this3=this;_get(SnowTooltip.prototype.__proto__||Object.getPrototypeOf(SnowTooltip.prototype),"listen",this).call(this),this.root.querySelector("a.ql-action").addEventListener("click",(function(event){_this3.root.classList.contains("ql-editing")?_this3.save():_this3.edit("link",_this3.preview.textContent),event.preventDefault()})),this.root.querySelector("a.ql-remove").addEventListener("click",(function(event){if(null!=_this3.linkRange){var range=_this3.linkRange;_this3.restoreFocus(),_this3.quill.formatText(range,"link",!1,_emitter2.default.sources.USER),delete _this3.linkRange}event.preventDefault(),_this3.hide()})),this.quill.on(_emitter2.default.events.SELECTION_CHANGE,(function(range,oldRange,source){if(null!=range){if(0===range.length&&source===_emitter2.default.sources.USER){var _quill$scroll$descend=_this3.quill.scroll.descendant(_link2.default,range.index),_quill$scroll$descend2=_slicedToArray(_quill$scroll$descend,2),link=_quill$scroll$descend2[0],offset=_quill$scroll$descend2[1];if(null!=link){_this3.linkRange=new _selection.Range(range.index-offset,link.length());var preview=_link2.default.formats(link.domNode);return _this3.preview.textContent=preview,_this3.preview.setAttribute("href",preview),_this3.show(),void _this3.position(_this3.quill.getBounds(_this3.linkRange))}}else delete _this3.linkRange;_this3.hide()}}))}},{key:"show",value:function(){_get(SnowTooltip.prototype.__proto__||Object.getPrototypeOf(SnowTooltip.prototype),"show",this).call(this),this.root.removeAttribute("data-mode")}}]),SnowTooltip}(_base.BaseTooltip);SnowTooltip.TEMPLATE=['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>','<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">','<a class="ql-action"></a>','<a class="ql-remove"></a>'].join(""),exports.default=SnowTheme},
/* 63 */
/***/function(module,exports,__nested_webpack_require_368316__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _core=__nested_webpack_require_368316__(29),_core2=_interopRequireDefault(_core),_align=__nested_webpack_require_368316__(36),_direction=__nested_webpack_require_368316__(38),_indent=__nested_webpack_require_368316__(64),_blockquote=__nested_webpack_require_368316__(65),_blockquote2=_interopRequireDefault(_blockquote),_header=__nested_webpack_require_368316__(66),_header2=_interopRequireDefault(_header),_list=__nested_webpack_require_368316__(67),_list2=_interopRequireDefault(_list),_background=__nested_webpack_require_368316__(37),_color=__nested_webpack_require_368316__(26),_font=__nested_webpack_require_368316__(39),_size=__nested_webpack_require_368316__(40),_bold=__nested_webpack_require_368316__(56),_bold2=_interopRequireDefault(_bold),_italic=__nested_webpack_require_368316__(68),_italic2=_interopRequireDefault(_italic),_link=__nested_webpack_require_368316__(27),_link2=_interopRequireDefault(_link),_script=__nested_webpack_require_368316__(69),_script2=_interopRequireDefault(_script),_strike=__nested_webpack_require_368316__(70),_strike2=_interopRequireDefault(_strike),_underline=__nested_webpack_require_368316__(71),_underline2=_interopRequireDefault(_underline),_image=__nested_webpack_require_368316__(72),_image2=_interopRequireDefault(_image),_video=__nested_webpack_require_368316__(73),_video2=_interopRequireDefault(_video),_code=__nested_webpack_require_368316__(13),_code2=_interopRequireDefault(_code),_formula=__nested_webpack_require_368316__(74),_formula2=_interopRequireDefault(_formula),_syntax=__nested_webpack_require_368316__(75),_syntax2=_interopRequireDefault(_syntax),_toolbar=__nested_webpack_require_368316__(57),_toolbar2=_interopRequireDefault(_toolbar),_icons=__nested_webpack_require_368316__(41),_icons2=_interopRequireDefault(_icons),_picker=__nested_webpack_require_368316__(28),_picker2=_interopRequireDefault(_picker),_colorPicker=__nested_webpack_require_368316__(59),_colorPicker2=_interopRequireDefault(_colorPicker),_iconPicker=__nested_webpack_require_368316__(60),_iconPicker2=_interopRequireDefault(_iconPicker),_tooltip=__nested_webpack_require_368316__(61),_tooltip2=_interopRequireDefault(_tooltip),_bubble=__nested_webpack_require_368316__(108),_bubble2=_interopRequireDefault(_bubble),_snow=__nested_webpack_require_368316__(62),_snow2=_interopRequireDefault(_snow);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}_core2.default.register({"attributors/attribute/direction":_direction.DirectionAttribute,"attributors/class/align":_align.AlignClass,"attributors/class/background":_background.BackgroundClass,"attributors/class/color":_color.ColorClass,"attributors/class/direction":_direction.DirectionClass,"attributors/class/font":_font.FontClass,"attributors/class/size":_size.SizeClass,"attributors/style/align":_align.AlignStyle,"attributors/style/background":_background.BackgroundStyle,"attributors/style/color":_color.ColorStyle,"attributors/style/direction":_direction.DirectionStyle,"attributors/style/font":_font.FontStyle,"attributors/style/size":_size.SizeStyle},!0),_core2.default.register({"formats/align":_align.AlignClass,"formats/direction":_direction.DirectionClass,"formats/indent":_indent.IndentClass,"formats/background":_background.BackgroundStyle,"formats/color":_color.ColorStyle,"formats/font":_font.FontClass,"formats/size":_size.SizeClass,"formats/blockquote":_blockquote2.default,"formats/code-block":_code2.default,"formats/header":_header2.default,"formats/list":_list2.default,"formats/bold":_bold2.default,"formats/code":_code.Code,"formats/italic":_italic2.default,"formats/link":_link2.default,"formats/script":_script2.default,"formats/strike":_strike2.default,"formats/underline":_underline2.default,"formats/image":_image2.default,"formats/video":_video2.default,"formats/list/item":_list.ListItem,"modules/formula":_formula2.default,"modules/syntax":_syntax2.default,"modules/toolbar":_toolbar2.default,"themes/bubble":_bubble2.default,"themes/snow":_snow2.default,"ui/icons":_icons2.default,"ui/picker":_picker2.default,"ui/icon-picker":_iconPicker2.default,"ui/color-picker":_colorPicker2.default,"ui/tooltip":_tooltip2.default},!0),exports.default=_core2.default},
/* 64 */
/***/function(module,exports,__nested_webpack_require_372903__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.IndentClass=void 0;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_parchment=__nested_webpack_require_372903__(0),_parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var IdentAttributor=function(_Parchment$Attributor){function IdentAttributor(){return _classCallCheck(this,IdentAttributor),_possibleConstructorReturn(this,(IdentAttributor.__proto__||Object.getPrototypeOf(IdentAttributor)).apply(this,arguments))}return _inherits(IdentAttributor,_Parchment$Attributor),_createClass(IdentAttributor,[{key:"add",value:function(node,value){if("+1"===value||"-1"===value){var indent=this.value(node)||0;value="+1"===value?indent+1:indent-1}return 0===value?(this.remove(node),!0):_get(IdentAttributor.prototype.__proto__||Object.getPrototypeOf(IdentAttributor.prototype),"add",this).call(this,node,value)}},{key:"canAdd",value:function(node,value){return _get(IdentAttributor.prototype.__proto__||Object.getPrototypeOf(IdentAttributor.prototype),"canAdd",this).call(this,node,value)||_get(IdentAttributor.prototype.__proto__||Object.getPrototypeOf(IdentAttributor.prototype),"canAdd",this).call(this,node,parseInt(value))}},{key:"value",value:function(node){return parseInt(_get(IdentAttributor.prototype.__proto__||Object.getPrototypeOf(IdentAttributor.prototype),"value",this).call(this,node))||void 0;// Don't return NaN
}}]),IdentAttributor}(_parchment2.default.Attributor.Class),IndentClass=new IdentAttributor("indent","ql-indent",{scope:_parchment2.default.Scope.BLOCK,whitelist:[1,2,3,4,5,6,7,8]});exports.IndentClass=IndentClass},
/* 65 */
/***/function(module,exports,__nested_webpack_require_376943__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _block=__nested_webpack_require_376943__(4),_block2=_interopRequireDefault(_block);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var Blockquote=function(_Block){function Blockquote(){return _classCallCheck(this,Blockquote),_possibleConstructorReturn(this,(Blockquote.__proto__||Object.getPrototypeOf(Blockquote)).apply(this,arguments))}return _inherits(Blockquote,_Block),Blockquote}(_block2.default);Blockquote.blotName="blockquote",Blockquote.tagName="blockquote",exports.default=Blockquote},
/* 66 */
/***/function(module,exports,__nested_webpack_require_378592__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_block=__nested_webpack_require_378592__(4),_block2=_interopRequireDefault(_block);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var Header=function(_Block){function Header(){return _classCallCheck(this,Header),_possibleConstructorReturn(this,(Header.__proto__||Object.getPrototypeOf(Header)).apply(this,arguments))}return _inherits(Header,_Block),_createClass(Header,null,[{key:"formats",value:function(domNode){return this.tagName.indexOf(domNode.tagName)+1}}]),Header}(_block2.default);Header.blotName="header",Header.tagName=["H1","H2","H3","H4","H5","H6"],exports.default=Header},
/* 67 */
/***/function(module,exports,__nested_webpack_require_380948__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.ListItem=void 0;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_parchment=__nested_webpack_require_380948__(0),_parchment2=_interopRequireDefault(_parchment),_block=__nested_webpack_require_380948__(4),_block2=_interopRequireDefault(_block),_container=__nested_webpack_require_380948__(25),_container2=_interopRequireDefault(_container);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var ListItem=function(_Block){function ListItem(){return _classCallCheck(this,ListItem),_possibleConstructorReturn(this,(ListItem.__proto__||Object.getPrototypeOf(ListItem)).apply(this,arguments))}return _inherits(ListItem,_Block),_createClass(ListItem,[{key:"format",value:function(name,value){name!==List.blotName||value?_get(ListItem.prototype.__proto__||Object.getPrototypeOf(ListItem.prototype),"format",this).call(this,name,value):this.replaceWith(_parchment2.default.create(this.statics.scope))}},{key:"remove",value:function(){null==this.prev&&null==this.next?this.parent.remove():_get(ListItem.prototype.__proto__||Object.getPrototypeOf(ListItem.prototype),"remove",this).call(this)}},{key:"replaceWith",value:function(name,value){return this.parent.isolate(this.offset(this.parent),this.length()),name===this.parent.statics.blotName?(this.parent.replaceWith(name,value),this):(this.parent.unwrap(),_get(ListItem.prototype.__proto__||Object.getPrototypeOf(ListItem.prototype),"replaceWith",this).call(this,name,value))}}],[{key:"formats",value:function(domNode){return domNode.tagName===this.tagName?void 0:_get(ListItem.__proto__||Object.getPrototypeOf(ListItem),"formats",this).call(this,domNode)}}]),ListItem}(_block2.default);ListItem.blotName="list-item",ListItem.tagName="LI";var List=function(_Container){function List(domNode){_classCallCheck(this,List);var _this2=_possibleConstructorReturn(this,(List.__proto__||Object.getPrototypeOf(List)).call(this,domNode)),listEventHandler=function(e){if(e.target.parentNode===domNode){var format=_this2.statics.formats(domNode),blot=_parchment2.default.find(e.target);"checked"===format?blot.format("list","unchecked"):"unchecked"===format&&blot.format("list","checked")}};return domNode.addEventListener("touchstart",listEventHandler),domNode.addEventListener("mousedown",listEventHandler),_this2}return _inherits(List,_Container),_createClass(List,null,[{key:"create",value:function(value){var tagName="ordered"===value?"OL":"UL",node=_get(List.__proto__||Object.getPrototypeOf(List),"create",this).call(this,tagName);return"checked"!==value&&"unchecked"!==value||node.setAttribute("data-checked","checked"===value),node}},{key:"formats",value:function(domNode){return"OL"===domNode.tagName?"ordered":"UL"===domNode.tagName?domNode.hasAttribute("data-checked")?"true"===domNode.getAttribute("data-checked")?"checked":"unchecked":"bullet":void 0}}]),_createClass(List,[{key:"format",value:function(name,value){this.children.length>0&&this.children.tail.format(name,value)}},{key:"formats",value:function(){
// We don't inherit from FormatBlot
return _defineProperty({},this.statics.blotName,this.statics.formats(this.domNode))}},{key:"insertBefore",value:function(blot,ref){if(blot instanceof ListItem)_get(List.prototype.__proto__||Object.getPrototypeOf(List.prototype),"insertBefore",this).call(this,blot,ref);else{var index=null==ref?this.length():ref.offset(this),after=this.split(index);after.parent.insertBefore(blot,after)}}},{key:"optimize",value:function(context){_get(List.prototype.__proto__||Object.getPrototypeOf(List.prototype),"optimize",this).call(this,context);var next=this.next;null!=next&&next.prev===this&&next.statics.blotName===this.statics.blotName&&next.domNode.tagName===this.domNode.tagName&&next.domNode.getAttribute("data-checked")===this.domNode.getAttribute("data-checked")&&(next.moveChildren(this),next.remove())}},{key:"replace",value:function(target){if(target.statics.blotName!==this.statics.blotName){var item=_parchment2.default.create(this.statics.defaultChild);target.moveChildren(item),this.appendChild(item)}_get(List.prototype.__proto__||Object.getPrototypeOf(List.prototype),"replace",this).call(this,target)}}]),List}(_container2.default);List.blotName="list",List.scope=_parchment2.default.Scope.BLOCK_BLOT,List.tagName=["OL","UL"],List.defaultChild="list-item",List.allowedChildren=[ListItem],exports.ListItem=ListItem,exports.default=List},
/* 68 */
/***/function(module,exports,__nested_webpack_require_389000__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _bold=__nested_webpack_require_389000__(56),_bold2=_interopRequireDefault(_bold);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var Italic=function(_Bold){function Italic(){return _classCallCheck(this,Italic),_possibleConstructorReturn(this,(Italic.__proto__||Object.getPrototypeOf(Italic)).apply(this,arguments))}return _inherits(Italic,_Bold),Italic}(_bold2.default);Italic.blotName="italic",Italic.tagName=["EM","I"],exports.default=Italic},
/* 69 */
/***/function(module,exports,__nested_webpack_require_390599__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_inline=__nested_webpack_require_390599__(6),_inline2=_interopRequireDefault(_inline);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var Script=function(_Inline){function Script(){return _classCallCheck(this,Script),_possibleConstructorReturn(this,(Script.__proto__||Object.getPrototypeOf(Script)).apply(this,arguments))}return _inherits(Script,_Inline),_createClass(Script,null,[{key:"create",value:function(value){return"super"===value?document.createElement("sup"):"sub"===value?document.createElement("sub"):_get(Script.__proto__||Object.getPrototypeOf(Script),"create",this).call(this,value)}},{key:"formats",value:function(domNode){return"SUB"===domNode.tagName?"sub":"SUP"===domNode.tagName?"super":void 0}}]),Script}(_inline2.default);Script.blotName="script",Script.tagName=["SUB","SUP"],exports.default=Script},
/* 70 */
/***/function(module,exports,__nested_webpack_require_393860__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _inline=__nested_webpack_require_393860__(6),_inline2=_interopRequireDefault(_inline);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var Strike=function(_Inline){function Strike(){return _classCallCheck(this,Strike),_possibleConstructorReturn(this,(Strike.__proto__||Object.getPrototypeOf(Strike)).apply(this,arguments))}return _inherits(Strike,_Inline),Strike}(_inline2.default);Strike.blotName="strike",Strike.tagName="S",exports.default=Strike},
/* 71 */
/***/function(module,exports,__nested_webpack_require_395462__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _inline=__nested_webpack_require_395462__(6),_inline2=_interopRequireDefault(_inline);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var Underline=function(_Inline){function Underline(){return _classCallCheck(this,Underline),_possibleConstructorReturn(this,(Underline.__proto__||Object.getPrototypeOf(Underline)).apply(this,arguments))}return _inherits(Underline,_Inline),Underline}(_inline2.default);Underline.blotName="underline",Underline.tagName="U",exports.default=Underline},
/* 72 */
/***/function(module,exports,__nested_webpack_require_397097__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_parchment=__nested_webpack_require_397097__(0),_parchment2=_interopRequireDefault(_parchment),_link=__nested_webpack_require_397097__(27);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var ATTRIBUTES=["alt","height","width"],Image=function(_Parchment$Embed){function Image(){return _classCallCheck(this,Image),_possibleConstructorReturn(this,(Image.__proto__||Object.getPrototypeOf(Image)).apply(this,arguments))}return _inherits(Image,_Parchment$Embed),_createClass(Image,[{key:"format",value:function(name,value){ATTRIBUTES.indexOf(name)>-1?value?this.domNode.setAttribute(name,value):this.domNode.removeAttribute(name):_get(Image.prototype.__proto__||Object.getPrototypeOf(Image.prototype),"format",this).call(this,name,value)}}],[{key:"create",value:function(value){var node=_get(Image.__proto__||Object.getPrototypeOf(Image),"create",this).call(this,value);return"string"===typeof value&&node.setAttribute("src",this.sanitize(value)),node}},{key:"formats",value:function(domNode){return ATTRIBUTES.reduce((function(formats,attribute){return domNode.hasAttribute(attribute)&&(formats[attribute]=domNode.getAttribute(attribute)),formats}),{})}},{key:"match",value:function(url){return/\.(jpe?g|gif|png)$/.test(url)||/^data:image\/.+;base64/.test(url)}},{key:"sanitize",value:function(url){return(0,_link.sanitize)(url,["http","https","data"])?url:"//:0"}},{key:"value",value:function(domNode){return domNode.getAttribute("src")}}]),Image}(_parchment2.default.Embed);Image.blotName="image",Image.tagName="IMG",exports.default=Image},
/* 73 */
/***/function(module,exports,__nested_webpack_require_401311__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_block=__nested_webpack_require_401311__(4),_link=__nested_webpack_require_401311__(27),_link2=_interopRequireDefault(_link);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var ATTRIBUTES=["height","width"],Video=function(_BlockEmbed){function Video(){return _classCallCheck(this,Video),_possibleConstructorReturn(this,(Video.__proto__||Object.getPrototypeOf(Video)).apply(this,arguments))}return _inherits(Video,_BlockEmbed),_createClass(Video,[{key:"format",value:function(name,value){ATTRIBUTES.indexOf(name)>-1?value?this.domNode.setAttribute(name,value):this.domNode.removeAttribute(name):_get(Video.prototype.__proto__||Object.getPrototypeOf(Video.prototype),"format",this).call(this,name,value)}}],[{key:"create",value:function(value){var node=_get(Video.__proto__||Object.getPrototypeOf(Video),"create",this).call(this,value);return node.setAttribute("frameborder","0"),node.setAttribute("allowfullscreen",!0),node.setAttribute("src",this.sanitize(value)),node}},{key:"formats",value:function(domNode){return ATTRIBUTES.reduce((function(formats,attribute){return domNode.hasAttribute(attribute)&&(formats[attribute]=domNode.getAttribute(attribute)),formats}),{})}},{key:"sanitize",value:function(url){return _link2.default.sanitize(url)}},{key:"value",value:function(domNode){return domNode.getAttribute("src")}}]),Video}(_block.BlockEmbed);Video.blotName="video",Video.className="ql-video",Video.tagName="IFRAME",exports.default=Video},
/* 74 */
/***/function(module,exports,__nested_webpack_require_405371__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.FormulaBlot=void 0;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_embed=__nested_webpack_require_405371__(35),_embed2=_interopRequireDefault(_embed),_quill=__nested_webpack_require_405371__(5),_quill2=_interopRequireDefault(_quill),_module=__nested_webpack_require_405371__(9),_module2=_interopRequireDefault(_module);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var FormulaBlot=function(_Embed){function FormulaBlot(){return _classCallCheck(this,FormulaBlot),_possibleConstructorReturn(this,(FormulaBlot.__proto__||Object.getPrototypeOf(FormulaBlot)).apply(this,arguments))}return _inherits(FormulaBlot,_Embed),_createClass(FormulaBlot,null,[{key:"create",value:function(value){var node=_get(FormulaBlot.__proto__||Object.getPrototypeOf(FormulaBlot),"create",this).call(this,value);return"string"===typeof value&&(window.katex.render(value,node,{throwOnError:!1,errorColor:"#f00"}),node.setAttribute("data-value",value)),node}},{key:"value",value:function(domNode){return domNode.getAttribute("data-value")}}]),FormulaBlot}(_embed2.default);FormulaBlot.blotName="formula",FormulaBlot.className="ql-formula",FormulaBlot.tagName="SPAN";var Formula=function(_Module){function Formula(){_classCallCheck(this,Formula);var _this2=_possibleConstructorReturn(this,(Formula.__proto__||Object.getPrototypeOf(Formula)).call(this));if(null==window.katex)throw new Error("Formula module requires KaTeX.");return _this2}return _inherits(Formula,_Module),_createClass(Formula,null,[{key:"register",value:function(){_quill2.default.register(FormulaBlot,!0)}}]),Formula}(_module2.default);exports.FormulaBlot=FormulaBlot,exports.default=Formula},
/* 75 */
/***/function(module,exports,__nested_webpack_require_409500__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.CodeToken=exports.CodeBlock=void 0;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_parchment=__nested_webpack_require_409500__(0),_parchment2=_interopRequireDefault(_parchment),_quill=__nested_webpack_require_409500__(5),_quill2=_interopRequireDefault(_quill),_module=__nested_webpack_require_409500__(9),_module2=_interopRequireDefault(_module),_code=__nested_webpack_require_409500__(13),_code2=_interopRequireDefault(_code);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var SyntaxCodeBlock=function(_CodeBlock){function SyntaxCodeBlock(){return _classCallCheck(this,SyntaxCodeBlock),_possibleConstructorReturn(this,(SyntaxCodeBlock.__proto__||Object.getPrototypeOf(SyntaxCodeBlock)).apply(this,arguments))}return _inherits(SyntaxCodeBlock,_CodeBlock),_createClass(SyntaxCodeBlock,[{key:"replaceWith",value:function(block){this.domNode.textContent=this.domNode.textContent,this.attach(),_get(SyntaxCodeBlock.prototype.__proto__||Object.getPrototypeOf(SyntaxCodeBlock.prototype),"replaceWith",this).call(this,block)}},{key:"highlight",value:function(_highlight){var text=this.domNode.textContent;this.cachedText!==text&&((text.trim().length>0||null==this.cachedText)&&(this.domNode.innerHTML=_highlight(text),this.domNode.normalize(),this.attach()),this.cachedText=text)}}]),SyntaxCodeBlock}(_code2.default);SyntaxCodeBlock.className="ql-syntax";var CodeToken=new _parchment2.default.Attributor.Class("token","hljs",{scope:_parchment2.default.Scope.INLINE}),Syntax=function(_Module){function Syntax(quill,options){_classCallCheck(this,Syntax);var _this2=_possibleConstructorReturn(this,(Syntax.__proto__||Object.getPrototypeOf(Syntax)).call(this,quill,options));if("function"!==typeof _this2.options.highlight)throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");var timer=null;return _this2.quill.on(_quill2.default.events.SCROLL_OPTIMIZE,(function(){clearTimeout(timer),timer=setTimeout((function(){_this2.highlight(),timer=null}),_this2.options.interval)})),_this2.highlight(),_this2}return _inherits(Syntax,_Module),_createClass(Syntax,null,[{key:"register",value:function(){_quill2.default.register(CodeToken,!0),_quill2.default.register(SyntaxCodeBlock,!0)}}]),_createClass(Syntax,[{key:"highlight",value:function(){var _this3=this;if(!this.quill.selection.composing){this.quill.update(_quill2.default.sources.USER);var range=this.quill.getSelection();this.quill.scroll.descendants(SyntaxCodeBlock).forEach((function(code){code.highlight(_this3.options.highlight)})),this.quill.update(_quill2.default.sources.SILENT),null!=range&&this.quill.setSelection(range,_quill2.default.sources.SILENT)}}}]),Syntax}(_module2.default);Syntax.DEFAULTS={highlight:function(){return null==window.hljs?null:function(text){var result=window.hljs.highlightAuto(text);return result.value}}(),interval:1e3},exports.CodeBlock=SyntaxCodeBlock,exports.CodeToken=CodeToken,exports.default=Syntax},
/* 76 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>';
/***/},
/* 77 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>';
/***/},
/* 78 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>';
/***/},
/* 79 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>';
/***/},
/* 80 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <g class="ql-fill ql-color-label"> <polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points="12 6.868 12 6 11.62 6 12 6.868"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points="5.5 13 9 5 12.5 13"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>';
/***/},
/* 81 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <rect class="ql-fill ql-stroke" height=3 width=3 x=4 y=5></rect> <rect class="ql-fill ql-stroke" height=3 width=3 x=11 y=5></rect> <path class="ql-even ql-fill ql-stroke" d=M7,8c0,4.031-3,5-3,5></path> <path class="ql-even ql-fill ql-stroke" d=M14,8c0,4.031-3,5-3,5></path> </svg>';
/***/},
/* 82 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>';
/***/},
/* 83 */
/***/function(module,exports){module.exports='<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>';
/***/},
/* 84 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <line class="ql-color-label ql-stroke ql-transparent" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points="5.5 11 9 3 12.5 11"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>';
/***/},
/* 85 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"></polygon> <line class="ql-stroke ql-fill" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>';
/***/},
/* 86 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"></polygon> <line class="ql-stroke ql-fill" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>';
/***/},
/* 87 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>';
/***/},
/* 88 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>';
/***/},
/* 89 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>';
/***/},
/* 90 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform="translate(24 18) rotate(-180)"/> </svg>';
/***/},
/* 91 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>';
/***/},
/* 92 */
/***/function(module,exports){module.exports='<svg viewBox="0 0 18 18"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>';
/***/},
/* 93 */
/***/function(module,exports){module.exports='<svg viewBox="0 0 18 18"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>';
/***/},
/* 94 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>';
/***/},
/* 95 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"></polyline> </svg>';
/***/},
/* 96 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"></polyline> </svg>';
/***/},
/* 97 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="5 7 5 11 3 9 5 7"></polyline> </svg>';
/***/},
/* 98 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class="ql-even ql-stroke" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class="ql-even ql-stroke" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>';
/***/},
/* 99 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class="ql-stroke ql-thin" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class="ql-stroke ql-thin" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class="ql-stroke ql-thin" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>';
/***/},
/* 100 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>';
/***/},
/* 101 */
/***/function(module,exports){module.exports='<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points="3 4 4 5 6 3"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points="3 14 4 15 6 13"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="3 9 4 10 6 8"></polyline> </svg>';
/***/},
/* 102 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>';
/***/},
/* 103 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>';
/***/},
/* 104 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <line class="ql-stroke ql-thin" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>';
/***/},
/* 105 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>';
/***/},
/* 106 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>';
/***/},
/* 107 */
/***/function(module,exports){module.exports='<svg viewbox="0 0 18 18"> <polygon class=ql-stroke points="7 11 9 13 11 11 7 11"></polygon> <polygon class=ql-stroke points="7 7 9 5 11 7 7 7"></polygon> </svg>';
/***/},
/* 108 */
/***/function(module,exports,__nested_webpack_require_432266__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.BubbleTooltip=void 0;var _get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;return void 0!==getter?getter.call(receiver):void 0},_createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_extend=__nested_webpack_require_432266__(3),_extend2=_interopRequireDefault(_extend),_emitter=__nested_webpack_require_432266__(8),_emitter2=_interopRequireDefault(_emitter),_base=__nested_webpack_require_432266__(43),_base2=_interopRequireDefault(_base),_selection=__nested_webpack_require_432266__(15),_icons=__nested_webpack_require_432266__(41),_icons2=_interopRequireDefault(_icons);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?self:call}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}var TOOLBAR_CONFIG=[["bold","italic","link"],[{header:1},{header:2},"blockquote"]],BubbleTheme=function(_BaseTheme){function BubbleTheme(quill,options){_classCallCheck(this,BubbleTheme),null!=options.modules.toolbar&&null==options.modules.toolbar.container&&(options.modules.toolbar.container=TOOLBAR_CONFIG);var _this=_possibleConstructorReturn(this,(BubbleTheme.__proto__||Object.getPrototypeOf(BubbleTheme)).call(this,quill,options));return _this.quill.container.classList.add("ql-bubble"),_this}return _inherits(BubbleTheme,_BaseTheme),_createClass(BubbleTheme,[{key:"extendToolbar",value:function(toolbar){this.tooltip=new BubbleTooltip(this.quill,this.options.bounds),this.tooltip.root.appendChild(toolbar.container),this.buildButtons([].slice.call(toolbar.container.querySelectorAll("button")),_icons2.default),this.buildPickers([].slice.call(toolbar.container.querySelectorAll("select")),_icons2.default)}}]),BubbleTheme}(_base2.default);BubbleTheme.DEFAULTS=(0,_extend2.default)(!0,{},_base2.default.DEFAULTS,{modules:{toolbar:{handlers:{link:function(value){value?this.quill.theme.tooltip.edit():this.quill.format("link",!1)}}}}});var BubbleTooltip=function(_BaseTooltip){function BubbleTooltip(quill,bounds){_classCallCheck(this,BubbleTooltip);var _this2=_possibleConstructorReturn(this,(BubbleTooltip.__proto__||Object.getPrototypeOf(BubbleTooltip)).call(this,quill,bounds));return _this2.quill.on(_emitter2.default.events.EDITOR_CHANGE,(function(type,range,oldRange,source){if(type===_emitter2.default.events.SELECTION_CHANGE)if(null!=range&&range.length>0&&source===_emitter2.default.sources.USER){_this2.show(),
// Lock our width so we will expand beyond our offsetParent boundaries
_this2.root.style.left="0px",_this2.root.style.width="",_this2.root.style.width=_this2.root.offsetWidth+"px";var lines=_this2.quill.getLines(range.index,range.length);if(1===lines.length)_this2.position(_this2.quill.getBounds(range));else{var lastLine=lines[lines.length-1],index=_this2.quill.getIndex(lastLine),length=Math.min(lastLine.length()-1,range.index+range.length-index),_bounds=_this2.quill.getBounds(new _selection.Range(index,length));_this2.position(_bounds)}}else document.activeElement!==_this2.textbox&&_this2.quill.hasFocus()&&_this2.hide()})),_this2}return _inherits(BubbleTooltip,_BaseTooltip),_createClass(BubbleTooltip,[{key:"listen",value:function(){var _this3=this;_get(BubbleTooltip.prototype.__proto__||Object.getPrototypeOf(BubbleTooltip.prototype),"listen",this).call(this),this.root.querySelector(".ql-close").addEventListener("click",(function(){_this3.root.classList.remove("ql-editing")})),this.quill.on(_emitter2.default.events.SCROLL_OPTIMIZE,(function(){
// Let selection be restored by toolbar handlers before repositioning
setTimeout((function(){if(!_this3.root.classList.contains("ql-hidden")){var range=_this3.quill.getSelection();null!=range&&_this3.position(_this3.quill.getBounds(range))}}),1)}))}},{key:"cancel",value:function(){this.show()}},{key:"position",value:function(reference){var shift=_get(BubbleTooltip.prototype.__proto__||Object.getPrototypeOf(BubbleTooltip.prototype),"position",this).call(this,reference),arrow=this.root.querySelector(".ql-tooltip-arrow");if(arrow.style.marginLeft="",0===shift)return shift;arrow.style.marginLeft=-1*shift-arrow.offsetWidth/2+"px"}}]),BubbleTooltip}(_base.BaseTooltip);BubbleTooltip.TEMPLATE=['<span class="ql-tooltip-arrow"></span>','<div class="ql-tooltip-editor">','<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">','<a class="ql-close"></a>',"</div>"].join(""),exports.BubbleTooltip=BubbleTooltip,exports.default=BubbleTheme},
/* 109 */
/***/function(module,exports,__nested_webpack_require_439588__){module.exports=__nested_webpack_require_439588__(63);
/***/}
/******/])["default"]}));
/***/},
/***/474737:
/***/function(module){"use strict";var rafThrottle=function(callback){var lastArgs,requestId=null,later=function(context){return function(){requestId=null,callback.apply(context,lastArgs)}},throttled=function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];lastArgs=args,null===requestId&&(requestId=requestAnimationFrame(later(this)))};return throttled.cancel=function(){cancelAnimationFrame(requestId),requestId=null},throttled};module.exports=rafThrottle},
/***/654087:
/***/function(module,__unused_webpack_exports,__webpack_require__){for(var now=__webpack_require__(75),root="undefined"===typeof window?__webpack_require__.g:window,vendors=["moz","webkit"],suffix="AnimationFrame",raf=root["request"+suffix],caf=root["cancel"+suffix]||root["cancelRequest"+suffix],i=0;!raf&&i<vendors.length;i++)raf=root[vendors[i]+"Request"+suffix],caf=root[vendors[i]+"Cancel"+suffix]||root[vendors[i]+"CancelRequest"+suffix];
// Some versions of FF have rAF but not cAF
if(!raf||!caf){var last=0,id=0,queue=[],frameDuration=1e3/60;raf=function(callback){if(0===queue.length){var _now=now(),next=Math.max(0,frameDuration-(_now-last));last=next+_now,setTimeout((function(){var cp=queue.slice(0);
// Clear queue here to prevent
// callbacks from appending listeners
// to the current frame's queue
queue.length=0;for(var i=0;i<cp.length;i++)if(!cp[i].cancelled)try{cp[i].callback(last)}catch(e){setTimeout((function(){throw e}),0)}}),Math.round(next))}return queue.push({handle:++id,callback:callback,cancelled:!1}),id},caf=function(handle){for(var i=0;i<queue.length;i++)queue[i].handle===handle&&(queue[i].cancelled=!0)}}module.exports=function(fn){
// Wrap in a new function to prevent
// `cancel` potentially being assigned
// to the native rAF function
return raf.call(root,fn)},module.exports.cancel=function(){caf.apply(root,arguments)},module.exports.polyfill=function(object){object||(object=root),object.requestAnimationFrame=raf,object.cancelAnimationFrame=caf}
/***/},
/***/925804:
/***/function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";
/* harmony export */__webpack_require__.d(__webpack_exports__,{
/* harmony export */Ig:function(){/* binding */return joinDown},
/* harmony export */MI:function(){/* binding */return joinUp},
/* harmony export */N0:function(){/* binding */return selectParentNode},
/* harmony export */NE:function(){/* binding */return deleteSelection},
/* harmony export */QK:function(){/* binding */return newlineInCode},
/* harmony export */U9:function(){/* binding */return selectTextblockStart},
/* harmony export */X0:function(){/* binding */return liftEmptyBlock},
/* harmony export */Y_:function(){/* binding */return joinForward},
/* harmony export */_M:function(){/* binding */return selectNodeBackward},
/* harmony export */al:function(){/* binding */return joinBackward},
/* harmony export */mD:function(){/* binding */return createParagraphNear},
/* harmony export */nw:function(){/* binding */return selectTextblockEnd},
/* harmony export */o:function(){/* binding */return selectNodeForward},
/* harmony export */uJ:function(){/* binding */return setBlockType},
/* harmony export */uo:function(){/* binding */return exitCode},
/* harmony export */xb:function(){/* binding */return lift},
/* harmony export */ym:function(){/* binding */return wrapIn}
/* harmony export */});
/* unused harmony exports autoJoin, baseKeymap, chainCommands, joinTextblockBackward, joinTextblockForward, macBaseKeymap, pcBaseKeymap, selectAll, splitBlock, splitBlockAs, splitBlockKeepMarks, toggleMark */
/* harmony import */var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(616560),prosemirror_model__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(759084),prosemirror_state__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(102376);
/* harmony import */
/**
Delete the selection, if there is one.
*/
const deleteSelection=(state,dispatch)=>!state.selection.empty&&(dispatch&&dispatch(state.tr.deleteSelection().scrollIntoView()),!0);function atBlockStart(state,view){let{$cursor:$cursor}=state.selection;return!$cursor||(view?!view.endOfTextblock("backward",state):$cursor.parentOffset>0)?null:$cursor}
/**
If the selection is empty and at the start of a textblock, try to
reduce the distance between that block and the one before it—if
there's a block directly before it that can be joined, join them.
If not, try to move the selected block closer to the next one in
the document structure by lifting it out of its parent or moving it
into a parent of the previous block. Will use the view for accurate
(bidi-aware) start-of-textblock detection if given.
*/const joinBackward=(state,dispatch,view)=>{let $cursor=atBlockStart(state,view);if(!$cursor)return!1;let $cut=findCutBefore($cursor);
// If there is no node before this, try to lift
if(!$cut){let range=$cursor.blockRange(),target=range&&(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .liftTarget */.k9)(range);return null!=target&&(dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0)}let before=$cut.nodeBefore;
// Apply the joining algorithm
if(!before.type.spec.isolating&&deleteBarrier(state,$cut,dispatch))return!0;
// If the node below has no content and the node above is
// selectable, delete the node below and select the one above.
if(0==$cursor.parent.content.size&&(textblockAt(before,"end")||prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.isSelectable(before))){let delStep=(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .replaceStep */.dR)(state.doc,$cursor.before(),$cursor.after(),prosemirror_model__WEBPACK_IMPORTED_MODULE_2__/* .Slice */.p2.empty);if(delStep&&delStep.slice.size<delStep.to-delStep.from){if(dispatch){let tr=state.tr.step(delStep);tr.setSelection(textblockAt(before,"end")?prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .Selection */.Y1.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos,-1)),-1):prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.create(tr.doc,$cut.pos-before.nodeSize)),dispatch(tr.scrollIntoView())}return!0}}
// If the node before is an atom, delete it
return!(!before.isAtom||$cut.depth!=$cursor.depth-1)&&(dispatch&&dispatch(state.tr.delete($cut.pos-before.nodeSize,$cut.pos).scrollIntoView()),!0)};
/**
A more limited form of [`joinBackward`]($commands.joinBackward)
that only tries to join the current textblock to the one before
it, if the cursor is at the start of a textblock.
*/function textblockAt(node,side,only=!1){for(let scan=node;scan;scan="start"==side?scan.firstChild:scan.lastChild){if(scan.isTextblock)return!0;if(only&&1!=scan.childCount)return!1}return!1}
/**
When the selection is empty and at the start of a textblock, select
the node before that textblock, if possible. This is intended to be
bound to keys like backspace, after
[`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward) or other deleting
commands, as a fall-back behavior when the schema doesn't allow
deletion at the selected point.
*/const selectNodeBackward=(state,dispatch,view)=>{let{$head:$head,empty:empty}=state.selection,$cut=$head;if(!empty)return!1;if($head.parent.isTextblock){if(view?!view.endOfTextblock("backward",state):$head.parentOffset>0)return!1;$cut=findCutBefore($head)}let node=$cut&&$cut.nodeBefore;return!(!node||!prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.isSelectable(node))&&(dispatch&&dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.create(state.doc,$cut.pos-node.nodeSize)).scrollIntoView()),!0)};function findCutBefore($pos){if(!$pos.parent.type.spec.isolating)for(let i=$pos.depth-1;i>=0;i--){if($pos.index(i)>0)return $pos.doc.resolve($pos.before(i+1));if($pos.node(i).type.spec.isolating)break}return null}function atBlockEnd(state,view){let{$cursor:$cursor}=state.selection;return!$cursor||(view?!view.endOfTextblock("forward",state):$cursor.parentOffset<$cursor.parent.content.size)?null:$cursor}
/**
If the selection is empty and the cursor is at the end of a
textblock, try to reduce or remove the boundary between that block
and the one after it, either by joining them or by moving the other
block closer to this one in the tree structure. Will use the view
for accurate start-of-textblock detection if given.
*/const joinForward=(state,dispatch,view)=>{let $cursor=atBlockEnd(state,view);if(!$cursor)return!1;let $cut=findCutAfter($cursor);
// If there is no node after this, there's nothing to do
if(!$cut)return!1;let after=$cut.nodeAfter;
// Try the joining algorithm
if(deleteBarrier(state,$cut,dispatch))return!0;
// If the node above has no content and the node below is
// selectable, delete the node above and select the one below.
if(0==$cursor.parent.content.size&&(textblockAt(after,"start")||prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.isSelectable(after))){let delStep=(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .replaceStep */.dR)(state.doc,$cursor.before(),$cursor.after(),prosemirror_model__WEBPACK_IMPORTED_MODULE_2__/* .Slice */.p2.empty);if(delStep&&delStep.slice.size<delStep.to-delStep.from){if(dispatch){let tr=state.tr.step(delStep);tr.setSelection(textblockAt(after,"start")?prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .Selection */.Y1.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)),1):prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.create(tr.doc,tr.mapping.map($cut.pos))),dispatch(tr.scrollIntoView())}return!0}}
// If the next node is an atom, delete it
return!(!after.isAtom||$cut.depth!=$cursor.depth-1)&&(dispatch&&dispatch(state.tr.delete($cut.pos,$cut.pos+after.nodeSize).scrollIntoView()),!0)},selectNodeForward=(state,dispatch,view)=>{let{$head:$head,empty:empty}=state.selection,$cut=$head;if(!empty)return!1;if($head.parent.isTextblock){if(view?!view.endOfTextblock("forward",state):$head.parentOffset<$head.parent.content.size)return!1;$cut=findCutAfter($head)}let node=$cut&&$cut.nodeAfter;return!(!node||!prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.isSelectable(node))&&(dispatch&&dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.create(state.doc,$cut.pos)).scrollIntoView()),!0)};
/**
When the selection is empty and at the end of a textblock, select
the node coming after that textblock, if possible. This is intended
to be bound to keys like delete, after
[`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward) and similar deleting
commands, to provide a fall-back behavior when the schema doesn't
allow deletion at the selected point.
*/function findCutAfter($pos){if(!$pos.parent.type.spec.isolating)for(let i=$pos.depth-1;i>=0;i--){let parent=$pos.node(i);if($pos.index(i)+1<parent.childCount)return $pos.doc.resolve($pos.after(i+1));if(parent.type.spec.isolating)break}return null}
/**
Join the selected block or, if there is a text selection, the
closest ancestor block of the selection that can be joined, with
the sibling above it.
*/const joinUp=(state,dispatch)=>{let point,sel=state.selection,nodeSel=sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv;if(nodeSel){if(sel.node.isTextblock||!(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .canJoin */.Mn)(state.doc,sel.from))return!1;point=sel.from}else if(point=(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .joinPoint */.GJ)(state.doc,sel.from,-1),null==point)return!1;if(dispatch){let tr=state.tr.join(point);nodeSel&&tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.create(tr.doc,point-state.doc.resolve(point).nodeBefore.nodeSize)),dispatch(tr.scrollIntoView())}return!0},joinDown=(state,dispatch)=>{let point,sel=state.selection;if(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv){if(sel.node.isTextblock||!(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .canJoin */.Mn)(state.doc,sel.to))return!1;point=sel.to}else if(point=(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .joinPoint */.GJ)(state.doc,sel.to,1),null==point)return!1;return dispatch&&dispatch(state.tr.join(point).scrollIntoView()),!0},lift=(state,dispatch)=>{let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to),target=range&&(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .liftTarget */.k9)(range);return null!=target&&(dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0)},newlineInCode=(state,dispatch)=>{let{$head:$head,$anchor:$anchor}=state.selection;return!(!$head.parent.type.spec.code||!$head.sameParent($anchor))&&(dispatch&&dispatch(state.tr.insertText("\n").scrollIntoView()),!0)};
/**
Join the selected block, or the closest ancestor of the selection
that can be joined, with the sibling after it.
*/function defaultBlockAt(match){for(let i=0;i<match.edgeCount;i++){let{type:type}=match.edge(i);if(type.isTextblock&&!type.hasRequiredAttrs())return type}return null}
/**
When the selection is in a node with a truthy
[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, create a
default block after the code block, and move the cursor there.
*/const exitCode=(state,dispatch)=>{let{$head:$head,$anchor:$anchor}=state.selection;if(!$head.parent.type.spec.code||!$head.sameParent($anchor))return!1;let above=$head.node(-1),after=$head.indexAfter(-1),type=defaultBlockAt(above.contentMatchAt(after));if(!type||!above.canReplaceWith(after,after,type))return!1;if(dispatch){let pos=$head.after(),tr=state.tr.replaceWith(pos,pos,type.createAndFill());tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .Selection */.Y1.near(tr.doc.resolve(pos),1)),dispatch(tr.scrollIntoView())}return!0},createParagraphNear=(state,dispatch)=>{let sel=state.selection,{$from:$from,$to:$to}=sel;if(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .AllSelection */.C1||$from.parent.inlineContent||$to.parent.inlineContent)return!1;let type=defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));if(!type||!type.isTextblock)return!1;if(dispatch){let side=(!$from.parentOffset&&$to.index()<$to.parent.childCount?$from:$to).pos,tr=state.tr.insert(side,type.createAndFill());tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .TextSelection */.Bs.create(tr.doc,side+1)),dispatch(tr.scrollIntoView())}return!0},liftEmptyBlock=(state,dispatch)=>{let{$cursor:$cursor}=state.selection;if(!$cursor||$cursor.parent.content.size)return!1;if($cursor.depth>1&&$cursor.after()!=$cursor.end(-1)){let before=$cursor.before();if((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .canSplit */.Ax)(state.doc,before))return dispatch&&dispatch(state.tr.split(before).scrollIntoView()),!0}let range=$cursor.blockRange(),target=range&&(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .liftTarget */.k9)(range);return null!=target&&(dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0)};
/**
If a block node is selected, create an empty paragraph before (if
it is its parent's first child) or after it.
*/
/**
Create a variant of [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock) that uses
a custom function to determine the type of the newly split off block.
*/
function splitBlockAs(splitNode){return(state,dispatch)=>{let{$from:$from,$to:$to}=state.selection;if(state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv&&state.selection.node.isBlock)return!(!$from.parentOffset||!(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .canSplit */.Ax)(state.doc,$from.pos))&&(dispatch&&dispatch(state.tr.split($from.pos).scrollIntoView()),!0);if(!$from.parent.isBlock)return!1;if(dispatch){let atEnd=$to.parentOffset==$to.parent.content.size,tr=state.tr;(state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .TextSelection */.Bs||state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .AllSelection */.C1)&&tr.deleteSelection();let deflt=0==$from.depth?null:defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1))),splitType=splitNode&&splitNode($to.parent,atEnd),types=splitType?[splitType]:atEnd&&deflt?[{type:deflt}]:void 0,can=(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .canSplit */.Ax)(tr.doc,tr.mapping.map($from.pos),1,types);if(types||can||!(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .canSplit */.Ax)(tr.doc,tr.mapping.map($from.pos),1,deflt?[{type:deflt}]:void 0)||(deflt&&(types=[{type:deflt}]),can=!0),can&&(tr.split(tr.mapping.map($from.pos),1,types),!atEnd&&!$from.parentOffset&&$from.parent.type!=deflt)){let first=tr.mapping.map($from.before()),$first=tr.doc.resolve(first);deflt&&$from.node(-1).canReplaceWith($first.index(),$first.index()+1,deflt)&&tr.setNodeMarkup(tr.mapping.map($from.before()),deflt)}dispatch(tr.scrollIntoView())}return!0}}
/**
Split the parent block of the selection. If the selection is a text
selection, also delete its content.
*/const splitBlock=splitBlockAs(),selectParentNode=(state,dispatch)=>{let pos,{$from:$from,to:to}=state.selection,same=$from.sharedDepth(to);return 0!=same&&(pos=$from.before(same),dispatch&&dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.create(state.doc,pos))),!0)},selectAll=(state,dispatch)=>(dispatch&&dispatch(state.tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .AllSelection */.C1(state.doc))),!0);
/**
Acts like [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock), but without
resetting the set of active marks at the cursor.
*/function joinMaybeClear(state,$pos,dispatch){let before=$pos.nodeBefore,after=$pos.nodeAfter,index=$pos.index();return!!(before&&after&&before.type.compatibleContent(after.type))&&(!before.content.size&&$pos.parent.canReplace(index-1,index)?(dispatch&&dispatch(state.tr.delete($pos.pos-before.nodeSize,$pos.pos).scrollIntoView()),!0):!(!$pos.parent.canReplace(index,index+1)||!after.isTextblock&&!(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .canJoin */.Mn)(state.doc,$pos.pos))&&(dispatch&&dispatch(state.tr.clearIncompatible($pos.pos,before.type,before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView()),!0))}function deleteBarrier(state,$cut,dispatch){let conn,match,before=$cut.nodeBefore,after=$cut.nodeAfter;if(before.type.spec.isolating||after.type.spec.isolating)return!1;if(joinMaybeClear(state,$cut,dispatch))return!0;let canDelAfter=$cut.parent.canReplace($cut.index(),$cut.index()+1);if(canDelAfter&&(conn=(match=before.contentMatchAt(before.childCount)).findWrapping(after.type))&&match.matchType(conn[0]||after.type).validEnd){if(dispatch){let end=$cut.pos+after.nodeSize,wrap=prosemirror_model__WEBPACK_IMPORTED_MODULE_2__/* .Fragment */.HY.empty;for(let i=conn.length-1;i>=0;i--)wrap=prosemirror_model__WEBPACK_IMPORTED_MODULE_2__/* .Fragment */.HY.from(conn[i].create(null,wrap));wrap=prosemirror_model__WEBPACK_IMPORTED_MODULE_2__/* .Fragment */.HY.from(before.copy(wrap));let tr=state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .ReplaceAroundStep */.FC($cut.pos-1,end,$cut.pos,end,new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__/* .Slice */.p2(wrap,1,0),conn.length,!0)),joinAt=end+2*conn.length;(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .canJoin */.Mn)(tr.doc,joinAt)&&tr.join(joinAt),dispatch(tr.scrollIntoView())}return!0}let selAfter=prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .Selection */.Y1.findFrom($cut,1),range=selAfter&&selAfter.$from.blockRange(selAfter.$to),target=range&&(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .liftTarget */.k9)(range);if(null!=target&&target>=$cut.depth)return dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0;if(canDelAfter&&textblockAt(after,"start",!0)&&textblockAt(before,"end")){let at=before,wrap=[];for(;;){if(wrap.push(at),at.isTextblock)break;at=at.lastChild}let afterText=after,afterDepth=1;for(;!afterText.isTextblock;afterText=afterText.firstChild)afterDepth++;if(at.canReplace(at.childCount,at.childCount,afterText.content)){if(dispatch){let end=prosemirror_model__WEBPACK_IMPORTED_MODULE_2__/* .Fragment */.HY.empty;for(let i=wrap.length-1;i>=0;i--)end=prosemirror_model__WEBPACK_IMPORTED_MODULE_2__/* .Fragment */.HY.from(wrap[i].copy(end));let tr=state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .ReplaceAroundStep */.FC($cut.pos-wrap.length,$cut.pos+after.nodeSize,$cut.pos+afterDepth,$cut.pos+after.nodeSize-afterDepth,new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__/* .Slice */.p2(end,wrap.length,0),0,!0));dispatch(tr.scrollIntoView())}return!0}}return!1}function selectTextblockSide(side){return function(state,dispatch){let sel=state.selection,$pos=side<0?sel.$from:sel.$to,depth=$pos.depth;while($pos.node(depth).isInline){if(!depth)return!1;depth--}return!!$pos.node(depth).isTextblock&&(dispatch&&dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .TextSelection */.Bs.create(state.doc,side<0?$pos.start(depth):$pos.end(depth)))),!0)}}
/**
Moves the cursor to the start of current text block.
*/const selectTextblockStart=selectTextblockSide(-1),selectTextblockEnd=selectTextblockSide(1);
/**
Moves the cursor to the end of current text block.
*/
// Parameterized commands
/**
Wrap the selection in a node of the given type with the given
attributes.
*/
function wrapIn(nodeType,attrs=null){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to),wrapping=range&&(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__/* .findWrapping */.nd)(range,nodeType,attrs);return!!wrapping&&(dispatch&&dispatch(state.tr.wrap(range,wrapping).scrollIntoView()),!0)}}
/**
Returns a command that tries to set the selected textblocks to the
given node type with the given attributes.
*/function setBlockType(nodeType,attrs=null){return function(state,dispatch){let applicable=!1;for(let i=0;i<state.selection.ranges.length&&!applicable;i++){let{$from:{pos:from},$to:{pos:to}}=state.selection.ranges[i];state.doc.nodesBetween(from,to,((node,pos)=>{if(applicable)return!1;if(node.isTextblock&&!node.hasMarkup(nodeType,attrs))if(node.type==nodeType)applicable=!0;else{let $pos=state.doc.resolve(pos),index=$pos.index();applicable=$pos.parent.canReplaceWith(index,index+1,nodeType)}}))}if(!applicable)return!1;if(dispatch){let tr=state.tr;for(let i=0;i<state.selection.ranges.length;i++){let{$from:{pos:from},$to:{pos:to}}=state.selection.ranges[i];tr.setBlockType(from,to,nodeType,attrs)}dispatch(tr.scrollIntoView())}return!0}}
/**
Combine a number of command functions into a single function (which
calls them one by one until one returns true).
*/
function chainCommands(...commands){return function(state,dispatch,view){for(let i=0;i<commands.length;i++)if(commands[i](state,dispatch,view))return!0;return!1}}let backspace=chainCommands(deleteSelection,joinBackward,selectNodeBackward),del=chainCommands(deleteSelection,joinForward,selectNodeForward);
/**
A basic keymap containing bindings not specific to any schema.
Binds the following keys (when multiple commands are listed, they
are chained with [`chainCommands`](https://prosemirror.net/docs/ref/#commands.chainCommands)):

* **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`
* **Mod-Enter** to `exitCode`
* **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`
* **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`
* **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`
* **Mod-a** to `selectAll`
*/
const pcBaseKeymap={Enter:chainCommands(newlineInCode,createParagraphNear,liftEmptyBlock,splitBlock),"Mod-Enter":exitCode,Backspace:backspace,"Mod-Backspace":backspace,"Shift-Backspace":backspace,Delete:del,"Mod-Delete":del,"Mod-a":selectAll},macBaseKeymap={"Ctrl-h":pcBaseKeymap["Backspace"],"Alt-Backspace":pcBaseKeymap["Mod-Backspace"],"Ctrl-d":pcBaseKeymap["Delete"],"Ctrl-Alt-Backspace":pcBaseKeymap["Mod-Delete"],"Alt-Delete":pcBaseKeymap["Mod-Delete"],"Alt-d":pcBaseKeymap["Mod-Delete"],"Ctrl-a":selectTextblockStart,"Ctrl-e":selectTextblockEnd};
/**
A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,
**Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and
**Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like
Ctrl-Delete.
*/for(let key in pcBaseKeymap)macBaseKeymap[key]=pcBaseKeymap[key];"undefined"!=typeof navigator?/Mac|iP(hone|[oa]d)/.test(navigator.platform):!("undefined"==typeof os||!os.platform)&&os.platform();
/**
Depending on the detected platform, this will hold
[`pcBasekeymap`](https://prosemirror.net/docs/ref/#commands.pcBaseKeymap) or
[`macBaseKeymap`](https://prosemirror.net/docs/ref/#commands.macBaseKeymap).
*/},
/***/124251:
/***/function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";
/* harmony export */__webpack_require__.d(__webpack_exports__,{
/* harmony export */q:function(){/* binding */return dropCursor}
/* harmony export */});
/* harmony import */var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(102376),prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(616560);
/* harmony import */
/**
Create a plugin that, when added to a ProseMirror instance,
causes a decoration to show up at the drop position when something
is dragged over the editor.

Nodes may add a `disableDropCursor` property to their spec to
control the showing of a drop cursor inside them. This may be a
boolean or a function, which will be called with a view and a
position, and should return a boolean.
*/
function dropCursor(options={}){return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .Plugin */.Sy({view(editorView){return new DropCursorView(editorView,options)}})}class DropCursorView{constructor(editorView,options){var _a;this.editorView=editorView,this.cursorPos=null,this.element=null,this.timeout=-1,this.width=null!==(_a=options.width)&&void 0!==_a?_a:1,this.color=!1===options.color?void 0:options.color||"black",this.class=options.class,this.handlers=["dragover","dragend","drop","dragleave"].map((name=>{let handler=e=>{this[name](e)};return editorView.dom.addEventListener(name,handler),{name:name,handler:handler}}))}destroy(){this.handlers.forEach((({name:name,handler:handler})=>this.editorView.dom.removeEventListener(name,handler)))}update(editorView,prevState){null!=this.cursorPos&&prevState.doc!=editorView.state.doc&&(this.cursorPos>editorView.state.doc.content.size?this.setCursor(null):this.updateOverlay())}setCursor(pos){pos!=this.cursorPos&&(this.cursorPos=pos,null==pos?(this.element.parentNode.removeChild(this.element),this.element=null):this.updateOverlay())}updateOverlay(){let rect,$pos=this.editorView.state.doc.resolve(this.cursorPos),isBlock=!$pos.parent.inlineContent;if(isBlock){let before=$pos.nodeBefore,after=$pos.nodeAfter;if(before||after){let node=this.editorView.nodeDOM(this.cursorPos-(before?before.nodeSize:0));if(node){let nodeRect=node.getBoundingClientRect(),top=before?nodeRect.bottom:nodeRect.top;before&&after&&(top=(top+this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top)/2),rect={left:nodeRect.left,right:nodeRect.right,top:top-this.width/2,bottom:top+this.width/2}}}}if(!rect){let coords=this.editorView.coordsAtPos(this.cursorPos);rect={left:coords.left-this.width/2,right:coords.left+this.width/2,top:coords.top,bottom:coords.bottom}}let parentLeft,parentTop,parent=this.editorView.dom.offsetParent;if(this.element||(this.element=parent.appendChild(document.createElement("div")),this.class&&(this.element.className=this.class),this.element.style.cssText="position: absolute; z-index: 50; pointer-events: none;",this.color&&(this.element.style.backgroundColor=this.color)),this.element.classList.toggle("prosemirror-dropcursor-block",isBlock),this.element.classList.toggle("prosemirror-dropcursor-inline",!isBlock),!parent||parent==document.body&&"static"==getComputedStyle(parent).position)parentLeft=-pageXOffset,parentTop=-pageYOffset;else{let rect=parent.getBoundingClientRect();parentLeft=rect.left-parent.scrollLeft,parentTop=rect.top-parent.scrollTop}this.element.style.left=rect.left-parentLeft+"px",this.element.style.top=rect.top-parentTop+"px",this.element.style.width=rect.right-rect.left+"px",this.element.style.height=rect.bottom-rect.top+"px"}scheduleRemoval(timeout){clearTimeout(this.timeout),this.timeout=setTimeout((()=>this.setCursor(null)),timeout)}dragover(event){if(!this.editorView.editable)return;let pos=this.editorView.posAtCoords({left:event.clientX,top:event.clientY}),node=pos&&pos.inside>=0&&this.editorView.state.doc.nodeAt(pos.inside),disableDropCursor=node&&node.type.spec.disableDropCursor,disabled="function"==typeof disableDropCursor?disableDropCursor(this.editorView,pos,event):disableDropCursor;if(pos&&!disabled){let target=pos.pos;if(this.editorView.dragging&&this.editorView.dragging.slice){let point=(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__/* .dropPoint */.nj)(this.editorView.state.doc,target,this.editorView.dragging.slice);null!=point&&(target=point)}this.setCursor(target),this.scheduleRemoval(5e3)}}dragend(){this.scheduleRemoval(20)}drop(){this.scheduleRemoval(20)}dragleave(event){event.target!=this.editorView.dom&&this.editorView.dom.contains(event.relatedTarget)||this.setCursor(null)}}
/***/},
/***/950915:
/***/function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";
/* harmony export */__webpack_require__.d(__webpack_exports__,{
/* harmony export */d:function(){/* binding */return gapCursor}
/* harmony export */});
/* unused harmony export GapCursor */
/* harmony import */var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(560440),prosemirror_state__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(102376),prosemirror_model__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(759084),prosemirror_view__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(484348);
/* harmony import */
/**
Gap cursor selections are represented using this class. Its
`$anchor` and `$head` properties both point at the cursor position.
*/
class GapCursor extends prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .Selection */.Y1{
/**
    Create a gap cursor.
    */
constructor($pos){super($pos,$pos)}map(doc,mapping){let $pos=doc.resolve(mapping.map(this.head));return GapCursor.valid($pos)?new GapCursor($pos):prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .Selection */.Y1.near($pos)}content(){return prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Slice */.p2.empty}eq(other){return other instanceof GapCursor&&other.head==this.head}toJSON(){return{type:"gapcursor",pos:this.head}}
/**
    @internal
    */static fromJSON(doc,json){if("number"!=typeof json.pos)throw new RangeError("Invalid input for GapCursor.fromJSON");return new GapCursor(doc.resolve(json.pos))}
/**
    @internal
    */getBookmark(){return new GapBookmark(this.anchor)}
/**
    @internal
    */static valid($pos){let parent=$pos.parent;if(parent.isTextblock||!closedBefore($pos)||!closedAfter($pos))return!1;let override=parent.type.spec.allowGapCursor;if(null!=override)return override;let deflt=parent.contentMatchAt($pos.index()).defaultType;return deflt&&deflt.isTextblock}
/**
    @internal
    */static findGapCursorFrom($pos,dir,mustMove=!1){search:for(;;){if(!mustMove&&GapCursor.valid($pos))return $pos;let pos=$pos.pos,next=null;
// Scan up from this position
for(let d=$pos.depth;;d--){let parent=$pos.node(d);if(dir>0?$pos.indexAfter(d)<parent.childCount:$pos.index(d)>0){next=parent.child(dir>0?$pos.indexAfter(d):$pos.index(d)-1);break}if(0==d)return null;pos+=dir;let $cur=$pos.doc.resolve(pos);if(GapCursor.valid($cur))return $cur}
// And then down into the next node
for(;;){let inside=dir>0?next.firstChild:next.lastChild;if(!inside){if(next.isAtom&&!next.isText&&!prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .NodeSelection */.qv.isSelectable(next)){$pos=$pos.doc.resolve(pos+next.nodeSize*dir),mustMove=!1;continue search}break}next=inside,pos+=dir;let $cur=$pos.doc.resolve(pos);if(GapCursor.valid($cur))return $cur}return null}}}GapCursor.prototype.visible=!1,GapCursor.findFrom=GapCursor.findGapCursorFrom,prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .Selection */.Y1.jsonID("gapcursor",GapCursor);class GapBookmark{constructor(pos){this.pos=pos}map(mapping){return new GapBookmark(mapping.map(this.pos))}resolve(doc){let $pos=doc.resolve(this.pos);return GapCursor.valid($pos)?new GapCursor($pos):prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .Selection */.Y1.near($pos)}}function closedBefore($pos){for(let d=$pos.depth;d>=0;d--){let index=$pos.index(d),parent=$pos.node(d);
// At the start of this parent, look at next one
if(0!=index)
// See if the node before (or its first ancestor) is closed
for(let before=parent.child(index-1);;before=before.lastChild){if(0==before.childCount&&!before.inlineContent||before.isAtom||before.type.spec.isolating)return!0;if(before.inlineContent)return!1}else if(parent.type.spec.isolating)return!0}
// Hit start of document
return!0}function closedAfter($pos){for(let d=$pos.depth;d>=0;d--){let index=$pos.indexAfter(d),parent=$pos.node(d);if(index!=parent.childCount)for(let after=parent.child(index);;after=after.firstChild){if(0==after.childCount&&!after.inlineContent||after.isAtom||after.type.spec.isolating)return!0;if(after.inlineContent)return!1}else if(parent.type.spec.isolating)return!0}return!0}
/**
Create a gap cursor plugin. When enabled, this will capture clicks
near and arrow-key-motion past places that don't have a normally
selectable position nearby, and create a gap cursor selection for
them. The cursor is drawn as an element with class
`ProseMirror-gapcursor`. You can either include
`style/gapcursor.css` from the package's directory or add your own
styles to make it visible.
*/function gapCursor(){return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .Plugin */.Sy({props:{decorations:drawGapCursor,createSelectionBetween(_view,$anchor,$head){return $anchor.pos==$head.pos&&GapCursor.valid($head)?new GapCursor($head):null},handleClick:handleClick,handleKeyDown:handleKeyDown,handleDOMEvents:{beforeinput:beforeinput}}})}const handleKeyDown=(0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__/* .keydownHandler */.$)({ArrowLeft:arrow("horiz",-1),ArrowRight:arrow("horiz",1),ArrowUp:arrow("vert",-1),ArrowDown:arrow("vert",1)});function arrow(axis,dir){const dirStr="vert"==axis?dir>0?"down":"up":dir>0?"right":"left";return function(state,dispatch,view){let sel=state.selection,$start=dir>0?sel.$to:sel.$from,mustMove=sel.empty;if(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .TextSelection */.Bs){if(!view.endOfTextblock(dirStr)||0==$start.depth)return!1;mustMove=!1,$start=state.doc.resolve(dir>0?$start.after():$start.before())}let $found=GapCursor.findGapCursorFrom($start,dir,mustMove);return!!$found&&(dispatch&&dispatch(state.tr.setSelection(new GapCursor($found))),!0)}}function handleClick(view,pos,event){if(!view||!view.editable)return!1;let $pos=view.state.doc.resolve(pos);if(!GapCursor.valid($pos))return!1;let clickPos=view.posAtCoords({left:event.clientX,top:event.clientY});return!(clickPos&&clickPos.inside>-1&&prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .NodeSelection */.qv.isSelectable(view.state.doc.nodeAt(clickPos.inside)))&&(view.dispatch(view.state.tr.setSelection(new GapCursor($pos))),!0)}
// This is a hack that, when a composition starts while a gap cursor
// is active, quickly creates an inline context for the composition to
// happen in, to avoid it being aborted by the DOM selection being
// moved into a valid position.
function beforeinput(view,event){if("insertCompositionText"!=event.inputType||!(view.state.selection instanceof GapCursor))return!1;let{$from:$from}=view.state.selection,insert=$from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);if(!insert)return!1;let frag=prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Fragment */.HY.empty;for(let i=insert.length-1;i>=0;i--)frag=prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Fragment */.HY.from(insert[i].createAndFill(null,frag));let tr=view.state.tr.replace($from.pos,$from.pos,new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Slice */.p2(frag,0,0));return tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .TextSelection */.Bs.near(tr.doc.resolve($from.pos+1))),view.dispatch(tr),!1}function drawGapCursor(state){if(!(state.selection instanceof GapCursor))return null;let node=document.createElement("div");return node.className="ProseMirror-gapcursor",prosemirror_view__WEBPACK_IMPORTED_MODULE_3__/* .DecorationSet */.EH.create(state.doc,[prosemirror_view__WEBPACK_IMPORTED_MODULE_3__/* .Decoration */.p.widget(state.selection.head,node,{key:"gapcursor"})])}
/***/},
/***/779717:
/***/function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";
/* harmony export */__webpack_require__.d(__webpack_exports__,{
/* harmony export */KX:function(){/* binding */return redo},
/* harmony export */Yw:function(){/* binding */return undo},
/* harmony export */m8:function(){/* binding */return history}
/* harmony export */});
/* unused harmony exports closeHistory, redoDepth, undoDepth */
/* harmony import */var rope_sequence__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(145879),prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(616560),prosemirror_state__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(102376);
/* harmony import */
// ProseMirror's history isn't simply a way to roll back to a previous
// state, because ProseMirror supports applying changes without adding
// them to the history (for example during collaboration).
// To this end, each 'Branch' (one for the undo history and one for
// the redo history) keeps an array of 'Items', which can optionally
// hold a step (an actual undoable change), and always hold a position
// map (which is needed to move changes below them to apply to the
// current document).
// An item that has both a step and a selection bookmark is the start
// of an 'event' — a group of changes that will be undone or redone at
// once. (It stores only the bookmark, since that way we don't have to
// provide a document until the selection is actually applied, which
// is useful when compressing.)
// Used to schedule history compression
const max_empty_items=500;class Branch{constructor(items,eventCount){this.items=items,this.eventCount=eventCount}
// Pop the latest event off the branch's history and apply it
// to a document transform.
popEvent(state,preserveItems){if(0==this.eventCount)return null;let remap,mapFrom,end=this.items.length;for(;;end--){let next=this.items.get(end-1);if(next.selection){--end;break}}preserveItems&&(remap=this.remapping(end,this.items.length),mapFrom=remap.maps.length);let selection,remaining,transform=state.tr,addAfter=[],addBefore=[];return this.items.forEach(((item,i)=>{if(!item.step)return remap||(remap=this.remapping(end,i+1),mapFrom=remap.maps.length),mapFrom--,void addBefore.push(item);if(remap){addBefore.push(new Item(item.map));let map,step=item.step.map(remap.slice(mapFrom));step&&transform.maybeStep(step).doc&&(map=transform.mapping.maps[transform.mapping.maps.length-1],addAfter.push(new Item(map,void 0,void 0,addAfter.length+addBefore.length))),mapFrom--,map&&remap.appendMap(map,mapFrom)}else transform.maybeStep(item.step);return item.selection?(selection=remap?item.selection.map(remap.slice(mapFrom)):item.selection,remaining=new Branch(this.items.slice(0,end).append(addBefore.reverse().concat(addAfter)),this.eventCount-1),!1):void 0}),this.items.length,0),{remaining:remaining,transform:transform,selection:selection}}
// Create a new branch with the given transform added.
addTransform(transform,selection,histOptions,preserveItems){let newItems=[],eventCount=this.eventCount,oldItems=this.items,lastItem=!preserveItems&&oldItems.length?oldItems.get(oldItems.length-1):null;for(let i=0;i<transform.steps.length;i++){let merged,step=transform.steps[i].invert(transform.docs[i]),item=new Item(transform.mapping.maps[i],step,selection);(merged=lastItem&&lastItem.merge(item))&&(item=merged,i?newItems.pop():oldItems=oldItems.slice(0,oldItems.length-1)),newItems.push(item),selection&&(eventCount++,selection=void 0),preserveItems||(lastItem=item)}let overflow=eventCount-histOptions.depth;return overflow>DEPTH_OVERFLOW&&(oldItems=cutOffEvents(oldItems,overflow),eventCount-=overflow),new Branch(oldItems.append(newItems),eventCount)}remapping(from,to){let maps=new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__/* .Mapping */.vs;return this.items.forEach(((item,i)=>{let mirrorPos=null!=item.mirrorOffset&&i-item.mirrorOffset>=from?maps.maps.length-item.mirrorOffset:void 0;maps.appendMap(item.map,mirrorPos)}),from,to),maps}addMaps(array){return 0==this.eventCount?this:new Branch(this.items.append(array.map((map=>new Item(map)))),this.eventCount)}
// When the collab module receives remote changes, the history has
// to know about those, so that it can adjust the steps that were
// rebased on top of the remote changes, and include the position
// maps for the remote changes in its array of items.
rebased(rebasedTransform,rebasedCount){if(!this.eventCount)return this;let rebasedItems=[],start=Math.max(0,this.items.length-rebasedCount),mapping=rebasedTransform.mapping,newUntil=rebasedTransform.steps.length,eventCount=this.eventCount;this.items.forEach((item=>{item.selection&&eventCount--}),start);let iRebased=rebasedCount;this.items.forEach((item=>{let pos=mapping.getMirror(--iRebased);if(null==pos)return;newUntil=Math.min(newUntil,pos);let map=mapping.maps[pos];if(item.step){let step=rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]),selection=item.selection&&item.selection.map(mapping.slice(iRebased+1,pos));selection&&eventCount++,rebasedItems.push(new Item(map,step,selection))}else rebasedItems.push(new Item(map))}),start);let newMaps=[];for(let i=rebasedCount;i<newUntil;i++)newMaps.push(new Item(mapping.maps[i]));let items=this.items.slice(0,start).append(newMaps).append(rebasedItems),branch=new Branch(items,eventCount);return branch.emptyItemCount()>max_empty_items&&(branch=branch.compress(this.items.length-rebasedItems.length)),branch}emptyItemCount(){let count=0;return this.items.forEach((item=>{item.step||count++})),count}
// Compressing a branch means rewriting it to push the air (map-only
// items) out. During collaboration, these naturally accumulate
// because each remote change adds one. The `upto` argument is used
// to ensure that only the items below a given level are compressed,
// because `rebased` relies on a clean, untouched set of items in
// order to associate old items with rebased steps.
compress(upto=this.items.length){let remap=this.remapping(0,upto),mapFrom=remap.maps.length,items=[],events=0;return this.items.forEach(((item,i)=>{if(i>=upto)items.push(item),item.selection&&events++;else if(item.step){let step=item.step.map(remap.slice(mapFrom)),map=step&&step.getMap();if(mapFrom--,map&&remap.appendMap(map,mapFrom),step){let selection=item.selection&&item.selection.map(remap.slice(mapFrom));selection&&events++;let merged,newItem=new Item(map.invert(),step,selection),last=items.length-1;(merged=items.length&&items[last].merge(newItem))?items[last]=merged:items.push(newItem)}}else item.map&&mapFrom--}),this.items.length,0),new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */.Z.from(items.reverse()),events)}}function cutOffEvents(items,n){let cutPoint;return items.forEach(((item,i)=>{if(item.selection&&0==n--)return cutPoint=i,!1})),items.slice(cutPoint)}Branch.empty=new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */.Z.empty,0);class Item{constructor(
// The (forward) step map for this item.
map,
// The inverted step
step,
// If this is non-null, this item is the start of a group, and
// this selection is the starting selection for the group (the one
// that was active before the first step was applied)
selection,
// If this item is the inverse of a previous mapping on the stack,
// this points at the inverse's offset
mirrorOffset){this.map=map,this.step=step,this.selection=selection,this.mirrorOffset=mirrorOffset}merge(other){if(this.step&&other.step&&!other.selection){let step=other.step.merge(this.step);if(step)return new Item(step.getMap().invert(),step,this.selection)}}}
// The value of the state field that tracks undo/redo history for that
// state. Will be stored in the plugin state when the history plugin
// is active.
class HistoryState{constructor(done,undone,prevRanges,prevTime){this.done=done,this.undone=undone,this.prevRanges=prevRanges,this.prevTime=prevTime}}const DEPTH_OVERFLOW=20;
// Record a transformation in undo history.
function applyTransaction(history,state,tr,options){let rebased,historyTr=tr.getMeta(historyKey);if(historyTr)return historyTr.historyState;tr.getMeta(closeHistoryKey)&&(history=new HistoryState(history.done,history.undone,null,0));let appended=tr.getMeta("appendedTransaction");if(0==tr.steps.length)return history;if(appended&&appended.getMeta(historyKey))return appended.getMeta(historyKey).redo?new HistoryState(history.done.addTransform(tr,void 0,options,mustPreserveItems(state)),history.undone,rangesFor(tr.mapping.maps[tr.steps.length-1]),history.prevTime):new HistoryState(history.done,history.undone.addTransform(tr,void 0,options,mustPreserveItems(state)),null,history.prevTime);if(!1===tr.getMeta("addToHistory")||appended&&!1===appended.getMeta("addToHistory"))return(rebased=tr.getMeta("rebased"))?new HistoryState(history.done.rebased(tr,rebased),history.undone.rebased(tr,rebased),mapRanges(history.prevRanges,tr.mapping),history.prevTime):new HistoryState(history.done.addMaps(tr.mapping.maps),history.undone.addMaps(tr.mapping.maps),mapRanges(history.prevRanges,tr.mapping),history.prevTime);{
// Group transforms that occur in quick succession into one event.
let newGroup=0==history.prevTime||!appended&&(history.prevTime<(tr.time||0)-options.newGroupDelay||!isAdjacentTo(tr,history.prevRanges)),prevRanges=appended?mapRanges(history.prevRanges,tr.mapping):rangesFor(tr.mapping.maps[tr.steps.length-1]);return new HistoryState(history.done.addTransform(tr,newGroup?state.selection.getBookmark():void 0,options,mustPreserveItems(state)),Branch.empty,prevRanges,tr.time)}}function isAdjacentTo(transform,prevRanges){if(!prevRanges)return!1;if(!transform.docChanged)return!0;let adjacent=!1;return transform.mapping.maps[0].forEach(((start,end)=>{for(let i=0;i<prevRanges.length;i+=2)start<=prevRanges[i+1]&&end>=prevRanges[i]&&(adjacent=!0)})),adjacent}function rangesFor(map){let result=[];return map.forEach(((_from,_to,from,to)=>result.push(from,to))),result}function mapRanges(ranges,mapping){if(!ranges)return null;let result=[];for(let i=0;i<ranges.length;i+=2){let from=mapping.map(ranges[i],1),to=mapping.map(ranges[i+1],-1);from<=to&&result.push(from,to)}return result}
// Apply the latest event from one branch to the document and shift the event
// onto the other branch.
function histTransaction(history,state,dispatch,redo){let preserveItems=mustPreserveItems(state),histOptions=historyKey.get(state).spec.config,pop=(redo?history.undone:history.done).popEvent(state,preserveItems);if(!pop)return;let selection=pop.selection.resolve(pop.transform.doc),added=(redo?history.done:history.undone).addTransform(pop.transform,state.selection.getBookmark(),histOptions,preserveItems),newHist=new HistoryState(redo?added:pop.remaining,redo?pop.remaining:added,null,0);dispatch(pop.transform.setSelection(selection).setMeta(historyKey,{redo:redo,historyState:newHist}).scrollIntoView())}let cachedPreserveItems=!1,cachedPreserveItemsPlugins=null;
// Check whether any plugin in the given state has a
// `historyPreserveItems` property in its spec, in which case we must
// preserve steps exactly as they came in, so that they can be
// rebased.
function mustPreserveItems(state){let plugins=state.plugins;if(cachedPreserveItemsPlugins!=plugins){cachedPreserveItems=!1,cachedPreserveItemsPlugins=plugins;for(let i=0;i<plugins.length;i++)if(plugins[i].spec.historyPreserveItems){cachedPreserveItems=!0;break}}return cachedPreserveItems}
/**
Set a flag on the given transaction that will prevent further steps
from being appended to an existing history event (so that they
require a separate undo command to undo).
*/const historyKey=new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__/* .PluginKey */.H$("history"),closeHistoryKey=new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__/* .PluginKey */.H$("closeHistory");
/**
Returns a plugin that enables the undo history for an editor. The
plugin will track undo and redo stacks, which can be used with the
[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.

You can set an `"addToHistory"` [metadata
property](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction
to prevent it from being rolled back by undo.
*/
function history(config={}){return config={depth:config.depth||100,newGroupDelay:config.newGroupDelay||500},new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__/* .Plugin */.Sy({key:historyKey,state:{init(){return new HistoryState(Branch.empty,Branch.empty,null,0)},apply(tr,hist,state){return applyTransaction(hist,state,tr,config)}},config:config,props:{handleDOMEvents:{beforeinput(view,e){let inputType=e.inputType,command="historyUndo"==inputType?undo:"historyRedo"==inputType?redo:null;return!!command&&(e.preventDefault(),command(view.state,view.dispatch))}}}})}
/**
A command function that undoes the last change, if any.
*/const undo=(state,dispatch)=>{let hist=historyKey.getState(state);return!(!hist||0==hist.done.eventCount)&&(dispatch&&histTransaction(hist,state,dispatch,!1),!0)},redo=(state,dispatch)=>{let hist=historyKey.getState(state);return!(!hist||0==hist.undone.eventCount)&&(dispatch&&histTransaction(hist,state,dispatch,!0),!0)};
/**
A command function that redoes the last undone change, if any.
*/},
/***/560440:
/***/function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";
/* harmony export */__webpack_require__.d(__webpack_exports__,{
/* harmony export */$:function(){/* binding */return keydownHandler},
/* harmony export */h:function(){/* binding */return keymap}
/* harmony export */});
/* harmony import */var w3c_keyname__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(581754),prosemirror_state__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(102376);
/* harmony import */const mac="undefined"!=typeof navigator&&/Mac|iP(hone|[oa]d)/.test(navigator.platform);function normalizeKeyName(name){let alt,ctrl,shift,meta,parts=name.split(/-(?!$)/),result=parts[parts.length-1];"Space"==result&&(result=" ");for(let i=0;i<parts.length-1;i++){let mod=parts[i];if(/^(cmd|meta|m)$/i.test(mod))meta=!0;else if(/^a(lt)?$/i.test(mod))alt=!0;else if(/^(c|ctrl|control)$/i.test(mod))ctrl=!0;else if(/^s(hift)?$/i.test(mod))shift=!0;else{if(!/^mod$/i.test(mod))throw new Error("Unrecognized modifier name: "+mod);mac?meta=!0:ctrl=!0}}return alt&&(result="Alt-"+result),ctrl&&(result="Ctrl-"+result),meta&&(result="Meta-"+result),shift&&(result="Shift-"+result),result}function normalize(map){let copy=Object.create(null);for(let prop in map)copy[normalizeKeyName(prop)]=map[prop];return copy}function modifiers(name,event,shift=!0){return event.altKey&&(name="Alt-"+name),event.ctrlKey&&(name="Ctrl-"+name),event.metaKey&&(name="Meta-"+name),shift&&event.shiftKey&&(name="Shift-"+name),name}
/**
Create a keymap plugin for the given set of bindings.

Bindings should map key names to [command](https://prosemirror.net/docs/ref/#commands)-style
functions, which will be called with `(EditorState, dispatch,
EditorView)` arguments, and should return true when they've handled
the key. Note that the view argument isn't part of the command
protocol, but can be used as an escape hatch if a binding needs to
directly interact with the UI.

Key names may be strings like `"Shift-Ctrl-Enter"`—a key
identifier prefixed with zero or more modifiers. Key identifiers
are based on the strings that can appear in
[`KeyEvent.key`](https:developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).
Use lowercase letters to refer to letter keys (or uppercase letters
if you want shift to be held). You may use `"Space"` as an alias
for the `" "` name.

Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or
`a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or
`Meta-`) are recognized. For characters that are created by holding
shift, the `Shift-` prefix is implied, and should not be added
explicitly.

You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on
other platforms.

You can add multiple keymap plugins to an editor. The order in
which they appear determines their precedence (the ones early in
the array get to dispatch first).
*/function keymap(bindings){return new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .Plugin */.Sy({props:{handleKeyDown:keydownHandler(bindings)}})}
/**
Given a set of bindings (using the same format as
[`keymap`](https://prosemirror.net/docs/ref/#keymap.keymap)), return a [keydown
handler](https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyDown) that handles them.
*/function keydownHandler(bindings){let map=normalize(bindings);return function(view,event){let baseName,name=(0,w3c_keyname__WEBPACK_IMPORTED_MODULE_0__/* .keyName */.YG)(event),direct=map[modifiers(name,event)];if(direct&&direct(view.state,view.dispatch,view))return!0;
// A character key
if(1==name.length&&" "!=name){if(event.shiftKey){
// In case the name was already modified by shift, try looking
// it up without its shift modifier
let noShift=map[modifiers(name,event,!1)];if(noShift&&noShift(view.state,view.dispatch,view))return!0}if((event.shiftKey||event.altKey||event.metaKey||name.charCodeAt(0)>127)&&(baseName=w3c_keyname__WEBPACK_IMPORTED_MODULE_0__/* .base */.ue[event.keyCode])&&baseName!=name){
// Try falling back to the keyCode when there's a modifier
// active or the character produced isn't ASCII, and our table
// produces a different name from the the keyCode. See #668,
// #1060
let fromCode=map[modifiers(baseName,event)];if(fromCode&&fromCode(view.state,view.dispatch,view))return!0}}return!1}}
/***/},
/***/759084:
/***/function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";
/* harmony export */__webpack_require__.d(__webpack_exports__,{
/* harmony export */HY:function(){/* binding */return Fragment},
/* harmony export */NB:function(){/* binding */return Node},
/* harmony export */PW:function(){/* binding */return DOMSerializer},
/* harmony export */Ts:function(){/* binding */return NodeRange},
/* harmony export */V_:function(){/* binding */return Schema},
/* harmony export */ZU:function(){/* binding */return MarkType},
/* harmony export */aw:function(){/* binding */return DOMParser},
/* harmony export */e4:function(){/* binding */return ReplaceError},
/* harmony export */p2:function(){/* binding */return Slice},
/* harmony export */vc:function(){/* binding */return Mark}
/* harmony export */});
/* unused harmony exports ContentMatch, NodeType, ResolvedPos */
/* harmony import */var orderedmap__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(17258);function findDiffStart(a,b,pos){for(let i=0;;i++){if(i==a.childCount||i==b.childCount)return a.childCount==b.childCount?null:pos;let childA=a.child(i),childB=b.child(i);if(childA!=childB){if(!childA.sameMarkup(childB))return pos;if(childA.isText&&childA.text!=childB.text){for(let j=0;childA.text[j]==childB.text[j];j++)pos++;return pos}if(childA.content.size||childB.content.size){let inner=findDiffStart(childA.content,childB.content,pos+1);if(null!=inner)return inner}pos+=childA.nodeSize}else pos+=childA.nodeSize}}function findDiffEnd(a,b,posA,posB){for(let iA=a.childCount,iB=b.childCount;;){if(0==iA||0==iB)return iA==iB?null:{a:posA,b:posB};let childA=a.child(--iA),childB=b.child(--iB),size=childA.nodeSize;if(childA!=childB){if(!childA.sameMarkup(childB))return{a:posA,b:posB};if(childA.isText&&childA.text!=childB.text){let same=0,minSize=Math.min(childA.text.length,childB.text.length);while(same<minSize&&childA.text[childA.text.length-same-1]==childB.text[childB.text.length-same-1])same++,posA--,posB--;return{a:posA,b:posB}}if(childA.content.size||childB.content.size){let inner=findDiffEnd(childA.content,childB.content,posA-1,posB-1);if(inner)return inner}posA-=size,posB-=size}else posA-=size,posB-=size}}
/**
A fragment represents a node's collection of child nodes.

Like nodes, fragments are persistent data structures, and you
should not mutate them or their content. Rather, you create new
instances whenever needed. The API tries to make this easy.
*/class Fragment{
/**
    @internal
    */
constructor(
/**
    @internal
    */
content,size){if(this.content=content,this.size=size||0,null==size)for(let i=0;i<content.length;i++)this.size+=content[i].nodeSize}
/**
    Invoke a callback for all descendant nodes between the given two
    positions (relative to start of this fragment). Doesn't descend
    into a node when the callback returns `false`.
    */nodesBetween(from,to,f,nodeStart=0,parent){for(let i=0,pos=0;pos<to;i++){let child=this.content[i],end=pos+child.nodeSize;if(end>from&&!1!==f(child,nodeStart+pos,parent||null,i)&&child.content.size){let start=pos+1;child.nodesBetween(Math.max(0,from-start),Math.min(child.content.size,to-start),f,nodeStart+start)}pos=end}}
/**
    Call the given callback for every descendant node. `pos` will be
    relative to the start of the fragment. The callback may return
    `false` to prevent traversal of a given node's children.
    */descendants(f){this.nodesBetween(0,this.size,f)}
/**
    Extract the text between `from` and `to`. See the same method on
    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
    */textBetween(from,to,blockSeparator,leafText){let text="",separated=!0;return this.nodesBetween(from,to,((node,pos)=>{node.isText?(text+=node.text.slice(Math.max(from,pos)-pos,to-pos),separated=!blockSeparator):node.isLeaf?(leafText?text+="function"===typeof leafText?leafText(node):leafText:node.type.spec.leafText&&(text+=node.type.spec.leafText(node)),separated=!blockSeparator):!separated&&node.isBlock&&(text+=blockSeparator,separated=!0)}),0),text}
/**
    Create a new fragment containing the combined content of this
    fragment and the other.
    */append(other){if(!other.size)return this;if(!this.size)return other;let last=this.lastChild,first=other.firstChild,content=this.content.slice(),i=0;for(last.isText&&last.sameMarkup(first)&&(content[content.length-1]=last.withText(last.text+first.text),i=1);i<other.content.length;i++)content.push(other.content[i]);return new Fragment(content,this.size+other.size)}
/**
    Cut out the sub-fragment between the two given positions.
    */cut(from,to=this.size){if(0==from&&to==this.size)return this;let result=[],size=0;if(to>from)for(let i=0,pos=0;pos<to;i++){let child=this.content[i],end=pos+child.nodeSize;end>from&&((pos<from||end>to)&&(child=child.isText?child.cut(Math.max(0,from-pos),Math.min(child.text.length,to-pos)):child.cut(Math.max(0,from-pos-1),Math.min(child.content.size,to-pos-1))),result.push(child),size+=child.nodeSize),pos=end}return new Fragment(result,size)}
/**
    @internal
    */cutByIndex(from,to){return from==to?Fragment.empty:0==from&&to==this.content.length?this:new Fragment(this.content.slice(from,to))}
/**
    Create a new fragment in which the node at the given index is
    replaced by the given node.
    */replaceChild(index,node){let current=this.content[index];if(current==node)return this;let copy=this.content.slice(),size=this.size+node.nodeSize-current.nodeSize;return copy[index]=node,new Fragment(copy,size)}
/**
    Create a new fragment by prepending the given node to this
    fragment.
    */addToStart(node){return new Fragment([node].concat(this.content),this.size+node.nodeSize)}
/**
    Create a new fragment by appending the given node to this
    fragment.
    */addToEnd(node){return new Fragment(this.content.concat(node),this.size+node.nodeSize)}
/**
    Compare this fragment to another one.
    */eq(other){if(this.content.length!=other.content.length)return!1;for(let i=0;i<this.content.length;i++)if(!this.content[i].eq(other.content[i]))return!1;return!0}
/**
    The first child of the fragment, or `null` if it is empty.
    */get firstChild(){return this.content.length?this.content[0]:null}
/**
    The last child of the fragment, or `null` if it is empty.
    */get lastChild(){return this.content.length?this.content[this.content.length-1]:null}
/**
    The number of child nodes in this fragment.
    */get childCount(){return this.content.length}
/**
    Get the child node at the given index. Raise an error when the
    index is out of range.
    */child(index){let found=this.content[index];if(!found)throw new RangeError("Index "+index+" out of range for "+this);return found}
/**
    Get the child node at the given index, if it exists.
    */maybeChild(index){return this.content[index]||null}
/**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */forEach(f){for(let i=0,p=0;i<this.content.length;i++){let child=this.content[i];f(child,p,i),p+=child.nodeSize}}
/**
    Find the first position at which this fragment and another
    fragment differ, or `null` if they are the same.
    */findDiffStart(other,pos=0){return findDiffStart(this,other,pos)}
/**
    Find the first position, searching from the end, at which this
    fragment and the given fragment differ, or `null` if they are
    the same. Since this position will not be the same in both
    nodes, an object with two separate positions is returned.
    */findDiffEnd(other,pos=this.size,otherPos=other.size){return findDiffEnd(this,other,pos,otherPos)}
/**
    Find the index and inner offset corresponding to a given relative
    position in this fragment. The result object will be reused
    (overwritten) the next time the function is called. (Not public.)
    */findIndex(pos,round=-1){if(0==pos)return retIndex(0,pos);if(pos==this.size)return retIndex(this.content.length,pos);if(pos>this.size||pos<0)throw new RangeError(`Position ${pos} outside of fragment (${this})`);for(let i=0,curPos=0;;i++){let cur=this.child(i),end=curPos+cur.nodeSize;if(end>=pos)return end==pos||round>0?retIndex(i+1,end):retIndex(i,curPos);curPos=end}}
/**
    Return a debugging string that describes this fragment.
    */toString(){return"<"+this.toStringInner()+">"}
/**
    @internal
    */toStringInner(){return this.content.join(", ")}
/**
    Create a JSON-serializeable representation of this fragment.
    */toJSON(){return this.content.length?this.content.map((n=>n.toJSON())):null}
/**
    Deserialize a fragment from its JSON representation.
    */static fromJSON(schema,value){if(!value)return Fragment.empty;if(!Array.isArray(value))throw new RangeError("Invalid input for Fragment.fromJSON");return new Fragment(value.map(schema.nodeFromJSON))}
/**
    Build a fragment from an array of nodes. Ensures that adjacent
    text nodes with the same marks are joined together.
    */static fromArray(array){if(!array.length)return Fragment.empty;let joined,size=0;for(let i=0;i<array.length;i++){let node=array[i];size+=node.nodeSize,i&&node.isText&&array[i-1].sameMarkup(node)?(joined||(joined=array.slice(0,i)),joined[joined.length-1]=node.withText(joined[joined.length-1].text+node.text)):joined&&joined.push(node)}return new Fragment(joined||array,size)}
/**
    Create a fragment from something that can be interpreted as a
    set of nodes. For `null`, it returns the empty fragment. For a
    fragment, the fragment itself. For a node or array of nodes, a
    fragment containing those nodes.
    */static from(nodes){if(!nodes)return Fragment.empty;if(nodes instanceof Fragment)return nodes;if(Array.isArray(nodes))return this.fromArray(nodes);if(nodes.attrs)return new Fragment([nodes],nodes.nodeSize);throw new RangeError("Can not convert "+nodes+" to a Fragment"+(nodes.nodesBetween?" (looks like multiple versions of prosemirror-model were loaded)":""))}}
/**
An empty fragment. Intended to be reused whenever a node doesn't
contain anything (rather than allocating a new empty fragment for
each leaf node).
*/Fragment.empty=new Fragment([],0);const found={index:0,offset:0};function retIndex(index,offset){return found.index=index,found.offset=offset,found}function compareDeep(a,b){if(a===b)return!0;if(!a||"object"!=typeof a||!b||"object"!=typeof b)return!1;let array=Array.isArray(a);if(Array.isArray(b)!=array)return!1;if(array){if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(!compareDeep(a[i],b[i]))return!1}else{for(let p in a)if(!(p in b)||!compareDeep(a[p],b[p]))return!1;for(let p in b)if(!(p in a))return!1}return!0}
/**
A mark is a piece of information that can be attached to a node,
such as it being emphasized, in code font, or a link. It has a
type and optionally a set of attributes that provide further
information (such as the target of the link). Marks are created
through a `Schema`, which controls which types exist and which
attributes they have.
*/class Mark{
/**
    @internal
    */
constructor(
/**
    The type of this mark.
    */
type,
/**
    The attributes associated with this mark.
    */
attrs){this.type=type,this.attrs=attrs}
/**
    Given a set of marks, create a new set which contains this one as
    well, in the right position. If this mark is already in the set,
    the set itself is returned. If any marks that are set to be
    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
    those are replaced by this one.
    */addToSet(set){let copy,placed=!1;for(let i=0;i<set.length;i++){let other=set[i];if(this.eq(other))return set;if(this.type.excludes(other.type))copy||(copy=set.slice(0,i));else{if(other.type.excludes(this.type))return set;!placed&&other.type.rank>this.type.rank&&(copy||(copy=set.slice(0,i)),copy.push(this),placed=!0),copy&&copy.push(other)}}return copy||(copy=set.slice()),placed||copy.push(this),copy}
/**
    Remove this mark from the given set, returning a new set. If this
    mark is not in the set, the set itself is returned.
    */removeFromSet(set){for(let i=0;i<set.length;i++)if(this.eq(set[i]))return set.slice(0,i).concat(set.slice(i+1));return set}
/**
    Test whether this mark is in the given set of marks.
    */isInSet(set){for(let i=0;i<set.length;i++)if(this.eq(set[i]))return!0;return!1}
/**
    Test whether this mark has the same type and attributes as
    another mark.
    */eq(other){return this==other||this.type==other.type&&compareDeep(this.attrs,other.attrs)}
/**
    Convert this mark to a JSON-serializeable representation.
    */toJSON(){let obj={type:this.type.name};for(let _ in this.attrs){obj.attrs=this.attrs;break}return obj}
/**
    Deserialize a mark from JSON.
    */static fromJSON(schema,json){if(!json)throw new RangeError("Invalid input for Mark.fromJSON");let type=schema.marks[json.type];if(!type)throw new RangeError(`There is no mark type ${json.type} in this schema`);return type.create(json.attrs)}
/**
    Test whether two sets of marks are identical.
    */static sameSet(a,b){if(a==b)return!0;if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(!a[i].eq(b[i]))return!1;return!0}
/**
    Create a properly sorted mark set from null, a single mark, or an
    unsorted array of marks.
    */static setFrom(marks){if(!marks||Array.isArray(marks)&&0==marks.length)return Mark.none;if(marks instanceof Mark)return[marks];let copy=marks.slice();return copy.sort(((a,b)=>a.type.rank-b.type.rank)),copy}}
/**
The empty set of marks.
*/Mark.none=[];
/**
Error type raised by [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) when
given an invalid replacement.
*/
class ReplaceError extends Error{}
/*
ReplaceError = function(this: any, message: string) {
  let err = Error.call(this, message)
  ;(err as any).__proto__ = ReplaceError.prototype
  return err
} as any

ReplaceError.prototype = Object.create(Error.prototype)
ReplaceError.prototype.constructor = ReplaceError
ReplaceError.prototype.name = "ReplaceError"
*/
/**
A slice represents a piece cut out of a larger document. It
stores not only a fragment, but also the depth up to which nodes on
both side are ‘open’ (cut through).
*/class Slice{
/**
    Create a slice. When specifying a non-zero open depth, you must
    make sure that there are nodes of at least that depth at the
    appropriate side of the fragment—i.e. if the fragment is an
    empty paragraph node, `openStart` and `openEnd` can't be greater
    than 1.
    
    It is not necessary for the content of open nodes to conform to
    the schema's content constraints, though it should be a valid
    start/end/middle for such a node, depending on which sides are
    open.
    */
constructor(
/**
    The slice's content.
    */
content,
/**
    The open depth at the start of the fragment.
    */
openStart,
/**
    The open depth at the end.
    */
openEnd){this.content=content,this.openStart=openStart,this.openEnd=openEnd}
/**
    The size this slice would add when inserted into a document.
    */get size(){return this.content.size-this.openStart-this.openEnd}
/**
    @internal
    */insertAt(pos,fragment){let content=insertInto(this.content,pos+this.openStart,fragment);return content&&new Slice(content,this.openStart,this.openEnd)}
/**
    @internal
    */removeBetween(from,to){return new Slice(removeRange(this.content,from+this.openStart,to+this.openStart),this.openStart,this.openEnd)}
/**
    Tests whether this slice is equal to another slice.
    */eq(other){return this.content.eq(other.content)&&this.openStart==other.openStart&&this.openEnd==other.openEnd}
/**
    @internal
    */toString(){return this.content+"("+this.openStart+","+this.openEnd+")"}
/**
    Convert a slice to a JSON-serializable representation.
    */toJSON(){if(!this.content.size)return null;let json={content:this.content.toJSON()};return this.openStart>0&&(json.openStart=this.openStart),this.openEnd>0&&(json.openEnd=this.openEnd),json}
/**
    Deserialize a slice from its JSON representation.
    */static fromJSON(schema,json){if(!json)return Slice.empty;let openStart=json.openStart||0,openEnd=json.openEnd||0;if("number"!=typeof openStart||"number"!=typeof openEnd)throw new RangeError("Invalid input for Slice.fromJSON");return new Slice(Fragment.fromJSON(schema,json.content),openStart,openEnd)}
/**
    Create a slice from a fragment by taking the maximum possible
    open value on both side of the fragment.
    */static maxOpen(fragment,openIsolating=!0){let openStart=0,openEnd=0;for(let n=fragment.firstChild;n&&!n.isLeaf&&(openIsolating||!n.type.spec.isolating);n=n.firstChild)openStart++;for(let n=fragment.lastChild;n&&!n.isLeaf&&(openIsolating||!n.type.spec.isolating);n=n.lastChild)openEnd++;return new Slice(fragment,openStart,openEnd)}}
/**
The empty slice.
*/function removeRange(content,from,to){let{index:index,offset:offset}=content.findIndex(from),child=content.maybeChild(index),{index:indexTo,offset:offsetTo}=content.findIndex(to);if(offset==from||child.isText){if(offsetTo!=to&&!content.child(indexTo).isText)throw new RangeError("Removing non-flat range");return content.cut(0,from).append(content.cut(to))}if(index!=indexTo)throw new RangeError("Removing non-flat range");return content.replaceChild(index,child.copy(removeRange(child.content,from-offset-1,to-offset-1)))}function insertInto(content,dist,insert,parent){let{index:index,offset:offset}=content.findIndex(dist),child=content.maybeChild(index);if(offset==dist||child.isText)return parent&&!parent.canReplace(index,index,insert)?null:content.cut(0,dist).append(insert).append(content.cut(dist));let inner=insertInto(child.content,dist-offset-1,insert);return inner&&content.replaceChild(index,child.copy(inner))}function replace($from,$to,slice){if(slice.openStart>$from.depth)throw new ReplaceError("Inserted content deeper than insertion position");if($from.depth-slice.openStart!=$to.depth-slice.openEnd)throw new ReplaceError("Inconsistent open depths");return replaceOuter($from,$to,slice,0)}function replaceOuter($from,$to,slice,depth){let index=$from.index(depth),node=$from.node(depth);if(index==$to.index(depth)&&depth<$from.depth-slice.openStart){let inner=replaceOuter($from,$to,slice,depth+1);return node.copy(node.content.replaceChild(index,inner))}if(slice.content.size){if(slice.openStart||slice.openEnd||$from.depth!=depth||$to.depth!=depth){let{start:start,end:end}=prepareSliceForReplace(slice,$from);return close(node,replaceThreeWay($from,start,end,$to,depth))}{// Simple, flat case
let parent=$from.parent,content=parent.content;return close(parent,content.cut(0,$from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))}}return close(node,replaceTwoWay($from,$to,depth))}function checkJoin(main,sub){if(!sub.type.compatibleContent(main.type))throw new ReplaceError("Cannot join "+sub.type.name+" onto "+main.type.name)}function joinable($before,$after,depth){let node=$before.node(depth);return checkJoin(node,$after.node(depth)),node}function addNode(child,target){let last=target.length-1;last>=0&&child.isText&&child.sameMarkup(target[last])?target[last]=child.withText(target[last].text+child.text):target.push(child)}function addRange($start,$end,depth,target){let node=($end||$start).node(depth),startIndex=0,endIndex=$end?$end.index(depth):node.childCount;$start&&(startIndex=$start.index(depth),$start.depth>depth?startIndex++:$start.textOffset&&(addNode($start.nodeAfter,target),startIndex++));for(let i=startIndex;i<endIndex;i++)addNode(node.child(i),target);$end&&$end.depth==depth&&$end.textOffset&&addNode($end.nodeBefore,target)}function close(node,content){return node.type.checkContent(content),node.copy(content)}function replaceThreeWay($from,$start,$end,$to,depth){let openStart=$from.depth>depth&&joinable($from,$start,depth+1),openEnd=$to.depth>depth&&joinable($end,$to,depth+1),content=[];return addRange(null,$from,depth,content),openStart&&openEnd&&$start.index(depth)==$end.index(depth)?(checkJoin(openStart,openEnd),addNode(close(openStart,replaceThreeWay($from,$start,$end,$to,depth+1)),content)):(openStart&&addNode(close(openStart,replaceTwoWay($from,$start,depth+1)),content),addRange($start,$end,depth,content),openEnd&&addNode(close(openEnd,replaceTwoWay($end,$to,depth+1)),content)),addRange($to,null,depth,content),new Fragment(content)}function replaceTwoWay($from,$to,depth){let content=[];if(addRange(null,$from,depth,content),$from.depth>depth){let type=joinable($from,$to,depth+1);addNode(close(type,replaceTwoWay($from,$to,depth+1)),content)}return addRange($to,null,depth,content),new Fragment(content)}function prepareSliceForReplace(slice,$along){let extra=$along.depth-slice.openStart,parent=$along.node(extra),node=parent.copy(slice.content);for(let i=extra-1;i>=0;i--)node=$along.node(i).copy(Fragment.from(node));return{start:node.resolveNoCache(slice.openStart+extra),end:node.resolveNoCache(node.content.size-slice.openEnd-extra)}}
/**
You can [_resolve_](https://prosemirror.net/docs/ref/#model.Node.resolve) a position to get more
information about it. Objects of this class represent such a
resolved position, providing various pieces of context
information, and some helper methods.

Throughout this interface, methods that take an optional `depth`
parameter will interpret undefined as `this.depth` and negative
numbers as `this.depth + value`.
*/Slice.empty=new Slice(Fragment.empty,0,0);class ResolvedPos{
/**
    @internal
    */
constructor(
/**
    The position that was resolved.
    */
pos,
/**
    @internal
    */
path,
/**
    The offset this position has into its parent node.
    */
parentOffset){this.pos=pos,this.path=path,this.parentOffset=parentOffset,this.depth=path.length/3-1}
/**
    @internal
    */resolveDepth(val){return null==val?this.depth:val<0?this.depth+val:val}
/**
    The parent node that the position points into. Note that even if
    a position points into a text node, that node is not considered
    the parent—text nodes are ‘flat’ in this model, and have no content.
    */get parent(){return this.node(this.depth)}
/**
    The root node in which the position was resolved.
    */get doc(){return this.node(0)}
/**
    The ancestor node at the given level. `p.node(p.depth)` is the
    same as `p.parent`.
    */node(depth){return this.path[3*this.resolveDepth(depth)]}
/**
    The index into the ancestor at the given level. If this points
    at the 3rd node in the 2nd paragraph on the top level, for
    example, `p.index(0)` is 1 and `p.index(1)` is 2.
    */index(depth){return this.path[3*this.resolveDepth(depth)+1]}
/**
    The index pointing after this position into the ancestor at the
    given level.
    */indexAfter(depth){return depth=this.resolveDepth(depth),this.index(depth)+(depth!=this.depth||this.textOffset?1:0)}
/**
    The (absolute) position at the start of the node at the given
    level.
    */start(depth){return depth=this.resolveDepth(depth),0==depth?0:this.path[3*depth-1]+1}
/**
    The (absolute) position at the end of the node at the given
    level.
    */end(depth){return depth=this.resolveDepth(depth),this.start(depth)+this.node(depth).content.size}
/**
    The (absolute) position directly before the wrapping node at the
    given level, or, when `depth` is `this.depth + 1`, the original
    position.
    */before(depth){if(depth=this.resolveDepth(depth),!depth)throw new RangeError("There is no position before the top-level node");return depth==this.depth+1?this.pos:this.path[3*depth-1]}
/**
    The (absolute) position directly after the wrapping node at the
    given level, or the original position when `depth` is `this.depth + 1`.
    */after(depth){if(depth=this.resolveDepth(depth),!depth)throw new RangeError("There is no position after the top-level node");return depth==this.depth+1?this.pos:this.path[3*depth-1]+this.path[3*depth].nodeSize}
/**
    When this position points into a text node, this returns the
    distance between the position and the start of the text node.
    Will be zero for positions that point between nodes.
    */get textOffset(){return this.pos-this.path[this.path.length-1]}
/**
    Get the node directly after the position, if any. If the position
    points into a text node, only the part of that node after the
    position is returned.
    */get nodeAfter(){let parent=this.parent,index=this.index(this.depth);if(index==parent.childCount)return null;let dOff=this.pos-this.path[this.path.length-1],child=parent.child(index);return dOff?parent.child(index).cut(dOff):child}
/**
    Get the node directly before the position, if any. If the
    position points into a text node, only the part of that node
    before the position is returned.
    */get nodeBefore(){let index=this.index(this.depth),dOff=this.pos-this.path[this.path.length-1];return dOff?this.parent.child(index).cut(0,dOff):0==index?null:this.parent.child(index-1)}
/**
    Get the position at the given index in the parent node at the
    given depth (which defaults to `this.depth`).
    */posAtIndex(index,depth){depth=this.resolveDepth(depth);let node=this.path[3*depth],pos=0==depth?0:this.path[3*depth-1]+1;for(let i=0;i<index;i++)pos+=node.child(i).nodeSize;return pos}
/**
    Get the marks at this position, factoring in the surrounding
    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
    position is at the start of a non-empty node, the marks of the
    node after it (if any) are returned.
    */marks(){let parent=this.parent,index=this.index();
// In an empty parent, return the empty array
if(0==parent.content.size)return Mark.none;
// When inside a text node, just return the text node's marks
if(this.textOffset)return parent.child(index).marks;let main=parent.maybeChild(index-1),other=parent.maybeChild(index);
// If the `after` flag is true of there is no node before, make
// the node after this position the main reference.
if(!main){let tmp=main;main=other,other=tmp}
// Use all marks in the main node, except those that have
// `inclusive` set to false and are not present in the other node.
let marks=main.marks;for(var i=0;i<marks.length;i++)!1!==marks[i].type.spec.inclusive||other&&marks[i].isInSet(other.marks)||(marks=marks[i--].removeFromSet(marks));return marks}
/**
    Get the marks after the current position, if any, except those
    that are non-inclusive and not present at position `$end`. This
    is mostly useful for getting the set of marks to preserve after a
    deletion. Will return `null` if this position is at the end of
    its parent node or its parent node isn't a textblock (in which
    case no marks should be preserved).
    */marksAcross($end){let after=this.parent.maybeChild(this.index());if(!after||!after.isInline)return null;let marks=after.marks,next=$end.parent.maybeChild($end.index());for(var i=0;i<marks.length;i++)!1!==marks[i].type.spec.inclusive||next&&marks[i].isInSet(next.marks)||(marks=marks[i--].removeFromSet(marks));return marks}
/**
    The depth up to which this position and the given (non-resolved)
    position share the same parent nodes.
    */sharedDepth(pos){for(let depth=this.depth;depth>0;depth--)if(this.start(depth)<=pos&&this.end(depth)>=pos)return depth;return 0}
/**
    Returns a range based on the place where this position and the
    given position diverge around block content. If both point into
    the same textblock, for example, a range around that textblock
    will be returned. If they point into different blocks, the range
    around those blocks in their shared ancestor is returned. You can
    pass in an optional predicate that will be called with a parent
    node to see if a range into that parent is acceptable.
    */blockRange(other=this,pred){if(other.pos<this.pos)return other.blockRange(this);for(let d=this.depth-(this.parent.inlineContent||this.pos==other.pos?1:0);d>=0;d--)if(other.pos<=this.end(d)&&(!pred||pred(this.node(d))))return new NodeRange(this,other,d);return null}
/**
    Query whether the given position shares the same parent node.
    */sameParent(other){return this.pos-this.parentOffset==other.pos-other.parentOffset}
/**
    Return the greater of this and the given position.
    */max(other){return other.pos>this.pos?other:this}
/**
    Return the smaller of this and the given position.
    */min(other){return other.pos<this.pos?other:this}
/**
    @internal
    */toString(){let str="";for(let i=1;i<=this.depth;i++)str+=(str?"/":"")+this.node(i).type.name+"_"+this.index(i-1);return str+":"+this.parentOffset}
/**
    @internal
    */static resolve(doc,pos){if(!(pos>=0&&pos<=doc.content.size))throw new RangeError("Position "+pos+" out of range");let path=[],start=0,parentOffset=pos;for(let node=doc;;){let{index:index,offset:offset}=node.content.findIndex(parentOffset),rem=parentOffset-offset;if(path.push(node,index,start+offset),!rem)break;if(node=node.child(index),node.isText)break;parentOffset=rem-1,start+=offset+1}return new ResolvedPos(pos,path,parentOffset)}
/**
    @internal
    */static resolveCached(doc,pos){for(let i=0;i<resolveCache.length;i++){let cached=resolveCache[i];if(cached.pos==pos&&cached.doc==doc)return cached}let result=resolveCache[resolveCachePos]=ResolvedPos.resolve(doc,pos);return resolveCachePos=(resolveCachePos+1)%resolveCacheSize,result}}let resolveCache=[],resolveCachePos=0,resolveCacheSize=12;
/**
Represents a flat range of content, i.e. one that starts and
ends in the same node.
*/class NodeRange{
/**
    Construct a node range. `$from` and `$to` should point into the
    same node until at least the given `depth`, since a node range
    denotes an adjacent set of nodes in a single parent node.
    */
constructor(
/**
    A resolved position along the start of the content. May have a
    `depth` greater than this object's `depth` property, since
    these are the positions that were used to compute the range,
    not re-resolved positions directly at its boundaries.
    */
$from,
/**
    A position along the end of the content. See
    caveat for [`$from`](https://prosemirror.net/docs/ref/#model.NodeRange.$from).
    */
$to,
/**
    The depth of the node that this range points into.
    */
depth){this.$from=$from,this.$to=$to,this.depth=depth}
/**
    The position at the start of the range.
    */get start(){return this.$from.before(this.depth+1)}
/**
    The position at the end of the range.
    */get end(){return this.$to.after(this.depth+1)}
/**
    The parent node that the range points into.
    */get parent(){return this.$from.node(this.depth)}
/**
    The start index of the range in the parent node.
    */get startIndex(){return this.$from.index(this.depth)}
/**
    The end index of the range in the parent node.
    */get endIndex(){return this.$to.indexAfter(this.depth)}}const emptyAttrs=Object.create(null);
/**
This class represents a node in the tree that makes up a
ProseMirror document. So a document is an instance of `Node`, with
children that are also instances of `Node`.

Nodes are persistent data structures. Instead of changing them, you
create new ones with the content you want. Old ones keep pointing
at the old document shape. This is made cheaper by sharing
structure between the old and new data as much as possible, which a
tree shape like this (without back pointers) makes easy.

**Do not** directly mutate the properties of a `Node` object. See
[the guide](/docs/guide/#doc) for more information.
*/class Node{
/**
    @internal
    */
constructor(
/**
    The type of node that this is.
    */
type,
/**
    An object mapping attribute names to values. The kind of
    attributes allowed and required are
    [determined](https://prosemirror.net/docs/ref/#model.NodeSpec.attrs) by the node type.
    */
attrs,
// A fragment holding the node's children.
content,
/**
    The marks (things like whether it is emphasized or part of a
    link) applied to this node.
    */
marks=Mark.none){this.type=type,this.attrs=attrs,this.marks=marks,this.content=content||Fragment.empty}
/**
    The size of this node, as defined by the integer-based [indexing
    scheme](/docs/guide/#doc.indexing). For text nodes, this is the
    amount of characters. For other leaf nodes, it is one. For
    non-leaf nodes, it is the size of the content plus two (the
    start and end token).
    */get nodeSize(){return this.isLeaf?1:2+this.content.size}
/**
    The number of children that the node has.
    */get childCount(){return this.content.childCount}
/**
    Get the child node at the given index. Raises an error when the
    index is out of range.
    */child(index){return this.content.child(index)}
/**
    Get the child node at the given index, if it exists.
    */maybeChild(index){return this.content.maybeChild(index)}
/**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */forEach(f){this.content.forEach(f)}
/**
    Invoke a callback for all descendant nodes recursively between
    the given two positions that are relative to start of this
    node's content. The callback is invoked with the node, its
    position relative to the original node (method receiver),
    its parent node, and its child index. When the callback returns
    false for a given node, that node's children will not be
    recursed over. The last parameter can be used to specify a
    starting position to count from.
    */nodesBetween(from,to,f,startPos=0){this.content.nodesBetween(from,to,f,startPos,this)}
/**
    Call the given callback for every descendant node. Doesn't
    descend into a node when the callback returns `false`.
    */descendants(f){this.nodesBetween(0,this.content.size,f)}
/**
    Concatenates all the text nodes found in this fragment and its
    children.
    */get textContent(){return this.isLeaf&&this.type.spec.leafText?this.type.spec.leafText(this):this.textBetween(0,this.content.size,"")}
/**
    Get all text between positions `from` and `to`. When
    `blockSeparator` is given, it will be inserted to separate text
    from different block nodes. If `leafText` is given, it'll be
    inserted for every non-text leaf node encountered, otherwise
    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
    */textBetween(from,to,blockSeparator,leafText){return this.content.textBetween(from,to,blockSeparator,leafText)}
/**
    Returns this node's first child, or `null` if there are no
    children.
    */get firstChild(){return this.content.firstChild}
/**
    Returns this node's last child, or `null` if there are no
    children.
    */get lastChild(){return this.content.lastChild}
/**
    Test whether two nodes represent the same piece of document.
    */eq(other){return this==other||this.sameMarkup(other)&&this.content.eq(other.content)}
/**
    Compare the markup (type, attributes, and marks) of this node to
    those of another. Returns `true` if both have the same markup.
    */sameMarkup(other){return this.hasMarkup(other.type,other.attrs,other.marks)}
/**
    Check whether this node's markup correspond to the given type,
    attributes, and marks.
    */hasMarkup(type,attrs,marks){return this.type==type&&compareDeep(this.attrs,attrs||type.defaultAttrs||emptyAttrs)&&Mark.sameSet(this.marks,marks||Mark.none)}
/**
    Create a new node with the same markup as this node, containing
    the given content (or empty, if no content is given).
    */copy(content=null){return content==this.content?this:new Node(this.type,this.attrs,content,this.marks)}
/**
    Create a copy of this node, with the given set of marks instead
    of the node's own marks.
    */mark(marks){return marks==this.marks?this:new Node(this.type,this.attrs,this.content,marks)}
/**
    Create a copy of this node with only the content between the
    given positions. If `to` is not given, it defaults to the end of
    the node.
    */cut(from,to=this.content.size){return 0==from&&to==this.content.size?this:this.copy(this.content.cut(from,to))}
/**
    Cut out the part of the document between the given positions, and
    return it as a `Slice` object.
    */slice(from,to=this.content.size,includeParents=!1){if(from==to)return Slice.empty;let $from=this.resolve(from),$to=this.resolve(to),depth=includeParents?0:$from.sharedDepth(to),start=$from.start(depth),node=$from.node(depth),content=node.content.cut($from.pos-start,$to.pos-start);return new Slice(content,$from.depth-depth,$to.depth-depth)}
/**
    Replace the part of the document between the given positions with
    the given slice. The slice must 'fit', meaning its open sides
    must be able to connect to the surrounding content, and its
    content nodes must be valid children for the node they are placed
    into. If any of this is violated, an error of type
    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
    */replace(from,to,slice){return replace(this.resolve(from),this.resolve(to),slice)}
/**
    Find the node directly after the given position.
    */nodeAt(pos){for(let node=this;;){let{index:index,offset:offset}=node.content.findIndex(pos);if(node=node.maybeChild(index),!node)return null;if(offset==pos||node.isText)return node;pos-=offset+1}}
/**
    Find the (direct) child node after the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */childAfter(pos){let{index:index,offset:offset}=this.content.findIndex(pos);return{node:this.content.maybeChild(index),index:index,offset:offset}}
/**
    Find the (direct) child node before the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */childBefore(pos){if(0==pos)return{node:null,index:0,offset:0};let{index:index,offset:offset}=this.content.findIndex(pos);if(offset<pos)return{node:this.content.child(index),index:index,offset:offset};let node=this.content.child(index-1);return{node:node,index:index-1,offset:offset-node.nodeSize}}
/**
    Resolve the given position in the document, returning an
    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
    */resolve(pos){return ResolvedPos.resolveCached(this,pos)}
/**
    @internal
    */resolveNoCache(pos){return ResolvedPos.resolve(this,pos)}
/**
    Test whether a given mark or mark type occurs in this document
    between the two given positions.
    */rangeHasMark(from,to,type){let found=!1;return to>from&&this.nodesBetween(from,to,(node=>(type.isInSet(node.marks)&&(found=!0),!found))),found}
/**
    True when this is a block (non-inline node)
    */get isBlock(){return this.type.isBlock}
/**
    True when this is a textblock node, a block node with inline
    content.
    */get isTextblock(){return this.type.isTextblock}
/**
    True when this node allows inline content.
    */get inlineContent(){return this.type.inlineContent}
/**
    True when this is an inline node (a text node or a node that can
    appear among text).
    */get isInline(){return this.type.isInline}
/**
    True when this is a text node.
    */get isText(){return this.type.isText}
/**
    True when this is a leaf node.
    */get isLeaf(){return this.type.isLeaf}
/**
    True when this is an atom, i.e. when it does not have directly
    editable content. This is usually the same as `isLeaf`, but can
    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
    on a node's spec (typically used when the node is displayed as
    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
    */get isAtom(){return this.type.isAtom}
/**
    Return a string representation of this node for debugging
    purposes.
    */toString(){if(this.type.spec.toDebugString)return this.type.spec.toDebugString(this);let name=this.type.name;return this.content.size&&(name+="("+this.content.toStringInner()+")"),wrapMarks(this.marks,name)}
/**
    Get the content match in this node at the given index.
    */contentMatchAt(index){let match=this.type.contentMatch.matchFragment(this.content,0,index);if(!match)throw new Error("Called contentMatchAt on a node with invalid content");return match}
/**
    Test whether replacing the range between `from` and `to` (by
    child index) with the given replacement fragment (which defaults
    to the empty fragment) would leave the node's content valid. You
    can optionally pass `start` and `end` indices into the
    replacement fragment.
    */canReplace(from,to,replacement=Fragment.empty,start=0,end=replacement.childCount){let one=this.contentMatchAt(from).matchFragment(replacement,start,end),two=one&&one.matchFragment(this.content,to);if(!two||!two.validEnd)return!1;for(let i=start;i<end;i++)if(!this.type.allowsMarks(replacement.child(i).marks))return!1;return!0}
/**
    Test whether replacing the range `from` to `to` (by index) with
    a node of the given type would leave the node's content valid.
    */canReplaceWith(from,to,type,marks){if(marks&&!this.type.allowsMarks(marks))return!1;let start=this.contentMatchAt(from).matchType(type),end=start&&start.matchFragment(this.content,to);return!!end&&end.validEnd}
/**
    Test whether the given node's content could be appended to this
    node. If that node is empty, this will only return true if there
    is at least one node type that can appear in both nodes (to avoid
    merging completely incompatible nodes).
    */canAppend(other){return other.content.size?this.canReplace(this.childCount,this.childCount,other.content):this.type.compatibleContent(other.type)}
/**
    Check whether this node and its descendants conform to the
    schema, and raise error when they do not.
    */check(){this.type.checkContent(this.content);let copy=Mark.none;for(let i=0;i<this.marks.length;i++)copy=this.marks[i].addToSet(copy);if(!Mark.sameSet(copy,this.marks))throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m=>m.type.name))}`);this.content.forEach((node=>node.check()))}
/**
    Return a JSON-serializeable representation of this node.
    */toJSON(){let obj={type:this.type.name};for(let _ in this.attrs){obj.attrs=this.attrs;break}return this.content.size&&(obj.content=this.content.toJSON()),this.marks.length&&(obj.marks=this.marks.map((n=>n.toJSON()))),obj}
/**
    Deserialize a node from its JSON representation.
    */static fromJSON(schema,json){if(!json)throw new RangeError("Invalid input for Node.fromJSON");let marks=null;if(json.marks){if(!Array.isArray(json.marks))throw new RangeError("Invalid mark data for Node.fromJSON");marks=json.marks.map(schema.markFromJSON)}if("text"==json.type){if("string"!=typeof json.text)throw new RangeError("Invalid text node in JSON");return schema.text(json.text,marks)}let content=Fragment.fromJSON(schema,json.content);return schema.nodeType(json.type).create(json.attrs,content,marks)}}Node.prototype.text=void 0;class TextNode extends Node{
/**
    @internal
    */
constructor(type,attrs,content,marks){if(super(type,attrs,null,marks),!content)throw new RangeError("Empty text nodes are not allowed");this.text=content}toString(){return this.type.spec.toDebugString?this.type.spec.toDebugString(this):wrapMarks(this.marks,JSON.stringify(this.text))}get textContent(){return this.text}textBetween(from,to){return this.text.slice(from,to)}get nodeSize(){return this.text.length}mark(marks){return marks==this.marks?this:new TextNode(this.type,this.attrs,this.text,marks)}withText(text){return text==this.text?this:new TextNode(this.type,this.attrs,text,this.marks)}cut(from=0,to=this.text.length){return 0==from&&to==this.text.length?this:this.withText(this.text.slice(from,to))}eq(other){return this.sameMarkup(other)&&this.text==other.text}toJSON(){let base=super.toJSON();return base.text=this.text,base}}function wrapMarks(marks,str){for(let i=marks.length-1;i>=0;i--)str=marks[i].type.name+"("+str+")";return str}
/**
Instances of this class represent a match state of a node type's
[content expression](https://prosemirror.net/docs/ref/#model.NodeSpec.content), and can be used to
find out whether further content matches here, and whether a given
position is a valid end of the node.
*/class ContentMatch{
/**
    @internal
    */
constructor(
/**
    True when this match state represents a valid end of the node.
    */
validEnd){this.validEnd=validEnd,
/**
        @internal
        */
this.next=[],
/**
        @internal
        */
this.wrapCache=[]}
/**
    @internal
    */static parse(string,nodeTypes){let stream=new TokenStream(string,nodeTypes);if(null==stream.next)return ContentMatch.empty;let expr=parseExpr(stream);stream.next&&stream.err("Unexpected trailing text");let match=dfa(nfa(expr));return checkForDeadEnds(match,stream),match}
/**
    Match a node type, returning a match after that node if
    successful.
    */matchType(type){for(let i=0;i<this.next.length;i++)if(this.next[i].type==type)return this.next[i].next;return null}
/**
    Try to match a fragment. Returns the resulting match when
    successful.
    */matchFragment(frag,start=0,end=frag.childCount){let cur=this;for(let i=start;cur&&i<end;i++)cur=cur.matchType(frag.child(i).type);return cur}
/**
    @internal
    */get inlineContent(){return 0!=this.next.length&&this.next[0].type.isInline}
/**
    Get the first matching node type at this match position that can
    be generated.
    */get defaultType(){for(let i=0;i<this.next.length;i++){let{type:type}=this.next[i];if(!type.isText&&!type.hasRequiredAttrs())return type}return null}
/**
    @internal
    */compatible(other){for(let i=0;i<this.next.length;i++)for(let j=0;j<other.next.length;j++)if(this.next[i].type==other.next[j].type)return!0;return!1}
/**
    Try to match the given fragment, and if that fails, see if it can
    be made to match by inserting nodes in front of it. When
    successful, return a fragment of inserted nodes (which may be
    empty if nothing had to be inserted). When `toEnd` is true, only
    return a fragment if the resulting match goes to the end of the
    content expression.
    */fillBefore(after,toEnd=!1,startIndex=0){let seen=[this];function search(match,types){let finished=match.matchFragment(after,startIndex);if(finished&&(!toEnd||finished.validEnd))return Fragment.from(types.map((tp=>tp.createAndFill())));for(let i=0;i<match.next.length;i++){let{type:type,next:next}=match.next[i];if(!type.isText&&!type.hasRequiredAttrs()&&-1==seen.indexOf(next)){seen.push(next);let found=search(next,types.concat(type));if(found)return found}}return null}return search(this,[])}
/**
    Find a set of wrapping node types that would allow a node of the
    given type to appear at this position. The result may be empty
    (when it fits directly) and will be null when no such wrapping
    exists.
    */findWrapping(target){for(let i=0;i<this.wrapCache.length;i+=2)if(this.wrapCache[i]==target)return this.wrapCache[i+1];let computed=this.computeWrapping(target);return this.wrapCache.push(target,computed),computed}
/**
    @internal
    */computeWrapping(target){let seen=Object.create(null),active=[{match:this,type:null,via:null}];while(active.length){let current=active.shift(),match=current.match;if(match.matchType(target)){let result=[];for(let obj=current;obj.type;obj=obj.via)result.push(obj.type);return result.reverse()}for(let i=0;i<match.next.length;i++){let{type:type,next:next}=match.next[i];type.isLeaf||type.hasRequiredAttrs()||type.name in seen||current.type&&!next.validEnd||(active.push({match:type.contentMatch,type:type,via:current}),seen[type.name]=!0)}}return null}
/**
    The number of outgoing edges this node has in the finite
    automaton that describes the content expression.
    */get edgeCount(){return this.next.length}
/**
    Get the _n_​th outgoing edge from this node in the finite
    automaton that describes the content expression.
    */edge(n){if(n>=this.next.length)throw new RangeError(`There's no ${n}th edge in this content match`);return this.next[n]}
/**
    @internal
    */toString(){let seen=[];function scan(m){seen.push(m);for(let i=0;i<m.next.length;i++)-1==seen.indexOf(m.next[i].next)&&scan(m.next[i].next)}return scan(this),seen.map(((m,i)=>{let out=i+(m.validEnd?"*":" ")+" ";for(let i=0;i<m.next.length;i++)out+=(i?", ":"")+m.next[i].type.name+"->"+seen.indexOf(m.next[i].next);return out})).join("\n")}}
/**
@internal
*/ContentMatch.empty=new ContentMatch(!0);class TokenStream{constructor(string,nodeTypes){this.string=string,this.nodeTypes=nodeTypes,this.inline=null,this.pos=0,this.tokens=string.split(/\s*(?=\b|\W|$)/),""==this.tokens[this.tokens.length-1]&&this.tokens.pop(),""==this.tokens[0]&&this.tokens.shift()}get next(){return this.tokens[this.pos]}eat(tok){return this.next==tok&&(this.pos++||!0)}err(str){throw new SyntaxError(str+" (in content expression '"+this.string+"')")}}function parseExpr(stream){let exprs=[];do{exprs.push(parseExprSeq(stream))}while(stream.eat("|"));return 1==exprs.length?exprs[0]:{type:"choice",exprs:exprs}}function parseExprSeq(stream){let exprs=[];do{exprs.push(parseExprSubscript(stream))}while(stream.next&&")"!=stream.next&&"|"!=stream.next);return 1==exprs.length?exprs[0]:{type:"seq",exprs:exprs}}function parseExprSubscript(stream){let expr=parseExprAtom(stream);for(;;)if(stream.eat("+"))expr={type:"plus",expr:expr};else if(stream.eat("*"))expr={type:"star",expr:expr};else if(stream.eat("?"))expr={type:"opt",expr:expr};else{if(!stream.eat("{"))break;expr=parseExprRange(stream,expr)}return expr}function parseNum(stream){/\D/.test(stream.next)&&stream.err("Expected number, got '"+stream.next+"'");let result=Number(stream.next);return stream.pos++,result}function parseExprRange(stream,expr){let min=parseNum(stream),max=min;return stream.eat(",")&&(max="}"!=stream.next?parseNum(stream):-1),stream.eat("}")||stream.err("Unclosed braced range"),{type:"range",min:min,max:max,expr:expr}}function resolveName(stream,name){let types=stream.nodeTypes,type=types[name];if(type)return[type];let result=[];for(let typeName in types){let type=types[typeName];type.groups.indexOf(name)>-1&&result.push(type)}return 0==result.length&&stream.err("No node type or group '"+name+"' found"),result}function parseExprAtom(stream){if(stream.eat("(")){let expr=parseExpr(stream);return stream.eat(")")||stream.err("Missing closing paren"),expr}if(!/\W/.test(stream.next)){let exprs=resolveName(stream,stream.next).map((type=>(null==stream.inline?stream.inline=type.isInline:stream.inline!=type.isInline&&stream.err("Mixing inline and block content"),{type:"name",value:type})));return stream.pos++,1==exprs.length?exprs[0]:{type:"choice",exprs:exprs}}stream.err("Unexpected token '"+stream.next+"'")}
/**
Construct an NFA from an expression as returned by the parser. The
NFA is represented as an array of states, which are themselves
arrays of edges, which are `{term, to}` objects. The first state is
the entry state and the last node is the success state.

Note that unlike typical NFAs, the edge ordering in this one is
significant, in that it is used to contruct filler content when
necessary.
*/function nfa(expr){let nfa=[[]];return connect(compile(expr,0),node()),nfa;function node(){return nfa.push([])-1}function edge(from,to,term){let edge={term:term,to:to};return nfa[from].push(edge),edge}function connect(edges,to){edges.forEach((edge=>edge.to=to))}function compile(expr,from){if("choice"==expr.type)return expr.exprs.reduce(((out,expr)=>out.concat(compile(expr,from))),[]);if("seq"!=expr.type){if("star"==expr.type){let loop=node();return edge(from,loop),connect(compile(expr.expr,loop),loop),[edge(loop)]}if("plus"==expr.type){let loop=node();return connect(compile(expr.expr,from),loop),connect(compile(expr.expr,loop),loop),[edge(loop)]}if("opt"==expr.type)return[edge(from)].concat(compile(expr.expr,from));if("range"==expr.type){let cur=from;for(let i=0;i<expr.min;i++){let next=node();connect(compile(expr.expr,cur),next),cur=next}if(-1==expr.max)connect(compile(expr.expr,cur),cur);else for(let i=expr.min;i<expr.max;i++){let next=node();edge(cur,next),connect(compile(expr.expr,cur),next),cur=next}return[edge(cur)]}if("name"==expr.type)return[edge(from,void 0,expr.value)];throw new Error("Unknown expr type")}for(let i=0;;i++){let next=compile(expr.exprs[i],from);if(i==expr.exprs.length-1)return next;connect(next,from=node())}}}function cmp(a,b){return b-a}
// Get the set of nodes reachable by null edges from `node`. Omit
// nodes with only a single null-out-edge, since they may lead to
// needless duplicated nodes.
function nullFrom(nfa,node){let result=[];return scan(node),result.sort(cmp);function scan(node){let edges=nfa[node];if(1==edges.length&&!edges[0].term)return scan(edges[0].to);result.push(node);for(let i=0;i<edges.length;i++){let{term:term,to:to}=edges[i];term||-1!=result.indexOf(to)||scan(to)}}}
// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set
// of state objects (`ContentMatch` instances) with transitions
// between them.
function dfa(nfa){let labeled=Object.create(null);return explore(nullFrom(nfa,0));function explore(states){let out=[];states.forEach((node=>{nfa[node].forEach((({term:term,to:to})=>{if(!term)return;let set;for(let i=0;i<out.length;i++)out[i][0]==term&&(set=out[i][1]);nullFrom(nfa,to).forEach((node=>{set||out.push([term,set=[]]),-1==set.indexOf(node)&&set.push(node)}))}))}));let state=labeled[states.join(",")]=new ContentMatch(states.indexOf(nfa.length-1)>-1);for(let i=0;i<out.length;i++){let states=out[i][1].sort(cmp);state.next.push({type:out[i][0],next:labeled[states.join(",")]||explore(states)})}return state}}function checkForDeadEnds(match,stream){for(let i=0,work=[match];i<work.length;i++){let state=work[i],dead=!state.validEnd,nodes=[];for(let j=0;j<state.next.length;j++){let{type:type,next:next}=state.next[j];nodes.push(type.name),!dead||type.isText||type.hasRequiredAttrs()||(dead=!1),-1==work.indexOf(next)&&work.push(next)}dead&&stream.err("Only non-generatable nodes ("+nodes.join(", ")+") in a required position (see https://prosemirror.net/docs/guide/#generatable)")}}
// For node types where all attrs have a default value (or which don't
// have any attributes), build up a single reusable default attribute
// object, and use it for all nodes that don't specify specific
// attributes.
function defaultAttrs(attrs){let defaults=Object.create(null);for(let attrName in attrs){let attr=attrs[attrName];if(!attr.hasDefault)return null;defaults[attrName]=attr.default}return defaults}function computeAttrs(attrs,value){let built=Object.create(null);for(let name in attrs){let given=value&&value[name];if(void 0===given){let attr=attrs[name];if(!attr.hasDefault)throw new RangeError("No value supplied for attribute "+name);given=attr.default}built[name]=given}return built}function initAttrs(attrs){let result=Object.create(null);if(attrs)for(let name in attrs)result[name]=new Attribute(attrs[name]);return result}
/**
Node types are objects allocated once per `Schema` and used to
[tag](https://prosemirror.net/docs/ref/#model.Node.type) `Node` instances. They contain information
about the node type, such as its name and what kind of node it
represents.
*/class NodeType{
/**
    @internal
    */
constructor(
/**
    The name the node type has in this schema.
    */
name,
/**
    A link back to the `Schema` the node type belongs to.
    */
schema,
/**
    The spec that this type is based on
    */
spec){this.name=name,this.schema=schema,this.spec=spec,
/**
        The set of marks allowed in this node. `null` means all marks
        are allowed.
        */
this.markSet=null,this.groups=spec.group?spec.group.split(" "):[],this.attrs=initAttrs(spec.attrs),this.defaultAttrs=defaultAttrs(this.attrs),this.contentMatch=null,this.inlineContent=null,this.isBlock=!(spec.inline||"text"==name),this.isText="text"==name}
/**
    True if this is an inline type.
    */get isInline(){return!this.isBlock}
/**
    True if this is a textblock type, a block that contains inline
    content.
    */get isTextblock(){return this.isBlock&&this.inlineContent}
/**
    True for node types that allow no content.
    */get isLeaf(){return this.contentMatch==ContentMatch.empty}
/**
    True when this node is an atom, i.e. when it does not have
    directly editable content.
    */get isAtom(){return this.isLeaf||!!this.spec.atom}
/**
    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
    */get whitespace(){return this.spec.whitespace||(this.spec.code?"pre":"normal")}
/**
    Tells you whether this node type has any required attributes.
    */hasRequiredAttrs(){for(let n in this.attrs)if(this.attrs[n].isRequired)return!0;return!1}
/**
    Indicates whether this node allows some of the same content as
    the given node type.
    */compatibleContent(other){return this==other||this.contentMatch.compatible(other.contentMatch)}
/**
    @internal
    */computeAttrs(attrs){return!attrs&&this.defaultAttrs?this.defaultAttrs:computeAttrs(this.attrs,attrs)}
/**
    Create a `Node` of this type. The given attributes are
    checked and defaulted (you can pass `null` to use the type's
    defaults entirely, if no required attributes exist). `content`
    may be a `Fragment`, a node, an array of nodes, or
    `null`. Similarly `marks` may be `null` to default to the empty
    set of marks.
    */create(attrs=null,content,marks){if(this.isText)throw new Error("NodeType.create can't construct text nodes");return new Node(this,this.computeAttrs(attrs),Fragment.from(content),Mark.setFrom(marks))}
/**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
    against the node type's content restrictions, and throw an error
    if it doesn't match.
    */createChecked(attrs=null,content,marks){return content=Fragment.from(content),this.checkContent(content),new Node(this,this.computeAttrs(attrs),content,Mark.setFrom(marks))}
/**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
    necessary to add nodes to the start or end of the given fragment
    to make it fit the node. If no fitting wrapping can be found,
    return null. Note that, due to the fact that required nodes can
    always be created, this will always succeed if you pass null or
    `Fragment.empty` as content.
    */createAndFill(attrs=null,content,marks){if(attrs=this.computeAttrs(attrs),content=Fragment.from(content),content.size){let before=this.contentMatch.fillBefore(content);if(!before)return null;content=before.append(content)}let matched=this.contentMatch.matchFragment(content),after=matched&&matched.fillBefore(Fragment.empty,!0);return after?new Node(this,attrs,content.append(after),Mark.setFrom(marks)):null}
/**
    Returns true if the given fragment is valid content for this node
    type with the given attributes.
    */validContent(content){let result=this.contentMatch.matchFragment(content);if(!result||!result.validEnd)return!1;for(let i=0;i<content.childCount;i++)if(!this.allowsMarks(content.child(i).marks))return!1;return!0}
/**
    Throws a RangeError if the given fragment is not valid content for this
    node type.
    @internal
    */checkContent(content){if(!this.validContent(content))throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0,50)}`)}
/**
    Check whether the given mark type is allowed in this node.
    */allowsMarkType(markType){return null==this.markSet||this.markSet.indexOf(markType)>-1}
/**
    Test whether the given set of marks are allowed in this node.
    */allowsMarks(marks){if(null==this.markSet)return!0;for(let i=0;i<marks.length;i++)if(!this.allowsMarkType(marks[i].type))return!1;return!0}
/**
    Removes the marks that are not allowed in this node from the given set.
    */allowedMarks(marks){if(null==this.markSet)return marks;let copy;for(let i=0;i<marks.length;i++)this.allowsMarkType(marks[i].type)?copy&&copy.push(marks[i]):copy||(copy=marks.slice(0,i));return copy?copy.length?copy:Mark.none:marks}
/**
    @internal
    */static compile(nodes,schema){let result=Object.create(null);nodes.forEach(((name,spec)=>result[name]=new NodeType(name,schema,spec)));let topType=schema.spec.topNode||"doc";if(!result[topType])throw new RangeError("Schema is missing its top node type ('"+topType+"')");if(!result.text)throw new RangeError("Every schema needs a 'text' type");for(let _ in result.text.attrs)throw new RangeError("The text node type should not have attributes");return result}}
// Attribute descriptors
class Attribute{constructor(options){this.hasDefault=Object.prototype.hasOwnProperty.call(options,"default"),this.default=options.default}get isRequired(){return!this.hasDefault}}
// Marks
/**
Like nodes, marks (which are associated with nodes to signify
things like emphasis or being part of a link) are
[tagged](https://prosemirror.net/docs/ref/#model.Mark.type) with type objects, which are
instantiated once per `Schema`.
*/class MarkType{
/**
    @internal
    */
constructor(
/**
    The name of the mark type.
    */
name,
/**
    @internal
    */
rank,
/**
    The schema that this mark type instance is part of.
    */
schema,
/**
    The spec on which the type is based.
    */
spec){this.name=name,this.rank=rank,this.schema=schema,this.spec=spec,this.attrs=initAttrs(spec.attrs),this.excluded=null;let defaults=defaultAttrs(this.attrs);this.instance=defaults?new Mark(this,defaults):null}
/**
    Create a mark of this type. `attrs` may be `null` or an object
    containing only some of the mark's attributes. The others, if
    they have defaults, will be added.
    */create(attrs=null){return!attrs&&this.instance?this.instance:new Mark(this,computeAttrs(this.attrs,attrs))}
/**
    @internal
    */static compile(marks,schema){let result=Object.create(null),rank=0;return marks.forEach(((name,spec)=>result[name]=new MarkType(name,rank++,schema,spec))),result}
/**
    When there is a mark of this type in the given set, a new set
    without it is returned. Otherwise, the input set is returned.
    */removeFromSet(set){for(var i=0;i<set.length;i++)set[i].type==this&&(set=set.slice(0,i).concat(set.slice(i+1)),i--);return set}
/**
    Tests whether there is a mark of this type in the given set.
    */isInSet(set){for(let i=0;i<set.length;i++)if(set[i].type==this)return set[i]}
/**
    Queries whether a given mark type is
    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
    */excludes(other){return this.excluded.indexOf(other)>-1}}
/**
A document schema. Holds [node](https://prosemirror.net/docs/ref/#model.NodeType) and [mark
type](https://prosemirror.net/docs/ref/#model.MarkType) objects for the nodes and marks that may
occur in conforming documents, and provides functionality for
creating and deserializing such documents.

When given, the type parameters provide the names of the nodes and
marks in this schema.
*/class Schema{
/**
    Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
    */
constructor(spec){
/**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
this.cached=Object.create(null);let instanceSpec=this.spec={};for(let prop in spec)instanceSpec[prop]=spec[prop];instanceSpec.nodes=orderedmap__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */.Z.from(spec.nodes),instanceSpec.marks=orderedmap__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */.Z.from(spec.marks||{}),this.nodes=NodeType.compile(this.spec.nodes,this),this.marks=MarkType.compile(this.spec.marks,this);let contentExprCache=Object.create(null);for(let prop in this.nodes){if(prop in this.marks)throw new RangeError(prop+" can not be both a node and a mark");let type=this.nodes[prop],contentExpr=type.spec.content||"",markExpr=type.spec.marks;type.contentMatch=contentExprCache[contentExpr]||(contentExprCache[contentExpr]=ContentMatch.parse(contentExpr,this.nodes)),type.inlineContent=type.contentMatch.inlineContent,type.markSet="_"==markExpr?null:markExpr?gatherMarks(this,markExpr.split(" ")):""!=markExpr&&type.inlineContent?null:[]}for(let prop in this.marks){let type=this.marks[prop],excl=type.spec.excludes;type.excluded=null==excl?[type]:""==excl?[]:gatherMarks(this,excl.split(" "))}this.nodeFromJSON=this.nodeFromJSON.bind(this),this.markFromJSON=this.markFromJSON.bind(this),this.topNodeType=this.nodes[this.spec.topNode||"doc"],this.cached.wrappings=Object.create(null)}
/**
    Create a node in this schema. The `type` may be a string or a
    `NodeType` instance. Attributes will be extended with defaults,
    `content` may be a `Fragment`, `null`, a `Node`, or an array of
    nodes.
    */node(type,attrs=null,content,marks){if("string"==typeof type)type=this.nodeType(type);else{if(!(type instanceof NodeType))throw new RangeError("Invalid node type: "+type);if(type.schema!=this)throw new RangeError("Node type from different schema used ("+type.name+")")}return type.createChecked(attrs,content,marks)}
/**
    Create a text node in the schema. Empty text nodes are not
    allowed.
    */text(text,marks){let type=this.nodes.text;return new TextNode(type,type.defaultAttrs,text,Mark.setFrom(marks))}
/**
    Create a mark with the given type and attributes.
    */mark(type,attrs){return"string"==typeof type&&(type=this.marks[type]),type.create(attrs)}
/**
    Deserialize a node from its JSON representation. This method is
    bound.
    */nodeFromJSON(json){return Node.fromJSON(this,json)}
/**
    Deserialize a mark from its JSON representation. This method is
    bound.
    */markFromJSON(json){return Mark.fromJSON(this,json)}
/**
    @internal
    */nodeType(name){let found=this.nodes[name];if(!found)throw new RangeError("Unknown node type: "+name);return found}}function gatherMarks(schema,marks){let found=[];for(let i=0;i<marks.length;i++){let name=marks[i],mark=schema.marks[name],ok=mark;if(mark)found.push(mark);else for(let prop in schema.marks){let mark=schema.marks[prop];("_"==name||mark.spec.group&&mark.spec.group.split(" ").indexOf(name)>-1)&&found.push(ok=mark)}if(!ok)throw new SyntaxError("Unknown mark type: '"+marks[i]+"'")}return found}
/**
A DOM parser represents a strategy for parsing DOM content into a
ProseMirror document conforming to a given schema. Its behavior is
defined by an array of [rules](https://prosemirror.net/docs/ref/#model.ParseRule).
*/class DOMParser{
/**
    Create a parser that targets the given schema, using the given
    parsing rules.
    */
constructor(
/**
    The schema into which the parser parses.
    */
schema,
/**
    The set of [parse rules](https://prosemirror.net/docs/ref/#model.ParseRule) that the parser
    uses, in order of precedence.
    */
rules){this.schema=schema,this.rules=rules,
/**
        @internal
        */
this.tags=[],
/**
        @internal
        */
this.styles=[],rules.forEach((rule=>{rule.tag?this.tags.push(rule):rule.style&&this.styles.push(rule)})),
// Only normalize list elements when lists in the schema can't directly contain themselves
this.normalizeLists=!this.tags.some((r=>{if(!/^(ul|ol)\b/.test(r.tag)||!r.node)return!1;let node=schema.nodes[r.node];return node.contentMatch.matchType(node)}))}
/**
    Parse a document from the content of a DOM node.
    */parse(dom,options={}){let context=new ParseContext(this,options,!1);return context.addAll(dom,options.from,options.to),context.finish()}
/**
    Parses the content of the given DOM node, like
    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
    options. But unlike that method, which produces a whole node,
    this one returns a slice that is open at the sides, meaning that
    the schema constraints aren't applied to the start of nodes to
    the left of the input and the end of nodes at the end.
    */parseSlice(dom,options={}){let context=new ParseContext(this,options,!0);return context.addAll(dom,options.from,options.to),Slice.maxOpen(context.finish())}
/**
    @internal
    */matchTag(dom,context,after){for(let i=after?this.tags.indexOf(after)+1:0;i<this.tags.length;i++){let rule=this.tags[i];if(matches(dom,rule.tag)&&(void 0===rule.namespace||dom.namespaceURI==rule.namespace)&&(!rule.context||context.matchesContext(rule.context))){if(rule.getAttrs){let result=rule.getAttrs(dom);if(!1===result)continue;rule.attrs=result||void 0}return rule}}}
/**
    @internal
    */matchStyle(prop,value,context,after){for(let i=after?this.styles.indexOf(after)+1:0;i<this.styles.length;i++){let rule=this.styles[i],style=rule.style;if(!(0!=style.indexOf(prop)||rule.context&&!context.matchesContext(rule.context)||
// Test that the style string either precisely matches the prop,
// or has an '=' sign after the prop, followed by the given
// value.
style.length>prop.length&&(61!=style.charCodeAt(prop.length)||style.slice(prop.length+1)!=value))){if(rule.getAttrs){let result=rule.getAttrs(value);if(!1===result)continue;rule.attrs=result||void 0}return rule}}}
/**
    @internal
    */static schemaRules(schema){let result=[];function insert(rule){let priority=null==rule.priority?50:rule.priority,i=0;for(;i<result.length;i++){let next=result[i],nextPriority=null==next.priority?50:next.priority;if(nextPriority<priority)break}result.splice(i,0,rule)}for(let name in schema.marks){let rules=schema.marks[name].spec.parseDOM;rules&&rules.forEach((rule=>{insert(rule=copy(rule)),rule.mark||rule.ignore||rule.clearMark||(rule.mark=name)}))}for(let name in schema.nodes){let rules=schema.nodes[name].spec.parseDOM;rules&&rules.forEach((rule=>{insert(rule=copy(rule)),rule.node||rule.ignore||rule.mark||(rule.node=name)}))}return result}
/**
    Construct a DOM parser using the parsing rules listed in a
    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
    */static fromSchema(schema){return schema.cached.domParser||(schema.cached.domParser=new DOMParser(schema,DOMParser.schemaRules(schema)))}}const blockTags={address:!0,article:!0,aside:!0,blockquote:!0,canvas:!0,dd:!0,div:!0,dl:!0,fieldset:!0,figcaption:!0,figure:!0,footer:!0,form:!0,h1:!0,h2:!0,h3:!0,h4:!0,h5:!0,h6:!0,header:!0,hgroup:!0,hr:!0,li:!0,noscript:!0,ol:!0,output:!0,p:!0,pre:!0,section:!0,table:!0,tfoot:!0,ul:!0},ignoreTags={head:!0,noscript:!0,object:!0,script:!0,style:!0,title:!0},listTags={ol:!0,ul:!0},OPT_PRESERVE_WS=1,OPT_PRESERVE_WS_FULL=2,OPT_OPEN_LEFT=4;function wsOptionsFor(type,preserveWhitespace,base){return null!=preserveWhitespace?(preserveWhitespace?OPT_PRESERVE_WS:0)|("full"===preserveWhitespace?OPT_PRESERVE_WS_FULL:0):type&&"pre"==type.whitespace?OPT_PRESERVE_WS|OPT_PRESERVE_WS_FULL:base&~OPT_OPEN_LEFT}class NodeContext{constructor(type,attrs,
// Marks applied to this node itself
marks,
// Marks that can't apply here, but will be used in children if possible
pendingMarks,solid,match,options){this.type=type,this.attrs=attrs,this.marks=marks,this.pendingMarks=pendingMarks,this.solid=solid,this.options=options,this.content=[],
// Marks applied to the node's children
this.activeMarks=Mark.none,
// Nested Marks with same type
this.stashMarks=[],this.match=match||(options&OPT_OPEN_LEFT?null:type.contentMatch)}findWrapping(node){if(!this.match){if(!this.type)return[];let fill=this.type.contentMatch.fillBefore(Fragment.from(node));if(!fill){let wrap,start=this.type.contentMatch;return(wrap=start.findWrapping(node.type))?(this.match=start,wrap):null}this.match=this.type.contentMatch.matchFragment(fill)}return this.match.findWrapping(node.type)}finish(openEnd){if(!(this.options&OPT_PRESERVE_WS)){// Strip trailing whitespace
let m,last=this.content[this.content.length-1];if(last&&last.isText&&(m=/[ \t\r\n\u000c]+$/.exec(last.text))){let text=last;last.text.length==m[0].length?this.content.pop():this.content[this.content.length-1]=text.withText(text.text.slice(0,text.text.length-m[0].length))}}let content=Fragment.from(this.content);return!openEnd&&this.match&&(content=content.append(this.match.fillBefore(Fragment.empty,!0))),this.type?this.type.create(this.attrs,content,this.marks):content}popFromStashMark(mark){for(let i=this.stashMarks.length-1;i>=0;i--)if(mark.eq(this.stashMarks[i]))return this.stashMarks.splice(i,1)[0]}applyPending(nextType){for(let i=0,pending=this.pendingMarks;i<pending.length;i++){let mark=pending[i];(this.type?this.type.allowsMarkType(mark.type):markMayApply(mark.type,nextType))&&!mark.isInSet(this.activeMarks)&&(this.activeMarks=mark.addToSet(this.activeMarks),this.pendingMarks=mark.removeFromSet(this.pendingMarks))}}inlineContext(node){return this.type?this.type.inlineContent:this.content.length?this.content[0].isInline:node.parentNode&&!blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase())}}class ParseContext{constructor(
// The parser we are using.
parser,
// The options passed to this parse.
options,isOpen){this.parser=parser,this.options=options,this.isOpen=isOpen,this.open=0;let topContext,topNode=options.topNode,topOptions=wsOptionsFor(null,options.preserveWhitespace,0)|(isOpen?OPT_OPEN_LEFT:0);topContext=topNode?new NodeContext(topNode.type,topNode.attrs,Mark.none,Mark.none,!0,options.topMatch||topNode.type.contentMatch,topOptions):new NodeContext(isOpen?null:parser.schema.topNodeType,null,Mark.none,Mark.none,!0,null,topOptions),this.nodes=[topContext],this.find=options.findPositions,this.needsBlock=!1}get top(){return this.nodes[this.open]}
// Add a DOM node to the content. Text is inserted as text node,
// otherwise, the node is passed to `addElement` or, if it has a
// `style` attribute, `addElementWithStyles`.
addDOM(dom){3==dom.nodeType?this.addTextNode(dom):1==dom.nodeType&&this.addElement(dom)}withStyleRules(dom,f){let style=dom.getAttribute("style");if(!style)return f();let marks=this.readStyles(parseStyles(style));if(!marks)return;// A style with ignore: true
let[addMarks,removeMarks]=marks,top=this.top;for(let i=0;i<removeMarks.length;i++)this.removePendingMark(removeMarks[i],top);for(let i=0;i<addMarks.length;i++)this.addPendingMark(addMarks[i]);f();for(let i=0;i<addMarks.length;i++)this.removePendingMark(addMarks[i],top);for(let i=0;i<removeMarks.length;i++)this.addPendingMark(removeMarks[i])}addTextNode(dom){let value=dom.nodeValue,top=this.top;if(top.options&OPT_PRESERVE_WS_FULL||top.inlineContext(dom)||/[^ \t\r\n\u000c]/.test(value)){if(top.options&OPT_PRESERVE_WS)value=top.options&OPT_PRESERVE_WS_FULL?value.replace(/\r\n?/g,"\n"):value.replace(/\r?\n|\r/g," ");else
// If this starts with whitespace, and there is no node before it, or
// a hard break, or a text node that ends with whitespace, strip the
// leading space.
if(value=value.replace(/[ \t\r\n\u000c]+/g," "),/^[ \t\r\n\u000c]/.test(value)&&this.open==this.nodes.length-1){let nodeBefore=top.content[top.content.length-1],domNodeBefore=dom.previousSibling;(!nodeBefore||domNodeBefore&&"BR"==domNodeBefore.nodeName||nodeBefore.isText&&/[ \t\r\n\u000c]$/.test(nodeBefore.text))&&(value=value.slice(1))}value&&this.insertNode(this.parser.schema.text(value)),this.findInText(dom)}else this.findInside(dom)}
// Try to find a handler for the given tag and use that to parse. If
// none is found, the element's content nodes are added directly.
addElement(dom,matchAfter){let ruleID,name=dom.nodeName.toLowerCase();listTags.hasOwnProperty(name)&&this.parser.normalizeLists&&normalizeList(dom);let rule=this.options.ruleFromNode&&this.options.ruleFromNode(dom)||(ruleID=this.parser.matchTag(dom,this,matchAfter));if(rule?rule.ignore:ignoreTags.hasOwnProperty(name))this.findInside(dom),this.ignoreFallback(dom);else if(!rule||rule.skip||rule.closeParent){rule&&rule.closeParent?this.open=Math.max(0,this.open-1):rule&&rule.skip.nodeType&&(dom=rule.skip);let sync,top=this.top,oldNeedsBlock=this.needsBlock;if(blockTags.hasOwnProperty(name))top.content.length&&top.content[0].isInline&&this.open&&(this.open--,top=this.top),sync=!0,top.type||(this.needsBlock=!0);else if(!dom.firstChild)return void this.leafFallback(dom);rule&&rule.skip?this.addAll(dom):this.withStyleRules(dom,(()=>this.addAll(dom))),sync&&this.sync(top),this.needsBlock=oldNeedsBlock}else this.withStyleRules(dom,(()=>{this.addElementByRule(dom,rule,!1===rule.consuming?ruleID:void 0)}))}
// Called for leaf DOM nodes that would otherwise be ignored
leafFallback(dom){"BR"==dom.nodeName&&this.top.type&&this.top.type.inlineContent&&this.addTextNode(dom.ownerDocument.createTextNode("\n"))}
// Called for ignored nodes
ignoreFallback(dom){
// Ignored BR nodes should at least create an inline context
"BR"!=dom.nodeName||this.top.type&&this.top.type.inlineContent||this.findPlace(this.parser.schema.text("-"))}
// Run any style parser associated with the node's styles. Either
// return an array of marks, or null to indicate some of the styles
// had a rule with `ignore` set.
readStyles(styles){let add=Mark.none,remove=Mark.none;for(let i=0;i<styles.length;i+=2)for(let after;;){let rule=this.parser.matchStyle(styles[i],styles[i+1],this,after);if(!rule)break;if(rule.ignore)return null;if(rule.clearMark?this.top.pendingMarks.concat(this.top.activeMarks).forEach((m=>{rule.clearMark(m)&&(remove=m.addToSet(remove))})):add=this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(add),!1!==rule.consuming)break;after=rule}return[add,remove]}
// Look up a handler for the given node. If none are found, return
// false. Otherwise, apply it, use its return value to drive the way
// the node's content is wrapped, and return true.
addElementByRule(dom,rule,continueAfter){let sync,nodeType,mark;if(rule.node)nodeType=this.parser.schema.nodes[rule.node],nodeType.isLeaf?this.insertNode(nodeType.create(rule.attrs))||this.leafFallback(dom):sync=this.enter(nodeType,rule.attrs||null,rule.preserveWhitespace);else{let markType=this.parser.schema.marks[rule.mark];mark=markType.create(rule.attrs),this.addPendingMark(mark)}let startIn=this.top;if(nodeType&&nodeType.isLeaf)this.findInside(dom);else if(continueAfter)this.addElement(dom,continueAfter);else if(rule.getContent)this.findInside(dom),rule.getContent(dom,this.parser.schema).forEach((node=>this.insertNode(node)));else{let contentDOM=dom;"string"==typeof rule.contentElement?contentDOM=dom.querySelector(rule.contentElement):"function"==typeof rule.contentElement?contentDOM=rule.contentElement(dom):rule.contentElement&&(contentDOM=rule.contentElement),this.findAround(dom,contentDOM,!0),this.addAll(contentDOM)}sync&&this.sync(startIn)&&this.open--,mark&&this.removePendingMark(mark,startIn)}
// Add all child nodes between `startIndex` and `endIndex` (or the
// whole node, if not given). If `sync` is passed, use it to
// synchronize after every block element.
addAll(parent,startIndex,endIndex){let index=startIndex||0;for(let dom=startIndex?parent.childNodes[startIndex]:parent.firstChild,end=null==endIndex?null:parent.childNodes[endIndex];dom!=end;dom=dom.nextSibling,++index)this.findAtPoint(parent,index),this.addDOM(dom);this.findAtPoint(parent,index)}
// Try to find a way to fit the given node type into the current
// context. May add intermediate wrappers and/or leave non-solid
// nodes that we're in.
findPlace(node){let route,sync;for(let depth=this.open;depth>=0;depth--){let cx=this.nodes[depth],found=cx.findWrapping(node);if(found&&(!route||route.length>found.length)&&(route=found,sync=cx,!found.length))break;if(cx.solid)break}if(!route)return!1;this.sync(sync);for(let i=0;i<route.length;i++)this.enterInner(route[i],null,!1);return!0}
// Try to insert the given node, adjusting the context when needed.
insertNode(node){if(node.isInline&&this.needsBlock&&!this.top.type){let block=this.textblockFromContext();block&&this.enterInner(block)}if(this.findPlace(node)){this.closeExtra();let top=this.top;top.applyPending(node.type),top.match&&(top.match=top.match.matchType(node.type));let marks=top.activeMarks;for(let i=0;i<node.marks.length;i++)top.type&&!top.type.allowsMarkType(node.marks[i].type)||(marks=node.marks[i].addToSet(marks));return top.content.push(node.mark(marks)),!0}return!1}
// Try to start a node of the given type, adjusting the context when
// necessary.
enter(type,attrs,preserveWS){let ok=this.findPlace(type.create(attrs));return ok&&this.enterInner(type,attrs,!0,preserveWS),ok}
// Open a node of the given type
enterInner(type,attrs=null,solid=!1,preserveWS){this.closeExtra();let top=this.top;top.applyPending(type),top.match=top.match&&top.match.matchType(type);let options=wsOptionsFor(type,preserveWS,top.options);top.options&OPT_OPEN_LEFT&&0==top.content.length&&(options|=OPT_OPEN_LEFT),this.nodes.push(new NodeContext(type,attrs,top.activeMarks,top.pendingMarks,solid,null,options)),this.open++}
// Make sure all nodes above this.open are finished and added to
// their parents
closeExtra(openEnd=!1){let i=this.nodes.length-1;if(i>this.open){for(;i>this.open;i--)this.nodes[i-1].content.push(this.nodes[i].finish(openEnd));this.nodes.length=this.open+1}}finish(){return this.open=0,this.closeExtra(this.isOpen),this.nodes[0].finish(this.isOpen||this.options.topOpen)}sync(to){for(let i=this.open;i>=0;i--)if(this.nodes[i]==to)return this.open=i,!0;return!1}get currentPos(){this.closeExtra();let pos=0;for(let i=this.open;i>=0;i--){let content=this.nodes[i].content;for(let j=content.length-1;j>=0;j--)pos+=content[j].nodeSize;i&&pos++}return pos}findAtPoint(parent,offset){if(this.find)for(let i=0;i<this.find.length;i++)this.find[i].node==parent&&this.find[i].offset==offset&&(this.find[i].pos=this.currentPos)}findInside(parent){if(this.find)for(let i=0;i<this.find.length;i++)null==this.find[i].pos&&1==parent.nodeType&&parent.contains(this.find[i].node)&&(this.find[i].pos=this.currentPos)}findAround(parent,content,before){if(parent!=content&&this.find)for(let i=0;i<this.find.length;i++)if(null==this.find[i].pos&&1==parent.nodeType&&parent.contains(this.find[i].node)){let pos=content.compareDocumentPosition(this.find[i].node);pos&(before?2:4)&&(this.find[i].pos=this.currentPos)}}findInText(textNode){if(this.find)for(let i=0;i<this.find.length;i++)this.find[i].node==textNode&&(this.find[i].pos=this.currentPos-(textNode.nodeValue.length-this.find[i].offset))}
// Determines whether the given context string matches this context.
matchesContext(context){if(context.indexOf("|")>-1)return context.split(/\s*\|\s*/).some(this.matchesContext,this);let parts=context.split("/"),option=this.options.context,useRoot=!this.isOpen&&(!option||option.parent.type==this.nodes[0].type),minDepth=-(option?option.depth+1:0)+(useRoot?0:1),match=(i,depth)=>{for(;i>=0;i--){let part=parts[i];if(""==part){if(i==parts.length-1||0==i)continue;for(;depth>=minDepth;depth--)if(match(i-1,depth))return!0;return!1}{let next=depth>0||0==depth&&useRoot?this.nodes[depth].type:option&&depth>=minDepth?option.node(depth-minDepth).type:null;if(!next||next.name!=part&&-1==next.groups.indexOf(part))return!1;depth--}}return!0};return match(parts.length-1,this.open)}textblockFromContext(){let $context=this.options.context;if($context)for(let d=$context.depth;d>=0;d--){let deflt=$context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;if(deflt&&deflt.isTextblock&&deflt.defaultAttrs)return deflt}for(let name in this.parser.schema.nodes){let type=this.parser.schema.nodes[name];if(type.isTextblock&&type.defaultAttrs)return type}}addPendingMark(mark){let found=findSameMarkInSet(mark,this.top.pendingMarks);found&&this.top.stashMarks.push(found),this.top.pendingMarks=mark.addToSet(this.top.pendingMarks)}removePendingMark(mark,upto){for(let depth=this.open;depth>=0;depth--){let level=this.nodes[depth],found=level.pendingMarks.lastIndexOf(mark);if(found>-1)level.pendingMarks=mark.removeFromSet(level.pendingMarks);else{level.activeMarks=mark.removeFromSet(level.activeMarks);let stashMark=level.popFromStashMark(mark);stashMark&&level.type&&level.type.allowsMarkType(stashMark.type)&&(level.activeMarks=stashMark.addToSet(level.activeMarks))}if(level==upto)break}}}
// Kludge to work around directly nested list nodes produced by some
// tools and allowed by browsers to mean that the nested list is
// actually part of the list item above it.
function normalizeList(dom){for(let child=dom.firstChild,prevItem=null;child;child=child.nextSibling){let name=1==child.nodeType?child.nodeName.toLowerCase():null;name&&listTags.hasOwnProperty(name)&&prevItem?(prevItem.appendChild(child),child=prevItem):"li"==name?prevItem=child:name&&(prevItem=null)}}
// Apply a CSS selector.
function matches(dom,selector){return(dom.matches||dom.msMatchesSelector||dom.webkitMatchesSelector||dom.mozMatchesSelector).call(dom,selector)}
// Tokenize a style attribute into property/value pairs.
function parseStyles(style){let m,re=/\s*([\w-]+)\s*:\s*([^;]+)/g,result=[];while(m=re.exec(style))result.push(m[1],m[2].trim());return result}function copy(obj){let copy={};for(let prop in obj)copy[prop]=obj[prop];return copy}
// Used when finding a mark at the top level of a fragment parse.
// Checks whether it would be reasonable to apply a given mark type to
// a given node, by looking at the way the mark occurs in the schema.
function markMayApply(markType,nodeType){let nodes=nodeType.schema.nodes;for(let name in nodes){let parent=nodes[name];if(!parent.allowsMarkType(markType))continue;let seen=[],scan=match=>{seen.push(match);for(let i=0;i<match.edgeCount;i++){let{type:type,next:next}=match.edge(i);if(type==nodeType)return!0;if(seen.indexOf(next)<0&&scan(next))return!0}};if(scan(parent.contentMatch))return!0}}function findSameMarkInSet(mark,set){for(let i=0;i<set.length;i++)if(mark.eq(set[i]))return set[i]}
/**
A DOM serializer knows how to convert ProseMirror nodes and
marks of various types to DOM nodes.
*/class DOMSerializer{
/**
    Create a serializer. `nodes` should map node names to functions
    that take a node and return a description of the corresponding
    DOM. `marks` does the same for mark names, but also gets an
    argument that tells it whether the mark's content is block or
    inline content (for typical use, it'll always be inline). A mark
    serializer may be `null` to indicate that marks of that type
    should not be serialized.
    */
constructor(
/**
    The node serialization functions.
    */
nodes,
/**
    The mark serialization functions.
    */
marks){this.nodes=nodes,this.marks=marks}
/**
    Serialize the content of this fragment to a DOM fragment. When
    not in the browser, the `document` option, containing a DOM
    document, should be passed so that the serializer can create
    nodes.
    */serializeFragment(fragment,options={},target){target||(target=doc(options).createDocumentFragment());let top=target,active=[];return fragment.forEach((node=>{if(active.length||node.marks.length){let keep=0,rendered=0;while(keep<active.length&&rendered<node.marks.length){let next=node.marks[rendered];if(this.marks[next.type.name]){if(!next.eq(active[keep][0])||!1===next.type.spec.spanning)break;keep++,rendered++}else rendered++}while(keep<active.length)top=active.pop()[1];while(rendered<node.marks.length){let add=node.marks[rendered++],markDOM=this.serializeMark(add,node.isInline,options);markDOM&&(active.push([add,top]),top.appendChild(markDOM.dom),top=markDOM.contentDOM||markDOM.dom)}}top.appendChild(this.serializeNodeInner(node,options))})),target}
/**
    @internal
    */serializeNodeInner(node,options){let{dom:dom,contentDOM:contentDOM}=DOMSerializer.renderSpec(doc(options),this.nodes[node.type.name](node));if(contentDOM){if(node.isLeaf)throw new RangeError("Content hole not allowed in a leaf node spec");this.serializeFragment(node.content,options,contentDOM)}return dom}
/**
    Serialize this node to a DOM node. This can be useful when you
    need to serialize a part of a document, as opposed to the whole
    document. To serialize a whole document, use
    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
    its [content](https://prosemirror.net/docs/ref/#model.Node.content).
    */serializeNode(node,options={}){let dom=this.serializeNodeInner(node,options);for(let i=node.marks.length-1;i>=0;i--){let wrap=this.serializeMark(node.marks[i],node.isInline,options);wrap&&((wrap.contentDOM||wrap.dom).appendChild(dom),dom=wrap.dom)}return dom}
/**
    @internal
    */serializeMark(mark,inline,options={}){let toDOM=this.marks[mark.type.name];return toDOM&&DOMSerializer.renderSpec(doc(options),toDOM(mark,inline))}
/**
    Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
    the spec has a hole (zero) in it, `contentDOM` will point at the
    node with the hole.
    */static renderSpec(doc,structure,xmlNS=null){if("string"==typeof structure)return{dom:doc.createTextNode(structure)};if(null!=structure.nodeType)return{dom:structure};if(structure.dom&&null!=structure.dom.nodeType)return structure;let contentDOM,tagName=structure[0],space=tagName.indexOf(" ");space>0&&(xmlNS=tagName.slice(0,space),tagName=tagName.slice(space+1));let dom=xmlNS?doc.createElementNS(xmlNS,tagName):doc.createElement(tagName),attrs=structure[1],start=1;if(attrs&&"object"==typeof attrs&&null==attrs.nodeType&&!Array.isArray(attrs)){start=2;for(let name in attrs)if(null!=attrs[name]){let space=name.indexOf(" ");space>0?dom.setAttributeNS(name.slice(0,space),name.slice(space+1),attrs[name]):dom.setAttribute(name,attrs[name])}}for(let i=start;i<structure.length;i++){let child=structure[i];if(0===child){if(i<structure.length-1||i>start)throw new RangeError("Content hole must be the only child of its parent node");return{dom:dom,contentDOM:dom}}{let{dom:inner,contentDOM:innerContent}=DOMSerializer.renderSpec(doc,child,xmlNS);if(dom.appendChild(inner),innerContent){if(contentDOM)throw new RangeError("Multiple content holes");contentDOM=innerContent}}}return{dom:dom,contentDOM:contentDOM}}
/**
    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
    properties in a schema's node and mark specs.
    */static fromSchema(schema){return schema.cached.domSerializer||(schema.cached.domSerializer=new DOMSerializer(this.nodesFromSchema(schema),this.marksFromSchema(schema)))}
/**
    Gather the serializers in a schema's node specs into an object.
    This can be useful as a base to build a custom serializer from.
    */static nodesFromSchema(schema){let result=gatherToDOM(schema.nodes);return result.text||(result.text=node=>node.text),result}
/**
    Gather the serializers in a schema's mark specs into an object.
    */static marksFromSchema(schema){return gatherToDOM(schema.marks)}}function gatherToDOM(obj){let result={};for(let name in obj){let toDOM=obj[name].spec.toDOM;toDOM&&(result[name]=toDOM)}return result}function doc(options){return options.document||window.document}
/***/},
/***/153833:
/***/function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";
/* harmony export */__webpack_require__.d(__webpack_exports__,{
/* harmony export */IB:function(){/* binding */return liftListItem},
/* harmony export */KI:function(){/* binding */return wrapInList},
/* harmony export */bw:function(){/* binding */return sinkListItem}
/* harmony export */});
/* unused harmony exports addListNodes, bulletList, listItem, orderedList, splitListItem */
/* harmony import */var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(616560),prosemirror_model__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(759084);
/* harmony import */
/**
Returns a command function that wraps the selection in a list with
the given type an attributes. If `dispatch` is null, only return a
value to indicate whether this is possible, but don't actually
perform the change.
*/
function wrapInList(listType,attrs=null){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to),doJoin=!1,outerRange=range;if(!range)return!1;
// This is at the top of an existing list item
if(range.depth>=2&&$from.node(range.depth-1).type.compatibleContent(listType)&&0==range.startIndex){
// Don't do anything if this is the top of the list
if(0==$from.index(range.depth-1))return!1;let $insert=state.doc.resolve(range.start-2);outerRange=new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .NodeRange */.Ts($insert,$insert,range.depth),range.endIndex<range.parent.childCount&&(range=new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .NodeRange */.Ts($from,state.doc.resolve($to.end(range.depth)),range.depth)),doJoin=!0}let wrap=(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__/* .findWrapping */.nd)(outerRange,listType,attrs,range);return!!wrap&&(dispatch&&dispatch(doWrapInList(state.tr,range,wrap,doJoin,listType).scrollIntoView()),!0)}}function doWrapInList(tr,range,wrappers,joinBefore,listType){let content=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty;for(let i=wrappers.length-1;i>=0;i--)content=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(wrappers[i].type.create(wrappers[i].attrs,content));tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__/* .ReplaceAroundStep */.FC(range.start-(joinBefore?2:0),range.end,range.start,range.end,new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(content,0,0),wrappers.length,!0));let found=0;for(let i=0;i<wrappers.length;i++)wrappers[i].type==listType&&(found=i+1);let splitDepth=wrappers.length-found,splitPos=range.start+wrappers.length-(joinBefore?2:0),parent=range.parent;for(let i=range.startIndex,e=range.endIndex,first=!0;i<e;i++,first=!1)!first&&(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__/* .canSplit */.Ax)(tr.doc,splitPos,splitDepth)&&(tr.split(splitPos,splitDepth),splitPos+=2*splitDepth),splitPos+=parent.child(i).nodeSize;return tr}
/**
Build a command that splits a non-empty textblock at the top level
of a list item by also splitting that list item.
*/
/**
Create a command to lift the list item around the selection up into
a wrapping list.
*/
function liftListItem(itemType){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to,(node=>node.childCount>0&&node.firstChild.type==itemType));return!!range&&(!dispatch||($from.node(range.depth-1).type==itemType?liftToOuterList(state,dispatch,itemType,range):liftOutOfList(state,dispatch,range)))}}function liftToOuterList(state,dispatch,itemType,range){let tr=state.tr,end=range.end,endOfList=range.$to.end(range.depth);end<endOfList&&(
// There are siblings after the lifted items, which must become
// children of the last item
tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__/* .ReplaceAroundStep */.FC(end-1,endOfList,end,endOfList,new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(itemType.create(null,range.parent.copy())),1,0),1,!0)),range=new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .NodeRange */.Ts(tr.doc.resolve(range.$from.pos),tr.doc.resolve(endOfList),range.depth));const target=(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__/* .liftTarget */.k9)(range);if(null==target)return!1;tr.lift(range,target);let after=tr.mapping.map(end,-1)-1;return(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__/* .canJoin */.Mn)(tr.doc,after)&&tr.join(after),dispatch(tr.scrollIntoView()),!0}function liftOutOfList(state,dispatch,range){let tr=state.tr,list=range.parent;
// Merge the list items into a single big item
for(let pos=range.end,i=range.endIndex-1,e=range.startIndex;i>e;i--)pos-=list.child(i).nodeSize,tr.delete(pos-1,pos+1);let $start=tr.doc.resolve(range.start),item=$start.nodeAfter;if(tr.mapping.map(range.end)!=range.start+$start.nodeAfter.nodeSize)return!1;let atStart=0==range.startIndex,atEnd=range.endIndex==list.childCount,parent=$start.node(-1),indexBefore=$start.index(-1);if(!parent.canReplace(indexBefore+(atStart?0:1),indexBefore+1,item.content.append(atEnd?prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty:prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(list))))return!1;let start=$start.pos,end=start+item.nodeSize;
// Strip off the surrounding list. At the sides where we're not at
// the end of the list, the existing list is closed. At sides where
// this is the end, it is overwritten to its end.
return tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__/* .ReplaceAroundStep */.FC(start-(atStart?1:0),end+(atEnd?1:0),start+1,end-1,new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2((atStart?prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty:prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty))).append(atEnd?prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty:prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty))),atStart?0:1,atEnd?0:1),atStart?0:1)),dispatch(tr.scrollIntoView()),!0}
/**
Create a command to sink the list item around the selection down
into an inner list.
*/function sinkListItem(itemType){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to,(node=>node.childCount>0&&node.firstChild.type==itemType));if(!range)return!1;let startIndex=range.startIndex;if(0==startIndex)return!1;let parent=range.parent,nodeBefore=parent.child(startIndex-1);if(nodeBefore.type!=itemType)return!1;if(dispatch){let nestedBefore=nodeBefore.lastChild&&nodeBefore.lastChild.type==parent.type,inner=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(nestedBefore?itemType.create():null),slice=new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(itemType.create(null,prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(parent.type.create(null,inner)))),nestedBefore?3:1,0),before=range.start,after=range.end;dispatch(state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__/* .ReplaceAroundStep */.FC(before-(nestedBefore?3:1),after,before,after,slice,1,!0)).scrollIntoView())}return!0}}
/***/},
/***/102376:
/***/function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";
/* harmony export */__webpack_require__.d(__webpack_exports__,{
/* harmony export */Bs:function(){/* binding */return TextSelection},
/* harmony export */C1:function(){/* binding */return AllSelection},
/* harmony export */H$:function(){/* binding */return PluginKey},
/* harmony export */Sy:function(){/* binding */return Plugin},
/* harmony export */Y1:function(){/* binding */return Selection},
/* harmony export */qv:function(){/* binding */return NodeSelection},
/* harmony export */xm:function(){/* binding */return SelectionRange},
/* harmony export */yy:function(){/* binding */return EditorState}
/* harmony export */});
/* unused harmony export Transaction */
/* harmony import */var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(759084),prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(616560);
/* harmony import */const classesById=Object.create(null);
/**
Superclass for editor selections. Every selection type should
extend this. Should not be instantiated directly.
*/class Selection{
/**
    Initialize a selection with the head and anchor and ranges. If no
    ranges are given, constructs a single range across `$anchor` and
    `$head`.
    */
constructor(
/**
    The resolved anchor of the selection (the side that stays in
    place when the selection is modified).
    */
$anchor,
/**
    The resolved head of the selection (the side that moves when
    the selection is modified).
    */
$head,ranges){this.$anchor=$anchor,this.$head=$head,this.ranges=ranges||[new SelectionRange($anchor.min($head),$anchor.max($head))]}
/**
    The selection's anchor, as an unresolved position.
    */get anchor(){return this.$anchor.pos}
/**
    The selection's head.
    */get head(){return this.$head.pos}
/**
    The lower bound of the selection's main range.
    */get from(){return this.$from.pos}
/**
    The upper bound of the selection's main range.
    */get to(){return this.$to.pos}
/**
    The resolved lower  bound of the selection's main range.
    */get $from(){return this.ranges[0].$from}
/**
    The resolved upper bound of the selection's main range.
    */get $to(){return this.ranges[0].$to}
/**
    Indicates whether the selection contains any content.
    */get empty(){let ranges=this.ranges;for(let i=0;i<ranges.length;i++)if(ranges[i].$from.pos!=ranges[i].$to.pos)return!1;return!0}
/**
    Get the content of this selection as a slice.
    */content(){return this.$from.doc.slice(this.from,this.to,!0)}
/**
    Replace the selection with a slice or, if no slice is given,
    delete the selection. Will append to the given transaction.
    */replace(tr,content=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.empty){
// Put the new selection at the position after the inserted
// content. When that ended in an inline node, search backwards,
// to get the position after that node. If not, search forward.
let lastNode=content.content.lastChild,lastParent=null;for(let i=0;i<content.openEnd;i++)lastParent=lastNode,lastNode=lastNode.lastChild;let mapFrom=tr.steps.length,ranges=this.ranges;for(let i=0;i<ranges.length;i++){let{$from:$from,$to:$to}=ranges[i],mapping=tr.mapping.slice(mapFrom);tr.replaceRange(mapping.map($from.pos),mapping.map($to.pos),i?prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.empty:content),0==i&&selectionToInsertionEnd(tr,mapFrom,(lastNode?lastNode.isInline:lastParent&&lastParent.isTextblock)?-1:1)}}
/**
    Replace the selection with the given node, appending the changes
    to the given transaction.
    */replaceWith(tr,node){let mapFrom=tr.steps.length,ranges=this.ranges;for(let i=0;i<ranges.length;i++){let{$from:$from,$to:$to}=ranges[i],mapping=tr.mapping.slice(mapFrom),from=mapping.map($from.pos),to=mapping.map($to.pos);i?tr.deleteRange(from,to):(tr.replaceRangeWith(from,to,node),selectionToInsertionEnd(tr,mapFrom,node.isInline?-1:1))}}
/**
    Find a valid cursor or leaf node selection starting at the given
    position and searching back if `dir` is negative, and forward if
    positive. When `textOnly` is true, only consider cursor
    selections. Will return null when no valid selection position is
    found.
    */static findFrom($pos,dir,textOnly=!1){let inner=$pos.parent.inlineContent?new TextSelection($pos):findSelectionIn($pos.node(0),$pos.parent,$pos.pos,$pos.index(),dir,textOnly);if(inner)return inner;for(let depth=$pos.depth-1;depth>=0;depth--){let found=dir<0?findSelectionIn($pos.node(0),$pos.node(depth),$pos.before(depth+1),$pos.index(depth),dir,textOnly):findSelectionIn($pos.node(0),$pos.node(depth),$pos.after(depth+1),$pos.index(depth)+1,dir,textOnly);if(found)return found}return null}
/**
    Find a valid cursor or leaf node selection near the given
    position. Searches forward first by default, but if `bias` is
    negative, it will search backwards first.
    */static near($pos,bias=1){return this.findFrom($pos,bias)||this.findFrom($pos,-bias)||new AllSelection($pos.node(0))}
/**
    Find the cursor or leaf node selection closest to the start of
    the given document. Will return an
    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
    exists.
    */static atStart(doc){return findSelectionIn(doc,doc,0,0,1)||new AllSelection(doc)}
/**
    Find the cursor or leaf node selection closest to the end of the
    given document.
    */static atEnd(doc){return findSelectionIn(doc,doc,doc.content.size,doc.childCount,-1)||new AllSelection(doc)}
/**
    Deserialize the JSON representation of a selection. Must be
    implemented for custom classes (as a static class method).
    */static fromJSON(doc,json){if(!json||!json.type)throw new RangeError("Invalid input for Selection.fromJSON");let cls=classesById[json.type];if(!cls)throw new RangeError(`No selection type ${json.type} defined`);return cls.fromJSON(doc,json)}
/**
    To be able to deserialize selections from JSON, custom selection
    classes must register themselves with an ID string, so that they
    can be disambiguated. Try to pick something that's unlikely to
    clash with classes from other modules.
    */static jsonID(id,selectionClass){if(id in classesById)throw new RangeError("Duplicate use of selection JSON ID "+id);return classesById[id]=selectionClass,selectionClass.prototype.jsonID=id,selectionClass}
/**
    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
    which is a value that can be mapped without having access to a
    current document, and later resolved to a real selection for a
    given document again. (This is used mostly by the history to
    track and restore old selections.) The default implementation of
    this method just converts the selection to a text selection and
    returns the bookmark for that.
    */getBookmark(){return TextSelection.between(this.$anchor,this.$head).getBookmark()}}Selection.prototype.visible=!0;
/**
Represents a selected range in a document.
*/
class SelectionRange{
/**
    Create a range.
    */
constructor(
/**
    The lower bound of the range.
    */
$from,
/**
    The upper bound of the range.
    */
$to){this.$from=$from,this.$to=$to}}let warnedAboutTextSelection=!1;function checkTextSelection($pos){warnedAboutTextSelection||$pos.parent.inlineContent||(warnedAboutTextSelection=!0)}
/**
A text selection represents a classical editor selection, with a
head (the moving side) and anchor (immobile side), both of which
point into textblock nodes. It can be empty (a regular cursor
position).
*/class TextSelection extends Selection{
/**
    Construct a text selection between the given points.
    */
constructor($anchor,$head=$anchor){checkTextSelection($anchor),checkTextSelection($head),super($anchor,$head)}
/**
    Returns a resolved position if this is a cursor selection (an
    empty text selection), and null otherwise.
    */get $cursor(){return this.$anchor.pos==this.$head.pos?this.$head:null}map(doc,mapping){let $head=doc.resolve(mapping.map(this.head));if(!$head.parent.inlineContent)return Selection.near($head);let $anchor=doc.resolve(mapping.map(this.anchor));return new TextSelection($anchor.parent.inlineContent?$anchor:$head,$head)}replace(tr,content=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.empty){if(super.replace(tr,content),content==prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.empty){let marks=this.$from.marksAcross(this.$to);marks&&tr.ensureMarks(marks)}}eq(other){return other instanceof TextSelection&&other.anchor==this.anchor&&other.head==this.head}getBookmark(){return new TextBookmark(this.anchor,this.head)}toJSON(){return{type:"text",anchor:this.anchor,head:this.head}}
/**
    @internal
    */static fromJSON(doc,json){if("number"!=typeof json.anchor||"number"!=typeof json.head)throw new RangeError("Invalid input for TextSelection.fromJSON");return new TextSelection(doc.resolve(json.anchor),doc.resolve(json.head))}
/**
    Create a text selection from non-resolved positions.
    */static create(doc,anchor,head=anchor){let $anchor=doc.resolve(anchor);return new this($anchor,head==anchor?$anchor:doc.resolve(head))}
/**
    Return a text selection that spans the given positions or, if
    they aren't text positions, find a text selection near them.
    `bias` determines whether the method searches forward (default)
    or backwards (negative number) first. Will fall back to calling
    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
    doesn't contain a valid text position.
    */static between($anchor,$head,bias){let dPos=$anchor.pos-$head.pos;if(bias&&!dPos||(bias=dPos>=0?1:-1),!$head.parent.inlineContent){let found=Selection.findFrom($head,bias,!0)||Selection.findFrom($head,-bias,!0);if(!found)return Selection.near($head,bias);$head=found.$head}return $anchor.parent.inlineContent||(0==dPos?$anchor=$head:($anchor=(Selection.findFrom($anchor,-bias,!0)||Selection.findFrom($anchor,bias,!0)).$anchor,$anchor.pos<$head.pos!=dPos<0&&($anchor=$head))),new TextSelection($anchor,$head)}}Selection.jsonID("text",TextSelection);class TextBookmark{constructor(anchor,head){this.anchor=anchor,this.head=head}map(mapping){return new TextBookmark(mapping.map(this.anchor),mapping.map(this.head))}resolve(doc){return TextSelection.between(doc.resolve(this.anchor),doc.resolve(this.head))}}
/**
A node selection is a selection that points at a single node. All
nodes marked [selectable](https://prosemirror.net/docs/ref/#model.NodeSpec.selectable) can be the
target of a node selection. In such a selection, `from` and `to`
point directly before and after the selected node, `anchor` equals
`from`, and `head` equals `to`..
*/class NodeSelection extends Selection{
/**
    Create a node selection. Does not verify the validity of its
    argument.
    */
constructor($pos){let node=$pos.nodeAfter,$end=$pos.node(0).resolve($pos.pos+node.nodeSize);super($pos,$end),this.node=node}map(doc,mapping){let{deleted:deleted,pos:pos}=mapping.mapResult(this.anchor),$pos=doc.resolve(pos);return deleted?Selection.near($pos):new NodeSelection($pos)}content(){return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(this.node),0,0)}eq(other){return other instanceof NodeSelection&&other.anchor==this.anchor}toJSON(){return{type:"node",anchor:this.anchor}}getBookmark(){return new NodeBookmark(this.anchor)}
/**
    @internal
    */static fromJSON(doc,json){if("number"!=typeof json.anchor)throw new RangeError("Invalid input for NodeSelection.fromJSON");return new NodeSelection(doc.resolve(json.anchor))}
/**
    Create a node selection from non-resolved positions.
    */static create(doc,from){return new NodeSelection(doc.resolve(from))}
/**
    Determines whether the given node may be selected as a node
    selection.
    */static isSelectable(node){return!node.isText&&!1!==node.type.spec.selectable}}NodeSelection.prototype.visible=!1,Selection.jsonID("node",NodeSelection);class NodeBookmark{constructor(anchor){this.anchor=anchor}map(mapping){let{deleted:deleted,pos:pos}=mapping.mapResult(this.anchor);return deleted?new TextBookmark(pos,pos):new NodeBookmark(pos)}resolve(doc){let $pos=doc.resolve(this.anchor),node=$pos.nodeAfter;return node&&NodeSelection.isSelectable(node)?new NodeSelection($pos):Selection.near($pos)}}
/**
A selection type that represents selecting the whole document
(which can not necessarily be expressed with a text selection, when
there are for example leaf block nodes at the start or end of the
document).
*/class AllSelection extends Selection{
/**
    Create an all-selection over the given document.
    */
constructor(doc){super(doc.resolve(0),doc.resolve(doc.content.size))}replace(tr,content=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.empty){if(content==prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.empty){tr.delete(0,tr.doc.content.size);let sel=Selection.atStart(tr.doc);sel.eq(tr.selection)||tr.setSelection(sel)}else super.replace(tr,content)}toJSON(){return{type:"all"}}
/**
    @internal
    */static fromJSON(doc){return new AllSelection(doc)}map(doc){return new AllSelection(doc)}eq(other){return other instanceof AllSelection}getBookmark(){return AllBookmark}}Selection.jsonID("all",AllSelection);const AllBookmark={map(){return this},resolve(doc){return new AllSelection(doc)}};
// FIXME we'll need some awareness of text direction when scanning for selections
// Try to find a selection inside the given node. `pos` points at the
// position where the search starts. When `text` is true, only return
// text selections.
function findSelectionIn(doc,node,pos,index,dir,text=!1){if(node.inlineContent)return TextSelection.create(doc,pos);for(let i=index-(dir>0?0:1);dir>0?i<node.childCount:i>=0;i+=dir){let child=node.child(i);if(child.isAtom){if(!text&&NodeSelection.isSelectable(child))return NodeSelection.create(doc,pos-(dir<0?child.nodeSize:0))}else{let inner=findSelectionIn(doc,child,pos+dir,dir<0?child.childCount:0,dir,text);if(inner)return inner}pos+=child.nodeSize*dir}return null}function selectionToInsertionEnd(tr,startLen,bias){let last=tr.steps.length-1;if(last<startLen)return;let step=tr.steps[last];if(!(step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__/* .ReplaceStep */.Pu||step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__/* .ReplaceAroundStep */.FC))return;let end,map=tr.mapping.maps[last];map.forEach(((_from,_to,_newFrom,newTo)=>{null==end&&(end=newTo)})),tr.setSelection(Selection.near(tr.doc.resolve(end),bias))}const UPDATED_SEL=1,UPDATED_MARKS=2,UPDATED_SCROLL=4;
/**
An editor state transaction, which can be applied to a state to
create an updated state. Use
[`EditorState.tr`](https://prosemirror.net/docs/ref/#state.EditorState.tr) to create an instance.

Transactions track changes to the document (they are a subclass of
[`Transform`](https://prosemirror.net/docs/ref/#transform.Transform)), but also other state changes,
like selection updates and adjustments of the set of [stored
marks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks). In addition, you can store
metadata properties in a transaction, which are extra pieces of
information that client code or plugins can use to describe what a
transaction represents, so that they can update their [own
state](https://prosemirror.net/docs/ref/#state.StateField) accordingly.

The [editor view](https://prosemirror.net/docs/ref/#view.EditorView) uses a few metadata
properties: it will attach a property `"pointer"` with the value
`true` to selection transactions directly caused by mouse or touch
input, a `"composition"` property holding an ID identifying the
composition that caused it to transactions caused by composed DOM
input, and a `"uiEvent"` property of that may be `"paste"`,
`"cut"`, or `"drop"`.
*/class Transaction extends prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__/* .Transform */.wx{
/**
    @internal
    */
constructor(state){super(state.doc),
// The step count for which the current selection is valid.
this.curSelectionFor=0,
// Bitfield to track which aspects of the state were updated by
// this transaction.
this.updated=0,
// Object used to store metadata properties for the transaction.
this.meta=Object.create(null),this.time=Date.now(),this.curSelection=state.selection,this.storedMarks=state.storedMarks}
/**
    The transaction's current selection. This defaults to the editor
    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
    transaction, but can be overwritten with
    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
    */get selection(){return this.curSelectionFor<this.steps.length&&(this.curSelection=this.curSelection.map(this.doc,this.mapping.slice(this.curSelectionFor)),this.curSelectionFor=this.steps.length),this.curSelection}
/**
    Update the transaction's current selection. Will determine the
    selection that the editor gets when the transaction is applied.
    */setSelection(selection){if(selection.$from.doc!=this.doc)throw new RangeError("Selection passed to setSelection must point at the current document");return this.curSelection=selection,this.curSelectionFor=this.steps.length,this.updated=(this.updated|UPDATED_SEL)&~UPDATED_MARKS,this.storedMarks=null,this}
/**
    Whether the selection was explicitly updated by this transaction.
    */get selectionSet(){return(this.updated&UPDATED_SEL)>0}
/**
    Set the current stored marks.
    */setStoredMarks(marks){return this.storedMarks=marks,this.updated|=UPDATED_MARKS,this}
/**
    Make sure the current stored marks or, if that is null, the marks
    at the selection, match the given set of marks. Does nothing if
    this is already the case.
    */ensureMarks(marks){return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Mark */.vc.sameSet(this.storedMarks||this.selection.$from.marks(),marks)||this.setStoredMarks(marks),this}
/**
    Add a mark to the set of stored marks.
    */addStoredMark(mark){return this.ensureMarks(mark.addToSet(this.storedMarks||this.selection.$head.marks()))}
/**
    Remove a mark or mark type from the set of stored marks.
    */removeStoredMark(mark){return this.ensureMarks(mark.removeFromSet(this.storedMarks||this.selection.$head.marks()))}
/**
    Whether the stored marks were explicitly set for this transaction.
    */get storedMarksSet(){return(this.updated&UPDATED_MARKS)>0}
/**
    @internal
    */addStep(step,doc){super.addStep(step,doc),this.updated=this.updated&~UPDATED_MARKS,this.storedMarks=null}
/**
    Update the timestamp for the transaction.
    */setTime(time){return this.time=time,this}
/**
    Replace the current selection with the given slice.
    */replaceSelection(slice){return this.selection.replace(this,slice),this}
/**
    Replace the selection with the given node. When `inheritMarks` is
    true and the content is inline, it inherits the marks from the
    place where it is inserted.
    */replaceSelectionWith(node,inheritMarks=!0){let selection=this.selection;return inheritMarks&&(node=node.mark(this.storedMarks||(selection.empty?selection.$from.marks():selection.$from.marksAcross(selection.$to)||prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Mark */.vc.none))),selection.replaceWith(this,node),this}
/**
    Delete the selection.
    */deleteSelection(){return this.selection.replace(this),this}
/**
    Replace the given range, or the selection if no range is given,
    with a text node containing the given string.
    */insertText(text,from,to){let schema=this.doc.type.schema;if(null==from)return text?this.replaceSelectionWith(schema.text(text),!0):this.deleteSelection();{if(null==to&&(to=from),to=null==to?from:to,!text)return this.deleteRange(from,to);let marks=this.storedMarks;if(!marks){let $from=this.doc.resolve(from);marks=to==from?$from.marks():$from.marksAcross(this.doc.resolve(to))}return this.replaceRangeWith(from,to,schema.text(text,marks)),this.selection.empty||this.setSelection(Selection.near(this.selection.$to)),this}}
/**
    Store a metadata property in this transaction, keyed either by
    name or by plugin.
    */setMeta(key,value){return this.meta["string"==typeof key?key:key.key]=value,this}
/**
    Retrieve a metadata property for a given name or plugin.
    */getMeta(key){return this.meta["string"==typeof key?key:key.key]}
/**
    Returns true if this transaction doesn't contain any metadata,
    and can thus safely be extended.
    */get isGeneric(){for(let _ in this.meta)return!1;return!0}
/**
    Indicate that the editor should scroll the selection into view
    when updated to the state produced by this transaction.
    */scrollIntoView(){return this.updated|=UPDATED_SCROLL,this}
/**
    True when this transaction has had `scrollIntoView` called on it.
    */get scrolledIntoView(){return(this.updated&UPDATED_SCROLL)>0}}function bind(f,self){return self&&f?f.bind(self):f}class FieldDesc{constructor(name,desc,self){this.name=name,this.init=bind(desc.init,self),this.apply=bind(desc.apply,self)}}const baseFields=[new FieldDesc("doc",{init(config){return config.doc||config.schema.topNodeType.createAndFill()},apply(tr){return tr.doc}}),new FieldDesc("selection",{init(config,instance){return config.selection||Selection.atStart(instance.doc)},apply(tr){return tr.selection}}),new FieldDesc("storedMarks",{init(config){return config.storedMarks||null},apply(tr,_marks,_old,state){return state.selection.$cursor?tr.storedMarks:null}}),new FieldDesc("scrollToSelection",{init(){return 0},apply(tr,prev){return tr.scrolledIntoView?prev+1:prev}})];
// Object wrapping the part of a state object that stays the same
// across transactions. Stored in the state's `config` property.
class Configuration{constructor(schema,plugins){this.schema=schema,this.plugins=[],this.pluginsByKey=Object.create(null),this.fields=baseFields.slice(),plugins&&plugins.forEach((plugin=>{if(this.pluginsByKey[plugin.key])throw new RangeError("Adding different instances of a keyed plugin ("+plugin.key+")");this.plugins.push(plugin),this.pluginsByKey[plugin.key]=plugin,plugin.spec.state&&this.fields.push(new FieldDesc(plugin.key,plugin.spec.state,plugin))}))}}
/**
The state of a ProseMirror editor is represented by an object of
this type. A state is a persistent data structure—it isn't
updated, but rather a new state value is computed from an old one
using the [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) method.

A state holds a number of built-in fields, and plugins can
[define](https://prosemirror.net/docs/ref/#state.PluginSpec.state) additional fields.
*/class EditorState{
/**
    @internal
    */
constructor(
/**
    @internal
    */
config){this.config=config}
/**
    The schema of the state's document.
    */get schema(){return this.config.schema}
/**
    The plugins that are active in this state.
    */get plugins(){return this.config.plugins}
/**
    Apply the given transaction to produce a new state.
    */apply(tr){return this.applyTransaction(tr).state}
/**
    @internal
    */filterTransaction(tr,ignore=-1){for(let i=0;i<this.config.plugins.length;i++)if(i!=ignore){let plugin=this.config.plugins[i];if(plugin.spec.filterTransaction&&!plugin.spec.filterTransaction.call(plugin,tr,this))return!1}return!0}
/**
    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
    returns the precise transactions that were applied (which might
    be influenced by the [transaction
    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
    plugins) along with the new state.
    */applyTransaction(rootTr){if(!this.filterTransaction(rootTr))return{state:this,transactions:[]};let trs=[rootTr],newState=this.applyInner(rootTr),seen=null;
// This loop repeatedly gives plugins a chance to respond to
// transactions as new transactions are added, making sure to only
// pass the transactions the plugin did not see before.
for(;;){let haveNew=!1;for(let i=0;i<this.config.plugins.length;i++){let plugin=this.config.plugins[i];if(plugin.spec.appendTransaction){let n=seen?seen[i].n:0,oldState=seen?seen[i].state:this,tr=n<trs.length&&plugin.spec.appendTransaction.call(plugin,n?trs.slice(n):trs,oldState,newState);if(tr&&newState.filterTransaction(tr,i)){if(tr.setMeta("appendedTransaction",rootTr),!seen){seen=[];for(let j=0;j<this.config.plugins.length;j++)seen.push(j<i?{state:newState,n:trs.length}:{state:this,n:0})}trs.push(tr),newState=newState.applyInner(tr),haveNew=!0}seen&&(seen[i]={state:newState,n:trs.length})}}if(!haveNew)return{state:newState,transactions:trs}}}
/**
    @internal
    */applyInner(tr){if(!tr.before.eq(this.doc))throw new RangeError("Applying a mismatched transaction");let newInstance=new EditorState(this.config),fields=this.config.fields;for(let i=0;i<fields.length;i++){let field=fields[i];newInstance[field.name]=field.apply(tr,this[field.name],this,newInstance)}return newInstance}
/**
    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
    */get tr(){return new Transaction(this)}
/**
    Create a new state.
    */static create(config){let $config=new Configuration(config.doc?config.doc.type.schema:config.schema,config.plugins),instance=new EditorState($config);for(let i=0;i<$config.fields.length;i++)instance[$config.fields[i].name]=$config.fields[i].init(config,instance);return instance}
/**
    Create a new state based on this one, but with an adjusted set
    of active plugins. State fields that exist in both sets of
    plugins are kept unchanged. Those that no longer exist are
    dropped, and those that are new are initialized using their
    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
    configuration object..
    */reconfigure(config){let $config=new Configuration(this.schema,config.plugins),fields=$config.fields,instance=new EditorState($config);for(let i=0;i<fields.length;i++){let name=fields[i].name;instance[name]=this.hasOwnProperty(name)?this[name]:fields[i].init(config,instance)}return instance}
/**
    Serialize this state to JSON. If you want to serialize the state
    of plugins, pass an object mapping property names to use in the
    resulting JSON object to plugin objects. The argument may also be
    a string or number, in which case it is ignored, to support the
    way `JSON.stringify` calls `toString` methods.
    */toJSON(pluginFields){let result={doc:this.doc.toJSON(),selection:this.selection.toJSON()};if(this.storedMarks&&(result.storedMarks=this.storedMarks.map((m=>m.toJSON()))),pluginFields&&"object"==typeof pluginFields)for(let prop in pluginFields){if("doc"==prop||"selection"==prop)throw new RangeError("The JSON fields `doc` and `selection` are reserved");let plugin=pluginFields[prop],state=plugin.spec.state;state&&state.toJSON&&(result[prop]=state.toJSON.call(plugin,this[plugin.key]))}return result}
/**
    Deserialize a JSON representation of a state. `config` should
    have at least a `schema` field, and should contain array of
    plugins to initialize the state with. `pluginFields` can be used
    to deserialize the state of plugins, by associating plugin
    instances with the property names they use in the JSON object.
    */static fromJSON(config,json,pluginFields){if(!json)throw new RangeError("Invalid input for EditorState.fromJSON");if(!config.schema)throw new RangeError("Required config field 'schema' missing");let $config=new Configuration(config.schema,config.plugins),instance=new EditorState($config);return $config.fields.forEach((field=>{if("doc"==field.name)instance.doc=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Node */.NB.fromJSON(config.schema,json.doc);else if("selection"==field.name)instance.selection=Selection.fromJSON(instance.doc,json.selection);else if("storedMarks"==field.name)json.storedMarks&&(instance.storedMarks=json.storedMarks.map(config.schema.markFromJSON));else{if(pluginFields)for(let prop in pluginFields){let plugin=pluginFields[prop],state=plugin.spec.state;if(plugin.key==field.name&&state&&state.fromJSON&&Object.prototype.hasOwnProperty.call(json,prop))return void(instance[field.name]=state.fromJSON.call(plugin,config,json[prop],instance))}instance[field.name]=field.init(config,instance)}})),instance}}function bindProps(obj,self,target){for(let prop in obj){let val=obj[prop];val instanceof Function?val=val.bind(self):"handleDOMEvents"==prop&&(val=bindProps(val,self,{})),target[prop]=val}return target}
/**
Plugins bundle functionality that can be added to an editor.
They are part of the [editor state](https://prosemirror.net/docs/ref/#state.EditorState) and
may influence that state and the view that contains it.
*/class Plugin{
/**
    Create a plugin.
    */
constructor(
/**
    The plugin's [spec object](https://prosemirror.net/docs/ref/#state.PluginSpec).
    */
spec){this.spec=spec,
/**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
this.props={},spec.props&&bindProps(spec.props,this,this.props),this.key=spec.key?spec.key.key:createKey("plugin")}
/**
    Extract the plugin's state field from an editor state.
    */getState(state){return state[this.key]}}const keys=Object.create(null);function createKey(name){return name in keys?name+"$"+ ++keys[name]:(keys[name]=0,name+"$")}
/**
A key is used to [tag](https://prosemirror.net/docs/ref/#state.PluginSpec.key) plugins in a way
that makes it possible to find them, given an editor state.
Assigning a key does mean only one plugin of that type can be
active in a state.
*/class PluginKey{
/**
    Create a plugin key.
    */
constructor(name="key"){this.key=createKey(name)}
/**
    Get the active plugin with this key, if any, from an editor
    state.
    */get(state){return state.config.pluginsByKey[this.key]}
/**
    Get the plugin's state from an editor state.
    */getState(state){return state[this.key]}}
/***/},
/***/378649:
/***/function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";
/* harmony export */__webpack_require__.d(__webpack_exports__,{
/* harmony export */Cr:function(){/* binding */return splitCell},
/* harmony export */G3:function(){/* binding */return tableEditing},
/* harmony export */II:function(){/* binding */return toggleHeaderCell},
/* harmony export */I_:function(){/* binding */return addColumnBefore},
/* harmony export */JX:function(){/* binding */return mergeCells},
/* harmony export */VH:function(){/* binding */return columnResizing},
/* harmony export */WQ:function(){/* binding */return deleteTable},
/* harmony export */Xc:function(){/* binding */return CellSelection},
/* harmony export */dO:function(){/* binding */return toggleHeader},
/* harmony export */dl:function(){/* binding */return addRowAfter},
/* harmony export */e2:function(){/* binding */return addColumnAfter},
/* harmony export */eA:function(){/* binding */return deleteColumn},
/* harmony export */nA:function(){/* binding */return goToNextCell},
/* harmony export */qK:function(){/* binding */return deleteRow},
/* harmony export */tp:function(){/* binding */return fixTables},
/* harmony export */wb:function(){/* binding */return setCellAttr},
/* harmony export */z2:function(){/* binding */return addRowBefore}
/* harmony export */});
/* unused harmony exports CellBookmark, ResizeState, TableMap, TableView, __clipCells, __insertCells, __pastedCells, addColSpan, addColumn, addRow, cellAround, colCount, columnIsHeader, columnResizingPluginKey, findCell, fixTablesKey, handlePaste, inSameTable, isInTable, moveCellForward, nextCell, pointsAtCell, removeColSpan, removeColumn, removeRow, rowIsHeader, selectedRect, selectionCell, splitCellWithType, tableEditingKey, tableNodeTypes, tableNodes, toggleHeaderColumn, toggleHeaderRow, updateColumnsOnResize */
/* harmony import */var readFromCache,addToCache,prosemirror_state__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(102376),prosemirror_model__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(759084),prosemirror_view__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(484348),prosemirror_keymap__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(560440),prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(616560);
/* harmony import */if("undefined"!=typeof WeakMap){let cache=new WeakMap;readFromCache=key=>cache.get(key),addToCache=(key,value)=>(cache.set(key,value),value)}else{const cache=[],cacheSize=10;let cachePos=0;readFromCache=key=>{for(let i=0;i<cache.length;i+=2)if(cache[i]==key)return cache[i+1]},addToCache=(key,value)=>(cachePos==cacheSize&&(cachePos=0),cache[cachePos++]=key,cache[cachePos++]=value)}var TableMap=class{constructor(width,height,map,problems){this.width=width,this.height=height,this.map=map,this.problems=problems}
// Find the dimensions of the cell at the given position.
findCell(pos){for(let i=0;i<this.map.length;i++){const curPos=this.map[i];if(curPos!=pos)continue;const left=i%this.width,top=i/this.width|0;let right=left+1,bottom=top+1;for(let j=1;right<this.width&&this.map[i+j]==curPos;j++)right++;for(let j=1;bottom<this.height&&this.map[i+this.width*j]==curPos;j++)bottom++;return{left:left,top:top,right:right,bottom:bottom}}throw new RangeError(`No cell with offset ${pos} found`)}
// Find the left side of the cell at the given position.
colCount(pos){for(let i=0;i<this.map.length;i++)if(this.map[i]==pos)return i%this.width;throw new RangeError(`No cell with offset ${pos} found`)}
// Find the next cell in the given direction, starting from the cell
// at `pos`, if any.
nextCell(pos,axis,dir){const{left:left,right:right,top:top,bottom:bottom}=this.findCell(pos);return"horiz"==axis?(dir<0?0==left:right==this.width)?null:this.map[top*this.width+(dir<0?left-1:right)]:(dir<0?0==top:bottom==this.height)?null:this.map[left+this.width*(dir<0?top-1:bottom)]}
// Get the rectangle spanning the two given cells.
rectBetween(a,b){const{left:leftA,right:rightA,top:topA,bottom:bottomA}=this.findCell(a),{left:leftB,right:rightB,top:topB,bottom:bottomB}=this.findCell(b);return{left:Math.min(leftA,leftB),top:Math.min(topA,topB),right:Math.max(rightA,rightB),bottom:Math.max(bottomA,bottomB)}}
// Return the position of all cells that have the top left corner in
// the given rectangle.
cellsInRect(rect){const result=[],seen={};for(let row=rect.top;row<rect.bottom;row++)for(let col=rect.left;col<rect.right;col++){const index=row*this.width+col,pos=this.map[index];seen[pos]||(seen[pos]=!0,col==rect.left&&col&&this.map[index-1]==pos||row==rect.top&&row&&this.map[index-this.width]==pos||result.push(pos))}return result}
// Return the position at which the cell at the given row and column
// starts, or would start, if a cell started there.
positionAt(row,col,table){for(let i=0,rowStart=0;;i++){const rowEnd=rowStart+table.child(i).nodeSize;if(i==row){let index=col+row*this.width;const rowEndIndex=(row+1)*this.width;while(index<rowEndIndex&&this.map[index]<rowStart)index++;return index==rowEndIndex?rowEnd-1:this.map[index]}rowStart=rowEnd}}
// Find the table map for the given table node.
static get(table){return readFromCache(table)||addToCache(table,computeMap(table))}};function computeMap(table){if("table"!=table.type.spec.tableRole)throw new RangeError("Not a table node: "+table.type.name);const width=findWidth(table),height=table.childCount,map=[];let mapPos=0,problems=null;const colWidths=[];for(let i=0,e=width*height;i<e;i++)map[i]=0;for(let row=0,pos=0;row<height;row++){const rowNode=table.child(row);pos++;for(let i=0;;i++){while(mapPos<map.length&&0!=map[mapPos])mapPos++;if(i==rowNode.childCount)break;const cellNode=rowNode.child(i),{colspan:colspan,rowspan:rowspan,colwidth:colwidth}=cellNode.attrs;for(let h=0;h<rowspan;h++){if(h+row>=height){(problems||(problems=[])).push({type:"overlong_rowspan",pos:pos,n:rowspan-h});break}const start=mapPos+h*width;for(let w=0;w<colspan;w++){0==map[start+w]?map[start+w]=pos:(problems||(problems=[])).push({type:"collision",row:row,pos:pos,n:colspan-w});const colW=colwidth&&colwidth[w];if(colW){const widthIndex=(start+w)%width*2,prev=colWidths[widthIndex];null==prev||prev!=colW&&1==colWidths[widthIndex+1]?(colWidths[widthIndex]=colW,colWidths[widthIndex+1]=1):prev==colW&&colWidths[widthIndex+1]++}}}mapPos+=colspan,pos+=cellNode.nodeSize}const expectedPos=(row+1)*width;let missing=0;while(mapPos<expectedPos)0==map[mapPos++]&&missing++;missing&&(problems||(problems=[])).push({type:"missing",row:row,n:missing}),pos++}const tableMap=new TableMap(width,height,map,problems);let badWidths=!1;for(let i=0;!badWidths&&i<colWidths.length;i+=2)null!=colWidths[i]&&colWidths[i+1]<height&&(badWidths=!0);return badWidths&&findBadColWidths(tableMap,colWidths,table),tableMap}function findWidth(table){let width=-1,hasRowSpan=!1;for(let row=0;row<table.childCount;row++){const rowNode=table.child(row);let rowWidth=0;if(hasRowSpan)for(let j=0;j<row;j++){const prevRow=table.child(j);for(let i=0;i<prevRow.childCount;i++){const cell=prevRow.child(i);j+cell.attrs.rowspan>row&&(rowWidth+=cell.attrs.colspan)}}for(let i=0;i<rowNode.childCount;i++){const cell=rowNode.child(i);rowWidth+=cell.attrs.colspan,cell.attrs.rowspan>1&&(hasRowSpan=!0)}-1==width?width=rowWidth:width!=rowWidth&&(width=Math.max(width,rowWidth))}return width}function findBadColWidths(map,colWidths,table){map.problems||(map.problems=[]);const seen={};for(let i=0;i<map.map.length;i++){const pos=map.map[i];if(seen[pos])continue;seen[pos]=!0;const node=table.nodeAt(pos);if(!node)throw new RangeError(`No cell with offset ${pos} found`);let updated=null;const attrs=node.attrs;for(let j=0;j<attrs.colspan;j++){const col=(i+j)%map.width,colWidth=colWidths[2*col];null==colWidth||attrs.colwidth&&attrs.colwidth[j]==colWidth||((updated||(updated=freshColWidth(attrs)))[j]=colWidth)}updated&&map.problems.unshift({type:"colwidth mismatch",pos:pos,colwidth:updated})}}function freshColWidth(attrs){if(attrs.colwidth)return attrs.colwidth.slice();const result=[];for(let i=0;i<attrs.colspan;i++)result.push(0);return result}
// src/util.ts
// src/schema.ts
function tableNodeTypes(schema){let result=schema.cached.tableNodeTypes;if(!result){result=schema.cached.tableNodeTypes={};for(const name in schema.nodes){const type=schema.nodes[name],role=type.spec.tableRole;role&&(result[role]=type)}}return result}
// src/util.ts
var tableEditingKey=new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .PluginKey */.H$("selectingCells");function cellAround($pos){for(let d=$pos.depth-1;d>0;d--)if("row"==$pos.node(d).type.spec.tableRole)return $pos.node(0).resolve($pos.before(d+1));return null}function cellWrapping($pos){for(let d=$pos.depth;d>0;d--){const role=$pos.node(d).type.spec.tableRole;if("cell"===role||"header_cell"===role)return $pos.node(d)}return null}function isInTable(state){const $head=state.selection.$head;for(let d=$head.depth;d>0;d--)if("row"==$head.node(d).type.spec.tableRole)return!0;return!1}function selectionCell(state){const sel=state.selection;if("$anchorCell"in sel&&sel.$anchorCell)return sel.$anchorCell.pos>sel.$headCell.pos?sel.$anchorCell:sel.$headCell;if("node"in sel&&sel.node&&"cell"==sel.node.type.spec.tableRole)return sel.$anchor;const $cell=cellAround(sel.$head)||cellNear(sel.$head);if($cell)return $cell;throw new RangeError(`No cell found around position ${sel.head}`)}function cellNear($pos){for(let after=$pos.nodeAfter,pos=$pos.pos;after;after=after.firstChild,pos++){const role=after.type.spec.tableRole;if("cell"==role||"header_cell"==role)return $pos.doc.resolve(pos)}for(let before=$pos.nodeBefore,pos=$pos.pos;before;before=before.lastChild,pos--){const role=before.type.spec.tableRole;if("cell"==role||"header_cell"==role)return $pos.doc.resolve(pos-before.nodeSize)}}function pointsAtCell($pos){return"row"==$pos.parent.type.spec.tableRole&&!!$pos.nodeAfter}function moveCellForward($pos){return $pos.node(0).resolve($pos.pos+$pos.nodeAfter.nodeSize)}function inSameTable($cellA,$cellB){return $cellA.depth==$cellB.depth&&$cellA.pos>=$cellB.start(-1)&&$cellA.pos<=$cellB.end(-1)}function nextCell($pos,axis,dir){const table=$pos.node(-1),map=TableMap.get(table),tableStart=$pos.start(-1),moved=map.nextCell($pos.pos-tableStart,axis,dir);return null==moved?null:$pos.node(0).resolve(tableStart+moved)}function removeColSpan(attrs,pos,n=1){const result={...attrs,colspan:attrs.colspan-n};return result.colwidth&&(result.colwidth=result.colwidth.slice(),result.colwidth.splice(pos,n),result.colwidth.some((w=>w>0))||(result.colwidth=null)),result}function addColSpan(attrs,pos,n=1){const result={...attrs,colspan:attrs.colspan+n};if(result.colwidth){result.colwidth=result.colwidth.slice();for(let i=0;i<n;i++)result.colwidth.splice(pos,0,0)}return result}function columnIsHeader(map,table,col){const headerCell=tableNodeTypes(table.type.schema).header_cell;for(let row=0;row<map.height;row++)if(table.nodeAt(map.map[col+row*map.width]).type!=headerCell)return!1;return!0}
// src/cellselection.ts
var CellSelection=class extends prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .Selection */.Y1{
// A table selection is identified by its anchor and head cells. The
// positions given to this constructor should point _before_ two
// cells in the same table. They may be the same, to select a single
// cell.
constructor($anchorCell,$headCell=$anchorCell){const table=$anchorCell.node(-1),map=TableMap.get(table),tableStart=$anchorCell.start(-1),rect=map.rectBetween($anchorCell.pos-tableStart,$headCell.pos-tableStart),doc=$anchorCell.node(0),cells=map.cellsInRect(rect).filter((p=>p!=$headCell.pos-tableStart));cells.unshift($headCell.pos-tableStart);const ranges=cells.map((pos=>{const cell=table.nodeAt(pos);if(!cell)throw RangeError(`No cell with offset ${pos} found`);const from=tableStart+pos+1;return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .SelectionRange */.xm(doc.resolve(from),doc.resolve(from+cell.content.size))}));super(ranges[0].$from,ranges[0].$to,ranges),this.$anchorCell=$anchorCell,this.$headCell=$headCell}map(doc,mapping){const $anchorCell=doc.resolve(mapping.map(this.$anchorCell.pos)),$headCell=doc.resolve(mapping.map(this.$headCell.pos));if(pointsAtCell($anchorCell)&&pointsAtCell($headCell)&&inSameTable($anchorCell,$headCell)){const tableChanged=this.$anchorCell.node(-1)!=$anchorCell.node(-1);return tableChanged&&this.isRowSelection()?CellSelection.rowSelection($anchorCell,$headCell):tableChanged&&this.isColSelection()?CellSelection.colSelection($anchorCell,$headCell):new CellSelection($anchorCell,$headCell)}return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .TextSelection */.Bs.between($anchorCell,$headCell)}
// Returns a rectangular slice of table rows containing the selected
// cells.
content(){const table=this.$anchorCell.node(-1),map=TableMap.get(table),tableStart=this.$anchorCell.start(-1),rect=map.rectBetween(this.$anchorCell.pos-tableStart,this.$headCell.pos-tableStart),seen={},rows=[];for(let row=rect.top;row<rect.bottom;row++){const rowContent=[];for(let index=row*map.width+rect.left,col=rect.left;col<rect.right;col++,index++){const pos=map.map[index];if(seen[pos])continue;seen[pos]=!0;const cellRect=map.findCell(pos);let cell=table.nodeAt(pos);if(!cell)throw RangeError(`No cell with offset ${pos} found`);const extraLeft=rect.left-cellRect.left,extraRight=cellRect.right-rect.right;if(extraLeft>0||extraRight>0){let attrs=cell.attrs;if(extraLeft>0&&(attrs=removeColSpan(attrs,0,extraLeft)),extraRight>0&&(attrs=removeColSpan(attrs,attrs.colspan-extraRight,extraRight)),cellRect.left<rect.left){if(cell=cell.type.createAndFill(attrs),!cell)throw RangeError(`Could not create cell with attrs ${JSON.stringify(attrs)}`)}else cell=cell.type.create(attrs,cell.content)}if(cellRect.top<rect.top||cellRect.bottom>rect.bottom){const attrs={...cell.attrs,rowspan:Math.min(cellRect.bottom,rect.bottom)-Math.max(cellRect.top,rect.top)};cell=cellRect.top<rect.top?cell.type.createAndFill(attrs):cell.type.create(attrs,cell.content)}rowContent.push(cell)}rows.push(table.child(row).copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Fragment */.HY.from(rowContent)))}const fragment=this.isColSelection()&&this.isRowSelection()?table:rows;return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Slice */.p2(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Fragment */.HY.from(fragment),1,1)}replace(tr,content=prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Slice */.p2.empty){const mapFrom=tr.steps.length,ranges=this.ranges;for(let i=0;i<ranges.length;i++){const{$from:$from,$to:$to}=ranges[i],mapping=tr.mapping.slice(mapFrom);tr.replace(mapping.map($from.pos),mapping.map($to.pos),i?prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Slice */.p2.empty:content)}const sel=prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .Selection */.Y1.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),-1);sel&&tr.setSelection(sel)}replaceWith(tr,node){this.replace(tr,new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Slice */.p2(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Fragment */.HY.from(node),0,0))}forEachCell(f){const table=this.$anchorCell.node(-1),map=TableMap.get(table),tableStart=this.$anchorCell.start(-1),cells=map.cellsInRect(map.rectBetween(this.$anchorCell.pos-tableStart,this.$headCell.pos-tableStart));for(let i=0;i<cells.length;i++)f(table.nodeAt(cells[i]),tableStart+cells[i])}
// True if this selection goes all the way from the top to the
// bottom of the table.
isColSelection(){const anchorTop=this.$anchorCell.index(-1),headTop=this.$headCell.index(-1);if(Math.min(anchorTop,headTop)>0)return!1;const anchorBottom=anchorTop+this.$anchorCell.nodeAfter.attrs.rowspan,headBottom=headTop+this.$headCell.nodeAfter.attrs.rowspan;return Math.max(anchorBottom,headBottom)==this.$headCell.node(-1).childCount}
// Returns the smallest column selection that covers the given anchor
// and head cell.
static colSelection($anchorCell,$headCell=$anchorCell){const table=$anchorCell.node(-1),map=TableMap.get(table),tableStart=$anchorCell.start(-1),anchorRect=map.findCell($anchorCell.pos-tableStart),headRect=map.findCell($headCell.pos-tableStart),doc=$anchorCell.node(0);return anchorRect.top<=headRect.top?(anchorRect.top>0&&($anchorCell=doc.resolve(tableStart+map.map[anchorRect.left])),headRect.bottom<map.height&&($headCell=doc.resolve(tableStart+map.map[map.width*(map.height-1)+headRect.right-1]))):(headRect.top>0&&($headCell=doc.resolve(tableStart+map.map[headRect.left])),anchorRect.bottom<map.height&&($anchorCell=doc.resolve(tableStart+map.map[map.width*(map.height-1)+anchorRect.right-1]))),new CellSelection($anchorCell,$headCell)}
// True if this selection goes all the way from the left to the
// right of the table.
isRowSelection(){const table=this.$anchorCell.node(-1),map=TableMap.get(table),tableStart=this.$anchorCell.start(-1),anchorLeft=map.colCount(this.$anchorCell.pos-tableStart),headLeft=map.colCount(this.$headCell.pos-tableStart);if(Math.min(anchorLeft,headLeft)>0)return!1;const anchorRight=anchorLeft+this.$anchorCell.nodeAfter.attrs.colspan,headRight=headLeft+this.$headCell.nodeAfter.attrs.colspan;return Math.max(anchorRight,headRight)==map.width}eq(other){return other instanceof CellSelection&&other.$anchorCell.pos==this.$anchorCell.pos&&other.$headCell.pos==this.$headCell.pos}
// Returns the smallest row selection that covers the given anchor
// and head cell.
static rowSelection($anchorCell,$headCell=$anchorCell){const table=$anchorCell.node(-1),map=TableMap.get(table),tableStart=$anchorCell.start(-1),anchorRect=map.findCell($anchorCell.pos-tableStart),headRect=map.findCell($headCell.pos-tableStart),doc=$anchorCell.node(0);return anchorRect.left<=headRect.left?(anchorRect.left>0&&($anchorCell=doc.resolve(tableStart+map.map[anchorRect.top*map.width])),headRect.right<map.width&&($headCell=doc.resolve(tableStart+map.map[map.width*(headRect.top+1)-1]))):(headRect.left>0&&($headCell=doc.resolve(tableStart+map.map[headRect.top*map.width])),anchorRect.right<map.width&&($anchorCell=doc.resolve(tableStart+map.map[map.width*(anchorRect.top+1)-1]))),new CellSelection($anchorCell,$headCell)}toJSON(){return{type:"cell",anchor:this.$anchorCell.pos,head:this.$headCell.pos}}static fromJSON(doc,json){return new CellSelection(doc.resolve(json.anchor),doc.resolve(json.head))}static create(doc,anchorCell,headCell=anchorCell){return new CellSelection(doc.resolve(anchorCell),doc.resolve(headCell))}getBookmark(){return new CellBookmark(this.$anchorCell.pos,this.$headCell.pos)}};CellSelection.prototype.visible=!1,prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .Selection */.Y1.jsonID("cell",CellSelection);var CellBookmark=class{constructor(anchor,head){this.anchor=anchor,this.head=head}map(mapping){return new CellBookmark(mapping.map(this.anchor),mapping.map(this.head))}resolve(doc){const $anchorCell=doc.resolve(this.anchor),$headCell=doc.resolve(this.head);return"row"==$anchorCell.parent.type.spec.tableRole&&"row"==$headCell.parent.type.spec.tableRole&&$anchorCell.index()<$anchorCell.parent.childCount&&$headCell.index()<$headCell.parent.childCount&&inSameTable($anchorCell,$headCell)?new CellSelection($anchorCell,$headCell):prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .Selection */.Y1.near($headCell,1)}};function drawCellSelection(state){if(!(state.selection instanceof CellSelection))return null;const cells=[];return state.selection.forEachCell(((node,pos)=>{cells.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_2__/* .Decoration */.p.node(pos,pos+node.nodeSize,{class:"selectedCell"}))})),prosemirror_view__WEBPACK_IMPORTED_MODULE_2__/* .DecorationSet */.EH.create(state.doc,cells)}function isCellBoundarySelection({$from:$from,$to:$to}){if($from.pos==$to.pos||$from.pos<$from.pos-6)return!1;let afterFrom=$from.pos,beforeTo=$to.pos,depth=$from.depth;for(;depth>=0;depth--,afterFrom++)if($from.after(depth+1)<$from.end(depth))break;for(let d=$to.depth;d>=0;d--,beforeTo--)if($to.before(d+1)>$to.start(d))break;return afterFrom==beforeTo&&/row|table/.test($from.node(depth).type.spec.tableRole)}function isTextSelectionAcrossCells({$from:$from,$to:$to}){let fromCellBoundaryNode,toCellBoundaryNode;for(let i=$from.depth;i>0;i--){const node=$from.node(i);if("cell"===node.type.spec.tableRole||"header_cell"===node.type.spec.tableRole){fromCellBoundaryNode=node;break}}for(let i=$to.depth;i>0;i--){const node=$to.node(i);if("cell"===node.type.spec.tableRole||"header_cell"===node.type.spec.tableRole){toCellBoundaryNode=node;break}}return fromCellBoundaryNode!==toCellBoundaryNode&&0===$to.parentOffset}function normalizeSelection(state,tr,allowTableNodeSelection){const sel=(tr||state).selection,doc=(tr||state).doc;let normalize,role;if(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .NodeSelection */.qv&&(role=sel.node.type.spec.tableRole)){if("cell"==role||"header_cell"==role)normalize=CellSelection.create(doc,sel.from);else if("row"==role){const $cell=doc.resolve(sel.from+1);normalize=CellSelection.rowSelection($cell,$cell)}else if(!allowTableNodeSelection){const map=TableMap.get(sel.node),start=sel.from+1,lastCell=start+map.map[map.width*map.height-1];normalize=CellSelection.create(doc,start+1,lastCell)}}else sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .TextSelection */.Bs&&isCellBoundarySelection(sel)?normalize=prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .TextSelection */.Bs.create(doc,sel.from):sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .TextSelection */.Bs&&isTextSelectionAcrossCells(sel)&&(normalize=prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .TextSelection */.Bs.create(doc,sel.$from.start(),sel.$from.end()));return normalize&&(tr||(tr=state.tr)).setSelection(normalize),tr}
// src/fixtables.ts
var fixTablesKey=new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .PluginKey */.H$("fix-tables");function changedDescendants(old,cur,offset,f){const oldSize=old.childCount,curSize=cur.childCount;outer:for(let i=0,j=0;i<curSize;i++){const child=cur.child(i);for(let scan=j,e=Math.min(oldSize,i+3);scan<e;scan++)if(old.child(scan)==child){j=scan+1,offset+=child.nodeSize;continue outer}f(child,offset),j<oldSize&&old.child(j).sameMarkup(child)?changedDescendants(old.child(j),child,offset+1,f):child.nodesBetween(0,child.content.size,f,offset+1),offset+=child.nodeSize}}function fixTables(state,oldState){let tr;const check=(node,pos)=>{"table"==node.type.spec.tableRole&&(tr=fixTable(state,node,pos,tr))};return oldState?oldState.doc!=state.doc&&changedDescendants(oldState.doc,state.doc,0,check):state.doc.descendants(check),tr}function fixTable(state,table,tablePos,tr){const map=TableMap.get(table);if(!map.problems)return tr;tr||(tr=state.tr);const mustAdd=[];for(let i=0;i<map.height;i++)mustAdd.push(0);for(let i=0;i<map.problems.length;i++){const prob=map.problems[i];if("collision"==prob.type){const cell=table.nodeAt(prob.pos);if(!cell)continue;const attrs=cell.attrs;for(let j=0;j<attrs.rowspan;j++)mustAdd[prob.row+j]+=prob.n;tr.setNodeMarkup(tr.mapping.map(tablePos+1+prob.pos),null,removeColSpan(attrs,attrs.colspan-prob.n,prob.n))}else if("missing"==prob.type)mustAdd[prob.row]+=prob.n;else if("overlong_rowspan"==prob.type){const cell=table.nodeAt(prob.pos);if(!cell)continue;tr.setNodeMarkup(tr.mapping.map(tablePos+1+prob.pos),null,{...cell.attrs,rowspan:cell.attrs.rowspan-prob.n})}else if("colwidth mismatch"==prob.type){const cell=table.nodeAt(prob.pos);if(!cell)continue;tr.setNodeMarkup(tr.mapping.map(tablePos+1+prob.pos),null,{...cell.attrs,colwidth:prob.colwidth})}}let first,last;for(let i=0;i<mustAdd.length;i++)mustAdd[i]&&(null==first&&(first=i),last=i);for(let i=0,pos=tablePos+1;i<map.height;i++){const row=table.child(i),end=pos+row.nodeSize,add=mustAdd[i];if(add>0){let role="cell";row.firstChild&&(role=row.firstChild.type.spec.tableRole);const nodes=[];for(let j=0;j<add;j++){const node=tableNodeTypes(state.schema)[role].createAndFill();node&&nodes.push(node)}const side=0!=i&&first!=i-1||last!=i?end-1:pos+1;tr.insert(tr.mapping.map(side),nodes)}pos=end}return tr.setMeta(fixTablesKey,{fixTables:!0})}
// src/input.ts
// src/copypaste.ts
function pastedCells(slice){if(!slice.size)return null;let{content:content,openStart:openStart,openEnd:openEnd}=slice;while(1==content.childCount&&(openStart>0&&openEnd>0||"table"==content.child(0).type.spec.tableRole))openStart--,openEnd--,content=content.child(0).content;const first=content.child(0),role=first.type.spec.tableRole,schema=first.type.schema,rows=[];if("row"==role)for(let i=0;i<content.childCount;i++){let cells=content.child(i).content;const left=i?0:Math.max(0,openStart-1),right=i<content.childCount-1?0:Math.max(0,openEnd-1);(left||right)&&(cells=fitSlice(tableNodeTypes(schema).row,new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Slice */.p2(cells,left,right)).content),rows.push(cells)}else{if("cell"!=role&&"header_cell"!=role)return null;rows.push(openStart||openEnd?fitSlice(tableNodeTypes(schema).row,new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Slice */.p2(content,openStart,openEnd)).content:content)}return ensureRectangular(schema,rows)}function ensureRectangular(schema,rows){const widths=[];for(let i=0;i<rows.length;i++){const row=rows[i];for(let j=row.childCount-1;j>=0;j--){const{rowspan:rowspan,colspan:colspan}=row.child(j).attrs;for(let r=i;r<i+rowspan;r++)widths[r]=(widths[r]||0)+colspan}}let width=0;for(let r=0;r<widths.length;r++)width=Math.max(width,widths[r]);for(let r=0;r<widths.length;r++)if(r>=rows.length&&rows.push(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Fragment */.HY.empty),widths[r]<width){const empty=tableNodeTypes(schema).cell.createAndFill(),cells=[];for(let i=widths[r];i<width;i++)cells.push(empty);rows[r]=rows[r].append(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Fragment */.HY.from(cells))}return{height:rows.length,width:width,rows:rows}}function fitSlice(nodeType,slice){const node=nodeType.createAndFill(),tr=new prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__/* .Transform */.wx(node).replace(0,node.content.size,slice);return tr.doc}function clipCells({width:width,height:height,rows:rows},newWidth,newHeight){if(width!=newWidth){const added=[],newRows=[];for(let row=0;row<rows.length;row++){const frag=rows[row],cells=[];for(let col=added[row]||0,i=0;col<newWidth;i++){let cell=frag.child(i%frag.childCount);col+cell.attrs.colspan>newWidth&&(cell=cell.type.createChecked(removeColSpan(cell.attrs,cell.attrs.colspan,col+cell.attrs.colspan-newWidth),cell.content)),cells.push(cell),col+=cell.attrs.colspan;for(let j=1;j<cell.attrs.rowspan;j++)added[row+j]=(added[row+j]||0)+cell.attrs.colspan}newRows.push(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Fragment */.HY.from(cells))}rows=newRows,width=newWidth}if(height!=newHeight){const newRows=[];for(let row=0,i=0;row<newHeight;row++,i++){const cells=[],source=rows[i%height];for(let j=0;j<source.childCount;j++){let cell=source.child(j);row+cell.attrs.rowspan>newHeight&&(cell=cell.type.create({...cell.attrs,rowspan:Math.max(1,newHeight-cell.attrs.rowspan)},cell.content)),cells.push(cell)}newRows.push(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Fragment */.HY.from(cells))}rows=newRows,height=newHeight}return{width:width,height:height,rows:rows}}function growTable(tr,map,table,start,width,height,mapFrom){const schema=tr.doc.type.schema,types=tableNodeTypes(schema);let empty,emptyHead;if(width>map.width)for(let row=0,rowEnd=0;row<map.height;row++){const rowNode=table.child(row);rowEnd+=rowNode.nodeSize;const cells=[];let add;add=null==rowNode.lastChild||rowNode.lastChild.type==types.cell?empty||(empty=types.cell.createAndFill()):emptyHead||(emptyHead=types.header_cell.createAndFill());for(let i=map.width;i<width;i++)cells.push(add);tr.insert(tr.mapping.slice(mapFrom).map(rowEnd-1+start),cells)}if(height>map.height){const cells=[];for(let i=0,start2=(map.height-1)*map.width;i<Math.max(map.width,width);i++){const header=!(i>=map.width)&&table.nodeAt(map.map[start2+i]).type==types.header_cell;cells.push(header?emptyHead||(emptyHead=types.header_cell.createAndFill()):empty||(empty=types.cell.createAndFill()))}const emptyRow=types.row.create(null,prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Fragment */.HY.from(cells)),rows=[];for(let i=map.height;i<height;i++)rows.push(emptyRow);tr.insert(tr.mapping.slice(mapFrom).map(start+table.nodeSize-2),rows)}return!(!empty&&!emptyHead)}function isolateHorizontal(tr,map,table,start,left,right,top,mapFrom){if(0==top||top==map.height)return!1;let found=!1;for(let col=left;col<right;col++){const index=top*map.width+col,pos=map.map[index];if(map.map[index-map.width]==pos){found=!0;const cell=table.nodeAt(pos),{top:cellTop,left:cellLeft}=map.findCell(pos);tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos+start),null,{...cell.attrs,rowspan:top-cellTop}),tr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top,cellLeft,table)),cell.type.createAndFill({...cell.attrs,rowspan:cellTop+cell.attrs.rowspan-top})),col+=cell.attrs.colspan-1}}return found}function isolateVertical(tr,map,table,start,top,bottom,left,mapFrom){if(0==left||left==map.width)return!1;let found=!1;for(let row=top;row<bottom;row++){const index=row*map.width+left,pos=map.map[index];if(map.map[index-1]==pos){found=!0;const cell=table.nodeAt(pos),cellLeft=map.colCount(pos),updatePos=tr.mapping.slice(mapFrom).map(pos+start);tr.setNodeMarkup(updatePos,null,removeColSpan(cell.attrs,left-cellLeft,cell.attrs.colspan-(left-cellLeft))),tr.insert(updatePos+cell.nodeSize,cell.type.createAndFill(removeColSpan(cell.attrs,0,left-cellLeft))),row+=cell.attrs.rowspan-1}}return found}function insertCells(state,dispatch,tableStart,rect,cells){let table=tableStart?state.doc.nodeAt(tableStart-1):state.doc;if(!table)throw new Error("No table found");let map=TableMap.get(table);const{top:top,left:left}=rect,right=left+cells.width,bottom=top+cells.height,tr=state.tr;let mapFrom=0;function recomp(){if(table=tableStart?tr.doc.nodeAt(tableStart-1):tr.doc,!table)throw new Error("No table found");map=TableMap.get(table),mapFrom=tr.mapping.maps.length}growTable(tr,map,table,tableStart,right,bottom,mapFrom)&&recomp(),isolateHorizontal(tr,map,table,tableStart,left,right,top,mapFrom)&&recomp(),isolateHorizontal(tr,map,table,tableStart,left,right,bottom,mapFrom)&&recomp(),isolateVertical(tr,map,table,tableStart,top,bottom,left,mapFrom)&&recomp(),isolateVertical(tr,map,table,tableStart,top,bottom,right,mapFrom)&&recomp();for(let row=top;row<bottom;row++){const from=map.positionAt(row,left,table),to=map.positionAt(row,right,table);tr.replace(tr.mapping.slice(mapFrom).map(from+tableStart),tr.mapping.slice(mapFrom).map(to+tableStart),new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Slice */.p2(cells.rows[row-top],0,0))}recomp(),tr.setSelection(new CellSelection(tr.doc.resolve(tableStart+map.positionAt(top,left,table)),tr.doc.resolve(tableStart+map.positionAt(bottom-1,right-1,table)))),dispatch(tr)}
// src/input.ts
var handleKeyDown=(0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_4__/* .keydownHandler */.$)({ArrowLeft:arrow("horiz",-1),ArrowRight:arrow("horiz",1),ArrowUp:arrow("vert",-1),ArrowDown:arrow("vert",1),"Shift-ArrowLeft":shiftArrow("horiz",-1),"Shift-ArrowRight":shiftArrow("horiz",1),"Shift-ArrowUp":shiftArrow("vert",-1),"Shift-ArrowDown":shiftArrow("vert",1),Backspace:deleteCellSelection,"Mod-Backspace":deleteCellSelection,Delete:deleteCellSelection,"Mod-Delete":deleteCellSelection});function maybeSetSelection(state,dispatch,selection){return!selection.eq(state.selection)&&(dispatch&&dispatch(state.tr.setSelection(selection).scrollIntoView()),!0)}function arrow(axis,dir){return(state,dispatch,view)=>{if(!view)return!1;const sel=state.selection;if(sel instanceof CellSelection)return maybeSetSelection(state,dispatch,prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .Selection */.Y1.near(sel.$headCell,dir));if("horiz"!=axis&&!sel.empty)return!1;const end=atEndOfCell(view,axis,dir);if(null==end)return!1;if("horiz"==axis)return maybeSetSelection(state,dispatch,prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .Selection */.Y1.near(state.doc.resolve(sel.head+dir),dir));{const $cell=state.doc.resolve(end),$next=nextCell($cell,axis,dir);let newSel;return newSel=$next?prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .Selection */.Y1.near($next,1):dir<0?prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .Selection */.Y1.near(state.doc.resolve($cell.before(-1)),-1):prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .Selection */.Y1.near(state.doc.resolve($cell.after(-1)),1),maybeSetSelection(state,dispatch,newSel)}}}function shiftArrow(axis,dir){return(state,dispatch,view)=>{if(!view)return!1;const sel=state.selection;let cellSel;if(sel instanceof CellSelection)cellSel=sel;else{const end=atEndOfCell(view,axis,dir);if(null==end)return!1;cellSel=new CellSelection(state.doc.resolve(end))}const $head=nextCell(cellSel.$headCell,axis,dir);return!!$head&&maybeSetSelection(state,dispatch,new CellSelection(cellSel.$anchorCell,$head))}}function deleteCellSelection(state,dispatch){const sel=state.selection;if(!(sel instanceof CellSelection))return!1;if(dispatch){const tr=state.tr,baseContent=tableNodeTypes(state.schema).cell.createAndFill().content;sel.forEachCell(((cell,pos)=>{cell.content.eq(baseContent)||tr.replace(tr.mapping.map(pos+1),tr.mapping.map(pos+cell.nodeSize-1),new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Slice */.p2(baseContent,0,0))})),tr.docChanged&&dispatch(tr)}return!0}function handleTripleClick(view,pos){const doc=view.state.doc,$cell=cellAround(doc.resolve(pos));return!!$cell&&(view.dispatch(view.state.tr.setSelection(new CellSelection($cell))),!0)}function handlePaste(view,_,slice){if(!isInTable(view.state))return!1;let cells=pastedCells(slice);const sel=view.state.selection;if(sel instanceof CellSelection){cells||(cells={width:1,height:1,rows:[prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Fragment */.HY.from(fitSlice(tableNodeTypes(view.state.schema).cell,slice))]});const table=sel.$anchorCell.node(-1),start=sel.$anchorCell.start(-1),rect=TableMap.get(table).rectBetween(sel.$anchorCell.pos-start,sel.$headCell.pos-start);return cells=clipCells(cells,rect.right-rect.left,rect.bottom-rect.top),insertCells(view.state,view.dispatch,start,rect,cells),!0}if(cells){const $cell=selectionCell(view.state),start=$cell.start(-1);return insertCells(view.state,view.dispatch,start,TableMap.get($cell.node(-1)).findCell($cell.pos-start),cells),!0}return!1}function handleMouseDown(view,startEvent){var _a;if(startEvent.ctrlKey||startEvent.metaKey)return;const startDOMCell=domInCell(view,startEvent.target);let $anchor;if(startEvent.shiftKey&&view.state.selection instanceof CellSelection)setCellSelection(view.state.selection.$anchorCell,startEvent),startEvent.preventDefault();else if(startEvent.shiftKey&&startDOMCell&&null!=($anchor=cellAround(view.state.selection.$anchor))&&(null==(_a=cellUnderMouse(view,startEvent))?void 0:_a.pos)!=$anchor.pos)setCellSelection($anchor,startEvent),startEvent.preventDefault();else if(!startDOMCell)return;function setCellSelection($anchor2,event){let $head=cellUnderMouse(view,event);const starting=null==tableEditingKey.getState(view.state);if(!$head||!inSameTable($anchor2,$head)){if(!starting)return;$head=$anchor2}const selection=new CellSelection($anchor2,$head);if(starting||!view.state.selection.eq(selection)){const tr=view.state.tr.setSelection(selection);starting&&tr.setMeta(tableEditingKey,$anchor2.pos),view.dispatch(tr)}}function stop(){view.root.removeEventListener("mouseup",stop),view.root.removeEventListener("dragstart",stop),view.root.removeEventListener("mousemove",move),null!=tableEditingKey.getState(view.state)&&view.dispatch(view.state.tr.setMeta(tableEditingKey,-1))}function move(_event){const event=_event,anchor=tableEditingKey.getState(view.state);let $anchor2;if(null!=anchor)$anchor2=view.state.doc.resolve(anchor);else if(domInCell(view,event.target)!=startDOMCell&&($anchor2=cellUnderMouse(view,startEvent),!$anchor2))return stop();$anchor2&&setCellSelection($anchor2,event)}view.root.addEventListener("mouseup",stop),view.root.addEventListener("dragstart",stop),view.root.addEventListener("mousemove",move)}function atEndOfCell(view,axis,dir){if(!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .TextSelection */.Bs))return null;const{$head:$head}=view.state.selection;for(let d=$head.depth-1;d>=0;d--){const parent=$head.node(d),index=dir<0?$head.index(d):$head.indexAfter(d);if(index!=(dir<0?0:parent.childCount))return null;if("cell"==parent.type.spec.tableRole||"header_cell"==parent.type.spec.tableRole){const cellPos=$head.before(d),dirStr="vert"==axis?dir>0?"down":"up":dir>0?"right":"left";return view.endOfTextblock(dirStr)?cellPos:null}}return null}function domInCell(view,dom){for(;dom&&dom!=view.dom;dom=dom.parentNode)if("TD"==dom.nodeName||"TH"==dom.nodeName)return dom;return null}function cellUnderMouse(view,event){const mousePos=view.posAtCoords({left:event.clientX,top:event.clientY});return mousePos&&mousePos?cellAround(view.state.doc.resolve(mousePos.pos)):null}
// src/columnresizing.ts
// src/tableview.ts
var TableView=class{constructor(node,cellMinWidth){this.node=node,this.cellMinWidth=cellMinWidth,this.dom=document.createElement("div"),this.dom.className="tableWrapper",this.table=this.dom.appendChild(document.createElement("table")),this.colgroup=this.table.appendChild(document.createElement("colgroup")),updateColumnsOnResize(node,this.colgroup,this.table,cellMinWidth),this.contentDOM=this.table.appendChild(document.createElement("tbody"))}update(node){return node.type==this.node.type&&(this.node=node,updateColumnsOnResize(node,this.colgroup,this.table,this.cellMinWidth),!0)}ignoreMutation(record){return"attributes"==record.type&&(record.target==this.table||this.colgroup.contains(record.target))}};function updateColumnsOnResize(node,colgroup,table,cellMinWidth,overrideCol,overrideValue){var _a;let totalWidth=0,fixedWidth=!0,nextDOM=colgroup.firstChild;const row=node.firstChild;if(row){for(let i=0,col=0;i<row.childCount;i++){const{colspan:colspan,colwidth:colwidth}=row.child(i).attrs;for(let j=0;j<colspan;j++,col++){const hasWidth=overrideCol==col?overrideValue:colwidth&&colwidth[j],cssWidth=hasWidth?hasWidth+"px":"";totalWidth+=hasWidth||cellMinWidth,hasWidth||(fixedWidth=!1),nextDOM?(nextDOM.style.width!=cssWidth&&(nextDOM.style.width=cssWidth),nextDOM=nextDOM.nextSibling):colgroup.appendChild(document.createElement("col")).style.width=cssWidth}}while(nextDOM){const after=nextDOM.nextSibling;null==(_a=nextDOM.parentNode)||_a.removeChild(nextDOM),nextDOM=after}fixedWidth?(table.style.width=totalWidth+"px",table.style.minWidth=""):(table.style.width="",table.style.minWidth=totalWidth+"px")}}
// src/columnresizing.ts
var columnResizingPluginKey=new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .PluginKey */.H$("tableColumnResizing");function columnResizing({handleWidth:handleWidth=5,cellMinWidth:cellMinWidth=25,View:View=TableView,lastColumnResizable:lastColumnResizable=!0}={}){const plugin=new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .Plugin */.Sy({key:columnResizingPluginKey,state:{init(_,state){return plugin.spec.props.nodeViews[tableNodeTypes(state.schema).table.name]=(node,view)=>new View(node,cellMinWidth,view),new ResizeState(-1,!1)},apply(tr,prev){return prev.apply(tr)}},props:{attributes:state=>{const pluginState=columnResizingPluginKey.getState(state);return pluginState&&pluginState.activeHandle>-1?{class:"resize-cursor"}:{}},handleDOMEvents:{mousemove:(view,event)=>{handleMouseMove(view,event,handleWidth,cellMinWidth,lastColumnResizable)},mouseleave:view=>{handleMouseLeave(view)},mousedown:(view,event)=>{handleMouseDown2(view,event,cellMinWidth)}},decorations:state=>{const pluginState=columnResizingPluginKey.getState(state);if(pluginState&&pluginState.activeHandle>-1)return handleDecorations(state,pluginState.activeHandle)},nodeViews:{}}});return plugin}var ResizeState=class{constructor(activeHandle,dragging){this.activeHandle=activeHandle,this.dragging=dragging}apply(tr){const state=this,action=tr.getMeta(columnResizingPluginKey);if(action&&null!=action.setHandle)return new ResizeState(action.setHandle,!1);if(action&&void 0!==action.setDragging)return new ResizeState(state.activeHandle,action.setDragging);if(state.activeHandle>-1&&tr.docChanged){let handle=tr.mapping.map(state.activeHandle,-1);return pointsAtCell(tr.doc.resolve(handle))||(handle=-1),new ResizeState(handle,state.dragging)}return state}};function handleMouseMove(view,event,handleWidth,cellMinWidth,lastColumnResizable){const pluginState=columnResizingPluginKey.getState(view.state);if(pluginState&&!pluginState.dragging){const target=domCellAround(event.target);let cell=-1;if(target){const{left:left,right:right}=target.getBoundingClientRect();event.clientX-left<=handleWidth?cell=edgeCell(view,event,"left",handleWidth):right-event.clientX<=handleWidth&&(cell=edgeCell(view,event,"right",handleWidth))}if(cell!=pluginState.activeHandle){if(!lastColumnResizable&&-1!==cell){const $cell=view.state.doc.resolve(cell),table=$cell.node(-1),map=TableMap.get(table),tableStart=$cell.start(-1),col=map.colCount($cell.pos-tableStart)+$cell.nodeAfter.attrs.colspan-1;if(col==map.width-1)return}updateHandle(view,cell)}}}function handleMouseLeave(view){const pluginState=columnResizingPluginKey.getState(view.state);pluginState&&pluginState.activeHandle>-1&&!pluginState.dragging&&updateHandle(view,-1)}function handleMouseDown2(view,event,cellMinWidth){const pluginState=columnResizingPluginKey.getState(view.state);if(!pluginState||-1==pluginState.activeHandle||pluginState.dragging)return!1;const cell=view.state.doc.nodeAt(pluginState.activeHandle),width=currentColWidth(view,pluginState.activeHandle,cell.attrs);function finish(event2){window.removeEventListener("mouseup",finish),window.removeEventListener("mousemove",move);const pluginState2=columnResizingPluginKey.getState(view.state);(null==pluginState2?void 0:pluginState2.dragging)&&(updateColumnWidth(view,pluginState2.activeHandle,draggedWidth(pluginState2.dragging,event2,cellMinWidth)),view.dispatch(view.state.tr.setMeta(columnResizingPluginKey,{setDragging:null})))}function move(event2){if(!event2.which)return finish(event2);const pluginState2=columnResizingPluginKey.getState(view.state);if(pluginState2&&pluginState2.dragging){const dragged=draggedWidth(pluginState2.dragging,event2,cellMinWidth);displayColumnWidth(view,pluginState2.activeHandle,dragged,cellMinWidth)}}return view.dispatch(view.state.tr.setMeta(columnResizingPluginKey,{setDragging:{startX:event.clientX,startWidth:width}})),window.addEventListener("mouseup",finish),window.addEventListener("mousemove",move),event.preventDefault(),!0}function currentColWidth(view,cellPos,{colspan:colspan,colwidth:colwidth}){const width=colwidth&&colwidth[colwidth.length-1];if(width)return width;const dom=view.domAtPos(cellPos),node=dom.node.childNodes[dom.offset];let domWidth=node.offsetWidth,parts=colspan;if(colwidth)for(let i=0;i<colspan;i++)colwidth[i]&&(domWidth-=colwidth[i],parts--);return domWidth/parts}function domCellAround(target){while(target&&"TD"!=target.nodeName&&"TH"!=target.nodeName)target=target.classList&&target.classList.contains("ProseMirror")?null:target.parentNode;return target}function edgeCell(view,event,side,handleWidth){const offset="right"==side?-handleWidth:handleWidth,found=view.posAtCoords({left:event.clientX+offset,top:event.clientY});if(!found)return-1;const{pos:pos}=found,$cell=cellAround(view.state.doc.resolve(pos));if(!$cell)return-1;if("right"==side)return $cell.pos;const map=TableMap.get($cell.node(-1)),start=$cell.start(-1),index=map.map.indexOf($cell.pos-start);return index%map.width==0?-1:start+map.map[index-1]}function draggedWidth(dragging,event,cellMinWidth){const offset=event.clientX-dragging.startX;return Math.max(cellMinWidth,dragging.startWidth+offset)}function updateHandle(view,value){view.dispatch(view.state.tr.setMeta(columnResizingPluginKey,{setHandle:value}))}function updateColumnWidth(view,cell,width){const $cell=view.state.doc.resolve(cell),table=$cell.node(-1),map=TableMap.get(table),start=$cell.start(-1),col=map.colCount($cell.pos-start)+$cell.nodeAfter.attrs.colspan-1,tr=view.state.tr;for(let row=0;row<map.height;row++){const mapIndex=row*map.width+col;if(row&&map.map[mapIndex]==map.map[mapIndex-map.width])continue;const pos=map.map[mapIndex],attrs=table.nodeAt(pos).attrs,index=1==attrs.colspan?0:col-map.colCount(pos);if(attrs.colwidth&&attrs.colwidth[index]==width)continue;const colwidth=attrs.colwidth?attrs.colwidth.slice():zeroes(attrs.colspan);colwidth[index]=width,tr.setNodeMarkup(start+pos,null,{...attrs,colwidth:colwidth})}tr.docChanged&&view.dispatch(tr)}function displayColumnWidth(view,cell,width,cellMinWidth){const $cell=view.state.doc.resolve(cell),table=$cell.node(-1),start=$cell.start(-1),col=TableMap.get(table).colCount($cell.pos-start)+$cell.nodeAfter.attrs.colspan-1;let dom=view.domAtPos($cell.start(-1)).node;while(dom&&"TABLE"!=dom.nodeName)dom=dom.parentNode;dom&&updateColumnsOnResize(table,dom.firstChild,dom,cellMinWidth,col,width)}function zeroes(n){return Array(n).fill(0)}function handleDecorations(state,cell){const decorations=[],$cell=state.doc.resolve(cell),table=$cell.node(-1);if(!table)return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__/* .DecorationSet */.EH.empty;const map=TableMap.get(table),start=$cell.start(-1),col=map.colCount($cell.pos-start)+$cell.nodeAfter.attrs.colspan;for(let row=0;row<map.height;row++){const index=col+row*map.width-1;if((col==map.width||map.map[index]!=map.map[index+1])&&(0==row||map.map[index]!=map.map[index-map.width])){const cellPos=map.map[index],pos=start+cellPos+table.nodeAt(cellPos).nodeSize-1,dom=document.createElement("div");dom.className="column-resize-handle",decorations.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_2__/* .Decoration */.p.widget(pos,dom))}}return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__/* .DecorationSet */.EH.create(state.doc,decorations)}
// src/commands.ts
function selectedRect(state){const sel=state.selection,$pos=selectionCell(state),table=$pos.node(-1),tableStart=$pos.start(-1),map=TableMap.get(table),rect=sel instanceof CellSelection?map.rectBetween(sel.$anchorCell.pos-tableStart,sel.$headCell.pos-tableStart):map.findCell($pos.pos-tableStart);return{...rect,tableStart:tableStart,map:map,table:table}}function addColumn(tr,{map:map,tableStart:tableStart,table:table},col){let refColumn=col>0?-1:0;columnIsHeader(map,table,col+refColumn)&&(refColumn=0==col||col==map.width?null:0);for(let row=0;row<map.height;row++){const index=row*map.width+col;if(col>0&&col<map.width&&map.map[index-1]==map.map[index]){const pos=map.map[index],cell=table.nodeAt(pos);tr.setNodeMarkup(tr.mapping.map(tableStart+pos),null,addColSpan(cell.attrs,col-map.colCount(pos))),row+=cell.attrs.rowspan-1}else{const type=null==refColumn?tableNodeTypes(table.type.schema).cell:table.nodeAt(map.map[index+refColumn]).type,pos=map.positionAt(row,col,table);tr.insert(tr.mapping.map(tableStart+pos),type.createAndFill())}}return tr}function addColumnBefore(state,dispatch){if(!isInTable(state))return!1;if(dispatch){const rect=selectedRect(state);dispatch(addColumn(state.tr,rect,rect.left))}return!0}function addColumnAfter(state,dispatch){if(!isInTable(state))return!1;if(dispatch){const rect=selectedRect(state);dispatch(addColumn(state.tr,rect,rect.right))}return!0}function removeColumn(tr,{map:map,table:table,tableStart:tableStart},col){const mapStart=tr.mapping.maps.length;for(let row=0;row<map.height;){const index=row*map.width+col,pos=map.map[index],cell=table.nodeAt(pos),attrs=cell.attrs;if(col>0&&map.map[index-1]==pos||col<map.width-1&&map.map[index+1]==pos)tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart+pos),null,removeColSpan(attrs,col-map.colCount(pos)));else{const start=tr.mapping.slice(mapStart).map(tableStart+pos);tr.delete(start,start+cell.nodeSize)}row+=attrs.rowspan}}function deleteColumn(state,dispatch){if(!isInTable(state))return!1;if(dispatch){const rect=selectedRect(state),tr=state.tr;if(0==rect.left&&rect.right==rect.map.width)return!1;for(let i=rect.right-1;;i--){if(removeColumn(tr,rect,i),i==rect.left)break;const table=rect.tableStart?tr.doc.nodeAt(rect.tableStart-1):tr.doc;if(!table)throw RangeError("No table found");rect.table=table,rect.map=TableMap.get(table)}dispatch(tr)}return!0}function rowIsHeader(map,table,row){var _a;const headerCell=tableNodeTypes(table.type.schema).header_cell;for(let col=0;col<map.width;col++)if((null==(_a=table.nodeAt(map.map[col+row*map.width]))?void 0:_a.type)!=headerCell)return!1;return!0}function addRow(tr,{map:map,tableStart:tableStart,table:table},row){var _a;let rowPos=tableStart;for(let i=0;i<row;i++)rowPos+=table.child(i).nodeSize;const cells=[];let refRow=row>0?-1:0;rowIsHeader(map,table,row+refRow)&&(refRow=0==row||row==map.height?null:0);for(let col=0,index=map.width*row;col<map.width;col++,index++)if(row>0&&row<map.height&&map.map[index]==map.map[index-map.width]){const pos=map.map[index],attrs=table.nodeAt(pos).attrs;tr.setNodeMarkup(tableStart+pos,null,{...attrs,rowspan:attrs.rowspan+1}),col+=attrs.colspan-1}else{const type=null==refRow?tableNodeTypes(table.type.schema).cell:null==(_a=table.nodeAt(map.map[index+refRow*map.width]))?void 0:_a.type,node=null==type?void 0:type.createAndFill();node&&cells.push(node)}return tr.insert(rowPos,tableNodeTypes(table.type.schema).row.create(null,cells)),tr}function addRowBefore(state,dispatch){if(!isInTable(state))return!1;if(dispatch){const rect=selectedRect(state);dispatch(addRow(state.tr,rect,rect.top))}return!0}function addRowAfter(state,dispatch){if(!isInTable(state))return!1;if(dispatch){const rect=selectedRect(state);dispatch(addRow(state.tr,rect,rect.bottom))}return!0}function removeRow(tr,{map:map,table:table,tableStart:tableStart},row){let rowPos=0;for(let i=0;i<row;i++)rowPos+=table.child(i).nodeSize;const nextRow=rowPos+table.child(row).nodeSize,mapFrom=tr.mapping.maps.length;tr.delete(rowPos+tableStart,nextRow+tableStart);for(let col=0,index=row*map.width;col<map.width;col++,index++){const pos=map.map[index];if(row>0&&pos==map.map[index-map.width]){const attrs=table.nodeAt(pos).attrs;tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos+tableStart),null,{...attrs,rowspan:attrs.rowspan-1}),col+=attrs.colspan-1}else if(row<map.width&&pos==map.map[index+map.width]){const cell=table.nodeAt(pos),attrs=cell.attrs,copy=cell.type.create({...attrs,rowspan:cell.attrs.rowspan-1},cell.content),newPos=map.positionAt(row+1,col,table);tr.insert(tr.mapping.slice(mapFrom).map(tableStart+newPos),copy),col+=attrs.colspan-1}}}function deleteRow(state,dispatch){if(!isInTable(state))return!1;if(dispatch){const rect=selectedRect(state),tr=state.tr;if(0==rect.top&&rect.bottom==rect.map.height)return!1;for(let i=rect.bottom-1;;i--){if(removeRow(tr,rect,i),i==rect.top)break;const table=rect.tableStart?tr.doc.nodeAt(rect.tableStart-1):tr.doc;if(!table)throw RangeError("No table found");rect.table=table,rect.map=TableMap.get(rect.table)}dispatch(tr)}return!0}function isEmpty(cell){const c=cell.content;return 1==c.childCount&&c.child(0).isTextblock&&0==c.child(0).childCount}function cellsOverlapRectangle({width:width,height:height,map:map},rect){let indexTop=rect.top*width+rect.left,indexLeft=indexTop,indexBottom=(rect.bottom-1)*width+rect.left,indexRight=indexTop+(rect.right-rect.left-1);for(let i=rect.top;i<rect.bottom;i++){if(rect.left>0&&map[indexLeft]==map[indexLeft-1]||rect.right<width&&map[indexRight]==map[indexRight+1])return!0;indexLeft+=width,indexRight+=width}for(let i=rect.left;i<rect.right;i++){if(rect.top>0&&map[indexTop]==map[indexTop-width]||rect.bottom<height&&map[indexBottom]==map[indexBottom+width])return!0;indexTop++,indexBottom++}return!1}function mergeCells(state,dispatch){const sel=state.selection;if(!(sel instanceof CellSelection)||sel.$anchorCell.pos==sel.$headCell.pos)return!1;const rect=selectedRect(state),{map:map}=rect;if(cellsOverlapRectangle(map,rect))return!1;if(dispatch){const tr=state.tr,seen={};let mergedPos,mergedCell,content=prosemirror_model__WEBPACK_IMPORTED_MODULE_1__/* .Fragment */.HY.empty;for(let row=rect.top;row<rect.bottom;row++)for(let col=rect.left;col<rect.right;col++){const cellPos=map.map[row*map.width+col],cell=rect.table.nodeAt(cellPos);if(!seen[cellPos]&&cell)if(seen[cellPos]=!0,null==mergedPos)mergedPos=cellPos,mergedCell=cell;else{isEmpty(cell)||(content=content.append(cell.content));const mapped=tr.mapping.map(cellPos+rect.tableStart);tr.delete(mapped,mapped+cell.nodeSize)}}if(null==mergedPos||null==mergedCell)return!0;if(tr.setNodeMarkup(mergedPos+rect.tableStart,null,{...addColSpan(mergedCell.attrs,mergedCell.attrs.colspan,rect.right-rect.left-mergedCell.attrs.colspan),rowspan:rect.bottom-rect.top}),content.size){const end=mergedPos+1+mergedCell.content.size,start=isEmpty(mergedCell)?mergedPos+1:end;tr.replaceWith(start+rect.tableStart,end+rect.tableStart,content)}tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos+rect.tableStart))),dispatch(tr)}return!0}function splitCell(state,dispatch){const nodeTypes=tableNodeTypes(state.schema);return splitCellWithType((({node:node})=>nodeTypes[node.type.spec.tableRole]))(state,dispatch)}function splitCellWithType(getCellType){return(state,dispatch)=>{var _a;const sel=state.selection;let cellNode,cellPos;if(sel instanceof CellSelection){if(sel.$anchorCell.pos!=sel.$headCell.pos)return!1;cellNode=sel.$anchorCell.nodeAfter,cellPos=sel.$anchorCell.pos}else{if(cellNode=cellWrapping(sel.$from),!cellNode)return!1;cellPos=null==(_a=cellAround(sel.$from))?void 0:_a.pos}if(null==cellNode||null==cellPos)return!1;if(1==cellNode.attrs.colspan&&1==cellNode.attrs.rowspan)return!1;if(dispatch){let baseAttrs=cellNode.attrs;const attrs=[],colwidth=baseAttrs.colwidth;baseAttrs.rowspan>1&&(baseAttrs={...baseAttrs,rowspan:1}),baseAttrs.colspan>1&&(baseAttrs={...baseAttrs,colspan:1});const rect=selectedRect(state),tr=state.tr;for(let i=0;i<rect.right-rect.left;i++)attrs.push(colwidth?{...baseAttrs,colwidth:colwidth&&colwidth[i]?[colwidth[i]]:null}:baseAttrs);let lastCell;for(let row=rect.top;row<rect.bottom;row++){let pos=rect.map.positionAt(row,rect.left,rect.table);row==rect.top&&(pos+=cellNode.nodeSize);for(let col=rect.left,i=0;col<rect.right;col++,i++)col==rect.left&&row==rect.top||tr.insert(lastCell=tr.mapping.map(pos+rect.tableStart,1),getCellType({node:cellNode,row:row,col:col}).createAndFill(attrs[i]))}tr.setNodeMarkup(cellPos,getCellType({node:cellNode,row:rect.top,col:rect.left}),attrs[0]),sel instanceof CellSelection&&tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos),lastCell?tr.doc.resolve(lastCell):void 0)),dispatch(tr)}return!0}}function setCellAttr(name,value){return function(state,dispatch){if(!isInTable(state))return!1;const $cell=selectionCell(state);if($cell.nodeAfter.attrs[name]===value)return!1;if(dispatch){const tr=state.tr;state.selection instanceof CellSelection?state.selection.forEachCell(((node,pos)=>{node.attrs[name]!==value&&tr.setNodeMarkup(pos,null,{...node.attrs,[name]:value})})):tr.setNodeMarkup($cell.pos,null,{...$cell.nodeAfter.attrs,[name]:value}),dispatch(tr)}return!0}}function deprecated_toggleHeader(type){return function(state,dispatch){if(!isInTable(state))return!1;if(dispatch){const types=tableNodeTypes(state.schema),rect=selectedRect(state),tr=state.tr,cells=rect.map.cellsInRect("column"==type?{left:rect.left,top:0,right:rect.right,bottom:rect.map.height}:"row"==type?{left:0,top:rect.top,right:rect.map.width,bottom:rect.bottom}:rect),nodes=cells.map((pos=>rect.table.nodeAt(pos)));for(let i=0;i<cells.length;i++)nodes[i].type==types.header_cell&&tr.setNodeMarkup(rect.tableStart+cells[i],types.cell,nodes[i].attrs);if(0==tr.steps.length)for(let i=0;i<cells.length;i++)tr.setNodeMarkup(rect.tableStart+cells[i],types.header_cell,nodes[i].attrs);dispatch(tr)}return!0}}function isHeaderEnabledByType(type,rect,types){const cellPositions=rect.map.cellsInRect({left:0,top:0,right:"row"==type?rect.map.width:1,bottom:"column"==type?rect.map.height:1});for(let i=0;i<cellPositions.length;i++){const cell=rect.table.nodeAt(cellPositions[i]);if(cell&&cell.type!==types.header_cell)return!1}return!0}function toggleHeader(type,options){return options=options||{useDeprecatedLogic:!1},options.useDeprecatedLogic?deprecated_toggleHeader(type):function(state,dispatch){if(!isInTable(state))return!1;if(dispatch){const types=tableNodeTypes(state.schema),rect=selectedRect(state),tr=state.tr,isHeaderRowEnabled=isHeaderEnabledByType("row",rect,types),isHeaderColumnEnabled=isHeaderEnabledByType("column",rect,types),isHeaderEnabled="column"===type?isHeaderRowEnabled:"row"===type&&isHeaderColumnEnabled,selectionStartsAt=isHeaderEnabled?1:0,cellsRect="column"==type?{left:0,top:selectionStartsAt,right:1,bottom:rect.map.height}:"row"==type?{left:selectionStartsAt,top:0,right:rect.map.width,bottom:1}:rect,newType="column"==type?isHeaderColumnEnabled?types.cell:types.header_cell:"row"==type?isHeaderRowEnabled?types.cell:types.header_cell:types.cell;rect.map.cellsInRect(cellsRect).forEach((relativeCellPos=>{const cellPos=relativeCellPos+rect.tableStart,cell=tr.doc.nodeAt(cellPos);cell&&tr.setNodeMarkup(cellPos,newType,cell.attrs)})),dispatch(tr)}return!0}}toggleHeader("row",{useDeprecatedLogic:!0}),toggleHeader("column",{useDeprecatedLogic:!0});var toggleHeaderCell=toggleHeader("cell",{useDeprecatedLogic:!0});function findNextCell($cell,dir){if(dir<0){const before=$cell.nodeBefore;if(before)return $cell.pos-before.nodeSize;for(let row=$cell.index(-1)-1,rowEnd=$cell.before();row>=0;row--){const rowNode=$cell.node(-1).child(row),lastChild=rowNode.lastChild;if(lastChild)return rowEnd-1-lastChild.nodeSize;rowEnd-=rowNode.nodeSize}}else{if($cell.index()<$cell.parent.childCount-1)return $cell.pos+$cell.nodeAfter.nodeSize;const table=$cell.node(-1);for(let row=$cell.indexAfter(-1),rowStart=$cell.after();row<table.childCount;row++){const rowNode=table.child(row);if(rowNode.childCount)return rowStart+1;rowStart+=rowNode.nodeSize}}return null}function goToNextCell(direction){return function(state,dispatch){if(!isInTable(state))return!1;const cell=findNextCell(selectionCell(state),direction);if(null==cell)return!1;if(dispatch){const $cell=state.doc.resolve(cell);dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .TextSelection */.Bs.between($cell,moveCellForward($cell))).scrollIntoView())}return!0}}function deleteTable(state,dispatch){const $pos=state.selection.$anchor;for(let d=$pos.depth;d>0;d--){const node=$pos.node(d);if("table"==node.type.spec.tableRole)return dispatch&&dispatch(state.tr.delete($pos.before(d),$pos.after(d)).scrollIntoView()),!0}return!1}
// src/index.ts
function tableEditing({allowTableNodeSelection:allowTableNodeSelection=!1}={}){return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__/* .Plugin */.Sy({key:tableEditingKey,
// This piece of state is used to remember when a mouse-drag
// cell-selection is happening, so that it can continue even as
// transactions (which might move its anchor cell) come in.
state:{init(){return null},apply(tr,cur){const set=tr.getMeta(tableEditingKey);if(null!=set)return-1==set?null:set;if(null==cur||!tr.docChanged)return cur;const{deleted:deleted,pos:pos}=tr.mapping.mapResult(cur);return deleted?null:pos}},props:{decorations:drawCellSelection,handleDOMEvents:{mousedown:handleMouseDown},createSelectionBetween(view){return null!=tableEditingKey.getState(view.state)?view.state.selection:null},handleTripleClick:handleTripleClick,handleKeyDown:handleKeyDown,handlePaste:handlePaste},appendTransaction(_,oldState,state){return normalizeSelection(state,fixTables(state,oldState),allowTableNodeSelection)}})}
/***/},
/***/616560:
/***/function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";
/* harmony export */__webpack_require__.d(__webpack_exports__,{
/* harmony export */Ax:function(){/* binding */return canSplit},
/* harmony export */FC:function(){/* binding */return ReplaceAroundStep},
/* harmony export */GJ:function(){/* binding */return joinPoint},
/* harmony export */Mn:function(){/* binding */return canJoin},
/* harmony export */Pu:function(){/* binding */return ReplaceStep},
/* harmony export */dR:function(){/* binding */return replaceStep},
/* harmony export */k9:function(){/* binding */return liftTarget},
/* harmony export */nd:function(){/* binding */return findWrapping},
/* harmony export */nj:function(){/* binding */return dropPoint},
/* harmony export */vs:function(){/* binding */return Mapping},
/* harmony export */wx:function(){/* binding */return Transform}
/* harmony export */});
/* unused harmony exports AddMarkStep, AddNodeMarkStep, AttrStep, DocAttrStep, MapResult, RemoveMarkStep, RemoveNodeMarkStep, Step, StepMap, StepResult, TransformError, insertPoint */
/* harmony import */var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(759084);
// Recovery values encode a range index and an offset. They are
// represented as numbers, because tons of them will be created when
// mapping, for example, a large number of decorations. The number's
// lower 16 bits provide the index, the remaining bits the offset.

// Note: We intentionally don't use bit shift operators to en- and
// decode these, since those clip to 32 bits, which we might in rare
// cases want to overflow. A 64-bit float can represent 48-bit
// integers precisely.
const lower16=65535,factor16=Math.pow(2,16);function makeRecover(index,offset){return index+offset*factor16}function recoverIndex(value){return value&lower16}function recoverOffset(value){return(value-(value&lower16))/factor16}const DEL_BEFORE=1,DEL_AFTER=2,DEL_ACROSS=4,DEL_SIDE=8;
/**
An object representing a mapped position with extra
information.
*/class MapResult{
/**
    @internal
    */
constructor(
/**
    The mapped version of the position.
    */
pos,
/**
    @internal
    */
delInfo,
/**
    @internal
    */
recover){this.pos=pos,this.delInfo=delInfo,this.recover=recover}
/**
    Tells you whether the position was deleted, that is, whether the
    step removed the token on the side queried (via the `assoc`)
    argument from the document.
    */get deleted(){return(this.delInfo&DEL_SIDE)>0}
/**
    Tells you whether the token before the mapped position was deleted.
    */get deletedBefore(){return(this.delInfo&(DEL_BEFORE|DEL_ACROSS))>0}
/**
    True when the token after the mapped position was deleted.
    */get deletedAfter(){return(this.delInfo&(DEL_AFTER|DEL_ACROSS))>0}
/**
    Tells whether any of the steps mapped through deletes across the
    position (including both the token before and after the
    position).
    */get deletedAcross(){return(this.delInfo&DEL_ACROSS)>0}}
/**
A map describing the deletions and insertions made by a step, which
can be used to find the correspondence between positions in the
pre-step version of a document and the same position in the
post-step version.
*/class StepMap{
/**
    Create a position map. The modifications to the document are
    represented as an array of numbers, in which each group of three
    represents a modified chunk as `[start, oldSize, newSize]`.
    */
constructor(
/**
    @internal
    */
ranges,
/**
    @internal
    */
inverted=!1){if(this.ranges=ranges,this.inverted=inverted,!ranges.length&&StepMap.empty)return StepMap.empty}
/**
    @internal
    */recover(value){let diff=0,index=recoverIndex(value);if(!this.inverted)for(let i=0;i<index;i++)diff+=this.ranges[3*i+2]-this.ranges[3*i+1];return this.ranges[3*index]+diff+recoverOffset(value)}mapResult(pos,assoc=1){return this._map(pos,assoc,!1)}map(pos,assoc=1){return this._map(pos,assoc,!0)}
/**
    @internal
    */_map(pos,assoc,simple){let diff=0,oldIndex=this.inverted?2:1,newIndex=this.inverted?1:2;for(let i=0;i<this.ranges.length;i+=3){let start=this.ranges[i]-(this.inverted?diff:0);if(start>pos)break;let oldSize=this.ranges[i+oldIndex],newSize=this.ranges[i+newIndex],end=start+oldSize;if(pos<=end){let side=oldSize?pos==start?-1:pos==end?1:assoc:assoc,result=start+diff+(side<0?0:newSize);if(simple)return result;let recover=pos==(assoc<0?start:end)?null:makeRecover(i/3,pos-start),del=pos==start?DEL_AFTER:pos==end?DEL_BEFORE:DEL_ACROSS;return(assoc<0?pos!=start:pos!=end)&&(del|=DEL_SIDE),new MapResult(result,del,recover)}diff+=newSize-oldSize}return simple?pos+diff:new MapResult(pos+diff,0,null)}
/**
    @internal
    */touches(pos,recover){let diff=0,index=recoverIndex(recover),oldIndex=this.inverted?2:1,newIndex=this.inverted?1:2;for(let i=0;i<this.ranges.length;i+=3){let start=this.ranges[i]-(this.inverted?diff:0);if(start>pos)break;let oldSize=this.ranges[i+oldIndex],end=start+oldSize;if(pos<=end&&i==3*index)return!0;diff+=this.ranges[i+newIndex]-oldSize}return!1}
/**
    Calls the given function on each of the changed ranges included in
    this map.
    */forEach(f){let oldIndex=this.inverted?2:1,newIndex=this.inverted?1:2;for(let i=0,diff=0;i<this.ranges.length;i+=3){let start=this.ranges[i],oldStart=start-(this.inverted?diff:0),newStart=start+(this.inverted?0:diff),oldSize=this.ranges[i+oldIndex],newSize=this.ranges[i+newIndex];f(oldStart,oldStart+oldSize,newStart,newStart+newSize),diff+=newSize-oldSize}}
/**
    Create an inverted version of this map. The result can be used to
    map positions in the post-step document to the pre-step document.
    */invert(){return new StepMap(this.ranges,!this.inverted)}
/**
    @internal
    */toString(){return(this.inverted?"-":"")+JSON.stringify(this.ranges)}
/**
    Create a map that moves all positions by offset `n` (which may be
    negative). This can be useful when applying steps meant for a
    sub-document to a larger document, or vice-versa.
    */static offset(n){return 0==n?StepMap.empty:new StepMap(n<0?[0,-n,0]:[0,0,n])}}
/**
A StepMap that contains no changed ranges.
*/StepMap.empty=new StepMap([]);
/**
A mapping represents a pipeline of zero or more [step
maps](https://prosemirror.net/docs/ref/#transform.StepMap). It has special provisions for losslessly
handling mapping positions through a series of steps in which some
steps are inverted versions of earlier steps. (This comes up when
‘[rebasing](/docs/guide/#transform.rebasing)’ steps for
collaboration or history management.)
*/
class Mapping{
/**
    Create a new mapping with the given position maps.
    */
constructor(
/**
    The step maps in this mapping.
    */
maps=[]
/**
    @internal
    */,mirror,
/**
    The starting position in the `maps` array, used when `map` or
    `mapResult` is called.
    */
from=0
/**
    The end position in the `maps` array.
    */,to=maps.length){this.maps=maps,this.mirror=mirror,this.from=from,this.to=to}
/**
    Create a mapping that maps only through a part of this one.
    */slice(from=0,to=this.maps.length){return new Mapping(this.maps,this.mirror,from,to)}
/**
    @internal
    */copy(){return new Mapping(this.maps.slice(),this.mirror&&this.mirror.slice(),this.from,this.to)}
/**
    Add a step map to the end of this mapping. If `mirrors` is
    given, it should be the index of the step map that is the mirror
    image of this one.
    */appendMap(map,mirrors){this.to=this.maps.push(map),null!=mirrors&&this.setMirror(this.maps.length-1,mirrors)}
/**
    Add all the step maps in a given mapping to this one (preserving
    mirroring information).
    */appendMapping(mapping){for(let i=0,startSize=this.maps.length;i<mapping.maps.length;i++){let mirr=mapping.getMirror(i);this.appendMap(mapping.maps[i],null!=mirr&&mirr<i?startSize+mirr:void 0)}}
/**
    Finds the offset of the step map that mirrors the map at the
    given offset, in this mapping (as per the second argument to
    `appendMap`).
    */getMirror(n){if(this.mirror)for(let i=0;i<this.mirror.length;i++)if(this.mirror[i]==n)return this.mirror[i+(i%2?-1:1)]}
/**
    @internal
    */setMirror(n,m){this.mirror||(this.mirror=[]),this.mirror.push(n,m)}
/**
    Append the inverse of the given mapping to this one.
    */appendMappingInverted(mapping){for(let i=mapping.maps.length-1,totalSize=this.maps.length+mapping.maps.length;i>=0;i--){let mirr=mapping.getMirror(i);this.appendMap(mapping.maps[i].invert(),null!=mirr&&mirr>i?totalSize-mirr-1:void 0)}}
/**
    Create an inverted version of this mapping.
    */invert(){let inverse=new Mapping;return inverse.appendMappingInverted(this),inverse}
/**
    Map a position through this mapping.
    */map(pos,assoc=1){if(this.mirror)return this._map(pos,assoc,!0);for(let i=this.from;i<this.to;i++)pos=this.maps[i].map(pos,assoc);return pos}
/**
    Map a position through this mapping, returning a mapping
    result.
    */mapResult(pos,assoc=1){return this._map(pos,assoc,!1)}
/**
    @internal
    */_map(pos,assoc,simple){let delInfo=0;for(let i=this.from;i<this.to;i++){let map=this.maps[i],result=map.mapResult(pos,assoc);if(null!=result.recover){let corr=this.getMirror(i);if(null!=corr&&corr>i&&corr<this.to){i=corr,pos=this.maps[corr].recover(result.recover);continue}}delInfo|=result.delInfo,pos=result.pos}return simple?pos:new MapResult(pos,delInfo,null)}}const stepsByID=Object.create(null);
/**
A step object represents an atomic change. It generally applies
only to the document it was created for, since the positions
stored in it will only make sense for that document.

New steps are defined by creating classes that extend `Step`,
overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`
methods, and registering your class with a unique
JSON-serialization identifier using
[`Step.jsonID`](https://prosemirror.net/docs/ref/#transform.Step^jsonID).
*/class Step{
/**
    Get the step map that represents the changes made by this step,
    and which can be used to transform between positions in the old
    and the new document.
    */
getMap(){return StepMap.empty}
/**
    Try to merge this step with another one, to be applied directly
    after it. Returns the merged step when possible, null if the
    steps can't be merged.
    */merge(other){return null}
/**
    Deserialize a step from its JSON representation. Will call
    through to the step class' own implementation of this method.
    */static fromJSON(schema,json){if(!json||!json.stepType)throw new RangeError("Invalid input for Step.fromJSON");let type=stepsByID[json.stepType];if(!type)throw new RangeError(`No step type ${json.stepType} defined`);return type.fromJSON(schema,json)}
/**
    To be able to serialize steps to JSON, each step needs a string
    ID to attach to its JSON representation. Use this method to
    register an ID for your step classes. Try to pick something
    that's unlikely to clash with steps from other modules.
    */static jsonID(id,stepClass){if(id in stepsByID)throw new RangeError("Duplicate use of step JSON ID "+id);return stepsByID[id]=stepClass,stepClass.prototype.jsonID=id,stepClass}}
/**
The result of [applying](https://prosemirror.net/docs/ref/#transform.Step.apply) a step. Contains either a
new document or a failure value.
*/class StepResult{
/**
    @internal
    */
constructor(
/**
    The transformed document, if successful.
    */
doc,
/**
    The failure message, if unsuccessful.
    */
failed){this.doc=doc,this.failed=failed}
/**
    Create a successful step result.
    */static ok(doc){return new StepResult(doc,null)}
/**
    Create a failed step result.
    */static fail(message){return new StepResult(null,message)}
/**
    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
    arguments. Create a successful result if it succeeds, and a
    failed one if it throws a `ReplaceError`.
    */static fromReplace(doc,from,to,slice){try{return StepResult.ok(doc.replace(from,to,slice))}catch(e){if(e instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .ReplaceError */.e4)return StepResult.fail(e.message);throw e}}}function mapFragment(fragment,f,parent){let mapped=[];for(let i=0;i<fragment.childCount;i++){let child=fragment.child(i);child.content.size&&(child=child.copy(mapFragment(child.content,f,child))),child.isInline&&(child=f(child,parent,i)),mapped.push(child)}return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.fromArray(mapped)}
/**
Add a mark to all inline content between two positions.
*/class AddMarkStep extends Step{
/**
    Create a mark step.
    */
constructor(
/**
    The start of the marked range.
    */
from,
/**
    The end of the marked range.
    */
to,
/**
    The mark to add.
    */
mark){super(),this.from=from,this.to=to,this.mark=mark}apply(doc){let oldSlice=doc.slice(this.from,this.to),$from=doc.resolve(this.from),parent=$from.node($from.sharedDepth(this.to)),slice=new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(mapFragment(oldSlice.content,((node,parent)=>node.isAtom&&parent.type.allowsMarkType(this.mark.type)?node.mark(this.mark.addToSet(node.marks)):node),parent),oldSlice.openStart,oldSlice.openEnd);return StepResult.fromReplace(doc,this.from,this.to,slice)}invert(){return new RemoveMarkStep(this.from,this.to,this.mark)}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1);return from.deleted&&to.deleted||from.pos>=to.pos?null:new AddMarkStep(from.pos,to.pos,this.mark)}merge(other){return other instanceof AddMarkStep&&other.mark.eq(this.mark)&&this.from<=other.to&&this.to>=other.from?new AddMarkStep(Math.min(this.from,other.from),Math.max(this.to,other.to),this.mark):null}toJSON(){return{stepType:"addMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to)throw new RangeError("Invalid input for AddMarkStep.fromJSON");return new AddMarkStep(json.from,json.to,schema.markFromJSON(json.mark))}}Step.jsonID("addMark",AddMarkStep);
/**
Remove a mark from all inline content between two positions.
*/
class RemoveMarkStep extends Step{
/**
    Create a mark-removing step.
    */
constructor(
/**
    The start of the unmarked range.
    */
from,
/**
    The end of the unmarked range.
    */
to,
/**
    The mark to remove.
    */
mark){super(),this.from=from,this.to=to,this.mark=mark}apply(doc){let oldSlice=doc.slice(this.from,this.to),slice=new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(mapFragment(oldSlice.content,(node=>node.mark(this.mark.removeFromSet(node.marks))),doc),oldSlice.openStart,oldSlice.openEnd);return StepResult.fromReplace(doc,this.from,this.to,slice)}invert(){return new AddMarkStep(this.from,this.to,this.mark)}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1);return from.deleted&&to.deleted||from.pos>=to.pos?null:new RemoveMarkStep(from.pos,to.pos,this.mark)}merge(other){return other instanceof RemoveMarkStep&&other.mark.eq(this.mark)&&this.from<=other.to&&this.to>=other.from?new RemoveMarkStep(Math.min(this.from,other.from),Math.max(this.to,other.to),this.mark):null}toJSON(){return{stepType:"removeMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to)throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");return new RemoveMarkStep(json.from,json.to,schema.markFromJSON(json.mark))}}Step.jsonID("removeMark",RemoveMarkStep);
/**
Add a mark to a specific node.
*/
class AddNodeMarkStep extends Step{
/**
    Create a node mark step.
    */
constructor(
/**
    The position of the target node.
    */
pos,
/**
    The mark to add.
    */
mark){super(),this.pos=pos,this.mark=mark}apply(doc){let node=doc.nodeAt(this.pos);if(!node)return StepResult.fail("No node at mark step's position");let updated=node.type.create(node.attrs,null,this.mark.addToSet(node.marks));return StepResult.fromReplace(doc,this.pos,this.pos+1,new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(updated),0,node.isLeaf?0:1))}invert(doc){let node=doc.nodeAt(this.pos);if(node){let newSet=this.mark.addToSet(node.marks);if(newSet.length==node.marks.length){for(let i=0;i<node.marks.length;i++)if(!node.marks[i].isInSet(newSet))return new AddNodeMarkStep(this.pos,node.marks[i]);return new AddNodeMarkStep(this.pos,this.mark)}}return new RemoveNodeMarkStep(this.pos,this.mark)}map(mapping){let pos=mapping.mapResult(this.pos,1);return pos.deletedAfter?null:new AddNodeMarkStep(pos.pos,this.mark)}toJSON(){return{stepType:"addNodeMark",pos:this.pos,mark:this.mark.toJSON()}}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.pos)throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");return new AddNodeMarkStep(json.pos,schema.markFromJSON(json.mark))}}Step.jsonID("addNodeMark",AddNodeMarkStep);
/**
Remove a mark from a specific node.
*/
class RemoveNodeMarkStep extends Step{
/**
    Create a mark-removing step.
    */
constructor(
/**
    The position of the target node.
    */
pos,
/**
    The mark to remove.
    */
mark){super(),this.pos=pos,this.mark=mark}apply(doc){let node=doc.nodeAt(this.pos);if(!node)return StepResult.fail("No node at mark step's position");let updated=node.type.create(node.attrs,null,this.mark.removeFromSet(node.marks));return StepResult.fromReplace(doc,this.pos,this.pos+1,new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(updated),0,node.isLeaf?0:1))}invert(doc){let node=doc.nodeAt(this.pos);return node&&this.mark.isInSet(node.marks)?new AddNodeMarkStep(this.pos,this.mark):this}map(mapping){let pos=mapping.mapResult(this.pos,1);return pos.deletedAfter?null:new RemoveNodeMarkStep(pos.pos,this.mark)}toJSON(){return{stepType:"removeNodeMark",pos:this.pos,mark:this.mark.toJSON()}}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.pos)throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");return new RemoveNodeMarkStep(json.pos,schema.markFromJSON(json.mark))}}Step.jsonID("removeNodeMark",RemoveNodeMarkStep);
/**
Replace a part of the document with a slice of new content.
*/
class ReplaceStep extends Step{
/**
    The given `slice` should fit the 'gap' between `from` and
    `to`—the depths must line up, and the surrounding nodes must be
    able to be joined with the open sides of the slice. When
    `structure` is true, the step will fail if the content between
    from and to is not just a sequence of closing and then opening
    tokens (this is to guard against rebased replace steps
    overwriting something they weren't supposed to).
    */
constructor(
/**
    The start position of the replaced range.
    */
from,
/**
    The end position of the replaced range.
    */
to,
/**
    The slice to insert.
    */
slice,
/**
    @internal
    */
structure=!1){super(),this.from=from,this.to=to,this.slice=slice,this.structure=structure}apply(doc){return this.structure&&contentBetween(doc,this.from,this.to)?StepResult.fail("Structure replace would overwrite content"):StepResult.fromReplace(doc,this.from,this.to,this.slice)}getMap(){return new StepMap([this.from,this.to-this.from,this.slice.size])}invert(doc){return new ReplaceStep(this.from,this.from+this.slice.size,doc.slice(this.from,this.to))}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1);return from.deletedAcross&&to.deletedAcross?null:new ReplaceStep(from.pos,Math.max(from.pos,to.pos),this.slice)}merge(other){if(!(other instanceof ReplaceStep)||other.structure||this.structure)return null;if(this.from+this.slice.size!=other.from||this.slice.openEnd||other.slice.openStart){if(other.to!=this.from||this.slice.openStart||other.slice.openEnd)return null;{let slice=this.slice.size+other.slice.size==0?prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.empty:new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(other.slice.content.append(this.slice.content),other.slice.openStart,this.slice.openEnd);return new ReplaceStep(other.from,this.to,slice,this.structure)}}{let slice=this.slice.size+other.slice.size==0?prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.empty:new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(this.slice.content.append(other.slice.content),this.slice.openStart,other.slice.openEnd);return new ReplaceStep(this.from,this.to+(other.to-other.from),slice,this.structure)}}toJSON(){let json={stepType:"replace",from:this.from,to:this.to};return this.slice.size&&(json.slice=this.slice.toJSON()),this.structure&&(json.structure=!0),json}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to)throw new RangeError("Invalid input for ReplaceStep.fromJSON");return new ReplaceStep(json.from,json.to,prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.fromJSON(schema,json.slice),!!json.structure)}}Step.jsonID("replace",ReplaceStep);
/**
Replace a part of the document with a slice of content, but
preserve a range of the replaced content by moving it into the
slice.
*/
class ReplaceAroundStep extends Step{
/**
    Create a replace-around step with the given range and gap.
    `insert` should be the point in the slice into which the content
    of the gap should be moved. `structure` has the same meaning as
    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
    */
constructor(
/**
    The start position of the replaced range.
    */
from,
/**
    The end position of the replaced range.
    */
to,
/**
    The start of preserved range.
    */
gapFrom,
/**
    The end of preserved range.
    */
gapTo,
/**
    The slice to insert.
    */
slice,
/**
    The position in the slice where the preserved range should be
    inserted.
    */
insert,
/**
    @internal
    */
structure=!1){super(),this.from=from,this.to=to,this.gapFrom=gapFrom,this.gapTo=gapTo,this.slice=slice,this.insert=insert,this.structure=structure}apply(doc){if(this.structure&&(contentBetween(doc,this.from,this.gapFrom)||contentBetween(doc,this.gapTo,this.to)))return StepResult.fail("Structure gap-replace would overwrite content");let gap=doc.slice(this.gapFrom,this.gapTo);if(gap.openStart||gap.openEnd)return StepResult.fail("Gap is not a flat range");let inserted=this.slice.insertAt(this.insert,gap.content);return inserted?StepResult.fromReplace(doc,this.from,this.to,inserted):StepResult.fail("Content does not fit in gap")}getMap(){return new StepMap([this.from,this.gapFrom-this.from,this.insert,this.gapTo,this.to-this.gapTo,this.slice.size-this.insert])}invert(doc){let gap=this.gapTo-this.gapFrom;return new ReplaceAroundStep(this.from,this.from+this.slice.size+gap,this.from+this.insert,this.from+this.insert+gap,doc.slice(this.from,this.to).removeBetween(this.gapFrom-this.from,this.gapTo-this.from),this.gapFrom-this.from,this.structure)}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1),gapFrom=mapping.map(this.gapFrom,-1),gapTo=mapping.map(this.gapTo,1);return from.deletedAcross&&to.deletedAcross||gapFrom<from.pos||gapTo>to.pos?null:new ReplaceAroundStep(from.pos,to.pos,gapFrom,gapTo,this.slice,this.insert,this.structure)}toJSON(){let json={stepType:"replaceAround",from:this.from,to:this.to,gapFrom:this.gapFrom,gapTo:this.gapTo,insert:this.insert};return this.slice.size&&(json.slice=this.slice.toJSON()),this.structure&&(json.structure=!0),json}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to||"number"!=typeof json.gapFrom||"number"!=typeof json.gapTo||"number"!=typeof json.insert)throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");return new ReplaceAroundStep(json.from,json.to,json.gapFrom,json.gapTo,prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.fromJSON(schema,json.slice),json.insert,!!json.structure)}}function contentBetween(doc,from,to){let $from=doc.resolve(from),dist=to-from,depth=$from.depth;while(dist>0&&depth>0&&$from.indexAfter(depth)==$from.node(depth).childCount)depth--,dist--;if(dist>0){let next=$from.node(depth).maybeChild($from.indexAfter(depth));while(dist>0){if(!next||next.isLeaf)return!0;next=next.firstChild,dist--}}return!1}function addMark(tr,from,to,mark){let removing,adding,removed=[],added=[];tr.doc.nodesBetween(from,to,((node,pos,parent)=>{if(!node.isInline)return;let marks=node.marks;if(!mark.isInSet(marks)&&parent.type.allowsMarkType(mark.type)){let start=Math.max(pos,from),end=Math.min(pos+node.nodeSize,to),newSet=mark.addToSet(marks);for(let i=0;i<marks.length;i++)marks[i].isInSet(newSet)||(removing&&removing.to==start&&removing.mark.eq(marks[i])?removing.to=end:removed.push(removing=new RemoveMarkStep(start,end,marks[i])));adding&&adding.to==start?adding.to=end:added.push(adding=new AddMarkStep(start,end,mark))}})),removed.forEach((s=>tr.step(s))),added.forEach((s=>tr.step(s)))}function removeMark(tr,from,to,mark){let matched=[],step=0;tr.doc.nodesBetween(from,to,((node,pos)=>{if(!node.isInline)return;step++;let toRemove=null;if(mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .MarkType */.ZU){let found,set=node.marks;while(found=mark.isInSet(set))(toRemove||(toRemove=[])).push(found),set=found.removeFromSet(set)}else mark?mark.isInSet(node.marks)&&(toRemove=[mark]):toRemove=node.marks;if(toRemove&&toRemove.length){let end=Math.min(pos+node.nodeSize,to);for(let i=0;i<toRemove.length;i++){let found,style=toRemove[i];for(let j=0;j<matched.length;j++){let m=matched[j];m.step==step-1&&style.eq(matched[j].style)&&(found=m)}found?(found.to=end,found.step=step):matched.push({style:style,from:Math.max(pos,from),to:end,step:step})}}})),matched.forEach((m=>tr.step(new RemoveMarkStep(m.from,m.to,m.style))))}function clearIncompatible(tr,pos,parentType,match=parentType.contentMatch){let node=tr.doc.nodeAt(pos),replSteps=[],cur=pos+1;for(let i=0;i<node.childCount;i++){let child=node.child(i),end=cur+child.nodeSize,allowed=match.matchType(child.type);if(allowed){match=allowed;for(let j=0;j<child.marks.length;j++)parentType.allowsMarkType(child.marks[j].type)||tr.step(new RemoveMarkStep(cur,end,child.marks[j]));if(child.isText&&!parentType.spec.code){let m,slice,newline=/\r?\n|\r/g;while(m=newline.exec(child.text))slice||(slice=new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(parentType.schema.text(" ",parentType.allowedMarks(child.marks))),0,0)),replSteps.push(new ReplaceStep(cur+m.index,cur+m.index+m[0].length,slice))}}else replSteps.push(new ReplaceStep(cur,end,prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.empty));cur=end}if(!match.validEnd){let fill=match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty,!0);tr.replace(cur,cur,new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(fill,0,0))}for(let i=replSteps.length-1;i>=0;i--)tr.step(replSteps[i])}function canCut(node,start,end){return(0==start||node.canReplace(start,node.childCount))&&(end==node.childCount||node.canReplace(0,end))}
/**
Try to find a target depth to which the content in the given range
can be lifted. Will not go across
[isolating](https://prosemirror.net/docs/ref/#model.NodeSpec.isolating) parent nodes.
*/function liftTarget(range){let parent=range.parent,content=parent.content.cutByIndex(range.startIndex,range.endIndex);for(let depth=range.depth;;--depth){let node=range.$from.node(depth),index=range.$from.index(depth),endIndex=range.$to.indexAfter(depth);if(depth<range.depth&&node.canReplace(index,endIndex,content))return depth;if(0==depth||node.type.spec.isolating||!canCut(node,index,endIndex))break}return null}function lift(tr,range,target){let{$from:$from,$to:$to,depth:depth}=range,gapStart=$from.before(depth+1),gapEnd=$to.after(depth+1),start=gapStart,end=gapEnd,before=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty,openStart=0;for(let d=depth,splitting=!1;d>target;d--)splitting||$from.index(d)>0?(splitting=!0,before=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from($from.node(d).copy(before)),openStart++):start--;let after=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty,openEnd=0;for(let d=depth,splitting=!1;d>target;d--)splitting||$to.after(d+1)<$to.end(d)?(splitting=!0,after=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from($to.node(d).copy(after)),openEnd++):end++;tr.step(new ReplaceAroundStep(start,end,gapStart,gapEnd,new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(before.append(after),openStart,openEnd),before.size-openStart,!0))}
/**
Try to find a valid way to wrap the content in the given range in a
node of the given type. May introduce extra nodes around and inside
the wrapper node, if necessary. Returns null if no valid wrapping
could be found. When `innerRange` is given, that range's content is
used as the content to fit into the wrapping, instead of the
content of `range`.
*/function findWrapping(range,nodeType,attrs=null,innerRange=range){let around=findWrappingOutside(range,nodeType),inner=around&&findWrappingInside(innerRange,nodeType);return inner?around.map(withAttrs).concat({type:nodeType,attrs:attrs}).concat(inner.map(withAttrs)):null}function withAttrs(type){return{type:type,attrs:null}}function findWrappingOutside(range,type){let{parent:parent,startIndex:startIndex,endIndex:endIndex}=range,around=parent.contentMatchAt(startIndex).findWrapping(type);if(!around)return null;let outer=around.length?around[0]:type;return parent.canReplaceWith(startIndex,endIndex,outer)?around:null}function findWrappingInside(range,type){let{parent:parent,startIndex:startIndex,endIndex:endIndex}=range,inner=parent.child(startIndex),inside=type.contentMatch.findWrapping(inner.type);if(!inside)return null;let lastType=inside.length?inside[inside.length-1]:type,innerMatch=lastType.contentMatch;for(let i=startIndex;innerMatch&&i<endIndex;i++)innerMatch=innerMatch.matchType(parent.child(i).type);return innerMatch&&innerMatch.validEnd?inside:null}function wrap(tr,range,wrappers){let content=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty;for(let i=wrappers.length-1;i>=0;i--){if(content.size){let match=wrappers[i].type.contentMatch.matchFragment(content);if(!match||!match.validEnd)throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper")}content=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(wrappers[i].type.create(wrappers[i].attrs,content))}let start=range.start,end=range.end;tr.step(new ReplaceAroundStep(start,end,start,end,new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(content,0,0),wrappers.length,!0))}function setBlockType(tr,from,to,type,attrs){if(!type.isTextblock)throw new RangeError("Type given to setBlockType should be a textblock");let mapFrom=tr.steps.length;tr.doc.nodesBetween(from,to,((node,pos)=>{if(node.isTextblock&&!node.hasMarkup(type,attrs)&&canChangeType(tr.doc,tr.mapping.slice(mapFrom).map(pos),type)){
// Ensure all markup that isn't allowed in the new node type is cleared
tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos,1),type);let mapping=tr.mapping.slice(mapFrom),startM=mapping.map(pos,1),endM=mapping.map(pos+node.nodeSize,1);return tr.step(new ReplaceAroundStep(startM,endM,startM+1,endM-1,new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(type.create(attrs,null,node.marks)),0,0),1,!0)),!1}}))}function canChangeType(doc,pos,type){let $pos=doc.resolve(pos),index=$pos.index();return $pos.parent.canReplaceWith(index,index+1,type)}
/**
Change the type, attributes, and/or marks of the node at `pos`.
When `type` isn't given, the existing node type is preserved,
*/function setNodeMarkup(tr,pos,type,attrs,marks){let node=tr.doc.nodeAt(pos);if(!node)throw new RangeError("No node at given position");type||(type=node.type);let newNode=type.create(attrs,null,marks||node.marks);if(node.isLeaf)return tr.replaceWith(pos,pos+node.nodeSize,newNode);if(!type.validContent(node.content))throw new RangeError("Invalid content for node type "+type.name);tr.step(new ReplaceAroundStep(pos,pos+node.nodeSize,pos+1,pos+node.nodeSize-1,new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(newNode),0,0),1,!0))}
/**
Check whether splitting at the given position is allowed.
*/function canSplit(doc,pos,depth=1,typesAfter){let $pos=doc.resolve(pos),base=$pos.depth-depth,innerType=typesAfter&&typesAfter[typesAfter.length-1]||$pos.parent;if(base<0||$pos.parent.type.spec.isolating||!$pos.parent.canReplace($pos.index(),$pos.parent.childCount)||!innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(),$pos.parent.childCount)))return!1;for(let d=$pos.depth-1,i=depth-2;d>base;d--,i--){let node=$pos.node(d),index=$pos.index(d);if(node.type.spec.isolating)return!1;let rest=node.content.cutByIndex(index,node.childCount),overrideChild=typesAfter&&typesAfter[i+1];overrideChild&&(rest=rest.replaceChild(0,overrideChild.type.create(overrideChild.attrs)));let after=typesAfter&&typesAfter[i]||node;if(!node.canReplace(index+1,node.childCount)||!after.type.validContent(rest))return!1}let index=$pos.indexAfter(base),baseType=typesAfter&&typesAfter[0];return $pos.node(base).canReplaceWith(index,index,baseType?baseType.type:$pos.node(base+1).type)}function split(tr,pos,depth=1,typesAfter){let $pos=tr.doc.resolve(pos),before=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty,after=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty;for(let d=$pos.depth,e=$pos.depth-depth,i=depth-1;d>e;d--,i--){before=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from($pos.node(d).copy(before));let typeAfter=typesAfter&&typesAfter[i];after=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(typeAfter?typeAfter.type.create(typeAfter.attrs,after):$pos.node(d).copy(after))}tr.step(new ReplaceStep(pos,pos,new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(before.append(after),depth,depth),!0))}
/**
Test whether the blocks before and after a given position can be
joined.
*/function canJoin(doc,pos){let $pos=doc.resolve(pos),index=$pos.index();return joinable($pos.nodeBefore,$pos.nodeAfter)&&$pos.parent.canReplace(index,index+1)}function joinable(a,b){return!(!a||!b||a.isLeaf||!a.canAppend(b))}
/**
Find an ancestor of the given position that can be joined to the
block before (or after if `dir` is positive). Returns the joinable
point, if any.
*/function joinPoint(doc,pos,dir=-1){let $pos=doc.resolve(pos);for(let d=$pos.depth;;d--){let before,after,index=$pos.index(d);if(d==$pos.depth?(before=$pos.nodeBefore,after=$pos.nodeAfter):dir>0?(before=$pos.node(d+1),index++,after=$pos.node(d).maybeChild(index)):(before=$pos.node(d).maybeChild(index-1),after=$pos.node(d+1)),before&&!before.isTextblock&&joinable(before,after)&&$pos.node(d).canReplace(index,index+1))return pos;if(0==d)break;pos=dir<0?$pos.before(d):$pos.after(d)}}function join(tr,pos,depth){let step=new ReplaceStep(pos-depth,pos+depth,prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.empty,!0);tr.step(step)}
/**
Try to find a point where a node of the given type can be inserted
near `pos`, by searching up the node hierarchy when `pos` itself
isn't a valid place but is at the start or end of a node. Return
null if no position was found.
*/function insertPoint(doc,pos,nodeType){let $pos=doc.resolve(pos);if($pos.parent.canReplaceWith($pos.index(),$pos.index(),nodeType))return pos;if(0==$pos.parentOffset)for(let d=$pos.depth-1;d>=0;d--){let index=$pos.index(d);if($pos.node(d).canReplaceWith(index,index,nodeType))return $pos.before(d+1);if(index>0)return null}if($pos.parentOffset==$pos.parent.content.size)for(let d=$pos.depth-1;d>=0;d--){let index=$pos.indexAfter(d);if($pos.node(d).canReplaceWith(index,index,nodeType))return $pos.after(d+1);if(index<$pos.node(d).childCount)return null}return null}
/**
Finds a position at or around the given position where the given
slice can be inserted. Will look at parent nodes' nearest boundary
and try there, even if the original position wasn't directly at the
start or end of that node. Returns null when no position was found.
*/function dropPoint(doc,pos,slice){let $pos=doc.resolve(pos);if(!slice.content.size)return pos;let content=slice.content;for(let i=0;i<slice.openStart;i++)content=content.firstChild.content;for(let pass=1;pass<=(0==slice.openStart&&slice.size?2:1);pass++)for(let d=$pos.depth;d>=0;d--){let bias=d==$pos.depth?0:$pos.pos<=($pos.start(d+1)+$pos.end(d+1))/2?-1:1,insertPos=$pos.index(d)+(bias>0?1:0),parent=$pos.node(d),fits=!1;if(1==pass)fits=parent.canReplace(insertPos,insertPos,content);else{let wrapping=parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);fits=wrapping&&parent.canReplaceWith(insertPos,insertPos,wrapping[0])}if(fits)return 0==bias?$pos.pos:bias<0?$pos.before(d+1):$pos.after(d+1)}return null}
/**
‘Fit’ a slice into a given position in the document, producing a
[step](https://prosemirror.net/docs/ref/#transform.Step) that inserts it. Will return null if
there's no meaningful way to insert the slice here, or inserting it
would be a no-op (an empty slice over an empty range).
*/function replaceStep(doc,from,to=from,slice=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.empty){if(from==to&&!slice.size)return null;let $from=doc.resolve(from),$to=doc.resolve(to);
// Optimization -- avoid work if it's obvious that it's not needed.
return fitsTrivially($from,$to,slice)?new ReplaceStep(from,to,slice):new Fitter($from,$to,slice).fit()}function fitsTrivially($from,$to,slice){return!slice.openStart&&!slice.openEnd&&$from.start()==$to.start()&&$from.parent.canReplace($from.index(),$to.index(),slice.content)}
// Algorithm for 'placing' the elements of a slice into a gap:

// We consider the content of each node that is open to the left to be
// independently placeable. I.e. in <p("foo"), p("bar")>, when the
// paragraph on the left is open, "foo" can be placed (somewhere on
// the left side of the replacement gap) independently from p("bar").

// This class tracks the state of the placement progress in the
// following properties:

//  - `frontier` holds a stack of `{type, match}` objects that
//    represent the open side of the replacement. It starts at
//    `$from`, then moves forward as content is placed, and is finally
//    reconciled with `$to`.

//  - `unplaced` is a slice that represents the content that hasn't
//    been placed yet.

//  - `placed` is a fragment of placed content. Its open-start value
//    is implicit in `$from`, and its open-end value in `frontier`.
Step.jsonID("replaceAround",ReplaceAroundStep);class Fitter{constructor($from,$to,unplaced){this.$from=$from,this.$to=$to,this.unplaced=unplaced,this.frontier=[],this.placed=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty;for(let i=0;i<=$from.depth;i++){let node=$from.node(i);this.frontier.push({type:node.type,match:node.contentMatchAt($from.indexAfter(i))})}for(let i=$from.depth;i>0;i--)this.placed=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from($from.node(i).copy(this.placed))}get depth(){return this.frontier.length-1}fit(){
// As long as there's unplaced content, try to place some of it.
// If that fails, either increase the open score of the unplaced
// slice, or drop nodes from it, and then try again.
while(this.unplaced.size){let fit=this.findFittable();fit?this.placeNodes(fit):this.openMore()||this.dropNode()}
// When there's inline content directly after the frontier _and_
// directly after `this.$to`, we must generate a `ReplaceAround`
// step that pulls that content into the node after the frontier.
// That means the fitting must be done to the end of the textblock
// node after `this.$to`, not `this.$to` itself.
let moveInline=this.mustMoveInline(),placedSize=this.placed.size-this.depth-this.$from.depth,$from=this.$from,$to=this.close(moveInline<0?this.$to:$from.doc.resolve(moveInline));if(!$to)return null;
// If closing to `$to` succeeded, create a step
let content=this.placed,openStart=$from.depth,openEnd=$to.depth;while(openStart&&openEnd&&1==content.childCount)// Normalize by dropping open parent nodes
content=content.firstChild.content,openStart--,openEnd--;let slice=new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(content,openStart,openEnd);return moveInline>-1?new ReplaceAroundStep($from.pos,moveInline,this.$to.pos,this.$to.end(),slice,placedSize):slice.size||$from.pos!=this.$to.pos?new ReplaceStep($from.pos,$to.pos,slice):null}
// Find a position on the start spine of `this.unplaced` that has
// content that can be moved somewhere on the frontier. Returns two
// depths, one for the slice and one for the frontier.
findFittable(){let startDepth=this.unplaced.openStart;for(let cur=this.unplaced.content,d=0,openEnd=this.unplaced.openEnd;d<startDepth;d++){let node=cur.firstChild;if(cur.childCount>1&&(openEnd=0),node.type.spec.isolating&&openEnd<=d){startDepth=d;break}cur=node.content}
// Only try wrapping nodes (pass 2) after finding a place without
// wrapping failed.
for(let pass=1;pass<=2;pass++)for(let sliceDepth=1==pass?startDepth:this.unplaced.openStart;sliceDepth>=0;sliceDepth--){let fragment,parent=null;sliceDepth?(parent=contentAt(this.unplaced.content,sliceDepth-1).firstChild,fragment=parent.content):fragment=this.unplaced.content;let first=fragment.firstChild;for(let frontierDepth=this.depth;frontierDepth>=0;frontierDepth--){let wrap,{type:type,match:match}=this.frontier[frontierDepth],inject=null;
// In pass 1, if the next node matches, or there is no next
// node but the parents look compatible, we've found a
// place.
if(1==pass&&(first?match.matchType(first.type)||(inject=match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(first),!1)):parent&&type.compatibleContent(parent.type)))return{sliceDepth:sliceDepth,frontierDepth:frontierDepth,parent:parent,inject:inject};
// In pass 2, look for a set of wrapping nodes that make
// `first` fit here.
// Don't continue looking further up if the parent node
// would fit here.
if(2==pass&&first&&(wrap=match.findWrapping(first.type)))return{sliceDepth:sliceDepth,frontierDepth:frontierDepth,parent:parent,wrap:wrap};if(parent&&match.matchType(parent.type))break}}}openMore(){let{content:content,openStart:openStart,openEnd:openEnd}=this.unplaced,inner=contentAt(content,openStart);return!(!inner.childCount||inner.firstChild.isLeaf)&&(this.unplaced=new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(content,openStart+1,Math.max(openEnd,inner.size+openStart>=content.size-openEnd?openStart+1:0)),!0)}dropNode(){let{content:content,openStart:openStart,openEnd:openEnd}=this.unplaced,inner=contentAt(content,openStart);if(inner.childCount<=1&&openStart>0){let openAtEnd=content.size-openStart<=openStart+inner.size;this.unplaced=new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(dropFromFragment(content,openStart-1,1),openStart-1,openAtEnd?openStart-1:openEnd)}else this.unplaced=new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(dropFromFragment(content,openStart,1),openStart,openEnd)}
// Move content from the unplaced slice at `sliceDepth` to the
// frontier node at `frontierDepth`. Close that frontier node when
// applicable.
placeNodes({sliceDepth:sliceDepth,frontierDepth:frontierDepth,parent:parent,inject:inject,wrap:wrap}){while(this.depth>frontierDepth)this.closeFrontierNode();if(wrap)for(let i=0;i<wrap.length;i++)this.openFrontierNode(wrap[i]);let slice=this.unplaced,fragment=parent?parent.content:slice.content,openStart=slice.openStart-sliceDepth,taken=0,add=[],{match:match,type:type}=this.frontier[frontierDepth];if(inject){for(let i=0;i<inject.childCount;i++)add.push(inject.child(i));match=match.matchFragment(inject)}
// Computes the amount of (end) open nodes at the end of the
// fragment. When 0, the parent is open, but no more. When
// negative, nothing is open.
let openEndCount=fragment.size+sliceDepth-(slice.content.size-slice.openEnd);
// Scan over the fragment, fitting as many child nodes as
// possible.
while(taken<fragment.childCount){let next=fragment.child(taken),matches=match.matchType(next.type);if(!matches)break;taken++,(taken>1||0==openStart||next.content.size)&&(// Drop empty open nodes
match=matches,add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)),1==taken?openStart:0,taken==fragment.childCount?openEndCount:-1)))}let toEnd=taken==fragment.childCount;toEnd||(openEndCount=-1),this.placed=addToFragment(this.placed,frontierDepth,prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(add)),this.frontier[frontierDepth].match=match,
// If the parent types match, and the entire node was moved, and
// it's not open, close this frontier node right away.
toEnd&&openEndCount<0&&parent&&parent.type==this.frontier[this.depth].type&&this.frontier.length>1&&this.closeFrontierNode();
// Add new frontier nodes for any open nodes at the end.
for(let i=0,cur=fragment;i<openEndCount;i++){let node=cur.lastChild;this.frontier.push({type:node.type,match:node.contentMatchAt(node.childCount)}),cur=node.content}
// Update `this.unplaced`. Drop the entire node from which we
// placed it we got to its end, otherwise just drop the placed
// nodes.
this.unplaced=toEnd?0==sliceDepth?prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.empty:new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(dropFromFragment(slice.content,sliceDepth-1,1),sliceDepth-1,openEndCount<0?slice.openEnd:sliceDepth-1):new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(dropFromFragment(slice.content,sliceDepth,taken),slice.openStart,slice.openEnd)}mustMoveInline(){if(!this.$to.parent.isTextblock)return-1;let level,top=this.frontier[this.depth];if(!top.type.isTextblock||!contentAfterFits(this.$to,this.$to.depth,top.type,top.match,!1)||this.$to.depth==this.depth&&(level=this.findCloseLevel(this.$to))&&level.depth==this.depth)return-1;let{depth:depth}=this.$to,after=this.$to.after(depth);while(depth>1&&after==this.$to.end(--depth))++after;return after}findCloseLevel($to){scan:for(let i=Math.min(this.depth,$to.depth);i>=0;i--){let{match:match,type:type}=this.frontier[i],dropInner=i<$to.depth&&$to.end(i+1)==$to.pos+($to.depth-(i+1)),fit=contentAfterFits($to,i,type,match,dropInner);if(fit){for(let d=i-1;d>=0;d--){let{match:match,type:type}=this.frontier[d],matches=contentAfterFits($to,d,type,match,!0);if(!matches||matches.childCount)continue scan}return{depth:i,fit:fit,move:dropInner?$to.doc.resolve($to.after(i+1)):$to}}}}close($to){let close=this.findCloseLevel($to);if(!close)return null;while(this.depth>close.depth)this.closeFrontierNode();close.fit.childCount&&(this.placed=addToFragment(this.placed,close.depth,close.fit)),$to=close.move;for(let d=close.depth+1;d<=$to.depth;d++){let node=$to.node(d),add=node.type.contentMatch.fillBefore(node.content,!0,$to.index(d));this.openFrontierNode(node.type,node.attrs,add)}return $to}openFrontierNode(type,attrs=null,content){let top=this.frontier[this.depth];top.match=top.match.matchType(type),this.placed=addToFragment(this.placed,this.depth,prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(type.create(attrs,content))),this.frontier.push({type:type,match:type.contentMatch})}closeFrontierNode(){let open=this.frontier.pop(),add=open.match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty,!0);add.childCount&&(this.placed=addToFragment(this.placed,this.frontier.length,add))}}function dropFromFragment(fragment,depth,count){return 0==depth?fragment.cutByIndex(count,fragment.childCount):fragment.replaceChild(0,fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content,depth-1,count)))}function addToFragment(fragment,depth,content){return 0==depth?fragment.append(content):fragment.replaceChild(fragment.childCount-1,fragment.lastChild.copy(addToFragment(fragment.lastChild.content,depth-1,content)))}function contentAt(fragment,depth){for(let i=0;i<depth;i++)fragment=fragment.firstChild.content;return fragment}function closeNodeStart(node,openStart,openEnd){if(openStart<=0)return node;let frag=node.content;return openStart>1&&(frag=frag.replaceChild(0,closeNodeStart(frag.firstChild,openStart-1,1==frag.childCount?openEnd-1:0))),openStart>0&&(frag=node.type.contentMatch.fillBefore(frag).append(frag),openEnd<=0&&(frag=frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty,!0)))),node.copy(frag)}function contentAfterFits($to,depth,type,match,open){let node=$to.node(depth),index=open?$to.indexAfter(depth):$to.index(depth);if(index==node.childCount&&!type.compatibleContent(node.type))return null;let fit=match.fillBefore(node.content,!0,index);return fit&&!invalidMarks(type,node.content,index)?fit:null}function invalidMarks(type,fragment,start){for(let i=start;i<fragment.childCount;i++)if(!type.allowsMarks(fragment.child(i).marks))return!0;return!1}function definesContent(type){return type.spec.defining||type.spec.definingForContent}function replaceRange(tr,from,to,slice){if(!slice.size)return tr.deleteRange(from,to);let $from=tr.doc.resolve(from),$to=tr.doc.resolve(to);if(fitsTrivially($from,$to,slice))return tr.step(new ReplaceStep(from,to,slice));let targetDepths=coveredDepths($from,tr.doc.resolve(to));
// Can't replace the whole document, so remove 0 if it's present
0==targetDepths[targetDepths.length-1]&&targetDepths.pop();
// Negative numbers represent not expansion over the whole node at
// that depth, but replacing from $from.before(-D) to $to.pos.
let preferredTarget=-($from.depth+1);targetDepths.unshift(preferredTarget);
// This loop picks a preferred target depth, if one of the covering
// depths is not outside of a defining node, and adds negative
// depths for any depth that has $from at its start and does not
// cross a defining node.
for(let d=$from.depth,pos=$from.pos-1;d>0;d--,pos--){let spec=$from.node(d).type.spec;if(spec.defining||spec.definingAsContext||spec.isolating)break;targetDepths.indexOf(d)>-1?preferredTarget=d:$from.before(d)==pos&&targetDepths.splice(1,0,-d)}
// Try to fit each possible depth of the slice into each possible
// target depth, starting with the preferred depths.
let preferredTargetIndex=targetDepths.indexOf(preferredTarget),leftNodes=[],preferredDepth=slice.openStart;for(let content=slice.content,i=0;;i++){let node=content.firstChild;if(leftNodes.push(node),i==slice.openStart)break;content=node.content}
// Back up preferredDepth to cover defining textblocks directly
// above it, possibly skipping a non-defining textblock.
for(let d=preferredDepth-1;d>=0;d--){let leftNode=leftNodes[d],def=definesContent(leftNode.type);if(def&&!leftNode.sameMarkup($from.node(Math.abs(preferredTarget)-1)))preferredDepth=d;else if(def||!leftNode.type.isTextblock)break}for(let j=slice.openStart;j>=0;j--){let openDepth=(j+preferredDepth+1)%(slice.openStart+1),insert=leftNodes[openDepth];if(insert)for(let i=0;i<targetDepths.length;i++){
// Loop over possible expansion levels, starting with the
// preferred one
let targetDepth=targetDepths[(i+preferredTargetIndex)%targetDepths.length],expand=!0;targetDepth<0&&(expand=!1,targetDepth=-targetDepth);let parent=$from.node(targetDepth-1),index=$from.index(targetDepth-1);if(parent.canReplaceWith(index,index,insert.type,insert.marks))return tr.replace($from.before(targetDepth),expand?$to.after(targetDepth):to,new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(closeFragment(slice.content,0,slice.openStart,openDepth),openDepth,slice.openEnd))}}let startSteps=tr.steps.length;for(let i=targetDepths.length-1;i>=0;i--){if(tr.replace(from,to,slice),tr.steps.length>startSteps)break;let depth=targetDepths[i];depth<0||(from=$from.before(depth),to=$to.after(depth))}}function closeFragment(fragment,depth,oldOpen,newOpen,parent){if(depth<oldOpen){let first=fragment.firstChild;fragment=fragment.replaceChild(0,first.copy(closeFragment(first.content,depth+1,oldOpen,newOpen,first)))}if(depth>newOpen){let match=parent.contentMatchAt(0),start=match.fillBefore(fragment).append(fragment);fragment=start.append(match.matchFragment(start).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty,!0))}return fragment}function replaceRangeWith(tr,from,to,node){if(!node.isInline&&from==to&&tr.doc.resolve(from).parent.content.size){let point=insertPoint(tr.doc,from,node.type);null!=point&&(from=to=point)}tr.replaceRange(from,to,new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(node),0,0))}function deleteRange(tr,from,to){let $from=tr.doc.resolve(from),$to=tr.doc.resolve(to),covered=coveredDepths($from,$to);for(let i=0;i<covered.length;i++){let depth=covered[i],last=i==covered.length-1;if(last&&0==depth||$from.node(depth).type.contentMatch.validEnd)return tr.delete($from.start(depth),$to.end(depth));if(depth>0&&(last||$from.node(depth-1).canReplace($from.index(depth-1),$to.indexAfter(depth-1))))return tr.delete($from.before(depth),$to.after(depth))}for(let d=1;d<=$from.depth&&d<=$to.depth;d++)if(from-$from.start(d)==$from.depth-d&&to>$from.end(d)&&$to.end(d)-to!=$to.depth-d)return tr.delete($from.before(d),to);tr.delete(from,to)}
// Returns an array of all depths for which $from - $to spans the
// whole content of the nodes at that depth.
function coveredDepths($from,$to){let result=[],minDepth=Math.min($from.depth,$to.depth);for(let d=minDepth;d>=0;d--){let start=$from.start(d);if(start<$from.pos-($from.depth-d)||$to.end(d)>$to.pos+($to.depth-d)||$from.node(d).type.spec.isolating||$to.node(d).type.spec.isolating)break;(start==$to.start(d)||d==$from.depth&&d==$to.depth&&$from.parent.inlineContent&&$to.parent.inlineContent&&d&&$to.start(d-1)==start-1)&&result.push(d)}return result}
/**
Update an attribute in a specific node.
*/class AttrStep extends Step{
/**
    Construct an attribute step.
    */
constructor(
/**
    The position of the target node.
    */
pos,
/**
    The attribute to set.
    */
attr,
// The attribute's new value.
value){super(),this.pos=pos,this.attr=attr,this.value=value}apply(doc){let node=doc.nodeAt(this.pos);if(!node)return StepResult.fail("No node at attribute step's position");let attrs=Object.create(null);for(let name in node.attrs)attrs[name]=node.attrs[name];attrs[this.attr]=this.value;let updated=node.type.create(attrs,null,node.marks);return StepResult.fromReplace(doc,this.pos,this.pos+1,new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(updated),0,node.isLeaf?0:1))}getMap(){return StepMap.empty}invert(doc){return new AttrStep(this.pos,this.attr,doc.nodeAt(this.pos).attrs[this.attr])}map(mapping){let pos=mapping.mapResult(this.pos,1);return pos.deletedAfter?null:new AttrStep(pos.pos,this.attr,this.value)}toJSON(){return{stepType:"attr",pos:this.pos,attr:this.attr,value:this.value}}static fromJSON(schema,json){if("number"!=typeof json.pos||"string"!=typeof json.attr)throw new RangeError("Invalid input for AttrStep.fromJSON");return new AttrStep(json.pos,json.attr,json.value)}}Step.jsonID("attr",AttrStep);
/**
Update an attribute in the doc node.
*/
class DocAttrStep extends Step{
/**
    Construct an attribute step.
    */
constructor(
/**
    The attribute to set.
    */
attr,
// The attribute's new value.
value){super(),this.attr=attr,this.value=value}apply(doc){let attrs=Object.create(null);for(let name in doc.attrs)attrs[name]=doc.attrs[name];attrs[this.attr]=this.value;let updated=doc.type.create(attrs,doc.content,doc.marks);return StepResult.ok(updated)}getMap(){return StepMap.empty}invert(doc){return new DocAttrStep(this.attr,doc.attrs[this.attr])}map(mapping){return this}toJSON(){return{stepType:"docAttr",attr:this.attr,value:this.value}}static fromJSON(schema,json){if("string"!=typeof json.attr)throw new RangeError("Invalid input for DocAttrStep.fromJSON");return new DocAttrStep(json.attr,json.value)}}Step.jsonID("docAttr",DocAttrStep);
/**
@internal
*/
let TransformError=class extends Error{};TransformError=function TransformError(message){let err=Error.call(this,message);return err.__proto__=TransformError.prototype,err},TransformError.prototype=Object.create(Error.prototype),TransformError.prototype.constructor=TransformError,TransformError.prototype.name="TransformError";
/**
Abstraction to build up and track an array of
[steps](https://prosemirror.net/docs/ref/#transform.Step) representing a document transformation.

Most transforming methods return the `Transform` object itself, so
that they can be chained.
*/
class Transform{
/**
    Create a transform that starts with the given document.
    */
constructor(
/**
    The current document (the result of applying the steps in the
    transform).
    */
doc){this.doc=doc,
/**
        The steps in this transform.
        */
this.steps=[],
/**
        The documents before each of the steps.
        */
this.docs=[],
/**
        A mapping with the maps for each of the steps in this transform.
        */
this.mapping=new Mapping}
/**
    The starting document.
    */get before(){return this.docs.length?this.docs[0]:this.doc}
/**
    Apply a new step in this transform, saving the result. Throws an
    error when the step fails.
    */step(step){let result=this.maybeStep(step);if(result.failed)throw new TransformError(result.failed);return this}
/**
    Try to apply a step in this transformation, ignoring it if it
    fails. Returns the step result.
    */maybeStep(step){let result=step.apply(this.doc);return result.failed||this.addStep(step,result.doc),result}
/**
    True when the document has been changed (when there are any
    steps).
    */get docChanged(){return this.steps.length>0}
/**
    @internal
    */addStep(step,doc){this.docs.push(this.doc),this.steps.push(step),this.mapping.appendMap(step.getMap()),this.doc=doc}
/**
    Replace the part of the document between `from` and `to` with the
    given `slice`.
    */replace(from,to=from,slice=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.empty){let step=replaceStep(this.doc,from,to,slice);return step&&this.step(step),this}
/**
    Replace the given range with the given content, which may be a
    fragment, node, or array of nodes.
    */replaceWith(from,to,content){return this.replace(from,to,new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(content),0,0))}
/**
    Delete the content between the given positions.
    */delete(from,to){return this.replace(from,to,prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.empty)}
/**
    Insert the given content at the given position.
    */insert(pos,content){return this.replaceWith(pos,pos,content)}
/**
    Replace a range of the document with a given slice, using
    `from`, `to`, and the slice's
    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
    than fixed start and end points. This method may grow the
    replaced area or close open nodes in the slice in order to get a
    fit that is more in line with WYSIWYG expectations, by dropping
    fully covered parent nodes of the replaced region when they are
    marked [non-defining as
    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
    open parent node from the slice that _is_ marked as [defining
    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
    
    This is the method, for example, to handle paste. The similar
    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
    primitive tool which will _not_ move the start and end of its given
    range, and is useful in situations where you need more precise
    control over what happens.
    */replaceRange(from,to,slice){return replaceRange(this,from,to,slice),this}
/**
    Replace the given range with a node, but use `from` and `to` as
    hints, rather than precise positions. When from and to are the same
    and are at the start or end of a parent node in which the given
    node doesn't fit, this method may _move_ them out towards a parent
    that does allow the given node to be placed. When the given range
    completely covers a parent node, this method may completely replace
    that parent node.
    */replaceRangeWith(from,to,node){return replaceRangeWith(this,from,to,node),this}
/**
    Delete the given range, expanding it to cover fully covered
    parent nodes until a valid replace is found.
    */deleteRange(from,to){return deleteRange(this,from,to),this}
/**
    Split the content in the given range off from its parent, if there
    is sibling content before or after it, and move it up the tree to
    the depth specified by `target`. You'll probably want to use
    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
    sure the lift is valid.
    */lift(range,target){return lift(this,range,target),this}
/**
    Join the blocks around the given position. If depth is 2, their
    last and first siblings are also joined, and so on.
    */join(pos,depth=1){return join(this,pos,depth),this}
/**
    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
    The wrappers are assumed to be valid in this position, and should
    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
    */wrap(range,wrappers){return wrap(this,range,wrappers),this}
/**
    Set the type of all textblocks (partly) between `from` and `to` to
    the given node type with the given attributes.
    */setBlockType(from,to=from,type,attrs=null){return setBlockType(this,from,to,type,attrs),this}
/**
    Change the type, attributes, and/or marks of the node at `pos`.
    When `type` isn't given, the existing node type is preserved,
    */setNodeMarkup(pos,type,attrs=null,marks){return setNodeMarkup(this,pos,type,attrs,marks),this}
/**
    Set a single attribute on a given node to a new value.
    The `pos` addresses the document content. Use `setDocAttribute`
    to set attributes on the document itself.
    */setNodeAttribute(pos,attr,value){return this.step(new AttrStep(pos,attr,value)),this}
/**
    Set a single attribute on the document to a new value.
    */setDocAttribute(attr,value){return this.step(new DocAttrStep(attr,value)),this}
/**
    Add a mark to the node at position `pos`.
    */addNodeMark(pos,mark){return this.step(new AddNodeMarkStep(pos,mark)),this}
/**
    Remove a mark (or a mark of the given type) from the node at
    position `pos`.
    */removeNodeMark(pos,mark){if(!(mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Mark */.vc)){let node=this.doc.nodeAt(pos);if(!node)throw new RangeError("No node at position "+pos);if(mark=mark.isInSet(node.marks),!mark)return this}return this.step(new RemoveNodeMarkStep(pos,mark)),this}
/**
    Split the node at the given position, and optionally, if `depth` is
    greater than one, any number of nodes above that. By default, the
    parts split off will inherit the node type of the original node.
    This can be changed by passing an array of types and attributes to
    use after the split.
    */split(pos,depth=1,typesAfter){return split(this,pos,depth,typesAfter),this}
/**
    Add the given mark to the inline content between `from` and `to`.
    */addMark(from,to,mark){return addMark(this,from,to,mark),this}
/**
    Remove marks from inline nodes between `from` and `to`. When
    `mark` is a single mark, remove precisely that mark. When it is
    a mark type, remove all marks of that type. When it is null,
    remove all marks of any type.
    */removeMark(from,to,mark){return removeMark(this,from,to,mark),this}
/**
    Removes all marks and nodes from the content of the node at
    `pos` that don't match the given new parent node type. Accepts
    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
    third argument.
    */clearIncompatible(pos,parentType,match){return clearIncompatible(this,pos,parentType,match),this}}
/***/},
/***/484348:
/***/function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";
/* harmony export */__webpack_require__.d(__webpack_exports__,{
/* harmony export */EH:function(){/* binding */return DecorationSet},
/* harmony export */p:function(){/* binding */return Decoration},
/* harmony export */tk:function(){/* binding */return EditorView}
/* harmony export */});
/* unused harmony exports __endComposition, __parseFromClipboard, __serializeForClipboard */
/* harmony import */var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(102376),prosemirror_model__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(759084),prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(616560);
/* harmony import */const domIndex=function(node){for(var index=0;;index++)if(node=node.previousSibling,!node)return index},parentNode=function(node){let parent=node.assignedSlot||node.parentNode;return parent&&11==parent.nodeType?parent.host:parent};let reusedRange=null;
// Note that this will always return the same range, because DOM range
// objects are every expensive, and keep slowing down subsequent DOM
// updates, for some reason.
const textRange=function(node,from,to){let range=reusedRange||(reusedRange=document.createRange());return range.setEnd(node,null==to?node.nodeValue.length:to),range.setStart(node,from||0),range},isEquivalentPosition=function(node,off,targetNode,targetOff){return targetNode&&(scanFor(node,off,targetNode,targetOff,-1)||scanFor(node,off,targetNode,targetOff,1))},atomElements=/^(img|br|input|textarea|hr)$/i;
// Scans forward and backward through DOM positions equivalent to the
// given one to see if the two are in the same place (i.e. after a
// text node vs at the end of that text node)
function scanFor(node,off,targetNode,targetOff,dir){for(;;){if(node==targetNode&&off==targetOff)return!0;if(off==(dir<0?0:nodeSize(node))){let parent=node.parentNode;if(!parent||1!=parent.nodeType||hasBlockDesc(node)||atomElements.test(node.nodeName)||"false"==node.contentEditable)return!1;off=domIndex(node)+(dir<0?0:1),node=parent}else{if(1!=node.nodeType)return!1;if(node=node.childNodes[off+(dir<0?-1:0)],"false"==node.contentEditable)return!1;off=dir<0?nodeSize(node):0}}}function nodeSize(node){return 3==node.nodeType?node.nodeValue.length:node.childNodes.length}function isOnEdge(node,offset,parent){for(let atStart=0==offset,atEnd=offset==nodeSize(node);atStart||atEnd;){if(node==parent)return!0;let index=domIndex(node);if(node=node.parentNode,!node)return!1;atStart=atStart&&0==index,atEnd=atEnd&&index==nodeSize(node)}}function hasBlockDesc(dom){let desc;for(let cur=dom;cur;cur=cur.parentNode)if(desc=cur.pmViewDesc)break;return desc&&desc.node&&desc.node.isBlock&&(desc.dom==dom||desc.contentDOM==dom)}
// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523
// (isCollapsed inappropriately returns true in shadow dom)
const selectionCollapsed=function(domSel){return domSel.focusNode&&isEquivalentPosition(domSel.focusNode,domSel.focusOffset,domSel.anchorNode,domSel.anchorOffset)};function keyEvent(keyCode,key){let event=document.createEvent("Event");return event.initEvent("keydown",!0,!0),event.keyCode=keyCode,event.key=event.code=key,event}function deepActiveElement(doc){let elt=doc.activeElement;while(elt&&elt.shadowRoot)elt=elt.shadowRoot.activeElement;return elt}function caretFromPoint(doc,x,y){if(doc.caretPositionFromPoint)try{// Firefox throws for this call in hard-to-predict circumstances (#994)
let pos=doc.caretPositionFromPoint(x,y);if(pos)return{node:pos.offsetNode,offset:pos.offset}}catch(_){}if(doc.caretRangeFromPoint){let range=doc.caretRangeFromPoint(x,y);if(range)return{node:range.startContainer,offset:range.startOffset}}}const nav="undefined"!=typeof navigator?navigator:null,doc="undefined"!=typeof document?document:null,agent=nav&&nav.userAgent||"",ie_edge=/Edge\/(\d+)/.exec(agent),ie_upto10=/MSIE \d/.exec(agent),ie_11up=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent),ie=!!(ie_upto10||ie_11up||ie_edge),ie_version=ie_upto10?document.documentMode:ie_11up?+ie_11up[1]:ie_edge?+ie_edge[1]:0,gecko=!ie&&/gecko\/(\d+)/i.test(agent);gecko&&(/Firefox\/(\d+)/.exec(agent)||[0,0])[1];const _chrome=!ie&&/Chrome\/(\d+)/.exec(agent),chrome=!!_chrome,chrome_version=_chrome?+_chrome[1]:0,safari=!ie&&!!nav&&/Apple Computer/.test(nav.vendor),ios=safari&&(/Mobile\/\w+/.test(agent)||!!nav&&nav.maxTouchPoints>2),mac=ios||!!nav&&/Mac/.test(nav.platform),windows=!!nav&&/Win/.test(nav.platform),android=/Android \d/.test(agent),webkit=!!doc&&"webkitFontSmoothing"in doc.documentElement.style,webkit_version=webkit?+(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent)||[0,0])[1]:0;function windowRect(doc){return{left:0,right:doc.documentElement.clientWidth,top:0,bottom:doc.documentElement.clientHeight}}function getSide(value,side){return"number"==typeof value?value:value[side]}function clientRect(node){let rect=node.getBoundingClientRect(),scaleX=rect.width/node.offsetWidth||1,scaleY=rect.height/node.offsetHeight||1;
// Adjust for elements with style "transform: scale()"
// Make sure scrollbar width isn't included in the rectangle
return{left:rect.left,right:rect.left+node.clientWidth*scaleX,top:rect.top,bottom:rect.top+node.clientHeight*scaleY}}function scrollRectIntoView(view,rect,startDOM){let scrollThreshold=view.someProp("scrollThreshold")||0,scrollMargin=view.someProp("scrollMargin")||5,doc=view.dom.ownerDocument;for(let parent=startDOM||view.dom;;parent=parentNode(parent)){if(!parent)break;if(1!=parent.nodeType)continue;let elt=parent,atTop=elt==doc.body,bounding=atTop?windowRect(doc):clientRect(elt),moveX=0,moveY=0;if(rect.top<bounding.top+getSide(scrollThreshold,"top")?moveY=-(bounding.top-rect.top+getSide(scrollMargin,"top")):rect.bottom>bounding.bottom-getSide(scrollThreshold,"bottom")&&(moveY=rect.bottom-rect.top>bounding.bottom-bounding.top?rect.top+getSide(scrollMargin,"top")-bounding.top:rect.bottom-bounding.bottom+getSide(scrollMargin,"bottom")),rect.left<bounding.left+getSide(scrollThreshold,"left")?moveX=-(bounding.left-rect.left+getSide(scrollMargin,"left")):rect.right>bounding.right-getSide(scrollThreshold,"right")&&(moveX=rect.right-bounding.right+getSide(scrollMargin,"right")),moveX||moveY)if(atTop)doc.defaultView.scrollBy(moveX,moveY);else{let startX=elt.scrollLeft,startY=elt.scrollTop;moveY&&(elt.scrollTop+=moveY),moveX&&(elt.scrollLeft+=moveX);let dX=elt.scrollLeft-startX,dY=elt.scrollTop-startY;rect={left:rect.left-dX,top:rect.top-dY,right:rect.right-dX,bottom:rect.bottom-dY}}if(atTop||/^(fixed|sticky)$/.test(getComputedStyle(parent).position))break}}
// Store the scroll position of the editor's parent nodes, along with
// the top position of an element near the top of the editor, which
// will be used to make sure the visible viewport remains stable even
// when the size of the content above changes.
function storeScrollPos(view){let refDOM,refTop,rect=view.dom.getBoundingClientRect(),startY=Math.max(0,rect.top);for(let x=(rect.left+rect.right)/2,y=startY+1;y<Math.min(innerHeight,rect.bottom);y+=5){let dom=view.root.elementFromPoint(x,y);if(!dom||dom==view.dom||!view.dom.contains(dom))continue;let localRect=dom.getBoundingClientRect();if(localRect.top>=startY-20){refDOM=dom,refTop=localRect.top;break}}return{refDOM:refDOM,refTop:refTop,stack:scrollStack(view.dom)}}function scrollStack(dom){let stack=[],doc=dom.ownerDocument;for(let cur=dom;cur;cur=parentNode(cur))if(stack.push({dom:cur,top:cur.scrollTop,left:cur.scrollLeft}),dom==doc)break;return stack}
// Reset the scroll position of the editor's parent nodes to that what
// it was before, when storeScrollPos was called.
function resetScrollPos({refDOM:refDOM,refTop:refTop,stack:stack}){let newRefTop=refDOM?refDOM.getBoundingClientRect().top:0;restoreScrollStack(stack,0==newRefTop?0:newRefTop-refTop)}function restoreScrollStack(stack,dTop){for(let i=0;i<stack.length;i++){let{dom:dom,top:top,left:left}=stack[i];dom.scrollTop!=top+dTop&&(dom.scrollTop=top+dTop),dom.scrollLeft!=left&&(dom.scrollLeft=left)}}let preventScrollSupported=null;
// Feature-detects support for .focus({preventScroll: true}), and uses
// a fallback kludge when not supported.
function focusPreventScroll(dom){if(dom.setActive)return dom.setActive();// in IE
if(preventScrollSupported)return dom.focus(preventScrollSupported);let stored=scrollStack(dom);dom.focus(null==preventScrollSupported?{get preventScroll(){return preventScrollSupported={preventScroll:!0},!0}}:void 0),preventScrollSupported||(preventScrollSupported=!1,restoreScrollStack(stored,0))}function findOffsetInNode(node,coords){let closest,coordsClosest,firstBelow,coordsBelow,dxClosest=2e8,offset=0,rowBot=coords.top,rowTop=coords.top;for(let child=node.firstChild,childIndex=0;child;child=child.nextSibling,childIndex++){let rects;if(1==child.nodeType)rects=child.getClientRects();else{if(3!=child.nodeType)continue;rects=textRange(child).getClientRects()}for(let i=0;i<rects.length;i++){let rect=rects[i];if(rect.top<=rowBot&&rect.bottom>=rowTop){rowBot=Math.max(rect.bottom,rowBot),rowTop=Math.min(rect.top,rowTop);let dx=rect.left>coords.left?rect.left-coords.left:rect.right<coords.left?coords.left-rect.right:0;if(dx<dxClosest){closest=child,dxClosest=dx,coordsClosest=dx&&3==closest.nodeType?{left:rect.right<coords.left?rect.right:rect.left,top:coords.top}:coords,1==child.nodeType&&dx&&(offset=childIndex+(coords.left>=(rect.left+rect.right)/2?1:0));continue}}else rect.top>coords.top&&!firstBelow&&rect.left<=coords.left&&rect.right>=coords.left&&(firstBelow=child,coordsBelow={left:Math.max(rect.left,Math.min(rect.right,coords.left)),top:rect.top});!closest&&(coords.left>=rect.right&&coords.top>=rect.top||coords.left>=rect.left&&coords.top>=rect.bottom)&&(offset=childIndex+1)}}return!closest&&firstBelow&&(closest=firstBelow,coordsClosest=coordsBelow,dxClosest=0),closest&&3==closest.nodeType?findOffsetInText(closest,coordsClosest):!closest||dxClosest&&1==closest.nodeType?{node:node,offset:offset}:findOffsetInNode(closest,coordsClosest)}function findOffsetInText(node,coords){let len=node.nodeValue.length,range=document.createRange();for(let i=0;i<len;i++){range.setEnd(node,i+1),range.setStart(node,i);let rect=singleRect(range,1);if(rect.top!=rect.bottom&&inRect(coords,rect))return{node:node,offset:i+(coords.left>=(rect.left+rect.right)/2?1:0)}}return{node:node,offset:0}}function inRect(coords,rect){return coords.left>=rect.left-1&&coords.left<=rect.right+1&&coords.top>=rect.top-1&&coords.top<=rect.bottom+1}function targetKludge(dom,coords){let parent=dom.parentNode;return parent&&/^li$/i.test(parent.nodeName)&&coords.left<dom.getBoundingClientRect().left?parent:dom}function posFromElement(view,elt,coords){let{node:node,offset:offset}=findOffsetInNode(elt,coords),bias=-1;if(1==node.nodeType&&!node.firstChild){let rect=node.getBoundingClientRect();bias=rect.left!=rect.right&&coords.left>(rect.left+rect.right)/2?1:-1}return view.docView.posFromDOM(node,offset,bias)}function posFromCaret(view,node,offset,coords){
// Browser (in caretPosition/RangeFromPoint) will agressively
// normalize towards nearby inline nodes. Since we are interested in
// positions between block nodes too, we first walk up the hierarchy
// of nodes to see if there are block nodes that the coordinates
// fall outside of. If so, we take the position before/after that
// block. If not, we call `posFromDOM` on the raw node/offset.
let outsideBlock=-1;for(let cur=node,sawBlock=!1;;){if(cur==view.dom)break;let desc=view.docView.nearestDesc(cur,!0);if(!desc)return null;if(1==desc.dom.nodeType&&(desc.node.isBlock&&desc.parent&&!sawBlock||!desc.contentDOM)){let rect=desc.dom.getBoundingClientRect();if(desc.node.isBlock&&desc.parent&&!sawBlock&&(sawBlock=!0,rect.left>coords.left||rect.top>coords.top?outsideBlock=desc.posBefore:(rect.right<coords.left||rect.bottom<coords.top)&&(outsideBlock=desc.posAfter)),!desc.contentDOM&&outsideBlock<0&&!desc.node.isText){
// If we are inside a leaf, return the side of the leaf closer to the coords
let before=desc.node.isBlock?coords.top<(rect.top+rect.bottom)/2:coords.left<(rect.left+rect.right)/2;return before?desc.posBefore:desc.posAfter}}cur=desc.dom.parentNode}return outsideBlock>-1?outsideBlock:view.docView.posFromDOM(node,offset,-1)}function elementFromPoint(element,coords,box){let len=element.childNodes.length;if(len&&box.top<box.bottom)for(let startI=Math.max(0,Math.min(len-1,Math.floor(len*(coords.top-box.top)/(box.bottom-box.top))-2)),i=startI;;){let child=element.childNodes[i];if(1==child.nodeType){let rects=child.getClientRects();for(let j=0;j<rects.length;j++){let rect=rects[j];if(inRect(coords,rect))return elementFromPoint(child,coords,rect)}}if((i=(i+1)%len)==startI)break}return element}
// Given an x,y position on the editor, get the position in the document.
function posAtCoords(view,coords){let node,doc=view.dom.ownerDocument,offset=0,caret=caretFromPoint(doc,coords.left,coords.top);caret&&({node:node,offset:offset}=caret);let pos,elt=(view.root.elementFromPoint?view.root:doc).elementFromPoint(coords.left,coords.top);if(!elt||!view.dom.contains(1!=elt.nodeType?elt.parentNode:elt)){let box=view.dom.getBoundingClientRect();if(!inRect(coords,box))return null;if(elt=elementFromPoint(view.dom,coords,box),!elt)return null}
// Safari's caretRangeFromPoint returns nonsense when on a draggable element
if(safari)for(let p=elt;node&&p;p=parentNode(p))p.draggable&&(node=void 0);if(elt=targetKludge(elt,coords),node){if(gecko&&1==node.nodeType&&(
// Firefox will sometimes return offsets into <input> nodes, which
// have no actual children, from caretPositionFromPoint (#953)
offset=Math.min(offset,node.childNodes.length),offset<node.childNodes.length)){let box,next=node.childNodes[offset];"IMG"==next.nodeName&&(box=next.getBoundingClientRect()).right<=coords.left&&box.bottom>coords.top&&offset++}let prev;
// When clicking above the right side of an uneditable node, Chrome will report a cursor position after that node.
webkit&&offset&&1==node.nodeType&&1==(prev=node.childNodes[offset-1]).nodeType&&"false"==prev.contentEditable&&prev.getBoundingClientRect().top>=coords.top&&offset--,
// Suspiciously specific kludge to work around caret*FromPoint
// never returning a position at the end of the document
node==view.dom&&offset==node.childNodes.length-1&&1==node.lastChild.nodeType&&coords.top>node.lastChild.getBoundingClientRect().bottom?pos=view.state.doc.content.size:0!=offset&&1==node.nodeType&&"BR"==node.childNodes[offset-1].nodeName||(pos=posFromCaret(view,node,offset,coords))}null==pos&&(pos=posFromElement(view,elt,coords));let desc=view.docView.nearestDesc(elt,!0);return{pos:pos,inside:desc?desc.posAtStart-desc.border:-1}}function nonZero(rect){return rect.top<rect.bottom||rect.left<rect.right}function singleRect(target,bias){let rects=target.getClientRects();if(rects.length){let first=rects[bias<0?0:rects.length-1];if(nonZero(first))return first}return Array.prototype.find.call(rects,nonZero)||target.getBoundingClientRect()}const BIDI=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
// Given a position in the document model, get a bounding box of the
// character at that position, relative to the window.
function coordsAtPos(view,pos,side){let{node:node,offset:offset,atom:atom}=view.docView.domFromPos(pos,side<0?-1:1),supportEmptyRange=webkit||gecko;if(3==node.nodeType){
// These browsers support querying empty text ranges. Prefer that in
// bidi context or when at the end of a node.
if(!supportEmptyRange||!BIDI.test(node.nodeValue)&&(side<0?offset:offset!=node.nodeValue.length)){let from=offset,to=offset,takeSide=side<0?1:-1;return side<0&&!offset?(to++,takeSide=-1):side>=0&&offset==node.nodeValue.length?(from--,takeSide=1):side<0?from--:to++,flattenV(singleRect(textRange(node,from,to),takeSide),takeSide<0)}{let rect=singleRect(textRange(node,offset,offset),side);
// Firefox returns bad results (the position before the space)
// when querying a position directly after line-broken
// whitespace. Detect this situation and and kludge around it
if(gecko&&offset&&/\s/.test(node.nodeValue[offset-1])&&offset<node.nodeValue.length){let rectBefore=singleRect(textRange(node,offset-1,offset-1),-1);if(rectBefore.top==rect.top){let rectAfter=singleRect(textRange(node,offset,offset+1),-1);if(rectAfter.top!=rect.top)return flattenV(rectAfter,rectAfter.left<rectBefore.left)}}return rect}}let $dom=view.state.doc.resolve(pos-(atom||0));
// Return a horizontal line in block context
if(!$dom.parent.inlineContent){if(null==atom&&offset&&(side<0||offset==nodeSize(node))){let before=node.childNodes[offset-1];if(1==before.nodeType)return flattenH(before.getBoundingClientRect(),!1)}if(null==atom&&offset<nodeSize(node)){let after=node.childNodes[offset];if(1==after.nodeType)return flattenH(after.getBoundingClientRect(),!0)}return flattenH(node.getBoundingClientRect(),side>=0)}
// Inline, not in text node (this is not Bidi-safe)
if(null==atom&&offset&&(side<0||offset==nodeSize(node))){let before=node.childNodes[offset-1],target=3==before.nodeType?textRange(before,nodeSize(before)-(supportEmptyRange?0:1)):1!=before.nodeType||"BR"==before.nodeName&&before.nextSibling?null:before;if(target)return flattenV(singleRect(target,1),!1)}if(null==atom&&offset<nodeSize(node)){let after=node.childNodes[offset];while(after.pmViewDesc&&after.pmViewDesc.ignoreForCoords)after=after.nextSibling;let target=after?3==after.nodeType?textRange(after,0,supportEmptyRange?0:1):1==after.nodeType?after:null:null;if(target)return flattenV(singleRect(target,-1),!0)}
// All else failed, just try to get a rectangle for the target node
return flattenV(singleRect(3==node.nodeType?textRange(node):node,-side),side>=0)}function flattenV(rect,left){if(0==rect.width)return rect;let x=left?rect.left:rect.right;return{top:rect.top,bottom:rect.bottom,left:x,right:x}}function flattenH(rect,top){if(0==rect.height)return rect;let y=top?rect.top:rect.bottom;return{top:y,bottom:y,left:rect.left,right:rect.right}}function withFlushedState(view,state,f){let viewState=view.state,active=view.root.activeElement;viewState!=state&&view.updateState(state),active!=view.dom&&view.focus();try{return f()}finally{viewState!=state&&view.updateState(viewState),active!=view.dom&&active&&active.focus()}}
// Whether vertical position motion in a given direction
// from a position would leave a text block.
function endOfTextblockVertical(view,state,dir){let sel=state.selection,$pos="up"==dir?sel.$from:sel.$to;return withFlushedState(view,state,(()=>{let{node:dom}=view.docView.domFromPos($pos.pos,"up"==dir?-1:1);for(;;){let nearest=view.docView.nearestDesc(dom,!0);if(!nearest)break;if(nearest.node.isBlock){dom=nearest.contentDOM||nearest.dom;break}dom=nearest.dom.parentNode}let coords=coordsAtPos(view,$pos.pos,1);for(let child=dom.firstChild;child;child=child.nextSibling){let boxes;if(1==child.nodeType)boxes=child.getClientRects();else{if(3!=child.nodeType)continue;boxes=textRange(child,0,child.nodeValue.length).getClientRects()}for(let i=0;i<boxes.length;i++){let box=boxes[i];if(box.bottom>box.top+1&&("up"==dir?coords.top-box.top>2*(box.bottom-coords.top):box.bottom-coords.bottom>2*(coords.bottom-box.top)))return!1}}return!0}))}const maybeRTL=/[\u0590-\u08ac]/;function endOfTextblockHorizontal(view,state,dir){let{$head:$head}=state.selection;if(!$head.parent.isTextblock)return!1;let offset=$head.parentOffset,atStart=!offset,atEnd=offset==$head.parent.content.size,sel=view.domSelection();
// If the textblock is all LTR, or the browser doesn't support
// Selection.modify (Edge), fall back to a primitive approach
return maybeRTL.test($head.parent.textContent)&&sel.modify?withFlushedState(view,state,(()=>{
// This is a huge hack, but appears to be the best we can
// currently do: use `Selection.modify` to move the selection by
// one character, and see if that moves the cursor out of the
// textblock (or doesn't move it at all, when at the start/end of
// the document).
let{focusNode:oldNode,focusOffset:oldOff,anchorNode:anchorNode,anchorOffset:anchorOffset}=view.domSelectionRange(),oldBidiLevel=sel.caretBidiLevel;sel.modify("move",dir,"character");let parentDOM=$head.depth?view.docView.domAfterPos($head.before()):view.dom,{focusNode:newNode,focusOffset:newOff}=view.domSelectionRange(),result=newNode&&!parentDOM.contains(1==newNode.nodeType?newNode:newNode.parentNode)||oldNode==newNode&&oldOff==newOff;
// Restore the previous selection
try{sel.collapse(anchorNode,anchorOffset),oldNode&&(oldNode!=anchorNode||oldOff!=anchorOffset)&&sel.extend&&sel.extend(oldNode,oldOff)}catch(_){}return null!=oldBidiLevel&&(sel.caretBidiLevel=oldBidiLevel),result})):"left"==dir||"backward"==dir?atStart:atEnd}let cachedState=null,cachedDir=null,cachedResult=!1;function endOfTextblock(view,state,dir){return cachedState==state&&cachedDir==dir?cachedResult:(cachedState=state,cachedDir=dir,cachedResult="up"==dir||"down"==dir?endOfTextblockVertical(view,state,dir):endOfTextblockHorizontal(view,state,dir))}
// View descriptions are data structures that describe the DOM that is
// used to represent the editor's content. They are used for:

// - Incremental redrawing when the document changes

// - Figuring out what part of the document a given DOM position
//   corresponds to

// - Wiring in custom implementations of the editing interface for a
//   given node

// They form a doubly-linked mutable tree, starting at `view.docView`.
const NOT_DIRTY=0,CHILD_DIRTY=1,CONTENT_DIRTY=2,NODE_DIRTY=3;
// Superclass for the various kinds of descriptions. Defines their
// basic structure and shared methods.
class ViewDesc{constructor(parent,children,dom,
// This is the node that holds the child views. It may be null for
// descs that don't have children.
contentDOM){this.parent=parent,this.children=children,this.dom=dom,this.contentDOM=contentDOM,this.dirty=NOT_DIRTY,
// An expando property on the DOM node provides a link back to its
// description.
dom.pmViewDesc=this}
// Used to check whether a given description corresponds to a
// widget/mark/node.
matchesWidget(widget){return!1}matchesMark(mark){return!1}matchesNode(node,outerDeco,innerDeco){return!1}matchesHack(nodeName){return!1}
// When parsing in-editor content (in domchange.js), we allow
// descriptions to determine the parse rules that should be used to
// parse them.
parseRule(){return null}
// Used by the editor's event handler to ignore events that come
// from certain descs.
stopEvent(event){return!1}
// The size of the content represented by this desc.
get size(){let size=0;for(let i=0;i<this.children.length;i++)size+=this.children[i].size;return size}
// For block nodes, this represents the space taken up by their
// start/end tokens.
get border(){return 0}destroy(){this.parent=void 0,this.dom.pmViewDesc==this&&(this.dom.pmViewDesc=void 0);for(let i=0;i<this.children.length;i++)this.children[i].destroy()}posBeforeChild(child){for(let i=0,pos=this.posAtStart;;i++){let cur=this.children[i];if(cur==child)return pos;pos+=cur.size}}get posBefore(){return this.parent.posBeforeChild(this)}get posAtStart(){return this.parent?this.parent.posBeforeChild(this)+this.border:0}get posAfter(){return this.posBefore+this.size}get posAtEnd(){return this.posAtStart+this.size-2*this.border}localPosFromDOM(dom,offset,bias){
// If the DOM position is in the content, use the child desc after
// it to figure out a position.
if(this.contentDOM&&this.contentDOM.contains(1==dom.nodeType?dom:dom.parentNode)){if(bias<0){let domBefore,desc;if(dom==this.contentDOM)domBefore=dom.childNodes[offset-1];else{while(dom.parentNode!=this.contentDOM)dom=dom.parentNode;domBefore=dom.previousSibling}while(domBefore&&(!(desc=domBefore.pmViewDesc)||desc.parent!=this))domBefore=domBefore.previousSibling;return domBefore?this.posBeforeChild(desc)+desc.size:this.posAtStart}{let domAfter,desc;if(dom==this.contentDOM)domAfter=dom.childNodes[offset];else{while(dom.parentNode!=this.contentDOM)dom=dom.parentNode;domAfter=dom.nextSibling}while(domAfter&&(!(desc=domAfter.pmViewDesc)||desc.parent!=this))domAfter=domAfter.nextSibling;return domAfter?this.posBeforeChild(desc):this.posAtEnd}}
// Otherwise, use various heuristics, falling back on the bias
// parameter, to determine whether to return the position at the
// start or at the end of this view desc.
let atEnd;if(dom==this.dom&&this.contentDOM)atEnd=offset>domIndex(this.contentDOM);else if(this.contentDOM&&this.contentDOM!=this.dom&&this.dom.contains(this.contentDOM))atEnd=2&dom.compareDocumentPosition(this.contentDOM);else if(this.dom.firstChild){if(0==offset)for(let search=dom;;search=search.parentNode){if(search==this.dom){atEnd=!1;break}if(search.previousSibling)break}if(null==atEnd&&offset==dom.childNodes.length)for(let search=dom;;search=search.parentNode){if(search==this.dom){atEnd=!0;break}if(search.nextSibling)break}}return(null==atEnd?bias>0:atEnd)?this.posAtEnd:this.posAtStart}nearestDesc(dom,onlyNodes=!1){for(let first=!0,cur=dom;cur;cur=cur.parentNode){let nodeDOM,desc=this.getDesc(cur);if(desc&&(!onlyNodes||desc.node)){
// If dom is outside of this desc's nodeDOM, don't count it.
if(!first||!(nodeDOM=desc.nodeDOM)||(1==nodeDOM.nodeType?nodeDOM.contains(1==dom.nodeType?dom:dom.parentNode):nodeDOM==dom))return desc;first=!1}}}getDesc(dom){let desc=dom.pmViewDesc;for(let cur=desc;cur;cur=cur.parent)if(cur==this)return desc}posFromDOM(dom,offset,bias){for(let scan=dom;scan;scan=scan.parentNode){let desc=this.getDesc(scan);if(desc)return desc.localPosFromDOM(dom,offset,bias)}return-1}
// Find the desc for the node after the given pos, if any. (When a
// parent node overrode rendering, there might not be one.)
descAt(pos){for(let i=0,offset=0;i<this.children.length;i++){let child=this.children[i],end=offset+child.size;if(offset==pos&&end!=offset){while(!child.border&&child.children.length)child=child.children[0];return child}if(pos<end)return child.descAt(pos-offset-child.border);offset=end}}domFromPos(pos,side){if(!this.contentDOM)return{node:this.dom,offset:0,atom:pos+1};
// First find the position in the child array
let i=0,offset=0;for(let curPos=0;i<this.children.length;i++){let child=this.children[i],end=curPos+child.size;if(end>pos||child instanceof TrailingHackViewDesc){offset=pos-curPos;break}curPos=end}
// If this points into the middle of a child, call through
if(offset)return this.children[i].domFromPos(offset-this.children[i].border,side);
// Go back if there were any zero-length widgets with side >= 0 before this point
for(let prev;i&&!(prev=this.children[i-1]).size&&prev instanceof WidgetViewDesc&&prev.side>=0;i--);
// Scan towards the first useable node
if(side<=0){let prev,enter=!0;for(;;i--,enter=!1)if(prev=i?this.children[i-1]:null,!prev||prev.dom.parentNode==this.contentDOM)break;return prev&&side&&enter&&!prev.border&&!prev.domAtom?prev.domFromPos(prev.size,side):{node:this.contentDOM,offset:prev?domIndex(prev.dom)+1:0}}{let next,enter=!0;for(;;i++,enter=!1)if(next=i<this.children.length?this.children[i]:null,!next||next.dom.parentNode==this.contentDOM)break;return next&&enter&&!next.border&&!next.domAtom?next.domFromPos(0,side):{node:this.contentDOM,offset:next?domIndex(next.dom):this.contentDOM.childNodes.length}}}
// Used to find a DOM range in a single parent for a given changed
// range.
parseRange(from,to,base=0){if(0==this.children.length)return{node:this.contentDOM,from:from,to:to,fromOffset:0,toOffset:this.contentDOM.childNodes.length};let fromOffset=-1,toOffset=-1;for(let offset=base,i=0;;i++){let child=this.children[i],end=offset+child.size;if(-1==fromOffset&&from<=end){let childBase=offset+child.border;
// FIXME maybe descend mark views to parse a narrower range?
if(from>=childBase&&to<=end-child.border&&child.node&&child.contentDOM&&this.contentDOM.contains(child.contentDOM))return child.parseRange(from,to,childBase);from=offset;for(let j=i;j>0;j--){let prev=this.children[j-1];if(prev.size&&prev.dom.parentNode==this.contentDOM&&!prev.emptyChildAt(1)){fromOffset=domIndex(prev.dom)+1;break}from-=prev.size}-1==fromOffset&&(fromOffset=0)}if(fromOffset>-1&&(end>to||i==this.children.length-1)){to=end;for(let j=i+1;j<this.children.length;j++){let next=this.children[j];if(next.size&&next.dom.parentNode==this.contentDOM&&!next.emptyChildAt(-1)){toOffset=domIndex(next.dom);break}to+=next.size}-1==toOffset&&(toOffset=this.contentDOM.childNodes.length);break}offset=end}return{node:this.contentDOM,from:from,to:to,fromOffset:fromOffset,toOffset:toOffset}}emptyChildAt(side){if(this.border||!this.contentDOM||!this.children.length)return!1;let child=this.children[side<0?0:this.children.length-1];return 0==child.size||child.emptyChildAt(side)}domAfterPos(pos){let{node:node,offset:offset}=this.domFromPos(pos,0);if(1!=node.nodeType||offset==node.childNodes.length)throw new RangeError("No node after pos "+pos);return node.childNodes[offset]}
// View descs are responsible for setting any selection that falls
// entirely inside of them, so that custom implementations can do
// custom things with the selection. Note that this falls apart when
// a selection starts in such a node and ends in another, in which
// case we just use whatever domFromPos produces as a best effort.
setSelection(anchor,head,root,force=!1){
// If the selection falls entirely in a child, give it to that child
let from=Math.min(anchor,head),to=Math.max(anchor,head);for(let i=0,offset=0;i<this.children.length;i++){let child=this.children[i],end=offset+child.size;if(from>offset&&to<end)return child.setSelection(anchor-offset-child.border,head-offset-child.border,root,force);offset=end}let anchorDOM=this.domFromPos(anchor,anchor?-1:1),headDOM=head==anchor?anchorDOM:this.domFromPos(head,head?-1:1),domSel=root.getSelection(),brKludge=!1;
// On Firefox, using Selection.collapse to put the cursor after a
// BR node for some reason doesn't always work (#1073). On Safari,
// the cursor sometimes inexplicable visually lags behind its
// reported position in such situations (#1092).
if((gecko||safari)&&anchor==head){let{node:node,offset:offset}=anchorDOM;if(3==node.nodeType){
// Issue #1128
if(brKludge=!(!offset||"\n"!=node.nodeValue[offset-1]),brKludge&&offset==node.nodeValue.length)for(let after,scan=node;scan;scan=scan.parentNode){if(after=scan.nextSibling){"BR"==after.nodeName&&(anchorDOM=headDOM={node:after.parentNode,offset:domIndex(after)+1});break}let desc=scan.pmViewDesc;if(desc&&desc.node&&desc.node.isBlock)break}}else{let prev=node.childNodes[offset-1];brKludge=prev&&("BR"==prev.nodeName||"false"==prev.contentEditable)}}
// Firefox can act strangely when the selection is in front of an
// uneditable node. See #1163 and https://bugzilla.mozilla.org/show_bug.cgi?id=1709536
if(gecko&&domSel.focusNode&&domSel.focusNode!=headDOM.node&&1==domSel.focusNode.nodeType){let after=domSel.focusNode.childNodes[domSel.focusOffset];after&&"false"==after.contentEditable&&(force=!0)}if(!(force||brKludge&&safari)&&isEquivalentPosition(anchorDOM.node,anchorDOM.offset,domSel.anchorNode,domSel.anchorOffset)&&isEquivalentPosition(headDOM.node,headDOM.offset,domSel.focusNode,domSel.focusOffset))return;
// Selection.extend can be used to create an 'inverted' selection
// (one where the focus is before the anchor), but not all
// browsers support it yet.
let domSelExtended=!1;if((domSel.extend||anchor==head)&&!brKludge){domSel.collapse(anchorDOM.node,anchorDOM.offset);try{anchor!=head&&domSel.extend(headDOM.node,headDOM.offset),domSelExtended=!0}catch(_){
// In some cases with Chrome the selection is empty after calling
// collapse, even when it should be valid. This appears to be a bug, but
// it is difficult to isolate. If this happens fallback to the old path
// without using extend.
// Similarly, this could crash on Safari if the editor is hidden, and
// there was no selection.
}}if(!domSelExtended){if(anchor>head){let tmp=anchorDOM;anchorDOM=headDOM,headDOM=tmp}let range=document.createRange();range.setEnd(headDOM.node,headDOM.offset),range.setStart(anchorDOM.node,anchorDOM.offset),domSel.removeAllRanges(),domSel.addRange(range)}}ignoreMutation(mutation){return!this.contentDOM&&"selection"!=mutation.type}get contentLost(){return this.contentDOM&&this.contentDOM!=this.dom&&!this.dom.contains(this.contentDOM)}
// Remove a subtree of the element tree that has been touched
// by a DOM change, so that the next update will redraw it.
markDirty(from,to){for(let offset=0,i=0;i<this.children.length;i++){let child=this.children[i],end=offset+child.size;if(offset==end?from<=end&&to>=offset:from<end&&to>offset){let startInside=offset+child.border,endInside=end-child.border;if(from>=startInside&&to<=endInside)return this.dirty=from==offset||to==end?CONTENT_DIRTY:CHILD_DIRTY,void(from!=startInside||to!=endInside||!child.contentLost&&child.dom.parentNode==this.contentDOM?child.markDirty(from-startInside,to-startInside):child.dirty=NODE_DIRTY);child.dirty=child.dom!=child.contentDOM||child.dom.parentNode!=this.contentDOM||child.children.length?NODE_DIRTY:CONTENT_DIRTY}offset=end}this.dirty=CONTENT_DIRTY}markParentsDirty(){let level=1;for(let node=this.parent;node;node=node.parent,level++){let dirty=1==level?CONTENT_DIRTY:CHILD_DIRTY;node.dirty<dirty&&(node.dirty=dirty)}}get domAtom(){return!1}get ignoreForCoords(){return!1}}
// A widget desc represents a widget decoration, which is a DOM node
// drawn between the document nodes.
class WidgetViewDesc extends ViewDesc{constructor(parent,widget,view,pos){let self,dom=widget.type.toDOM;if("function"==typeof dom&&(dom=dom(view,(()=>self?self.parent?self.parent.posBeforeChild(self):void 0:pos))),!widget.type.spec.raw){if(1!=dom.nodeType){let wrap=document.createElement("span");wrap.appendChild(dom),dom=wrap}dom.contentEditable="false",dom.classList.add("ProseMirror-widget")}super(parent,[],dom,null),this.widget=widget,this.widget=widget,self=this}matchesWidget(widget){return this.dirty==NOT_DIRTY&&widget.type.eq(this.widget.type)}parseRule(){return{ignore:!0}}stopEvent(event){let stop=this.widget.spec.stopEvent;return!!stop&&stop(event)}ignoreMutation(mutation){return"selection"!=mutation.type||this.widget.spec.ignoreSelection}destroy(){this.widget.type.destroy(this.dom),super.destroy()}get domAtom(){return!0}get side(){return this.widget.type.side}}class CompositionViewDesc extends ViewDesc{constructor(parent,dom,textDOM,text){super(parent,[],dom,null),this.textDOM=textDOM,this.text=text}get size(){return this.text.length}localPosFromDOM(dom,offset){return dom!=this.textDOM?this.posAtStart+(offset?this.size:0):this.posAtStart+offset}domFromPos(pos){return{node:this.textDOM,offset:pos}}ignoreMutation(mut){return"characterData"===mut.type&&mut.target.nodeValue==mut.oldValue}}
// A mark desc represents a mark. May have multiple children,
// depending on how the mark is split. Note that marks are drawn using
// a fixed nesting order, for simplicity and predictability, so in
// some cases they will be split more often than would appear
// necessary.
class MarkViewDesc extends ViewDesc{constructor(parent,mark,dom,contentDOM){super(parent,[],dom,contentDOM),this.mark=mark}static create(parent,mark,inline,view){let custom=view.nodeViews[mark.type.name],spec=custom&&custom(mark,view,inline);return spec&&spec.dom||(spec=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .DOMSerializer */.PW.renderSpec(document,mark.type.spec.toDOM(mark,inline))),new MarkViewDesc(parent,mark,spec.dom,spec.contentDOM||spec.dom)}parseRule(){return this.dirty&NODE_DIRTY||this.mark.type.spec.reparseInView?null:{mark:this.mark.type.name,attrs:this.mark.attrs,contentElement:this.contentDOM}}matchesMark(mark){return this.dirty!=NODE_DIRTY&&this.mark.eq(mark)}markDirty(from,to){
// Move dirty info to nearest node view
if(super.markDirty(from,to),this.dirty!=NOT_DIRTY){let parent=this.parent;while(!parent.node)parent=parent.parent;parent.dirty<this.dirty&&(parent.dirty=this.dirty),this.dirty=NOT_DIRTY}}slice(from,to,view){let copy=MarkViewDesc.create(this.parent,this.mark,!0,view),nodes=this.children,size=this.size;to<size&&(nodes=replaceNodes(nodes,to,size,view)),from>0&&(nodes=replaceNodes(nodes,0,from,view));for(let i=0;i<nodes.length;i++)nodes[i].parent=copy;return copy.children=nodes,copy}}
// Node view descs are the main, most common type of view desc, and
// correspond to an actual node in the document. Unlike mark descs,
// they populate their child array themselves.
class NodeViewDesc extends ViewDesc{constructor(parent,node,outerDeco,innerDeco,dom,contentDOM,nodeDOM,view,pos){super(parent,[],dom,contentDOM),this.node=node,this.outerDeco=outerDeco,this.innerDeco=innerDeco,this.nodeDOM=nodeDOM}
// By default, a node is rendered using the `toDOM` method from the
// node type spec. But client code can use the `nodeViews` spec to
// supply a custom node view, which can influence various aspects of
// the way the node works.
// (Using subclassing for this was intentionally decided against,
// since it'd require exposing a whole slew of finicky
// implementation details to the user code that they probably will
// never need.)
static create(parent,node,outerDeco,innerDeco,view,pos){let descObj,custom=view.nodeViews[node.type.name],spec=custom&&custom(node,view,(()=>
// (This is a function that allows the custom view to find its
// own position)
descObj?descObj.parent?descObj.parent.posBeforeChild(descObj):void 0:pos),outerDeco,innerDeco),dom=spec&&spec.dom,contentDOM=spec&&spec.contentDOM;if(node.isText)if(dom){if(3!=dom.nodeType)throw new RangeError("Text must be rendered as a DOM text node")}else dom=document.createTextNode(node.text);else dom||({dom:dom,contentDOM:contentDOM}=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .DOMSerializer */.PW.renderSpec(document,node.type.spec.toDOM(node)));contentDOM||node.isText||"BR"==dom.nodeName||(// Chrome gets confused by <br contenteditable=false>
dom.hasAttribute("contenteditable")||(dom.contentEditable="false"),node.type.spec.draggable&&(dom.draggable=!0));let nodeDOM=dom;return dom=applyOuterDeco(dom,outerDeco,node),spec?descObj=new CustomNodeViewDesc(parent,node,outerDeco,innerDeco,dom,contentDOM||null,nodeDOM,spec,view,pos+1):node.isText?new TextViewDesc(parent,node,outerDeco,innerDeco,dom,nodeDOM,view):new NodeViewDesc(parent,node,outerDeco,innerDeco,dom,contentDOM||null,nodeDOM,view,pos+1)}parseRule(){
// Experimental kludge to allow opt-in re-parsing of nodes
if(this.node.type.spec.reparseInView)return null;
// FIXME the assumption that this can always return the current
// attrs means that if the user somehow manages to change the
// attrs in the dom, that won't be picked up. Not entirely sure
// whether this is a problem
let rule={node:this.node.type.name,attrs:this.node.attrs};if("pre"==this.node.type.whitespace&&(rule.preserveWhitespace="full"),this.contentDOM)if(this.contentLost){
// Chrome likes to randomly recreate parent nodes when
// backspacing things. When that happens, this tries to find the
// new parent.
for(let i=this.children.length-1;i>=0;i--){let child=this.children[i];if(this.dom.contains(child.dom.parentNode)){rule.contentElement=child.dom.parentNode;break}}rule.contentElement||(rule.getContent=()=>prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty)}else rule.contentElement=this.contentDOM;else rule.getContent=()=>this.node.content;return rule}matchesNode(node,outerDeco,innerDeco){return this.dirty==NOT_DIRTY&&node.eq(this.node)&&sameOuterDeco(outerDeco,this.outerDeco)&&innerDeco.eq(this.innerDeco)}get size(){return this.node.nodeSize}get border(){return this.node.isLeaf?0:1}
// Syncs `this.children` to match `this.node.content` and the local
// decorations, possibly introducing nesting for marks. Then, in a
// separate step, syncs the DOM inside `this.contentDOM` to
// `this.children`.
updateChildren(view,pos){let inline=this.node.inlineContent,off=pos,composition=view.composing?this.localCompositionInfo(view,pos):null,localComposition=composition&&composition.pos>-1?composition:null,compositionInChild=composition&&composition.pos<0,updater=new ViewTreeUpdater(this,localComposition&&localComposition.node,view);iterDeco(this.node,this.innerDeco,((widget,i,insideNode)=>{widget.spec.marks?updater.syncToMarks(widget.spec.marks,inline,view):widget.type.side>=0&&!insideNode&&updater.syncToMarks(i==this.node.childCount?prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Mark */.vc.none:this.node.child(i).marks,inline,view),
// If the next node is a desc matching this widget, reuse it,
// otherwise insert the widget as a new view desc.
updater.placeWidget(widget,view,off)}),((child,outerDeco,innerDeco,i)=>{
// Try several strategies for drawing this node
let compIndex;
// Make sure the wrapping mark descs match the node's marks.
updater.syncToMarks(child.marks,inline,view),updater.findNodeMatch(child,outerDeco,innerDeco,i)||compositionInChild&&view.state.selection.from>off&&view.state.selection.to<off+child.nodeSize&&(compIndex=updater.findIndexWithChild(composition.node))>-1&&updater.updateNodeAt(child,outerDeco,innerDeco,compIndex,view)||updater.updateNextNode(child,outerDeco,innerDeco,view,i,off)||
// Add it as a new view
updater.addNode(child,outerDeco,innerDeco,view,off),off+=child.nodeSize})),
// Drop all remaining descs after the current position.
updater.syncToMarks([],inline,view),this.node.isTextblock&&updater.addTextblockHacks(),updater.destroyRest(),
// Sync the DOM if anything changed
(updater.changed||this.dirty==CONTENT_DIRTY)&&(
// May have to protect focused DOM from being changed if a composition is active
localComposition&&this.protectLocalComposition(view,localComposition),renderDescs(this.contentDOM,this.children,view),ios&&iosHacks(this.dom))}localCompositionInfo(view,pos){
// Only do something if both the selection and a focused text node
// are inside of this node
let{from:from,to:to}=view.state.selection;if(!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .TextSelection */.Bs)||from<pos||to>pos+this.node.content.size)return null;let sel=view.domSelectionRange(),textNode=nearbyTextNode(sel.focusNode,sel.focusOffset);if(!textNode||!this.dom.contains(textNode.parentNode))return null;if(this.node.inlineContent){
// Find the text in the focused node in the node, stop if it's not
// there (may have been modified through other means, in which
// case it should overwritten)
let text=textNode.nodeValue,textPos=findTextInFragment(this.node.content,text,from-pos,to-pos);return textPos<0?null:{node:textNode,pos:textPos,text:text}}return{node:textNode,pos:-1,text:""}}protectLocalComposition(view,{node:node,pos:pos,text:text}){
// The node is already part of a local view desc, leave it there
if(this.getDesc(node))return;
// Create a composition view for the orphaned nodes
let topNode=node;for(;;topNode=topNode.parentNode){if(topNode.parentNode==this.contentDOM)break;while(topNode.previousSibling)topNode.parentNode.removeChild(topNode.previousSibling);while(topNode.nextSibling)topNode.parentNode.removeChild(topNode.nextSibling);topNode.pmViewDesc&&(topNode.pmViewDesc=void 0)}let desc=new CompositionViewDesc(this,topNode,node,text);view.input.compositionNodes.push(desc),
// Patch up this.children to contain the composition view
this.children=replaceNodes(this.children,pos,pos+text.length,view,desc)}
// If this desc must be updated to match the given node decoration,
// do so and return true.
update(node,outerDeco,innerDeco,view){return!(this.dirty==NODE_DIRTY||!node.sameMarkup(this.node))&&(this.updateInner(node,outerDeco,innerDeco,view),!0)}updateInner(node,outerDeco,innerDeco,view){this.updateOuterDeco(outerDeco),this.node=node,this.innerDeco=innerDeco,this.contentDOM&&this.updateChildren(view,this.posAtStart),this.dirty=NOT_DIRTY}updateOuterDeco(outerDeco){if(sameOuterDeco(outerDeco,this.outerDeco))return;let needsWrap=1!=this.nodeDOM.nodeType,oldDOM=this.dom;this.dom=patchOuterDeco(this.dom,this.nodeDOM,computeOuterDeco(this.outerDeco,this.node,needsWrap),computeOuterDeco(outerDeco,this.node,needsWrap)),this.dom!=oldDOM&&(oldDOM.pmViewDesc=void 0,this.dom.pmViewDesc=this),this.outerDeco=outerDeco}
// Mark this node as being the selected node.
selectNode(){1==this.nodeDOM.nodeType&&this.nodeDOM.classList.add("ProseMirror-selectednode"),!this.contentDOM&&this.node.type.spec.draggable||(this.dom.draggable=!0)}
// Remove selected node marking from this node.
deselectNode(){1==this.nodeDOM.nodeType&&this.nodeDOM.classList.remove("ProseMirror-selectednode"),!this.contentDOM&&this.node.type.spec.draggable||this.dom.removeAttribute("draggable")}get domAtom(){return this.node.isAtom}}
// Create a view desc for the top-level document node, to be exported
// and used by the view class.
function docViewDesc(doc,outerDeco,innerDeco,dom,view){applyOuterDeco(dom,outerDeco,doc);let docView=new NodeViewDesc(void 0,doc,outerDeco,innerDeco,dom,dom,dom,view,0);return docView.contentDOM&&docView.updateChildren(view,0),docView}class TextViewDesc extends NodeViewDesc{constructor(parent,node,outerDeco,innerDeco,dom,nodeDOM,view){super(parent,node,outerDeco,innerDeco,dom,null,nodeDOM,view,0)}parseRule(){let skip=this.nodeDOM.parentNode;while(skip&&skip!=this.dom&&!skip.pmIsDeco)skip=skip.parentNode;return{skip:skip||!0}}update(node,outerDeco,innerDeco,view){return!(this.dirty==NODE_DIRTY||this.dirty!=NOT_DIRTY&&!this.inParent()||!node.sameMarkup(this.node))&&(this.updateOuterDeco(outerDeco),this.dirty==NOT_DIRTY&&node.text==this.node.text||node.text==this.nodeDOM.nodeValue||(this.nodeDOM.nodeValue=node.text,view.trackWrites==this.nodeDOM&&(view.trackWrites=null)),this.node=node,this.dirty=NOT_DIRTY,!0)}inParent(){let parentDOM=this.parent.contentDOM;for(let n=this.nodeDOM;n;n=n.parentNode)if(n==parentDOM)return!0;return!1}domFromPos(pos){return{node:this.nodeDOM,offset:pos}}localPosFromDOM(dom,offset,bias){return dom==this.nodeDOM?this.posAtStart+Math.min(offset,this.node.text.length):super.localPosFromDOM(dom,offset,bias)}ignoreMutation(mutation){return"characterData"!=mutation.type&&"selection"!=mutation.type}slice(from,to,view){let node=this.node.cut(from,to),dom=document.createTextNode(node.text);return new TextViewDesc(this.parent,node,this.outerDeco,this.innerDeco,dom,dom,view)}markDirty(from,to){super.markDirty(from,to),this.dom==this.nodeDOM||0!=from&&to!=this.nodeDOM.nodeValue.length||(this.dirty=NODE_DIRTY)}get domAtom(){return!1}}
// A dummy desc used to tag trailing BR or IMG nodes created to work
// around contentEditable terribleness.
class TrailingHackViewDesc extends ViewDesc{parseRule(){return{ignore:!0}}matchesHack(nodeName){return this.dirty==NOT_DIRTY&&this.dom.nodeName==nodeName}get domAtom(){return!0}get ignoreForCoords(){return"IMG"==this.dom.nodeName}}
// A separate subclass is used for customized node views, so that the
// extra checks only have to be made for nodes that are actually
// customized.
class CustomNodeViewDesc extends NodeViewDesc{constructor(parent,node,outerDeco,innerDeco,dom,contentDOM,nodeDOM,spec,view,pos){super(parent,node,outerDeco,innerDeco,dom,contentDOM,nodeDOM,view,pos),this.spec=spec}
// A custom `update` method gets to decide whether the update goes
// through. If it does, and there's a `contentDOM` node, our logic
// updates the children.
update(node,outerDeco,innerDeco,view){if(this.dirty==NODE_DIRTY)return!1;if(this.spec.update){let result=this.spec.update(node,outerDeco,innerDeco);return result&&this.updateInner(node,outerDeco,innerDeco,view),result}return!(!this.contentDOM&&!node.isLeaf)&&super.update(node,outerDeco,innerDeco,view)}selectNode(){this.spec.selectNode?this.spec.selectNode():super.selectNode()}deselectNode(){this.spec.deselectNode?this.spec.deselectNode():super.deselectNode()}setSelection(anchor,head,root,force){this.spec.setSelection?this.spec.setSelection(anchor,head,root):super.setSelection(anchor,head,root,force)}destroy(){this.spec.destroy&&this.spec.destroy(),super.destroy()}stopEvent(event){return!!this.spec.stopEvent&&this.spec.stopEvent(event)}ignoreMutation(mutation){return this.spec.ignoreMutation?this.spec.ignoreMutation(mutation):super.ignoreMutation(mutation)}}
// Sync the content of the given DOM node with the nodes associated
// with the given array of view descs, recursing into mark descs
// because this should sync the subtree for a whole node at a time.
function renderDescs(parentDOM,descs,view){let dom=parentDOM.firstChild,written=!1;for(let i=0;i<descs.length;i++){let desc=descs[i],childDOM=desc.dom;if(childDOM.parentNode==parentDOM){while(childDOM!=dom)dom=rm(dom),written=!0;dom=dom.nextSibling}else written=!0,parentDOM.insertBefore(childDOM,dom);if(desc instanceof MarkViewDesc){let pos=dom?dom.previousSibling:parentDOM.lastChild;renderDescs(desc.contentDOM,desc.children,view),dom=pos?pos.nextSibling:parentDOM.firstChild}}while(dom)dom=rm(dom),written=!0;written&&view.trackWrites==parentDOM&&(view.trackWrites=null)}const OuterDecoLevel=function(nodeName){nodeName&&(this.nodeName=nodeName)};OuterDecoLevel.prototype=Object.create(null);const noDeco=[new OuterDecoLevel];function computeOuterDeco(outerDeco,node,needsWrap){if(0==outerDeco.length)return noDeco;let top=needsWrap?noDeco[0]:new OuterDecoLevel,result=[top];for(let i=0;i<outerDeco.length;i++){let attrs=outerDeco[i].type.attrs;if(attrs){attrs.nodeName&&result.push(top=new OuterDecoLevel(attrs.nodeName));for(let name in attrs){let val=attrs[name];null!=val&&(needsWrap&&1==result.length&&result.push(top=new OuterDecoLevel(node.isInline?"span":"div")),"class"==name?top.class=(top.class?top.class+" ":"")+val:"style"==name?top.style=(top.style?top.style+";":"")+val:"nodeName"!=name&&(top[name]=val))}}}return result}function patchOuterDeco(outerDOM,nodeDOM,prevComputed,curComputed){
// Shortcut for trivial case
if(prevComputed==noDeco&&curComputed==noDeco)return nodeDOM;let curDOM=nodeDOM;for(let i=0;i<curComputed.length;i++){let deco=curComputed[i],prev=prevComputed[i];if(i){let parent;prev&&prev.nodeName==deco.nodeName&&curDOM!=outerDOM&&(parent=curDOM.parentNode)&&parent.nodeName.toLowerCase()==deco.nodeName||(parent=document.createElement(deco.nodeName),parent.pmIsDeco=!0,parent.appendChild(curDOM),prev=noDeco[0]),curDOM=parent}patchAttributes(curDOM,prev||noDeco[0],deco)}return curDOM}function patchAttributes(dom,prev,cur){for(let name in prev)"class"==name||"style"==name||"nodeName"==name||name in cur||dom.removeAttribute(name);for(let name in cur)"class"!=name&&"style"!=name&&"nodeName"!=name&&cur[name]!=prev[name]&&dom.setAttribute(name,cur[name]);if(prev.class!=cur.class){let prevList=prev.class?prev.class.split(" ").filter(Boolean):[],curList=cur.class?cur.class.split(" ").filter(Boolean):[];for(let i=0;i<prevList.length;i++)-1==curList.indexOf(prevList[i])&&dom.classList.remove(prevList[i]);for(let i=0;i<curList.length;i++)-1==prevList.indexOf(curList[i])&&dom.classList.add(curList[i]);0==dom.classList.length&&dom.removeAttribute("class")}if(prev.style!=cur.style){if(prev.style){let m,prop=/\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g;while(m=prop.exec(prev.style))dom.style.removeProperty(m[1])}cur.style&&(dom.style.cssText+=cur.style)}}function applyOuterDeco(dom,deco,node){return patchOuterDeco(dom,dom,noDeco,computeOuterDeco(deco,node,1!=dom.nodeType))}function sameOuterDeco(a,b){if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(!a[i].type.eq(b[i].type))return!1;return!0}
// Remove a DOM node and return its next sibling.
function rm(dom){let next=dom.nextSibling;return dom.parentNode.removeChild(dom),next}
// Helper class for incrementally updating a tree of mark descs and
// the widget and node descs inside of them.
class ViewTreeUpdater{constructor(top,lock,view){this.lock=lock,this.view=view,
// Index into `this.top`'s child array, represents the current
// update position.
this.index=0,
// When entering a mark, the current top and index are pushed
// onto this.
this.stack=[],
// Tracks whether anything was changed
this.changed=!1,this.top=top,this.preMatch=preMatch(top.node.content,top)}
// Destroy and remove the children between the given indices in
// `this.top`.
destroyBetween(start,end){if(start!=end){for(let i=start;i<end;i++)this.top.children[i].destroy();this.top.children.splice(start,end-start),this.changed=!0}}
// Destroy all remaining children in `this.top`.
destroyRest(){this.destroyBetween(this.index,this.top.children.length)}
// Sync the current stack of mark descs with the given array of
// marks, reusing existing mark descs when possible.
syncToMarks(marks,inline,view){let keep=0,depth=this.stack.length>>1,maxKeep=Math.min(depth,marks.length);while(keep<maxKeep&&(keep==depth-1?this.top:this.stack[keep+1<<1]).matchesMark(marks[keep])&&!1!==marks[keep].type.spec.spanning)keep++;while(keep<depth)this.destroyRest(),this.top.dirty=NOT_DIRTY,this.index=this.stack.pop(),this.top=this.stack.pop(),depth--;while(depth<marks.length){this.stack.push(this.top,this.index+1);let found=-1;for(let i=this.index;i<Math.min(this.index+3,this.top.children.length);i++){let next=this.top.children[i];if(next.matchesMark(marks[depth])&&!this.isLocked(next.dom)){found=i;break}}if(found>-1)found>this.index&&(this.changed=!0,this.destroyBetween(this.index,found)),this.top=this.top.children[this.index];else{let markDesc=MarkViewDesc.create(this.top,marks[depth],inline,view);this.top.children.splice(this.index,0,markDesc),this.top=markDesc,this.changed=!0}this.index=0,depth++}}
// Try to find a node desc matching the given data. Skip over it and
// return true when successful.
findNodeMatch(node,outerDeco,innerDeco,index){let targetDesc,found=-1;if(index>=this.preMatch.index&&(targetDesc=this.preMatch.matches[index-this.preMatch.index]).parent==this.top&&targetDesc.matchesNode(node,outerDeco,innerDeco))found=this.top.children.indexOf(targetDesc,this.index);else for(let i=this.index,e=Math.min(this.top.children.length,i+5);i<e;i++){let child=this.top.children[i];if(child.matchesNode(node,outerDeco,innerDeco)&&!this.preMatch.matched.has(child)){found=i;break}}return!(found<0)&&(this.destroyBetween(this.index,found),this.index++,!0)}updateNodeAt(node,outerDeco,innerDeco,index,view){let child=this.top.children[index];return child.dirty==NODE_DIRTY&&child.dom==child.contentDOM&&(child.dirty=CONTENT_DIRTY),!!child.update(node,outerDeco,innerDeco,view)&&(this.destroyBetween(this.index,index),this.index++,!0)}findIndexWithChild(domNode){for(;;){let parent=domNode.parentNode;if(!parent)return-1;if(parent==this.top.contentDOM){let desc=domNode.pmViewDesc;if(desc)for(let i=this.index;i<this.top.children.length;i++)if(this.top.children[i]==desc)return i;return-1}domNode=parent}}
// Try to update the next node, if any, to the given data. Checks
// pre-matches to avoid overwriting nodes that could still be used.
updateNextNode(node,outerDeco,innerDeco,view,index,pos){for(let i=this.index;i<this.top.children.length;i++){let next=this.top.children[i];if(next instanceof NodeViewDesc){let preMatch=this.preMatch.matched.get(next);if(null!=preMatch&&preMatch!=index)return!1;let updated,nextDOM=next.dom,locked=this.isLocked(nextDOM)&&!(node.isText&&next.node&&next.node.isText&&next.nodeDOM.nodeValue==node.text&&next.dirty!=NODE_DIRTY&&sameOuterDeco(outerDeco,next.outerDeco));
// Can't update if nextDOM is or contains this.lock, except if
// it's a text node whose content already matches the new text
// and whose decorations match the new ones.
if(!locked&&next.update(node,outerDeco,innerDeco,view))return this.destroyBetween(this.index,i),next.dom!=nextDOM&&(this.changed=!0),this.index++,!0;if(!locked&&(updated=this.recreateWrapper(next,node,outerDeco,innerDeco,view,pos)))return this.top.children[this.index]=updated,updated.contentDOM&&(updated.dirty=CONTENT_DIRTY,updated.updateChildren(view,pos+1),updated.dirty=NOT_DIRTY),this.changed=!0,this.index++,!0;break}}return!1}
// When a node with content is replaced by a different node with
// identical content, move over its children.
recreateWrapper(next,node,outerDeco,innerDeco,view,pos){if(next.dirty||node.isAtom||!next.children.length||!next.node.content.eq(node.content))return null;let wrapper=NodeViewDesc.create(this.top,node,outerDeco,innerDeco,view,pos);if(wrapper.contentDOM){wrapper.children=next.children,next.children=[];for(let ch of wrapper.children)ch.parent=wrapper}return next.destroy(),wrapper}
// Insert the node as a newly created node desc.
addNode(node,outerDeco,innerDeco,view,pos){let desc=NodeViewDesc.create(this.top,node,outerDeco,innerDeco,view,pos);desc.contentDOM&&desc.updateChildren(view,pos+1),this.top.children.splice(this.index++,0,desc),this.changed=!0}placeWidget(widget,view,pos){let next=this.index<this.top.children.length?this.top.children[this.index]:null;if(!next||!next.matchesWidget(widget)||widget!=next.widget&&next.widget.type.toDOM.parentNode){let desc=new WidgetViewDesc(this.top,widget,view,pos);this.top.children.splice(this.index++,0,desc),this.changed=!0}else this.index++}
// Make sure a textblock looks and behaves correctly in
// contentEditable.
addTextblockHacks(){let lastChild=this.top.children[this.index-1],parent=this.top;while(lastChild instanceof MarkViewDesc)parent=lastChild,lastChild=parent.children[parent.children.length-1];(!lastChild||// Empty textblock
!(lastChild instanceof TextViewDesc)||/\n$/.test(lastChild.node.text)||this.view.requiresGeckoHackNode&&/\s$/.test(lastChild.node.text))&&(
// Avoid bugs in Safari's cursor drawing (#1165) and Chrome's mouse selection (#1152)
(safari||chrome)&&lastChild&&"false"==lastChild.dom.contentEditable&&this.addHackNode("IMG",parent),this.addHackNode("BR",this.top))}addHackNode(nodeName,parent){if(parent==this.top&&this.index<parent.children.length&&parent.children[this.index].matchesHack(nodeName))this.index++;else{let dom=document.createElement(nodeName);"IMG"==nodeName&&(dom.className="ProseMirror-separator",dom.alt=""),"BR"==nodeName&&(dom.className="ProseMirror-trailingBreak");let hack=new TrailingHackViewDesc(this.top,[],dom,null);parent!=this.top?parent.children.push(hack):parent.children.splice(this.index++,0,hack),this.changed=!0}}isLocked(node){return this.lock&&(node==this.lock||1==node.nodeType&&node.contains(this.lock.parentNode))}}
// Iterate from the end of the fragment and array of descs to find
// directly matching ones, in order to avoid overeagerly reusing those
// for other nodes. Returns the fragment index of the first node that
// is part of the sequence of matched nodes at the end of the
// fragment.
function preMatch(frag,parentDesc){let curDesc=parentDesc,descI=curDesc.children.length,fI=frag.childCount,matched=new Map,matches=[];outer:while(fI>0){let desc;for(;;)if(descI){let next=curDesc.children[descI-1];if(!(next instanceof MarkViewDesc)){desc=next,descI--;break}curDesc=next,descI=next.children.length}else{if(curDesc==parentDesc)break outer;
// FIXME
descI=curDesc.parent.children.indexOf(curDesc),curDesc=curDesc.parent}let node=desc.node;if(node){if(node!=frag.child(fI-1))break;--fI,matched.set(desc,fI),matches.push(desc)}}return{index:fI,matched:matched,matches:matches.reverse()}}function compareSide(a,b){return a.type.side-b.type.side}
// This function abstracts iterating over the nodes and decorations in
// a fragment. Calls `onNode` for each node, with its local and child
// decorations. Splits text nodes when there is a decoration starting
// or ending inside of them. Calls `onWidget` for each widget.
function iterDeco(parent,deco,onWidget,onNode){let locals=deco.locals(parent),offset=0;
// Simple, cheap variant for when there are no local decorations
if(0==locals.length){for(let i=0;i<parent.childCount;i++){let child=parent.child(i);onNode(child,locals,deco.forChild(offset,child),i),offset+=child.nodeSize}return}let decoIndex=0,active=[],restNode=null;for(let parentIndex=0;;){let widget,widgets,child,index;while(decoIndex<locals.length&&locals[decoIndex].to==offset){let next=locals[decoIndex++];next.widget&&(widget?(widgets||(widgets=[widget])).push(next):widget=next)}if(widget)if(widgets){widgets.sort(compareSide);for(let i=0;i<widgets.length;i++)onWidget(widgets[i],parentIndex,!!restNode)}else onWidget(widget,parentIndex,!!restNode);if(restNode)index=-1,child=restNode,restNode=null;else{if(!(parentIndex<parent.childCount))break;index=parentIndex,child=parent.child(parentIndex++)}for(let i=0;i<active.length;i++)active[i].to<=offset&&active.splice(i--,1);while(decoIndex<locals.length&&locals[decoIndex].from<=offset&&locals[decoIndex].to>offset)active.push(locals[decoIndex++]);let end=offset+child.nodeSize;if(child.isText){let cutAt=end;decoIndex<locals.length&&locals[decoIndex].from<cutAt&&(cutAt=locals[decoIndex].from);for(let i=0;i<active.length;i++)active[i].to<cutAt&&(cutAt=active[i].to);cutAt<end&&(restNode=child.cut(cutAt-offset),child=child.cut(0,cutAt-offset),end=cutAt,index=-1)}let outerDeco=child.isInline&&!child.isLeaf?active.filter((d=>!d.inline)):active.slice();onNode(child,outerDeco,deco.forChild(offset,child),index),offset=end}}
// List markers in Mobile Safari will mysteriously disappear
// sometimes. This works around that.
function iosHacks(dom){if("UL"==dom.nodeName||"OL"==dom.nodeName){let oldCSS=dom.style.cssText;dom.style.cssText=oldCSS+"; list-style: square !important",window.getComputedStyle(dom).listStyle,dom.style.cssText=oldCSS}}function nearbyTextNode(node,offset){for(;;){if(3==node.nodeType)return node;if(1==node.nodeType&&offset>0){if(node.childNodes.length>offset&&3==node.childNodes[offset].nodeType)return node.childNodes[offset];node=node.childNodes[offset-1],offset=nodeSize(node)}else{if(!(1==node.nodeType&&offset<node.childNodes.length))return null;node=node.childNodes[offset],offset=0}}}
// Find a piece of text in an inline fragment, overlapping from-to
function findTextInFragment(frag,text,from,to){for(let i=0,pos=0;i<frag.childCount&&pos<=to;){let child=frag.child(i++),childStart=pos;if(pos+=child.nodeSize,!child.isText)continue;let str=child.text;while(i<frag.childCount){let next=frag.child(i++);if(pos+=next.nodeSize,!next.isText)break;str+=next.text}if(pos>=from){if(pos>=to&&str.slice(to-text.length-childStart,to-childStart)==text)return to-text.length;let found=childStart<to?str.lastIndexOf(text,to-childStart-1):-1;if(found>=0&&found+text.length+childStart>=from)return childStart+found;if(from==to&&str.length>=to+text.length-childStart&&str.slice(to-childStart,to-childStart+text.length)==text)return to}}return-1}
// Replace range from-to in an array of view descs with replacement
// (may be null to just delete). This goes very much against the grain
// of the rest of this code, which tends to create nodes with the
// right shape in one go, rather than messing with them after
// creation, but is necessary in the composition hack.
function replaceNodes(nodes,from,to,view,replacement){let result=[];for(let i=0,off=0;i<nodes.length;i++){let child=nodes[i],start=off,end=off+=child.size;start>=to||end<=from?result.push(child):(start<from&&result.push(child.slice(0,from-start,view)),replacement&&(result.push(replacement),replacement=void 0),end>to&&result.push(child.slice(to-start,child.size,view)))}return result}function selectionFromDOM(view,origin=null){let domSel=view.domSelectionRange(),doc=view.state.doc;if(!domSel.focusNode)return null;let nearestDesc=view.docView.nearestDesc(domSel.focusNode),inWidget=nearestDesc&&0==nearestDesc.size,head=view.docView.posFromDOM(domSel.focusNode,domSel.focusOffset,1);if(head<0)return null;let $anchor,selection,$head=doc.resolve(head);if(selectionCollapsed(domSel)){$anchor=$head;while(nearestDesc&&!nearestDesc.node)nearestDesc=nearestDesc.parent;let nearestDescNode=nearestDesc.node;if(nearestDesc&&nearestDescNode.isAtom&&prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.isSelectable(nearestDescNode)&&nearestDesc.parent&&(!nearestDescNode.isInline||!isOnEdge(domSel.focusNode,domSel.focusOffset,nearestDesc.dom))){let pos=nearestDesc.posBefore;selection=new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv(head==pos?$head:doc.resolve(pos))}}else{let anchor=view.docView.posFromDOM(domSel.anchorNode,domSel.anchorOffset,1);if(anchor<0)return null;$anchor=doc.resolve(anchor)}if(!selection){let bias="pointer"==origin||view.state.selection.head<$head.pos&&!inWidget?1:-1;selection=selectionBetween(view,$anchor,$head,bias)}return selection}function editorOwnsSelection(view){return view.editable?view.hasFocus():hasSelection(view)&&document.activeElement&&document.activeElement.contains(view.dom)}function selectionToDOM(view,force=!1){let sel=view.state.selection;if(syncNodeSelection(view,sel),editorOwnsSelection(view)){
// The delayed drag selection causes issues with Cell Selections
// in Safari. And the drag selection delay is to workarond issues
// which only present in Chrome.
if(!force&&view.input.mouseDown&&view.input.mouseDown.allowDefault&&chrome){let domSel=view.domSelectionRange(),curSel=view.domObserver.currentSelection;if(domSel.anchorNode&&curSel.anchorNode&&isEquivalentPosition(domSel.anchorNode,domSel.anchorOffset,curSel.anchorNode,curSel.anchorOffset))return view.input.mouseDown.delayedSelectionSync=!0,void view.domObserver.setCurSelection()}if(view.domObserver.disconnectSelection(),view.cursorWrapper)selectCursorWrapper(view);else{let resetEditableFrom,resetEditableTo,{anchor:anchor,head:head}=sel;!brokenSelectBetweenUneditable||sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .TextSelection */.Bs||(sel.$from.parent.inlineContent||(resetEditableFrom=temporarilyEditableNear(view,sel.from)),sel.empty||sel.$from.parent.inlineContent||(resetEditableTo=temporarilyEditableNear(view,sel.to))),view.docView.setSelection(anchor,head,view.root,force),brokenSelectBetweenUneditable&&(resetEditableFrom&&resetEditable(resetEditableFrom),resetEditableTo&&resetEditable(resetEditableTo)),sel.visible?view.dom.classList.remove("ProseMirror-hideselection"):(view.dom.classList.add("ProseMirror-hideselection"),"onselectionchange"in document&&removeClassOnSelectionChange(view))}view.domObserver.setCurSelection(),view.domObserver.connectSelection()}}
// Kludge to work around Webkit not allowing a selection to start/end
// between non-editable block nodes. We briefly make something
// editable, set the selection, then set it uneditable again.
const brokenSelectBetweenUneditable=safari||chrome&&chrome_version<63;function temporarilyEditableNear(view,pos){let{node:node,offset:offset}=view.docView.domFromPos(pos,0),after=offset<node.childNodes.length?node.childNodes[offset]:null,before=offset?node.childNodes[offset-1]:null;if(safari&&after&&"false"==after.contentEditable)return setEditable(after);if((!after||"false"==after.contentEditable)&&(!before||"false"==before.contentEditable)){if(after)return setEditable(after);if(before)return setEditable(before)}}function setEditable(element){return element.contentEditable="true",safari&&element.draggable&&(element.draggable=!1,element.wasDraggable=!0),element}function resetEditable(element){element.contentEditable="false",element.wasDraggable&&(element.draggable=!0,element.wasDraggable=null)}function removeClassOnSelectionChange(view){let doc=view.dom.ownerDocument;doc.removeEventListener("selectionchange",view.input.hideSelectionGuard);let domSel=view.domSelectionRange(),node=domSel.anchorNode,offset=domSel.anchorOffset;doc.addEventListener("selectionchange",view.input.hideSelectionGuard=()=>{domSel.anchorNode==node&&domSel.anchorOffset==offset||(doc.removeEventListener("selectionchange",view.input.hideSelectionGuard),setTimeout((()=>{editorOwnsSelection(view)&&!view.state.selection.visible||view.dom.classList.remove("ProseMirror-hideselection")}),20))})}function selectCursorWrapper(view){let domSel=view.domSelection(),range=document.createRange(),node=view.cursorWrapper.dom,img="IMG"==node.nodeName;img?range.setEnd(node.parentNode,domIndex(node)+1):range.setEnd(node,0),range.collapse(!1),domSel.removeAllRanges(),domSel.addRange(range),
// Kludge to kill 'control selection' in IE11 when selecting an
// invisible cursor wrapper, since that would result in those weird
// resize handles and a selection that considers the absolutely
// positioned wrapper, rather than the root editable node, the
// focused element.
!img&&!view.state.selection.visible&&ie&&ie_version<=11&&(node.disabled=!0,node.disabled=!1)}function syncNodeSelection(view,sel){if(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv){let desc=view.docView.descAt(sel.from);desc!=view.lastSelectedViewDesc&&(clearNodeSelection(view),desc&&desc.selectNode(),view.lastSelectedViewDesc=desc)}else clearNodeSelection(view)}
// Clear all DOM statefulness of the last node selection.
function clearNodeSelection(view){view.lastSelectedViewDesc&&(view.lastSelectedViewDesc.parent&&view.lastSelectedViewDesc.deselectNode(),view.lastSelectedViewDesc=void 0)}function selectionBetween(view,$anchor,$head,bias){return view.someProp("createSelectionBetween",(f=>f(view,$anchor,$head)))||prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .TextSelection */.Bs.between($anchor,$head,bias)}function hasFocusAndSelection(view){return!(view.editable&&!view.hasFocus())&&hasSelection(view)}function hasSelection(view){let sel=view.domSelectionRange();if(!sel.anchorNode)return!1;try{
// Firefox will raise 'permission denied' errors when accessing
// properties of `sel.anchorNode` when it's in a generated CSS
// element.
return view.dom.contains(3==sel.anchorNode.nodeType?sel.anchorNode.parentNode:sel.anchorNode)&&(view.editable||view.dom.contains(3==sel.focusNode.nodeType?sel.focusNode.parentNode:sel.focusNode))}catch(_){return!1}}function anchorInRightPlace(view){let anchorDOM=view.docView.domFromPos(view.state.selection.anchor,0),domSel=view.domSelectionRange();return isEquivalentPosition(anchorDOM.node,anchorDOM.offset,domSel.anchorNode,domSel.anchorOffset)}function moveSelectionBlock(state,dir){let{$anchor:$anchor,$head:$head}=state.selection,$side=dir>0?$anchor.max($head):$anchor.min($head),$start=$side.parent.inlineContent?$side.depth?state.doc.resolve(dir>0?$side.after():$side.before()):null:$side;return $start&&prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .Selection */.Y1.findFrom($start,dir)}function apply(view,sel){return view.dispatch(view.state.tr.setSelection(sel).scrollIntoView()),!0}function selectHorizontally(view,dir,mods){let sel=view.state.selection;if(!(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .TextSelection */.Bs)){if(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv&&sel.node.isInline)return apply(view,new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .TextSelection */.Bs(dir>0?sel.$to:sel.$from));{let next=moveSelectionBlock(view.state,dir);return!!next&&apply(view,next)}}if(mods.indexOf("s")>-1){let{$head:$head}=sel,node=$head.textOffset?null:dir<0?$head.nodeBefore:$head.nodeAfter;if(!node||node.isText||!node.isLeaf)return!1;let $newHead=view.state.doc.resolve($head.pos+node.nodeSize*(dir<0?-1:1));return apply(view,new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .TextSelection */.Bs(sel.$anchor,$newHead))}if(!sel.empty)return!1;if(view.endOfTextblock(dir>0?"forward":"backward")){let next=moveSelectionBlock(view.state,dir);return!!(next&&next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv)&&apply(view,next)}if(!(mac&&mods.indexOf("m")>-1)){let desc,$head=sel.$head,node=$head.textOffset?null:dir<0?$head.nodeBefore:$head.nodeAfter;if(!node||node.isText)return!1;let nodePos=dir<0?$head.pos-node.nodeSize:$head.pos;return!!(node.isAtom||(desc=view.docView.descAt(nodePos))&&!desc.contentDOM)&&(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.isSelectable(node)?apply(view,new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv(dir<0?view.state.doc.resolve($head.pos-node.nodeSize):$head)):!!webkit&&apply(view,new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .TextSelection */.Bs(view.state.doc.resolve(dir<0?nodePos:nodePos+node.nodeSize))))}}function nodeLen(node){return 3==node.nodeType?node.nodeValue.length:node.childNodes.length}function isIgnorable(dom,dir){let desc=dom.pmViewDesc;return desc&&0==desc.size&&(dir<0||dom.nextSibling||"BR"!=dom.nodeName)}function skipIgnoredNodes(view,dir){return dir<0?skipIgnoredNodesBefore(view):skipIgnoredNodesAfter(view)}
// Make sure the cursor isn't directly after one or more ignored
// nodes, which will confuse the browser's cursor motion logic.
function skipIgnoredNodesBefore(view){let sel=view.domSelectionRange(),node=sel.focusNode,offset=sel.focusOffset;if(!node)return;let moveNode,moveOffset,force=!1;
// Gecko will do odd things when the selection is directly in front
// of a non-editable node, so in that case, move it into the next
// node if possible. Issue prosemirror/prosemirror#832.
for(gecko&&1==node.nodeType&&offset<nodeLen(node)&&isIgnorable(node.childNodes[offset],-1)&&(force=!0);;)if(offset>0){if(1!=node.nodeType)break;{let before=node.childNodes[offset-1];if(isIgnorable(before,-1))moveNode=node,moveOffset=--offset;else{if(3!=before.nodeType)break;node=before,offset=node.nodeValue.length}}}else{if(isBlockNode(node))break;{let prev=node.previousSibling;while(prev&&isIgnorable(prev,-1))moveNode=node.parentNode,moveOffset=domIndex(prev),prev=prev.previousSibling;if(prev)node=prev,offset=nodeLen(node);else{if(node=node.parentNode,node==view.dom)break;offset=0}}}force?setSelFocus(view,node,offset):moveNode&&setSelFocus(view,moveNode,moveOffset)}
// Make sure the cursor isn't directly before one or more ignored
// nodes.
function skipIgnoredNodesAfter(view){let sel=view.domSelectionRange(),node=sel.focusNode,offset=sel.focusOffset;if(!node)return;let moveNode,moveOffset,len=nodeLen(node);for(;;)if(offset<len){if(1!=node.nodeType)break;let after=node.childNodes[offset];if(!isIgnorable(after,1))break;moveNode=node,moveOffset=++offset}else{if(isBlockNode(node))break;{let next=node.nextSibling;while(next&&isIgnorable(next,1))moveNode=next.parentNode,moveOffset=domIndex(next)+1,next=next.nextSibling;if(next)node=next,offset=0,len=nodeLen(node);else{if(node=node.parentNode,node==view.dom)break;offset=len=0}}}moveNode&&setSelFocus(view,moveNode,moveOffset)}function isBlockNode(dom){let desc=dom.pmViewDesc;return desc&&desc.node&&desc.node.isBlock}function textNodeAfter(node,offset){while(node&&offset==node.childNodes.length&&!hasBlockDesc(node))offset=domIndex(node)+1,node=node.parentNode;while(node&&offset<node.childNodes.length){let next=node.childNodes[offset];if(3==next.nodeType)return next;if(1==next.nodeType&&"false"==next.contentEditable)break;node=next,offset=0}}function textNodeBefore(node,offset){while(node&&!offset&&!hasBlockDesc(node))offset=domIndex(node),node=node.parentNode;while(node&&offset){let next=node.childNodes[offset-1];if(3==next.nodeType)return next;if(1==next.nodeType&&"false"==next.contentEditable)break;node=next,offset=node.childNodes.length}}function setSelFocus(view,node,offset){if(3!=node.nodeType){let before,after;(after=textNodeAfter(node,offset))?(node=after,offset=0):(before=textNodeBefore(node,offset))&&(node=before,offset=before.nodeValue.length)}let sel=view.domSelection();if(selectionCollapsed(sel)){let range=document.createRange();range.setEnd(node,offset),range.setStart(node,offset),sel.removeAllRanges(),sel.addRange(range)}else sel.extend&&sel.extend(node,offset);view.domObserver.setCurSelection();let{state:state}=view;
// If no state update ends up happening, reset the selection.
setTimeout((()=>{view.state==state&&selectionToDOM(view)}),50)}function findDirection(view,pos){let $pos=view.state.doc.resolve(pos);if(!chrome&&!windows&&$pos.parent.inlineContent){let coords=view.coordsAtPos(pos);if(pos>$pos.start()){let before=view.coordsAtPos(pos-1),mid=(before.top+before.bottom)/2;if(mid>coords.top&&mid<coords.bottom&&Math.abs(before.left-coords.left)>1)return before.left<coords.left?"ltr":"rtl"}if(pos<$pos.end()){let after=view.coordsAtPos(pos+1),mid=(after.top+after.bottom)/2;if(mid>coords.top&&mid<coords.bottom&&Math.abs(after.left-coords.left)>1)return after.left>coords.left?"ltr":"rtl"}}let computed=getComputedStyle(view.dom).direction;return"rtl"==computed?"rtl":"ltr"}
// Check whether vertical selection motion would involve node
// selections. If so, apply it (if not, the result is left to the
// browser)
function selectVertically(view,dir,mods){let sel=view.state.selection;if(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .TextSelection */.Bs&&!sel.empty||mods.indexOf("s")>-1)return!1;if(mac&&mods.indexOf("m")>-1)return!1;let{$from:$from,$to:$to}=sel;if(!$from.parent.inlineContent||view.endOfTextblock(dir<0?"up":"down")){let next=moveSelectionBlock(view.state,dir);if(next&&next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv)return apply(view,next)}if(!$from.parent.inlineContent){let side=dir<0?$from:$to,beyond=sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .AllSelection */.C1?prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .Selection */.Y1.near(side,dir):prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .Selection */.Y1.findFrom(side,dir);return!!beyond&&apply(view,beyond)}return!1}function stopNativeHorizontalDelete(view,dir){if(!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .TextSelection */.Bs))return!0;let{$head:$head,$anchor:$anchor,empty:empty}=view.state.selection;if(!$head.sameParent($anchor))return!0;if(!empty)return!1;if(view.endOfTextblock(dir>0?"forward":"backward"))return!0;let nextNode=!$head.textOffset&&(dir<0?$head.nodeBefore:$head.nodeAfter);if(nextNode&&!nextNode.isText){let tr=view.state.tr;return dir<0?tr.delete($head.pos-nextNode.nodeSize,$head.pos):tr.delete($head.pos,$head.pos+nextNode.nodeSize),view.dispatch(tr),!0}return!1}function switchEditable(view,node,state){view.domObserver.stop(),node.contentEditable=state,view.domObserver.start()}
// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821
// In which Safari (and at some point in the past, Chrome) does really
// wrong things when the down arrow is pressed when the cursor is
// directly at the start of a textblock and has an uneditable node
// after it
function safariDownArrowBug(view){if(!safari||view.state.selection.$head.parentOffset>0)return!1;let{focusNode:focusNode,focusOffset:focusOffset}=view.domSelectionRange();if(focusNode&&1==focusNode.nodeType&&0==focusOffset&&focusNode.firstChild&&"false"==focusNode.firstChild.contentEditable){let child=focusNode.firstChild;switchEditable(view,child,"true"),setTimeout((()=>switchEditable(view,child,"false")),20)}return!1}
// A backdrop key mapping used to make sure we always suppress keys
// that have a dangerous default effect, even if the commands they are
// bound to return false, and to make sure that cursor-motion keys
// find a cursor (as opposed to a node selection) when pressed. For
// cursor-motion keys, the code in the handlers also takes care of
// block selections.
function getMods(event){let result="";return event.ctrlKey&&(result+="c"),event.metaKey&&(result+="m"),event.altKey&&(result+="a"),event.shiftKey&&(result+="s"),result}function captureKeyDown(view,event){let code=event.keyCode,mods=getMods(event);if(8==code||mac&&72==code&&"c"==mods)// Backspace, Ctrl-h on Mac
return stopNativeHorizontalDelete(view,-1)||skipIgnoredNodes(view,-1);if(46==code&&!event.shiftKey||mac&&68==code&&"c"==mods)// Delete, Ctrl-d on Mac
return stopNativeHorizontalDelete(view,1)||skipIgnoredNodes(view,1);if(13==code||27==code)// Enter, Esc
return!0;if(37==code||mac&&66==code&&"c"==mods){// Left arrow, Ctrl-b on Mac
let dir=37==code?"ltr"==findDirection(view,view.state.selection.from)?-1:1:-1;return selectHorizontally(view,dir,mods)||skipIgnoredNodes(view,dir)}if(39==code||mac&&70==code&&"c"==mods){// Right arrow, Ctrl-f on Mac
let dir=39==code?"ltr"==findDirection(view,view.state.selection.from)?1:-1:1;return selectHorizontally(view,dir,mods)||skipIgnoredNodes(view,dir)}return 38==code||mac&&80==code&&"c"==mods?selectVertically(view,-1,mods)||skipIgnoredNodes(view,-1):40==code||mac&&78==code&&"c"==mods?safariDownArrowBug(view)||selectVertically(view,1,mods)||skipIgnoredNodes(view,1):mods==(mac?"m":"c")&&(66==code||73==code||89==code||90==code)}function serializeForClipboard(view,slice){view.someProp("transformCopied",(f=>{slice=f(slice,view)}));let context=[],{content:content,openStart:openStart,openEnd:openEnd}=slice;while(openStart>1&&openEnd>1&&1==content.childCount&&1==content.firstChild.childCount){openStart--,openEnd--;let node=content.firstChild;context.push(node.type.name,node.attrs!=node.type.defaultAttrs?node.attrs:null),content=node.content}let serializer=view.someProp("clipboardSerializer")||prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .DOMSerializer */.PW.fromSchema(view.state.schema),doc=detachedDoc(),wrap=doc.createElement("div");wrap.appendChild(serializer.serializeFragment(content,{document:doc}));let needsWrap,firstChild=wrap.firstChild,wrappers=0;while(firstChild&&1==firstChild.nodeType&&(needsWrap=wrapMap[firstChild.nodeName.toLowerCase()])){for(let i=needsWrap.length-1;i>=0;i--){let wrapper=doc.createElement(needsWrap[i]);while(wrap.firstChild)wrapper.appendChild(wrap.firstChild);wrap.appendChild(wrapper),wrappers++}firstChild=wrap.firstChild}firstChild&&1==firstChild.nodeType&&firstChild.setAttribute("data-pm-slice",`${openStart} ${openEnd}${wrappers?` -${wrappers}`:""} ${JSON.stringify(context)}`);let text=view.someProp("clipboardTextSerializer",(f=>f(slice,view)))||slice.content.textBetween(0,slice.content.size,"\n\n");return{dom:wrap,text:text}}
// Read a slice of content from the clipboard (or drop data).
function parseFromClipboard(view,text,html,plainText,$context){let dom,slice,inCode=$context.parent.type.spec.code;if(!html&&!text)return null;let asText=text&&(plainText||inCode||!html);if(asText){if(view.someProp("transformPastedText",(f=>{text=f(text,inCode||plainText,view)})),inCode)return text?new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(view.state.schema.text(text.replace(/\r\n?/g,"\n"))),0,0):prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.empty;let parsed=view.someProp("clipboardTextParser",(f=>f(text,$context,plainText,view)));if(parsed)slice=parsed;else{let marks=$context.marks(),{schema:schema}=view.state,serializer=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .DOMSerializer */.PW.fromSchema(schema);dom=document.createElement("div"),text.split(/(?:\r\n?|\n)+/).forEach((block=>{let p=dom.appendChild(document.createElement("p"));block&&p.appendChild(serializer.serializeNode(schema.text(block,marks)))}))}}else view.someProp("transformPastedHTML",(f=>{html=f(html,view)})),dom=readHTML(html),webkit&&restoreReplacedSpaces(dom);let contextNode=dom&&dom.querySelector("[data-pm-slice]"),sliceData=contextNode&&/^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice")||"");if(sliceData&&sliceData[3])for(let i=+sliceData[3];i>0;i--){let child=dom.firstChild;while(child&&1!=child.nodeType)child=child.nextSibling;if(!child)break;dom=child}if(!slice){let parser=view.someProp("clipboardParser")||view.someProp("domParser")||prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .DOMParser */.aw.fromSchema(view.state.schema);slice=parser.parseSlice(dom,{preserveWhitespace:!(!asText&&!sliceData),context:$context,ruleFromNode(dom){return"BR"!=dom.nodeName||dom.nextSibling||!dom.parentNode||inlineParents.test(dom.parentNode.nodeName)?null:{ignore:!0}}})}if(sliceData)slice=addContext(closeSlice(slice,+sliceData[1],+sliceData[2]),sliceData[4]);else if(// HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent
slice=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.maxOpen(normalizeSiblings(slice.content,$context),!0),slice.openStart||slice.openEnd){let openStart=0,openEnd=0;for(let node=slice.content.firstChild;openStart<slice.openStart&&!node.type.spec.isolating;openStart++,node=node.firstChild);for(let node=slice.content.lastChild;openEnd<slice.openEnd&&!node.type.spec.isolating;openEnd++,node=node.lastChild);slice=closeSlice(slice,openStart,openEnd)}return view.someProp("transformPasted",(f=>{slice=f(slice,view)})),slice}const inlineParents=/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
// Takes a slice parsed with parseSlice, which means there hasn't been
// any content-expression checking done on the top nodes, tries to
// find a parent node in the current context that might fit the nodes,
// and if successful, rebuilds the slice so that it fits into that parent.

// This addresses the problem that Transform.replace expects a
// coherent slice, and will fail to place a set of siblings that don't
// fit anywhere in the schema.
function normalizeSiblings(fragment,$context){if(fragment.childCount<2)return fragment;for(let d=$context.depth;d>=0;d--){let lastWrap,parent=$context.node(d),match=parent.contentMatchAt($context.index(d)),result=[];if(fragment.forEach((node=>{if(!result)return;let inLast,wrap=match.findWrapping(node.type);if(!wrap)return result=null;if(inLast=result.length&&lastWrap.length&&addToSibling(wrap,lastWrap,node,result[result.length-1],0))result[result.length-1]=inLast;else{result.length&&(result[result.length-1]=closeRight(result[result.length-1],lastWrap.length));let wrapped=withWrappers(node,wrap);result.push(wrapped),match=match.matchType(wrapped.type),lastWrap=wrap}})),result)return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(result)}return fragment}function withWrappers(node,wrap,from=0){for(let i=wrap.length-1;i>=from;i--)node=wrap[i].create(null,prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(node));return node}
// Used to group adjacent nodes wrapped in similar parents by
// normalizeSiblings into the same parent node
function addToSibling(wrap,lastWrap,node,sibling,depth){if(depth<wrap.length&&depth<lastWrap.length&&wrap[depth]==lastWrap[depth]){let inner=addToSibling(wrap,lastWrap,node,sibling.lastChild,depth+1);if(inner)return sibling.copy(sibling.content.replaceChild(sibling.childCount-1,inner));let match=sibling.contentMatchAt(sibling.childCount);if(match.matchType(depth==wrap.length-1?node.type:wrap[depth+1]))return sibling.copy(sibling.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(withWrappers(node,wrap,depth+1))))}}function closeRight(node,depth){if(0==depth)return node;let fragment=node.content.replaceChild(node.childCount-1,closeRight(node.lastChild,depth-1)),fill=node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty,!0);return node.copy(fragment.append(fill))}function closeRange(fragment,side,from,to,depth,openEnd){let node=side<0?fragment.firstChild:fragment.lastChild,inner=node.content;return fragment.childCount>1&&(openEnd=0),depth<to-1&&(inner=closeRange(inner,side,from,to,depth+1,openEnd)),depth>=from&&(inner=side<0?node.contentMatchAt(0).fillBefore(inner,openEnd<=depth).append(inner):inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.empty,!0))),fragment.replaceChild(side<0?0:fragment.childCount-1,node.copy(inner))}function closeSlice(slice,openStart,openEnd){return openStart<slice.openStart&&(slice=new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(closeRange(slice.content,-1,openStart,slice.openStart,0,slice.openEnd),openStart,slice.openEnd)),openEnd<slice.openEnd&&(slice=new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(closeRange(slice.content,1,openEnd,slice.openEnd,0,0),slice.openStart,openEnd)),slice}
// Trick from jQuery -- some elements must be wrapped in other
// elements for innerHTML to work. I.e. if you do `div.innerHTML =
// "<td>..</td>"` the table cells are ignored.
const wrapMap={thead:["table"],tbody:["table"],tfoot:["table"],caption:["table"],colgroup:["table"],col:["table","colgroup"],tr:["table","tbody"],td:["table","tbody","tr"],th:["table","tbody","tr"]};let _detachedDoc=null;function detachedDoc(){return _detachedDoc||(_detachedDoc=document.implementation.createHTMLDocument("title"))}function readHTML(html){let metas=/^(\s*<meta [^>]*>)*/.exec(html);metas&&(html=html.slice(metas[0].length));let wrap,elt=detachedDoc().createElement("div"),firstTag=/<([a-z][^>\s]+)/i.exec(html);if((wrap=firstTag&&wrapMap[firstTag[1].toLowerCase()])&&(html=wrap.map((n=>"<"+n+">")).join("")+html+wrap.map((n=>"</"+n+">")).reverse().join("")),elt.innerHTML=html,wrap)for(let i=0;i<wrap.length;i++)elt=elt.querySelector(wrap[i])||elt;return elt}
// Webkit browsers do some hard-to-predict replacement of regular
// spaces with non-breaking spaces when putting content on the
// clipboard. This tries to convert such non-breaking spaces (which
// will be wrapped in a plain span on Chrome, a span with class
// Apple-converted-space on Safari) back to regular spaces.
function restoreReplacedSpaces(dom){let nodes=dom.querySelectorAll(chrome?"span:not([class]):not([style])":"span.Apple-converted-space");for(let i=0;i<nodes.length;i++){let node=nodes[i];1==node.childNodes.length&&" "==node.textContent&&node.parentNode&&node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "),node)}}function addContext(slice,context){if(!slice.size)return slice;let array,schema=slice.content.firstChild.type.schema;try{array=JSON.parse(context)}catch(e){return slice}let{content:content,openStart:openStart,openEnd:openEnd}=slice;for(let i=array.length-2;i>=0;i-=2){let type=schema.nodes[array[i]];if(!type||type.hasRequiredAttrs())break;content=prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(type.create(array[i+1],content)),openStart++,openEnd++}return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2(content,openStart,openEnd)}
// A collection of DOM events that occur within the editor, and callback functions
// to invoke when the event fires.
const handlers={},editHandlers={},passiveHandlers={touchstart:!0,touchmove:!0};class InputState{constructor(){this.shiftKey=!1,this.mouseDown=null,this.lastKeyCode=null,this.lastKeyCodeTime=0,this.lastClick={time:0,x:0,y:0,type:""},this.lastSelectionOrigin=null,this.lastSelectionTime=0,this.lastIOSEnter=0,this.lastIOSEnterFallbackTimeout=-1,this.lastFocus=0,this.lastTouch=0,this.lastAndroidDelete=0,this.composing=!1,this.composingTimeout=-1,this.compositionNodes=[],this.compositionEndedAt=-2e8,this.compositionID=1,
// Set to a composition ID when there are pending changes at compositionend
this.compositionPendingChanges=0,this.domChangeCount=0,this.eventHandlers=Object.create(null),this.hideSelectionGuard=null}}function initInput(view){for(let event in handlers){let handler=handlers[event];view.dom.addEventListener(event,view.input.eventHandlers[event]=event=>{!eventBelongsToView(view,event)||runCustomHandler(view,event)||!view.editable&&event.type in editHandlers||handler(view,event)},passiveHandlers[event]?{passive:!0}:void 0)}
// On Safari, for reasons beyond my understanding, adding an input
// event handler makes an issue where the composition vanishes when
// you press enter go away.
safari&&view.dom.addEventListener("input",(()=>null)),ensureListeners(view)}function setSelectionOrigin(view,origin){view.input.lastSelectionOrigin=origin,view.input.lastSelectionTime=Date.now()}function destroyInput(view){view.domObserver.stop();for(let type in view.input.eventHandlers)view.dom.removeEventListener(type,view.input.eventHandlers[type]);clearTimeout(view.input.composingTimeout),clearTimeout(view.input.lastIOSEnterFallbackTimeout)}function ensureListeners(view){view.someProp("handleDOMEvents",(currentHandlers=>{for(let type in currentHandlers)view.input.eventHandlers[type]||view.dom.addEventListener(type,view.input.eventHandlers[type]=event=>runCustomHandler(view,event))}))}function runCustomHandler(view,event){return view.someProp("handleDOMEvents",(handlers=>{let handler=handlers[event.type];return!!handler&&(handler(view,event)||event.defaultPrevented)}))}function eventBelongsToView(view,event){if(!event.bubbles)return!0;if(event.defaultPrevented)return!1;for(let node=event.target;node!=view.dom;node=node.parentNode)if(!node||11==node.nodeType||node.pmViewDesc&&node.pmViewDesc.stopEvent(event))return!1;return!0}function dispatchEvent(view,event){runCustomHandler(view,event)||!handlers[event.type]||!view.editable&&event.type in editHandlers||handlers[event.type](view,event)}function eventCoords(event){return{left:event.clientX,top:event.clientY}}function isNear(event,click){let dx=click.x-event.clientX,dy=click.y-event.clientY;return dx*dx+dy*dy<100}function runHandlerOnContext(view,propName,pos,inside,event){if(-1==inside)return!1;let $pos=view.state.doc.resolve(inside);for(let i=$pos.depth+1;i>0;i--)if(view.someProp(propName,(f=>i>$pos.depth?f(view,pos,$pos.nodeAfter,$pos.before(i),event,!0):f(view,pos,$pos.node(i),$pos.before(i),event,!1))))return!0;return!1}function updateSelection(view,selection,origin){view.focused||view.focus();let tr=view.state.tr.setSelection(selection);"pointer"==origin&&tr.setMeta("pointer",!0),view.dispatch(tr)}function selectClickedLeaf(view,inside){if(-1==inside)return!1;let $pos=view.state.doc.resolve(inside),node=$pos.nodeAfter;return!!(node&&node.isAtom&&prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.isSelectable(node))&&(updateSelection(view,new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv($pos),"pointer"),!0)}function selectClickedNode(view,inside){if(-1==inside)return!1;let selectedNode,selectAt,sel=view.state.selection;sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv&&(selectedNode=sel.node);let $pos=view.state.doc.resolve(inside);for(let i=$pos.depth+1;i>0;i--){let node=i>$pos.depth?$pos.nodeAfter:$pos.node(i);if(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.isSelectable(node)){selectAt=selectedNode&&sel.$from.depth>0&&i>=sel.$from.depth&&$pos.before(sel.$from.depth+1)==sel.$from.pos?$pos.before(sel.$from.depth):$pos.before(i);break}}return null!=selectAt&&(updateSelection(view,prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.create(view.state.doc,selectAt),"pointer"),!0)}function handleSingleClick(view,pos,inside,event,selectNode){return runHandlerOnContext(view,"handleClickOn",pos,inside,event)||view.someProp("handleClick",(f=>f(view,pos,event)))||(selectNode?selectClickedNode(view,inside):selectClickedLeaf(view,inside))}function handleDoubleClick(view,pos,inside,event){return runHandlerOnContext(view,"handleDoubleClickOn",pos,inside,event)||view.someProp("handleDoubleClick",(f=>f(view,pos,event)))}function handleTripleClick(view,pos,inside,event){return runHandlerOnContext(view,"handleTripleClickOn",pos,inside,event)||view.someProp("handleTripleClick",(f=>f(view,pos,event)))||defaultTripleClick(view,inside,event)}function defaultTripleClick(view,inside,event){if(0!=event.button)return!1;let doc=view.state.doc;if(-1==inside)return!!doc.inlineContent&&(updateSelection(view,prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .TextSelection */.Bs.create(doc,0,doc.content.size),"pointer"),!0);let $pos=doc.resolve(inside);for(let i=$pos.depth+1;i>0;i--){let node=i>$pos.depth?$pos.nodeAfter:$pos.node(i),nodePos=$pos.before(i);if(node.inlineContent)updateSelection(view,prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .TextSelection */.Bs.create(doc,nodePos+1,nodePos+1+node.content.size),"pointer");else{if(!prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.isSelectable(node))continue;updateSelection(view,prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.create(doc,nodePos),"pointer")}return!0}}function forceDOMFlush(view){return endComposition(view)}editHandlers.keydown=(view,_event)=>{let event=_event;if(view.input.shiftKey=16==event.keyCode||event.shiftKey,!inOrNearComposition(view,event)&&(view.input.lastKeyCode=event.keyCode,view.input.lastKeyCodeTime=Date.now(),!android||!chrome||13!=event.keyCode))
// On iOS, if we preventDefault enter key presses, the virtual
// keyboard gets confused. So the hack here is to set a flag that
// makes the DOM change code recognize that what just happens should
// be replaced by whatever the Enter key handlers do.
if(229!=event.keyCode&&view.domObserver.forceFlush(),!ios||13!=event.keyCode||event.ctrlKey||event.altKey||event.metaKey)view.someProp("handleKeyDown",(f=>f(view,event)))||captureKeyDown(view,event)?event.preventDefault():setSelectionOrigin(view,"key");else{let now=Date.now();view.input.lastIOSEnter=now,view.input.lastIOSEnterFallbackTimeout=setTimeout((()=>{view.input.lastIOSEnter==now&&(view.someProp("handleKeyDown",(f=>f(view,keyEvent(13,"Enter")))),view.input.lastIOSEnter=0)}),200)}},editHandlers.keyup=(view,event)=>{16==event.keyCode&&(view.input.shiftKey=!1)},editHandlers.keypress=(view,_event)=>{let event=_event;if(inOrNearComposition(view,event)||!event.charCode||event.ctrlKey&&!event.altKey||mac&&event.metaKey)return;if(view.someProp("handleKeyPress",(f=>f(view,event))))return void event.preventDefault();let sel=view.state.selection;if(!(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .TextSelection */.Bs)||!sel.$from.sameParent(sel.$to)){let text=String.fromCharCode(event.charCode);/[\r\n]/.test(text)||view.someProp("handleTextInput",(f=>f(view,sel.$from.pos,sel.$to.pos,text)))||view.dispatch(view.state.tr.insertText(text).scrollIntoView()),event.preventDefault()}};const selectNodeModifier=mac?"metaKey":"ctrlKey";handlers.mousedown=(view,_event)=>{let event=_event;view.input.shiftKey=event.shiftKey;let flushed=forceDOMFlush(view),now=Date.now(),type="singleClick";now-view.input.lastClick.time<500&&isNear(event,view.input.lastClick)&&!event[selectNodeModifier]&&("singleClick"==view.input.lastClick.type?type="doubleClick":"doubleClick"==view.input.lastClick.type&&(type="tripleClick")),view.input.lastClick={time:now,x:event.clientX,y:event.clientY,type:type};let pos=view.posAtCoords(eventCoords(event));pos&&("singleClick"==type?(view.input.mouseDown&&view.input.mouseDown.done(),view.input.mouseDown=new MouseDown(view,pos,event,!!flushed)):("doubleClick"==type?handleDoubleClick:handleTripleClick)(view,pos.pos,pos.inside,event)?event.preventDefault():setSelectionOrigin(view,"pointer"))};class MouseDown{constructor(view,pos,event,flushed){let targetNode,targetPos;if(this.view=view,this.pos=pos,this.event=event,this.flushed=flushed,this.delayedSelectionSync=!1,this.mightDrag=null,this.startDoc=view.state.doc,this.selectNode=!!event[selectNodeModifier],this.allowDefault=event.shiftKey,pos.inside>-1)targetNode=view.state.doc.nodeAt(pos.inside),targetPos=pos.inside;else{let $pos=view.state.doc.resolve(pos.pos);targetNode=$pos.parent,targetPos=$pos.depth?$pos.before():0}const target=flushed?null:event.target,targetDesc=target?view.docView.nearestDesc(target,!0):null;this.target=targetDesc?targetDesc.dom:null;let{selection:selection}=view.state;(0==event.button&&targetNode.type.spec.draggable&&!1!==targetNode.type.spec.selectable||selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv&&selection.from<=targetPos&&selection.to>targetPos)&&(this.mightDrag={node:targetNode,pos:targetPos,addAttr:!(!this.target||this.target.draggable),setUneditable:!(!this.target||!gecko||this.target.hasAttribute("contentEditable"))}),this.target&&this.mightDrag&&(this.mightDrag.addAttr||this.mightDrag.setUneditable)&&(this.view.domObserver.stop(),this.mightDrag.addAttr&&(this.target.draggable=!0),this.mightDrag.setUneditable&&setTimeout((()=>{this.view.input.mouseDown==this&&this.target.setAttribute("contentEditable","false")}),20),this.view.domObserver.start()),view.root.addEventListener("mouseup",this.up=this.up.bind(this)),view.root.addEventListener("mousemove",this.move=this.move.bind(this)),setSelectionOrigin(view,"pointer")}done(){this.view.root.removeEventListener("mouseup",this.up),this.view.root.removeEventListener("mousemove",this.move),this.mightDrag&&this.target&&(this.view.domObserver.stop(),this.mightDrag.addAttr&&this.target.removeAttribute("draggable"),this.mightDrag.setUneditable&&this.target.removeAttribute("contentEditable"),this.view.domObserver.start()),this.delayedSelectionSync&&setTimeout((()=>selectionToDOM(this.view))),this.view.input.mouseDown=null}up(event){if(this.done(),!this.view.dom.contains(event.target))return;let pos=this.pos;this.view.state.doc!=this.startDoc&&(pos=this.view.posAtCoords(eventCoords(event))),this.updateAllowDefault(event),this.allowDefault||!pos?setSelectionOrigin(this.view,"pointer"):handleSingleClick(this.view,pos.pos,pos.inside,event,this.selectNode)?event.preventDefault():0==event.button&&(this.flushed||
// Safari ignores clicks on draggable elements
safari&&this.mightDrag&&!this.mightDrag.node.isAtom||
// Chrome will sometimes treat a node selection as a
// cursor, but still report that the node is selected
// when asked through getSelection. You'll then get a
// situation where clicking at the point where that
// (hidden) cursor is doesn't change the selection, and
// thus doesn't get a reaction from ProseMirror. This
// works around that.
chrome&&!this.view.state.selection.visible&&Math.min(Math.abs(pos.pos-this.view.state.selection.from),Math.abs(pos.pos-this.view.state.selection.to))<=2)?(updateSelection(this.view,prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .Selection */.Y1.near(this.view.state.doc.resolve(pos.pos)),"pointer"),event.preventDefault()):setSelectionOrigin(this.view,"pointer")}move(event){this.updateAllowDefault(event),setSelectionOrigin(this.view,"pointer"),0==event.buttons&&this.done()}updateAllowDefault(event){!this.allowDefault&&(Math.abs(this.event.x-event.clientX)>4||Math.abs(this.event.y-event.clientY)>4)&&(this.allowDefault=!0)}}function inOrNearComposition(view,event){return!!view.composing||
// See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
// On Japanese input method editors (IMEs), the Enter key is used to confirm character
// selection. On Safari, when Enter is pressed, compositionend and keydown events are
// emitted. The keydown event triggers newline insertion, which we don't want.
// This method returns true if the keydown event should be ignored.
// We only ignore it once, as pressing Enter a second time *should* insert a newline.
// Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.
// This guards against the case where compositionend is triggered without the keyboard
// (e.g. character confirmation may be done with the mouse), and keydown is triggered
// afterwards- we wouldn't want to ignore the keydown event in this case.
!!(safari&&Math.abs(event.timeStamp-view.input.compositionEndedAt)<500)&&(view.input.compositionEndedAt=-2e8,!0)}
// Drop active composition after 5 seconds of inactivity on Android
handlers.touchstart=view=>{view.input.lastTouch=Date.now(),forceDOMFlush(view),setSelectionOrigin(view,"pointer")},handlers.touchmove=view=>{view.input.lastTouch=Date.now(),setSelectionOrigin(view,"pointer")},handlers.contextmenu=view=>forceDOMFlush(view);const timeoutComposition=android?5e3:-1;function scheduleComposeEnd(view,delay){clearTimeout(view.input.composingTimeout),delay>-1&&(view.input.composingTimeout=setTimeout((()=>endComposition(view)),delay))}function clearComposition(view){view.composing&&(view.input.composing=!1,view.input.compositionEndedAt=timestampFromCustomEvent());while(view.input.compositionNodes.length>0)view.input.compositionNodes.pop().markParentsDirty()}function timestampFromCustomEvent(){let event=document.createEvent("Event");return event.initEvent("event",!0,!0),event.timeStamp}
/**
@internal
*/function endComposition(view,forceUpdate=!1){if(!(android&&view.domObserver.flushingSoon>=0)){if(view.domObserver.forceFlush(),clearComposition(view),forceUpdate||view.docView&&view.docView.dirty){let sel=selectionFromDOM(view);return sel&&!sel.eq(view.state.selection)?view.dispatch(view.state.tr.setSelection(sel)):view.updateState(view.state),!0}return!1}}function captureCopy(view,dom){
// The extra wrapper is somehow necessary on IE/Edge to prevent the
// content from being mangled when it is put onto the clipboard
if(!view.dom.parentNode)return;let wrap=view.dom.parentNode.appendChild(document.createElement("div"));wrap.appendChild(dom),wrap.style.cssText="position: fixed; left: -10000px; top: 10px";let sel=getSelection(),range=document.createRange();range.selectNodeContents(dom),
// Done because IE will fire a selectionchange moving the selection
// to its start when removeAllRanges is called and the editor still
// has focus (which will mess up the editor's selection state).
view.dom.blur(),sel.removeAllRanges(),sel.addRange(range),setTimeout((()=>{wrap.parentNode&&wrap.parentNode.removeChild(wrap),view.focus()}),50)}
// This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard API—all the objects and methods are
// there, they just don't work, and they are hard to test.
editHandlers.compositionstart=editHandlers.compositionupdate=view=>{if(!view.composing){view.domObserver.flush();let{state:state}=view,$pos=state.selection.$from;if(state.selection.empty&&(state.storedMarks||!$pos.textOffset&&$pos.parentOffset&&$pos.nodeBefore.marks.some((m=>!1===m.type.spec.inclusive))))
// Need to wrap the cursor in mark nodes different from the ones in the DOM context
view.markCursor=view.state.storedMarks||$pos.marks(),endComposition(view,!0),view.markCursor=null;else
// In firefox, if the cursor is after but outside a marked node,
// the inserted text won't inherit the marks. So this moves it
// inside if necessary.
if(endComposition(view),gecko&&state.selection.empty&&$pos.parentOffset&&!$pos.textOffset&&$pos.nodeBefore.marks.length){let sel=view.domSelectionRange();for(let node=sel.focusNode,offset=sel.focusOffset;node&&1==node.nodeType&&0!=offset;){let before=offset<0?node.lastChild:node.childNodes[offset-1];if(!before)break;if(3==before.nodeType){view.domSelection().collapse(before,before.nodeValue.length);break}node=before,offset=-1}}view.input.composing=!0}scheduleComposeEnd(view,timeoutComposition)},editHandlers.compositionend=(view,event)=>{view.composing&&(view.input.composing=!1,view.input.compositionEndedAt=event.timeStamp,view.input.compositionPendingChanges=view.domObserver.pendingRecords().length?view.input.compositionID:0,view.input.compositionPendingChanges&&Promise.resolve().then((()=>view.domObserver.flush())),view.input.compositionID++,scheduleComposeEnd(view,20))};const brokenClipboardAPI=ie&&ie_version<15||ios&&webkit_version<604;function sliceSingleNode(slice){return 0==slice.openStart&&0==slice.openEnd&&1==slice.content.childCount?slice.content.firstChild:null}function capturePaste(view,event){if(!view.dom.parentNode)return;let plainText=view.input.shiftKey||view.state.selection.$from.parent.type.spec.code,target=view.dom.parentNode.appendChild(document.createElement(plainText?"textarea":"div"));plainText||(target.contentEditable="true"),target.style.cssText="position: fixed; left: -10000px; top: 10px",target.focus();let plain=view.input.shiftKey&&45!=view.input.lastKeyCode;setTimeout((()=>{view.focus(),target.parentNode&&target.parentNode.removeChild(target),plainText?doPaste(view,target.value,null,plain,event):doPaste(view,target.textContent,target.innerHTML,plain,event)}),50)}function doPaste(view,text,html,preferPlain,event){let slice=parseFromClipboard(view,text,html,preferPlain,view.state.selection.$from);if(view.someProp("handlePaste",(f=>f(view,event,slice||prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.empty))))return!0;if(!slice)return!1;let singleNode=sliceSingleNode(slice),tr=singleNode?view.state.tr.replaceSelectionWith(singleNode,preferPlain):view.state.tr.replaceSelection(slice);return view.dispatch(tr.scrollIntoView().setMeta("paste",!0).setMeta("uiEvent","paste")),!0}function getText(clipboardData){let text=clipboardData.getData("text/plain")||clipboardData.getData("Text");if(text)return text;let uris=clipboardData.getData("text/uri-list");return uris?uris.replace(/\r?\n/g," "):""}handlers.copy=editHandlers.cut=(view,_event)=>{let event=_event,sel=view.state.selection,cut="cut"==event.type;if(sel.empty)return;
// IE and Edge's clipboard interface is completely broken
let data=brokenClipboardAPI?null:event.clipboardData,slice=sel.content(),{dom:dom,text:text}=serializeForClipboard(view,slice);data?(event.preventDefault(),data.clearData(),data.setData("text/html",dom.innerHTML),data.setData("text/plain",text)):captureCopy(view,dom),cut&&view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent","cut"))},editHandlers.paste=(view,_event)=>{let event=_event;
// Handling paste from JavaScript during composition is very poorly
// handled by browsers, so as a dodgy but preferable kludge, we just
// let the browser do its native thing there, except on Android,
// where the editor is almost always composing.
if(view.composing&&!android)return;let data=brokenClipboardAPI?null:event.clipboardData,plain=view.input.shiftKey&&45!=view.input.lastKeyCode;data&&doPaste(view,getText(data),data.getData("text/html"),plain,event)?event.preventDefault():capturePaste(view,event)};class Dragging{constructor(slice,move){this.slice=slice,this.move=move}}const dragCopyModifier=mac?"altKey":"ctrlKey";handlers.dragstart=(view,_event)=>{let event=_event,mouseDown=view.input.mouseDown;if(mouseDown&&mouseDown.done(),!event.dataTransfer)return;let sel=view.state.selection,pos=sel.empty?null:view.posAtCoords(eventCoords(event));if(pos&&pos.pos>=sel.from&&pos.pos<=(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv?sel.to-1:sel.to));else if(mouseDown&&mouseDown.mightDrag)view.dispatch(view.state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.create(view.state.doc,mouseDown.mightDrag.pos)));else if(event.target&&1==event.target.nodeType){let desc=view.docView.nearestDesc(event.target,!0);desc&&desc.node.type.spec.draggable&&desc!=view.docView&&view.dispatch(view.state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.create(view.state.doc,desc.posBefore)))}let slice=view.state.selection.content(),{dom:dom,text:text}=serializeForClipboard(view,slice);event.dataTransfer.clearData(),event.dataTransfer.setData(brokenClipboardAPI?"Text":"text/html",dom.innerHTML),
// See https://github.com/ProseMirror/prosemirror/issues/1156
event.dataTransfer.effectAllowed="copyMove",brokenClipboardAPI||event.dataTransfer.setData("text/plain",text),view.dragging=new Dragging(slice,!event[dragCopyModifier])},handlers.dragend=view=>{let dragging=view.dragging;window.setTimeout((()=>{view.dragging==dragging&&(view.dragging=null)}),50)},editHandlers.dragover=editHandlers.dragenter=(_,e)=>e.preventDefault(),editHandlers.drop=(view,_event)=>{let event=_event,dragging=view.dragging;if(view.dragging=null,!event.dataTransfer)return;let eventPos=view.posAtCoords(eventCoords(event));if(!eventPos)return;let $mouse=view.state.doc.resolve(eventPos.pos),slice=dragging&&dragging.slice;slice?view.someProp("transformPasted",(f=>{slice=f(slice,view)})):slice=parseFromClipboard(view,getText(event.dataTransfer),brokenClipboardAPI?null:event.dataTransfer.getData("text/html"),!1,$mouse);let move=!(!dragging||event[dragCopyModifier]);if(view.someProp("handleDrop",(f=>f(view,event,slice||prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Slice */.p2.empty,move))))return void event.preventDefault();if(!slice)return;event.preventDefault();let insertPos=slice?(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__/* .dropPoint */.nj)(view.state.doc,$mouse.pos,slice):$mouse.pos;null==insertPos&&(insertPos=$mouse.pos);let tr=view.state.tr;move&&tr.deleteSelection();let pos=tr.mapping.map(insertPos),isNode=0==slice.openStart&&0==slice.openEnd&&1==slice.content.childCount,beforeInsert=tr.doc;if(isNode?tr.replaceRangeWith(pos,pos,slice.content.firstChild):tr.replaceRange(pos,pos,slice),tr.doc.eq(beforeInsert))return;let $pos=tr.doc.resolve(pos);if(isNode&&prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv.isSelectable(slice.content.firstChild)&&$pos.nodeAfter&&$pos.nodeAfter.sameMarkup(slice.content.firstChild))tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv($pos));else{let end=tr.mapping.map(insertPos);tr.mapping.maps[tr.mapping.maps.length-1].forEach(((_from,_to,_newFrom,newTo)=>end=newTo)),tr.setSelection(selectionBetween(view,$pos,tr.doc.resolve(end)))}view.focus(),view.dispatch(tr.setMeta("uiEvent","drop"))},handlers.focus=view=>{view.input.lastFocus=Date.now(),view.focused||(view.domObserver.stop(),view.dom.classList.add("ProseMirror-focused"),view.domObserver.start(),view.focused=!0,setTimeout((()=>{view.docView&&view.hasFocus()&&!view.domObserver.currentSelection.eq(view.domSelectionRange())&&selectionToDOM(view)}),20))},handlers.blur=(view,_event)=>{let event=_event;view.focused&&(view.domObserver.stop(),view.dom.classList.remove("ProseMirror-focused"),view.domObserver.start(),event.relatedTarget&&view.dom.contains(event.relatedTarget)&&view.domObserver.currentSelection.clear(),view.focused=!1)},handlers.beforeinput=(view,_event)=>{let event=_event;
// We should probably do more with beforeinput events, but support
// is so spotty that I'm still waiting to see where they are going.
// Very specific hack to deal with backspace sometimes failing on
// Chrome Android when after an uneditable node.
if(chrome&&android&&"deleteContentBackward"==event.inputType){view.domObserver.flushSoon();let{domChangeCount:domChangeCount}=view.input;setTimeout((()=>{if(view.input.domChangeCount!=domChangeCount)return;// Event already had some effect
// This bug tends to close the virtual keyboard, so we refocus
if(view.dom.blur(),view.focus(),view.someProp("handleKeyDown",(f=>f(view,keyEvent(8,"Backspace")))))return;let{$cursor:$cursor}=view.state.selection;
// Crude approximation of backspace behavior when no command handled it
$cursor&&$cursor.pos>0&&view.dispatch(view.state.tr.delete($cursor.pos-1,$cursor.pos).scrollIntoView())}),50)}};
// Make sure all handlers get registered
for(let prop in editHandlers)handlers[prop]=editHandlers[prop];function compareObjs(a,b){if(a==b)return!0;for(let p in a)if(a[p]!==b[p])return!1;for(let p in b)if(!(p in a))return!1;return!0}class WidgetType{constructor(toDOM,spec){this.toDOM=toDOM,this.spec=spec||noSpec,this.side=this.spec.side||0}map(mapping,span,offset,oldOffset){let{pos:pos,deleted:deleted}=mapping.mapResult(span.from+oldOffset,this.side<0?-1:1);return deleted?null:new Decoration(pos-offset,pos-offset,this)}valid(){return!0}eq(other){return this==other||other instanceof WidgetType&&(this.spec.key&&this.spec.key==other.spec.key||this.toDOM==other.toDOM&&compareObjs(this.spec,other.spec))}destroy(node){this.spec.destroy&&this.spec.destroy(node)}}class InlineType{constructor(attrs,spec){this.attrs=attrs,this.spec=spec||noSpec}map(mapping,span,offset,oldOffset){let from=mapping.map(span.from+oldOffset,this.spec.inclusiveStart?-1:1)-offset,to=mapping.map(span.to+oldOffset,this.spec.inclusiveEnd?1:-1)-offset;return from>=to?null:new Decoration(from,to,this)}valid(_,span){return span.from<span.to}eq(other){return this==other||other instanceof InlineType&&compareObjs(this.attrs,other.attrs)&&compareObjs(this.spec,other.spec)}static is(span){return span.type instanceof InlineType}destroy(){}}class NodeType{constructor(attrs,spec){this.attrs=attrs,this.spec=spec||noSpec}map(mapping,span,offset,oldOffset){let from=mapping.mapResult(span.from+oldOffset,1);if(from.deleted)return null;let to=mapping.mapResult(span.to+oldOffset,-1);return to.deleted||to.pos<=from.pos?null:new Decoration(from.pos-offset,to.pos-offset,this)}valid(node,span){let child,{index:index,offset:offset}=node.content.findIndex(span.from);return offset==span.from&&!(child=node.child(index)).isText&&offset+child.nodeSize==span.to}eq(other){return this==other||other instanceof NodeType&&compareObjs(this.attrs,other.attrs)&&compareObjs(this.spec,other.spec)}destroy(){}}
/**
Decoration objects can be provided to the view through the
[`decorations` prop](https://prosemirror.net/docs/ref/#view.EditorProps.decorations). They come in
several variants—see the static members of this class for details.
*/class Decoration{
/**
    @internal
    */
constructor(
/**
    The start position of the decoration.
    */
from,
/**
    The end position. Will be the same as `from` for [widget
    decorations](https://prosemirror.net/docs/ref/#view.Decoration^widget).
    */
to,
/**
    @internal
    */
type){this.from=from,this.to=to,this.type=type}
/**
    @internal
    */copy(from,to){return new Decoration(from,to,this.type)}
/**
    @internal
    */eq(other,offset=0){return this.type.eq(other.type)&&this.from+offset==other.from&&this.to+offset==other.to}
/**
    @internal
    */map(mapping,offset,oldOffset){return this.type.map(mapping,this,offset,oldOffset)}
/**
    Creates a widget decoration, which is a DOM node that's shown in
    the document at the given position. It is recommended that you
    delay rendering the widget by passing a function that will be
    called when the widget is actually drawn in a view, but you can
    also directly pass a DOM node. `getPos` can be used to find the
    widget's current document position.
    */static widget(pos,toDOM,spec){return new Decoration(pos,pos,new WidgetType(toDOM,spec))}
/**
    Creates an inline decoration, which adds the given attributes to
    each inline node between `from` and `to`.
    */static inline(from,to,attrs,spec){return new Decoration(from,to,new InlineType(attrs,spec))}
/**
    Creates a node decoration. `from` and `to` should point precisely
    before and after a node in the document. That node, and only that
    node, will receive the given attributes.
    */static node(from,to,attrs,spec){return new Decoration(from,to,new NodeType(attrs,spec))}
/**
    The spec provided when creating this decoration. Can be useful
    if you've stored extra information in that object.
    */get spec(){return this.type.spec}
/**
    @internal
    */get inline(){return this.type instanceof InlineType}
/**
    @internal
    */get widget(){return this.type instanceof WidgetType}}const none=[],noSpec={};
/**
A collection of [decorations](https://prosemirror.net/docs/ref/#view.Decoration), organized in such
a way that the drawing algorithm can efficiently use and compare
them. This is a persistent data structure—it is not modified,
updates create a new value.
*/class DecorationSet{
/**
    @internal
    */
constructor(local,children){this.local=local.length?local:none,this.children=children.length?children:none}
/**
    Create a set of decorations, using the structure of the given
    document. This will consume (modify) the `decorations` array, so
    you must make a copy if you want need to preserve that.
    */static create(doc,decorations){return decorations.length?buildTree(decorations,doc,0,noSpec):empty}
/**
    Find all decorations in this set which touch the given range
    (including decorations that start or end directly at the
    boundaries) and match the given predicate on their spec. When
    `start` and `end` are omitted, all decorations in the set are
    considered. When `predicate` isn't given, all decorations are
    assumed to match.
    */find(start,end,predicate){let result=[];return this.findInner(null==start?0:start,null==end?1e9:end,result,0,predicate),result}findInner(start,end,result,offset,predicate){for(let i=0;i<this.local.length;i++){let span=this.local[i];span.from<=end&&span.to>=start&&(!predicate||predicate(span.spec))&&result.push(span.copy(span.from+offset,span.to+offset))}for(let i=0;i<this.children.length;i+=3)if(this.children[i]<end&&this.children[i+1]>start){let childOff=this.children[i]+1;this.children[i+2].findInner(start-childOff,end-childOff,result,offset+childOff,predicate)}}
/**
    Map the set of decorations in response to a change in the
    document.
    */map(mapping,doc,options){return this==empty||0==mapping.maps.length?this:this.mapInner(mapping,doc,0,0,options||noSpec)}
/**
    @internal
    */mapInner(mapping,node,offset,oldOffset,options){let newLocal;for(let i=0;i<this.local.length;i++){let mapped=this.local[i].map(mapping,offset,oldOffset);mapped&&mapped.type.valid(node,mapped)?(newLocal||(newLocal=[])).push(mapped):options.onRemove&&options.onRemove(this.local[i].spec)}return this.children.length?mapChildren(this.children,newLocal||[],mapping,node,offset,oldOffset,options):newLocal?new DecorationSet(newLocal.sort(byPos),none):empty}
/**
    Add the given array of decorations to the ones in the set,
    producing a new set. Consumes the `decorations` array. Needs
    access to the current document to create the appropriate tree
    structure.
    */add(doc,decorations){return decorations.length?this==empty?DecorationSet.create(doc,decorations):this.addInner(doc,decorations,0):this}addInner(doc,decorations,offset){let children,childIndex=0;doc.forEach(((childNode,childOffset)=>{let found,baseOffset=childOffset+offset;if(found=takeSpansForNode(decorations,childNode,baseOffset)){children||(children=this.children.slice());while(childIndex<children.length&&children[childIndex]<childOffset)childIndex+=3;children[childIndex]==childOffset?children[childIndex+2]=children[childIndex+2].addInner(childNode,found,baseOffset+1):children.splice(childIndex,0,childOffset,childOffset+childNode.nodeSize,buildTree(found,childNode,baseOffset+1,noSpec)),childIndex+=3}}));let local=moveSpans(childIndex?withoutNulls(decorations):decorations,-offset);for(let i=0;i<local.length;i++)local[i].type.valid(doc,local[i])||local.splice(i--,1);return new DecorationSet(local.length?this.local.concat(local).sort(byPos):this.local,children||this.children)}
/**
    Create a new set that contains the decorations in this set, minus
    the ones in the given array.
    */remove(decorations){return 0==decorations.length||this==empty?this:this.removeInner(decorations,0)}removeInner(decorations,offset){let children=this.children,local=this.local;for(let i=0;i<children.length;i+=3){let found,from=children[i]+offset,to=children[i+1]+offset;for(let span,j=0;j<decorations.length;j++)(span=decorations[j])&&span.from>from&&span.to<to&&(decorations[j]=null,(found||(found=[])).push(span));if(!found)continue;children==this.children&&(children=this.children.slice());let removed=children[i+2].removeInner(found,from+1);removed!=empty?children[i+2]=removed:(children.splice(i,3),i-=3)}if(local.length)for(let span,i=0;i<decorations.length;i++)if(span=decorations[i])for(let j=0;j<local.length;j++)local[j].eq(span,offset)&&(local==this.local&&(local=this.local.slice()),local.splice(j--,1));return children==this.children&&local==this.local?this:local.length||children.length?new DecorationSet(local,children):empty}
/**
    @internal
    */forChild(offset,node){if(this==empty)return this;if(node.isLeaf)return DecorationSet.empty;let child,local;for(let i=0;i<this.children.length;i+=3)if(this.children[i]>=offset){this.children[i]==offset&&(child=this.children[i+2]);break}let start=offset+1,end=start+node.content.size;for(let i=0;i<this.local.length;i++){let dec=this.local[i];if(dec.from<end&&dec.to>start&&dec.type instanceof InlineType){let from=Math.max(start,dec.from)-start,to=Math.min(end,dec.to)-start;from<to&&(local||(local=[])).push(dec.copy(from,to))}}if(local){let localSet=new DecorationSet(local.sort(byPos),none);return child?new DecorationGroup([localSet,child]):localSet}return child||empty}
/**
    @internal
    */eq(other){if(this==other)return!0;if(!(other instanceof DecorationSet)||this.local.length!=other.local.length||this.children.length!=other.children.length)return!1;for(let i=0;i<this.local.length;i++)if(!this.local[i].eq(other.local[i]))return!1;for(let i=0;i<this.children.length;i+=3)if(this.children[i]!=other.children[i]||this.children[i+1]!=other.children[i+1]||!this.children[i+2].eq(other.children[i+2]))return!1;return!0}
/**
    @internal
    */locals(node){return removeOverlap(this.localsInner(node))}
/**
    @internal
    */localsInner(node){if(this==empty)return none;if(node.inlineContent||!this.local.some(InlineType.is))return this.local;let result=[];for(let i=0;i<this.local.length;i++)this.local[i].type instanceof InlineType||result.push(this.local[i]);return result}}
/**
The empty set of decorations.
*/DecorationSet.empty=new DecorationSet([],[]),
/**
@internal
*/
DecorationSet.removeOverlap=removeOverlap;const empty=DecorationSet.empty;
// An abstraction that allows the code dealing with decorations to
// treat multiple DecorationSet objects as if it were a single object
// with (a subset of) the same interface.
class DecorationGroup{constructor(members){this.members=members}map(mapping,doc){const mappedDecos=this.members.map((member=>member.map(mapping,doc,noSpec)));return DecorationGroup.from(mappedDecos)}forChild(offset,child){if(child.isLeaf)return DecorationSet.empty;let found=[];for(let i=0;i<this.members.length;i++){let result=this.members[i].forChild(offset,child);result!=empty&&(result instanceof DecorationGroup?found=found.concat(result.members):found.push(result))}return DecorationGroup.from(found)}eq(other){if(!(other instanceof DecorationGroup)||other.members.length!=this.members.length)return!1;for(let i=0;i<this.members.length;i++)if(!this.members[i].eq(other.members[i]))return!1;return!0}locals(node){let result,sorted=!0;for(let i=0;i<this.members.length;i++){let locals=this.members[i].localsInner(node);if(locals.length)if(result){sorted&&(result=result.slice(),sorted=!1);for(let j=0;j<locals.length;j++)result.push(locals[j])}else result=locals}return result?removeOverlap(sorted?result:result.sort(byPos)):none}
// Create a group for the given array of decoration sets, or return
// a single set when possible.
static from(members){switch(members.length){case 0:return empty;case 1:return members[0];default:return new DecorationGroup(members.every((m=>m instanceof DecorationSet))?members:members.reduce(((r,m)=>r.concat(m instanceof DecorationSet?m:m.members)),[]))}}}function mapChildren(oldChildren,newLocal,mapping,node,offset,oldOffset,options){let children=oldChildren.slice();
// Mark the children that are directly touched by changes, and
// move those that are after the changes.
for(let i=0,baseOffset=oldOffset;i<mapping.maps.length;i++){let moved=0;mapping.maps[i].forEach(((oldStart,oldEnd,newStart,newEnd)=>{let dSize=newEnd-newStart-(oldEnd-oldStart);for(let i=0;i<children.length;i+=3){let end=children[i+1];if(end<0||oldStart>end+baseOffset-moved)continue;let start=children[i]+baseOffset-moved;oldEnd>=start?children[i+1]=oldStart<=start?-2:-1:newStart>=offset&&dSize&&(children[i]+=dSize,children[i+1]+=dSize)}moved+=dSize})),baseOffset=mapping.maps[i].map(baseOffset,-1)}
// Find the child nodes that still correspond to a single node,
// recursively call mapInner on them and update their positions.
let mustRebuild=!1;for(let i=0;i<children.length;i+=3)if(children[i+1]<0){// Touched nodes
if(-2==children[i+1]){mustRebuild=!0,children[i+1]=-1;continue}let from=mapping.map(oldChildren[i]+oldOffset),fromLocal=from-offset;if(fromLocal<0||fromLocal>=node.content.size){mustRebuild=!0;continue}
// Must read oldChildren because children was tagged with -1
let to=mapping.map(oldChildren[i+1]+oldOffset,-1),toLocal=to-offset,{index:index,offset:childOffset}=node.content.findIndex(fromLocal),childNode=node.maybeChild(index);if(childNode&&childOffset==fromLocal&&childOffset+childNode.nodeSize==toLocal){let mapped=children[i+2].mapInner(mapping,childNode,from+1,oldChildren[i]+oldOffset+1,options);mapped!=empty?(children[i]=fromLocal,children[i+1]=toLocal,children[i+2]=mapped):(children[i+1]=-2,mustRebuild=!0)}else mustRebuild=!0}
// Remaining children must be collected and rebuilt into the appropriate structure
if(mustRebuild){let decorations=mapAndGatherRemainingDecorations(children,oldChildren,newLocal,mapping,offset,oldOffset,options),built=buildTree(decorations,node,0,options);newLocal=built.local;for(let i=0;i<children.length;i+=3)children[i+1]<0&&(children.splice(i,3),i-=3);for(let i=0,j=0;i<built.children.length;i+=3){let from=built.children[i];while(j<children.length&&children[j]<from)j+=3;children.splice(j,0,built.children[i],built.children[i+1],built.children[i+2])}}return new DecorationSet(newLocal.sort(byPos),children)}function moveSpans(spans,offset){if(!offset||!spans.length)return spans;let result=[];for(let i=0;i<spans.length;i++){let span=spans[i];result.push(new Decoration(span.from+offset,span.to+offset,span.type))}return result}function mapAndGatherRemainingDecorations(children,oldChildren,decorations,mapping,offset,oldOffset,options){
// Gather all decorations from the remaining marked children
function gather(set,oldOffset){for(let i=0;i<set.local.length;i++){let mapped=set.local[i].map(mapping,offset,oldOffset);mapped?decorations.push(mapped):options.onRemove&&options.onRemove(set.local[i].spec)}for(let i=0;i<set.children.length;i+=3)gather(set.children[i+2],set.children[i]+oldOffset+1)}for(let i=0;i<children.length;i+=3)-1==children[i+1]&&gather(children[i+2],oldChildren[i]+oldOffset+1);return decorations}function takeSpansForNode(spans,node,offset){if(node.isLeaf)return null;let end=offset+node.nodeSize,found=null;for(let span,i=0;i<spans.length;i++)(span=spans[i])&&span.from>offset&&span.to<end&&((found||(found=[])).push(span),spans[i]=null);return found}function withoutNulls(array){let result=[];for(let i=0;i<array.length;i++)null!=array[i]&&result.push(array[i]);return result}
// Build up a tree that corresponds to a set of decorations. `offset`
// is a base offset that should be subtracted from the `from` and `to`
// positions in the spans (so that we don't have to allocate new spans
// for recursive calls).
function buildTree(spans,node,offset,options){let children=[],hasNulls=!1;node.forEach(((childNode,localStart)=>{let found=takeSpansForNode(spans,childNode,localStart+offset);if(found){hasNulls=!0;let subtree=buildTree(found,childNode,offset+localStart+1,options);subtree!=empty&&children.push(localStart,localStart+childNode.nodeSize,subtree)}}));let locals=moveSpans(hasNulls?withoutNulls(spans):spans,-offset).sort(byPos);for(let i=0;i<locals.length;i++)locals[i].type.valid(node,locals[i])||(options.onRemove&&options.onRemove(locals[i].spec),locals.splice(i--,1));return locals.length||children.length?new DecorationSet(locals,children):empty}
// Used to sort decorations so that ones with a low start position
// come first, and within a set with the same start position, those
// with an smaller end position come first.
function byPos(a,b){return a.from-b.from||a.to-b.to}
// Scan a sorted array of decorations for partially overlapping spans,
// and split those so that only fully overlapping spans are left (to
// make subsequent rendering easier). Will return the input array if
// no partially overlapping spans are found (the common case).
function removeOverlap(spans){let working=spans;for(let i=0;i<working.length-1;i++){let span=working[i];if(span.from!=span.to)for(let j=i+1;j<working.length;j++){let next=working[j];if(next.from!=span.from){next.from<span.to&&(working==spans&&(working=spans.slice()),
// The end of this one overlaps with a subsequent span. Split
// this one.
working[i]=span.copy(span.from,next.from),insertAhead(working,j,span.copy(next.from,span.to)));break}next.to!=span.to&&(working==spans&&(working=spans.slice()),
// Followed by a partially overlapping larger span. Split that
// span.
working[j]=next.copy(next.from,span.to),insertAhead(working,j+1,next.copy(span.to,next.to)))}}return working}function insertAhead(array,i,deco){while(i<array.length&&byPos(deco,array[i])>0)i++;array.splice(i,0,deco)}
// Get the decorations associated with the current props of a view.
function viewDecorations(view){let found=[];return view.someProp("decorations",(f=>{let result=f(view.state);result&&result!=empty&&found.push(result)})),view.cursorWrapper&&found.push(DecorationSet.create(view.state.doc,[view.cursorWrapper.deco])),DecorationGroup.from(found)}const observeOptions={childList:!0,characterData:!0,characterDataOldValue:!0,attributes:!0,attributeOldValue:!0,subtree:!0},useCharData=ie&&ie_version<=11;
// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified
class SelectionState{constructor(){this.anchorNode=null,this.anchorOffset=0,this.focusNode=null,this.focusOffset=0}set(sel){this.anchorNode=sel.anchorNode,this.anchorOffset=sel.anchorOffset,this.focusNode=sel.focusNode,this.focusOffset=sel.focusOffset}clear(){this.anchorNode=this.focusNode=null}eq(sel){return sel.anchorNode==this.anchorNode&&sel.anchorOffset==this.anchorOffset&&sel.focusNode==this.focusNode&&sel.focusOffset==this.focusOffset}}class DOMObserver{constructor(view,handleDOMChange){this.view=view,this.handleDOMChange=handleDOMChange,this.queue=[],this.flushingSoon=-1,this.observer=null,this.currentSelection=new SelectionState,this.onCharData=null,this.suppressingSelectionUpdates=!1,this.observer=window.MutationObserver&&new window.MutationObserver((mutations=>{for(let i=0;i<mutations.length;i++)this.queue.push(mutations[i]);
// IE11 will sometimes (on backspacing out a single character
// text node after a BR node) call the observer callback
// before actually updating the DOM, which will cause
// ProseMirror to miss the change (see #930)
ie&&ie_version<=11&&mutations.some((m=>"childList"==m.type&&m.removedNodes.length||"characterData"==m.type&&m.oldValue.length>m.target.nodeValue.length))?this.flushSoon():this.flush()})),useCharData&&(this.onCharData=e=>{this.queue.push({target:e.target,type:"characterData",oldValue:e.prevValue}),this.flushSoon()}),this.onSelectionChange=this.onSelectionChange.bind(this)}flushSoon(){this.flushingSoon<0&&(this.flushingSoon=window.setTimeout((()=>{this.flushingSoon=-1,this.flush()}),20))}forceFlush(){this.flushingSoon>-1&&(window.clearTimeout(this.flushingSoon),this.flushingSoon=-1,this.flush())}start(){this.observer&&(this.observer.takeRecords(),this.observer.observe(this.view.dom,observeOptions)),this.onCharData&&this.view.dom.addEventListener("DOMCharacterDataModified",this.onCharData),this.connectSelection()}stop(){if(this.observer){let take=this.observer.takeRecords();if(take.length){for(let i=0;i<take.length;i++)this.queue.push(take[i]);window.setTimeout((()=>this.flush()),20)}this.observer.disconnect()}this.onCharData&&this.view.dom.removeEventListener("DOMCharacterDataModified",this.onCharData),this.disconnectSelection()}connectSelection(){this.view.dom.ownerDocument.addEventListener("selectionchange",this.onSelectionChange)}disconnectSelection(){this.view.dom.ownerDocument.removeEventListener("selectionchange",this.onSelectionChange)}suppressSelectionUpdates(){this.suppressingSelectionUpdates=!0,setTimeout((()=>this.suppressingSelectionUpdates=!1),50)}onSelectionChange(){if(hasFocusAndSelection(this.view)){if(this.suppressingSelectionUpdates)return selectionToDOM(this.view);
// Deletions on IE11 fire their events in the wrong order, giving
// us a selection change event before the DOM changes are
// reported.
if(ie&&ie_version<=11&&!this.view.state.selection.empty){let sel=this.view.domSelectionRange();
// Selection.isCollapsed isn't reliable on IE
if(sel.focusNode&&isEquivalentPosition(sel.focusNode,sel.focusOffset,sel.anchorNode,sel.anchorOffset))return this.flushSoon()}this.flush()}}setCurSelection(){this.currentSelection.set(this.view.domSelectionRange())}ignoreSelectionChange(sel){if(!sel.focusNode)return!0;let container,ancestors=new Set;for(let scan=sel.focusNode;scan;scan=parentNode(scan))ancestors.add(scan);for(let scan=sel.anchorNode;scan;scan=parentNode(scan))if(ancestors.has(scan)){container=scan;break}let desc=container&&this.view.docView.nearestDesc(container);return desc&&desc.ignoreMutation({type:"selection",target:3==container.nodeType?container.parentNode:container})?(this.setCurSelection(),!0):void 0}pendingRecords(){if(this.observer)for(let mut of this.observer.takeRecords())this.queue.push(mut);return this.queue}flush(){let{view:view}=this;if(!view.docView||this.flushingSoon>-1)return;let mutations=this.pendingRecords();mutations.length&&(this.queue=[]);let sel=view.domSelectionRange(),newSel=!this.suppressingSelectionUpdates&&!this.currentSelection.eq(sel)&&hasFocusAndSelection(view)&&!this.ignoreSelectionChange(sel),from=-1,to=-1,typeOver=!1,added=[];if(view.editable)for(let i=0;i<mutations.length;i++){let result=this.registerMutation(mutations[i],added);result&&(from=from<0?result.from:Math.min(result.from,from),to=to<0?result.to:Math.max(result.to,to),result.typeOver&&(typeOver=!0))}if(gecko&&added.length>1){let brs=added.filter((n=>"BR"==n.nodeName));if(2==brs.length){let a=brs[0],b=brs[1];a.parentNode&&a.parentNode.parentNode==b.parentNode?b.remove():a.remove()}}let readSel=null;
// If it looks like the browser has reset the selection to the
// start of the document after focus, restore the selection from
// the state
from<0&&newSel&&view.input.lastFocus>Date.now()-200&&Math.max(view.input.lastTouch,view.input.lastClick.time)<Date.now()-300&&selectionCollapsed(sel)&&(readSel=selectionFromDOM(view))&&readSel.eq(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .Selection */.Y1.near(view.state.doc.resolve(0),1))?(view.input.lastFocus=0,selectionToDOM(view),this.currentSelection.set(sel),view.scrollToSelection()):(from>-1||newSel)&&(from>-1&&(view.docView.markDirty(from,to),checkCSS(view)),this.handleDOMChange(from,to,typeOver,added),view.docView&&view.docView.dirty?view.updateState(view.state):this.currentSelection.eq(sel)||selectionToDOM(view),this.currentSelection.set(sel))}registerMutation(mut,added){
// Ignore mutations inside nodes that were already noted as inserted
if(added.indexOf(mut.target)>-1)return null;let desc=this.view.docView.nearestDesc(mut.target);if("attributes"==mut.type&&(desc==this.view.docView||"contenteditable"==mut.attributeName||
// Firefox sometimes fires spurious events for null/empty styles
"style"==mut.attributeName&&!mut.oldValue&&!mut.target.getAttribute("style")))return null;if(!desc||desc.ignoreMutation(mut))return null;if("childList"==mut.type){for(let i=0;i<mut.addedNodes.length;i++)added.push(mut.addedNodes[i]);if(desc.contentDOM&&desc.contentDOM!=desc.dom&&!desc.contentDOM.contains(mut.target))return{from:desc.posBefore,to:desc.posAfter};let prev=mut.previousSibling,next=mut.nextSibling;if(ie&&ie_version<=11&&mut.addedNodes.length)
// IE11 gives us incorrect next/prev siblings for some
// insertions, so if there are added nodes, recompute those
for(let i=0;i<mut.addedNodes.length;i++){let{previousSibling:previousSibling,nextSibling:nextSibling}=mut.addedNodes[i];(!previousSibling||Array.prototype.indexOf.call(mut.addedNodes,previousSibling)<0)&&(prev=previousSibling),(!nextSibling||Array.prototype.indexOf.call(mut.addedNodes,nextSibling)<0)&&(next=nextSibling)}let fromOffset=prev&&prev.parentNode==mut.target?domIndex(prev)+1:0,from=desc.localPosFromDOM(mut.target,fromOffset,-1),toOffset=next&&next.parentNode==mut.target?domIndex(next):mut.target.childNodes.length,to=desc.localPosFromDOM(mut.target,toOffset,1);return{from:from,to:to}}return"attributes"==mut.type?{from:desc.posAtStart-desc.border,to:desc.posAtEnd+desc.border}:{from:desc.posAtStart,to:desc.posAtEnd,
// An event was generated for a text change that didn't change
// any text. Mark the dom change to fall back to assuming the
// selection was typed over with an identical value if it can't
// find another change.
typeOver:mut.target.nodeValue==mut.oldValue}}}let cssChecked=new WeakMap,cssCheckWarned=!1;function checkCSS(view){if(!cssChecked.has(view)&&(cssChecked.set(view,null),-1!==["normal","nowrap","pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace))){if(view.requiresGeckoHackNode=gecko,cssCheckWarned)return;cssCheckWarned=!0}}
// Used to work around a Safari Selection/shadow DOM bug
// Based on https://github.com/codemirror/dev/issues/414 fix
function safariShadowSelectionRange(view){let found;function read(event){event.preventDefault(),event.stopImmediatePropagation(),found=event.getTargetRanges()[0]}
// Because Safari (at least in 2018-2022) doesn't provide regular
// access to the selection inside a shadowRoot, we have to perform a
// ridiculous hack to get at it—using `execCommand` to trigger a
// `beforeInput` event so that we can read the target range from the
// event.
view.dom.addEventListener("beforeinput",read,!0),document.execCommand("indent"),view.dom.removeEventListener("beforeinput",read,!0);let anchorNode=found.startContainer,anchorOffset=found.startOffset,focusNode=found.endContainer,focusOffset=found.endOffset,currentAnchor=view.domAtPos(view.state.selection.anchor);
// Since such a range doesn't distinguish between anchor and head,
// use a heuristic that flips it around if its end matches the
// current anchor.
return isEquivalentPosition(currentAnchor.node,currentAnchor.offset,focusNode,focusOffset)&&([anchorNode,anchorOffset,focusNode,focusOffset]=[focusNode,focusOffset,anchorNode,anchorOffset]),{anchorNode:anchorNode,anchorOffset:anchorOffset,focusNode:focusNode,focusOffset:focusOffset}}
// Note that all referencing and parsing is done with the
// start-of-operation selection and document, since that's the one
// that the DOM represents. If any changes came in in the meantime,
// the modification is mapped over those before it is applied, in
// readDOMChange.
function parseBetween(view,from_,to_){let find,{node:parent,fromOffset:fromOffset,toOffset:toOffset,from:from,to:to}=view.docView.parseRange(from_,to_),domSel=view.domSelectionRange(),anchor=domSel.anchorNode;
// Work around issue in Chrome where backspacing sometimes replaces
// the deleted content with a random BR node (issues #799, #831)
if(anchor&&view.dom.contains(1==anchor.nodeType?anchor:anchor.parentNode)&&(find=[{node:anchor,offset:domSel.anchorOffset}],selectionCollapsed(domSel)||find.push({node:domSel.focusNode,offset:domSel.focusOffset})),chrome&&8===view.input.lastKeyCode)for(let off=toOffset;off>fromOffset;off--){let node=parent.childNodes[off-1],desc=node.pmViewDesc;if("BR"==node.nodeName&&!desc){toOffset=off;break}if(!desc||desc.size)break}let startDoc=view.state.doc,parser=view.someProp("domParser")||prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .DOMParser */.aw.fromSchema(view.state.schema),$from=startDoc.resolve(from),sel=null,doc=parser.parse(parent,{topNode:$from.parent,topMatch:$from.parent.contentMatchAt($from.index()),topOpen:!0,from:fromOffset,to:toOffset,preserveWhitespace:"pre"!=$from.parent.type.whitespace||"full",findPositions:find,ruleFromNode:ruleFromNode,context:$from});if(find&&null!=find[0].pos){let anchor=find[0].pos,head=find[1]&&find[1].pos;null==head&&(head=anchor),sel={anchor:anchor+from,head:head+from}}return{doc:doc,sel:sel,from:from,to:to}}function ruleFromNode(dom){let desc=dom.pmViewDesc;if(desc)return desc.parseRule();if("BR"==dom.nodeName&&dom.parentNode){
// Safari replaces the list item or table cell with a BR
// directly in the list node (?!) if you delete the last
// character in a list item or table cell (#708, #862)
if(safari&&/^(ul|ol)$/i.test(dom.parentNode.nodeName)){let skip=document.createElement("div");return skip.appendChild(document.createElement("li")),{skip:skip}}if(dom.parentNode.lastChild==dom||safari&&/^(tr|table)$/i.test(dom.parentNode.nodeName))return{ignore:!0}}else if("IMG"==dom.nodeName&&dom.getAttribute("mark-placeholder"))return{ignore:!0};return null}const isInline=/^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;function readDOMChange(view,from,to,typeOver,addedNodes){let compositionID=view.input.compositionPendingChanges||(view.composing?view.input.compositionID:0);if(view.input.compositionPendingChanges=0,from<0){let origin=view.input.lastSelectionTime>Date.now()-50?view.input.lastSelectionOrigin:null,newSel=selectionFromDOM(view,origin);if(newSel&&!view.state.selection.eq(newSel)){if(chrome&&android&&13===view.input.lastKeyCode&&Date.now()-100<view.input.lastKeyCodeTime&&view.someProp("handleKeyDown",(f=>f(view,keyEvent(13,"Enter")))))return;let tr=view.state.tr.setSelection(newSel);"pointer"==origin?tr.setMeta("pointer",!0):"key"==origin&&tr.scrollIntoView(),compositionID&&tr.setMeta("composition",compositionID),view.dispatch(tr)}return}let $before=view.state.doc.resolve(from),shared=$before.sharedDepth(to);from=$before.before(shared+1),to=view.state.doc.resolve(to).after(shared+1);let preferredPos,preferredSide,sel=view.state.selection,parse=parseBetween(view,from,to),doc=view.state.doc,compare=doc.slice(parse.from,parse.to);
// Prefer anchoring to end when Backspace is pressed
8===view.input.lastKeyCode&&Date.now()-100<view.input.lastKeyCodeTime?(preferredPos=view.state.selection.to,preferredSide="end"):(preferredPos=view.state.selection.from,preferredSide="start"),view.input.lastKeyCode=null;let change=findDiff(compare.content,parse.doc.content,parse.from,preferredPos,preferredSide);if((ios&&view.input.lastIOSEnter>Date.now()-225||android)&&addedNodes.some((n=>1==n.nodeType&&!isInline.test(n.nodeName)))&&(!change||change.endA>=change.endB)&&view.someProp("handleKeyDown",(f=>f(view,keyEvent(13,"Enter")))))return void(view.input.lastIOSEnter=0);if(!change){if(!(typeOver&&sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .TextSelection */.Bs&&!sel.empty&&sel.$head.sameParent(sel.$anchor))||view.composing||parse.sel&&parse.sel.anchor!=parse.sel.head){if(parse.sel){let sel=resolveSelection(view,view.state.doc,parse.sel);if(sel&&!sel.eq(view.state.selection)){let tr=view.state.tr.setSelection(sel);compositionID&&tr.setMeta("composition",compositionID),view.dispatch(tr)}}return}change={start:sel.from,endA:sel.to,endB:sel.to}}
// Chrome sometimes leaves the cursor before the inserted text when
// composing after a cursor wrapper. This moves it forward.
if(chrome&&view.cursorWrapper&&parse.sel&&parse.sel.anchor==view.cursorWrapper.deco.from&&parse.sel.head==parse.sel.anchor){let size=change.endB-change.start;parse.sel={anchor:parse.sel.anchor+size,head:parse.sel.anchor+size}}view.input.domChangeCount++,
// Handle the case where overwriting a selection by typing matches
// the start or end of the selected content, creating a change
// that's smaller than what was actually overwritten.
view.state.selection.from<view.state.selection.to&&change.start==change.endB&&view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .TextSelection */.Bs&&(change.start>view.state.selection.from&&change.start<=view.state.selection.from+2&&view.state.selection.from>=parse.from?change.start=view.state.selection.from:change.endA<view.state.selection.to&&change.endA>=view.state.selection.to-2&&view.state.selection.to<=parse.to&&(change.endB+=view.state.selection.to-change.endA,change.endA=view.state.selection.to)),
// IE11 will insert a non-breaking space _ahead_ of the space after
// the cursor space when adding a space before another space. When
// that happened, adjust the change to cover the space instead.
ie&&ie_version<=11&&change.endB==change.start+1&&change.endA==change.start&&change.start>parse.from&&"  "==parse.doc.textBetween(change.start-parse.from-1,change.start-parse.from+1)&&(change.start--,change.endA--,change.endB--);let nextSel,$from=parse.doc.resolveNoCache(change.start-parse.from),$to=parse.doc.resolveNoCache(change.endB-parse.from),$fromA=doc.resolve(change.start),inlineChange=$from.sameParent($to)&&$from.parent.inlineContent&&$fromA.end()>=change.endA;
// If this looks like the effect of pressing Enter (or was recorded
// as being an iOS enter press), just dispatch an Enter key instead.
if((ios&&view.input.lastIOSEnter>Date.now()-225&&(!inlineChange||addedNodes.some((n=>"DIV"==n.nodeName||"P"==n.nodeName)))||!inlineChange&&$from.pos<parse.doc.content.size&&!$from.sameParent($to)&&(nextSel=prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .Selection */.Y1.findFrom(parse.doc.resolve($from.pos+1),1,!0))&&nextSel.head==$to.pos)&&view.someProp("handleKeyDown",(f=>f(view,keyEvent(13,"Enter")))))return void(view.input.lastIOSEnter=0);
// Same for backspace
if(view.state.selection.anchor>change.start&&looksLikeJoin(doc,change.start,change.endA,$from,$to)&&view.someProp("handleKeyDown",(f=>f(view,keyEvent(8,"Backspace")))))// #820
return void(android&&chrome&&view.domObserver.suppressSelectionUpdates());
// Chrome Android will occasionally, during composition, delete the
// entire composition and then immediately insert it again. This is
// used to detect that situation.
chrome&&android&&change.endB==change.start&&(view.input.lastAndroidDelete=Date.now()),
// This tries to detect Android virtual keyboard
// enter-and-pick-suggestion action. That sometimes (see issue
// #1059) first fires a DOM mutation, before moving the selection to
// the newly created block. And then, because ProseMirror cleans up
// the DOM selection, it gives up moving the selection entirely,
// leaving the cursor in the wrong place. When that happens, we drop
// the new paragraph from the initial change, and fire a simulated
// enter key afterwards.
android&&!inlineChange&&$from.start()!=$to.start()&&0==$to.parentOffset&&$from.depth==$to.depth&&parse.sel&&parse.sel.anchor==parse.sel.head&&parse.sel.head==change.endA&&(change.endB-=2,$to=parse.doc.resolveNoCache(change.endB-parse.from),setTimeout((()=>{view.someProp("handleKeyDown",(function(f){return f(view,keyEvent(13,"Enter"))}))}),20));let tr,storedMarks,markChange,chFrom=change.start,chTo=change.endA;if(inlineChange)if($from.pos==$to.pos)// Deletion
// IE11 sometimes weirdly moves the DOM selection around after
// backspacing out the first element in a textblock
ie&&ie_version<=11&&0==$from.parentOffset&&(view.domObserver.suppressSelectionUpdates(),setTimeout((()=>selectionToDOM(view)),20)),tr=view.state.tr.delete(chFrom,chTo),storedMarks=doc.resolve(change.start).marksAcross(doc.resolve(change.endA));else if(// Adding or removing a mark
change.endA==change.endB&&(markChange=isMarkChange($from.parent.content.cut($from.parentOffset,$to.parentOffset),$fromA.parent.content.cut($fromA.parentOffset,change.endA-$fromA.start()))))tr=view.state.tr,"add"==markChange.type?tr.addMark(chFrom,chTo,markChange.mark):tr.removeMark(chFrom,chTo,markChange.mark);else if($from.parent.child($from.index()).isText&&$from.index()==$to.index()-($to.textOffset?0:1)){
// Both positions in the same text node -- simply insert text
let text=$from.parent.textBetween($from.parentOffset,$to.parentOffset);if(view.someProp("handleTextInput",(f=>f(view,chFrom,chTo,text))))return;tr=view.state.tr.insertText(text,chFrom,chTo)}if(tr||(tr=view.state.tr.replace(chFrom,chTo,parse.doc.slice(change.start-parse.from,change.endB-parse.from))),parse.sel){let sel=resolveSelection(view,tr.doc,parse.sel);
// Chrome Android will sometimes, during composition, report the
// selection in the wrong place. If it looks like that is
// happening, don't update the selection.
// Edge just doesn't move the cursor forward when you start typing
// in an empty block or between br nodes.
sel&&!(chrome&&android&&view.composing&&sel.empty&&(change.start!=change.endB||view.input.lastAndroidDelete<Date.now()-100)&&(sel.head==chFrom||sel.head==tr.mapping.map(chTo)-1)||ie&&sel.empty&&sel.head==chFrom)&&tr.setSelection(sel)}storedMarks&&tr.ensureMarks(storedMarks),compositionID&&tr.setMeta("composition",compositionID),view.dispatch(tr.scrollIntoView())}function resolveSelection(view,doc,parsedSel){return Math.max(parsedSel.anchor,parsedSel.head)>doc.content.size?null:selectionBetween(view,doc.resolve(parsedSel.anchor),doc.resolve(parsedSel.head))}
// Given two same-length, non-empty fragments of inline content,
// determine whether the first could be created from the second by
// removing or adding a single mark type.
function isMarkChange(cur,prev){let type,mark,update,curMarks=cur.firstChild.marks,prevMarks=prev.firstChild.marks,added=curMarks,removed=prevMarks;for(let i=0;i<prevMarks.length;i++)added=prevMarks[i].removeFromSet(added);for(let i=0;i<curMarks.length;i++)removed=curMarks[i].removeFromSet(removed);if(1==added.length&&0==removed.length)mark=added[0],type="add",update=node=>node.mark(mark.addToSet(node.marks));else{if(0!=added.length||1!=removed.length)return null;mark=removed[0],type="remove",update=node=>node.mark(mark.removeFromSet(node.marks))}let updated=[];for(let i=0;i<prev.childCount;i++)updated.push(update(prev.child(i)));if(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */.HY.from(updated).eq(cur))return{mark:mark,type:type}}function looksLikeJoin(old,start,end,$newStart,$newEnd){if(!$newStart.parent.isTextblock||
// The content must have shrunk
end-start<=$newEnd.pos-$newStart.pos||
// newEnd must point directly at or after the end of the block that newStart points into
skipClosingAndOpening($newStart,!0,!1)<$newEnd.pos)return!1;let $start=old.resolve(start);
// Start must be at the end of a block
if($start.parentOffset<$start.parent.content.size||!$start.parent.isTextblock)return!1;let $next=old.resolve(skipClosingAndOpening($start,!0,!0));
// The next textblock must start before end and end near it
return!(!$next.parent.isTextblock||$next.pos>end||skipClosingAndOpening($next,!0,!1)<end)&&$newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
// The fragments after the join point must match
}function skipClosingAndOpening($pos,fromEnd,mayOpen){let depth=$pos.depth,end=fromEnd?$pos.end():$pos.pos;while(depth>0&&(fromEnd||$pos.indexAfter(depth)==$pos.node(depth).childCount))depth--,end++,fromEnd=!1;if(mayOpen){let next=$pos.node(depth).maybeChild($pos.indexAfter(depth));while(next&&!next.isLeaf)next=next.firstChild,end++}return end}function findDiff(a,b,pos,preferredPos,preferredSide){let start=a.findDiffStart(b,pos);if(null==start)return null;let{a:endA,b:endB}=a.findDiffEnd(b,pos+a.size,pos+b.size);if("end"==preferredSide){let adjust=Math.max(0,start-Math.min(endA,endB));preferredPos-=endA+adjust-start}if(endA<start&&a.size<b.size){let move=preferredPos<=start&&preferredPos>=endA?start-preferredPos:0;start-=move,endB=start+(endB-endA),endA=start}else if(endB<start){let move=preferredPos<=start&&preferredPos>=endB?start-preferredPos:0;start-=move,endA=start+(endA-endB),endB=start}return{start:start,endA:endA,endB:endB}}
/**
@internal
*/
/**
An editor view manages the DOM structure that represents an
editable document. Its state and behavior are determined by its
[props](https://prosemirror.net/docs/ref/#view.DirectEditorProps).
*/
class EditorView{
/**
    Create a view. `place` may be a DOM node that the editor should
    be appended to, a function that will place it into the document,
    or an object whose `mount` property holds the node to use as the
    document container. If it is `null`, the editor will not be
    added to the document.
    */
constructor(place,props){this._root=null,
/**
        @internal
        */
this.focused=!1,
/**
        Kludge used to work around a Chrome bug @internal
        */
this.trackWrites=null,this.mounted=!1,
/**
        @internal
        */
this.markCursor=null,
/**
        @internal
        */
this.cursorWrapper=null,
/**
        @internal
        */
this.lastSelectedViewDesc=void 0,
/**
        @internal
        */
this.input=new InputState,this.prevDirectPlugins=[],this.pluginViews=[],
/**
        Holds `true` when a hack node is needed in Firefox to prevent the
        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
        @internal
        */
this.requiresGeckoHackNode=!1,
/**
        When editor content is being dragged, this object contains
        information about the dragged slice and whether it is being
        copied or moved. At any other time, it is null.
        */
this.dragging=null,this._props=props,this.state=props.state,this.directPlugins=props.plugins||[],this.directPlugins.forEach(checkStateComponent),this.dispatch=this.dispatch.bind(this),this.dom=place&&place.mount||document.createElement("div"),place&&(place.appendChild?place.appendChild(this.dom):"function"==typeof place?place(this.dom):place.mount&&(this.mounted=!0)),this.editable=getEditable(this),updateCursorWrapper(this),this.nodeViews=buildNodeViews(this),this.docView=docViewDesc(this.state.doc,computeDocDeco(this),viewDecorations(this),this.dom,this),this.domObserver=new DOMObserver(this,((from,to,typeOver,added)=>readDOMChange(this,from,to,typeOver,added))),this.domObserver.start(),initInput(this),this.updatePluginViews()}
/**
    Holds `true` when a
    [composition](https://w3c.github.io/uievents/#events-compositionevents)
    is active.
    */get composing(){return this.input.composing}
/**
    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
    */get props(){if(this._props.state!=this.state){let prev=this._props;this._props={};for(let name in prev)this._props[name]=prev[name];this._props.state=this.state}return this._props}
/**
    Update the view's props. Will immediately cause an update to
    the DOM.
    */update(props){props.handleDOMEvents!=this._props.handleDOMEvents&&ensureListeners(this);let prevProps=this._props;this._props=props,props.plugins&&(props.plugins.forEach(checkStateComponent),this.directPlugins=props.plugins),this.updateStateInner(props.state,prevProps)}
/**
    Update the view by updating existing props object with the object
    given as argument. Equivalent to `view.update(Object.assign({},
    view.props, props))`.
    */setProps(props){let updated={};for(let name in this._props)updated[name]=this._props[name];updated.state=this.state;for(let name in props)updated[name]=props[name];this.update(updated)}
/**
    Update the editor's `state` prop, without touching any of the
    other props.
    */updateState(state){this.updateStateInner(state,this._props)}updateStateInner(state,prevProps){let prev=this.state,redraw=!1,updateSel=!1;
// When stored marks are added, stop composition, so that they can
// be displayed.
state.storedMarks&&this.composing&&(clearComposition(this),updateSel=!0),this.state=state;let pluginsChanged=prev.plugins!=state.plugins||this._props.plugins!=prevProps.plugins;if(pluginsChanged||this._props.plugins!=prevProps.plugins||this._props.nodeViews!=prevProps.nodeViews){let nodeViews=buildNodeViews(this);changedNodeViews(nodeViews,this.nodeViews)&&(this.nodeViews=nodeViews,redraw=!0)}(pluginsChanged||prevProps.handleDOMEvents!=this._props.handleDOMEvents)&&ensureListeners(this),this.editable=getEditable(this),updateCursorWrapper(this);let innerDeco=viewDecorations(this),outerDeco=computeDocDeco(this),scroll=prev.plugins==state.plugins||prev.doc.eq(state.doc)?state.scrollToSelection>prev.scrollToSelection?"to selection":"preserve":"reset",updateDoc=redraw||!this.docView.matchesNode(state.doc,outerDeco,innerDeco);!updateDoc&&state.selection.eq(prev.selection)||(updateSel=!0);let oldScrollPos="preserve"==scroll&&updateSel&&null==this.dom.style.overflowAnchor&&storeScrollPos(this);if(updateSel){this.domObserver.stop();
// Work around an issue in Chrome, IE, and Edge where changing
// the DOM around an active selection puts it into a broken
// state where the thing the user sees differs from the
// selection reported by the Selection object (#710, #973,
// #1011, #1013, #1035).
let forceSelUpdate=updateDoc&&(ie||chrome)&&!this.composing&&!prev.selection.empty&&!state.selection.empty&&selectionContextChanged(prev.selection,state.selection);if(updateDoc){
// If the node that the selection points into is written to,
// Chrome sometimes starts misreporting the selection, so this
// tracks that and forces a selection reset when our update
// did write to the node.
let chromeKludge=chrome?this.trackWrites=this.domSelectionRange().focusNode:null;!redraw&&this.docView.update(state.doc,outerDeco,innerDeco,this)||(this.docView.updateOuterDeco([]),this.docView.destroy(),this.docView=docViewDesc(state.doc,outerDeco,innerDeco,this.dom,this)),chromeKludge&&!this.trackWrites&&(forceSelUpdate=!0)}
// Work around for an issue where an update arriving right between
// a DOM selection change and the "selectionchange" event for it
// can cause a spurious DOM selection update, disrupting mouse
// drag selection.
forceSelUpdate||!(this.input.mouseDown&&this.domObserver.currentSelection.eq(this.domSelectionRange())&&anchorInRightPlace(this))?selectionToDOM(this,forceSelUpdate):(syncNodeSelection(this,state.selection),this.domObserver.setCurSelection()),this.domObserver.start()}this.updatePluginViews(prev),"reset"==scroll?this.dom.scrollTop=0:"to selection"==scroll?this.scrollToSelection():oldScrollPos&&resetScrollPos(oldScrollPos)}
/**
    @internal
    */scrollToSelection(){let startDOM=this.domSelectionRange().focusNode;if(this.someProp("handleScrollToSelection",(f=>f(this))));else if(this.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__/* .NodeSelection */.qv){let target=this.docView.domAfterPos(this.state.selection.from);1==target.nodeType&&scrollRectIntoView(this,target.getBoundingClientRect(),startDOM)}else scrollRectIntoView(this,this.coordsAtPos(this.state.selection.head,1),startDOM)}destroyPluginViews(){let view;while(view=this.pluginViews.pop())view.destroy&&view.destroy()}updatePluginViews(prevState){if(prevState&&prevState.plugins==this.state.plugins&&this.directPlugins==this.prevDirectPlugins)for(let i=0;i<this.pluginViews.length;i++){let pluginView=this.pluginViews[i];pluginView.update&&pluginView.update(this,prevState)}else{this.prevDirectPlugins=this.directPlugins,this.destroyPluginViews();for(let i=0;i<this.directPlugins.length;i++){let plugin=this.directPlugins[i];plugin.spec.view&&this.pluginViews.push(plugin.spec.view(this))}for(let i=0;i<this.state.plugins.length;i++){let plugin=this.state.plugins[i];plugin.spec.view&&this.pluginViews.push(plugin.spec.view(this))}}}someProp(propName,f){let value,prop=this._props&&this._props[propName];if(null!=prop&&(value=f?f(prop):prop))return value;for(let i=0;i<this.directPlugins.length;i++){let prop=this.directPlugins[i].props[propName];if(null!=prop&&(value=f?f(prop):prop))return value}let plugins=this.state.plugins;if(plugins)for(let i=0;i<plugins.length;i++){let prop=plugins[i].props[propName];if(null!=prop&&(value=f?f(prop):prop))return value}}
/**
    Query whether the view has focus.
    */hasFocus(){
// Work around IE not handling focus correctly if resize handles are shown.
// If the cursor is inside an element with resize handles, activeElement
// will be that element instead of this.dom.
if(ie){
// If activeElement is within this.dom, and there are no other elements
// setting `contenteditable` to false in between, treat it as focused.
let node=this.root.activeElement;if(node==this.dom)return!0;if(!node||!this.dom.contains(node))return!1;while(node&&this.dom!=node&&this.dom.contains(node)){if("false"==node.contentEditable)return!1;node=node.parentElement}return!0}return this.root.activeElement==this.dom}
/**
    Focus the editor.
    */focus(){this.domObserver.stop(),this.editable&&focusPreventScroll(this.dom),selectionToDOM(this),this.domObserver.start()}
/**
    Get the document root in which the editor exists. This will
    usually be the top-level `document`, but might be a [shadow
    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
    root if the editor is inside one.
    */get root(){let cached=this._root;if(null==cached)for(let search=this.dom.parentNode;search;search=search.parentNode)if(9==search.nodeType||11==search.nodeType&&search.host)return search.getSelection||(Object.getPrototypeOf(search).getSelection=()=>search.ownerDocument.getSelection()),this._root=search;return cached||document}
/**
    When an existing editor view is moved to a new document or
    shadow tree, call this to make it recompute its root.
    */updateRoot(){this._root=null}
/**
    Given a pair of viewport coordinates, return the document
    position that corresponds to them. May return null if the given
    coordinates aren't inside of the editor. When an object is
    returned, its `pos` property is the position nearest to the
    coordinates, and its `inside` property holds the position of the
    inner node that the position falls inside of, or -1 if it is at
    the top level, not in any node.
    */posAtCoords(coords){return posAtCoords(this,coords)}
/**
    Returns the viewport rectangle at a given document position.
    `left` and `right` will be the same number, as this returns a
    flat cursor-ish rectangle. If the position is between two things
    that aren't directly adjacent, `side` determines which element
    is used. When < 0, the element before the position is used,
    otherwise the element after.
    */coordsAtPos(pos,side=1){return coordsAtPos(this,pos,side)}
/**
    Find the DOM position that corresponds to the given document
    position. When `side` is negative, find the position as close as
    possible to the content before the position. When positive,
    prefer positions close to the content after the position. When
    zero, prefer as shallow a position as possible.
    
    Note that you should **not** mutate the editor's internal DOM,
    only inspect it (and even that is usually not necessary).
    */domAtPos(pos,side=0){return this.docView.domFromPos(pos,side)}
/**
    Find the DOM node that represents the document node after the
    given position. May return `null` when the position doesn't point
    in front of a node or if the node is inside an opaque node view.
    
    This is intended to be able to call things like
    `getBoundingClientRect` on that DOM node. Do **not** mutate the
    editor DOM directly, or add styling this way, since that will be
    immediately overriden by the editor as it redraws the node.
    */nodeDOM(pos){let desc=this.docView.descAt(pos);return desc?desc.nodeDOM:null}
/**
    Find the document position that corresponds to a given DOM
    position. (Whenever possible, it is preferable to inspect the
    document structure directly, rather than poking around in the
    DOM, but sometimes—for example when interpreting an event
    target—you don't have a choice.)
    
    The `bias` parameter can be used to influence which side of a DOM
    node to use when the position is inside a leaf node.
    */posAtDOM(node,offset,bias=-1){let pos=this.docView.posFromDOM(node,offset,bias);if(null==pos)throw new RangeError("DOM position not inside the editor");return pos}
/**
    Find out whether the selection is at the end of a textblock when
    moving in a given direction. When, for example, given `"left"`,
    it will return true if moving left from the current cursor
    position would leave that position's parent textblock. Will apply
    to the view's current state by default, but it is possible to
    pass a different state.
    */endOfTextblock(dir,state){return endOfTextblock(this,state||this.state,dir)}
/**
    Run the editor's paste logic with the given HTML string. The
    `event`, if given, will be passed to the
    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
    */pasteHTML(html,event){return doPaste(this,"",html,!1,event||new ClipboardEvent("paste"))}
/**
    Run the editor's paste logic with the given plain-text input.
    */pasteText(text,event){return doPaste(this,text,null,!0,event||new ClipboardEvent("paste"))}
/**
    Removes the editor from the DOM and destroys all [node
    views](https://prosemirror.net/docs/ref/#view.NodeView).
    */destroy(){this.docView&&(destroyInput(this),this.destroyPluginViews(),this.mounted?(this.docView.update(this.state.doc,[],viewDecorations(this),this),this.dom.textContent=""):this.dom.parentNode&&this.dom.parentNode.removeChild(this.dom),this.docView.destroy(),this.docView=null)}
/**
    This is true when the view has been
    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
    used anymore).
    */get isDestroyed(){return null==this.docView}
/**
    Used for testing.
    */dispatchEvent(event){return dispatchEvent(this,event)}
/**
    Dispatch a transaction. Will call
    [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
    when given, and otherwise defaults to applying the transaction to
    the current state and calling
    [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
    This method is bound to the view instance, so that it can be
    easily passed around.
    */dispatch(tr){let dispatchTransaction=this._props.dispatchTransaction;dispatchTransaction?dispatchTransaction.call(this,tr):this.updateState(this.state.apply(tr))}
/**
    @internal
    */domSelectionRange(){return safari&&11===this.root.nodeType&&deepActiveElement(this.dom.ownerDocument)==this.dom?safariShadowSelectionRange(this):this.domSelection()}
/**
    @internal
    */domSelection(){return this.root.getSelection()}}function computeDocDeco(view){let attrs=Object.create(null);return attrs.class="ProseMirror",attrs.contenteditable=String(view.editable),view.someProp("attributes",(value=>{if("function"==typeof value&&(value=value(view.state)),value)for(let attr in value)"class"==attr?attrs.class+=" "+value[attr]:"style"==attr?attrs.style=(attrs.style?attrs.style+";":"")+value[attr]:attrs[attr]||"contenteditable"==attr||"nodeName"==attr||(attrs[attr]=String(value[attr]))})),attrs.translate||(attrs.translate="no"),[Decoration.node(0,view.state.doc.content.size,attrs)]}function updateCursorWrapper(view){if(view.markCursor){let dom=document.createElement("img");dom.className="ProseMirror-separator",dom.setAttribute("mark-placeholder","true"),dom.setAttribute("alt",""),view.cursorWrapper={dom:dom,deco:Decoration.widget(view.state.selection.head,dom,{raw:!0,marks:view.markCursor})}}else view.cursorWrapper=null}function getEditable(view){return!view.someProp("editable",(value=>!1===value(view.state)))}function selectionContextChanged(sel1,sel2){let depth=Math.min(sel1.$anchor.sharedDepth(sel1.head),sel2.$anchor.sharedDepth(sel2.head));return sel1.$anchor.start(depth)!=sel2.$anchor.start(depth)}function buildNodeViews(view){let result=Object.create(null);function add(obj){for(let prop in obj)Object.prototype.hasOwnProperty.call(result,prop)||(result[prop]=obj[prop])}return view.someProp("nodeViews",add),view.someProp("markViews",add),result}function changedNodeViews(a,b){let nA=0,nB=0;for(let prop in a){if(a[prop]!=b[prop])return!0;nA++}for(let _ in b)nB++;return nA!=nB}function checkStateComponent(plugin){if(plugin.spec.state||plugin.spec.filterTransaction||plugin.spec.appendTransaction)throw new RangeError("Plugins passed directly to the view must not have a state component")}
/***/}}]);
//# sourceMappingURL=http://localhost:5050/sourcemaps/js/chunk-common-fa70753b.js.map