(self["webpackChunkfacilio_web"]=self["webpackChunkfacilio_web"]||[]).push([[91853],{
/***/102650:
/***/function(module){function webpackEmptyAsyncContext(req){
// Here Promise.resolve().then() is used instead of new Promise() to prevent
// uncaught exception popping up in devtools
return Promise.resolve().then((function(){var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}))}webpackEmptyAsyncContext.keys=function(){return[]},webpackEmptyAsyncContext.resolve=webpackEmptyAsyncContext,webpackEmptyAsyncContext.id=102650,module.exports=webpackEmptyAsyncContext},
/***/129058:
/***/function(){
/* (ignored) */
/***/},
/***/191853:
/***/function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";
// EXPORTS
__webpack_require__.d(__webpack_exports__,{ZJ:function(){/* binding */return dist_AdvancedSearch},gP:function(){/* binding */return Condition},IP:function(){/* binding */return CriteriaBuilder},KW:function(){/* binding */return dist_FTags}});
// UNUSED EXPORTS: ConditionValue
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js
__webpack_require__(450886),__webpack_require__(169358),__webpack_require__(932320),__webpack_require__(538077),__webpack_require__(260228),__webpack_require__(249693),__webpack_require__(947522),__webpack_require__(336585),__webpack_require__(821694),__webpack_require__(76265),__webpack_require__(919649),__webpack_require__(434284),__webpack_require__(976801),__webpack_require__(670560),__webpack_require__(425728),__webpack_require__(634338),__webpack_require__(900278),__webpack_require__(564043),__webpack_require__(709873),__webpack_require__(322462),__webpack_require__(339772),__webpack_require__(879288),__webpack_require__(506203),__webpack_require__(843843),__webpack_require__(186466),__webpack_require__(163975),__webpack_require__(155791);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.keys.js
var api=__webpack_require__(32284),validation=__webpack_require__(990260),cloneDeep=(__webpack_require__(598742),__webpack_require__(150361)),element_ui_common=__webpack_require__(364720),moment_timezone=__webpack_require__(480008),debounce=__webpack_require__(23279),dlv_umd=__webpack_require__(226905),transform=__webpack_require__(768718),lodash_isEqual=__webpack_require__(618446),vue_runtime_esm=__webpack_require__(720144),merge=(__webpack_require__(730381),__webpack_require__(696869),__webpack_require__(682492)),crypto_ignored_=__webpack_require__(129058),isFunction=(__webpack_require__(397895),__webpack_require__(857267),__webpack_require__(623560)),lodash=(__webpack_require__(648324),__webpack_require__(268932),__webpack_require__(830024),__webpack_require__(212826),__webpack_require__(689730),__webpack_require__(496486));// CONCATENATED MODULE: ./node_modules/@facilio/criteria/node_modules/@facilio/ui/forms/index.mjs
function styleInject$7(css,ref){void 0===ref&&(ref={});var insertAt=ref.insertAt;if(css&&"undefined"!==typeof document){var head=document.head||document.getElementsByTagName("head")[0],style=document.createElement("style");style.type="text/css","top"===insertAt&&head.firstChild?head.insertBefore(style,head.firstChild):head.appendChild(style),style.styleSheet?style.styleSheet.cssText=css:style.appendChild(document.createTextNode(css))}}var css_248z$b="*, ::before, ::after {\n  --tw-border-opacity: 1;\n  border-color: rgba(229, 231, 235, var(--tw-border-opacity))\n}\n\n.visible {\n  visibility: visible\n}\n\n.invisible {\n  visibility: hidden\n}\n\n.static {\n  position: static\n}\n\n.fixed {\n  position: fixed\n}\n\n.float-right {\n  float: right\n}\n\n.m-0 {\n  margin: 0px\n}\n\n.m-0\\.5 {\n  margin: 0.125rem\n}\n\n.my-1 {\n  margin-top: 0.25rem;\n  margin-bottom: 0.25rem\n}\n\n.my-4 {\n  margin-top: 1rem;\n  margin-bottom: 1rem\n}\n\n.mt-auto {\n  margin-top: auto\n}\n\n.mr-1 {\n  margin-right: 0.25rem\n}\n\n.mr-2 {\n  margin-right: 0.5rem\n}\n\n.mr-3 {\n  margin-right: 0.75rem\n}\n\n.mr-1\\.5 {\n  margin-right: 0.375rem\n}\n\n.mb-2 {\n  margin-bottom: 0.5rem\n}\n\n.mb-2\\.5 {\n  margin-bottom: 0.625rem\n}\n\n.ml-5 {\n  margin-left: 1.25rem\n}\n\n.ml-auto {\n  margin-left: auto\n}\n\n.flex {\n  display: flex\n}\n\n.table {\n  display: table\n}\n\n.hidden {\n  display: none\n}\n\n.h-4 {\n  height: 1rem\n}\n\n.h-6 {\n  height: 1.5rem\n}\n\n.h-9 {\n  height: 2.25rem\n}\n\n.h-10 {\n  height: 2.5rem\n}\n\n.h-20 {\n  height: 5rem\n}\n\n.h-40 {\n  height: 10rem\n}\n\n.h-full {\n  height: 100%\n}\n\n.w-4 {\n  width: 1rem\n}\n\n.w-6 {\n  width: 1.5rem\n}\n\n.w-10 {\n  width: 2.5rem\n}\n\n.w-12 {\n  width: 3rem\n}\n\n.w-28 {\n  width: 7rem\n}\n\n.w-40 {\n  width: 10rem\n}\n\n.w-10\\/12 {\n  width: 83.333333%\n}\n\n.w-full {\n  width: 100%\n}\n\n.border-collapse {\n  border-collapse: collapse\n}\n\n.transform {\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  transform: translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))\n}\n\n@keyframes spin {\n  to {\n    transform: rotate(360deg)\n  }\n}\n\n@keyframes ping {\n  75%, 100% {\n    transform: scale(2);\n    opacity: 0\n  }\n}\n\n@keyframes pulse {\n  50% {\n    opacity: .5\n  }\n}\n\n@keyframes bounce {\n  0%, 100% {\n    transform: translateY(-25%);\n    animation-timing-function: cubic-bezier(0.8,0,1,1)\n  }\n\n  50% {\n    transform: none;\n    animation-timing-function: cubic-bezier(0,0,0.2,1)\n  }\n}\n\n.cursor-pointer {\n  cursor: pointer\n}\n\n.select-all {\n  -webkit-user-select: all;\n          user-select: all\n}\n\n.flex-col {\n  flex-direction: column\n}\n\n.flex-wrap {\n  flex-wrap: wrap\n}\n\n.flex-nowrap {\n  flex-wrap: nowrap\n}\n\n.items-center {\n  align-items: center\n}\n\n.justify-center {\n  justify-content: center\n}\n\n.justify-between {\n  justify-content: space-between\n}\n\n.self-center {\n  align-self: center\n}\n\n.border {\n  border-width: 1px\n}\n\n.py-1 {\n  padding-top: 0.25rem;\n  padding-bottom: 0.25rem\n}\n\n.py-2 {\n  padding-top: 0.5rem;\n  padding-bottom: 0.5rem\n}\n\n.py-1\\.5 {\n  padding-top: 0.375rem;\n  padding-bottom: 0.375rem\n}\n\n.pr-3 {\n  padding-right: 0.75rem\n}\n\n.pl-0 {\n  padding-left: 0px\n}\n\n.pl-1 {\n  padding-left: 0.25rem\n}\n\n.pl-0\\.5 {\n  padding-left: 0.125rem\n}\n\n.text-left {\n  text-align: left\n}\n\n.text-center {\n  text-align: center\n}\n\n.text-xs {\n  font-size: 0.75rem;\n  line-height: 1rem\n}\n\n.uppercase {\n  text-transform: uppercase\n}\n\n.italic {\n  font-style: italic\n}\n\n.underline {\n  text-decoration: underline\n}\n\n*, ::before, ::after {\n  --tw-shadow: 0 0 #0000\n}\n\n*, ::before, ::after {\n  --tw-ring-inset: var(--tw-empty,/*!*/ /*!*/);\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgba(59, 130, 246, 0.5);\n  --tw-ring-offset-shadow: 0 0 #0000;\n  --tw-ring-shadow: 0 0 #0000\n}\n\n.filter {\n  --tw-blur: var(--tw-empty,/*!*/ /*!*/);\n  --tw-brightness: var(--tw-empty,/*!*/ /*!*/);\n  --tw-contrast: var(--tw-empty,/*!*/ /*!*/);\n  --tw-grayscale: var(--tw-empty,/*!*/ /*!*/);\n  --tw-hue-rotate: var(--tw-empty,/*!*/ /*!*/);\n  --tw-invert: var(--tw-empty,/*!*/ /*!*/);\n  --tw-saturate: var(--tw-empty,/*!*/ /*!*/);\n  --tw-sepia: var(--tw-empty,/*!*/ /*!*/);\n  --tw-drop-shadow: var(--tw-empty,/*!*/ /*!*/);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)\n}\n\n.blur {\n  --tw-blur: blur(8px)\n}\n\n.transition {\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms\n}\n\n.ease-in-out {\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1)\n}\n\n@media (min-width: 640px) {\n}\n\n@media (min-width: 768px) {\n}\n\n@media (min-width: 1024px) {\n}\n\n@media (min-width: 1280px) {\n}\n\n@media (min-width: 1536px) {\n}\n";styleInject$7(css_248z$b);var css_248z$a="/*purgecss start ignore*/\n\n.f-ui-base-text-input .el-input__inner, .f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input__inner,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input__inner, .f-ui-forms .f-ui-date-picker .el-input__inner, .f-ui-forms .f-ui-time-picker .el-input__inner, .f-ui-forms .f-ui-select .el-input__inner, .f-ui-forms .f-ui-text-input .el-input__inner {\n  height: 40px;\n  line-height: 40px;\n  padding-left: 15px;\n  padding-right: 15px;\n  border-radius: 3px;\n  background-color: #fff;\n  border: 1px solid #d0d9e2;\n  font-size: 14px;\n  letter-spacing: 0.4px;\n  color: #324056;\n  text-overflow: ellipsis;\n  font-weight: 400;\n  padding-right: 30px;\n  white-space: nowrap;\n}\n\n.f-ui-base-text-input .el-input__inner:hover, .f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input__inner:hover,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input__inner:hover, .f-ui-forms .f-ui-date-picker .el-input__inner:hover, .f-ui-forms .f-ui-time-picker .el-input__inner:hover, .f-ui-forms .f-ui-select .el-input__inner:hover, .f-ui-forms .f-ui-text-input .el-input__inner:hover,\n.f-ui-base-text-input .el-input__inner:focus,\n.f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input__inner:focus,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input__inner:focus,\n.f-ui-forms .f-ui-date-picker .el-input__inner:focus,\n.f-ui-forms .f-ui-time-picker .el-input__inner:focus,\n.f-ui-forms .f-ui-select .el-input__inner:focus,\n.f-ui-forms .f-ui-text-input .el-input__inner:focus {\n  border-color: #39b2c2;\n}\n\n.f-ui-base-text-input .el-input.is-focus .el-input__inner, .f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input.is-focus .el-input__inner,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input.is-focus .el-input__inner, .f-ui-forms .f-ui-date-picker .el-input.is-focus .el-input__inner, .f-ui-forms .f-ui-time-picker .el-input.is-focus .el-input__inner, .f-ui-forms .f-ui-select .el-input.is-focus .el-input__inner, .f-ui-forms .f-ui-text-input .el-input.is-focus .el-input__inner {\n  border-color: #39b2c2;\n}\n\n.f-ui-base-text-input .el-input__inner[disabled=disabled], .f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input__inner[disabled=disabled],\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input__inner[disabled=disabled], .f-ui-forms .f-ui-date-picker .el-input__inner[disabled=disabled], .f-ui-forms .f-ui-time-picker .el-input__inner[disabled=disabled], .f-ui-forms .f-ui-select .el-input__inner[disabled=disabled], .f-ui-forms .f-ui-text-input .el-input__inner[disabled=disabled] {\n  background-color: #f5f7fa;\n  border-color: #e4e7ed;\n  color: #c0c4cc;\n}\n\n.f-ui-base-text-input input::-webkit-outer-spin-button, .f-date-picker-popper .el-date-picker__editor-wrap .el-input input::-webkit-outer-spin-button,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input input::-webkit-outer-spin-button, .f-ui-forms .f-ui-date-picker input::-webkit-outer-spin-button, .f-ui-forms .f-ui-time-picker input::-webkit-outer-spin-button, .f-ui-forms .f-ui-select input::-webkit-outer-spin-button, .f-ui-forms .f-ui-text-input input::-webkit-outer-spin-button,\n.f-ui-base-text-input input::-webkit-inner-spin-button,\n.f-date-picker-popper .el-date-picker__editor-wrap .el-input input::-webkit-inner-spin-button,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input input::-webkit-inner-spin-button,\n.f-ui-forms .f-ui-date-picker input::-webkit-inner-spin-button,\n.f-ui-forms .f-ui-time-picker input::-webkit-inner-spin-button,\n.f-ui-forms .f-ui-select input::-webkit-inner-spin-button,\n.f-ui-forms .f-ui-text-input input::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n\n.f-ui-base-text-input input[type=number], .f-date-picker-popper .el-date-picker__editor-wrap .el-input input[type=number],\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input input[type=number], .f-ui-forms .f-ui-date-picker input[type=number], .f-ui-forms .f-ui-time-picker input[type=number], .f-ui-forms .f-ui-select input[type=number], .f-ui-forms .f-ui-text-input input[type=number] {\n  -moz-appearance: textfield;\n}\n\n.f-ui-forms .f-ui-select-tag .el-tag,\n.f-ui-forms .f-ui-lookup-container .el-tag {\n  border-radius: 50px;\n  border: solid 1px #39b2c2;\n  letter-spacing: 0.4px;\n  color: #39b2c2;\n  line-height: 25px;\n  height: 25px;\n  background: #fff;\n}\n\n.f-ui-forms .f-ui-select-tag .el-tag .el-icon-close,\n.f-ui-forms .f-ui-lookup-container .el-tag .el-icon-close {\n  color: #39b2c2;\n  background: transparent;\n  font-size: 16px;\n  padding-right: 10px;\n  font-weight: 600;\n  margin-right: 5px;\n  line-height: 15px;\n}\n\n.f-ui-forms .f-ui-select-tag .el-tag .el-icon-close:hover,\n.f-ui-forms .f-ui-lookup-container .el-tag .el-icon-close:hover {\n  background: transparent;\n  color: #39b2c2;\n}\n\n.f-ui-forms .f-ui-select-tag .el-select__tags,\n.f-ui-forms .f-ui-lookup-container .el-select__tags {\n  padding-left: 0;\n}\n\n.f-ui-forms .f-ui-select-tag .el-select__tags span.el-tag.el-tag--info.el-tag--small.el-tag--light,\n.f-ui-forms .f-ui-lookup-container .el-select__tags span.el-tag.el-tag--info.el-tag--small.el-tag--light {\n  display: flex;\n}\n\n.f-ui-forms .f-ui-select-tag .el-select__tags-text,\n.f-ui-forms .f-ui-lookup-container .el-select__tags-text {\n  max-width: 55px;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n  display: block;\n}\n\n.f-ui-forms .f-ui-time-picker {\n  width: 100%;\n}\n\n.f-ui-forms .f-ui-time-picker .el-input__inner {\n  padding-left: 30px;\n}\n\n.f-ui-forms .f-ui-date-picker {\n  width: 100%;\n}\n\n.f-ui-forms .f-ui-date-picker .el-input__inner {\n  padding-left: 30px;\n}\n\n.f-ui-forms .f-ui-date-picker.is-active,\n.f-ui-forms .f-ui-date-picker.is-active:hover {\n  border-color: #39b2c2;\n}\n\n.f-ui-forms .f-ui-tag {\n  border-radius: 50px;\n  border: solid 1px #39b2c2;\n  letter-spacing: 0.4px;\n  color: #39b2c2;\n  line-height: 25px;\n  height: 25px;\n  background: #fff;\n}\n\n.f-ui-forms .f-ui-tag .el-icon-close {\n  color: #39b2c2;\n  background: transparent;\n  font-size: 14px;\n  padding-right: 10px;\n  font-weight: 600;\n  margin-right: 5px;\n  line-height: 15px;\n  margin-top: 3px;\n}\n\n.f-ui-forms .f-ui-tag .el-icon-close:hover {\n  background: transparent;\n  color: #39b2c2;\n}\n\n.f-ui-forms .f-ui-icon-hover {\n  border: solid 1px transparent;\n  border-radius: 4px;\n}\n\n.f-ui-forms .f-ui-icon-hover:hover {\n  color: #615e88;\n  background: #f5f6f8;\n  border: 1px solid #dae0e8;\n}\n\n.f-ui-select-popper .f-ui-select-item {\n  display: flex;\n}\n\n.f-ui-select-popper .f-ui-select-item.selected {\n  font-weight: 400 !important;\n  /*color: #ef4f8f;*/\n  color: #ff3184;\n  letter-spacing: 1px !important;\n  font-size: 14px !important;\n}\n\n.f-ui-select-popper.is-multiple .f-ui-select-item {\n  display: flex;\n}\n\n.f-ui-select-popper.is-multiple .f-ui-select-item.selected {\n  color: #39b2c2 !important;\n}\n\n.f-date-picker-popper .el-picker-panel__footer .el-button--text {\n  color: #39b2c2;\n}\n\n.f-date-picker-popper .el-date-table td.available:hover,\n.f-date-picker-popper .el-date-table td.today span,\n.f-date-picker-popper .el-month-table td .cell:hover,\n.f-date-picker-popper .el-month-table td.today .cell,\n.f-date-picker-popper .el-year-table td .cell:hover,\n.f-date-picker-popper .el-year-table td.current:not(.disabled) .cell,\n.f-date-picker-popper .el-year-table td.today .cell,\n.f-date-picker-popper .el-time-panel__btn.confirm {\n  color: #39b2c2;\n}\n\n.f-date-picker-popper .el-date-table td.current:not(.disabled) span,\n.f-date-picker-popper .el-date-table td.end-date span,\n.f-date-picker-popper .el-date-table td.start-date span {\n  color: #fff;\n  background-color: #39b2c2;\n}\n\n.f-date-picker-popper .el-date-picker__header-label.active,\n.f-date-picker-popper .el-date-picker__header-label:hover {\n  color: #ff3184;\n}\n\n/*purgecss end ignore*/";styleInject$7(css_248z$a);
var script$v={name:"TextInput",components:{Input:element_ui_common.Input},props:["value","disabled","readonly","clearable"],data(){return{props:{},inputValue:""}},watch:{value:{handler(newVal,oldVal){newVal!==oldVal&&(this.inputValue=newVal)},immediate:!0}},mounted(){this.getProps()},methods:{getProps(){let props=this.$vnode.elm.attributes;Object.keys(props).forEach((key=>{this.$set(this.props,props[key].name,props[key].nodeValue)}))},change(value){this.$emit("input",value),this.$emit("change",value)},blur(...args){this.$emit("blur",args)},input(value){this.$emit("input",value)},clear(){this.$emit("clear")}}};function normalizeComponent$a(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);
// Vue.extend constructor export interop.
const options="function"===typeof script?script.options:script;
// render functions
let hook;if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,
// functional template
isFunctionalTemplate&&(options.functional=!0)),
// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),
// inject component styles
style&&style.call(this,createInjectorSSR(context)),
// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},
// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(context){style.call(this,createInjectorShadow(context,this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
const originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
const existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}const isOldIE$7="undefined"!==typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());function createInjector$7(context){return(id,style)=>addStyle$b(id,style)}let HEAD$7;const styles$b={};function addStyle$b(id,css){const group=isOldIE$7?css.media||"default":id,style=styles$b[group]||(styles$b[group]={ids:new Set,styles:[]});if(!style.ids.has(id)){style.ids.add(id);let code=css.source;if(css.map&&(
// https://developer.chrome.com/devtools/docs/javascript-debugging
// this makes source maps inside style tags work properly in Chrome
code+="\n/*# sourceURL="+css.map.sources[0]+" */",
// http://stackoverflow.com/a/26603875
code+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(css.map))))+" */"),style.element||(style.element=document.createElement("style"),style.element.type="text/css",css.media&&style.element.setAttribute("media",css.media),void 0===HEAD$7&&(HEAD$7=document.head||document.getElementsByTagName("head")[0]),HEAD$7.appendChild(style.element)),"styleSheet"in style.element)style.styles.push(code),style.element.styleSheet.cssText=style.styles.filter(Boolean).join("\n");else{const index=style.ids.size-1,textNode=document.createTextNode(code),nodes=style.element.childNodes;nodes[index]&&style.element.removeChild(nodes[index]),nodes.length?style.element.insertBefore(textNode,nodes[index]):style.element.appendChild(textNode)}}}
/* script */const __vue_script__$v=script$v;
/* template */var __vue_render__$s=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"f-ui-forms"},[_c("Input",_vm._b({staticClass:"f-ui-text-input",attrs:{disabled:_vm.disabled,readonly:_vm.readonly,clearable:_vm.clearable},on:{change:_vm.change,blur:_vm.blur,input:_vm.input,clear:_vm.clear},model:{value:_vm.inputValue,callback:function($$v){_vm.inputValue=$$v},expression:"inputValue"}},"Input",_vm.props,!1))],1)},__vue_staticRenderFns__$s=[];
/* style */
const __vue_inject_styles__$v=function(inject){inject&&inject("data-v-90911826_0",{source:".f-ui-text-input .el-input__inner{height:40px;line-height:40px;padding-left:15px;padding-right:15px;border-radius:3px;background-color:#fff;border:1px solid #d0d9e2;font-size:14px;letter-spacing:.4px;color:#324056;text-overflow:ellipsis;font-weight:400;padding-right:30px;white-space:nowrap}",map:void 0,media:void 0})},__vue_scope_id__$v=void 0,__vue_module_identifier__$v=void 0,__vue_is_functional_template__$v=!1,__vue_component__$u=normalizeComponent$a({render:__vue_render__$s,staticRenderFns:__vue_staticRenderFns__$s},__vue_inject_styles__$v,__vue_script__$v,__vue_scope_id__$v,__vue_is_functional_template__$v,__vue_module_identifier__$v,!1,createInjector$7,void 0,void 0),isEmpty$a=value=>void 0===value||null===value||-1===Number(value)||"object"===typeof value&&!(value instanceof Blob)&&0===Object.keys(value).length||"string"===typeof value&&0===value.trim().length,isNull$3=value=>null===value,isArray$3=value=>value&&value.constructor===Array,isObject$5=obj=>null!==obj&&"object"===typeof obj&&!1===Array.isArray(obj),isFunction$8=value=>"function"===typeof value,durationToSeconds=obj=>{let durationObj=moment_timezone.duration(obj),totalSec=durationObj.asSeconds();return totalSec},constructOptionsToMap$3=valueArr=>{let optionsObj=valueArr.reduce(((optionsObj,option)=>{let{label:label,value:value}=option||{};return optionsObj[value]=label,optionsObj}),{});return optionsObj},deepClean$2=objValue=>{
/**
    Deep cleans the object based on isEmpty in util/validation.
    @param {Object,Array}
    @result {Object,Array} Deep cleaned
    Sample Input => {
          a: { b: null, c: 1 },
          d: null,
          e: -1,
          f: [],
          l: [{ a: null }, { b: 2 }, 3],
          h: 100,
          i: [1, 2, '', -1],
          j: [{}, -1, ''],
          k: [{ a: null, b: [[[]]] }, -1, ''],
        }
    Sample Output => {
          a: { c: 1 },
          h: 100,
          i: [1, 2],
          l: [{ b: 2 }, 3],
        }
  */
let obj=cloneDeep(objValue);return transform(obj,((result,value,key)=>{if((isArray$3(value)||isObject$5(value))&&(value=deepClean$2(value)),!isEmpty$a(value))return isArray$3(result)?result.push(value):void(result[key]=value)}))},INTERVAL_HASH=["00","15","30","45"],TIME_FORMAT_HASH={"24Hour":1,"12Hour":2};
/* scoped */var script$u={components:{Dropdown:element_ui_common.Dropdown,DropdownMenu:element_ui_common.DropdownMenu,DropdownItem:element_ui_common.DropdownItem,Input:element_ui_common.Input},props:{value:{type:String,default:null},timeFormat:{type:Number,default:null},field:{type:Object,default:()=>({})},disabled:{type:Boolean,default:!1}},data(){return{time:"",inputValue:null,debounce:debounce,errMsg:"",isError:null,interval:30,dropdownStyle:""}},computed:{is12Hour(){let timeFormat=this.timeFormat;return timeFormat===TIME_FORMAT_HASH["12Hour"]},modelValue:{get(){return this.value},set(value){this.$emit("input",this.getFormattedTime(value))}},rows(){let rows=[],{is12Hour:is12Hour,interval:interval}=this;return rows=this.generateRows(is12Hour,interval),rows},canShowSystemClear(){let{disabled:disabled,modelValue:modelValue}=this;return!disabled&&!isEmpty$a(modelValue)}},watch:{value:{handler(val){isEmpty$a(val)?this.resetTimeValue():this.handleValue(val)},immediate:!0},inputValue:{handler(){this.errMsg="",this.isError=!1},immediate:!0}},mounted(){let element=this.$refs["time-picker-input"];if(!isEmpty$a(element)){let width=dlv_umd(element,"$el.clientWidth");this.dropdownStyle=`width:${width}px`}},methods:{handleValue(val){let selectedTime=this.rows.find((row=>row.label==this.getFormattedTime(val)));isEmpty$a(selectedTime)?this.inputValue=this.getFormattedTime(val):this.inputValue=selectedTime.label,this.handleChange()},generateRows(is12Hour,interval){let rows=[],minutesInterval=30===interval?2:4,startHour=is12Hour?"12":"0",meridian=is12Hour?"AM":"";
// mintuesInterval helps to decide the interval hash interval
for(let i=0;i<24;i++){for(let j=0;j<minutesInterval;j++){let minutes=30===interval?INTERVAL_HASH[2*j]:INTERVAL_HASH[j];rows.push({label:`${startHour<10?"0":""}${startHour}:${minutes} ${meridian}`,value:this.getUnixTime(startHour,minutes,meridian)})}is12Hour?(startHour=(parseInt(startHour)+1)%12,0===startHour&&(startHour=12,meridian="PM")):startHour=parseInt(startHour)+1}return rows},getUnixTime(hours,minutes,meridian){let setHour=hours;isEmpty$a(meridian)||(setHour="AM"===meridian?hours:hours+12),"AM"===meridian&&12==hours?setHour=0:"PM"===meridian&&12==hours&&(setHour=12);let time=this.getTimeAsMills(setHour,minutes);return time},handleSelect(val){this.$emit("input",val);let selectedTime=this.rows.find((row=>row.value===parseInt(val)));this.inputValue=selectedTime.label,this.handleChange()},handleChange(){let{value:value}=this||{};!isEmpty$a(value)&&this.$emit("change",value)},resetTimeValue(){this.modelValue=null,this.inputValue=null,this.handleChange(),this.$emit("input",null)},formatTime:debounce((function(value){if(!isEmpty$a(value)){
// regex for 01:34 PM, 11:59 am
value=value.replace(/\s/g,"");let meridianRegex=/^(0?[0-9]|1[0-9]|2[0-4]):([0-5][0-9]) ([AaPp][Mm])$/,meridianValues=value.match(meridianRegex);if(isEmpty$a(meridianValues)){
// regex for 00:46, 22:30, 01:56
let nonMeridianRegex=/^(0?[0-9]|1[0-9]|2[0-3]):([0-5][0-9])$/,nonMeridianValues=value.match(nonMeridianRegex);if(isEmpty$a(nonMeridianValues))if(isEmpty$a(nonMeridianValues)){let numberRegex=/^(0?[0-9]|1[0-9]|2[0-3])$/,colonRegex=/^(0?[0-9]|1[0-9]|2[0-3]):$/,numberPatternRegex=/^(0?[0-9]|1[0-9]|2[0-3]):([0-5])$/,numberValues=value.match(numberRegex),colonValues=value.match(colonRegex),numberPatternValues=value.match(numberPatternRegex);if(isEmpty$a(numberPatternValues))if(isEmpty$a(colonValues))if(isEmpty$a(numberValues))this.isError=!0,this.errMsg="Please enter valid time";else{let[,hours]=numberValues||[],mins=0,updatedTime=this.getTimeAsMills(hours,mins);updatedTime=moment_timezone(updatedTime).format("x"),this.$emit("input",updatedTime)}else{let[,hours]=colonValues||[],mins=0,updatedTime=this.getTimeAsMills(hours,mins);updatedTime=moment_timezone(updatedTime).format("x"),this.$emit("input",updatedTime)}else{let[,hours,mins]=numberPatternValues||[],min=10*mins,updatedTime=this.getTimeAsMills(hours,min);updatedTime=moment_timezone(updatedTime).format("x"),this.$emit("input",updatedTime)}}else this.isError=!0,this.errMsg="Please enter valid time";else{let[,hours,mins]=nonMeridianValues||[],updatedTime=this.getTimeAsMills(hours,mins);updatedTime=moment_timezone(updatedTime).format("x"),this.$emit("input",updatedTime)}}else{let[,hours,mins,meridian]=meridianValues||[];
// handling for cases : 16:45 PM ---> 04:45 PM , 14:22 AM ---> 02:22 PM
hours>12&&hours<=24&&(hours-=12,meridian="PM"),"0"!==hours&&"00"!==hours||(hours="00",meridian="AM"),
// we need to convert 12 AM to 24 hrs format
hours="12"===hours&&"AM"==meridian.toUpperCase()?"00":"PM"===meridian.toUpperCase()&&12!=hours?parseInt(hours)+12:hours;let updatedTime=this.getTimeAsMills(hours,mins);updatedTime=moment_timezone(updatedTime).format("x"),this.$emit("input",updatedTime)}this.isDropdownVisible=!1}}),1e3),getTimeAsMills(hours,minutes){let seconds=0,days=0,formatedDuration=durationToSeconds({seconds:seconds,minutes:minutes,hours:hours,days:days});return 1e3*formatedDuration},getFormattedTime(value){let format=this.is12Hour?"hh:mm A":"  HH:mm";return this.convertMilliSecondsToTimeHHMM(value,format)},convertMilliSecondsToTimeHHMM(timeValue,format){let timeFieldValue=timeValue||{};return moment_timezone().startOf("day").milliseconds(timeFieldValue).format(format)}}};
/* script */const __vue_script__$u=script$u;
/* template */var __vue_render__$r=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",[_c("Dropdown",{staticClass:"width100",attrs:{trigger:"click",disabled:_vm.disabled},on:{command:_vm.handleSelect},model:{value:_vm.modelValue,callback:function($$v){_vm.modelValue=$$v},expression:"modelValue"}},[_c("Input",{ref:"time-picker-input",staticClass:"time-picker-input fc-input-full-border-select2 width100",class:_vm.isError&&"time-input-error",attrs:{disabled:_vm.disabled},on:{input:_vm.formatTime},scopedSlots:_vm._u([{key:"prefix",fn:function(){return[_c("div",{staticClass:"el-input__icon el-icon-time"})]},proxy:!0},{key:"suffix",fn:function(){return[_vm.canShowSystemClear?_c("div",{staticClass:"ftime-remove-icon-alignment",on:{click:_vm.resetTimeValue}},[_c("i",{staticClass:"el-icon-circle-close pointer fc-lookup-icon f13"})]):_vm._e()]},proxy:!0}]),model:{value:_vm.inputValue,callback:function($$v){_vm.inputValue=$$v},expression:"inputValue"}}),_vm._v(" "),_c("DropdownMenu",{staticClass:"time-height200 time-overflow-scroll",style:_vm.dropdownStyle,attrs:{slot:"dropdown"},slot:"dropdown"},_vm._l(_vm.rows,(function(row){return _c("DropdownItem",{key:""+row.value,attrs:{command:""+row.value}},[_vm._v(_vm._s(row.label))])})),1)],1),_vm._v(" "),_c("div",{staticClass:"el-form-item-time__error"},[_vm._v(_vm._s(_vm.errMsg))])],1)},__vue_staticRenderFns__$r=[];
/* style */
const __vue_inject_styles__$u=function(inject){inject&&inject("data-v-621714c8_0",{source:".time-icon{height:37px!important;width:16px!important}.el-form-item-time__error{color:#f56c6c;font-size:12px;line-height:1;padding-top:4px;position:absolute;top:100%;left:0}.time-picker-input .el-input__inner{padding-left:30px!important}.time-input-error .el-input__inner{border-color:#f56c6c!important}.ftime-remove-icon-alignment{color:#809aae!important;width:20px;line-height:40px}.time-overflow-scroll{overflow:scroll}.time-height200{height:200px!important}",map:void 0,media:void 0})},__vue_scope_id__$u=void 0,__vue_module_identifier__$u=void 0,__vue_is_functional_template__$u=!1,__vue_component__$t=normalizeComponent$a({render:__vue_render__$r,staticRenderFns:__vue_staticRenderFns__$r},__vue_inject_styles__$u,__vue_script__$u,__vue_scope_id__$u,__vue_is_functional_template__$u,__vue_module_identifier__$u,!1,createInjector$7,void 0,void 0);
/* scoped */var Constants$3={FIELD_PLACEHOLDERS:["${CURRENT_DATE}","${CURRENT_TIME}","${LOGGED_USER}","${LOGGED_TENANT}","${LOGGED_VENDOR}"],LOOKUP_FILTER_ENABLED_FIELDS:["resource","people"],LOOKUP_FILTERS_MAP:{1:"building",2:"asset",3:"tenantcontact",4:"clientcontact",5:"vendorcontact",6:"employee"},QUICK_FILTERS:[{value:null,key:"category",placeHolderText:"Category",lookupModule:{name:null},disabled:!1,options:[]},{spaceType:1,value:null,key:"site",placeHolderText:"Site",lookupModule:{name:"site"},disabled:!1,options:[]},{spaceType:2,value:null,key:"building",placeHolderText:"Building",lookupModule:{name:"building"},disabled:!1,options:[]},{spaceType:3,value:null,key:"floor",placeHolderText:"Floor",lookupModule:{name:"floor"},disabled:!0,options:[]},{spaceType:4,value:null,key:"space",placeHolderText:"Space",lookupModule:{name:"basespace"},disabled:!0,options:[]}]};const getFieldOptions$3=async props=>{let{field:field,siteId:siteId,searchText:searchText,page:page,perPage:perPage,defaultIds:defaultIds,customOptions:customOptions}=props,{filters:filters={},field:fieldObj,clientCriteria:clientCriteria={},lookupModule:lookupModule,resourceLookupModuleName:resourceLookupModuleName,lookupModuleName:lookupModuleName,skipDeserialize:skipDeserialize,operatorLookupModule:operatorLookupModule,additionalParams:additionalParams={}}=field||{},currentLookupModule=isEmpty$a(lookupModule)?fieldObj?.lookupModule:lookupModule,{name:name}=currentLookupModule||{},{name:operatorLookupModuleName}=operatorLookupModule||{},moduleName=resourceLookupModuleName||lookupModuleName||name;isEmpty$a(operatorLookupModuleName)||(moduleName=operatorLookupModuleName);let{filters:lookupModuleFilters}=lookupModule||{};isEmpty$a(lookupModuleFilters)||(filters={...filters,...lookupModuleFilters}),isEmpty$a(siteId)||(filters={...filters,siteId:{operatorId:36,value:[`${siteId}`]}}),"quote"===dlv_umd(fieldObj,"module.name")&&"workorder"===moduleName&&(filters={...filters,isQuotationNeeded:{operatorId:15,value:[String(!0)]}});let defaultIdsStr=isEmpty$a(defaultIds)?"":defaultIds.toString(),payload={moduleName:moduleName,searchText:searchText,page:page,perPage:perPage,filters:isEmpty$a(filters)?null:JSON.stringify(filters),clientCriteria:isEmpty$a(clientCriteria)?null:JSON.stringify(clientCriteria),defaultIds:defaultIdsStr||null,additionalParams:additionalParams},{error:error,options:options=[],meta:meta}=await fetchFieldOptions$3(payload)||{};if(error)return{error:error};if(isEmpty$a(customOptions)||(options=[...options,...customOptions]),skipDeserialize){let optionsObj=constructOptionsToMap$3(options||[]);return{options:optionsObj,meta:meta}}return{options:options,meta:meta}},fetchFieldOptions$3=async payload=>{let{moduleName:moduleName,searchText:searchText,page:page,perPage:perPage,filters:filters,clientCriteria:clientCriteria,defaultIds:defaultIds,additionalParams:additionalParams}=payload,url=`/v3/picklist/${moduleName}`,params={page:page,perPage:perPage,clientCriteria:clientCriteria,filters:filters,search:searchText,default:defaultIds,viewName:"hidden-all",...additionalParams},{error:error,data:data,meta:meta={}}=await api/* API */.bl.get(url,params)||{};if(error)return{error:error};{let{pickList:options}=data||{};return{options:options||[],meta:meta}}};var LookupIcon$3={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{width:"512",height:"512",viewBox:"0 0 512 512",xmlns:"http://www.w3.org/2000/svg"}},[_c("path",{attrs:{d:"M215.466 481.432c0 10.704-8.71 15.247-19.492 15.247h-85.892C52.151 496.679 32 481.432 32 419.15V78.028C32 17.754 47.553.5 110.082.5h239.999c62.999 0 78.082 14.659 78.082 77.528v185.098c0 10.705-4.305 20.37-15.083 20.37-10.782 0-14.915-9.665-14.915-20.37V78.028c0-38.847-5.615-47.576-48.084-47.576H110.082c-39.68 0-47.917 13.097-47.917 47.576V419.15c0 40.768 6.732 47.518 47.917 47.518h85.892c10.782 0 19.492 4.058 19.492 14.763z"}}),_c("path",{attrs:{d:"M330.56 116.792H129.497c-10.782 0-19.52 6.637-19.52 14.827 0 8.19 8.738 14.828 19.52 14.828H330.56c10.78 0 19.522-6.638 19.522-14.828s-8.743-14.827-19.522-14.827zm19.522 92.355c0-8.19-8.744-14.827-19.523-14.827H129.498c-10.782 0-19.52 6.637-19.52 14.827 0 8.19 8.738 14.827 19.52 14.827H330.56c10.78 0 19.522-6.637 19.522-14.827zm-220.584 62.7c-10.783 0-19.522 6.639-19.522 14.828 0 8.19 8.739 14.827 19.52 14.827h102.592c10.782 0 19.52-6.637 19.52-14.827 0-8.19-8.74-14.827-19.52-14.827H129.497zm215.809 21.927c31.684 0 62.96 12.212 92.762 35.826a230.97 230.97 0 0111.047 9.343c13.134 11.819 22.4 22.164 33.691 36.212l.773.963c.603.753 1.29 1.656 2.058 2.693l.897 1.222.937 1.295 1.133 1.59c8.391 11.835 8.391 27.68.026 39.48l-1.116 1.57a159.25 159.25 0 01-3.376 4.56l-.558.709-1.538 1.914c-10.94 13.558-20.096 23.715-32.938 35.267a231.043 231.043 0 01-11.036 9.333c-29.8 23.615-61.078 35.827-92.762 35.827-31.683 0-62.96-12.211-92.761-35.826a230.993 230.993 0 01-11.047-9.343c-12.837-11.55-21.989-21.705-32.928-35.264l-1.54-1.914-.466-.592a121.78 121.78 0 01-2.179-2.9l-.745-1.024c-.288-.398-.569-.789-.841-1.17l-.792-1.113a34.168 34.168 0 01-.003-39.513l.802-1.126.412-.575.859-1.187.899-1.225a91.05 91.05 0 012.059-2.693l.792-.988c14.496-18.03 27.043-31.52 44.717-45.524 29.801-23.615 61.079-35.827 92.762-35.827zm0 29.8c-24.536 0-49.45 9.727-74.255 29.383-15.22 12.06-26.349 23.94-39.232 39.888l-1.671 2.08-.324.417c-.743.966-1.739 2.33-2.78 3.786l-.725 1.02a4.37 4.37 0 00.002 5.056l1.089 1.526a138.74 138.74 0 002.414 3.276l.473.605 1.479 1.84c10.016 12.41 18.255 21.549 29.654 31.806a201.246 201.246 0 009.621 8.139c24.806 19.655 49.72 29.383 74.255 29.383 24.536 0 49.45-9.728 74.255-29.384a201.302 201.302 0 009.613-8.13c11.675-10.504 20.036-19.834 30.372-32.69l.911-1.14.34-.438c.664-.867 1.54-2.06 2.385-3.236l1.112-1.562a4.368 4.368 0 00-.01-5.06l-.931-1.309c-1.171-1.633-2.325-3.2-3.036-4.087l-.744-.927-1.54-1.908c-9.667-11.92-17.758-20.832-28.85-30.813a201.224 201.224 0 00-9.622-8.138c-24.806-19.656-49.719-29.383-74.255-29.383z"}}),_c("path",{attrs:{d:"M345.6 365.85c-16.497 0-29.867 13.276-29.867 29.655 0 16.378 13.37 29.654 29.867 29.654s29.867-13.276 29.867-29.654c0-16.379-13.37-29.654-29.867-29.654z"}})])}},AddPinkIcon$3={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{width:"14",height:"14",viewBox:"0 0 14 14",xmlns:"http://www.w3.org/2000/svg"}},[_c("path",{attrs:{d:"M7.6 6.4h4.9a.6.6 0 110 1.2H7.6v4.9a.6.6 0 11-1.2 0V7.6H1.5a.6.6 0 110-1.2h4.9V1.5a.6.6 0 111.2 0v4.9z",fill:"#EF508F","fill-rule":"evenodd"}})])}},script$t={name:"Lookup",components:{Select:element_ui_common.Select,Option:element_ui_common.Option,Tooltip:element_ui_common.Tooltip,LookupIcon:LookupIcon$3,AddPinkIcon:AddPinkIcon$3},props:{customOptions:{type:Array,default:()=>[]},value:void 0,field:{type:Object,default:null},disabled:{type:Boolean},siteId:{type:Number,default:null},categoryId:{type:Number,default:null},hideLookupIcon:{type:Boolean,default:!1},popperAppendToBody:{required:!1,type:Boolean,default:!1},fetchOptionsOnLoad:{type:Boolean,default:!0},fetchOptionsMethod:{type:Function,default:null},preHookFilterConstruction:{type:Function,default:field=>field.filters},hideDropDown:{type:Boolean,default:!1},skipLoading:{type:Boolean,default:!1},isClearable:{type:Boolean,default:!0},userfilmoduleEnum:{type:String,default:""},clearable:{type:Boolean,default:!1}},data(){return{localSearch:!1,isLoadedOnce:!1,currentModelValue:!1,showQuickCreateData:!1,isEmpty:isEmpty$a,isFieldOptionsLoading:!1,fieldOptions:[]}},computed:{modelObj:{get(){return this.value},set(val){this.currentModelValue=val,this.$emit("input",val)}},moduleDisplayName(){let{field:field}=this,{lookupModule:lookupModule}=field.field||{},{displayName:displayName}=lookupModule||{};return displayName},isFieldLoading(){let{field:field,defaultIds:defaultIds,skipLoading:skipLoading,isLoadedOnce:isLoadedOnce}=this;return!skipLoading&&!isLoadedOnce&&!isEmpty$a(defaultIds)&&field.isDataLoading},isPickListTypeModule(){let{field:field}=this,{field:fieldObj}=field,{lookupModule:lookupModule}=fieldObj||field,{type:type}=lookupModule||{};
// type 1 is for base entity modules
return!!type&&1!==type},isRemote(){let{localSearch:localSearch}=this;return!localSearch},canHideLookupIcon(){let{hideLookupIcon:hideLookupIcon,isPickListTypeModule:isPickListTypeModule,hideDropDown:hideDropDown,field:field,userfilmoduleEnum:userfilmoduleEnum}=this,{config:config}=field||{},canHide=!1;if(!isEmpty$a(config)){let canShowLookupWizard=dlv_umd(config,"canShowLookupWizard",null);isNull$3(canShowLookupWizard)||(canHide=!canShowLookupWizard)}return!hideDropDown&&("PICK_LIST"===userfilmoduleEnum||(canHide||hideLookupIcon||isPickListTypeModule))},canShowQuickCreateIcon(){let{disabled:disabled,field:field}=this,{config:config}=field||{},canShow=!1;return isEmpty$a(config)||(canShow=dlv_umd(config,"canShowQuickCreate")),disabled&&(canShow=!1),canShow},isSiteEnabled(){let siteId=Number(this.$cookie.get("fc.currentSite")),currentSiteId=siteId>0?siteId:-1;return!isEmpty$a(currentSiteId)},isMultiple(){let{field:field}=this;return!!field.multiple},resourceModuleName(){let{field:field}=this,{config:config,lookupModuleName:lookupModuleName}=field,{isFiltersEnabled:isFiltersEnabled,filterValue:filterValue}=config||{};if(isFiltersEnabled&&Constants$3.LOOKUP_FILTER_ENABLED_FIELDS.includes(lookupModuleName)){let moduleName=Constants$3.LOOKUP_FILTERS_MAP[filterValue];return moduleName}return null},isResourceField(){let{field:field}=this,{name:name}=field,isResourceField=this.isChooserTypeField(field)||"resource"===name;return isResourceField},
// To prefill the existing values, we have to send default ids in picklist api
defaultIds(){let{modelObj:modelObj}=this,isPlaceHoldersEnabled=Constants$3.FIELD_PLACEHOLDERS.includes(modelObj)||!1,defaultIds=[];return isEmpty$a(modelObj)||isPlaceHoldersEnabled||(defaultIds=isArray$3(modelObj)?[...modelObj]:[modelObj]),defaultIds=(defaultIds||[]).filter((id=>!`${id}`.includes("${"))),defaultIds},operatorLookupModule(){let{field:field}=this,{operatorLookupModule:operatorLookupModule}=field||{};return operatorLookupModule||{}},skipSiteFilter(){let{field:field}=this,{config:config}=field||{},{skipSiteFilter:skipSiteFilter=!1}=config||{};return skipSiteFilter},canShowSystemClear(){let{canHideLookupIcon:canHideLookupIcon,isClearable:isClearable,modelObj:modelObj}=this;return!canHideLookupIcon&&(isClearable&&!isEmpty$a(modelObj))}},watch:{value(newVal){let{currentModelValue:currentModelValue,isRemote:isRemote}=this;lodash_isEqual(newVal,currentModelValue)||(isRemote&&this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options),this.fieldOptions=options})),this.$set(this,"modelObj",newVal))},siteId:{handler(newVal,oldVal){let{isSiteEnabled:isSiteEnabled,skipSiteFilter:skipSiteFilter}=this;skipSiteFilter||isSiteEnabled||newVal===oldVal||this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options),this.fieldOptions=options}))}},operatorLookupModule:{handler(newVal,oldVal){lodash_isEqual(newVal,oldVal)||this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options),this.fieldOptions=options}))}},"field.clientCriteria":{handler(newVal,oldVal){lodash_isEqual(newVal,oldVal)||this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options),this.fieldOptions=options}))}},categoryId:{handler(newVal,oldVal){lodash_isEqual(newVal,oldVal)||this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options),this.fieldOptions=options}))}},"field.options":{handler(value){let{modelObj:modelObj}=this;if(!isEmpty$a(value))if(isEmpty$a(modelObj))
// eslint-disable-next-line vue/no-mutating-props
this.field.selectedItems=[];else if(isArray$3(modelObj)){let selectedItems=value.filter((option=>modelObj.includes(option.value)));
// eslint-disable-next-line vue/no-mutating-props
this.field.selectedItems=selectedItems}else{let selectedItem=value.find((option=>option.value===modelObj));
// eslint-disable-next-line vue/no-mutating-props
this.field.selectedItems=[selectedItem]}},immediate:!0,deep:!0},isLoadedOnce:{handler(value){value&&this.$emit("optionsLoadedOnce")}}},async created(){let{fetchOptionsOnLoad:fetchOptionsOnLoad,field:field,modelObj:modelObj}=this;
// Have to skip fetching options initially, when module is 'resource' and filters is not enabled
if(this.currentModelValue=modelObj,fetchOptionsOnLoad){let options=await this.getOptions({initialFetch:!0})||[];this.$set(this.field,"options",options),this.fieldOptions=options,this.$set(this,"isLoadedOnce",!0)}this.remoteMethod=debounce((async searchText=>{let{isDataLoading:isDataLoading}=field;if(!isDataLoading){let options=await this.getOptions({searchText:searchText});this.$set(this.field,"options",options),this.fieldOptions=options}}),1e3)},methods:{isChooserTypeField(field){let{displayTypeEnum:displayTypeEnum}=field;
// temp have to use a global constant
return["WOASSETSPACECHOOSER","SPACECHOOSER"].includes(displayTypeEnum)},focus(){isEmpty$a(this.$refs["selectBox"])||this.$refs["selectBox"].focus()},isSiteDecommissioned(data){let{fourthLabel:fourthLabel}=data||{};return!isEmpty$a(fourthLabel)&&JSON.parse(fourthLabel)},async getOptions(params){let{searchText:searchText,initialFetch:initialFetch}=params,{fetchOptionsMethod:fetchOptionsMethod,field:field,siteId:siteId,categoryId:categoryId,isRemote:isRemote,defaultIds:defaultIds,resourceModuleName:resourceModuleName,isResourceField:isResourceField,skipSiteFilter:skipSiteFilter,customOptions:customOptions}=this,options=[];isEmpty$a(resourceModuleName)||(field.resourceLookupModuleName=resourceModuleName),field.filters=this.preHookFilterConstruction(field),isEmpty$a(categoryId)||(field.filters={...field.filters,category:{operator:"is",value:[`${categoryId}`]}});let props={field:field,searchText:searchText};
/*
        Have to return empty options if field is of resourcetype, if filters havent be enabled
        and if no values selected already
      */
if(skipSiteFilter||(props={...props,siteId:siteId}),isResourceField&&isEmpty$a(resourceModuleName)&&isEmpty$a(defaultIds))return[{label:"",value:""}];if(initialFetch&&isRemote&&(props={...props,page:1,perPage:defaultIds.length>50?defaultIds.length:50,defaultIds:defaultIds},isEmpty$a(resourceModuleName)&&isResourceField&&(
// Have to fetch only selected values, which is same as the number of defaultids
props={...props,perPage:defaultIds.length})),isEmpty$a(customOptions)||(props={...props,customOptions:customOptions}),this.$set(field,"isDataLoading",!0),this.isFieldOptionsLoading=!0,isEmpty$a(fetchOptionsMethod)){let{options:optionsArr=[],error:error,meta:meta}=await getFieldOptions$3(props);if(error){let{message:message}=error||{};this.$message.error(message||"Error Occured")}if(meta&&isEmpty$a(searchText)){let{localSearch:localSearch=!1}=meta;this.$set(this,"localSearch",localSearch)}options=optionsArr}else{let{options:optionsArr=[],error:error}=await this.fetchOptionsMethod(props);if(error){let{message:message}=error||{};this.$message.error(message||"Error Occured")}options=optionsArr}return this.$set(field,"isDataLoading",!1),this.isFieldOptionsLoading=!1,options},clearData(){this.$emit("input",""),this.recordSelected("")},recordSelected(value){let{field:field,field:{options:options=[]},isMultiple:isMultiple}=this,selectedValues=null;isMultiple?(selectedValues=options.filter((e=>(value||[]).includes(e.value))),field.selectedItems=selectedValues):(selectedValues=options.find((e=>e.value==value))||{},field.selectedItems=[],isEmpty$a(selectedValues)||(field.selectedItems=[selectedValues])),this.$emit("recordSelected",selectedValues,field)},openLookupFieldWizard(field){let{disabled:disabled}=this;disabled||setTimeout((()=>{this.$emit("showLookupWizard",field,!0)}),400)},openQuickCreate(){let{disabled:disabled}=this;disabled||(this.showQuickCreateData=!0)},setAddedRecord(props){let{record:record}=props,{id:id}=record||{},name=record.displayName||record.name||record.subject,{field:field}=this;field.selectedItems=[{value:id,label:name}],this.$emit("setLookupFieldValue",{field:{...field}})}}};
/* script */
const __vue_script__$t=script$t;
/* template */var __vue_render__$q=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _vm.isFieldLoading?_c("div",{staticClass:"field-loading loading-shimmer"}):_c("div",{staticClass:"f-ui-forms f-ui-lookup-container"},[_c("Select",{ref:"selectBox",class:["f-ui-forms f-ui-select w-full",!_vm.canHideLookupIcon||_vm.canShowQuickCreateIcon?"field-icons-visible":"select-icon-visible",_vm.isMultiple&&"f-ui-select-tag",_vm.hideDropDown&&!_vm.disabled&&"skip-disable"],attrs:{"collapse-tags":"",remote:_vm.isRemote,filterable:"",clearable:_vm.canHideLookupIcon,multiple:_vm.isMultiple,popperAppendToBody:_vm.popperAppendToBody,"remote-method":function(searchText){return _vm.remoteMethod(searchText)},loading:_vm.isFieldOptionsLoading,"loading-text":"Searching",disabled:_vm.disabled||_vm.hideDropDown,placeholder:_vm.field.placeHolderText||"Select","popper-class":"f-ui-select-popper"},on:{change:_vm.recordSelected},model:{value:_vm.modelObj,callback:function($$v){_vm.modelObj=$$v},expression:"modelObj"}},[_c("div",{staticClass:"float-right h-full flex flex-nowrap cursor-pointer",class:!_vm.disabled&&"pointer",attrs:{slot:"prefix"},slot:"prefix"},[_vm.canShowSystemClear?_c("div",{staticClass:"prefix-icon-container flookup-remove-icon",on:{click:_vm.clearData}},[_c("i",{staticClass:"el-icon-circle-close pointer fc-lookup-icon f13"})]):_vm._e(),_vm._v(" "),_vm.canHideLookupIcon?_vm._e():_c("div",{staticClass:"prefix-icon-container flex flex-nowrap",on:{click:function($event){return $event.stopPropagation(),_vm.openLookupFieldWizard(_vm.field)}}},[_c("div",{staticClass:"lookup-icon f-ui-icon-hover"},[_c("LookupIcon",{staticClass:"w-4 h-4"})],1)]),_vm._v(" "),_vm.canShowQuickCreateIcon?_c("div",{staticClass:"prefix-icon-container flex flex-nowrap",on:{click:function($event){return $event.stopPropagation(),function(){return _vm.openQuickCreate()}.apply(null,arguments)}}},[_c("Tooltip",{attrs:{effect:"dark",content:"Add\n          "+_vm.moduleDisplayName,placement:"top"}},[_c("AddPinkIcon",{staticClass:"icon"})],1)],1):_vm._e()]),_vm._v(" "),_vm._l(_vm.fieldOptions,(function(option,index){return _c("Option",{key:option.value+" "+index,staticClass:"f-ui-select-item width100",attrs:{label:option.label,value:option.value}},[_c("span",{staticClass:"fL"},[_vm._v(_vm._s(option.label))]),_vm._v(" "),_vm.isEmpty(option.secondaryLabel)?_vm._e():_c("span",{staticClass:"select-float-right-text13"},[_vm._v(_vm._s(option.secondaryLabel))]),_vm._v(" "),_vm.isSiteDecommissioned(option)?_c("span",{directives:[{name:"tippy",rawName:"v-tippy"}],staticClass:"decommission-warning-icon",attrs:{title:"Decommissioned"}},[_c("fc-icon",{staticClass:"fR pT10",attrs:{group:"alert",name:"decommissioning",size:"16"}})],1):_vm._e()])}))],2),_vm._v(" "),_vm.showQuickCreateData?_c("div",[_vm._v("Testing")]):_vm._e()],1)},__vue_staticRenderFns__$q=[];
/* style */
const __vue_inject_styles__$t=function(inject){inject&&(inject("data-v-5dacd3a0_0",{source:".field-loading[data-v-5dacd3a0]{height:40px;display:flex;flex:1;border-radius:3px}.decommission-warning-icon[data-v-5dacd3a0]{width:100%!important;padding-left:10px;float:right;color:#8492a6;font-size:13px}",map:void 0,media:void 0}),inject("data-v-5dacd3a0_1",{source:".search-input-comp .field-icons-visible .el-input__inner{padding-left:15px!important}.f-ui-lookup-container{position:relative}.f-ui-lookup-container .el-icon-arrow-up:before{visibility:hidden}.f-ui-lookup-container .select-icon-visible .el-icon-arrow-up:before{visibility:visible}.f-ui-lookup-container .field-icons-visible .el-input .el-input__prefix{right:5px;left:88%;z-index:3}.f-ui-lookup-container .skip-disable .el-input__inner:disabled{cursor:auto!important;background-color:#fff;color:#324056}.f-ui-lookup-container .lookup-icon{display:flex;position:relative;padding:5px}.f-ui-lookup-container:hover .flookup-remove-icon{display:flex}.f-ui-lookup-container .flookup-remove-icon{display:none}.f-ui-lookup-container .prefix-icon-container{height:100%;align-items:center;justify-content:center;margin:1px 3px}",map:void 0,media:void 0}))},__vue_scope_id__$t="data-v-5dacd3a0",__vue_module_identifier__$t=void 0,__vue_is_functional_template__$t=!1,__vue_component__$s=normalizeComponent$a({render:__vue_render__$q,staticRenderFns:__vue_staticRenderFns__$q},__vue_inject_styles__$t,__vue_script__$t,__vue_scope_id__$t,__vue_is_functional_template__$t,__vue_module_identifier__$t,!1,createInjector$7,void 0,void 0);
/* scoped */
var script$s={components:{Select:element_ui_common.Select,Option:element_ui_common.Option},props:["value","options","filterable","multiple","labelName","valueName","disabled","placeholder","allowCreate","clearable"],mounted(){this.getProps()},data(){return{props:{},inputValue:""}},watch:{value:{handler(newVal,oldVal){newVal!==oldVal&&(this.inputValue=newVal)},immediate:!0}},computed:{optionsLabelString(){let{labelName:labelName}=this||{};return labelName||"label"},optionsValueString(){let{valueName:valueName}=this||{};return valueName||"value"},isClearable(){let{disabled:disabled,clearable:clearable}=this;return!disabled&&!!clearable}},methods:{getProps(){let props=this.$vnode.elm.attributes;Object.keys(props).forEach((key=>{this.$set(this.props,props[key].name,props[key].nodeValue)}))},selectValueChange(value){this.$emit("input",value),this.$emit("change",value)},onClear(){this.$emit("clear")}}};
/* script */const __vue_script__$s=script$s;
/* template */var __vue_render__$p=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"f-ui-forms"},[_c("Select",_vm._b({staticClass:"f-ui-select w-full f-ui-select-tag",attrs:{placeholder:_vm.placeholder||"Select","collapse-tags":"",filterable:_vm.filterable,multiple:_vm.multiple,disabled:_vm.disabled,"allow-create":_vm.allowCreate,"popper-class":"f-ui-select-popper",clearable:_vm.isClearable},on:{change:_vm.selectValueChange,clear:_vm.onClear},model:{value:_vm.inputValue,callback:function($$v){_vm.inputValue=$$v},expression:"inputValue"}},"Select",_vm.props,!1),_vm._l(_vm.options,(function(item){return _c("Option",{key:item[_vm.optionsValueString],staticClass:"f-ui-select-item width100",attrs:{label:item[_vm.optionsLabelString],value:item[_vm.optionsValueString]}})})),1)],1)},__vue_staticRenderFns__$p=[];
/* style */
const __vue_inject_styles__$s=void 0,__vue_scope_id__$s=void 0,__vue_module_identifier__$s=void 0,__vue_is_functional_template__$s=!1,__vue_component__$r=normalizeComponent$a({render:__vue_render__$p,staticRenderFns:__vue_staticRenderFns__$p},__vue_inject_styles__$s,__vue_script__$s,__vue_scope_id__$s,__vue_is_functional_template__$s,__vue_module_identifier__$s,!1,void 0,void 0,void 0);
/* scoped */function _extends$9(){return _extends$9=Object.assign?Object.assign.bind():function(a){for(var b,c=1;c<arguments.length;c++)for(var d in b=arguments[c],b)Object.prototype.hasOwnProperty.call(b,d)&&(a[d]=b[d]);return a},_extends$9.apply(this,arguments)}var normalMerge$3=["attrs","props","domProps"],toArrayMerge$3=["class","style","directives"],functionalMerge$3=["on","nativeOn"],mergeJsxProps$3=function(a){return a.reduce((function(c,a){for(var b in a)if(c[b])if(-1!==normalMerge$3.indexOf(b))c[b]=_extends$9({},c[b],a[b]);else if(-1!==toArrayMerge$3.indexOf(b)){var d=c[b]instanceof Array?c[b]:[c[b]],e=a[b]instanceof Array?a[b]:[a[b]];c[b]=[].concat(d,e)}else if(-1!==functionalMerge$3.indexOf(b))for(var f in a[b])if(c[b][f]){var g=c[b][f]instanceof Array?c[b][f]:[c[b][f]],h=a[b][f]instanceof Array?a[b][f]:[a[b][f]];c[b][f]=[].concat(g,h)}else c[b][f]=a[b][f];else if("hook"===b)for(var i in a[b])c[b][i]=c[b][i]?mergeFn$3(c[b][i],a[b][i]):a[b][i];else c[b]=a[b];else c[b]=a[b];return c}),{})},mergeFn$3=function(a,b){return function(){a&&a.apply(this,arguments),b&&b.apply(this,arguments)}},helper$3=mergeJsxProps$3;const NAMESPACE$3="facicons-ui";
/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/snabbdom/snabbdom/blob/master/LICENSE
 *
 * Modified for Stencil's renderer and slot projection
 */let scopeId$3,hostTagName$3,isSvgMode$3=!1,queuePending$3=!1;const createTime$3=(fnName,tagName="")=>()=>{},uniqueTime$3=(key,measureText)=>()=>{},HYDRATED_CSS$3="{visibility:hidden}.hydrated{visibility:inherit}",EMPTY_OBJ$3={},isDef$3=v=>null!=v,isComplexType$3=o=>(
// https://jsperf.com/typeof-fn-object/5
o=typeof o,"object"===o||"function"===o),h$3=(nodeName,vnodeData,...children)=>{let child=null,simple=!1,lastSimple=!1;const vNodeChildren=[],walk=c=>{for(let i=0;i<c.length;i++)child=c[i],Array.isArray(child)?walk(child):null!=child&&"boolean"!==typeof child&&((simple="function"!==typeof nodeName&&!isComplexType$3(child))&&(child=String(child)),simple&&lastSimple?
// If the previous child was simple (string), we merge both
vNodeChildren[vNodeChildren.length-1].$text$+=child:
// Append a new vNode, if it's text, we create a text vNode
vNodeChildren.push(simple?newVNode$3(null,child):child),lastSimple=simple)};if(walk(children),vnodeData){const classData=vnodeData.className||vnodeData.class;classData&&(vnodeData.class="object"!==typeof classData?classData:Object.keys(classData).filter((k=>classData[k])).join(" "))}const vnode=newVNode$3(nodeName,null);return vnode.$attrs$=vnodeData,vNodeChildren.length>0&&(vnode.$children$=vNodeChildren),vnode},newVNode$3=(tag,text)=>{const vnode={$flags$:0,$tag$:tag,$text$:text,$elm$:null,$children$:null,$attrs$:null};return vnode},Host$3={},isHost$3=node=>node&&node.$tag$===Host$3
/**
 * Parse a new property value for a given property type.
 *
 * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,
 * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:
 *   1. `any`, the type given to `propValue` in the function signature
 *   2. the type stored from `propType`.
 *
 * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.
 *
 * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to
 * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is
 * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.
 * ```tsx
 * <my-cmp prop-val={0}></my-cmp>
 * ```
 *
 * HTML prop values on the other hand, will always a string
 *
 * @param propValue the new value to coerce to some type
 * @param propType the type of the prop, expressed as a binary number
 * @returns the parsed/coerced value
 */,parsePropertyValue$3=(propValue,propType)=>
// ensure this value is of the correct prop type
null==propValue||isComplexType$3(propValue)?propValue:1/* MEMBER_FLAGS.String */&propType?String(propValue):propValue,emitEvent$3=(elm,name,opts)=>{const ev=plt$3.ce(name,opts);return elm.dispatchEvent(ev),ev},rootAppliedStyles$3=new WeakMap,registerStyle$3=(scopeId,cssText,allowCS)=>{let style=styles$a.get(scopeId);supportsConstructableStylesheets&&allowCS?(style=style||new CSSStyleSheet,"string"===typeof style?style=cssText:style.replaceSync(cssText)):style=cssText,styles$a.set(scopeId,style)},addStyle$a=(styleContainerNode,cmpMeta,mode,hostElm)=>{let scopeId=getScopeId$3(cmpMeta);const style=styles$a.get(scopeId);
// if an element is NOT connected then getRootNode() will return the wrong root node
// so the fallback is to always use the document for the root node in those cases
if(styleContainerNode=11/* NODE_TYPE.DocumentFragment */===styleContainerNode.nodeType?styleContainerNode:doc$8,style)if("string"===typeof style){styleContainerNode=styleContainerNode.head||styleContainerNode;let styleElm,appliedStyles=rootAppliedStyles$3.get(styleContainerNode);appliedStyles||rootAppliedStyles$3.set(styleContainerNode,appliedStyles=new Set),appliedStyles.has(scopeId)||(styleElm=doc$8.createElement("style"),styleElm.innerHTML=style,styleContainerNode.insertBefore(styleElm,styleContainerNode.querySelector("link")),appliedStyles&&appliedStyles.add(scopeId))}else styleContainerNode.adoptedStyleSheets.includes(style)||(styleContainerNode.adoptedStyleSheets=[...styleContainerNode.adoptedStyleSheets,style]);return scopeId},attachStyles$3=hostRef=>{const cmpMeta=hostRef.$cmpMeta$,elm=hostRef.$hostElement$,flags=cmpMeta.$flags$,endAttachStyles=createTime$3("attachStyles",cmpMeta.$tagName$),scopeId=addStyle$a(elm.shadowRoot?elm.shadowRoot:elm.getRootNode(),cmpMeta);10/* CMP_FLAGS.needsScopedEncapsulation */&flags&&(
// only required when we're NOT using native shadow dom (slot)
// or this browser doesn't support native shadow dom
// and this host element was NOT created with SSR
// let's pick out the inner content for slot projection
// create a node to represent where the original
// content was first placed, which is useful later on
// DOM WRITE!!
elm["s-sc"]=scopeId,elm.classList.add(scopeId+"-h")),endAttachStyles()},getScopeId$3=(cmp,mode)=>"sc-"+cmp.$tagName$
/**
 * Production setAccessor() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */,setAccessor$3=(elm,memberName,oldValue,newValue,isSvg,flags)=>{if(oldValue!==newValue){let isProp=isMemberInElement$3(elm,memberName);if(memberName.toLowerCase(),"class"===memberName){const classList=elm.classList,oldClasses=parseClassList$3(oldValue),newClasses=parseClassList$3(newValue);classList.remove(...oldClasses.filter((c=>c&&!newClasses.includes(c)))),classList.add(...newClasses.filter((c=>c&&!oldClasses.includes(c))))}else{
// Set property if it exists and it's not a SVG
const isComplex=isComplexType$3(newValue);if((isProp||isComplex&&null!==newValue)&&!isSvg)try{if(elm.tagName.includes("-"))elm[memberName]=newValue;else{const n=null==newValue?"":newValue;
// Workaround for Safari, moving the <input> caret when re-assigning the same valued
"list"===memberName?isProp=!1:null!=oldValue&&elm[memberName]==n||(elm[memberName]=n)}}catch(e){}null==newValue||!1===newValue?!1===newValue&&""!==elm.getAttribute(memberName)||elm.removeAttribute(memberName):(!isProp||4/* VNODE_FLAGS.isHost */&flags||isSvg)&&!isComplex&&(newValue=!0===newValue?"":newValue,elm.setAttribute(memberName,newValue))}}},parseClassListRegex$3=/\s/,parseClassList$3=value=>value?value.split(parseClassListRegex$3):[],updateElement$3=(oldVnode,newVnode,isSvgMode,memberName)=>{
// if the element passed in is a shadow root, which is a document fragment
// then we want to be adding attrs/props to the shadow root's "host" element
// if it's not a shadow root, then we add attrs/props to the same element
const elm=11/* NODE_TYPE.DocumentFragment */===newVnode.$elm$.nodeType&&newVnode.$elm$.host?newVnode.$elm$.host:newVnode.$elm$,oldVnodeAttrs=oldVnode&&oldVnode.$attrs$||EMPTY_OBJ$3,newVnodeAttrs=newVnode.$attrs$||EMPTY_OBJ$3;
// remove attributes no longer present on the vnode by setting them to undefined
for(memberName in oldVnodeAttrs)memberName in newVnodeAttrs||setAccessor$3(elm,memberName,oldVnodeAttrs[memberName],void 0,isSvgMode,newVnode.$flags$);
// add new & update changed attributes
for(memberName in newVnodeAttrs)setAccessor$3(elm,memberName,oldVnodeAttrs[memberName],newVnodeAttrs[memberName],isSvgMode,newVnode.$flags$)},createElm$3=(oldParentVNode,newParentVNode,childIndex,parentElm)=>{
// tslint:disable-next-line: prefer-const
const newVNode=newParentVNode.$children$[childIndex];let elm,childNode,i=0;if(
// create element
elm=newVNode.$elm$=doc$8.createElement(newVNode.$tag$),updateElement$3(null,newVNode,isSvgMode$3),isDef$3(scopeId$3)&&elm["s-si"]!==scopeId$3&&
// if there is a scopeId and this is the initial render
// then let's add the scopeId as a css class
elm.classList.add(elm["s-si"]=scopeId$3),newVNode.$children$)for(i=0;i<newVNode.$children$.length;++i)
// create the node
childNode=createElm$3(oldParentVNode,newVNode,i),
// return node could have been null
childNode&&
// append our new node
elm.appendChild(childNode);return elm},addVnodes$3=(parentElm,before,parentVNode,vnodes,startIdx,endIdx)=>{let childNode,containerElm=parentElm;for(containerElm.shadowRoot&&containerElm.tagName===hostTagName$3&&(containerElm=containerElm.shadowRoot);startIdx<=endIdx;++startIdx)vnodes[startIdx]&&(childNode=createElm$3(null,parentVNode,startIdx),childNode&&(vnodes[startIdx].$elm$=childNode,containerElm.insertBefore(childNode,before)))},removeVnodes$3=(vnodes,startIdx,endIdx,vnode,elm)=>{for(;startIdx<=endIdx;++startIdx)(vnode=vnodes[startIdx])&&(elm=vnode.$elm$,
// remove the vnode's element from the dom
elm.remove())},updateChildren$3=(parentElm,oldCh,newVNode,newCh)=>{let node,oldStartIdx=0,newStartIdx=0,oldEndIdx=oldCh.length-1,oldStartVnode=oldCh[0],oldEndVnode=oldCh[oldEndIdx],newEndIdx=newCh.length-1,newStartVnode=newCh[0],newEndVnode=newCh[newEndIdx];while(oldStartIdx<=oldEndIdx&&newStartIdx<=newEndIdx)null==oldStartVnode?
// VNode might have been moved left
oldStartVnode=oldCh[++oldStartIdx]:null==oldEndVnode?oldEndVnode=oldCh[--oldEndIdx]:null==newStartVnode?newStartVnode=newCh[++newStartIdx]:null==newEndVnode?newEndVnode=newCh[--newEndIdx]:isSameVnode$3(oldStartVnode,newStartVnode)?(
// if the start nodes are the same then we should patch the new VNode
// onto the old one, and increment our `newStartIdx` and `oldStartIdx`
// indices to reflect that. We don't need to move any DOM Nodes around
// since things are matched up in order.
patch$3(oldStartVnode,newStartVnode),oldStartVnode=oldCh[++oldStartIdx],newStartVnode=newCh[++newStartIdx]):isSameVnode$3(oldEndVnode,newEndVnode)?(
// likewise, if the end nodes are the same we patch new onto old and
// decrement our end indices, and also likewise in this case we don't
// need to move any DOM Nodes.
patch$3(oldEndVnode,newEndVnode),oldEndVnode=oldCh[--oldEndIdx],newEndVnode=newCh[--newEndIdx]):isSameVnode$3(oldStartVnode,newEndVnode)?(patch$3(oldStartVnode,newEndVnode),
// We need to move the element for `oldStartVnode` into a position which
// will be appropriate for `newEndVnode`. For this we can use
// `.insertBefore` and `oldEndVnode.$elm$.nextSibling`. If there is a
// sibling for `oldEndVnode.$elm$` then we want to move the DOM node for
// `oldStartVnode` between `oldEndVnode` and it's sibling, like so:
// <old-start-node />
// <some-intervening-node />
// <old-end-node />
// <!-- ->              <-- `oldStartVnode.$elm$` should be inserted here
// <next-sibling />
// If instead `oldEndVnode.$elm$` has no sibling then we just want to put
// the node for `oldStartVnode` at the end of the children of
// `parentElm`. Luckily, `Node.nextSibling` will return `null` if there
// aren't any siblings, and passing `null` to `Node.insertBefore` will
// append it to the children of the parent element.
parentElm.insertBefore(oldStartVnode.$elm$,oldEndVnode.$elm$.nextSibling),oldStartVnode=oldCh[++oldStartIdx],newEndVnode=newCh[--newEndIdx]):isSameVnode$3(oldEndVnode,newStartVnode)?(patch$3(oldEndVnode,newStartVnode),
// We've already checked above if `oldStartVnode` and `newStartVnode` are
// the same node, so since we're here we know that they are not. Thus we
// can move the element for `oldEndVnode` _before_ the element for
// `oldStartVnode`, leaving `oldStartVnode` to be reconciled in the
// future.
parentElm.insertBefore(oldEndVnode.$elm$,oldStartVnode.$elm$),oldEndVnode=oldCh[--oldEndIdx],newStartVnode=newCh[++newStartIdx]):(
// We either didn't find an element in the old children that matches
// the key of the first new child OR the build is not using `key`
// attributes at all. In either case we need to create a new element
// for the new node.
node=createElm$3(oldCh&&oldCh[newStartIdx],newVNode,newStartIdx),newStartVnode=newCh[++newStartIdx],node&&oldStartVnode.$elm$.parentNode.insertBefore(node,oldStartVnode.$elm$));oldStartIdx>oldEndIdx?
// we have some more new nodes to add which don't match up with old nodes
addVnodes$3(parentElm,null==newCh[newEndIdx+1]?null:newCh[newEndIdx+1].$elm$,newVNode,newCh,newStartIdx,newEndIdx):newStartIdx>newEndIdx&&
// there are nodes in the `oldCh` array which no longer correspond to nodes
// in the new array, so lets remove them (which entails cleaning up the
// relevant DOM nodes)
removeVnodes$3(oldCh,oldStartIdx,oldEndIdx)},isSameVnode$3=(leftVNode,rightVNode)=>leftVNode.$tag$===rightVNode.$tag$,patch$3=(oldVNode,newVNode)=>{const elm=newVNode.$elm$=oldVNode.$elm$,oldChildren=oldVNode.$children$,newChildren=newVNode.$children$;
// either this is the first render of an element OR it's an update
// AND we already know it's possible it could have changed
// this updates the element's css classes, attrs, props, listeners, etc.
updateElement$3(oldVNode,newVNode,isSvgMode$3),null!==oldChildren&&null!==newChildren?
// looks like there's child vnodes for both the old and new vnodes
// so we need to call `updateChildren` to reconcile them
updateChildren$3(elm,oldChildren,newVNode,newChildren):null!==newChildren?
// add the new vnode children
addVnodes$3(elm,null,newVNode,newChildren,0,newChildren.length-1):null!==oldChildren&&
// no new child vnodes, but there are old child vnodes to remove
removeVnodes$3(oldChildren,0,oldChildren.length-1)},renderVdom$3=(hostRef,renderFnResults)=>{const hostElm=hostRef.$hostElement$,oldVNode=hostRef.$vnode$||newVNode$3(null,null),rootVnode=isHost$3(renderFnResults)?renderFnResults:h$3(null,null,renderFnResults);hostTagName$3=hostElm.tagName,rootVnode.$tag$=null,rootVnode.$flags$|=4/* VNODE_FLAGS.isHost */,hostRef.$vnode$=rootVnode,rootVnode.$elm$=oldVNode.$elm$=hostElm.shadowRoot||hostElm,scopeId$3=hostElm["s-sc"],
// synchronous patch
patch$3(oldVNode,rootVnode)},attachToAncestor$3=(hostRef,ancestorComponent)=>{ancestorComponent&&!hostRef.$onRenderResolve$&&ancestorComponent["s-p"]&&ancestorComponent["s-p"].push(new Promise((r=>hostRef.$onRenderResolve$=r)))},scheduleUpdate$3=(hostRef,isInitialLoad)=>{if(hostRef.$flags$|=16/* HOST_FLAGS.isQueuedForUpdate */,4/* HOST_FLAGS.isWaitingForChildren */&hostRef.$flags$)return void(hostRef.$flags$|=512/* HOST_FLAGS.needsRerender */);attachToAncestor$3(hostRef,hostRef.$ancestorComponent$);
// there is no ancestor component or the ancestor component
// has already fired off its lifecycle update then
// fire off the initial update
const dispatch=()=>dispatchHooks$3(hostRef,isInitialLoad);return writeTask$3(dispatch)},dispatchHooks$3=(hostRef,isInitialLoad)=>{const endSchedule=createTime$3("scheduleUpdate",hostRef.$cmpMeta$.$tagName$),instance=hostRef.$lazyInstance$;let promise;return isInitialLoad&&(promise=safeCall$3(instance,"componentWillLoad")),endSchedule(),then$3(promise,(()=>updateComponent$3(hostRef,instance,isInitialLoad)))},updateComponent$3=async(hostRef,instance,isInitialLoad)=>{
// updateComponent
const elm=hostRef.$hostElement$,endUpdate=createTime$3("update",hostRef.$cmpMeta$.$tagName$),rc=elm["s-rc"];isInitialLoad&&
// DOM WRITE!
attachStyles$3(hostRef);const endRender=createTime$3("render",hostRef.$cmpMeta$.$tagName$);callRender$3(hostRef,instance),rc&&(
// ok, so turns out there are some child host elements
// waiting on this parent element to load
// let's fire off all update callbacks waiting
rc.map((cb=>cb())),elm["s-rc"]=void 0),endRender(),endUpdate();{const childrenPromises=elm["s-p"],postUpdate=()=>postUpdateComponent$3(hostRef);0===childrenPromises.length?postUpdate():(Promise.all(childrenPromises).then(postUpdate),hostRef.$flags$|=4/* HOST_FLAGS.isWaitingForChildren */,childrenPromises.length=0)}},callRender$3=(hostRef,instance,elm)=>{try{instance=instance.render(),hostRef.$flags$&=-17/* HOST_FLAGS.isQueuedForUpdate */,hostRef.$flags$|=2/* HOST_FLAGS.hasRendered */,renderVdom$3(hostRef,instance)}catch(e){consoleError$3(e,hostRef.$hostElement$)}return null},postUpdateComponent$3=hostRef=>{const tagName=hostRef.$cmpMeta$.$tagName$,elm=hostRef.$hostElement$,endPostUpdate=createTime$3("postUpdate",tagName),ancestorComponent=hostRef.$ancestorComponent$;64/* HOST_FLAGS.hasLoadedComponent */&hostRef.$flags$?endPostUpdate():(hostRef.$flags$|=64/* HOST_FLAGS.hasLoadedComponent */,
// DOM WRITE!
addHydratedFlag$3(elm),endPostUpdate(),hostRef.$onReadyResolve$(elm),ancestorComponent||appDidLoad$3()),hostRef.$onRenderResolve$&&(hostRef.$onRenderResolve$(),hostRef.$onRenderResolve$=void 0),512/* HOST_FLAGS.needsRerender */&hostRef.$flags$&&nextTick$3((()=>scheduleUpdate$3(hostRef,!1))),hostRef.$flags$&=-517/* HOST_FLAGS.needsRerender */;
// load events fire from bottom to top
// the deepest elements load first then bubbles up
}
// ( •_•)
// ( •_•)>⌐■-■
// (⌐■_■)
,appDidLoad$3=who=>{addHydratedFlag$3(doc$8.documentElement),nextTick$3((()=>emitEvent$3(win$3,"appload",{detail:{namespace:NAMESPACE$3}})))},safeCall$3=(instance,method,arg)=>{if(instance&&instance[method])try{return instance[method](arg)}catch(e){consoleError$3(e)}},then$3=(promise,thenFn)=>promise&&promise.then?promise.then(thenFn):thenFn(),addHydratedFlag$3=elm=>elm.classList.add("hydrated"),getValue$7=(ref,propName)=>getHostRef$3(ref).$instanceValues$.get(propName),setValue$3=(ref,propName,newVal,cmpMeta)=>{
// check our new property value against our internal value
const hostRef=getHostRef$3(ref),elm=hostRef.$hostElement$,oldVal=hostRef.$instanceValues$.get(propName),flags=hostRef.$flags$,instance=hostRef.$lazyInstance$;newVal=parsePropertyValue$3(newVal,cmpMeta.$members$[propName][0]);
// explicitly check for NaN on both sides, as `NaN === NaN` is always false
const areBothNaN=Number.isNaN(oldVal)&&Number.isNaN(newVal),didValueChange=newVal!==oldVal&&!areBothNaN;if((!(8/* HOST_FLAGS.isConstructingInstance */&flags)||void 0===oldVal)&&didValueChange&&(
// gadzooks! the property's value has changed!!
// set our new value!
hostRef.$instanceValues$.set(propName,newVal),instance)){
// get an array of method names of watch functions to call
if(cmpMeta.$watchers$&&128/* HOST_FLAGS.isWatchReady */&flags){const watchMethods=cmpMeta.$watchers$[propName];watchMethods&&
// this instance is watching for when this property changed
watchMethods.map((watchMethodName=>{try{
// fire off each of the watch methods that are watching this property
instance[watchMethodName](newVal,oldVal,propName)}catch(e){consoleError$3(e,elm)}}))}2/* HOST_FLAGS.hasRendered */===(18/* HOST_FLAGS.isQueuedForUpdate */&flags)&&
// looks like this value actually changed, so we've got work to do!
// but only if we've already rendered, otherwise just chill out
// queue that we need to do an update, but don't worry about queuing
// up millions cuz this function ensures it only runs once
scheduleUpdate$3(hostRef,!1)}},proxyComponent$3=(Cstr,cmpMeta,flags)=>{if(cmpMeta.$members$){Cstr.watchers&&(cmpMeta.$watchers$=Cstr.watchers);
// It's better to have a const than two Object.entries()
const members=Object.entries(cmpMeta.$members$),prototype=Cstr.prototype;if(members.map((([memberName,[memberFlags]])=>{(31/* MEMBER_FLAGS.Prop */&memberFlags||2/* PROXY_FLAGS.proxyState */&flags&&32/* MEMBER_FLAGS.State */&memberFlags)&&
// proxyComponent - prop
Object.defineProperty(prototype,memberName,{get(){
// proxyComponent, get value
return getValue$7(this,memberName)},set(newValue){
// proxyComponent, set value
setValue$3(this,memberName,newValue,cmpMeta)},configurable:!0,enumerable:!0})})),1/* PROXY_FLAGS.isElementConstructor */&flags){const attrNameToPropName=new Map;prototype.attributeChangedCallback=function(attrName,_oldValue,newValue){plt$3.jmp((()=>{const propName=attrNameToPropName.get(attrName);
//  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback
//  in the case where an attribute was set inline.
//  ```html
//    <my-component some-attribute="some-value"></my-component>
//  ```

//  There is an edge case where a developer sets the attribute inline on a custom element and then
//  programmatically changes it before it has been upgraded as shown below:

//  ```html
//    <!-- this component has _not_ been upgraded yet -->
//    <my-component id="test" some-attribute="some-value"></my-component>
//    <script>
//      // grab non-upgraded component
//      el = document.querySelector("#test");
//      el.someAttribute = "another-value";
//      // upgrade component
//      customElements.define('my-component', MyComponent);
//    <\/script>
//  ```
//  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback
//  will be called with `newValue = "some-value"` and will set the shadowed property (this.someAttribute = "another-value")
//  to the value that was set inline i.e. "some-value" from above example. When
//  the connectedCallback attempts to unshadow it will use "some-value" as the initial value rather than "another-value"

//  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed
//  by connectedCallback as this attributeChangedCallback will not fire.

//  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties

//  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to
//  properties here given that this goes against best practices outlined here
//  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy
if(this.hasOwnProperty(propName))newValue=this[propName],delete this[propName];else if(prototype.hasOwnProperty(propName)&&"number"===typeof this[propName]&&this[propName]==newValue)
// if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native
// APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in
// `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.
return;this[propName]=(null!==newValue||"boolean"!==typeof this[propName])&&newValue}))},
// create an array of attributes to observe
// and also create a map of html attribute name to js property name
Cstr.observedAttributes=members.filter((([_,m])=>15/* MEMBER_FLAGS.HasAttribute */&m[0]// filter to only keep props that should match attributes
)).map((([propName,m])=>{const attrName=m[1]||propName;return attrNameToPropName.set(attrName,propName),attrName}))}}return Cstr},initializeComponent$3=async(elm,hostRef,cmpMeta,hmrVersionId,Cstr)=>{
// initializeComponent
if(0===(32/* HOST_FLAGS.hasInitializedComponent */&hostRef.$flags$)){{if(
// we haven't initialized this element yet
hostRef.$flags$|=32/* HOST_FLAGS.hasInitializedComponent */,
// lazy loaded components
// request the component's implementation to be
// wired up with the host element
Cstr=loadModule$3(cmpMeta),Cstr.then){
// Await creates a micro-task avoid if possible
const endLoad=uniqueTime$3();Cstr=await Cstr,endLoad()}Cstr.isProxied||(cmpMeta.$watchers$=Cstr.watchers,proxyComponent$3(Cstr,cmpMeta,2/* PROXY_FLAGS.proxyState */),Cstr.isProxied=!0);const endNewInstance=createTime$3("createInstance",cmpMeta.$tagName$);
// ok, time to construct the instance
// but let's keep track of when we start and stop
// so that the getters/setters don't incorrectly step on data
hostRef.$flags$|=8/* HOST_FLAGS.isConstructingInstance */;
// construct the lazy-loaded component implementation
// passing the hostRef is very important during
// construction in order to directly wire together the
// host element and the lazy-loaded instance
try{new Cstr(hostRef)}catch(e){consoleError$3(e)}hostRef.$flags$&=-9/* HOST_FLAGS.isConstructingInstance */,hostRef.$flags$|=128/* HOST_FLAGS.isWatchReady */,endNewInstance()}if(Cstr.style){
// this component has styles but we haven't registered them yet
let style=Cstr.style;const scopeId=getScopeId$3(cmpMeta);if(!styles$a.has(scopeId)){const endRegisterStyles=createTime$3("registerStyles",cmpMeta.$tagName$);registerStyle$3(scopeId,style,!!(1/* CMP_FLAGS.shadowDomEncapsulation */&cmpMeta.$flags$)),endRegisterStyles()}}}
// we've successfully created a lazy instance
const ancestorComponent=hostRef.$ancestorComponent$,schedule=()=>scheduleUpdate$3(hostRef,!0);ancestorComponent&&ancestorComponent["s-rc"]?
// this is the initial load and this component it has an ancestor component
// but the ancestor component has NOT fired its will update lifecycle yet
// so let's just cool our jets and wait for the ancestor to continue first
// this will get fired off when the ancestor component
// finally gets around to rendering its lazy self
// fire off the initial update
ancestorComponent["s-rc"].push(schedule):schedule()},connectedCallback$3=elm=>{if(0===(1/* PLATFORM_FLAGS.isTmpDisconnected */&plt$3.$flags$)){const hostRef=getHostRef$3(elm),cmpMeta=hostRef.$cmpMeta$,endConnected=createTime$3("connectedCallback",cmpMeta.$tagName$);if(!(1/* HOST_FLAGS.hasConnected */&hostRef.$flags$)){
// first time this component has connected
hostRef.$flags$|=1/* HOST_FLAGS.hasConnected */;{
// find the first ancestor component (if there is one) and register
// this component as one of the actively loading child components for its ancestor
let ancestorComponent=elm;while(ancestorComponent=ancestorComponent.parentNode||ancestorComponent.host)
// climb up the ancestors looking for the first
// component that hasn't finished its lifecycle update yet
if(ancestorComponent["s-p"]){
// we found this components first ancestor component
// keep a reference to this component's ancestor component
attachToAncestor$3(hostRef,hostRef.$ancestorComponent$=ancestorComponent);break}}
// Lazy properties
// https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
cmpMeta.$members$&&Object.entries(cmpMeta.$members$).map((([memberName,[memberFlags]])=>{if(31/* MEMBER_FLAGS.Prop */&memberFlags&&elm.hasOwnProperty(memberName)){const value=elm[memberName];delete elm[memberName],elm[memberName]=value}})),initializeComponent$3(elm,hostRef,cmpMeta)}endConnected()}},disconnectedCallback$3=elm=>{0===(1/* PLATFORM_FLAGS.isTmpDisconnected */&plt$3.$flags$)&&getHostRef$3(elm)},bootstrapLazy$3=(lazyBundles,options={})=>{const endBootstrap=createTime$3(),cmpTags=[],exclude=options.exclude||[],customElements=win$3.customElements,head=doc$8.head,metaCharset=head.querySelector("meta[charset]"),visibilityStyle=doc$8.createElement("style"),deferredConnectedCallbacks=[];let appLoadFallback,isBootstrapping=!0;Object.assign(plt$3,options),plt$3.$resourcesUrl$=new URL(options.resourcesUrl||"./",doc$8.baseURI).href,lazyBundles.map((lazyBundle=>{lazyBundle[1].map((compactMeta=>{const cmpMeta={$flags$:compactMeta[0],$tagName$:compactMeta[1],$members$:compactMeta[2],$listeners$:compactMeta[3]};cmpMeta.$members$=compactMeta[2],cmpMeta.$watchers$={};const tagName=cmpMeta.$tagName$,HostElement=class extends HTMLElement{
// StencilLazyHost
constructor(self){
// @ts-ignore
super(self),self=this,registerHost$3(self,cmpMeta),1/* CMP_FLAGS.shadowDomEncapsulation */&cmpMeta.$flags$&&self.attachShadow({mode:"open"})}connectedCallback(){appLoadFallback&&(clearTimeout(appLoadFallback),appLoadFallback=null),isBootstrapping?
// connectedCallback will be processed once all components have been registered
deferredConnectedCallbacks.push(this):plt$3.jmp((()=>connectedCallback$3(this)))}disconnectedCallback(){plt$3.jmp((()=>disconnectedCallback$3(this)))}componentOnReady(){return getHostRef$3(this).$onReadyPromise$}};cmpMeta.$lazyBundleId$=lazyBundle[0],exclude.includes(tagName)||customElements.get(tagName)||(cmpTags.push(tagName),customElements.define(tagName,proxyComponent$3(HostElement,cmpMeta,1/* PROXY_FLAGS.isElementConstructor */)))}))})),visibilityStyle.innerHTML=cmpTags+HYDRATED_CSS$3,visibilityStyle.setAttribute("data-styles",""),head.insertBefore(visibilityStyle,metaCharset?metaCharset.nextSibling:head.firstChild),
// Process deferred connectedCallbacks now all components have been registered
isBootstrapping=!1,deferredConnectedCallbacks.length?deferredConnectedCallbacks.map((host=>host.connectedCallback())):plt$3.jmp((()=>appLoadFallback=setTimeout(appDidLoad$3,30))),
// Fallback appLoad event
endBootstrap()},hostRefs$3=new WeakMap,getHostRef$3=ref=>hostRefs$3.get(ref),registerHost$3=(elm,cmpMeta)=>{const hostRef={$flags$:0,$hostElement$:elm,$cmpMeta$:cmpMeta,$instanceValues$:new Map};return hostRef.$onReadyPromise$=new Promise((r=>hostRef.$onReadyResolve$=r)),elm["s-p"]=[],elm["s-rc"]=[],hostRefs$3.set(elm,hostRef)},isMemberInElement$3=(elm,memberName)=>memberName in elm,consoleError$3=(e,el)=>(0,console.error)(e,el),cmpModules$3=new Map,loadModule$3=(cmpMeta,hostRef,hmrVersionId)=>{
// loadModuleImport
const exportName=cmpMeta.$tagName$.replace(/-/g,"_"),bundleId=cmpMeta.$lazyBundleId$,module=cmpModules$3.get(bundleId);return module?module[exportName]:__webpack_require__(102650)(`./${bundleId}.entry.js`).then((importedModule=>(cmpModules$3.set(bundleId,importedModule),importedModule[exportName])),consoleError$3)
/*!__STENCIL_STATIC_IMPORT_SWITCH__*/},styles$a=new Map,win$3="undefined"!==typeof window?window:{},doc$8=win$3.document||{head:{}},plt$3={$flags$:0,$resourcesUrl$:"",jmp:h=>h(),raf:h=>requestAnimationFrame(h),ael:(el,eventName,listener,opts)=>el.addEventListener(eventName,listener,opts),rel:(el,eventName,listener,opts)=>el.removeEventListener(eventName,listener,opts),ce:(eventName,opts)=>new CustomEvent(eventName,opts)},promiseResolve$3=v=>Promise.resolve(v),supportsConstructableStylesheets=(()=>{try{return new CSSStyleSheet,"function"===typeof(new CSSStyleSheet).replaceSync}catch(e){}return!1})(),queueDomReads$3=[],queueDomWrites$3=[],queueTask$3=(queue,write)=>cb=>{queue.push(cb),queuePending$3||(queuePending$3=!0,write&&4/* PLATFORM_FLAGS.queueSync */&plt$3.$flags$?nextTick$3(flush$3):plt$3.raf(flush$3))},consume$3=queue=>{for(let i=0;i<queue.length;i++)try{queue[i](performance.now())}catch(e){consoleError$3(e)}queue.length=0},flush$3=()=>{
// always force a bunch of medium callbacks to run, but still have
// a throttle on how many can run in a certain time
// DOM READS!!!
consume$3(queueDomReads$3),consume$3(queueDomWrites$3),(queuePending$3=queueDomReads$3.length>0)&&
// still more to do yet, but we've run out of time
// let's let this thing cool off and try again in the next tick
plt$3.raf(flush$3)},nextTick$3=cb=>promiseResolve$3().then(cb),writeTask$3=queueTask$3(queueDomWrites$3,!0),patchEsm$3=()=>promiseResolve$3(),defineCustomElements$3=(win,options)=>"undefined"===typeof window?Promise.resolve():patchEsm$3().then((()=>bootstrapLazy$3([["fc-icon",[[1,"fc-icon",{name:[1],group:[1],size:[1],color:[1],svgContent:[32],iconClass:[32],icon:[32],baseURL:[32],sym:[32]}]]]],options)));(function(){if("undefined"!==typeof window&&void 0!==window.Reflect&&void 0!==window.customElements){var a=HTMLElement;window.HTMLElement=function(){return Reflect.construct(a,[],this.constructor)},HTMLElement.prototype=a.prototype,HTMLElement.prototype.constructor=HTMLElement,Object.setPrototypeOf(HTMLElement,a)}})(),vue_runtime_esm["default"].component(element_ui_common.Checkbox.name,element_ui_common.Checkbox);const formatDate$2$1=(date,excludeTime,onlyTime)=>{let dateformat="DD-MMM-YYYY",timeformat="HH:mm";// let orgformatArray = orgformat.match(/DD-MMM-YYYY (HH:mm)/)
return onlyTime?moment_timezone(date).format(timeformat):excludeTime?moment_timezone(date).format(dateformat):moment_timezone(date).format(dateformat+" "+timeformat)},getFormattedDuration$1$1=(value,format="milliseconds",skipDurationCreation=!1)=>{if(!value)return"00:00 Hrs";let duration;duration=skipDurationCreation?value:moment_timezone.duration(parseInt(value,10),format);let days=parseInt(duration.asDays(),10),hours=duration.hours(),minutes=duration.minutes(),seconds=duration.seconds();return days>0?1===days?hours?`${days} Day ${hours} Hrs`:`${days} Day`:hours?`${days} Days ${hours} Hrs`:`${days} Days`:hours>0?minutes?`${hours} Hrs ${minutes} Mins`:`${hours} Hrs`:minutes>0?seconds?`${minutes} Mins ${seconds} Secs`:`${minutes} Mins`:`${seconds} Secs`},DATA_TYPE_VALUE_HASH$2$1={LOOKUP(field,data){let{name:fieldName}=field,{primaryValue:primaryValue,name:name,displayName:displayName,subject:subject}=data[fieldName]||{},value=displayName||name||subject;return isEmpty$a(primaryValue)?value:primaryValue},FILE(field,data){let filename=data[`${field.name}FileName`];return filename},DATE(field,data){let{name:name}=field||{},value=data[name];return value&&-1!==value?formatDate$2$1(value,!0):""},DATE_TIME(field,data){let{name:name}=field||{},value=data[name];return value&&-1!==value?formatDate$2$1(value):""},ENUM(field,data){let{name:name}=field||{},value=data[name],fieldObj=field.field;return value=value?fieldObj.enumMap[data[fieldObj.name]]:value,value},SYSTEM_ENUM(field,data){let{name:name}=field||{},value=data[name],fieldObj=field.field;return value=value?fieldObj.enumMap[data[fieldObj.name]]:value,value},MULTI_ENUM(field,data){let{name:name,enumMap:enumMap}=field.field||{},values=data[name]||[],valueStr=values.reduce(((accStr,value)=>{let str=enumMap[value]||"";return isEmpty$a(accStr)?`${str}`:`${accStr}, ${str}`}),"");return isEmpty$a(valueStr)?"---":valueStr},BOOLEAN(field,data){let{name:name}=field||{},value=data[name]?field.trueVal||"Yes":field.falseVal||"No";return value},MULTI_LOOKUP(field,data){let{name:name}=field,value=data[name]||[],lookupRecordNames=(value||[]).map((currRecord=>currRecord.displayName||currRecord.name||currRecord.subject));return lookupRecordNames.length>2?`${lookupRecordNames.slice(0,2).join(", ")} +${Math.abs(lookupRecordNames.length-2)}`:isEmpty$a(lookupRecordNames)?"---":`${lookupRecordNames.join(", ")}`},OTHERS(field,data){let{name:name}=field||{};if(!isObject$5(data[name]))return data[name];{let{name:name}=data[name]||{};if(!isEmpty$a(name))return name;data[name]}}},DISPLAY_TYPE_HASH$4={DURATION(field,record){const h=this.$createElement;let{name:name}=field,value=record[name]||[];return h("div",[isEmpty$a(value)||"---"===value?"---":getFormattedDuration$1$1(value,isEmpty$a(field.unit)?"s":field.unit)])},URL_FIELD(field,record){const h=this.$createElement;let{name:name}=field||{};if(isEmpty$a(record[name]))return"---";{let{name:displayName,href:href,target:target}=record[name]||{},value=isEmpty$a(displayName)?href:displayName;return h(element_ui_common.Tooltip,{attrs:{effect:"dark",content:value,placement:"bottom-start"}},[h("a",{attrs:{rel:"nofollow",referrerpolicy:"no-referrer",href:href,target:target},class:"url-field-display truncate-text"},[h("span",{class:"textoverflow-ellipsis"},[value])])])}},OTHERS(field,record){const h=this.$createElement;return h("div",{class:"truncate-text"},[this.getColumnDisplayValue(field,record)])}};var script$a$3={props:["viewDetail","records","moduleName","redirectToOverview","columnConfig","slotList","hideListSelect","customButtonList","canShowCustomButton","refreshList","metaInfo"],computed:{viewColumns(){let columns=[],{viewDetail:viewDetail}=this,{fields:viewDetailFields=[]}=viewDetail;isEmpty$a(viewDetail)||isEmpty$a(viewDetailFields)||(columns=viewDetailFields.map((viewField=>{let{field:field,fieldName:fieldName}=viewField||{};field=field||{};let name=field.name||fieldName,fieldId=field.fieldId,defaultColumnName=viewDetail.defaultModuleFields&&viewDetail.defaultModuleFields[viewField.name]?viewDetail.defaultModuleFields[viewField.name].columnDisplayName:null,displayName=viewField.columnDisplayName||defaultColumnName||field.displayName;return viewField={...viewField,name:name,fieldId:fieldId,displayName:displayName},viewField})));let{columnConfig:columnConfig}=this,{fixedSelectableColumns:fixedSelectableColumns}=columnConfig||{};return isEmpty$a(columns)?[]:columns.filter((column=>!(fixedSelectableColumns||[]).includes(column.name)))},customFieldValueSlots(){let{slotList:slotList}=this;return isEmpty$a(slotList)?[]:slotList.filter((slotObj=>!slotObj.isActionColumn))},actionColumnSlots(){let{slotList:slotList}=this;return isEmpty$a(slotList)?[]:slotList.filter((slotObj=>slotObj.isActionColumn))},hardCodedSlots(){let{slotList:slotList}=this;return isEmpty$a(slotList)?[]:slotList.filter((slotObj=>slotObj.isHardcodedColumn))}},methods:{
// field type checks
isDecimalField(field){let{dataTypeEnum:dataTypeEnum}=field.field||{};return field.field&&"DECIMAL"===dataTypeEnum},isFixedColumn(name){let{columnConfig:{fixedColumns:fixedColumns}={}}=this;return(fixedColumns||[]).includes(name)},
// column display related methods
getColumnHeaderLabel(column){let{displayName:displayName,field:field}=column;if(!isEmpty$a(field)&&!isEmpty$a(field.unit)){let{unit:unit}=field;return`${displayName} (${unit})`}return displayName},getColumnDisplayValue(field,record){let value,{parentField:parentField}=field,fieldObj=field.field||field,{dataTypeEnum:dataTypeEnum}=fieldObj||{};// first level lookup value, related handling
if(!isEmpty$a(parentField)){let{name:lookupModuleName}=parentField||{};isEmpty$a(lookupModuleName)||isEmpty$a(record[lookupModuleName])||(record=record[lookupModuleName])}return isEmpty$a(DATA_TYPE_VALUE_HASH$2$1[dataTypeEnum])?value=DATA_TYPE_VALUE_HASH$2$1["OTHERS"](field,record,this):(dataTypeEnum=dataTypeEnum||dataTypeEnum._name,value=DATA_TYPE_VALUE_HASH$2$1[dataTypeEnum](field,record,this)),isEmpty$a(value)?"---":value},getColumnDisplayComponent(field,record){let fieldObj=field.field||field,{displayType:displayType}=fieldObj||{},{criteriaCheckForSlot:criteriaCheckForSlot}=this||{},{canRenderSlot:canRenderSlot,slotName:slotName}=criteriaCheckForSlot(field);return canRenderSlot&&!isEmpty$a(this.$scopedSlots[slotName])?this.$scopedSlots[slotName]({record:record}):isEmpty$a(this[displayType])?this["OTHERS"](field,record,this.getColumnDisplayValue):this[displayType](field,record,this.getColumnDisplayValue)},criteriaCheckForSlot(field){let{customFieldValueSlots:customFieldValueSlots}=this,canRenderSlot=!0,slotName="",fieldObj=field.field||field;if(!isEmpty$a(customFieldValueSlots))for(let currSlot of customFieldValueSlots){let{criteria:criteria}=currSlot||{};if(!isEmpty$a(criteria)){let slotCriteria=JSON.parse(criteria);if(isObject$5(slotCriteria)&&Object.keys(slotCriteria).forEach((fieldName=>{canRenderSlot=fieldObj[fieldName]===slotCriteria[fieldName]})),canRenderSlot){slotName=criteria;break}}}return{canRenderSlot:canRenderSlot,slotName:slotName}},
// redirects and event emiters
selectionChange(selected){this.$emit("selection-change",selected)},toggleVisibility(id,val){let{$el:$el}=this.$refs[`custom-btn-${id}`]||{},{classList:classList}=$el||{};val?classList.remove("visibility-hide-actions"):classList.add("visibility-hide-actions")},toggleRowSelection(item,val){let{moduleName:moduleName}=this||{},ref=this.$refs[`${moduleName}-list`];ref.toggleRowSelection(item,val)},clearSelection(){let{moduleName:moduleName}=this||{},ref=this.$refs[`${moduleName}-list`];ref.clearSelection()},
// display type hash
...DISPLAY_TYPE_HASH$4},render(){const h=arguments[0];return h(element_ui_common.Table,{attrs:{data:this.records,height:"100%",fit:!0,"row-class-name":"no-hover"},ref:`${this.moduleName}-list`,style:"width: 100%;",class:"table-border",on:{"selection-change":this.selectionChange}},[!this.hideListSelect&&h(element_ui_common.TableColumn,{attrs:{fixed:!0,align:"left",type:"selection",width:"60"}}),this.hardCodedSlots.map(((slotObj,index)=>h(element_ui_common.TableColumn,helper$3([{key:`${slotObj.name}-${index}`},{scopedSlots:{default:data=>this.$scopedSlots[slotObj.name]({record:data.row})}},{attrs:{...slotObj.columnAttrs||{}}}])))),this.viewColumns.map(((field,index)=>h(element_ui_common.TableColumn,helper$3([{attrs:{fixed:this.isFixedColumn(field.name),prop:field.name,label:this.getColumnHeaderLabel(field),align:this.isDecimalField(field)?"right":"left","min-width":"230"},key:index},{scopedSlots:{default:data=>this.getColumnDisplayComponent(field,data.row)}},{attrs:{...field.columnAttrs||{}}}])))),this.actionColumnSlots.map(((slotObj,index)=>h(element_ui_common.TableColumn,helper$3([{key:`${slotObj.name}-${index}`},{scopedSlots:{default:data=>this.$scopedSlots[slotObj.name]({record:data.row})}},{attrs:{...slotObj.columnAttrs||{}}}]))))])}};function normalizeComponent$9(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier
/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);// Vue.extend constructor export interop.
const options="function"===typeof script?script.options:script;// render functions
let hook;if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,// functional template
isFunctionalTemplate&&(options.functional=!0)),// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),// inject component styles
style&&style.call(this,createInjectorSSR(context)),// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(context){style.call(this,createInjectorShadow(context,this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
const originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
const existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}const isOldIE$6="undefined"!==typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());function createInjector$6(context){return(id,style)=>addStyle$9(id,style)}let HEAD$6;const styles$9={};function addStyle$9(id,css){const group=isOldIE$6?css.media||"default":id,style=styles$9[group]||(styles$9[group]={ids:new Set,styles:[]});if(!style.ids.has(id)){style.ids.add(id);let code=css.source;if(css.map&&(
// https://developer.chrome.com/devtools/docs/javascript-debugging
// this makes source maps inside style tags work properly in Chrome
code+="\n/*# sourceURL="+css.map.sources[0]+" */",// http://stackoverflow.com/a/26603875
code+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(css.map))))+" */"),style.element||(style.element=document.createElement("style"),style.element.type="text/css",css.media&&style.element.setAttribute("media",css.media),void 0===HEAD$6&&(HEAD$6=document.head||document.getElementsByTagName("head")[0]),HEAD$6.appendChild(style.element)),"styleSheet"in style.element)style.styles.push(code),style.element.styleSheet.cssText=style.styles.filter(Boolean).join("\n");else{const index=style.ids.size-1,textNode=document.createTextNode(code),nodes=style.element.childNodes;nodes[index]&&style.element.removeChild(nodes[index]),nodes.length?style.element.insertBefore(textNode,nodes[index]):style.element.appendChild(textNode)}}}
/* script */const __vue_script__$a$3=script$a$3,__vue_inject_styles__$a$3=function(inject){inject&&inject("data-v-64fad4c9_0",{source:".url-field-display[data-v-64fad4c9]{color:#46a2bf}.url-field-display[data-v-64fad4c9]:hover{text-decoration:underline;text-underline-offset:3px;color:#46a2bf}",map:void 0,media:void 0})},__vue_scope_id__$a$3="data-v-64fad4c9",__vue_module_identifier__$a$3=void 0,__vue_is_functional_template__$a$3=void 0,__vue_component__$a$3=normalizeComponent$9({},__vue_inject_styles__$a$3,__vue_script__$a$3,__vue_scope_id__$a$3,__vue_is_functional_template__$a$3,__vue_module_identifier__$a$3,!1,createInjector$6,void 0,void 0);
/* template */
/* style */
defineCustomElements$3();
var script$r={name:"spinner",props:["show","size","colour"],computed:{spinnerSize(){return this.size?this.size+"px":"50px"},strokeColor(){return this.colour?this.colour:"#fd4b92"}}};
/* script */const __vue_script__$r=script$r;
/* template */var __vue_render__$o=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("transition",[_c("svg",{directives:[{name:"show",rawName:"v-show",value:_vm.show,expression:"show"}],staticClass:"spinner",class:{show:_vm.show},attrs:{width:_vm.spinnerSize,height:_vm.spinnerSize,viewBox:"0 0 44 44"}},[_c("circle",{staticClass:"path",style:{stroke:_vm.strokeColor},attrs:{fill:"none","stroke-width":"4","stroke-linecap":"round",cx:"22",cy:"22",r:"20"}})])])},__vue_staticRenderFns__$o=[];
/* style */
const __vue_inject_styles__$r=function(inject){inject&&inject("data-v-3994ea33_0",{source:".spinner[data-v-3994ea33]{transition:opacity .15s ease;animation:rotator-data-v-3994ea33 1.4s linear infinite;animation-play-state:paused}.spinner.show[data-v-3994ea33]{animation-play-state:running}.spinner.v-enter[data-v-3994ea33],.spinner.v-leave-active[data-v-3994ea33]{opacity:0}.spinner.v-enter-active[data-v-3994ea33],.spinner.v-leave[data-v-3994ea33]{opacity:1}.spinner .path[data-v-3994ea33]{stroke-dasharray:126;stroke-dashoffset:0;transform-origin:center;animation:dash-data-v-3994ea33 1.4s ease-in-out infinite}@-moz-keyframes rotator-data-v-3994ea33{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-webkit-keyframes rotator-data-v-3994ea33{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-o-keyframes rotator-data-v-3994ea33{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@keyframes rotator-data-v-3994ea33{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-moz-keyframes dash-data-v-3994ea33{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@-webkit-keyframes dash-data-v-3994ea33{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@-o-keyframes dash-data-v-3994ea33{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@keyframes dash-data-v-3994ea33{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}",map:void 0,media:void 0})},__vue_scope_id__$r="data-v-3994ea33",__vue_module_identifier__$r=void 0,__vue_is_functional_template__$r=!1,__vue_component__$q=normalizeComponent$a({render:__vue_render__$o,staticRenderFns:__vue_staticRenderFns__$o},__vue_inject_styles__$r,__vue_script__$r,__vue_scope_id__$r,__vue_is_functional_template__$r,__vue_module_identifier__$r,!1,createInjector$7,void 0,void 0);
/* scoped */
var script$p={props:["currentPage","perPage","total","hideToggle"],data(){return{from:0,to:0,page:1}},mounted(){this.init()},watch:{total(){this.init()},currentPage(val){val!==this.page&&this.init()}},methods:{init(){this.page=this.currentPage||1,this.from=(this.page-1)*this.perPage+1;let to=this.from+this.perPage-1;this.to=this.total>to?to:this.total},next(){this.from=this.to+1,this.to+=this.perPage,this.to>this.total&&(this.to=this.total),this.page++,
// Update currentPage value
this.$emit("update:currentPage",this.page)},prev(){this.to=this.from-1,this.from-=this.perPage,this.from<=1?this.from=this.page=1:this.page--,
// Update currentPage value
this.$emit("update:currentPage",this.page)}}};
/* script */const __vue_script__$p=script$p;
/* template */var __vue_render__$m=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _vm.total>0?_c("div",{staticClass:"f-ui-widget-pagination"},[_vm.from!==_vm.to?_c("span",[_vm._v(_vm._s(_vm.from)+" -")]):_vm._e(),_vm._v(" "),_c("span",[_vm._v(_vm._s(_vm.to))]),_vm._v(" "),_vm.hideToggle?_vm._e():[_c("span",{staticClass:"pl-1 pr-3"},[_vm._v("of "+_vm._s(_vm.total))]),_vm._v(" "),_c("span",{staticClass:"el-icon-arrow-left arrow-icons cursor-pointer",class:{disable:_vm.from<=1},on:{click:function($event){_vm.from>1&&_vm.prev()}}}),_vm._v(" "),_c("span",{staticClass:"el-icon-arrow-right arrow-icons cursor-pointer",class:{disable:_vm.to===_vm.total},on:{click:function($event){_vm.to!==_vm.total&&_vm.next()}}})]],2):_vm._e()},__vue_staticRenderFns__$m=[];
/* style */
const __vue_inject_styles__$p=function(inject){inject&&inject("data-v-dec3861c_0",{source:".f-ui-widget-pagination{display:flex;align-items:center;font-size:12px;font-weight:500;font-style:normal;letter-spacing:1px;color:#50506c}.f-ui-widget-pagination .arrow-icons{font-size:15px}.f-ui-widget-pagination .disable{opacity:.5;cursor:not-allowed}.f-ui-widget-pagination .el-icon-arrow-left{padding:4px 3px;border-radius:4px;border:1px solid transparent}.f-ui-widget-pagination .el-icon-arrow-left:hover{color:#615e88;background:#f5f6f8;border:1px solid #dae0e8}.f-ui-widget-pagination .el-icon-arrow-right{padding:4px 3px;border-radius:4px;border:1px solid transparent}.f-ui-widget-pagination .el-icon-arrow-right:hover{color:#615e88;background:#f5f6f8;border:1px solid #dae0e8}",map:void 0,media:void 0})},__vue_scope_id__$p=void 0,__vue_module_identifier__$p=void 0,__vue_is_functional_template__$p=!1,__vue_component__$o=normalizeComponent$a({render:__vue_render__$m,staticRenderFns:__vue_staticRenderFns__$m},__vue_inject_styles__$p,__vue_script__$p,__vue_scope_id__$p,__vue_is_functional_template__$p,__vue_module_identifier__$p,!1,createInjector$7,void 0,void 0);
/* scoped */var EmptyIcon$3={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{width:"87",height:"66",viewBox:"0 0 87 66",xmlns:"http://www.w3.org/2000/svg"}},[_c("g",{attrs:{transform:"translate(0 .87)",fill:"none","fill-rule":"evenodd"}},[_c("path",{attrs:{stroke:"#7176C4",fill:"#FFF","stroke-linecap":"round","stroke-linejoin":"round",d:"M76.196 57.682l-2.284-3.27 5.511-3.86 5.002 7.144"}}),_c("path",{attrs:{fill:"#DBDBF3",d:"M75.243 54.064l3.99-2.793 4.646 6.636-5.915.044z"}}),_c("path",{attrs:{fill:"#FFF",d:"M77.846 52.252l.926-.649 3.96 5.657-.925.648zm-1.073.746l.819-.573 3.461 4.943-.819.574z"}}),_c("path",{attrs:{stroke:"#7176C4","stroke-linecap":"round","stroke-linejoin":"round",d:"M.5 57.682h85.874m-31.686 6.635h10.86m-44.222 0h24.253"}}),_c("path",{attrs:{stroke:"#FFF","stroke-linecap":"round","stroke-linejoin":"round",d:"M57.377 33.73h0m10.875 0h0"}}),_c("path",{attrs:{stroke:"#7176C4","stroke-linecap":"round","stroke-linejoin":"round",d:"M25.525 57.111V.5h35.062l7.666 7.725v48.887"}}),_c("path",{attrs:{stroke:"#7176C4","stroke-linecap":"round","stroke-linejoin":"round",d:"M60.682.5l7.571 7.57h-7.57z"}}),_c("path",{attrs:{fill:"#DBDBF3",d:"M67.806 15.954l-7.57-7.57h7.57zM21.507 6.16h3.509v50.952h-3.509z"}}),_c("path",{attrs:{stroke:"#7176C4","stroke-linecap":"round","stroke-linejoin":"round",d:"M7.482 57.16v-51h18.043"}}),_c("path",{attrs:{d:"M72.705 22.132a18.131 18.131 0 018.923 9.319M73.27 19.113c.4.2.795.413 1.182.638m1.443.912a21.96 21.96 0 013.622 3.122",stroke:"#BCBCE2","stroke-linecap":"round","stroke-linejoin":"round"}}),_c("path",{attrs:{fill:"#AAAAE2",opacity:".5",d:"M33.001 35.954h28.027V34.13H33.001zm0-5h28.027V29.13H33.001z"}}),_c("path",{attrs:{"fill-opacity":".5",fill:"#DBDBF3",d:"M33.001 40.954h28.027V39.13H33.001zM33 45.977h14.014v-1.823H33z"}}),_c("path",{attrs:{fill:"#AAAAE2",opacity:".5",d:"M33.001 9.954h25.34V8.13h-25.34z"}}),_c("path",{attrs:{"fill-opacity":".5",fill:"#DBDBF3",d:"M33.001 14.954h25.34V13.13h-25.34zM33 19.977h14.014v-1.823H33z"}}),_c("path",{attrs:{fill:"#AAAAE2",opacity:".5",d:"M12 14.954h9.551V13.13h-9.55z"}}),_c("path",{attrs:{"fill-opacity":".5",fill:"#DBDBF3",d:"M12 19.954h9.551V18.13h-9.55z"}}),_c("path",{attrs:{stroke:"#7176C4",fill:"#FFF","stroke-linecap":"round","stroke-linejoin":"round",d:"M69.658 45.844l3.277-2.294 5.725 8.176-3.276 2.295z"}}),_c("path",{attrs:{"fill-opacity":".3",fill:"#7176C4",d:"M70.218 47.319l3.898-2.73 1.98 2.83-3.897 2.728z"}}),_c("path",{attrs:{d:"M64.459 52.077c1.146 0 2.257-.148 3.316-.425.088-25.227.088-24.887.088-25.227a13.067 13.067 0 00-3.404-.448c-7.208 0-13.05 5.842-13.05 13.05 0 7.207 5.842 13.05 13.05 13.05z","fill-opacity":".3",fill:"#BCBCE2"}}),_c("circle",{attrs:{stroke:"#7176C4",fill:"#FFF","stroke-linecap":"round","stroke-linejoin":"round",cx:"65.99",cy:"37.431",r:"11.302"}}),_c("path",{attrs:{"fill-opacity":".5",fill:"#DBDBF3",d:"M12 24.977h7.112v-1.823H12z"}}),_c("circle",{attrs:{fill:"#DBDBF3",cx:"66.262",cy:"37.704",r:"10.489"}}),_c("circle",{attrs:{fill:"#FFF",cx:"65.99",cy:"37.431",r:"8.127"}}),_c("path",{attrs:{d:"M74.117 37.431c0-.687-.086-1.355-.246-1.992m-.685-1.788a8.127 8.127 0 10-7.196 11.907h0m7.167 1.072l1.29 1.815m1.013 1.424l.253.357",stroke:"#7176C4",fill:"#FFF","stroke-linecap":"round","stroke-linejoin":"round"}}),_c("circle",{attrs:{fill:"#EDEDF9",cx:"66.829",cy:"33.959",r:"2.829"}}),_c("circle",{attrs:{fill:"#EDEDF9",cx:"70.75",cy:"37.959",r:"1.171"}})])])}},AdvancedFilterIcon$2={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",width:"13",height:"10",viewBox:"0 0 13 10"}},[_c("path",{attrs:{fill:"#6C6A91",d:"M7.966 8.738c.351 0 .635.282.635.63 0 .35-.284.632-.635.632H5.034a.633.633 0 01-.635-.631c0-.349.284-.631.635-.631h2.932zm1.955-4.38a.632.632 0 110 1.263H3.079a.633.633 0 01-.635-.631c0-.349.284-.631.635-.631h6.842zM12.365 0c.35 0 .635.283.635.631a.632.632 0 01-.635.631H.635A.632.632 0 11.635 0h11.73z"}})])}};function styleInject$5(css,ref){void 0===ref&&(ref={});var insertAt=ref.insertAt;if(css&&"undefined"!==typeof document){var head=document.head||document.getElementsByTagName("head")[0],style=document.createElement("style");style.type="text/css","top"===insertAt&&head.firstChild?head.insertBefore(style,head.firstChild):head.appendChild(style),style.styleSheet?style.styleSheet.cssText=css:style.appendChild(document.createTextNode(css))}}var css_248z$8="*, ::before, ::after {\n  --tw-border-opacity: 1;\n  border-color: rgba(229, 231, 235, var(--tw-border-opacity))\n}\n\n.fixed {\n  position: fixed\n}\n\n.float-right {\n  float: right\n}\n\n.m-0 {\n  margin: 0px\n}\n\n.m-0\\.5 {\n  margin: 0.125rem\n}\n\n.my-1 {\n  margin-top: 0.25rem;\n  margin-bottom: 0.25rem\n}\n\n.my-4 {\n  margin-top: 1rem;\n  margin-bottom: 1rem\n}\n\n.mt-auto {\n  margin-top: auto\n}\n\n.mr-1 {\n  margin-right: 0.25rem\n}\n\n.mr-2 {\n  margin-right: 0.5rem\n}\n\n.mr-3 {\n  margin-right: 0.75rem\n}\n\n.mr-1\\.5 {\n  margin-right: 0.375rem\n}\n\n.mb-2 {\n  margin-bottom: 0.5rem\n}\n\n.mb-2\\.5 {\n  margin-bottom: 0.625rem\n}\n\n.ml-5 {\n  margin-left: 1.25rem\n}\n\n.ml-auto {\n  margin-left: auto\n}\n\n.flex {\n  display: flex\n}\n\n.table {\n  display: table\n}\n\n.hidden {\n  display: none\n}\n\n.h-4 {\n  height: 1rem\n}\n\n.h-6 {\n  height: 1.5rem\n}\n\n.h-9 {\n  height: 2.25rem\n}\n\n.h-10 {\n  height: 2.5rem\n}\n\n.h-20 {\n  height: 5rem\n}\n\n.h-40 {\n  height: 10rem\n}\n\n.h-full {\n  height: 100%\n}\n\n.w-4 {\n  width: 1rem\n}\n\n.w-6 {\n  width: 1.5rem\n}\n\n.w-9 {\n  width: 2.25rem\n}\n\n.w-10 {\n  width: 2.5rem\n}\n\n.w-12 {\n  width: 3rem\n}\n\n.w-28 {\n  width: 7rem\n}\n\n.w-40 {\n  width: 10rem\n}\n\n.w-10\\/12 {\n  width: 83.333333%\n}\n\n.w-full {\n  width: 100%\n}\n\n.border-collapse {\n  border-collapse: collapse\n}\n\n.transform {\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  transform: translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))\n}\n\n@keyframes spin {\n  to {\n    transform: rotate(360deg)\n  }\n}\n\n@keyframes ping {\n  75%, 100% {\n    transform: scale(2);\n    opacity: 0\n  }\n}\n\n@keyframes pulse {\n  50% {\n    opacity: .5\n  }\n}\n\n@keyframes bounce {\n  0%, 100% {\n    transform: translateY(-25%);\n    animation-timing-function: cubic-bezier(0.8,0,1,1)\n  }\n\n  50% {\n    transform: none;\n    animation-timing-function: cubic-bezier(0,0,0.2,1)\n  }\n}\n\n.cursor-pointer {\n  cursor: pointer\n}\n\n.flex-col {\n  flex-direction: column\n}\n\n.flex-wrap {\n  flex-wrap: wrap\n}\n\n.flex-nowrap {\n  flex-wrap: nowrap\n}\n\n.items-center {\n  align-items: center\n}\n\n.justify-center {\n  justify-content: center\n}\n\n.justify-between {\n  justify-content: space-between\n}\n\n.self-center {\n  align-self: center\n}\n\n.border {\n  border-width: 1px\n}\n\n.py-1 {\n  padding-top: 0.25rem;\n  padding-bottom: 0.25rem\n}\n\n.py-2 {\n  padding-top: 0.5rem;\n  padding-bottom: 0.5rem\n}\n\n.py-1\\.5 {\n  padding-top: 0.375rem;\n  padding-bottom: 0.375rem\n}\n\n.pr-3 {\n  padding-right: 0.75rem\n}\n\n.pl-1 {\n  padding-left: 0.25rem\n}\n\n.text-left {\n  text-align: left\n}\n\n.text-center {\n  text-align: center\n}\n\n.text-xs {\n  font-size: 0.75rem;\n  line-height: 1rem\n}\n\n.uppercase {\n  text-transform: uppercase\n}\n\n.italic {\n  font-style: italic\n}\n\n.underline {\n  text-decoration: underline\n}\n\n*, ::before, ::after {\n  --tw-shadow: 0 0 #0000\n}\n\n*, ::before, ::after {\n  --tw-ring-inset: var(--tw-empty,/*!*/ /*!*/);\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgba(59, 130, 246, 0.5);\n  --tw-ring-offset-shadow: 0 0 #0000;\n  --tw-ring-shadow: 0 0 #0000\n}\n\n.filter {\n  --tw-blur: var(--tw-empty,/*!*/ /*!*/);\n  --tw-brightness: var(--tw-empty,/*!*/ /*!*/);\n  --tw-contrast: var(--tw-empty,/*!*/ /*!*/);\n  --tw-grayscale: var(--tw-empty,/*!*/ /*!*/);\n  --tw-hue-rotate: var(--tw-empty,/*!*/ /*!*/);\n  --tw-invert: var(--tw-empty,/*!*/ /*!*/);\n  --tw-saturate: var(--tw-empty,/*!*/ /*!*/);\n  --tw-sepia: var(--tw-empty,/*!*/ /*!*/);\n  --tw-drop-shadow: var(--tw-empty,/*!*/ /*!*/);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)\n}\n\n.blur {\n  --tw-blur: blur(8px)\n}\n\n.transition {\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms\n}\n\n.ease-in-out {\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1)\n}\n\n@media (min-width: 640px) {\n}\n\n@media (min-width: 768px) {\n}\n\n@media (min-width: 1024px) {\n}\n\n@media (min-width: 1280px) {\n}\n\n@media (min-width: 1536px) {\n}\n";styleInject$5(css_248z$8);var css_248z$7="/*purgecss start ignore*/\n\n.f-ui-base-text-input .el-input__inner, .f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input__inner,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input__inner, .f-ui-forms .f-ui-date-picker .el-input__inner, .f-ui-forms .f-ui-time-picker .el-input__inner, .f-ui-forms .f-ui-select .el-input__inner, .f-ui-forms .f-ui-text-input .el-input__inner {\n  height: 40px;\n  line-height: 40px;\n  padding-left: 15px;\n  padding-right: 15px;\n  border-radius: 3px;\n  background-color: #fff;\n  border: 1px solid #d0d9e2;\n  font-size: 14px;\n  letter-spacing: 0.4px;\n  color: #324056;\n  text-overflow: ellipsis;\n  font-weight: 400;\n  padding-right: 30px;\n  white-space: nowrap;\n}\n\n.f-ui-base-text-input .el-input__inner:hover, .f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input__inner:hover,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input__inner:hover, .f-ui-forms .f-ui-date-picker .el-input__inner:hover, .f-ui-forms .f-ui-time-picker .el-input__inner:hover, .f-ui-forms .f-ui-select .el-input__inner:hover, .f-ui-forms .f-ui-text-input .el-input__inner:hover,\n.f-ui-base-text-input .el-input__inner:focus,\n.f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input__inner:focus,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input__inner:focus,\n.f-ui-forms .f-ui-date-picker .el-input__inner:focus,\n.f-ui-forms .f-ui-time-picker .el-input__inner:focus,\n.f-ui-forms .f-ui-select .el-input__inner:focus,\n.f-ui-forms .f-ui-text-input .el-input__inner:focus {\n  border-color: #39b2c2;\n}\n\n.f-ui-base-text-input .el-input.is-focus .el-input__inner, .f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input.is-focus .el-input__inner,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input.is-focus .el-input__inner, .f-ui-forms .f-ui-date-picker .el-input.is-focus .el-input__inner, .f-ui-forms .f-ui-time-picker .el-input.is-focus .el-input__inner, .f-ui-forms .f-ui-select .el-input.is-focus .el-input__inner, .f-ui-forms .f-ui-text-input .el-input.is-focus .el-input__inner {\n  border-color: #39b2c2;\n}\n\n.f-ui-base-text-input .el-input__inner[disabled=disabled], .f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input__inner[disabled=disabled],\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input__inner[disabled=disabled], .f-ui-forms .f-ui-date-picker .el-input__inner[disabled=disabled], .f-ui-forms .f-ui-time-picker .el-input__inner[disabled=disabled], .f-ui-forms .f-ui-select .el-input__inner[disabled=disabled], .f-ui-forms .f-ui-text-input .el-input__inner[disabled=disabled] {\n  background-color: #f5f7fa;\n  border-color: #e4e7ed;\n  color: #c0c4cc;\n}\n\n.f-ui-base-text-input input::-webkit-outer-spin-button, .f-date-picker-popper .el-date-picker__editor-wrap .el-input input::-webkit-outer-spin-button,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input input::-webkit-outer-spin-button, .f-ui-forms .f-ui-date-picker input::-webkit-outer-spin-button, .f-ui-forms .f-ui-time-picker input::-webkit-outer-spin-button, .f-ui-forms .f-ui-select input::-webkit-outer-spin-button, .f-ui-forms .f-ui-text-input input::-webkit-outer-spin-button,\n.f-ui-base-text-input input::-webkit-inner-spin-button,\n.f-date-picker-popper .el-date-picker__editor-wrap .el-input input::-webkit-inner-spin-button,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input input::-webkit-inner-spin-button,\n.f-ui-forms .f-ui-date-picker input::-webkit-inner-spin-button,\n.f-ui-forms .f-ui-time-picker input::-webkit-inner-spin-button,\n.f-ui-forms .f-ui-select input::-webkit-inner-spin-button,\n.f-ui-forms .f-ui-text-input input::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n\n.f-ui-base-text-input input[type=number], .f-date-picker-popper .el-date-picker__editor-wrap .el-input input[type=number],\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input input[type=number], .f-ui-forms .f-ui-date-picker input[type=number], .f-ui-forms .f-ui-time-picker input[type=number], .f-ui-forms .f-ui-select input[type=number], .f-ui-forms .f-ui-text-input input[type=number] {\n  -moz-appearance: textfield;\n}\n\n.f-ui-forms .f-ui-select-tag .el-tag,\n.f-ui-forms .f-ui-lookup-container .el-tag {\n  border-radius: 50px;\n  border: solid 1px #39b2c2;\n  letter-spacing: 0.4px;\n  color: #39b2c2;\n  line-height: 25px;\n  height: 25px;\n  background: #fff;\n}\n\n.f-ui-forms .f-ui-select-tag .el-tag .el-icon-close,\n.f-ui-forms .f-ui-lookup-container .el-tag .el-icon-close {\n  color: #39b2c2;\n  background: transparent;\n  font-size: 16px;\n  padding-right: 10px;\n  font-weight: 600;\n  margin-right: 5px;\n  line-height: 15px;\n}\n\n.f-ui-forms .f-ui-select-tag .el-tag .el-icon-close:hover,\n.f-ui-forms .f-ui-lookup-container .el-tag .el-icon-close:hover {\n  background: transparent;\n  color: #39b2c2;\n}\n\n.f-ui-forms .f-ui-select-tag .el-select__tags,\n.f-ui-forms .f-ui-lookup-container .el-select__tags {\n  padding-left: 0;\n}\n\n.f-ui-forms .f-ui-select-tag .el-select__tags-text,\n.f-ui-forms .f-ui-lookup-container .el-select__tags-text {\n  max-width: 70px;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n  display: block;\n}\n\n.f-ui-forms .f-ui-time-picker {\n  width: 100%;\n}\n\n.f-ui-forms .f-ui-time-picker .el-input__inner {\n  padding-left: 30px;\n}\n\n.f-ui-forms .f-ui-date-picker {\n  width: 100%;\n}\n\n.f-ui-forms .f-ui-date-picker .el-input__inner {\n  padding-left: 30px;\n}\n\n.f-ui-forms .f-ui-date-picker.is-active,\n.f-ui-forms .f-ui-date-picker.is-active:hover {\n  border-color: #39b2c2;\n}\n\n.f-ui-forms .f-ui-tag {\n  border-radius: 50px;\n  border: solid 1px #39b2c2;\n  letter-spacing: 0.4px;\n  color: #39b2c2;\n  line-height: 25px;\n  height: 25px;\n  background: #fff;\n}\n\n.f-ui-forms .f-ui-tag .el-icon-close {\n  color: #39b2c2;\n  background: transparent;\n  font-size: 14px;\n  padding-right: 10px;\n  font-weight: 600;\n  margin-right: 5px;\n  line-height: 15px;\n  margin-top: 3px;\n}\n\n.f-ui-forms .f-ui-tag .el-icon-close:hover {\n  background: transparent;\n  color: #39b2c2;\n}\n\n.f-ui-forms .f-ui-icon-hover {\n  border: solid 1px transparent;\n  border-radius: 4px;\n}\n\n.f-ui-forms .f-ui-icon-hover:hover {\n  color: #615e88;\n  background: #f5f6f8;\n  border: 1px solid #dae0e8;\n}\n\n.f-ui-select-popper .f-ui-select-item {\n  display: flex;\n}\n\n.f-ui-select-popper .f-ui-select-item.selected {\n  font-weight: 400 !important;\n  /*color: #ef4f8f;*/\n  color: #ff3184;\n  letter-spacing: 1px !important;\n  font-size: 14px !important;\n}\n\n.f-ui-select-popper.is-multiple .f-ui-select-item {\n  display: flex;\n}\n\n.f-ui-select-popper.is-multiple .f-ui-select-item.selected {\n  color: #39b2c2 !important;\n}\n\n.f-date-picker-popper .el-picker-panel__footer .el-button--text {\n  color: #39b2c2;\n}\n\n.f-date-picker-popper .el-date-table td.available:hover,\n.f-date-picker-popper .el-date-table td.today span,\n.f-date-picker-popper .el-month-table td .cell:hover,\n.f-date-picker-popper .el-month-table td.today .cell,\n.f-date-picker-popper .el-year-table td .cell:hover,\n.f-date-picker-popper .el-year-table td.current:not(.disabled) .cell,\n.f-date-picker-popper .el-year-table td.today .cell,\n.f-date-picker-popper .el-time-panel__btn.confirm {\n  color: #39b2c2;\n}\n\n.f-date-picker-popper .el-date-table td.current:not(.disabled) span,\n.f-date-picker-popper .el-date-table td.end-date span,\n.f-date-picker-popper .el-date-table td.start-date span {\n  color: #fff;\n  background-color: #39b2c2;\n}\n\n.f-date-picker-popper .el-date-picker__header-label.active,\n.f-date-picker-popper .el-date-picker__header-label:hover {\n  color: #ff3184;\n}\n\n/*purgecss end ignore*/";styleInject$5(css_248z$7);
var script$q={name:"TextInput",components:{Input:element_ui_common.Input},props:["value","disabled","readonly"],data(){return{props:{},inputValue:""}},watch:{value:{handler(newVal,oldVal){newVal!==oldVal&&(this.inputValue=newVal)},immediate:!0}},mounted(){this.getProps()},methods:{getProps(){let props=this.$vnode.elm.attributes;Object.keys(props).forEach((key=>{this.$set(this.props,props[key].name,props[key].nodeValue)}))},change(value){this.$emit("input",value),this.$emit("change",value)},blur(...args){this.$emit("blur",args)},input(value){this.$emit("input",value)}}};function normalizeComponent$7(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);
// Vue.extend constructor export interop.
const options="function"===typeof script?script.options:script;
// render functions
let hook;if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,
// functional template
isFunctionalTemplate&&(options.functional=!0)),
// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),
// inject component styles
style&&style.call(this,createInjectorSSR(context)),
// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},
// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(context){style.call(this,createInjectorShadow(context,this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
const originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
const existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}const isOldIE$4="undefined"!==typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());function createInjector$4(context){return(id,style)=>addStyle$7(id,style)}let HEAD$4;const styles$7={};function addStyle$7(id,css){const group=isOldIE$4?css.media||"default":id,style=styles$7[group]||(styles$7[group]={ids:new Set,styles:[]});if(!style.ids.has(id)){style.ids.add(id);let code=css.source;if(css.map&&(
// https://developer.chrome.com/devtools/docs/javascript-debugging
// this makes source maps inside style tags work properly in Chrome
code+="\n/*# sourceURL="+css.map.sources[0]+" */",
// http://stackoverflow.com/a/26603875
code+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(css.map))))+" */"),style.element||(style.element=document.createElement("style"),style.element.type="text/css",css.media&&style.element.setAttribute("media",css.media),void 0===HEAD$4&&(HEAD$4=document.head||document.getElementsByTagName("head")[0]),HEAD$4.appendChild(style.element)),"styleSheet"in style.element)style.styles.push(code),style.element.styleSheet.cssText=style.styles.filter(Boolean).join("\n");else{const index=style.ids.size-1,textNode=document.createTextNode(code),nodes=style.element.childNodes;nodes[index]&&style.element.removeChild(nodes[index]),nodes.length?style.element.insertBefore(textNode,nodes[index]):style.element.appendChild(textNode)}}}
/* script */const __vue_script__$q=script$q;
/* template */var __vue_render__$n=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"f-ui-forms"},[_c("Input",_vm._b({staticClass:"f-ui-text-input",attrs:{disabled:_vm.disabled,readonly:_vm.readonly},on:{change:_vm.change,blur:_vm.blur,input:_vm.input},model:{value:_vm.inputValue,callback:function($$v){_vm.inputValue=$$v},expression:"inputValue"}},"Input",_vm.props,!1))],1)},__vue_staticRenderFns__$n=[];
/* style */
const __vue_inject_styles__$q=function(inject){inject&&inject("data-v-1c999eb9_0",{source:".f-ui-text-input .el-input__inner{height:40px;line-height:40px;padding-left:15px;padding-right:15px;border-radius:3px;background-color:#fff;border:1px solid #d0d9e2;font-size:14px;letter-spacing:.4px;color:#324056;text-overflow:ellipsis;font-weight:400;padding-right:30px;white-space:nowrap}",map:void 0,media:void 0})},__vue_scope_id__$q=void 0,__vue_module_identifier__$q=void 0,__vue_is_functional_template__$q=!1,__vue_component__$p=normalizeComponent$7({render:__vue_render__$n,staticRenderFns:__vue_staticRenderFns__$n},__vue_inject_styles__$q,__vue_script__$q,__vue_scope_id__$q,__vue_is_functional_template__$q,__vue_module_identifier__$q,!1,createInjector$4,void 0,void 0),isEmpty$8=value=>void 0===value||null===value||-1===Number(value)||"object"===typeof value&&!(value instanceof Blob)&&0===Object.keys(value).length||"string"===typeof value&&0===value.trim().length,isNull$2=value=>null===value,isArray$2=value=>value&&value.constructor===Array,isObject$4=obj=>null!==obj&&"object"===typeof obj&&!1===Array.isArray(obj),isFunction$6=value=>"function"===typeof value;
/* scoped */var Constants$2={FIELD_PLACEHOLDERS:["${CURRENT_DATE}","${CURRENT_TIME}","${LOGGED_USER}","${LOGGED_TENANT}","${LOGGED_VENDOR}"],LOOKUP_FILTER_ENABLED_FIELDS:["resource","people"],LOOKUP_FILTERS_MAP:{1:"building",2:"asset",3:"tenantcontact",4:"clientcontact",5:"vendorcontact",6:"employee"},QUICK_FILTERS:[{value:null,key:"category",placeHolderText:"Category",lookupModule:{name:null},disabled:!1,options:[]},{spaceType:1,value:null,key:"site",placeHolderText:"Site",lookupModule:{name:"site"},disabled:!1,options:[]},{spaceType:2,value:null,key:"building",placeHolderText:"Building",lookupModule:{name:"building"},disabled:!1,options:[]},{spaceType:3,value:null,key:"floor",placeHolderText:"Floor",lookupModule:{name:"floor"},disabled:!0,options:[]},{spaceType:4,value:null,key:"space",placeHolderText:"Space",lookupModule:{name:"basespace"},disabled:!0,options:[]}]};const constructOptionsToMap$2=valueArr=>{let optionsObj=valueArr.reduce(((optionsObj,option)=>{let{label:label,value:value}=option||{};return optionsObj[value]=label,optionsObj}),{});return optionsObj},deepClean$1=objValue=>{
/**
    Deep cleans the object based on isEmpty in util/validation.
    @param {Object,Array}
    @result {Object,Array} Deep cleaned
    Sample Input => {
          a: { b: null, c: 1 },
          d: null,
          e: -1,
          f: [],
          l: [{ a: null }, { b: 2 }, 3],
          h: 100,
          i: [1, 2, '', -1],
          j: [{}, -1, ''],
          k: [{ a: null, b: [[[]]] }, -1, ''],
        }
    Sample Output => {
          a: { c: 1 },
          h: 100,
          i: [1, 2],
          l: [{ b: 2 }, 3],
        }
  */
let obj=cloneDeep(objValue);return transform(obj,((result,value,key)=>{if((isArray$2(value)||isObject$4(value))&&(value=deepClean$1(value)),!isEmpty$8(value))return isArray$2(result)?result.push(value):void(result[key]=value)}))},getFieldOptions$2=async props=>{let{field:field,siteId:siteId,searchText:searchText,page:page,perPage:perPage,defaultIds:defaultIds,customOptions:customOptions}=props,{filters:filters={},field:fieldObj,clientCriteria:clientCriteria={},lookupModule:lookupModule,resourceLookupModuleName:resourceLookupModuleName,lookupModuleName:lookupModuleName,skipDeserialize:skipDeserialize,operatorLookupModule:operatorLookupModule,additionalParams:additionalParams={}}=field||{},{name:name}=lookupModule||{},{name:operatorLookupModuleName}=operatorLookupModule||{},moduleName=resourceLookupModuleName||lookupModuleName||name;isEmpty$8(operatorLookupModuleName)||(moduleName=operatorLookupModuleName);let{filters:lookupModuleFilters}=lookupModule||{};isEmpty$8(lookupModuleFilters)||(filters={...filters,...lookupModuleFilters}),isEmpty$8(siteId)||(filters={...filters,siteId:{operatorId:36,value:[`${siteId}`]}}),"quote"===dlv_umd(fieldObj,"module.name")&&"workorder"===moduleName&&(filters={...filters,isQuotationNeeded:{operatorId:15,value:[String(!0)]}});let defaultIdsStr=isEmpty$8(defaultIds)?"":defaultIds.toString(),payload={moduleName:moduleName,searchText:searchText,page:page,perPage:perPage,filters:isEmpty$8(filters)?null:JSON.stringify(filters),clientCriteria:isEmpty$8(clientCriteria)?null:JSON.stringify(clientCriteria),defaultIds:defaultIdsStr||null,additionalParams:additionalParams},{error:error,options:options=[],meta:meta}=await fetchFieldOptions$2(payload)||{};if(error)return{error:error};if(isEmpty$8(customOptions)||(options=[...options,...customOptions]),skipDeserialize){let optionsObj=constructOptionsToMap$2(options||[]);return{options:optionsObj,meta:meta}}return{options:options,meta:meta}},fetchFieldOptions$2=async payload=>{let{moduleName:moduleName,searchText:searchText,page:page,perPage:perPage,filters:filters,clientCriteria:clientCriteria,defaultIds:defaultIds,additionalParams:additionalParams}=payload,url=`/v3/picklist/${moduleName}`,params={page:page,perPage:perPage,clientCriteria:clientCriteria,filters:filters,search:searchText,default:defaultIds,viewName:"hidden-all",...additionalParams},{error:error,data:data,meta:meta={}}=await api/* API */.bl.get(url,params)||{};if(error)return{error:error};{let{pickList:options}=data||{};return{options:options||[],meta:meta}}};var LookupIcon$2={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{width:"512",height:"512",viewBox:"0 0 512 512",xmlns:"http://www.w3.org/2000/svg"}},[_c("path",{attrs:{d:"M215.466 481.432c0 10.704-8.71 15.247-19.492 15.247h-85.892C52.151 496.679 32 481.432 32 419.15V78.028C32 17.754 47.553.5 110.082.5h239.999c62.999 0 78.082 14.659 78.082 77.528v185.098c0 10.705-4.305 20.37-15.083 20.37-10.782 0-14.915-9.665-14.915-20.37V78.028c0-38.847-5.615-47.576-48.084-47.576H110.082c-39.68 0-47.917 13.097-47.917 47.576V419.15c0 40.768 6.732 47.518 47.917 47.518h85.892c10.782 0 19.492 4.058 19.492 14.763z"}}),_c("path",{attrs:{d:"M330.56 116.792H129.497c-10.782 0-19.52 6.637-19.52 14.827 0 8.19 8.738 14.828 19.52 14.828H330.56c10.78 0 19.522-6.638 19.522-14.828s-8.743-14.827-19.522-14.827zm19.522 92.355c0-8.19-8.744-14.827-19.523-14.827H129.498c-10.782 0-19.52 6.637-19.52 14.827 0 8.19 8.738 14.827 19.52 14.827H330.56c10.78 0 19.522-6.637 19.522-14.827zm-220.584 62.7c-10.783 0-19.522 6.639-19.522 14.828 0 8.19 8.739 14.827 19.52 14.827h102.592c10.782 0 19.52-6.637 19.52-14.827 0-8.19-8.74-14.827-19.52-14.827H129.497zm215.809 21.927c31.684 0 62.96 12.212 92.762 35.826a230.97 230.97 0 0111.047 9.343c13.134 11.819 22.4 22.164 33.691 36.212l.773.963c.603.753 1.29 1.656 2.058 2.693l.897 1.222.937 1.295 1.133 1.59c8.391 11.835 8.391 27.68.026 39.48l-1.116 1.57a159.25 159.25 0 01-3.376 4.56l-.558.709-1.538 1.914c-10.94 13.558-20.096 23.715-32.938 35.267a231.043 231.043 0 01-11.036 9.333c-29.8 23.615-61.078 35.827-92.762 35.827-31.683 0-62.96-12.211-92.761-35.826a230.993 230.993 0 01-11.047-9.343c-12.837-11.55-21.989-21.705-32.928-35.264l-1.54-1.914-.466-.592a121.78 121.78 0 01-2.179-2.9l-.745-1.024c-.288-.398-.569-.789-.841-1.17l-.792-1.113a34.168 34.168 0 01-.003-39.513l.802-1.126.412-.575.859-1.187.899-1.225a91.05 91.05 0 012.059-2.693l.792-.988c14.496-18.03 27.043-31.52 44.717-45.524 29.801-23.615 61.079-35.827 92.762-35.827zm0 29.8c-24.536 0-49.45 9.727-74.255 29.383-15.22 12.06-26.349 23.94-39.232 39.888l-1.671 2.08-.324.417c-.743.966-1.739 2.33-2.78 3.786l-.725 1.02a4.37 4.37 0 00.002 5.056l1.089 1.526a138.74 138.74 0 002.414 3.276l.473.605 1.479 1.84c10.016 12.41 18.255 21.549 29.654 31.806a201.246 201.246 0 009.621 8.139c24.806 19.655 49.72 29.383 74.255 29.383 24.536 0 49.45-9.728 74.255-29.384a201.302 201.302 0 009.613-8.13c11.675-10.504 20.036-19.834 30.372-32.69l.911-1.14.34-.438c.664-.867 1.54-2.06 2.385-3.236l1.112-1.562a4.368 4.368 0 00-.01-5.06l-.931-1.309c-1.171-1.633-2.325-3.2-3.036-4.087l-.744-.927-1.54-1.908c-9.667-11.92-17.758-20.832-28.85-30.813a201.224 201.224 0 00-9.622-8.138c-24.806-19.656-49.719-29.383-74.255-29.383z"}}),_c("path",{attrs:{d:"M345.6 365.85c-16.497 0-29.867 13.276-29.867 29.655 0 16.378 13.37 29.654 29.867 29.654s29.867-13.276 29.867-29.654c0-16.379-13.37-29.654-29.867-29.654z"}})])}},AddPinkIcon$2={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{width:"14",height:"14",viewBox:"0 0 14 14",xmlns:"http://www.w3.org/2000/svg"}},[_c("path",{attrs:{d:"M7.6 6.4h4.9a.6.6 0 110 1.2H7.6v4.9a.6.6 0 11-1.2 0V7.6H1.5a.6.6 0 110-1.2h4.9V1.5a.6.6 0 111.2 0v4.9z",fill:"#EF508F","fill-rule":"evenodd"}})])}},script$o={name:"Lookup",components:{Select:element_ui_common.Select,Option:element_ui_common.Option,Tooltip:element_ui_common.Tooltip,LookupIcon:LookupIcon$2,AddPinkIcon:AddPinkIcon$2},props:{customOptions:{type:Array,default:()=>[]},value:void 0,field:{type:Object,default:null},disabled:{type:Boolean},siteId:{type:Number,default:null},categoryId:{type:Number,default:null},hideLookupIcon:{type:Boolean,default:!1},popperAppendToBody:{required:!1,type:Boolean,default:!1},fetchOptionsOnLoad:{type:Boolean,default:!0},fetchOptionsMethod:{type:Function,default:null},preHookFilterConstruction:{type:Function,default:field=>field.filters},hideDropDown:{type:Boolean,default:!1},skipLoading:{type:Boolean,default:!1},isClearable:{type:Boolean,default:!0},userfilmoduleEnum:{type:String,default:""}},data(){return{localSearch:!1,isLoadedOnce:!1,currentModelValue:!1,showQuickCreateData:!1,isEmpty:isEmpty$8}},computed:{modelObj:{get(){return this.value},set(val){this.currentModelValue=val,this.$emit("input",val)}},moduleDisplayName(){let{field:field}=this,{lookupModule:lookupModule}=field.field||{},{displayName:displayName}=lookupModule||{};return displayName},isFieldLoading(){let{field:field,defaultIds:defaultIds,skipLoading:skipLoading,isLoadedOnce:isLoadedOnce}=this;return!skipLoading&&!isLoadedOnce&&!isEmpty$8(defaultIds)&&field.isDataLoading},isPickListTypeModule(){let{field:field}=this,{field:fieldObj}=field,{lookupModule:lookupModule}=fieldObj||field,{type:type}=lookupModule||{};// type 1 is for base entity modules
return!!type&&1!==type},isRemote(){let{localSearch:localSearch}=this;return!localSearch},canHideLookupIcon(){let{hideLookupIcon:hideLookupIcon,isPickListTypeModule:isPickListTypeModule,hideDropDown:hideDropDown,field:field,userfilmoduleEnum:userfilmoduleEnum}=this,{config:config}=field||{},canHide=!1;if(!isEmpty$8(config)){let canShowLookupWizard=dlv_umd(config,"canShowLookupWizard",null);isNull$2(canShowLookupWizard)||(canHide=!canShowLookupWizard)}return!hideDropDown&&("PICK_LIST"===userfilmoduleEnum||(canHide||hideLookupIcon||isPickListTypeModule))},canShowQuickCreateIcon(){let{disabled:disabled,field:field}=this,{config:config}=field||{},canShow=!1;return isEmpty$8(config)||(canShow=dlv_umd(config,"canShowQuickCreate")),disabled&&(canShow=!1),canShow},isSiteEnabled(){let siteId=Number(this.$cookie.get("fc.currentSite")),currentSiteId=siteId>0?siteId:-1;return!isEmpty$8(currentSiteId)},isMultiple(){let{field:field}=this;return!!field.multiple},resourceModuleName(){let{field:field}=this,{config:config,lookupModuleName:lookupModuleName}=field,{isFiltersEnabled:isFiltersEnabled,filterValue:filterValue}=config||{};if(isFiltersEnabled&&Constants$2.LOOKUP_FILTER_ENABLED_FIELDS.includes(lookupModuleName)){let moduleName=Constants$2.LOOKUP_FILTERS_MAP[filterValue];return moduleName}return null},isResourceField(){let{field:field}=this,{name:name}=field,isResourceField=this.isChooserTypeField(field)||"resource"===name;return isResourceField},
// To prefill the existing values, we have to send default ids in picklist api
defaultIds(){let{modelObj:modelObj}=this,isPlaceHoldersEnabled=Constants$2.FIELD_PLACEHOLDERS.includes(modelObj)||!1,defaultIds=[];return isEmpty$8(modelObj)||isPlaceHoldersEnabled||(defaultIds=isArray$2(modelObj)?[...modelObj]:[modelObj]),defaultIds=(defaultIds||[]).filter((id=>!`${id}`.includes("${"))),defaultIds},operatorLookupModule(){let{field:field}=this,{operatorLookupModule:operatorLookupModule}=field||{};return operatorLookupModule||{}},skipSiteFilter(){let{field:field}=this,{config:config}=field||{},{skipSiteFilter:skipSiteFilter=!1}=config||{};return skipSiteFilter},canShowSystemClear(){let{canHideLookupIcon:canHideLookupIcon,isClearable:isClearable,modelObj:modelObj}=this;return!canHideLookupIcon&&(isClearable&&!isEmpty$8(modelObj))}},watch:{value(newVal){let{currentModelValue:currentModelValue,isRemote:isRemote}=this;lodash_isEqual(newVal,currentModelValue)||(isRemote&&this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options)})),this.$set(this,"modelObj",newVal))},siteId:{handler(newVal,oldVal){let{isSiteEnabled:isSiteEnabled,skipSiteFilter:skipSiteFilter}=this;skipSiteFilter||isSiteEnabled||newVal===oldVal||this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options)}))}},operatorLookupModule:{handler(newVal,oldVal){lodash_isEqual(newVal,oldVal)||this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options)}))}},"field.clientCriteria":{handler(newVal,oldVal){lodash_isEqual(newVal,oldVal)||this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options)}))}},categoryId:{handler(newVal,oldVal){lodash_isEqual(newVal,oldVal)||this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options)}))}},"field.options":{handler(value){let{modelObj:modelObj}=this;if(!isEmpty$8(value))if(isEmpty$8(modelObj))
// eslint-disable-next-line vue/no-mutating-props
this.field.selectedItems=[];else if(isArray$2(modelObj)){let selectedItems=value.filter((option=>modelObj.includes(option.value)));// eslint-disable-next-line vue/no-mutating-props
this.field.selectedItems=selectedItems}else{let selectedItem=value.find((option=>option.value===modelObj));// eslint-disable-next-line vue/no-mutating-props
this.field.selectedItems=[selectedItem]}},immediate:!0}},async created(){let{fetchOptionsOnLoad:fetchOptionsOnLoad,field:field,modelObj:modelObj}=this;// Have to skip fetching options initially, when module is 'resource' and filters is not enabled
if(this.currentModelValue=modelObj,fetchOptionsOnLoad){let options=await this.getOptions({initialFetch:!0})||[];this.$set(this.field,"options",options),this.$set(this,"isLoadedOnce",!0)}this.remoteMethod=debounce((async searchText=>{let{isDataLoading:isDataLoading}=field;if(!isDataLoading){let options=await this.getOptions({searchText:searchText});this.$set(this.field,"options",options)}}),1e3)},methods:{isChooserTypeField(field){let{displayTypeEnum:displayTypeEnum}=field;// temp have to use a global constant
return["WOASSETSPACECHOOSER","SPACECHOOSER"].includes(displayTypeEnum)},focus(){isEmpty$8(this.$refs["selectBox"])||this.$refs["selectBox"].focus()},async getOptions(params){let{searchText:searchText,initialFetch:initialFetch}=params,{fetchOptionsMethod:fetchOptionsMethod,field:field,siteId:siteId,categoryId:categoryId,isRemote:isRemote,defaultIds:defaultIds,resourceModuleName:resourceModuleName,isResourceField:isResourceField,skipSiteFilter:skipSiteFilter,customOptions:customOptions}=this,options=[];isEmpty$8(resourceModuleName)||(field.resourceLookupModuleName=resourceModuleName),field.filters=this.preHookFilterConstruction(field),isEmpty$8(categoryId)||(field.filters={...field.filters,category:{operator:"is",value:[`${categoryId}`]}});let props={field:field,searchText:searchText};
/*
        Have to return empty options if field is of resourcetype, if filters havent be enabled
        and if no values selected already
      */
if(skipSiteFilter||(props={...props,siteId:siteId}),isResourceField&&isEmpty$8(resourceModuleName)&&isEmpty$8(defaultIds))return[{label:"",value:""}];if(initialFetch&&isRemote&&(props={...props,page:1,perPage:50,defaultIds:defaultIds},isEmpty$8(resourceModuleName)&&isResourceField&&(
// Have to fetch only selected values, which is same as the number of defaultids
props={...props,perPage:defaultIds.length})),isEmpty$8(customOptions)||(props={...props,customOptions:customOptions}),this.$set(field,"isDataLoading",!0),isEmpty$8(fetchOptionsMethod)){let{options:optionsArr=[],error:error,meta:meta}=await getFieldOptions$2(props);if(error){let{message:message}=error||{};this.$message.error(message||"Error Occured")}if(meta&&isEmpty$8(searchText)){let{localSearch:localSearch=!1}=meta;this.$set(this,"localSearch",localSearch)}options=optionsArr}else{let{options:optionsArr=[],error:error}=await this.fetchOptionsMethod(props);if(error){let{message:message}=error||{};this.$message.error(message||"Error Occured")}options=optionsArr}return this.$set(field,"isDataLoading",!1),options},clearData(){this.$emit("input",""),this.recordSelected("")},recordSelected(value){let{field:field,field:{options:options=[]},isMultiple:isMultiple}=this,selectedValues=null;isMultiple?(selectedValues=options.filter((e=>(value||[]).includes(e.value))),field.selectedItems=selectedValues):(selectedValues=options.find((e=>e.value==value))||{},field.selectedItems=[],isEmpty$8(selectedValues)||(field.selectedItems=[selectedValues])),this.$emit("recordSelected",selectedValues,field)},openLookupFieldWizard(field){let{disabled:disabled}=this;disabled||this.$emit("showLookupWizard",field,!0)},openQuickCreate(){let{disabled:disabled}=this;disabled||(this.showQuickCreateData=!0)},setAddedRecord(props){let{record:record}=props,{id:id}=record||{},name=record.displayName||record.name||record.subject,{field:field}=this;field.selectedItems=[{value:id,label:name}],this.$emit("setLookupFieldValue",{field:{...field}})}}};
/* script */
const __vue_script__$o=script$o;
/* template */var __vue_render__$l=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _vm.isFieldLoading?_c("div",{staticClass:"field-loading loading-shimmer"}):_c("div",{staticClass:"f-ui-forms f-ui-lookup-container"},[_c("Select",{ref:"selectBox",class:["f-ui-forms f-ui-select w-full",!_vm.canHideLookupIcon||_vm.canShowQuickCreateIcon?"field-icons-visible":"select-icon-visible",_vm.isMultiple&&"f-ui-select-tag",_vm.hideDropDown&&!_vm.disabled&&"skip-disable"],attrs:{"collapse-tags":"",remote:_vm.isRemote,filterable:"",clearable:_vm.canHideLookupIcon,multiple:_vm.isMultiple,popperAppendToBody:_vm.popperAppendToBody,"remote-method":function(searchText){return _vm.remoteMethod(searchText)},loading:_vm.field.isDataLoading,"loading-text":"Searching",disabled:_vm.disabled||_vm.hideDropDown,placeholder:_vm.field.placeHolderText||"Select","popper-class":"f-ui-select-popper"},on:{change:_vm.recordSelected},model:{value:_vm.modelObj,callback:function($$v){_vm.modelObj=$$v},expression:"modelObj"}},[_c("div",{staticClass:"float-right h-full flex flex-nowrap cursor-pointer",class:!_vm.disabled&&"pointer",attrs:{slot:"prefix"},slot:"prefix"},[_vm.canShowSystemClear?_c("div",{staticClass:"prefix-icon-container flookup-remove-icon",on:{click:_vm.clearData}},[_c("i",{staticClass:"el-icon-circle-close pointer fc-lookup-icon f13"})]):_vm._e(),_vm._v(" "),_vm.canHideLookupIcon?_vm._e():_c("div",{staticClass:"prefix-icon-container flex flex-nowrap",on:{click:function($event){return $event.stopPropagation(),_vm.openLookupFieldWizard(_vm.field)}}},[_c("div",{staticClass:"lookup-icon f-ui-icon-hover"},[_c("LookupIcon",{staticClass:"w-4 h-4"})],1)]),_vm._v(" "),_vm.canShowQuickCreateIcon?_c("div",{staticClass:"prefix-icon-container flex flex-nowrap",on:{click:function($event){return $event.stopPropagation(),function(){return _vm.openQuickCreate()}.apply(null,arguments)}}},[_c("Tooltip",{attrs:{effect:"dark",content:"Add\n          "+_vm.moduleDisplayName,placement:"top"}},[_c("AddPinkIcon",{staticClass:"icon"})],1)],1):_vm._e()]),_vm._v(" "),_vm._l(_vm.field.options,(function(option,index){return _c("Option",{key:option.value+" "+index,staticClass:"f-ui-select-item width100",attrs:{label:option.label,value:option.value}},[_vm.isEmpty(option.secondaryLabel)?_vm._e():_c("span",{staticClass:"fL"},[_vm._v(_vm._s(option.label))]),_vm._v(" "),_vm.isEmpty(option.secondaryLabel)?_vm._e():_c("span",{staticClass:"select-float-right-text13"},[_vm._v(_vm._s(option.secondaryLabel))])])}))],2),_vm._v(" "),_vm.showQuickCreateData?_c("div",[_vm._v("Testing")]):_vm._e()],1)},__vue_staticRenderFns__$l=[];
/* style */
const __vue_inject_styles__$o=function(inject){inject&&(inject("data-v-15f5e51a_0",{source:".field-loading[data-v-15f5e51a]{height:40px;display:flex;flex:1;border-radius:3px}",map:void 0,media:void 0}),inject("data-v-15f5e51a_1",{source:".search-input-comp .field-icons-visible .el-input__inner{padding-left:15px!important}.f-ui-lookup-container{position:relative}.f-ui-lookup-container .el-icon-arrow-up:before{visibility:hidden}.f-ui-lookup-container .select-icon-visible .el-icon-arrow-up:before{visibility:visible}.f-ui-lookup-container .field-icons-visible .el-input .el-input__prefix{right:5px;left:88%;z-index:10}.f-ui-lookup-container .skip-disable .el-input__inner:disabled{cursor:auto!important;background-color:#fff;color:#324056}.f-ui-lookup-container .lookup-icon{display:flex;position:relative;padding:5px}.f-ui-lookup-container:hover .flookup-remove-icon{display:flex}.f-ui-lookup-container .flookup-remove-icon{display:none}.f-ui-lookup-container .prefix-icon-container{height:100%;align-items:center;justify-content:center;margin:1px 3px}",map:void 0,media:void 0}))},__vue_scope_id__$o="data-v-15f5e51a",__vue_module_identifier__$o=void 0,__vue_is_functional_template__$o=!1,__vue_component__$n=normalizeComponent$7({render:__vue_render__$l,staticRenderFns:__vue_staticRenderFns__$l},__vue_inject_styles__$o,__vue_script__$o,__vue_scope_id__$o,__vue_is_functional_template__$o,__vue_module_identifier__$o,!1,createInjector$4,void 0,void 0);
/* scoped */
var script$n={components:{Select:element_ui_common.Select,Option:element_ui_common.Option},props:["value","options","filterable","multiple","labelName","valueName","disabled","placeholder","allowCreate"],mounted(){this.getProps()},data(){return{props:{},inputValue:""}},watch:{value:{handler(newVal,oldVal){newVal!==oldVal&&(this.inputValue=newVal)},immediate:!0}},computed:{optionsLabelString(){let{labelName:labelName}=this||{};return labelName||"label"},optionsValueString(){let{valueName:valueName}=this||{};return valueName||"value"}},methods:{getProps(){let props=this.$vnode.elm.attributes;Object.keys(props).forEach((key=>{this.$set(this.props,props[key].name,props[key].nodeValue)}))},selectValueChange(value){this.$emit("input",value),this.$emit("change",value)},onClear(){this.$emit("clear")}}};
/* script */const __vue_script__$n=script$n;
/* template */var __vue_render__$k=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"f-ui-forms"},[_c("Select",_vm._b({staticClass:"f-ui-select w-full f-ui-select-tag",attrs:{placeholder:_vm.placeholder||"Select","collapse-tags":"",filterable:_vm.filterable,multiple:_vm.multiple,disabled:_vm.disabled,"allow-create":_vm.allowCreate,"popper-class":"f-ui-select-popper"},on:{change:_vm.selectValueChange,clear:_vm.onClear},model:{value:_vm.inputValue,callback:function($$v){_vm.inputValue=$$v},expression:"inputValue"}},"Select",_vm.props,!1),_vm._l(_vm.options,(function(item){return _c("Option",{key:item[_vm.optionsValueString],staticClass:"f-ui-select-item width100",attrs:{label:item[_vm.optionsLabelString],value:item[_vm.optionsValueString]}})})),1)],1)},__vue_staticRenderFns__$k=[];
/* style */
const __vue_inject_styles__$n=void 0,__vue_scope_id__$n=void 0,__vue_module_identifier__$n=void 0,__vue_is_functional_template__$n=!1,__vue_component__$m=normalizeComponent$7({render:__vue_render__$k,staticRenderFns:__vue_staticRenderFns__$k},__vue_inject_styles__$n,__vue_script__$n,__vue_scope_id__$n,__vue_is_functional_template__$n,__vue_module_identifier__$n,!1,void 0,void 0,void 0);
/* scoped */function _extends$7(){return _extends$7=Object.assign||function(a){for(var b,c=1;c<arguments.length;c++)for(var d in b=arguments[c],b)Object.prototype.hasOwnProperty.call(b,d)&&(a[d]=b[d]);return a},_extends$7.apply(this,arguments)}var normalMerge$2=["attrs","props","domProps"],toArrayMerge$2=["class","style","directives"],functionalMerge$2=["on","nativeOn"],mergeJsxProps$2=function(a){return a.reduce((function(c,a){for(var b in a)if(c[b])if(-1!==normalMerge$2.indexOf(b))c[b]=_extends$7({},c[b],a[b]);else if(-1!==toArrayMerge$2.indexOf(b)){var d=c[b]instanceof Array?c[b]:[c[b]],e=a[b]instanceof Array?a[b]:[a[b]];c[b]=d.concat(e)}else if(-1!==functionalMerge$2.indexOf(b))for(var f in a[b])if(c[b][f]){var g=c[b][f]instanceof Array?c[b][f]:[c[b][f]],h=a[b][f]instanceof Array?a[b][f]:[a[b][f]];c[b][f]=g.concat(h)}else c[b][f]=a[b][f];else if("hook"==b)for(var i in a[b])c[b][i]=c[b][i]?mergeFn$2(c[b][i],a[b][i]):a[b][i];else c[b]=a[b];else c[b]=a[b];return c}),{})},mergeFn$2=function(a,b){return function(){a&&a.apply(this,arguments),b&&b.apply(this,arguments)}},helper$2=mergeJsxProps$2;const isEmpty$7=value=>void 0===value||null===value||-1===Number(value)||"object"===typeof value&&!(value instanceof Blob)&&0===Object.keys(value).length||"string"===typeof value&&0===value.trim().length,isObject$3=obj=>null!==obj&&"object"===typeof obj&&!1===Array.isArray(obj);vue_runtime_esm["default"].component(element_ui_common.Checkbox.name,element_ui_common.Checkbox);const formatDate$2=(date,excludeTime,onlyTime)=>{let dateformat="DD-MMM-YYYY",timeformat="HH:mm";// let orgformatArray = orgformat.match(/DD-MMM-YYYY (HH:mm)/)
return onlyTime?moment_timezone(date).format(timeformat):excludeTime?moment_timezone(date).format(dateformat):moment_timezone(date).format(dateformat+" "+timeformat)},getFormattedDuration$2=(value,format="milliseconds",skipDurationCreation=!1)=>{if(!value)return"00:00 Hrs";let duration;duration=skipDurationCreation?value:moment_timezone.duration(parseInt(value,10),format);let days=parseInt(duration.asDays(),10),hours=duration.hours(),minutes=duration.minutes(),seconds=duration.seconds();return days>0?1===days?hours?`${days} Day ${hours} Hrs`:`${days} Day`:hours?`${days} Days ${hours} Hrs`:`${days} Days`:hours>0?minutes?`${hours} Hrs ${minutes} Mins`:`${hours} Hrs`:minutes>0?seconds?`${minutes} Mins ${seconds} Secs`:`${minutes} Mins`:`${seconds} Secs`},DATA_TYPE_VALUE_HASH$2={LOOKUP(field,data){let{name:fieldName}=field,{primaryValue:primaryValue,name:name,displayName:displayName,subject:subject}=data[fieldName]||{},value=displayName||name||subject;return isEmpty$7(primaryValue)?value:primaryValue},FILE(field,data){let filename=data[`${field.name}FileName`];return filename},DATE(field,data){let{name:name}=field||{},value=data[name];return value&&-1!==value?formatDate$2(value,!0):""},DATE_TIME(field,data){let{name:name}=field||{},value=data[name];return value&&-1!==value?formatDate$2(value):""},ENUM(field,data){let{name:name}=field||{},value=data[name],fieldObj=field.field;return value=value?fieldObj.enumMap[data[fieldObj.name]]:value,value},SYSTEM_ENUM(field,data){let{name:name}=field||{},value=data[name],fieldObj=field.field;return value=value?fieldObj.enumMap[data[fieldObj.name]]:value,value},MULTI_ENUM(field,data){let{name:name,enumMap:enumMap}=field.field||{},values=data[name]||[],valueStr=values.reduce(((accStr,value)=>{let str=enumMap[value]||"";return isEmpty$7(accStr)?`${str}`:`${accStr}, ${str}`}),"");return isEmpty$7(valueStr)?"---":valueStr},BOOLEAN(field,data){let{name:name}=field||{},value=data[name]?field.trueVal||"Yes":field.falseVal||"No";return value},MULTI_LOOKUP(field,data){let{name:name}=field,value=data[name]||[],lookupRecordNames=(value||[]).map((currRecord=>currRecord.displayName||currRecord.name||currRecord.subject));return lookupRecordNames.length>2?`${lookupRecordNames.slice(0,2).join(", ")} +${Math.abs(lookupRecordNames.length-2)}`:isEmpty$7(lookupRecordNames)?"---":`${lookupRecordNames.join(", ")}`},OTHERS(field,data){let{name:name}=field||{};if(!isObject$3(data[name]))return data[name];{let{name:name}=data[name]||{};if(!isEmpty$7(name))return name;data[name]}}},DISPLAY_TYPE_HASH$2={DURATION(field,record){const h=this.$createElement;let{name:name}=field,value=record[name]||[];return h("div",[isEmpty$7(value)||"---"===value?"---":getFormattedDuration$2(value,isEmpty$7(field.unit)?"s":field.unit)])},URL_FIELD(field,record){const h=this.$createElement;let{name:name}=field||{};if(isEmpty$7(record[name]))return"---";{let{name:displayName,href:href,target:target}=record[name]||{},value=isEmpty$7(displayName)?href:displayName;return h(element_ui_common.Tooltip,{attrs:{effect:"dark",content:value,placement:"bottom-start"}},[h("a",{attrs:{rel:"nofollow",referrerpolicy:"no-referrer",href:href,target:target},class:"url-field-display truncate-text"},[h("span",{class:"textoverflow-ellipsis"},[value])])])}},OTHERS(field,record){const h=this.$createElement;return h("div",{class:"truncate-text"},[this.getColumnDisplayValue(field,record)])}};var script$m={props:["viewDetail","records","moduleName","redirectToOverview","columnConfig","slotList","hideListSelect","customButtonList","canShowCustomButton","refreshList","metaInfo"],computed:{viewColumns(){let columns=[],{viewDetail:viewDetail}=this,{fields:viewDetailFields=[]}=viewDetail;isEmpty$7(viewDetail)||isEmpty$7(viewDetailFields)||(columns=viewDetailFields.map((viewField=>{let{field:field,fieldName:fieldName}=viewField||{};field=field||{};let name=field.name||fieldName,fieldId=field.fieldId,defaultColumnName=viewDetail.defaultModuleFields&&viewDetail.defaultModuleFields[viewField.name]?viewDetail.defaultModuleFields[viewField.name].columnDisplayName:null,displayName=viewField.columnDisplayName||defaultColumnName||field.displayName;return viewField={...viewField,name:name,fieldId:fieldId,displayName:displayName},viewField})));let{columnConfig:columnConfig}=this,{fixedSelectableColumns:fixedSelectableColumns}=columnConfig||{};return isEmpty$7(columns)?[]:columns.filter((column=>!(fixedSelectableColumns||[]).includes(column.name)))},customFieldValueSlots(){let{slotList:slotList}=this;return isEmpty$7(slotList)?[]:slotList.filter((slotObj=>!slotObj.isActionColumn))},actionColumnSlots(){let{slotList:slotList}=this;return isEmpty$7(slotList)?[]:slotList.filter((slotObj=>slotObj.isActionColumn))},hardCodedSlots(){let{slotList:slotList}=this;return isEmpty$7(slotList)?[]:slotList.filter((slotObj=>slotObj.isHardcodedColumn))}},methods:{
// field type checks
isDecimalField(field){let{dataTypeEnum:dataTypeEnum}=field.field||{};return field.field&&"DECIMAL"===dataTypeEnum},isFixedColumn(name){let{columnConfig:{fixedColumns:fixedColumns}={}}=this;return(fixedColumns||[]).includes(name)},
// column display related methods
getColumnHeaderLabel(column){let{displayName:displayName,field:field}=column;if(!isEmpty$7(field)&&!isEmpty$7(field.unit)){let{unit:unit}=field;return`${displayName} (${unit})`}return displayName},getColumnDisplayValue(field,record){let value,{parentField:parentField}=field,fieldObj=field.field||field,{dataTypeEnum:dataTypeEnum}=fieldObj||{};// first level lookup value, related handling
if(!isEmpty$7(parentField)){let{name:lookupModuleName}=parentField||{};isEmpty$7(lookupModuleName)||isEmpty$7(record[lookupModuleName])||(record=record[lookupModuleName])}return isEmpty$7(DATA_TYPE_VALUE_HASH$2[dataTypeEnum])?value=DATA_TYPE_VALUE_HASH$2["OTHERS"](field,record,this):(dataTypeEnum=dataTypeEnum||dataTypeEnum._name,value=DATA_TYPE_VALUE_HASH$2[dataTypeEnum](field,record,this)),isEmpty$7(value)?"---":value},getColumnDisplayComponent(field,record){let fieldObj=field.field||field,{displayType:displayType}=fieldObj||{},{criteriaCheckForSlot:criteriaCheckForSlot}=this||{},{canRenderSlot:canRenderSlot,slotName:slotName}=criteriaCheckForSlot(field);return canRenderSlot&&!isEmpty$7(this.$scopedSlots[slotName])?this.$scopedSlots[slotName]({record:record}):isEmpty$7(this[displayType])?this["OTHERS"](field,record,this.getColumnDisplayValue):this[displayType](field,record,this.getColumnDisplayValue)},criteriaCheckForSlot(field){let{customFieldValueSlots:customFieldValueSlots}=this,canRenderSlot=!0,slotName="",fieldObj=field.field||field;if(!isEmpty$7(customFieldValueSlots))for(let currSlot of customFieldValueSlots){let{criteria:criteria}=currSlot||{};if(!isEmpty$7(criteria)){let slotCriteria=JSON.parse(criteria);if(isObject$3(slotCriteria)&&Object.keys(slotCriteria).forEach((fieldName=>{canRenderSlot=fieldObj[fieldName]===slotCriteria[fieldName]})),canRenderSlot){slotName=criteria;break}}}return{canRenderSlot:canRenderSlot,slotName:slotName}},
// redirects and event emiters
selectionChange(selected){this.$emit("selection-change",selected)},toggleVisibility(id,val){let{$el:$el}=this.$refs[`custom-btn-${id}`]||{},{classList:classList}=$el||{};val?classList.remove("visibility-hide-actions"):classList.add("visibility-hide-actions")},toggleRowSelection(item,val){let{moduleName:moduleName}=this||{},ref=this.$refs[`${moduleName}-list`];ref.toggleRowSelection(item,val)},clearSelection(){let{moduleName:moduleName}=this||{},ref=this.$refs[`${moduleName}-list`];ref.clearSelection()},
// display type hash
...DISPLAY_TYPE_HASH$2},render(){const h=arguments[0];return h(element_ui_common.Table,{attrs:{data:this.records,height:"100%",fit:!0,"row-class-name":"no-hover"},ref:`${this.moduleName}-list`,style:"width: 100%;",class:"table-border",on:{"selection-change":this.selectionChange}},[!this.hideListSelect&&h(element_ui_common.TableColumn,{attrs:{fixed:!0,align:"left",type:"selection",width:"60"}}),this.hardCodedSlots.map(((slotObj,index)=>h(element_ui_common.TableColumn,helper$2([{key:`${slotObj.name}-${index}`},{scopedSlots:{default:data=>this.$scopedSlots[slotObj.name]({record:data.row})}},{attrs:{...slotObj.columnAttrs||{}}}])))),this.viewColumns.map(((field,index)=>h(element_ui_common.TableColumn,helper$2([{attrs:{fixed:this.isFixedColumn(field.name),prop:field.name,label:this.getColumnHeaderLabel(field),align:this.isDecimalField(field)?"right":"left","min-width":"230"},key:index},{scopedSlots:{default:data=>this.getColumnDisplayComponent(field,data.row)}},{attrs:{...field.columnAttrs||{}}}])))),this.actionColumnSlots.map(((slotObj,index)=>h(element_ui_common.TableColumn,helper$2([{key:`${slotObj.name}-${index}`},{scopedSlots:{default:data=>this.$scopedSlots[slotObj.name]({record:data.row})}},{attrs:{...slotObj.columnAttrs||{}}}]))))])}};
/* script */const __vue_script__$m=script$m,__vue_inject_styles__$m=function(inject){inject&&inject("data-v-64fad4c9_0",{source:".url-field-display[data-v-64fad4c9]{color:#46a2bf}.url-field-display[data-v-64fad4c9]:hover{text-decoration:underline;text-underline-offset:3px;color:#46a2bf}",map:void 0,media:void 0})},__vue_scope_id__$m="data-v-64fad4c9",__vue_module_identifier__$m=void 0,__vue_is_functional_template__$m=void 0,__vue_component__$l=normalizeComponent$7({},__vue_inject_styles__$m,__vue_script__$m,__vue_scope_id__$m,__vue_is_functional_template__$m,__vue_module_identifier__$m,!1,createInjector$4,void 0,void 0);
/* template */
/* style */
var script$l={props:["currentPage","perPage","total","hideToggle"],data(){return{from:0,to:0,page:1}},mounted(){this.init()},watch:{total(){this.init()},currentPage(val){val!==this.page&&this.init()}},methods:{init(){this.page=this.currentPage||1,this.from=(this.page-1)*this.perPage+1;let to=this.from+this.perPage-1;this.to=this.total>to?to:this.total},next(){this.from=this.to+1,this.to+=this.perPage,this.to>this.total&&(this.to=this.total),this.page++,// Update currentPage value
this.$emit("update:currentPage",this.page)},prev(){this.to=this.from-1,this.from-=this.perPage,this.from<=1?this.from=this.page=1:this.page--,// Update currentPage value
this.$emit("update:currentPage",this.page)}}};
/* script */const __vue_script__$l=script$l;
/* template */var __vue_render__$j=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _vm.total>0?_c("div",{staticClass:"f-ui-widget-pagination"},[_vm.from!==_vm.to?_c("span",[_vm._v(_vm._s(_vm.from)+" -")]):_vm._e(),_vm._v(" "),_c("span",[_vm._v(_vm._s(_vm.to))]),_vm._v(" "),_vm.hideToggle?_vm._e():[_c("span",{staticClass:"pl-1 pr-3"},[_vm._v("of "+_vm._s(_vm.total))]),_vm._v(" "),_c("span",{staticClass:"el-icon-arrow-left arrow-icons cursor-pointer",class:{disable:_vm.from<=1},on:{click:function($event){_vm.from>1&&_vm.prev()}}}),_vm._v(" "),_c("span",{staticClass:"el-icon-arrow-right arrow-icons cursor-pointer",class:{disable:_vm.to===_vm.total},on:{click:function($event){_vm.to!==_vm.total&&_vm.next()}}})]],2):_vm._e()},__vue_staticRenderFns__$j=[];
/* style */
const __vue_inject_styles__$l=function(inject){inject&&inject("data-v-dec3861c_0",{source:".f-ui-widget-pagination{display:flex;align-items:center;font-size:12px;font-weight:500;font-style:normal;letter-spacing:1px;color:#50506c}.f-ui-widget-pagination .arrow-icons{font-size:15px}.f-ui-widget-pagination .disable{opacity:.5;cursor:not-allowed}.f-ui-widget-pagination .el-icon-arrow-left{padding:4px 3px;border-radius:4px;border:1px solid transparent}.f-ui-widget-pagination .el-icon-arrow-left:hover{color:#615e88;background:#f5f6f8;border:1px solid #dae0e8}.f-ui-widget-pagination .el-icon-arrow-right{padding:4px 3px;border-radius:4px;border:1px solid transparent}.f-ui-widget-pagination .el-icon-arrow-right:hover{color:#615e88;background:#f5f6f8;border:1px solid #dae0e8}",map:void 0,media:void 0})},__vue_scope_id__$l=void 0,__vue_module_identifier__$l=void 0,__vue_is_functional_template__$l=!1,__vue_component__$k=normalizeComponent$7({render:__vue_render__$j,staticRenderFns:__vue_staticRenderFns__$j},__vue_inject_styles__$l,__vue_script__$l,__vue_scope_id__$l,__vue_is_functional_template__$l,__vue_module_identifier__$l,!1,createInjector$4,void 0,void 0);
/* scoped */
var script$j={name:"spinner",props:["show","size","colour"],computed:{spinnerSize(){return this.size?this.size+"px":"50px"},strokeColor(){return this.colour?this.colour:"#fd4b92"}}};
/* script */const __vue_script__$j=script$j;
/* template */var __vue_render__$h=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("transition",[_c("svg",{directives:[{name:"show",rawName:"v-show",value:_vm.show,expression:"show"}],staticClass:"spinner",class:{show:_vm.show},attrs:{width:_vm.spinnerSize,height:_vm.spinnerSize,viewBox:"0 0 44 44"}},[_c("circle",{staticClass:"path",style:{stroke:_vm.strokeColor},attrs:{fill:"none","stroke-width":"4","stroke-linecap":"round",cx:"22",cy:"22",r:"20"}})])])},__vue_staticRenderFns__$h=[];
/* style */
const __vue_inject_styles__$j=function(inject){inject&&inject("data-v-3994ea33_0",{source:".spinner[data-v-3994ea33]{transition:opacity .15s ease;animation:rotator-data-v-3994ea33 1.4s linear infinite;animation-play-state:paused}.spinner.show[data-v-3994ea33]{animation-play-state:running}.spinner.v-enter[data-v-3994ea33],.spinner.v-leave-active[data-v-3994ea33]{opacity:0}.spinner.v-enter-active[data-v-3994ea33],.spinner.v-leave[data-v-3994ea33]{opacity:1}.spinner .path[data-v-3994ea33]{stroke-dasharray:126;stroke-dashoffset:0;transform-origin:center;animation:dash-data-v-3994ea33 1.4s ease-in-out infinite}@-moz-keyframes rotator-data-v-3994ea33{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-webkit-keyframes rotator-data-v-3994ea33{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-o-keyframes rotator-data-v-3994ea33{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@keyframes rotator-data-v-3994ea33{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-moz-keyframes dash-data-v-3994ea33{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@-webkit-keyframes dash-data-v-3994ea33{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@-o-keyframes dash-data-v-3994ea33{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@keyframes dash-data-v-3994ea33{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}",map:void 0,media:void 0})},__vue_scope_id__$j="data-v-3994ea33",__vue_module_identifier__$j=void 0,__vue_is_functional_template__$j=!1,__vue_component__$i=normalizeComponent$7({render:__vue_render__$h,staticRenderFns:__vue_staticRenderFns__$h},__vue_inject_styles__$j,__vue_script__$j,__vue_scope_id__$j,__vue_is_functional_template__$j,__vue_module_identifier__$j,!1,createInjector$4,void 0,void 0),NAMESPACE$2="facicons-ui";
/* scoped */let scopeId$2,hostTagName$2,isSvgMode$2=!1,queuePending$2=!1;const win$2="undefined"!==typeof window?window:{},doc$6=win$2.document||{head:{}},plt$2={$flags$:0,$resourcesUrl$:"",jmp:h=>h(),raf:h=>requestAnimationFrame(h),ael:(el,eventName,listener,opts)=>el.addEventListener(eventName,listener,opts),rel:(el,eventName,listener,opts)=>el.removeEventListener(eventName,listener,opts),ce:(eventName,opts)=>new CustomEvent(eventName,opts)},promiseResolve$2=v=>Promise.resolve(v),supportsConstructibleStylesheets$2=(()=>{try{return new CSSStyleSheet,"function"===typeof(new CSSStyleSheet).replace}catch(e){}return!1})(),HYDRATED_CSS$2="{visibility:hidden}.hydrated{visibility:inherit}",createTime$2=(fnName,tagName="")=>()=>{},uniqueTime$2=(key,measureText)=>()=>{},rootAppliedStyles$2=new WeakMap,registerStyle$2=(scopeId,cssText,allowCS)=>{let style=styles$6.get(scopeId);supportsConstructibleStylesheets$2&&allowCS?(style=style||new CSSStyleSheet,style.replace(cssText)):style=cssText,styles$6.set(scopeId,style)},addStyle$6=(styleContainerNode,cmpMeta,mode,hostElm)=>{let scopeId=getScopeId$2(cmpMeta);const style=styles$6.get(scopeId);// if an element is NOT connected then getRootNode() will return the wrong root node
// so the fallback is to always use the document for the root node in those cases
if(styleContainerNode=11
/* DocumentFragment */===styleContainerNode.nodeType?styleContainerNode:doc$6,style)if("string"===typeof style){styleContainerNode=styleContainerNode.head||styleContainerNode;let styleElm,appliedStyles=rootAppliedStyles$2.get(styleContainerNode);appliedStyles||rootAppliedStyles$2.set(styleContainerNode,appliedStyles=new Set),appliedStyles.has(scopeId)||(styleElm=doc$6.createElement("style"),styleElm.innerHTML=style,styleContainerNode.insertBefore(styleElm,styleContainerNode.querySelector("link")),appliedStyles&&appliedStyles.add(scopeId))}else styleContainerNode.adoptedStyleSheets.includes(style)||(styleContainerNode.adoptedStyleSheets=[...styleContainerNode.adoptedStyleSheets,style]);return scopeId},attachStyles$2=hostRef=>{const cmpMeta=hostRef.$cmpMeta$,elm=hostRef.$hostElement$,flags=cmpMeta.$flags$,endAttachStyles=createTime$2("attachStyles",cmpMeta.$tagName$),scopeId=addStyle$6(elm.shadowRoot?elm.shadowRoot:elm.getRootNode(),cmpMeta);10
/* needsScopedEncapsulation */&flags&&(
// only required when we're NOT using native shadow dom (slot)
// or this browser doesn't support native shadow dom
// and this host element was NOT created with SSR
// let's pick out the inner content for slot projection
// create a node to represent where the original
// content was first placed, which is useful later on
// DOM WRITE!!
elm["s-sc"]=scopeId,elm.classList.add(scopeId+"-h")),endAttachStyles()},getScopeId$2=(cmp,mode)=>"sc-"+cmp.$tagName$
/**
 * Default style mode id
 */
/**
 * Reusable empty obj/array
 * Don't add values to these!!
 */,EMPTY_OBJ$2={},isDef$2=v=>null!=v,isComplexType$2=o=>(
// https://jsperf.com/typeof-fn-object/5
o=typeof o,"object"===o||"function"===o),h$2=(nodeName,vnodeData,...children)=>{let child=null,simple=!1,lastSimple=!1;const vNodeChildren=[],walk=c=>{for(let i=0;i<c.length;i++)child=c[i],Array.isArray(child)?walk(child):null!=child&&"boolean"!==typeof child&&((simple="function"!==typeof nodeName&&!isComplexType$2(child))&&(child=String(child)),simple&&lastSimple?
// If the previous child was simple (string), we merge both
vNodeChildren[vNodeChildren.length-1].$text$+=child:
// Append a new vNode, if it's text, we create a text vNode
vNodeChildren.push(simple?newVNode$2(null,child):child),lastSimple=simple)};if(walk(children),vnodeData){const classData=vnodeData.className||vnodeData.class;classData&&(vnodeData.class="object"!==typeof classData?classData:Object.keys(classData).filter((k=>classData[k])).join(" "))}const vnode=newVNode$2(nodeName,null);return vnode.$attrs$=vnodeData,vNodeChildren.length>0&&(vnode.$children$=vNodeChildren),vnode},newVNode$2=(tag,text)=>{const vnode={$flags$:0,$tag$:tag,$text$:text,$elm$:null,$children$:null,$attrs$:null};return vnode},Host$2={},isHost$2=node=>node&&node.$tag$===Host$2
/**
 * Production setAccessor() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */,setAccessor$2=(elm,memberName,oldValue,newValue,isSvg,flags)=>{if(oldValue!==newValue){let isProp=isMemberInElement$2(elm,memberName);if(memberName.toLowerCase(),"class"===memberName){const classList=elm.classList,oldClasses=parseClassList$2(oldValue),newClasses=parseClassList$2(newValue);classList.remove(...oldClasses.filter((c=>c&&!newClasses.includes(c)))),classList.add(...newClasses.filter((c=>c&&!oldClasses.includes(c))))}else{
// Set property if it exists and it's not a SVG
const isComplex=isComplexType$2(newValue);if((isProp||isComplex&&null!==newValue)&&!isSvg)try{if(elm.tagName.includes("-"))elm[memberName]=newValue;else{const n=null==newValue?"":newValue;// Workaround for Safari, moving the <input> caret when re-assigning the same valued
"list"===memberName?isProp=!1:null!=oldValue&&elm[memberName]==n||(elm[memberName]=n)}}catch(e){}null==newValue||!1===newValue?!1===newValue&&""!==elm.getAttribute(memberName)||elm.removeAttribute(memberName):(!isProp||4
/* isHost */&flags||isSvg)&&!isComplex&&(newValue=!0===newValue?"":newValue,elm.setAttribute(memberName,newValue))}}},parseClassListRegex$2=/\s/,parseClassList$2=value=>value?value.split(parseClassListRegex$2):[],updateElement$2=(oldVnode,newVnode,isSvgMode,memberName)=>{
// if the element passed in is a shadow root, which is a document fragment
// then we want to be adding attrs/props to the shadow root's "host" element
// if it's not a shadow root, then we add attrs/props to the same element
const elm=11
/* DocumentFragment */===newVnode.$elm$.nodeType&&newVnode.$elm$.host?newVnode.$elm$.host:newVnode.$elm$,oldVnodeAttrs=oldVnode&&oldVnode.$attrs$||EMPTY_OBJ$2,newVnodeAttrs=newVnode.$attrs$||EMPTY_OBJ$2;
// remove attributes no longer present on the vnode by setting them to undefined
for(memberName in oldVnodeAttrs)memberName in newVnodeAttrs||setAccessor$2(elm,memberName,oldVnodeAttrs[memberName],void 0,isSvgMode,newVnode.$flags$);// add new & update changed attributes
for(memberName in newVnodeAttrs)setAccessor$2(elm,memberName,oldVnodeAttrs[memberName],newVnodeAttrs[memberName],isSvgMode,newVnode.$flags$)},createElm$2=(oldParentVNode,newParentVNode,childIndex,parentElm)=>{
// tslint:disable-next-line: prefer-const
const newVNode=newParentVNode.$children$[childIndex];let elm,childNode,i=0;if(
// create element
elm=newVNode.$elm$=doc$6.createElement(newVNode.$tag$),updateElement$2(null,newVNode,isSvgMode$2),isDef$2(scopeId$2)&&elm["s-si"]!==scopeId$2&&
// if there is a scopeId and this is the initial render
// then let's add the scopeId as a css class
elm.classList.add(elm["s-si"]=scopeId$2),newVNode.$children$)for(i=0;i<newVNode.$children$.length;++i)
// create the node
childNode=createElm$2(oldParentVNode,newVNode,i),// return node could have been null
childNode&&
// append our new node
elm.appendChild(childNode);return elm},addVnodes$2=(parentElm,before,parentVNode,vnodes,startIdx,endIdx)=>{let childNode,containerElm=parentElm;for(containerElm.shadowRoot&&containerElm.tagName===hostTagName$2&&(containerElm=containerElm.shadowRoot);startIdx<=endIdx;++startIdx)vnodes[startIdx]&&(childNode=createElm$2(null,parentVNode,startIdx),childNode&&(vnodes[startIdx].$elm$=childNode,containerElm.insertBefore(childNode,before)))},removeVnodes$2=(vnodes,startIdx,endIdx,vnode,elm)=>{for(;startIdx<=endIdx;++startIdx)(vnode=vnodes[startIdx])&&(elm=vnode.$elm$,// remove the vnode's element from the dom
elm.remove())},updateChildren$2=(parentElm,oldCh,newVNode,newCh)=>{let node,oldStartIdx=0,newStartIdx=0,oldEndIdx=oldCh.length-1,oldStartVnode=oldCh[0],oldEndVnode=oldCh[oldEndIdx],newEndIdx=newCh.length-1,newStartVnode=newCh[0],newEndVnode=newCh[newEndIdx];while(oldStartIdx<=oldEndIdx&&newStartIdx<=newEndIdx)null==oldStartVnode?
// Vnode might have been moved left
oldStartVnode=oldCh[++oldStartIdx]:null==oldEndVnode?oldEndVnode=oldCh[--oldEndIdx]:null==newStartVnode?newStartVnode=newCh[++newStartIdx]:null==newEndVnode?newEndVnode=newCh[--newEndIdx]:isSameVnode$2(oldStartVnode,newStartVnode)?(patch$2(oldStartVnode,newStartVnode),oldStartVnode=oldCh[++oldStartIdx],newStartVnode=newCh[++newStartIdx]):isSameVnode$2(oldEndVnode,newEndVnode)?(patch$2(oldEndVnode,newEndVnode),oldEndVnode=oldCh[--oldEndIdx],newEndVnode=newCh[--newEndIdx]):isSameVnode$2(oldStartVnode,newEndVnode)?(patch$2(oldStartVnode,newEndVnode),parentElm.insertBefore(oldStartVnode.$elm$,oldEndVnode.$elm$.nextSibling),oldStartVnode=oldCh[++oldStartIdx],newEndVnode=newCh[--newEndIdx]):isSameVnode$2(oldEndVnode,newStartVnode)?(patch$2(oldEndVnode,newStartVnode),parentElm.insertBefore(oldEndVnode.$elm$,oldStartVnode.$elm$),oldEndVnode=oldCh[--oldEndIdx],newStartVnode=newCh[++newStartIdx]):(
// new element
node=createElm$2(oldCh&&oldCh[newStartIdx],newVNode,newStartIdx),newStartVnode=newCh[++newStartIdx],node&&oldStartVnode.$elm$.parentNode.insertBefore(node,oldStartVnode.$elm$));oldStartIdx>oldEndIdx?addVnodes$2(parentElm,null==newCh[newEndIdx+1]?null:newCh[newEndIdx+1].$elm$,newVNode,newCh,newStartIdx,newEndIdx):newStartIdx>newEndIdx&&removeVnodes$2(oldCh,oldStartIdx,oldEndIdx)},isSameVnode$2=(vnode1,vnode2)=>vnode1.$tag$===vnode2.$tag$,patch$2=(oldVNode,newVNode)=>{const elm=newVNode.$elm$=oldVNode.$elm$,oldChildren=oldVNode.$children$,newChildren=newVNode.$children$;
// either this is the first render of an element OR it's an update
// AND we already know it's possible it could have changed
// this updates the element's css classes, attrs, props, listeners, etc.
updateElement$2(oldVNode,newVNode,isSvgMode$2),null!==oldChildren&&null!==newChildren?
// looks like there's child vnodes for both the old and new vnodes
updateChildren$2(elm,oldChildren,newVNode,newChildren):null!==newChildren?
// add the new vnode children
addVnodes$2(elm,null,newVNode,newChildren,0,newChildren.length-1):null!==oldChildren&&
// no new child vnodes, but there are old child vnodes to remove
removeVnodes$2(oldChildren,0,oldChildren.length-1)},renderVdom$2=(hostRef,renderFnResults)=>{const hostElm=hostRef.$hostElement$,oldVNode=hostRef.$vnode$||newVNode$2(null,null),rootVnode=isHost$2(renderFnResults)?renderFnResults:h$2(null,null,renderFnResults);hostTagName$2=hostElm.tagName,rootVnode.$tag$=null,rootVnode.$flags$|=4
/* isHost */,hostRef.$vnode$=rootVnode,rootVnode.$elm$=oldVNode.$elm$=hostElm.shadowRoot||hostElm,scopeId$2=hostElm["s-sc"],// synchronous patch
patch$2(oldVNode,rootVnode)},emitEvent$2=(elm,name,opts)=>{const ev=plt$2.ce(name,opts);return elm.dispatchEvent(ev),ev},attachToAncestor$2=(hostRef,ancestorComponent)=>{ancestorComponent&&!hostRef.$onRenderResolve$&&ancestorComponent["s-p"]&&ancestorComponent["s-p"].push(new Promise((r=>hostRef.$onRenderResolve$=r)))},scheduleUpdate$2=(hostRef,isInitialLoad)=>{if(hostRef.$flags$|=16
/* isQueuedForUpdate */,4
/* isWaitingForChildren */&hostRef.$flags$)return void(hostRef.$flags$|=512
/* needsRerender */);attachToAncestor$2(hostRef,hostRef.$ancestorComponent$);// there is no ancestor component or the ancestor component
// has already fired off its lifecycle update then
// fire off the initial update
const dispatch=()=>dispatchHooks$2(hostRef,isInitialLoad);return writeTask$2(dispatch)},dispatchHooks$2=(hostRef,isInitialLoad)=>{const endSchedule=createTime$2("scheduleUpdate",hostRef.$cmpMeta$.$tagName$),instance=hostRef.$lazyInstance$;let promise;return isInitialLoad&&(promise=safeCall$2(instance,"componentWillLoad")),endSchedule(),then$2(promise,(()=>updateComponent$2(hostRef,instance,isInitialLoad)))},updateComponent$2=async(hostRef,instance,isInitialLoad)=>{
// updateComponent
const elm=hostRef.$hostElement$,endUpdate=createTime$2("update",hostRef.$cmpMeta$.$tagName$),rc=elm["s-rc"];isInitialLoad&&
// DOM WRITE!
attachStyles$2(hostRef);const endRender=createTime$2("render",hostRef.$cmpMeta$.$tagName$);callRender$2(hostRef,instance),rc&&(
// ok, so turns out there are some child host elements
// waiting on this parent element to load
// let's fire off all update callbacks waiting
rc.map((cb=>cb())),elm["s-rc"]=void 0),endRender(),endUpdate();{const childrenPromises=elm["s-p"],postUpdate=()=>postUpdateComponent$2(hostRef);0===childrenPromises.length?postUpdate():(Promise.all(childrenPromises).then(postUpdate),hostRef.$flags$|=4
/* isWaitingForChildren */,childrenPromises.length=0)}},callRender$2=(hostRef,instance,elm)=>{try{instance=instance.render(),hostRef.$flags$&=-17
/* isQueuedForUpdate */,hostRef.$flags$|=2
/* hasRendered */,renderVdom$2(hostRef,instance)}catch(e){consoleError$2(e,hostRef.$hostElement$)}return null},postUpdateComponent$2=hostRef=>{const tagName=hostRef.$cmpMeta$.$tagName$,elm=hostRef.$hostElement$,endPostUpdate=createTime$2("postUpdate",tagName),ancestorComponent=hostRef.$ancestorComponent$;64
/* hasLoadedComponent */&hostRef.$flags$?endPostUpdate():(hostRef.$flags$|=64
/* hasLoadedComponent */,
// DOM WRITE!
addHydratedFlag$2(elm),endPostUpdate(),hostRef.$onReadyResolve$(elm),ancestorComponent||appDidLoad$2()),hostRef.$onRenderResolve$&&(hostRef.$onRenderResolve$(),hostRef.$onRenderResolve$=void 0),512
/* needsRerender */&hostRef.$flags$&&nextTick$2((()=>scheduleUpdate$2(hostRef,!1))),hostRef.$flags$&=-517
/* needsRerender */;// load events fire from bottom to top
// the deepest elements load first then bubbles up
}// ( •_•)
// ( •_•)>⌐■-■
// (⌐■_■)
,appDidLoad$2=who=>{addHydratedFlag$2(doc$6.documentElement),nextTick$2((()=>emitEvent$2(win$2,"appload",{detail:{namespace:NAMESPACE$2}})))},safeCall$2=(instance,method,arg)=>{if(instance&&instance[method])try{return instance[method](arg)}catch(e){consoleError$2(e)}},then$2=(promise,thenFn)=>promise&&promise.then?promise.then(thenFn):thenFn(),addHydratedFlag$2=elm=>elm.classList.add("hydrated")
/**
 * Parse a new property value for a given property type.
 *
 * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,
 * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:
 *   1. `any`, the type given to `propValue` in the function signature
 *   2. the type stored from `propType`.
 *
 * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.
 *
 * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to
 * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is
 * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.
 * ```tsx
 * <my-cmp prop-val={0}></my-cmp>
 * ```
 *
 * HTML prop values on the other hand, will always a string
 *
 * @param propValue the new value to coerce to some type
 * @param propType the type of the prop, expressed as a binary number
 * @returns the parsed/coerced value
 */,parsePropertyValue$2=(propValue,propType)=>
// ensure this value is of the correct prop type
null==propValue||isComplexType$2(propValue)?propValue:1
/* String */&propType?String(propValue):propValue,getValue$5=(ref,propName)=>getHostRef$2(ref).$instanceValues$.get(propName),setValue$2=(ref,propName,newVal,cmpMeta)=>{
// check our new property value against our internal value
const hostRef=getHostRef$2(ref),elm=hostRef.$hostElement$,oldVal=hostRef.$instanceValues$.get(propName),flags=hostRef.$flags$,instance=hostRef.$lazyInstance$;newVal=parsePropertyValue$2(newVal,cmpMeta.$members$[propName][0]);// explicitly check for NaN on both sides, as `NaN === NaN` is always false
const areBothNaN=Number.isNaN(oldVal)&&Number.isNaN(newVal),didValueChange=newVal!==oldVal&&!areBothNaN;if((!(8
/* isConstructingInstance */&flags)||void 0===oldVal)&&didValueChange&&(
// gadzooks! the property's value has changed!!
// set our new value!
hostRef.$instanceValues$.set(propName,newVal),instance)){
// get an array of method names of watch functions to call
if(cmpMeta.$watchers$&&128
/* isWatchReady */&flags){const watchMethods=cmpMeta.$watchers$[propName];watchMethods&&
// this instance is watching for when this property changed
watchMethods.map((watchMethodName=>{try{
// fire off each of the watch methods that are watching this property
instance[watchMethodName](newVal,oldVal,propName)}catch(e){consoleError$2(e,elm)}}))}2
/* hasRendered */===(18
/* isQueuedForUpdate */&flags)&&
// looks like this value actually changed, so we've got work to do!
// but only if we've already rendered, otherwise just chill out
// queue that we need to do an update, but don't worry about queuing
// up millions cuz this function ensures it only runs once
scheduleUpdate$2(hostRef,!1)}},proxyComponent$2=(Cstr,cmpMeta,flags)=>{if(cmpMeta.$members$){Cstr.watchers&&(cmpMeta.$watchers$=Cstr.watchers);// It's better to have a const than two Object.entries()
const members=Object.entries(cmpMeta.$members$),prototype=Cstr.prototype;if(members.map((([memberName,[memberFlags]])=>{(31
/* Prop */&memberFlags||2
/* proxyState */&flags&&32
/* State */&memberFlags)&&
// proxyComponent - prop
Object.defineProperty(prototype,memberName,{get(){
// proxyComponent, get value
return getValue$5(this,memberName)},set(newValue){
// proxyComponent, set value
setValue$2(this,memberName,newValue,cmpMeta)},configurable:!0,enumerable:!0})})),1
/* isElementConstructor */&flags){const attrNameToPropName=new Map;prototype.attributeChangedCallback=function(attrName,_oldValue,newValue){plt$2.jmp((()=>{const propName=attrNameToPropName.get(attrName);//  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback
//  in the case where an attribute was set inline.
//  ```html
//    <my-component some-attribute="some-value"></my-component>
//  ```

//  There is an edge case where a developer sets the attribute inline on a custom element and then
//  programmatically changes it before it has been upgraded as shown below:

//  ```html
//    <!-- this component has _not_ been upgraded yet -->
//    <my-component id="test" some-attribute="some-value"></my-component>
//    <script>
//      // grab non-upgraded component
//      el = document.querySelector("#test");
//      el.someAttribute = "another-value";
//      // upgrade component
//      customElements.define('my-component', MyComponent);
//    <\/script>
//  ```
//  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback
//  will be called with `newValue = "some-value"` and will set the shadowed property (this.someAttribute = "another-value")
//  to the value that was set inline i.e. "some-value" from above example. When
//  the connectedCallback attempts to unshadow it will use "some-value" as the initial value rather than "another-value"

//  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed
//  by connectedCallback as this attributeChangedCallback will not fire.

//  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties

//  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to
//  properties here given that this goes against best practices outlined here
//  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy
if(this.hasOwnProperty(propName))newValue=this[propName],delete this[propName];else if(prototype.hasOwnProperty(propName)&&"number"===typeof this[propName]&&this[propName]==newValue)
// if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native
// APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in
// `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.
return;this[propName]=(null!==newValue||"boolean"!==typeof this[propName])&&newValue}))},// create an array of attributes to observe
// and also create a map of html attribute name to js property name
Cstr.observedAttributes=members.filter((([_,m])=>15
/* HasAttribute */&m[0]// filter to only keep props that should match attributes
)).map((([propName,m])=>{const attrName=m[1]||propName;return attrNameToPropName.set(attrName,propName),attrName}))}}return Cstr},initializeComponent$2=async(elm,hostRef,cmpMeta,hmrVersionId,Cstr)=>{
// initializeComponent
if(0===(32
/* hasInitializedComponent */&hostRef.$flags$)){{if(
// we haven't initialized this element yet
hostRef.$flags$|=32
/* hasInitializedComponent */,// lazy loaded components
// request the component's implementation to be
// wired up with the host element
Cstr=loadModule$2(cmpMeta),Cstr.then){
// Await creates a micro-task avoid if possible
const endLoad=uniqueTime$2();Cstr=await Cstr,endLoad()}Cstr.isProxied||(cmpMeta.$watchers$=Cstr.watchers,proxyComponent$2(Cstr,cmpMeta,2
/* proxyState */),Cstr.isProxied=!0);const endNewInstance=createTime$2("createInstance",cmpMeta.$tagName$);// ok, time to construct the instance
// but let's keep track of when we start and stop
// so that the getters/setters don't incorrectly step on data
hostRef.$flags$|=8
/* isConstructingInstance */;// construct the lazy-loaded component implementation
// passing the hostRef is very important during
// construction in order to directly wire together the
// host element and the lazy-loaded instance
try{new Cstr(hostRef)}catch(e){consoleError$2(e)}hostRef.$flags$&=-9
/* isConstructingInstance */,hostRef.$flags$|=128
/* isWatchReady */,endNewInstance()}if(Cstr.style){
// this component has styles but we haven't registered them yet
let style=Cstr.style;const scopeId=getScopeId$2(cmpMeta);if(!styles$6.has(scopeId)){const endRegisterStyles=createTime$2("registerStyles",cmpMeta.$tagName$);registerStyle$2(scopeId,style,!!(1
/* shadowDomEncapsulation */&cmpMeta.$flags$)),endRegisterStyles()}}}// we've successfully created a lazy instance
const ancestorComponent=hostRef.$ancestorComponent$,schedule=()=>scheduleUpdate$2(hostRef,!0);ancestorComponent&&ancestorComponent["s-rc"]?
// this is the initial load and this component it has an ancestor component
// but the ancestor component has NOT fired its will update lifecycle yet
// so let's just cool our jets and wait for the ancestor to continue first
// this will get fired off when the ancestor component
// finally gets around to rendering its lazy self
// fire off the initial update
ancestorComponent["s-rc"].push(schedule):schedule()},connectedCallback$2=elm=>{if(0===(1
/* isTmpDisconnected */&plt$2.$flags$)){const hostRef=getHostRef$2(elm),cmpMeta=hostRef.$cmpMeta$,endConnected=createTime$2("connectedCallback",cmpMeta.$tagName$);if(!(1
/* hasConnected */&hostRef.$flags$)){
// first time this component has connected
hostRef.$flags$|=1
/* hasConnected */;{
// find the first ancestor component (if there is one) and register
// this component as one of the actively loading child components for its ancestor
let ancestorComponent=elm;while(ancestorComponent=ancestorComponent.parentNode||ancestorComponent.host)
// climb up the ancestors looking for the first
// component that hasn't finished its lifecycle update yet
if(ancestorComponent["s-p"]){
// we found this components first ancestor component
// keep a reference to this component's ancestor component
attachToAncestor$2(hostRef,hostRef.$ancestorComponent$=ancestorComponent);break}}// Lazy properties
// https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
cmpMeta.$members$&&Object.entries(cmpMeta.$members$).map((([memberName,[memberFlags]])=>{if(31
/* Prop */&memberFlags&&elm.hasOwnProperty(memberName)){const value=elm[memberName];delete elm[memberName],elm[memberName]=value}})),initializeComponent$2(elm,hostRef,cmpMeta)}endConnected()}},disconnectedCallback$2=elm=>{0===(1
/* isTmpDisconnected */&plt$2.$flags$)&&getHostRef$2(elm)},bootstrapLazy$2=(lazyBundles,options={})=>{const endBootstrap=createTime$2(),cmpTags=[],exclude=options.exclude||[],customElements=win$2.customElements,head=doc$6.head,metaCharset=head.querySelector("meta[charset]"),visibilityStyle=doc$6.createElement("style"),deferredConnectedCallbacks=[];let appLoadFallback,isBootstrapping=!0;Object.assign(plt$2,options),plt$2.$resourcesUrl$=new URL(options.resourcesUrl||"./",doc$6.baseURI).href,lazyBundles.map((lazyBundle=>{lazyBundle[1].map((compactMeta=>{const cmpMeta={$flags$:compactMeta[0],$tagName$:compactMeta[1],$members$:compactMeta[2],$listeners$:compactMeta[3]};cmpMeta.$members$=compactMeta[2],cmpMeta.$watchers$={};const tagName=cmpMeta.$tagName$,HostElement=class extends HTMLElement{
// StencilLazyHost
constructor(self){
// @ts-ignore
super(self),self=this,registerHost$2(self,cmpMeta),1
/* shadowDomEncapsulation */&cmpMeta.$flags$&&self.attachShadow({mode:"open"})}connectedCallback(){appLoadFallback&&(clearTimeout(appLoadFallback),appLoadFallback=null),isBootstrapping?
// connectedCallback will be processed once all components have been registered
deferredConnectedCallbacks.push(this):plt$2.jmp((()=>connectedCallback$2(this)))}disconnectedCallback(){plt$2.jmp((()=>disconnectedCallback$2(this)))}componentOnReady(){return getHostRef$2(this).$onReadyPromise$}};cmpMeta.$lazyBundleId$=lazyBundle[0],exclude.includes(tagName)||customElements.get(tagName)||(cmpTags.push(tagName),customElements.define(tagName,proxyComponent$2(HostElement,cmpMeta,1
/* isElementConstructor */)))}))})),visibilityStyle.innerHTML=cmpTags+HYDRATED_CSS$2,visibilityStyle.setAttribute("data-styles",""),head.insertBefore(visibilityStyle,metaCharset?metaCharset.nextSibling:head.firstChild),// Process deferred connectedCallbacks now all components have been registered
isBootstrapping=!1,deferredConnectedCallbacks.length?deferredConnectedCallbacks.map((host=>host.connectedCallback())):plt$2.jmp((()=>appLoadFallback=setTimeout(appDidLoad$2,30))),// Fallback appLoad event
endBootstrap()},hostRefs$2=new WeakMap,getHostRef$2=ref=>hostRefs$2.get(ref),registerHost$2=(elm,cmpMeta)=>{const hostRef={$flags$:0,$hostElement$:elm,$cmpMeta$:cmpMeta,$instanceValues$:new Map};return hostRef.$onReadyPromise$=new Promise((r=>hostRef.$onReadyResolve$=r)),elm["s-p"]=[],elm["s-rc"]=[],hostRefs$2.set(elm,hostRef)},isMemberInElement$2=(elm,memberName)=>memberName in elm,consoleError$2=(e,el)=>(0,console.error)(e,el),cmpModules$2=new Map,loadModule$2=(cmpMeta,hostRef,hmrVersionId)=>{
// loadModuleImport
const exportName=cmpMeta.$tagName$.replace(/-/g,"_"),bundleId=cmpMeta.$lazyBundleId$,module=cmpModules$2.get(bundleId);return module?module[exportName]:__webpack_require__(102650)(`./${bundleId}.entry.js`).then((importedModule=>(cmpModules$2.set(bundleId,importedModule),importedModule[exportName])),consoleError$2)
/*!__STENCIL_STATIC_IMPORT_SWITCH__*/},styles$6=new Map,queueDomReads$2=[],queueDomWrites$2=[],queueTask$2=(queue,write)=>cb=>{queue.push(cb),queuePending$2||(queuePending$2=!0,write&&4
/* queueSync */&plt$2.$flags$?nextTick$2(flush$2):plt$2.raf(flush$2))},consume$2=queue=>{for(let i=0;i<queue.length;i++)try{queue[i](performance.now())}catch(e){consoleError$2(e)}queue.length=0},flush$2=()=>{
// always force a bunch of medium callbacks to run, but still have
// a throttle on how many can run in a certain time
// DOM READS!!!
consume$2(queueDomReads$2),consume$2(queueDomWrites$2),(queuePending$2=queueDomReads$2.length>0)&&
// still more to do yet, but we've run out of time
// let's let this thing cool off and try again in the next tick
plt$2.raf(flush$2)},nextTick$2=cb=>promiseResolve$2().then(cb),writeTask$2=queueTask$2(queueDomWrites$2,!0),patchEsm$2=()=>promiseResolve$2(),defineCustomElements$2=(win,options)=>"undefined"===typeof window?Promise.resolve():patchEsm$2().then((()=>bootstrapLazy$2([["fc-icon",[[1,"fc-icon",{name:[1],group:[1],size:[1],color:[1],svgContent:[32],iconClass:[32],icon:[32],baseURL:[32],sym:[32]}]]]],options)));(function(){if("undefined"!==typeof window&&void 0!==window.Reflect&&void 0!==window.customElements){var a=HTMLElement;window.HTMLElement=function(){return Reflect.construct(a,[],this.constructor)},HTMLElement.prototype=a.prototype,HTMLElement.prototype.constructor=HTMLElement,Object.setPrototypeOf(HTMLElement,a)}})(),
defineCustomElements$2();var EmptyIcon$2={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{width:"87",height:"66",viewBox:"0 0 87 66",xmlns:"http://www.w3.org/2000/svg"}},[_c("g",{attrs:{transform:"translate(0 .87)",fill:"none","fill-rule":"evenodd"}},[_c("path",{attrs:{stroke:"#7176C4",fill:"#FFF","stroke-linecap":"round","stroke-linejoin":"round",d:"M76.196 57.682l-2.284-3.27 5.511-3.86 5.002 7.144"}}),_c("path",{attrs:{fill:"#DBDBF3",d:"M75.243 54.064l3.99-2.793 4.646 6.636-5.915.044z"}}),_c("path",{attrs:{fill:"#FFF",d:"M77.846 52.252l.926-.649 3.96 5.657-.925.648zm-1.073.746l.819-.573 3.461 4.943-.819.574z"}}),_c("path",{attrs:{stroke:"#7176C4","stroke-linecap":"round","stroke-linejoin":"round",d:"M.5 57.682h85.874m-31.686 6.635h10.86m-44.222 0h24.253"}}),_c("path",{attrs:{stroke:"#FFF","stroke-linecap":"round","stroke-linejoin":"round",d:"M57.377 33.73h0m10.875 0h0"}}),_c("path",{attrs:{stroke:"#7176C4","stroke-linecap":"round","stroke-linejoin":"round",d:"M25.525 57.111V.5h35.062l7.666 7.725v48.887"}}),_c("path",{attrs:{stroke:"#7176C4","stroke-linecap":"round","stroke-linejoin":"round",d:"M60.682.5l7.571 7.57h-7.57z"}}),_c("path",{attrs:{fill:"#DBDBF3",d:"M67.806 15.954l-7.57-7.57h7.57zM21.507 6.16h3.509v50.952h-3.509z"}}),_c("path",{attrs:{stroke:"#7176C4","stroke-linecap":"round","stroke-linejoin":"round",d:"M7.482 57.16v-51h18.043"}}),_c("path",{attrs:{d:"M72.705 22.132a18.131 18.131 0 018.923 9.319M73.27 19.113c.4.2.795.413 1.182.638m1.443.912a21.96 21.96 0 013.622 3.122",stroke:"#BCBCE2","stroke-linecap":"round","stroke-linejoin":"round"}}),_c("path",{attrs:{fill:"#AAAAE2",opacity:".5",d:"M33.001 35.954h28.027V34.13H33.001zm0-5h28.027V29.13H33.001z"}}),_c("path",{attrs:{"fill-opacity":".5",fill:"#DBDBF3",d:"M33.001 40.954h28.027V39.13H33.001zM33 45.977h14.014v-1.823H33z"}}),_c("path",{attrs:{fill:"#AAAAE2",opacity:".5",d:"M33.001 9.954h25.34V8.13h-25.34z"}}),_c("path",{attrs:{"fill-opacity":".5",fill:"#DBDBF3",d:"M33.001 14.954h25.34V13.13h-25.34zM33 19.977h14.014v-1.823H33z"}}),_c("path",{attrs:{fill:"#AAAAE2",opacity:".5",d:"M12 14.954h9.551V13.13h-9.55z"}}),_c("path",{attrs:{"fill-opacity":".5",fill:"#DBDBF3",d:"M12 19.954h9.551V18.13h-9.55z"}}),_c("path",{attrs:{stroke:"#7176C4",fill:"#FFF","stroke-linecap":"round","stroke-linejoin":"round",d:"M69.658 45.844l3.277-2.294 5.725 8.176-3.276 2.295z"}}),_c("path",{attrs:{"fill-opacity":".3",fill:"#7176C4",d:"M70.218 47.319l3.898-2.73 1.98 2.83-3.897 2.728z"}}),_c("path",{attrs:{d:"M64.459 52.077c1.146 0 2.257-.148 3.316-.425.088-25.227.088-24.887.088-25.227a13.067 13.067 0 00-3.404-.448c-7.208 0-13.05 5.842-13.05 13.05 0 7.207 5.842 13.05 13.05 13.05z","fill-opacity":".3",fill:"#BCBCE2"}}),_c("circle",{attrs:{stroke:"#7176C4",fill:"#FFF","stroke-linecap":"round","stroke-linejoin":"round",cx:"65.99",cy:"37.431",r:"11.302"}}),_c("path",{attrs:{"fill-opacity":".5",fill:"#DBDBF3",d:"M12 24.977h7.112v-1.823H12z"}}),_c("circle",{attrs:{fill:"#DBDBF3",cx:"66.262",cy:"37.704",r:"10.489"}}),_c("circle",{attrs:{fill:"#FFF",cx:"65.99",cy:"37.431",r:"8.127"}}),_c("path",{attrs:{d:"M74.117 37.431c0-.687-.086-1.355-.246-1.992m-.685-1.788a8.127 8.127 0 10-7.196 11.907h0m7.167 1.072l1.29 1.815m1.013 1.424l.253.357",stroke:"#7176C4",fill:"#FFF","stroke-linecap":"round","stroke-linejoin":"round"}}),_c("circle",{attrs:{fill:"#EDEDF9",cx:"66.829",cy:"33.959",r:"2.829"}}),_c("circle",{attrs:{fill:"#EDEDF9",cx:"70.75",cy:"37.959",r:"1.171"}})])])}},AdvancedFilterIcon$1={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",width:"13",height:"10",viewBox:"0 0 13 10"}},[_c("path",{attrs:{fill:"#6C6A91",d:"M7.966 8.738c.351 0 .635.282.635.63 0 .35-.284.632-.635.632H5.034a.633.633 0 01-.635-.631c0-.349.284-.631.635-.631h2.932zm1.955-4.38a.632.632 0 110 1.263H3.079a.633.633 0 01-.635-.631c0-.349.284-.631.635-.631h6.842zM12.365 0c.35 0 .635.283.635.631a.632.632 0 01-.635.631H.635A.632.632 0 11.635 0h11.73z"}})])}};function styleInject$3(css,ref){void 0===ref&&(ref={});var insertAt=ref.insertAt;if(css&&"undefined"!==typeof document){var head=document.head||document.getElementsByTagName("head")[0],style=document.createElement("style");style.type="text/css","top"===insertAt&&head.firstChild?head.insertBefore(style,head.firstChild):head.appendChild(style),style.styleSheet?style.styleSheet.cssText=css:style.appendChild(document.createTextNode(css))}}var css_248z$5="*, ::before, ::after {\n  --tw-border-opacity: 1;\n  border-color: rgba(229, 231, 235, var(--tw-border-opacity))\n}\n\n.fixed {\n  position: fixed\n}\n\n.float-right {\n  float: right\n}\n\n.m-0 {\n  margin: 0px\n}\n\n.m-0\\.5 {\n  margin: 0.125rem\n}\n\n.my-1 {\n  margin-top: 0.25rem;\n  margin-bottom: 0.25rem\n}\n\n.my-4 {\n  margin-top: 1rem;\n  margin-bottom: 1rem\n}\n\n.mt-auto {\n  margin-top: auto\n}\n\n.mr-1 {\n  margin-right: 0.25rem\n}\n\n.mr-2 {\n  margin-right: 0.5rem\n}\n\n.mr-3 {\n  margin-right: 0.75rem\n}\n\n.mr-1\\.5 {\n  margin-right: 0.375rem\n}\n\n.mb-2 {\n  margin-bottom: 0.5rem\n}\n\n.mb-2\\.5 {\n  margin-bottom: 0.625rem\n}\n\n.ml-5 {\n  margin-left: 1.25rem\n}\n\n.ml-auto {\n  margin-left: auto\n}\n\n.flex {\n  display: flex\n}\n\n.table {\n  display: table\n}\n\n.hidden {\n  display: none\n}\n\n.h-4 {\n  height: 1rem\n}\n\n.h-6 {\n  height: 1.5rem\n}\n\n.h-9 {\n  height: 2.25rem\n}\n\n.h-10 {\n  height: 2.5rem\n}\n\n.h-20 {\n  height: 5rem\n}\n\n.h-40 {\n  height: 10rem\n}\n\n.h-full {\n  height: 100%\n}\n\n.w-4 {\n  width: 1rem\n}\n\n.w-6 {\n  width: 1.5rem\n}\n\n.w-9 {\n  width: 2.25rem\n}\n\n.w-10 {\n  width: 2.5rem\n}\n\n.w-12 {\n  width: 3rem\n}\n\n.w-28 {\n  width: 7rem\n}\n\n.w-40 {\n  width: 10rem\n}\n\n.w-10\\/12 {\n  width: 83.333333%\n}\n\n.w-full {\n  width: 100%\n}\n\n.border-collapse {\n  border-collapse: collapse\n}\n\n.transform {\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  transform: translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))\n}\n\n@keyframes spin {\n  to {\n    transform: rotate(360deg)\n  }\n}\n\n@keyframes ping {\n  75%, 100% {\n    transform: scale(2);\n    opacity: 0\n  }\n}\n\n@keyframes pulse {\n  50% {\n    opacity: .5\n  }\n}\n\n@keyframes bounce {\n  0%, 100% {\n    transform: translateY(-25%);\n    animation-timing-function: cubic-bezier(0.8,0,1,1)\n  }\n\n  50% {\n    transform: none;\n    animation-timing-function: cubic-bezier(0,0,0.2,1)\n  }\n}\n\n.cursor-pointer {\n  cursor: pointer\n}\n\n.flex-col {\n  flex-direction: column\n}\n\n.flex-wrap {\n  flex-wrap: wrap\n}\n\n.flex-nowrap {\n  flex-wrap: nowrap\n}\n\n.items-center {\n  align-items: center\n}\n\n.justify-center {\n  justify-content: center\n}\n\n.justify-between {\n  justify-content: space-between\n}\n\n.self-center {\n  align-self: center\n}\n\n.border {\n  border-width: 1px\n}\n\n.py-1 {\n  padding-top: 0.25rem;\n  padding-bottom: 0.25rem\n}\n\n.py-2 {\n  padding-top: 0.5rem;\n  padding-bottom: 0.5rem\n}\n\n.py-1\\.5 {\n  padding-top: 0.375rem;\n  padding-bottom: 0.375rem\n}\n\n.pr-3 {\n  padding-right: 0.75rem\n}\n\n.pl-1 {\n  padding-left: 0.25rem\n}\n\n.text-left {\n  text-align: left\n}\n\n.text-center {\n  text-align: center\n}\n\n.text-xs {\n  font-size: 0.75rem;\n  line-height: 1rem\n}\n\n.uppercase {\n  text-transform: uppercase\n}\n\n.italic {\n  font-style: italic\n}\n\n.underline {\n  text-decoration: underline\n}\n\n*, ::before, ::after {\n  --tw-shadow: 0 0 #0000\n}\n\n*, ::before, ::after {\n  --tw-ring-inset: var(--tw-empty,/*!*/ /*!*/);\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgba(59, 130, 246, 0.5);\n  --tw-ring-offset-shadow: 0 0 #0000;\n  --tw-ring-shadow: 0 0 #0000\n}\n\n.filter {\n  --tw-blur: var(--tw-empty,/*!*/ /*!*/);\n  --tw-brightness: var(--tw-empty,/*!*/ /*!*/);\n  --tw-contrast: var(--tw-empty,/*!*/ /*!*/);\n  --tw-grayscale: var(--tw-empty,/*!*/ /*!*/);\n  --tw-hue-rotate: var(--tw-empty,/*!*/ /*!*/);\n  --tw-invert: var(--tw-empty,/*!*/ /*!*/);\n  --tw-saturate: var(--tw-empty,/*!*/ /*!*/);\n  --tw-sepia: var(--tw-empty,/*!*/ /*!*/);\n  --tw-drop-shadow: var(--tw-empty,/*!*/ /*!*/);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)\n}\n\n.blur {\n  --tw-blur: blur(8px)\n}\n\n.transition {\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms\n}\n\n.ease-in-out {\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1)\n}\n\n@media (min-width: 640px) {\n}\n\n@media (min-width: 768px) {\n}\n\n@media (min-width: 1024px) {\n}\n\n@media (min-width: 1280px) {\n}\n\n@media (min-width: 1536px) {\n}\n";styleInject$3(css_248z$5);var css_248z$4="/*purgecss start ignore*/\n\n.f-ui-base-text-input .el-input__inner, .f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input__inner,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input__inner, .f-ui-forms .f-ui-date-picker .el-input__inner, .f-ui-forms .f-ui-time-picker .el-input__inner, .f-ui-forms .f-ui-select .el-input__inner, .f-ui-forms .f-ui-text-input .el-input__inner {\n  height: 40px;\n  line-height: 40px;\n  padding-left: 15px;\n  padding-right: 15px;\n  border-radius: 3px;\n  background-color: #fff;\n  border: 1px solid #d0d9e2;\n  font-size: 14px;\n  letter-spacing: 0.4px;\n  color: #324056;\n  text-overflow: ellipsis;\n  font-weight: 400;\n  padding-right: 30px;\n  white-space: nowrap;\n}\n\n.f-ui-base-text-input .el-input__inner:hover, .f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input__inner:hover,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input__inner:hover, .f-ui-forms .f-ui-date-picker .el-input__inner:hover, .f-ui-forms .f-ui-time-picker .el-input__inner:hover, .f-ui-forms .f-ui-select .el-input__inner:hover, .f-ui-forms .f-ui-text-input .el-input__inner:hover,\n.f-ui-base-text-input .el-input__inner:focus,\n.f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input__inner:focus,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input__inner:focus,\n.f-ui-forms .f-ui-date-picker .el-input__inner:focus,\n.f-ui-forms .f-ui-time-picker .el-input__inner:focus,\n.f-ui-forms .f-ui-select .el-input__inner:focus,\n.f-ui-forms .f-ui-text-input .el-input__inner:focus {\n  border-color: #39b2c2;\n}\n\n.f-ui-base-text-input .el-input.is-focus .el-input__inner, .f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input.is-focus .el-input__inner,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input.is-focus .el-input__inner, .f-ui-forms .f-ui-date-picker .el-input.is-focus .el-input__inner, .f-ui-forms .f-ui-time-picker .el-input.is-focus .el-input__inner, .f-ui-forms .f-ui-select .el-input.is-focus .el-input__inner, .f-ui-forms .f-ui-text-input .el-input.is-focus .el-input__inner {\n  border-color: #39b2c2;\n}\n\n.f-ui-base-text-input .el-input__inner[disabled=disabled], .f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input__inner[disabled=disabled],\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input__inner[disabled=disabled], .f-ui-forms .f-ui-date-picker .el-input__inner[disabled=disabled], .f-ui-forms .f-ui-time-picker .el-input__inner[disabled=disabled], .f-ui-forms .f-ui-select .el-input__inner[disabled=disabled], .f-ui-forms .f-ui-text-input .el-input__inner[disabled=disabled] {\n  background-color: #f5f7fa;\n  border-color: #e4e7ed;\n  color: #c0c4cc;\n}\n\n.f-ui-base-text-input input::-webkit-outer-spin-button, .f-date-picker-popper .el-date-picker__editor-wrap .el-input input::-webkit-outer-spin-button,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input input::-webkit-outer-spin-button, .f-ui-forms .f-ui-date-picker input::-webkit-outer-spin-button, .f-ui-forms .f-ui-time-picker input::-webkit-outer-spin-button, .f-ui-forms .f-ui-select input::-webkit-outer-spin-button, .f-ui-forms .f-ui-text-input input::-webkit-outer-spin-button,\n.f-ui-base-text-input input::-webkit-inner-spin-button,\n.f-date-picker-popper .el-date-picker__editor-wrap .el-input input::-webkit-inner-spin-button,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input input::-webkit-inner-spin-button,\n.f-ui-forms .f-ui-date-picker input::-webkit-inner-spin-button,\n.f-ui-forms .f-ui-time-picker input::-webkit-inner-spin-button,\n.f-ui-forms .f-ui-select input::-webkit-inner-spin-button,\n.f-ui-forms .f-ui-text-input input::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n\n.f-ui-base-text-input input[type=number], .f-date-picker-popper .el-date-picker__editor-wrap .el-input input[type=number],\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input input[type=number], .f-ui-forms .f-ui-date-picker input[type=number], .f-ui-forms .f-ui-time-picker input[type=number], .f-ui-forms .f-ui-select input[type=number], .f-ui-forms .f-ui-text-input input[type=number] {\n  -moz-appearance: textfield;\n}\n\n.f-ui-forms .f-ui-select-tag .el-tag,\n.f-ui-forms .f-ui-lookup-container .el-tag {\n  border-radius: 50px;\n  border: solid 1px #39b2c2;\n  letter-spacing: 0.4px;\n  color: #39b2c2;\n  line-height: 25px;\n  height: 25px;\n  background: #fff;\n}\n\n.f-ui-forms .f-ui-select-tag .el-tag .el-icon-close,\n.f-ui-forms .f-ui-lookup-container .el-tag .el-icon-close {\n  color: #39b2c2;\n  background: transparent;\n  font-size: 16px;\n  padding-right: 10px;\n  font-weight: 600;\n  margin-right: 5px;\n  line-height: 15px;\n}\n\n.f-ui-forms .f-ui-select-tag .el-tag .el-icon-close:hover,\n.f-ui-forms .f-ui-lookup-container .el-tag .el-icon-close:hover {\n  background: transparent;\n  color: #39b2c2;\n}\n\n.f-ui-forms .f-ui-select-tag .el-select__tags,\n.f-ui-forms .f-ui-lookup-container .el-select__tags {\n  padding-left: 0;\n}\n\n.f-ui-forms .f-ui-select-tag .el-select__tags-text,\n.f-ui-forms .f-ui-lookup-container .el-select__tags-text {\n  max-width: 70px;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n  display: block;\n}\n\n.f-ui-forms .f-ui-time-picker {\n  width: 100%;\n}\n\n.f-ui-forms .f-ui-time-picker .el-input__inner {\n  padding-left: 30px;\n}\n\n.f-ui-forms .f-ui-date-picker {\n  width: 100%;\n}\n\n.f-ui-forms .f-ui-date-picker .el-input__inner {\n  padding-left: 30px;\n}\n\n.f-ui-forms .f-ui-date-picker.is-active,\n.f-ui-forms .f-ui-date-picker.is-active:hover {\n  border-color: #39b2c2;\n}\n\n.f-ui-forms .f-ui-tag {\n  border-radius: 50px;\n  border: solid 1px #39b2c2;\n  letter-spacing: 0.4px;\n  color: #39b2c2;\n  line-height: 25px;\n  height: 25px;\n  background: #fff;\n}\n\n.f-ui-forms .f-ui-tag .el-icon-close {\n  color: #39b2c2;\n  background: transparent;\n  font-size: 14px;\n  padding-right: 10px;\n  font-weight: 600;\n  margin-right: 5px;\n  line-height: 15px;\n  margin-top: 3px;\n}\n\n.f-ui-forms .f-ui-tag .el-icon-close:hover {\n  background: transparent;\n  color: #39b2c2;\n}\n\n.f-ui-forms .f-ui-icon-hover {\n  border: solid 1px transparent;\n  border-radius: 4px;\n}\n\n.f-ui-forms .f-ui-icon-hover:hover {\n  color: #615e88;\n  background: #f5f6f8;\n  border: 1px solid #dae0e8;\n}\n\n.f-ui-select-popper .f-ui-select-item {\n  display: flex;\n}\n\n.f-ui-select-popper .f-ui-select-item.selected {\n  font-weight: 400 !important;\n  /*color: #ef4f8f;*/\n  color: #ff3184;\n  letter-spacing: 1px !important;\n  font-size: 14px !important;\n}\n\n.f-ui-select-popper.is-multiple .f-ui-select-item {\n  display: flex;\n}\n\n.f-ui-select-popper.is-multiple .f-ui-select-item.selected {\n  color: #39b2c2 !important;\n}\n\n.f-date-picker-popper .el-picker-panel__footer .el-button--text {\n  color: #39b2c2;\n}\n\n.f-date-picker-popper .el-date-table td.available:hover,\n.f-date-picker-popper .el-date-table td.today span,\n.f-date-picker-popper .el-month-table td .cell:hover,\n.f-date-picker-popper .el-month-table td.today .cell,\n.f-date-picker-popper .el-year-table td .cell:hover,\n.f-date-picker-popper .el-year-table td.current:not(.disabled) .cell,\n.f-date-picker-popper .el-year-table td.today .cell,\n.f-date-picker-popper .el-time-panel__btn.confirm {\n  color: #39b2c2;\n}\n\n.f-date-picker-popper .el-date-table td.current:not(.disabled) span,\n.f-date-picker-popper .el-date-table td.end-date span,\n.f-date-picker-popper .el-date-table td.start-date span {\n  color: #fff;\n  background-color: #39b2c2;\n}\n\n.f-date-picker-popper .el-date-picker__header-label.active,\n.f-date-picker-popper .el-date-picker__header-label:hover {\n  color: #ff3184;\n}\n\n/*purgecss end ignore*/";styleInject$3(css_248z$4);
var script$k={name:"TextInput",components:{Input:element_ui_common.Input},props:["value","disabled","readonly"],data(){return{props:{},inputValue:""}},watch:{value:{handler(newVal,oldVal){newVal!==oldVal&&(this.inputValue=newVal)},immediate:!0}},mounted(){this.getProps()},methods:{getProps(){let props=this.$vnode.elm.attributes;Object.keys(props).forEach((key=>{this.$set(this.props,props[key].name,props[key].nodeValue)}))},change(value){this.$emit("input",value),this.$emit("change",value)},blur(...args){this.$emit("blur",args)},input(value){this.$emit("input",value)}}};function normalizeComponent$5(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);
// Vue.extend constructor export interop.
const options="function"===typeof script?script.options:script;
// render functions
let hook;if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,
// functional template
isFunctionalTemplate&&(options.functional=!0)),
// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),
// inject component styles
style&&style.call(this,createInjectorSSR(context)),
// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},
// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(context){style.call(this,createInjectorShadow(context,this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
const originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
const existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}const isOldIE$2="undefined"!==typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());function createInjector$2(context){return(id,style)=>addStyle$4(id,style)}let HEAD$2;const styles$4={};function addStyle$4(id,css){const group=isOldIE$2?css.media||"default":id,style=styles$4[group]||(styles$4[group]={ids:new Set,styles:[]});if(!style.ids.has(id)){style.ids.add(id);let code=css.source;if(css.map&&(
// https://developer.chrome.com/devtools/docs/javascript-debugging
// this makes source maps inside style tags work properly in Chrome
code+="\n/*# sourceURL="+css.map.sources[0]+" */",
// http://stackoverflow.com/a/26603875
code+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(css.map))))+" */"),style.element||(style.element=document.createElement("style"),style.element.type="text/css",css.media&&style.element.setAttribute("media",css.media),void 0===HEAD$2&&(HEAD$2=document.head||document.getElementsByTagName("head")[0]),HEAD$2.appendChild(style.element)),"styleSheet"in style.element)style.styles.push(code),style.element.styleSheet.cssText=style.styles.filter(Boolean).join("\n");else{const index=style.ids.size-1,textNode=document.createTextNode(code),nodes=style.element.childNodes;nodes[index]&&style.element.removeChild(nodes[index]),nodes.length?style.element.insertBefore(textNode,nodes[index]):style.element.appendChild(textNode)}}}
/* script */const __vue_script__$k=script$k;
/* template */var __vue_render__$i=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"f-ui-forms"},[_c("Input",_vm._b({staticClass:"f-ui-text-input",attrs:{disabled:_vm.disabled,readonly:_vm.readonly},on:{change:_vm.change,blur:_vm.blur,input:_vm.input},model:{value:_vm.inputValue,callback:function($$v){_vm.inputValue=$$v},expression:"inputValue"}},"Input",_vm.props,!1))],1)},__vue_staticRenderFns__$i=[];
/* style */
const __vue_inject_styles__$k=function(inject){inject&&inject("data-v-1c999eb9_0",{source:".f-ui-text-input .el-input__inner{height:40px;line-height:40px;padding-left:15px;padding-right:15px;border-radius:3px;background-color:#fff;border:1px solid #d0d9e2;font-size:14px;letter-spacing:.4px;color:#324056;text-overflow:ellipsis;font-weight:400;padding-right:30px;white-space:nowrap}",map:void 0,media:void 0})},__vue_scope_id__$k=void 0,__vue_module_identifier__$k=void 0,__vue_is_functional_template__$k=!1,__vue_component__$j=normalizeComponent$5({render:__vue_render__$i,staticRenderFns:__vue_staticRenderFns__$i},__vue_inject_styles__$k,__vue_script__$k,__vue_scope_id__$k,__vue_is_functional_template__$k,__vue_module_identifier__$k,!1,createInjector$2,void 0,void 0),isEmpty$5=value=>void 0===value||null===value||-1===Number(value)||"object"===typeof value&&!(value instanceof Blob)&&0===Object.keys(value).length||"string"===typeof value&&0===value.trim().length,isNull$1=value=>null===value,isArray$1=value=>value&&value.constructor===Array,isObject$2=obj=>null!==obj&&"object"===typeof obj&&!1===Array.isArray(obj),isFunction$4=value=>"function"===typeof value;
/* scoped */var Constants$1={FIELD_PLACEHOLDERS:["${CURRENT_DATE}","${CURRENT_TIME}","${LOGGED_USER}","${LOGGED_TENANT}","${LOGGED_VENDOR}"],LOOKUP_FILTER_ENABLED_FIELDS:["resource","people"],LOOKUP_FILTERS_MAP:{1:"building",2:"asset",3:"tenantcontact",4:"clientcontact",5:"vendorcontact",6:"employee"},QUICK_FILTERS:[{value:null,key:"category",placeHolderText:"Category",lookupModule:{name:null},disabled:!1,options:[]},{spaceType:1,value:null,key:"site",placeHolderText:"Site",lookupModule:{name:"site"},disabled:!1,options:[]},{spaceType:2,value:null,key:"building",placeHolderText:"Building",lookupModule:{name:"building"},disabled:!1,options:[]},{spaceType:3,value:null,key:"floor",placeHolderText:"Floor",lookupModule:{name:"floor"},disabled:!0,options:[]},{spaceType:4,value:null,key:"space",placeHolderText:"Space",lookupModule:{name:"basespace"},disabled:!0,options:[]}]};const constructOptionsToMap$1=valueArr=>{let optionsObj=valueArr.reduce(((optionsObj,option)=>{let{label:label,value:value}=option||{};return optionsObj[value]=label,optionsObj}),{});return optionsObj},deepClean=objValue=>{
/**
    Deep cleans the object based on isEmpty in util/validation.
    @param {Object,Array}
    @result {Object,Array} Deep cleaned
    Sample Input => {
          a: { b: null, c: 1 },
          d: null,
          e: -1,
          f: [],
          l: [{ a: null }, { b: 2 }, 3],
          h: 100,
          i: [1, 2, '', -1],
          j: [{}, -1, ''],
          k: [{ a: null, b: [[[]]] }, -1, ''],
        }
    Sample Output => {
          a: { c: 1 },
          h: 100,
          i: [1, 2],
          l: [{ b: 2 }, 3],
        }
  */
let obj=cloneDeep(objValue);return transform(obj,((result,value,key)=>{if((isArray$1(value)||isObject$2(value))&&(value=deepClean(value)),!isEmpty$5(value))return isArray$1(result)?result.push(value):void(result[key]=value)}))},getFieldOptions$1=async props=>{let{field:field,siteId:siteId,searchText:searchText,page:page,perPage:perPage,defaultIds:defaultIds,customOptions:customOptions}=props,{filters:filters={},field:fieldObj,clientCriteria:clientCriteria={},lookupModule:lookupModule,resourceLookupModuleName:resourceLookupModuleName,lookupModuleName:lookupModuleName,skipDeserialize:skipDeserialize,operatorLookupModule:operatorLookupModule,additionalParams:additionalParams={}}=field||{},{name:name}=lookupModule||{},{name:operatorLookupModuleName}=operatorLookupModule||{},moduleName=resourceLookupModuleName||lookupModuleName||name;isEmpty$5(operatorLookupModuleName)||(moduleName=operatorLookupModuleName);let{filters:lookupModuleFilters}=lookupModule||{};isEmpty$5(lookupModuleFilters)||(filters={...filters,...lookupModuleFilters}),isEmpty$5(siteId)||(filters={...filters,siteId:{operatorId:36,value:[`${siteId}`]}}),"quote"===dlv_umd(fieldObj,"module.name")&&"workorder"===moduleName&&(filters={...filters,isQuotationNeeded:{operatorId:15,value:[String(!0)]}});let defaultIdsStr=isEmpty$5(defaultIds)?"":defaultIds.toString(),payload={moduleName:moduleName,searchText:searchText,page:page,perPage:perPage,filters:isEmpty$5(filters)?null:JSON.stringify(filters),clientCriteria:isEmpty$5(clientCriteria)?null:JSON.stringify(clientCriteria),defaultIds:defaultIdsStr||null,additionalParams:additionalParams},{error:error,options:options=[],meta:meta}=await fetchFieldOptions$1(payload)||{};if(error)return{error:error};if(isEmpty$5(customOptions)||(options=[...options,...customOptions]),skipDeserialize){let optionsObj=constructOptionsToMap$1(options||[]);return{options:optionsObj,meta:meta}}return{options:options,meta:meta}},fetchFieldOptions$1=async payload=>{let{moduleName:moduleName,searchText:searchText,page:page,perPage:perPage,filters:filters,clientCriteria:clientCriteria,defaultIds:defaultIds,additionalParams:additionalParams}=payload,url=`/v3/picklist/${moduleName}`,params={page:page,perPage:perPage,clientCriteria:clientCriteria,filters:filters,search:searchText,default:defaultIds,viewName:"hidden-all",...additionalParams},{error:error,data:data,meta:meta={}}=await api/* API */.bl.get(url,params)||{};if(error)return{error:error};{let{pickList:options}=data||{};return{options:options||[],meta:meta}}};var LookupIcon$1={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{width:"512",height:"512",viewBox:"0 0 512 512",xmlns:"http://www.w3.org/2000/svg"}},[_c("path",{attrs:{d:"M215.466 481.432c0 10.704-8.71 15.247-19.492 15.247h-85.892C52.151 496.679 32 481.432 32 419.15V78.028C32 17.754 47.553.5 110.082.5h239.999c62.999 0 78.082 14.659 78.082 77.528v185.098c0 10.705-4.305 20.37-15.083 20.37-10.782 0-14.915-9.665-14.915-20.37V78.028c0-38.847-5.615-47.576-48.084-47.576H110.082c-39.68 0-47.917 13.097-47.917 47.576V419.15c0 40.768 6.732 47.518 47.917 47.518h85.892c10.782 0 19.492 4.058 19.492 14.763z"}}),_c("path",{attrs:{d:"M330.56 116.792H129.497c-10.782 0-19.52 6.637-19.52 14.827 0 8.19 8.738 14.828 19.52 14.828H330.56c10.78 0 19.522-6.638 19.522-14.828s-8.743-14.827-19.522-14.827zm19.522 92.355c0-8.19-8.744-14.827-19.523-14.827H129.498c-10.782 0-19.52 6.637-19.52 14.827 0 8.19 8.738 14.827 19.52 14.827H330.56c10.78 0 19.522-6.637 19.522-14.827zm-220.584 62.7c-10.783 0-19.522 6.639-19.522 14.828 0 8.19 8.739 14.827 19.52 14.827h102.592c10.782 0 19.52-6.637 19.52-14.827 0-8.19-8.74-14.827-19.52-14.827H129.497zm215.809 21.927c31.684 0 62.96 12.212 92.762 35.826a230.97 230.97 0 0111.047 9.343c13.134 11.819 22.4 22.164 33.691 36.212l.773.963c.603.753 1.29 1.656 2.058 2.693l.897 1.222.937 1.295 1.133 1.59c8.391 11.835 8.391 27.68.026 39.48l-1.116 1.57a159.25 159.25 0 01-3.376 4.56l-.558.709-1.538 1.914c-10.94 13.558-20.096 23.715-32.938 35.267a231.043 231.043 0 01-11.036 9.333c-29.8 23.615-61.078 35.827-92.762 35.827-31.683 0-62.96-12.211-92.761-35.826a230.993 230.993 0 01-11.047-9.343c-12.837-11.55-21.989-21.705-32.928-35.264l-1.54-1.914-.466-.592a121.78 121.78 0 01-2.179-2.9l-.745-1.024c-.288-.398-.569-.789-.841-1.17l-.792-1.113a34.168 34.168 0 01-.003-39.513l.802-1.126.412-.575.859-1.187.899-1.225a91.05 91.05 0 012.059-2.693l.792-.988c14.496-18.03 27.043-31.52 44.717-45.524 29.801-23.615 61.079-35.827 92.762-35.827zm0 29.8c-24.536 0-49.45 9.727-74.255 29.383-15.22 12.06-26.349 23.94-39.232 39.888l-1.671 2.08-.324.417c-.743.966-1.739 2.33-2.78 3.786l-.725 1.02a4.37 4.37 0 00.002 5.056l1.089 1.526a138.74 138.74 0 002.414 3.276l.473.605 1.479 1.84c10.016 12.41 18.255 21.549 29.654 31.806a201.246 201.246 0 009.621 8.139c24.806 19.655 49.72 29.383 74.255 29.383 24.536 0 49.45-9.728 74.255-29.384a201.302 201.302 0 009.613-8.13c11.675-10.504 20.036-19.834 30.372-32.69l.911-1.14.34-.438c.664-.867 1.54-2.06 2.385-3.236l1.112-1.562a4.368 4.368 0 00-.01-5.06l-.931-1.309c-1.171-1.633-2.325-3.2-3.036-4.087l-.744-.927-1.54-1.908c-9.667-11.92-17.758-20.832-28.85-30.813a201.224 201.224 0 00-9.622-8.138c-24.806-19.656-49.719-29.383-74.255-29.383z"}}),_c("path",{attrs:{d:"M345.6 365.85c-16.497 0-29.867 13.276-29.867 29.655 0 16.378 13.37 29.654 29.867 29.654s29.867-13.276 29.867-29.654c0-16.379-13.37-29.654-29.867-29.654z"}})])}},AddPinkIcon$1={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{width:"14",height:"14",viewBox:"0 0 14 14",xmlns:"http://www.w3.org/2000/svg"}},[_c("path",{attrs:{d:"M7.6 6.4h4.9a.6.6 0 110 1.2H7.6v4.9a.6.6 0 11-1.2 0V7.6H1.5a.6.6 0 110-1.2h4.9V1.5a.6.6 0 111.2 0v4.9z",fill:"#EF508F","fill-rule":"evenodd"}})])}},script$i={name:"Lookup",components:{Select:element_ui_common.Select,Option:element_ui_common.Option,Tooltip:element_ui_common.Tooltip,LookupIcon:LookupIcon$1,AddPinkIcon:AddPinkIcon$1},props:{customOptions:{type:Array,default:()=>[]},value:void 0,field:{type:Object,default:null},disabled:{type:Boolean},siteId:{type:Number,default:null},categoryId:{type:Number,default:null},hideLookupIcon:{type:Boolean,default:!1},popperAppendToBody:{required:!1,type:Boolean,default:!1},fetchOptionsOnLoad:{type:Boolean,default:!0},fetchOptionsMethod:{type:Function,default:null},preHookFilterConstruction:{type:Function,default:field=>field.filters},hideDropDown:{type:Boolean,default:!1},skipLoading:{type:Boolean,default:!1},isClearable:{type:Boolean,default:!0},userfilmoduleEnum:{type:String,default:""}},data(){return{localSearch:!1,isLoadedOnce:!1,currentModelValue:!1,showQuickCreateData:!1,isEmpty:isEmpty$5}},computed:{modelObj:{get(){return this.value},set(val){this.currentModelValue=val,this.$emit("input",val)}},moduleDisplayName(){let{field:field}=this,{lookupModule:lookupModule}=field.field||{},{displayName:displayName}=lookupModule||{};return displayName},isFieldLoading(){let{field:field,defaultIds:defaultIds,skipLoading:skipLoading,isLoadedOnce:isLoadedOnce}=this;return!skipLoading&&!isLoadedOnce&&!isEmpty$5(defaultIds)&&field.isDataLoading},isPickListTypeModule(){let{field:field}=this,{field:fieldObj}=field,{lookupModule:lookupModule}=fieldObj||field,{type:type}=lookupModule||{};// type 1 is for base entity modules
return!!type&&1!==type},isRemote(){let{localSearch:localSearch}=this;return!localSearch},canHideLookupIcon(){let{hideLookupIcon:hideLookupIcon,isPickListTypeModule:isPickListTypeModule,hideDropDown:hideDropDown,field:field,userfilmoduleEnum:userfilmoduleEnum}=this,{config:config}=field||{},canHide=!1;if(!isEmpty$5(config)){let canShowLookupWizard=dlv_umd(config,"canShowLookupWizard",null);isNull$1(canShowLookupWizard)||(canHide=!canShowLookupWizard)}return!hideDropDown&&("PICK_LIST"===userfilmoduleEnum||(canHide||hideLookupIcon||isPickListTypeModule))},canShowQuickCreateIcon(){let{disabled:disabled,field:field}=this,{config:config}=field||{},canShow=!1;return isEmpty$5(config)||(canShow=dlv_umd(config,"canShowQuickCreate")),disabled&&(canShow=!1),canShow},isSiteEnabled(){let siteId=Number(this.$cookie.get("fc.currentSite")),currentSiteId=siteId>0?siteId:-1;return!isEmpty$5(currentSiteId)},isMultiple(){let{field:field}=this;return!!field.multiple},resourceModuleName(){let{field:field}=this,{config:config,lookupModuleName:lookupModuleName}=field,{isFiltersEnabled:isFiltersEnabled,filterValue:filterValue}=config||{};if(isFiltersEnabled&&Constants$1.LOOKUP_FILTER_ENABLED_FIELDS.includes(lookupModuleName)){let moduleName=Constants$1.LOOKUP_FILTERS_MAP[filterValue];return moduleName}return null},isResourceField(){let{field:field}=this,{name:name}=field,isResourceField=this.isChooserTypeField(field)||"resource"===name;return isResourceField},
// To prefill the existing values, we have to send default ids in picklist api
defaultIds(){let{modelObj:modelObj}=this,isPlaceHoldersEnabled=Constants$1.FIELD_PLACEHOLDERS.includes(modelObj)||!1,defaultIds=[];return isEmpty$5(modelObj)||isPlaceHoldersEnabled||(defaultIds=isArray$1(modelObj)?[...modelObj]:[modelObj]),defaultIds=(defaultIds||[]).filter((id=>!`${id}`.includes("${"))),defaultIds},operatorLookupModule(){let{field:field}=this,{operatorLookupModule:operatorLookupModule}=field||{};return operatorLookupModule||{}},skipSiteFilter(){let{field:field}=this,{config:config}=field||{},{skipSiteFilter:skipSiteFilter=!1}=config||{};return skipSiteFilter},canShowSystemClear(){let{canHideLookupIcon:canHideLookupIcon,isClearable:isClearable,modelObj:modelObj}=this;return!canHideLookupIcon&&(isClearable&&!isEmpty$5(modelObj))}},watch:{value(newVal){let{currentModelValue:currentModelValue,isRemote:isRemote}=this;lodash_isEqual(newVal,currentModelValue)||(isRemote&&this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options)})),this.$set(this,"modelObj",newVal))},siteId:{handler(newVal,oldVal){let{isSiteEnabled:isSiteEnabled,skipSiteFilter:skipSiteFilter}=this;skipSiteFilter||isSiteEnabled||newVal===oldVal||this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options)}))}},operatorLookupModule:{handler(newVal,oldVal){lodash_isEqual(newVal,oldVal)||this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options)}))}},"field.clientCriteria":{handler(newVal,oldVal){lodash_isEqual(newVal,oldVal)||this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options)}))}},categoryId:{handler(newVal,oldVal){lodash_isEqual(newVal,oldVal)||this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options)}))}},"field.options":{handler(value){let{modelObj:modelObj}=this;if(!isEmpty$5(value))if(isEmpty$5(modelObj))
// eslint-disable-next-line vue/no-mutating-props
this.field.selectedItems=[];else if(isArray$1(modelObj)){let selectedItems=value.filter((option=>modelObj.includes(option.value)));// eslint-disable-next-line vue/no-mutating-props
this.field.selectedItems=selectedItems}else{let selectedItem=value.find((option=>option.value===modelObj));// eslint-disable-next-line vue/no-mutating-props
this.field.selectedItems=[selectedItem]}},immediate:!0}},async created(){let{fetchOptionsOnLoad:fetchOptionsOnLoad,field:field,modelObj:modelObj}=this;// Have to skip fetching options initially, when module is 'resource' and filters is not enabled
if(this.currentModelValue=modelObj,fetchOptionsOnLoad){let options=await this.getOptions({initialFetch:!0})||[];this.$set(this.field,"options",options),this.$set(this,"isLoadedOnce",!0)}this.remoteMethod=debounce((async searchText=>{let{isDataLoading:isDataLoading}=field;if(!isDataLoading){let options=await this.getOptions({searchText:searchText});this.$set(this.field,"options",options)}}),1e3)},methods:{isChooserTypeField(field){let{displayTypeEnum:displayTypeEnum}=field;// temp have to use a global constant
return["WOASSETSPACECHOOSER","SPACECHOOSER"].includes(displayTypeEnum)},focus(){isEmpty$5(this.$refs["selectBox"])||this.$refs["selectBox"].focus()},async getOptions(params){let{searchText:searchText,initialFetch:initialFetch}=params,{fetchOptionsMethod:fetchOptionsMethod,field:field,siteId:siteId,categoryId:categoryId,isRemote:isRemote,defaultIds:defaultIds,resourceModuleName:resourceModuleName,isResourceField:isResourceField,skipSiteFilter:skipSiteFilter,customOptions:customOptions}=this,options=[];isEmpty$5(resourceModuleName)||(field.resourceLookupModuleName=resourceModuleName),field.filters=this.preHookFilterConstruction(field),isEmpty$5(categoryId)||(field.filters={...field.filters,category:{operator:"is",value:[`${categoryId}`]}});let props={field:field,searchText:searchText};
/*
        Have to return empty options if field is of resourcetype, if filters havent be enabled
        and if no values selected already
      */
if(skipSiteFilter||(props={...props,siteId:siteId}),isResourceField&&isEmpty$5(resourceModuleName)&&isEmpty$5(defaultIds))return options;if(initialFetch&&isRemote&&(props={...props,page:1,perPage:50,defaultIds:defaultIds},isEmpty$5(resourceModuleName)&&isResourceField&&(
// Have to fetch only selected values, which is same as the number of defaultids
props={...props,perPage:defaultIds.length})),isEmpty$5(customOptions)||(props={...props,customOptions:customOptions}),this.$set(field,"isDataLoading",!0),isEmpty$5(fetchOptionsMethod)){let{options:optionsArr=[],error:error,meta:meta}=await getFieldOptions$1(props);if(error){let{message:message}=error||{};this.$message.error(message||"Error Occured")}if(meta&&isEmpty$5(searchText)){let{localSearch:localSearch=!1}=meta;this.$set(this,"localSearch",localSearch)}options=optionsArr}else{let{options:optionsArr=[],error:error}=await this.fetchOptionsMethod(props);if(error){let{message:message}=error||{};this.$message.error(message||"Error Occured")}options=optionsArr}return this.$set(field,"isDataLoading",!1),options},clearData(){this.$emit("input",""),this.recordSelected("")},recordSelected(value){let{field:field,field:{options:options=[]},isMultiple:isMultiple}=this,selectedValues=null;isMultiple?(selectedValues=options.filter((e=>(value||[]).includes(e.value))),field.selectedItems=selectedValues):(selectedValues=options.find((e=>e.value==value))||{},field.selectedItems=[],isEmpty$5(selectedValues)||(field.selectedItems=[selectedValues])),this.$emit("recordSelected",selectedValues,field)},openLookupFieldWizard(field){let{disabled:disabled}=this;disabled||this.$emit("showLookupWizard",field,!0)},openQuickCreate(){let{disabled:disabled}=this;disabled||(this.showQuickCreateData=!0)},setAddedRecord(props){let{record:record}=props,{id:id}=record||{},name=record.displayName||record.name||record.subject,{field:field}=this;field.selectedItems=[{value:id,label:name}],this.$emit("setLookupFieldValue",{field:{...field}})}}};
/* script */
const __vue_script__$i=script$i;
/* template */var __vue_render__$g=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _vm.isFieldLoading?_c("div",{staticClass:"field-loading loading-shimmer"}):_c("div",{staticClass:"f-ui-forms f-ui-lookup-container"},[_c("Select",{ref:"selectBox",class:["f-ui-forms f-ui-select w-full",!_vm.canHideLookupIcon||_vm.canShowQuickCreateIcon?"field-icons-visible":"select-icon-visible",_vm.isMultiple&&"f-ui-select-tag",_vm.hideDropDown&&!_vm.disabled&&"skip-disable"],attrs:{"collapse-tags":"",remote:_vm.isRemote,filterable:"",clearable:_vm.canHideLookupIcon,multiple:_vm.isMultiple,popperAppendToBody:_vm.popperAppendToBody,"remote-method":function(searchText){return _vm.remoteMethod(searchText)},loading:_vm.field.isDataLoading,"loading-text":"Searching",disabled:_vm.disabled||_vm.hideDropDown,placeholder:_vm.field.placeHolderText||"Select","popper-class":"f-ui-select-popper"},on:{change:_vm.recordSelected},model:{value:_vm.modelObj,callback:function($$v){_vm.modelObj=$$v},expression:"modelObj"}},[_c("div",{staticClass:"float-right h-full flex flex-nowrap cursor-pointer",class:!_vm.disabled&&"pointer",attrs:{slot:"prefix"},slot:"prefix"},[_vm.canShowSystemClear?_c("div",{staticClass:"prefix-icon-container flookup-remove-icon",on:{click:_vm.clearData}},[_c("i",{staticClass:"el-icon-circle-close pointer fc-lookup-icon f13"})]):_vm._e(),_vm._v(" "),_vm.canHideLookupIcon?_vm._e():_c("div",{staticClass:"prefix-icon-container flex flex-nowrap",on:{click:function($event){return $event.stopPropagation(),_vm.openLookupFieldWizard(_vm.field)}}},[_c("div",{staticClass:"lookup-icon f-ui-icon-hover"},[_c("LookupIcon",{staticClass:"w-4 h-4"})],1)]),_vm._v(" "),_vm.canShowQuickCreateIcon?_c("div",{staticClass:"prefix-icon-container flex flex-nowrap",on:{click:function($event){return $event.stopPropagation(),function(){return _vm.openQuickCreate()}.apply(null,arguments)}}},[_c("Tooltip",{attrs:{effect:"dark",content:"Add\n          "+_vm.moduleDisplayName,placement:"top"}},[_c("AddPinkIcon",{staticClass:"icon"})],1)],1):_vm._e()]),_vm._v(" "),_vm._l(_vm.field.options,(function(option,index){return _c("Option",{key:option.value+" "+index,staticClass:"f-ui-select-item width100",attrs:{label:option.label,value:option.value}},[_vm.isEmpty(option.secondaryLabel)?_vm._e():_c("span",{staticClass:"fL"},[_vm._v(_vm._s(option.label))]),_vm._v(" "),_vm.isEmpty(option.secondaryLabel)?_vm._e():_c("span",{staticClass:"select-float-right-text13"},[_vm._v(_vm._s(option.secondaryLabel))])])}))],2),_vm._v(" "),_vm.showQuickCreateData?_c("div",[_vm._v("Testing")]):_vm._e()],1)},__vue_staticRenderFns__$g=[];
/* style */
const __vue_inject_styles__$i=function(inject){inject&&(inject("data-v-4bcf6127_0",{source:".field-loading[data-v-4bcf6127]{height:40px;display:flex;flex:1;border-radius:3px}",map:void 0,media:void 0}),inject("data-v-4bcf6127_1",{source:".search-input-comp .field-icons-visible .el-input__inner{padding-left:15px!important}.f-ui-lookup-container{position:relative}.f-ui-lookup-container .el-icon-arrow-up:before{visibility:hidden}.f-ui-lookup-container .select-icon-visible .el-icon-arrow-up:before{visibility:visible}.f-ui-lookup-container .field-icons-visible .el-input .el-input__prefix{right:5px;left:88%;z-index:10}.f-ui-lookup-container .skip-disable .el-input__inner:disabled{cursor:auto!important;background-color:#fff;color:#324056}.f-ui-lookup-container .lookup-icon{display:flex;position:relative;padding:5px}.f-ui-lookup-container:hover .flookup-remove-icon{display:flex}.f-ui-lookup-container .flookup-remove-icon{display:none}.f-ui-lookup-container .prefix-icon-container{height:100%;align-items:center;justify-content:center;margin:1px 3px}",map:void 0,media:void 0}))},__vue_scope_id__$i="data-v-4bcf6127",__vue_module_identifier__$i=void 0,__vue_is_functional_template__$i=!1,__vue_component__$h=normalizeComponent$5({render:__vue_render__$g,staticRenderFns:__vue_staticRenderFns__$g},__vue_inject_styles__$i,__vue_script__$i,__vue_scope_id__$i,__vue_is_functional_template__$i,__vue_module_identifier__$i,!1,createInjector$2,void 0,void 0);
/* scoped */
var script$h={components:{Select:element_ui_common.Select,Option:element_ui_common.Option},props:["value","options","filterable","multiple","labelName","valueName","disabled","placeholder","allowCreate"],mounted(){this.getProps()},data(){return{props:{},inputValue:""}},watch:{value:{handler(newVal,oldVal){newVal!==oldVal&&(this.inputValue=newVal)},immediate:!0}},computed:{optionsLabelString(){let{labelName:labelName}=this||{};return labelName||"label"},optionsValueString(){let{valueName:valueName}=this||{};return valueName||"value"}},methods:{getProps(){let props=this.$vnode.elm.attributes;Object.keys(props).forEach((key=>{this.$set(this.props,props[key].name,props[key].nodeValue)}))},selectValueChange(value){this.$emit("input",value),this.$emit("change",value)},onClear(){this.$emit("clear")}}};
/* script */const __vue_script__$h=script$h;
/* template */var __vue_render__$f=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"f-ui-forms"},[_c("Select",_vm._b({staticClass:"f-ui-select w-full f-ui-select-tag",attrs:{placeholder:_vm.placeholder||"Select","collapse-tags":"",filterable:_vm.filterable,multiple:_vm.multiple,disabled:_vm.disabled,"allow-create":_vm.allowCreate,"popper-class":"f-ui-select-popper"},on:{change:_vm.selectValueChange,clear:_vm.onClear},model:{value:_vm.inputValue,callback:function($$v){_vm.inputValue=$$v},expression:"inputValue"}},"Select",_vm.props,!1),_vm._l(_vm.options,(function(item){return _c("Option",{key:item[_vm.optionsValueString],staticClass:"f-ui-select-item width100",attrs:{label:item[_vm.optionsLabelString],value:item[_vm.optionsValueString]}})})),1)],1)},__vue_staticRenderFns__$f=[];
/* style */
const __vue_inject_styles__$h=void 0,__vue_scope_id__$h=void 0,__vue_module_identifier__$h=void 0,__vue_is_functional_template__$h=!1,__vue_component__$g=normalizeComponent$5({render:__vue_render__$f,staticRenderFns:__vue_staticRenderFns__$f},__vue_inject_styles__$h,__vue_script__$h,__vue_scope_id__$h,__vue_is_functional_template__$h,__vue_module_identifier__$h,!1,void 0,void 0,void 0);
/* scoped */function _extends$5(){return _extends$5=Object.assign||function(a){for(var b,c=1;c<arguments.length;c++)for(var d in b=arguments[c],b)Object.prototype.hasOwnProperty.call(b,d)&&(a[d]=b[d]);return a},_extends$5.apply(this,arguments)}var normalMerge$1=["attrs","props","domProps"],toArrayMerge$1=["class","style","directives"],functionalMerge$1=["on","nativeOn"],mergeJsxProps$1=function(a){return a.reduce((function(c,a){for(var b in a)if(c[b])if(-1!==normalMerge$1.indexOf(b))c[b]=_extends$5({},c[b],a[b]);else if(-1!==toArrayMerge$1.indexOf(b)){var d=c[b]instanceof Array?c[b]:[c[b]],e=a[b]instanceof Array?a[b]:[a[b]];c[b]=d.concat(e)}else if(-1!==functionalMerge$1.indexOf(b))for(var f in a[b])if(c[b][f]){var g=c[b][f]instanceof Array?c[b][f]:[c[b][f]],h=a[b][f]instanceof Array?a[b][f]:[a[b][f]];c[b][f]=g.concat(h)}else c[b][f]=a[b][f];else if("hook"==b)for(var i in a[b])c[b][i]=c[b][i]?mergeFn$1(c[b][i],a[b][i]):a[b][i];else c[b]=a[b];else c[b]=a[b];return c}),{})},mergeFn$1=function(a,b){return function(){a&&a.apply(this,arguments),b&&b.apply(this,arguments)}},helper$1=mergeJsxProps$1;const isEmpty$4=value=>void 0===value||null===value||-1===Number(value)||"object"===typeof value&&!(value instanceof Blob)&&0===Object.keys(value).length||"string"===typeof value&&0===value.trim().length,isObject$1=obj=>null!==obj&&"object"===typeof obj&&!1===Array.isArray(obj);vue_runtime_esm["default"].component(element_ui_common.Checkbox.name,element_ui_common.Checkbox);const formatDate$1=(date,excludeTime,onlyTime)=>{let dateformat="DD-MMM-YYYY",timeformat="HH:mm";// let orgformatArray = orgformat.match(/DD-MMM-YYYY (HH:mm)/)
return onlyTime?moment_timezone(date).format(timeformat):excludeTime?moment_timezone(date).format(dateformat):moment_timezone(date).format(dateformat+" "+timeformat)},getFormattedDuration$1=(value,format="milliseconds",skipDurationCreation=!1)=>{if(!value)return"00:00 Hrs";let duration;duration=skipDurationCreation?value:moment_timezone.duration(parseInt(value,10),format);let days=parseInt(duration.asDays(),10),hours=duration.hours(),minutes=duration.minutes(),seconds=duration.seconds();return days>0?1===days?hours?`${days} Day ${hours} Hrs`:`${days} Day`:hours?`${days} Days ${hours} Hrs`:`${days} Days`:hours>0?minutes?`${hours} Hrs ${minutes} Mins`:`${hours} Hrs`:minutes>0?seconds?`${minutes} Mins ${seconds} Secs`:`${minutes} Mins`:`${seconds} Secs`},DATA_TYPE_VALUE_HASH$1={LOOKUP(field,data){let{name:fieldName}=field,{primaryValue:primaryValue,name:name,displayName:displayName,subject:subject}=data[fieldName]||{},value=displayName||name||subject;return isEmpty$4(primaryValue)?value:primaryValue},FILE(field,data){let filename=data[`${field.name}FileName`];return filename},DATE(field,data){let{name:name}=field||{},value=data[name];return value&&-1!==value?formatDate$1(value,!0):""},DATE_TIME(field,data){let{name:name}=field||{},value=data[name];return value&&-1!==value?formatDate$1(value):""},ENUM(field,data){let{name:name}=field||{},value=data[name],fieldObj=field.field;return value=value?fieldObj.enumMap[data[fieldObj.name]]:value,value},SYSTEM_ENUM(field,data){let{name:name}=field||{},value=data[name],fieldObj=field.field;return value=value?fieldObj.enumMap[data[fieldObj.name]]:value,value},MULTI_ENUM(field,data){let{name:name,enumMap:enumMap}=field.field||{},values=data[name]||[],valueStr=values.reduce(((accStr,value)=>{let str=enumMap[value]||"";return isEmpty$4(accStr)?`${str}`:`${accStr}, ${str}`}),"");return isEmpty$4(valueStr)?"---":valueStr},BOOLEAN(field,data){let{name:name}=field||{},value=data[name]?field.trueVal||"Yes":field.falseVal||"No";return value},MULTI_LOOKUP(field,data){let{name:name}=field,value=data[name]||[],lookupRecordNames=(value||[]).map((currRecord=>currRecord.displayName||currRecord.name||currRecord.subject));return lookupRecordNames.length>2?`${lookupRecordNames.slice(0,2).join(", ")} +${Math.abs(lookupRecordNames.length-2)}`:isEmpty$4(lookupRecordNames)?"---":`${lookupRecordNames.join(", ")}`},OTHERS(field,data){let{name:name}=field||{};if(!isObject$1(data[name]))return data[name];{let{name:name}=data[name]||{};if(!isEmpty$4(name))return name;data[name]}}},DISPLAY_TYPE_HASH$1={DURATION(field,record){const h=this.$createElement;let{name:name}=field,value=record[name]||[];return h("div",[isEmpty$4(value)||"---"===value?"---":getFormattedDuration$1(value,isEmpty$4(field.unit)?"s":field.unit)])},URL_FIELD(field,record){const h=this.$createElement;let{name:name}=field||{};if(isEmpty$4(record[name]))return"---";{let{name:displayName,href:href,target:target}=record[name]||{},value=isEmpty$4(displayName)?href:displayName;return h(element_ui_common.Tooltip,{attrs:{effect:"dark",content:value,placement:"bottom-start"}},[h("a",{attrs:{rel:"nofollow",referrerpolicy:"no-referrer",href:href,target:target},class:"url-field-display truncate-text"},[h("span",{class:"textoverflow-ellipsis"},[value])])])}},OTHERS(field,record){const h=this.$createElement;return h("div",{class:"truncate-text"},[this.getColumnDisplayValue(field,record)])}};var script$g={props:["viewDetail","records","moduleName","redirectToOverview","columnConfig","slotList","hideListSelect","customButtonList","canShowCustomButton","refreshList","metaInfo"],computed:{viewColumns(){let columns=[],{viewDetail:viewDetail}=this,{fields:viewDetailFields=[]}=viewDetail;isEmpty$4(viewDetail)||isEmpty$4(viewDetailFields)||(columns=viewDetailFields.map((viewField=>{let{field:field,fieldName:fieldName}=viewField||{};field=field||{};let name=field.name||fieldName,fieldId=field.fieldId,defaultColumnName=viewDetail.defaultModuleFields&&viewDetail.defaultModuleFields[viewField.name]?viewDetail.defaultModuleFields[viewField.name].columnDisplayName:null,displayName=viewField.columnDisplayName||defaultColumnName||field.displayName;return viewField={...viewField,name:name,fieldId:fieldId,displayName:displayName},viewField})));let{columnConfig:columnConfig}=this,{fixedSelectableColumns:fixedSelectableColumns}=columnConfig||{};return isEmpty$4(columns)?[]:columns.filter((column=>!(fixedSelectableColumns||[]).includes(column.name)))},customFieldValueSlots(){let{slotList:slotList}=this;return isEmpty$4(slotList)?[]:slotList.filter((slotObj=>!slotObj.isActionColumn))},actionColumnSlots(){let{slotList:slotList}=this;return isEmpty$4(slotList)?[]:slotList.filter((slotObj=>slotObj.isActionColumn))},hardCodedSlots(){let{slotList:slotList}=this;return isEmpty$4(slotList)?[]:slotList.filter((slotObj=>slotObj.isHardcodedColumn))}},methods:{
// field type checks
isDecimalField(field){let{dataTypeEnum:dataTypeEnum}=field.field||{};return field.field&&"DECIMAL"===dataTypeEnum},isFixedColumn(name){let{columnConfig:{fixedColumns:fixedColumns}={}}=this;return(fixedColumns||[]).includes(name)},
// column display related methods
getColumnHeaderLabel(column){let{displayName:displayName,field:field}=column;if(!isEmpty$4(field)&&!isEmpty$4(field.unit)){let{unit:unit}=field;return`${displayName} (${unit})`}return displayName},getColumnDisplayValue(field,record){let value,{parentField:parentField}=field,fieldObj=field.field||field,{dataTypeEnum:dataTypeEnum}=fieldObj||{};// first level lookup value, related handling
if(!isEmpty$4(parentField)){let{name:lookupModuleName}=parentField||{};isEmpty$4(lookupModuleName)||isEmpty$4(record[lookupModuleName])||(record=record[lookupModuleName])}return isEmpty$4(DATA_TYPE_VALUE_HASH$1[dataTypeEnum])?value=DATA_TYPE_VALUE_HASH$1["OTHERS"](field,record,this):(dataTypeEnum=dataTypeEnum||dataTypeEnum._name,value=DATA_TYPE_VALUE_HASH$1[dataTypeEnum](field,record,this)),isEmpty$4(value)?"---":value},getColumnDisplayComponent(field,record){let fieldObj=field.field||field,{displayType:displayType}=fieldObj||{},{criteriaCheckForSlot:criteriaCheckForSlot}=this||{},{canRenderSlot:canRenderSlot,slotName:slotName}=criteriaCheckForSlot(field);return canRenderSlot&&!isEmpty$4(this.$scopedSlots[slotName])?this.$scopedSlots[slotName]({record:record}):isEmpty$4(this[displayType])?this["OTHERS"](field,record,this.getColumnDisplayValue):this[displayType](field,record,this.getColumnDisplayValue)},criteriaCheckForSlot(field){let{customFieldValueSlots:customFieldValueSlots}=this,canRenderSlot=!0,slotName="",fieldObj=field.field||field;if(!isEmpty$4(customFieldValueSlots))for(let currSlot of customFieldValueSlots){let{criteria:criteria}=currSlot||{};if(!isEmpty$4(criteria)){let slotCriteria=JSON.parse(criteria);if(isObject$1(slotCriteria)&&Object.keys(slotCriteria).forEach((fieldName=>{canRenderSlot=fieldObj[fieldName]===slotCriteria[fieldName]})),canRenderSlot){slotName=criteria;break}}}return{canRenderSlot:canRenderSlot,slotName:slotName}},
// redirects and event emiters
selectionChange(selected){this.$emit("selection-change",selected)},toggleVisibility(id,val){let{$el:$el}=this.$refs[`custom-btn-${id}`]||{},{classList:classList}=$el||{};val?classList.remove("visibility-hide-actions"):classList.add("visibility-hide-actions")},toggleRowSelection(item,val){let{moduleName:moduleName}=this||{},ref=this.$refs[`${moduleName}-list`];ref.toggleRowSelection(item,val)},clearSelection(){let{moduleName:moduleName}=this||{},ref=this.$refs[`${moduleName}-list`];ref.clearSelection()},
// display type hash
...DISPLAY_TYPE_HASH$1},render(){const h=arguments[0];return h(element_ui_common.Table,{attrs:{data:this.records,height:"100%",fit:!0,"row-class-name":"no-hover"},ref:`${this.moduleName}-list`,style:"width: 100%;",class:"table-border",on:{"selection-change":this.selectionChange}},[!this.hideListSelect&&h(element_ui_common.TableColumn,{attrs:{fixed:!0,align:"left",type:"selection",width:"60"}}),this.hardCodedSlots.map(((slotObj,index)=>h(element_ui_common.TableColumn,helper$1([{key:`${slotObj.name}-${index}`},{scopedSlots:{default:data=>this.$scopedSlots[slotObj.name]({record:data.row})}},{attrs:{...slotObj.columnAttrs||{}}}])))),this.viewColumns.map(((field,index)=>h(element_ui_common.TableColumn,helper$1([{attrs:{fixed:this.isFixedColumn(field.name),prop:field.name,label:this.getColumnHeaderLabel(field),align:this.isDecimalField(field)?"right":"left","min-width":"230"},key:index},{scopedSlots:{default:data=>this.getColumnDisplayComponent(field,data.row)}},{attrs:{...field.columnAttrs||{}}}])))),this.actionColumnSlots.map(((slotObj,index)=>h(element_ui_common.TableColumn,helper$1([{key:`${slotObj.name}-${index}`},{scopedSlots:{default:data=>this.$scopedSlots[slotObj.name]({record:data.row})}},{attrs:{...slotObj.columnAttrs||{}}}]))))])}};
/* script */const __vue_script__$g=script$g,__vue_inject_styles__$g=function(inject){inject&&inject("data-v-64fad4c9_0",{source:".url-field-display[data-v-64fad4c9]{color:#46a2bf}.url-field-display[data-v-64fad4c9]:hover{text-decoration:underline;text-underline-offset:3px;color:#46a2bf}",map:void 0,media:void 0})},__vue_scope_id__$g="data-v-64fad4c9",__vue_module_identifier__$g=void 0,__vue_is_functional_template__$g=void 0,__vue_component__$f=normalizeComponent$5({},__vue_inject_styles__$g,__vue_script__$g,__vue_scope_id__$g,__vue_is_functional_template__$g,__vue_module_identifier__$g,!1,createInjector$2,void 0,void 0);
/* template */
/* style */
var script$f={props:["currentPage","perPage","total","hideToggle"],data(){return{from:0,to:0,page:1}},mounted(){this.init()},watch:{total(){this.init()},currentPage(val){val!==this.page&&this.init()}},methods:{init(){this.page=this.currentPage||1,this.from=(this.page-1)*this.perPage+1;let to=this.from+this.perPage-1;this.to=this.total>to?to:this.total},next(){this.from=this.to+1,this.to+=this.perPage,this.to>this.total&&(this.to=this.total),this.page++,// Update currentPage value
this.$emit("update:currentPage",this.page)},prev(){this.to=this.from-1,this.from-=this.perPage,this.from<=1?this.from=this.page=1:this.page--,// Update currentPage value
this.$emit("update:currentPage",this.page)}}};
/* script */const __vue_script__$f=script$f;
/* template */var __vue_render__$e=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _vm.total>0?_c("div",{staticClass:"f-ui-widget-pagination"},[_vm.from!==_vm.to?_c("span",[_vm._v(_vm._s(_vm.from)+" -")]):_vm._e(),_vm._v(" "),_c("span",[_vm._v(_vm._s(_vm.to))]),_vm._v(" "),_vm.hideToggle?_vm._e():[_c("span",{staticClass:"pl-1 pr-3"},[_vm._v("of "+_vm._s(_vm.total))]),_vm._v(" "),_c("span",{staticClass:"el-icon-arrow-left arrow-icons cursor-pointer",class:{disable:_vm.from<=1},on:{click:function($event){_vm.from>1&&_vm.prev()}}}),_vm._v(" "),_c("span",{staticClass:"el-icon-arrow-right arrow-icons cursor-pointer",class:{disable:_vm.to===_vm.total},on:{click:function($event){_vm.to!==_vm.total&&_vm.next()}}})]],2):_vm._e()},__vue_staticRenderFns__$e=[];
/* style */
const __vue_inject_styles__$f=function(inject){inject&&inject("data-v-dec3861c_0",{source:".f-ui-widget-pagination{display:flex;align-items:center;font-size:12px;font-weight:500;font-style:normal;letter-spacing:1px;color:#50506c}.f-ui-widget-pagination .arrow-icons{font-size:15px}.f-ui-widget-pagination .disable{opacity:.5;cursor:not-allowed}.f-ui-widget-pagination .el-icon-arrow-left{padding:4px 3px;border-radius:4px;border:1px solid transparent}.f-ui-widget-pagination .el-icon-arrow-left:hover{color:#615e88;background:#f5f6f8;border:1px solid #dae0e8}.f-ui-widget-pagination .el-icon-arrow-right{padding:4px 3px;border-radius:4px;border:1px solid transparent}.f-ui-widget-pagination .el-icon-arrow-right:hover{color:#615e88;background:#f5f6f8;border:1px solid #dae0e8}",map:void 0,media:void 0})},__vue_scope_id__$f=void 0,__vue_module_identifier__$f=void 0,__vue_is_functional_template__$f=!1,__vue_component__$e=normalizeComponent$5({render:__vue_render__$e,staticRenderFns:__vue_staticRenderFns__$e},__vue_inject_styles__$f,__vue_script__$f,__vue_scope_id__$f,__vue_is_functional_template__$f,__vue_module_identifier__$f,!1,createInjector$2,void 0,void 0);
/* scoped */
var script$d={name:"spinner",props:["show","size","colour"],computed:{spinnerSize(){return this.size?this.size+"px":"50px"},strokeColor(){return this.colour?this.colour:"#fd4b92"}}};
/* script */const __vue_script__$d=script$d;
/* template */var __vue_render__$c=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("transition",[_c("svg",{directives:[{name:"show",rawName:"v-show",value:_vm.show,expression:"show"}],staticClass:"spinner",class:{show:_vm.show},attrs:{width:_vm.spinnerSize,height:_vm.spinnerSize,viewBox:"0 0 44 44"}},[_c("circle",{staticClass:"path",style:{stroke:_vm.strokeColor},attrs:{fill:"none","stroke-width":"4","stroke-linecap":"round",cx:"22",cy:"22",r:"20"}})])])},__vue_staticRenderFns__$c=[];
/* style */
const __vue_inject_styles__$d=function(inject){inject&&inject("data-v-3994ea33_0",{source:".spinner[data-v-3994ea33]{transition:opacity .15s ease;animation:rotator-data-v-3994ea33 1.4s linear infinite;animation-play-state:paused}.spinner.show[data-v-3994ea33]{animation-play-state:running}.spinner.v-enter[data-v-3994ea33],.spinner.v-leave-active[data-v-3994ea33]{opacity:0}.spinner.v-enter-active[data-v-3994ea33],.spinner.v-leave[data-v-3994ea33]{opacity:1}.spinner .path[data-v-3994ea33]{stroke-dasharray:126;stroke-dashoffset:0;transform-origin:center;animation:dash-data-v-3994ea33 1.4s ease-in-out infinite}@-moz-keyframes rotator-data-v-3994ea33{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-webkit-keyframes rotator-data-v-3994ea33{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-o-keyframes rotator-data-v-3994ea33{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@keyframes rotator-data-v-3994ea33{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-moz-keyframes dash-data-v-3994ea33{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@-webkit-keyframes dash-data-v-3994ea33{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@-o-keyframes dash-data-v-3994ea33{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@keyframes dash-data-v-3994ea33{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}",map:void 0,media:void 0})},__vue_scope_id__$d="data-v-3994ea33",__vue_module_identifier__$d=void 0,__vue_is_functional_template__$d=!1,__vue_component__$c=normalizeComponent$5({render:__vue_render__$c,staticRenderFns:__vue_staticRenderFns__$c},__vue_inject_styles__$d,__vue_script__$d,__vue_scope_id__$d,__vue_is_functional_template__$d,__vue_module_identifier__$d,!1,createInjector$2,void 0,void 0),NAMESPACE$1="facicons-ui";
/* scoped */let scopeId$1,hostTagName$1,isSvgMode$1=!1,queuePending$1=!1;const win$1="undefined"!==typeof window?window:{},doc$4=win$1.document||{head:{}},plt$1={$flags$:0,$resourcesUrl$:"",jmp:h=>h(),raf:h=>requestAnimationFrame(h),ael:(el,eventName,listener,opts)=>el.addEventListener(eventName,listener,opts),rel:(el,eventName,listener,opts)=>el.removeEventListener(eventName,listener,opts),ce:(eventName,opts)=>new CustomEvent(eventName,opts)},promiseResolve$1=v=>Promise.resolve(v),supportsConstructibleStylesheets$1=(()=>{try{return new CSSStyleSheet,"function"===typeof(new CSSStyleSheet).replace}catch(e){}return!1})(),HYDRATED_CSS$1="{visibility:hidden}.hydrated{visibility:inherit}",createTime$1=(fnName,tagName="")=>()=>{},uniqueTime$1=(key,measureText)=>()=>{},rootAppliedStyles$1=new WeakMap,registerStyle$1=(scopeId,cssText,allowCS)=>{let style=styles$3.get(scopeId);supportsConstructibleStylesheets$1&&allowCS?(style=style||new CSSStyleSheet,style.replace(cssText)):style=cssText,styles$3.set(scopeId,style)},addStyle$3=(styleContainerNode,cmpMeta,mode,hostElm)=>{let scopeId=getScopeId$1(cmpMeta);const style=styles$3.get(scopeId);// if an element is NOT connected then getRootNode() will return the wrong root node
// so the fallback is to always use the document for the root node in those cases
if(styleContainerNode=11
/* DocumentFragment */===styleContainerNode.nodeType?styleContainerNode:doc$4,style)if("string"===typeof style){styleContainerNode=styleContainerNode.head||styleContainerNode;let styleElm,appliedStyles=rootAppliedStyles$1.get(styleContainerNode);appliedStyles||rootAppliedStyles$1.set(styleContainerNode,appliedStyles=new Set),appliedStyles.has(scopeId)||(styleElm=doc$4.createElement("style"),styleElm.innerHTML=style,styleContainerNode.insertBefore(styleElm,styleContainerNode.querySelector("link")),appliedStyles&&appliedStyles.add(scopeId))}else styleContainerNode.adoptedStyleSheets.includes(style)||(styleContainerNode.adoptedStyleSheets=[...styleContainerNode.adoptedStyleSheets,style]);return scopeId},attachStyles$1=hostRef=>{const cmpMeta=hostRef.$cmpMeta$,elm=hostRef.$hostElement$,flags=cmpMeta.$flags$,endAttachStyles=createTime$1("attachStyles",cmpMeta.$tagName$),scopeId=addStyle$3(elm.shadowRoot?elm.shadowRoot:elm.getRootNode(),cmpMeta);10
/* needsScopedEncapsulation */&flags&&(
// only required when we're NOT using native shadow dom (slot)
// or this browser doesn't support native shadow dom
// and this host element was NOT created with SSR
// let's pick out the inner content for slot projection
// create a node to represent where the original
// content was first placed, which is useful later on
// DOM WRITE!!
elm["s-sc"]=scopeId,elm.classList.add(scopeId+"-h")),endAttachStyles()},getScopeId$1=(cmp,mode)=>"sc-"+cmp.$tagName$
/**
 * Default style mode id
 */
/**
 * Reusable empty obj/array
 * Don't add values to these!!
 */,EMPTY_OBJ$1={},isDef$1=v=>null!=v,isComplexType$1=o=>(
// https://jsperf.com/typeof-fn-object/5
o=typeof o,"object"===o||"function"===o),h$1=(nodeName,vnodeData,...children)=>{let child=null,simple=!1,lastSimple=!1;const vNodeChildren=[],walk=c=>{for(let i=0;i<c.length;i++)child=c[i],Array.isArray(child)?walk(child):null!=child&&"boolean"!==typeof child&&((simple="function"!==typeof nodeName&&!isComplexType$1(child))&&(child=String(child)),simple&&lastSimple?
// If the previous child was simple (string), we merge both
vNodeChildren[vNodeChildren.length-1].$text$+=child:
// Append a new vNode, if it's text, we create a text vNode
vNodeChildren.push(simple?newVNode$1(null,child):child),lastSimple=simple)};if(walk(children),vnodeData){const classData=vnodeData.className||vnodeData.class;classData&&(vnodeData.class="object"!==typeof classData?classData:Object.keys(classData).filter((k=>classData[k])).join(" "))}const vnode=newVNode$1(nodeName,null);return vnode.$attrs$=vnodeData,vNodeChildren.length>0&&(vnode.$children$=vNodeChildren),vnode},newVNode$1=(tag,text)=>{const vnode={$flags$:0,$tag$:tag,$text$:text,$elm$:null,$children$:null,$attrs$:null};return vnode},Host$1={},isHost$1=node=>node&&node.$tag$===Host$1
/**
 * Production setAccessor() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */,setAccessor$1=(elm,memberName,oldValue,newValue,isSvg,flags)=>{if(oldValue!==newValue){let isProp=isMemberInElement$1(elm,memberName);if(memberName.toLowerCase(),"class"===memberName){const classList=elm.classList,oldClasses=parseClassList$1(oldValue),newClasses=parseClassList$1(newValue);classList.remove(...oldClasses.filter((c=>c&&!newClasses.includes(c)))),classList.add(...newClasses.filter((c=>c&&!oldClasses.includes(c))))}else{
// Set property if it exists and it's not a SVG
const isComplex=isComplexType$1(newValue);if((isProp||isComplex&&null!==newValue)&&!isSvg)try{if(elm.tagName.includes("-"))elm[memberName]=newValue;else{const n=null==newValue?"":newValue;// Workaround for Safari, moving the <input> caret when re-assigning the same valued
"list"===memberName?isProp=!1:null!=oldValue&&elm[memberName]==n||(elm[memberName]=n)}}catch(e){}null==newValue||!1===newValue?!1===newValue&&""!==elm.getAttribute(memberName)||elm.removeAttribute(memberName):(!isProp||4
/* isHost */&flags||isSvg)&&!isComplex&&(newValue=!0===newValue?"":newValue,elm.setAttribute(memberName,newValue))}}},parseClassListRegex$1=/\s/,parseClassList$1=value=>value?value.split(parseClassListRegex$1):[],updateElement$1=(oldVnode,newVnode,isSvgMode,memberName)=>{
// if the element passed in is a shadow root, which is a document fragment
// then we want to be adding attrs/props to the shadow root's "host" element
// if it's not a shadow root, then we add attrs/props to the same element
const elm=11
/* DocumentFragment */===newVnode.$elm$.nodeType&&newVnode.$elm$.host?newVnode.$elm$.host:newVnode.$elm$,oldVnodeAttrs=oldVnode&&oldVnode.$attrs$||EMPTY_OBJ$1,newVnodeAttrs=newVnode.$attrs$||EMPTY_OBJ$1;
// remove attributes no longer present on the vnode by setting them to undefined
for(memberName in oldVnodeAttrs)memberName in newVnodeAttrs||setAccessor$1(elm,memberName,oldVnodeAttrs[memberName],void 0,isSvgMode,newVnode.$flags$);// add new & update changed attributes
for(memberName in newVnodeAttrs)setAccessor$1(elm,memberName,oldVnodeAttrs[memberName],newVnodeAttrs[memberName],isSvgMode,newVnode.$flags$)},createElm$1=(oldParentVNode,newParentVNode,childIndex,parentElm)=>{
// tslint:disable-next-line: prefer-const
const newVNode=newParentVNode.$children$[childIndex];let elm,childNode,i=0;if(
// create element
elm=newVNode.$elm$=doc$4.createElement(newVNode.$tag$),updateElement$1(null,newVNode,isSvgMode$1),isDef$1(scopeId$1)&&elm["s-si"]!==scopeId$1&&
// if there is a scopeId and this is the initial render
// then let's add the scopeId as a css class
elm.classList.add(elm["s-si"]=scopeId$1),newVNode.$children$)for(i=0;i<newVNode.$children$.length;++i)
// create the node
childNode=createElm$1(oldParentVNode,newVNode,i),// return node could have been null
childNode&&
// append our new node
elm.appendChild(childNode);return elm},addVnodes$1=(parentElm,before,parentVNode,vnodes,startIdx,endIdx)=>{let childNode,containerElm=parentElm;for(containerElm.shadowRoot&&containerElm.tagName===hostTagName$1&&(containerElm=containerElm.shadowRoot);startIdx<=endIdx;++startIdx)vnodes[startIdx]&&(childNode=createElm$1(null,parentVNode,startIdx),childNode&&(vnodes[startIdx].$elm$=childNode,containerElm.insertBefore(childNode,before)))},removeVnodes$1=(vnodes,startIdx,endIdx,vnode,elm)=>{for(;startIdx<=endIdx;++startIdx)(vnode=vnodes[startIdx])&&(elm=vnode.$elm$,// remove the vnode's element from the dom
elm.remove())},updateChildren$1=(parentElm,oldCh,newVNode,newCh)=>{let node,oldStartIdx=0,newStartIdx=0,oldEndIdx=oldCh.length-1,oldStartVnode=oldCh[0],oldEndVnode=oldCh[oldEndIdx],newEndIdx=newCh.length-1,newStartVnode=newCh[0],newEndVnode=newCh[newEndIdx];while(oldStartIdx<=oldEndIdx&&newStartIdx<=newEndIdx)null==oldStartVnode?
// Vnode might have been moved left
oldStartVnode=oldCh[++oldStartIdx]:null==oldEndVnode?oldEndVnode=oldCh[--oldEndIdx]:null==newStartVnode?newStartVnode=newCh[++newStartIdx]:null==newEndVnode?newEndVnode=newCh[--newEndIdx]:isSameVnode$1(oldStartVnode,newStartVnode)?(patch$1(oldStartVnode,newStartVnode),oldStartVnode=oldCh[++oldStartIdx],newStartVnode=newCh[++newStartIdx]):isSameVnode$1(oldEndVnode,newEndVnode)?(patch$1(oldEndVnode,newEndVnode),oldEndVnode=oldCh[--oldEndIdx],newEndVnode=newCh[--newEndIdx]):isSameVnode$1(oldStartVnode,newEndVnode)?(patch$1(oldStartVnode,newEndVnode),parentElm.insertBefore(oldStartVnode.$elm$,oldEndVnode.$elm$.nextSibling),oldStartVnode=oldCh[++oldStartIdx],newEndVnode=newCh[--newEndIdx]):isSameVnode$1(oldEndVnode,newStartVnode)?(patch$1(oldEndVnode,newStartVnode),parentElm.insertBefore(oldEndVnode.$elm$,oldStartVnode.$elm$),oldEndVnode=oldCh[--oldEndIdx],newStartVnode=newCh[++newStartIdx]):(
// new element
node=createElm$1(oldCh&&oldCh[newStartIdx],newVNode,newStartIdx),newStartVnode=newCh[++newStartIdx],node&&oldStartVnode.$elm$.parentNode.insertBefore(node,oldStartVnode.$elm$));oldStartIdx>oldEndIdx?addVnodes$1(parentElm,null==newCh[newEndIdx+1]?null:newCh[newEndIdx+1].$elm$,newVNode,newCh,newStartIdx,newEndIdx):newStartIdx>newEndIdx&&removeVnodes$1(oldCh,oldStartIdx,oldEndIdx)},isSameVnode$1=(vnode1,vnode2)=>vnode1.$tag$===vnode2.$tag$,patch$1=(oldVNode,newVNode)=>{const elm=newVNode.$elm$=oldVNode.$elm$,oldChildren=oldVNode.$children$,newChildren=newVNode.$children$;
// either this is the first render of an element OR it's an update
// AND we already know it's possible it could have changed
// this updates the element's css classes, attrs, props, listeners, etc.
updateElement$1(oldVNode,newVNode,isSvgMode$1),null!==oldChildren&&null!==newChildren?
// looks like there's child vnodes for both the old and new vnodes
updateChildren$1(elm,oldChildren,newVNode,newChildren):null!==newChildren?
// add the new vnode children
addVnodes$1(elm,null,newVNode,newChildren,0,newChildren.length-1):null!==oldChildren&&
// no new child vnodes, but there are old child vnodes to remove
removeVnodes$1(oldChildren,0,oldChildren.length-1)},renderVdom$1=(hostRef,renderFnResults)=>{const hostElm=hostRef.$hostElement$,oldVNode=hostRef.$vnode$||newVNode$1(null,null),rootVnode=isHost$1(renderFnResults)?renderFnResults:h$1(null,null,renderFnResults);hostTagName$1=hostElm.tagName,rootVnode.$tag$=null,rootVnode.$flags$|=4
/* isHost */,hostRef.$vnode$=rootVnode,rootVnode.$elm$=oldVNode.$elm$=hostElm.shadowRoot||hostElm,scopeId$1=hostElm["s-sc"],// synchronous patch
patch$1(oldVNode,rootVnode)},emitEvent$1=(elm,name,opts)=>{const ev=plt$1.ce(name,opts);return elm.dispatchEvent(ev),ev},attachToAncestor$1=(hostRef,ancestorComponent)=>{ancestorComponent&&!hostRef.$onRenderResolve$&&ancestorComponent["s-p"]&&ancestorComponent["s-p"].push(new Promise((r=>hostRef.$onRenderResolve$=r)))},scheduleUpdate$1=(hostRef,isInitialLoad)=>{if(hostRef.$flags$|=16
/* isQueuedForUpdate */,4
/* isWaitingForChildren */&hostRef.$flags$)return void(hostRef.$flags$|=512
/* needsRerender */);attachToAncestor$1(hostRef,hostRef.$ancestorComponent$);// there is no ancestor component or the ancestor component
// has already fired off its lifecycle update then
// fire off the initial update
const dispatch=()=>dispatchHooks$1(hostRef,isInitialLoad);return writeTask$1(dispatch)},dispatchHooks$1=(hostRef,isInitialLoad)=>{const endSchedule=createTime$1("scheduleUpdate",hostRef.$cmpMeta$.$tagName$),instance=hostRef.$lazyInstance$;let promise;return isInitialLoad&&(promise=safeCall$1(instance,"componentWillLoad")),endSchedule(),then$1(promise,(()=>updateComponent$1(hostRef,instance,isInitialLoad)))},updateComponent$1=async(hostRef,instance,isInitialLoad)=>{
// updateComponent
const elm=hostRef.$hostElement$,endUpdate=createTime$1("update",hostRef.$cmpMeta$.$tagName$),rc=elm["s-rc"];isInitialLoad&&
// DOM WRITE!
attachStyles$1(hostRef);const endRender=createTime$1("render",hostRef.$cmpMeta$.$tagName$);callRender$1(hostRef,instance),rc&&(
// ok, so turns out there are some child host elements
// waiting on this parent element to load
// let's fire off all update callbacks waiting
rc.map((cb=>cb())),elm["s-rc"]=void 0),endRender(),endUpdate();{const childrenPromises=elm["s-p"],postUpdate=()=>postUpdateComponent$1(hostRef);0===childrenPromises.length?postUpdate():(Promise.all(childrenPromises).then(postUpdate),hostRef.$flags$|=4
/* isWaitingForChildren */,childrenPromises.length=0)}},callRender$1=(hostRef,instance,elm)=>{try{instance=instance.render(),hostRef.$flags$&=-17
/* isQueuedForUpdate */,hostRef.$flags$|=2
/* hasRendered */,renderVdom$1(hostRef,instance)}catch(e){consoleError$1(e,hostRef.$hostElement$)}return null},postUpdateComponent$1=hostRef=>{const tagName=hostRef.$cmpMeta$.$tagName$,elm=hostRef.$hostElement$,endPostUpdate=createTime$1("postUpdate",tagName),ancestorComponent=hostRef.$ancestorComponent$;64
/* hasLoadedComponent */&hostRef.$flags$?endPostUpdate():(hostRef.$flags$|=64
/* hasLoadedComponent */,
// DOM WRITE!
addHydratedFlag$1(elm),endPostUpdate(),hostRef.$onReadyResolve$(elm),ancestorComponent||appDidLoad$1()),hostRef.$onRenderResolve$&&(hostRef.$onRenderResolve$(),hostRef.$onRenderResolve$=void 0),512
/* needsRerender */&hostRef.$flags$&&nextTick$1((()=>scheduleUpdate$1(hostRef,!1))),hostRef.$flags$&=-517
/* needsRerender */;// load events fire from bottom to top
// the deepest elements load first then bubbles up
}// ( •_•)
// ( •_•)>⌐■-■
// (⌐■_■)
,appDidLoad$1=who=>{addHydratedFlag$1(doc$4.documentElement),nextTick$1((()=>emitEvent$1(win$1,"appload",{detail:{namespace:NAMESPACE$1}})))},safeCall$1=(instance,method,arg)=>{if(instance&&instance[method])try{return instance[method](arg)}catch(e){consoleError$1(e)}},then$1=(promise,thenFn)=>promise&&promise.then?promise.then(thenFn):thenFn(),addHydratedFlag$1=elm=>elm.classList.add("hydrated")
/**
 * Parse a new property value for a given property type.
 *
 * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,
 * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:
 *   1. `any`, the type given to `propValue` in the function signature
 *   2. the type stored from `propType`.
 *
 * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.
 *
 * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to
 * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is
 * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.
 * ```tsx
 * <my-cmp prop-val={0}></my-cmp>
 * ```
 *
 * HTML prop values on the other hand, will always a string
 *
 * @param propValue the new value to coerce to some type
 * @param propType the type of the prop, expressed as a binary number
 * @returns the parsed/coerced value
 */,parsePropertyValue$1=(propValue,propType)=>
// ensure this value is of the correct prop type
null==propValue||isComplexType$1(propValue)?propValue:1
/* String */&propType?String(propValue):propValue,getValue$3=(ref,propName)=>getHostRef$1(ref).$instanceValues$.get(propName),setValue$1=(ref,propName,newVal,cmpMeta)=>{
// check our new property value against our internal value
const hostRef=getHostRef$1(ref),elm=hostRef.$hostElement$,oldVal=hostRef.$instanceValues$.get(propName),flags=hostRef.$flags$,instance=hostRef.$lazyInstance$;newVal=parsePropertyValue$1(newVal,cmpMeta.$members$[propName][0]);// explicitly check for NaN on both sides, as `NaN === NaN` is always false
const areBothNaN=Number.isNaN(oldVal)&&Number.isNaN(newVal),didValueChange=newVal!==oldVal&&!areBothNaN;if((!(8
/* isConstructingInstance */&flags)||void 0===oldVal)&&didValueChange&&(
// gadzooks! the property's value has changed!!
// set our new value!
hostRef.$instanceValues$.set(propName,newVal),instance)){
// get an array of method names of watch functions to call
if(cmpMeta.$watchers$&&128
/* isWatchReady */&flags){const watchMethods=cmpMeta.$watchers$[propName];watchMethods&&
// this instance is watching for when this property changed
watchMethods.map((watchMethodName=>{try{
// fire off each of the watch methods that are watching this property
instance[watchMethodName](newVal,oldVal,propName)}catch(e){consoleError$1(e,elm)}}))}2
/* hasRendered */===(18
/* isQueuedForUpdate */&flags)&&
// looks like this value actually changed, so we've got work to do!
// but only if we've already rendered, otherwise just chill out
// queue that we need to do an update, but don't worry about queuing
// up millions cuz this function ensures it only runs once
scheduleUpdate$1(hostRef,!1)}},proxyComponent$1=(Cstr,cmpMeta,flags)=>{if(cmpMeta.$members$){Cstr.watchers&&(cmpMeta.$watchers$=Cstr.watchers);// It's better to have a const than two Object.entries()
const members=Object.entries(cmpMeta.$members$),prototype=Cstr.prototype;if(members.map((([memberName,[memberFlags]])=>{(31
/* Prop */&memberFlags||2
/* proxyState */&flags&&32
/* State */&memberFlags)&&
// proxyComponent - prop
Object.defineProperty(prototype,memberName,{get(){
// proxyComponent, get value
return getValue$3(this,memberName)},set(newValue){
// proxyComponent, set value
setValue$1(this,memberName,newValue,cmpMeta)},configurable:!0,enumerable:!0})})),1
/* isElementConstructor */&flags){const attrNameToPropName=new Map;prototype.attributeChangedCallback=function(attrName,_oldValue,newValue){plt$1.jmp((()=>{const propName=attrNameToPropName.get(attrName);//  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback
//  in the case where an attribute was set inline.
//  ```html
//    <my-component some-attribute="some-value"></my-component>
//  ```

//  There is an edge case where a developer sets the attribute inline on a custom element and then
//  programmatically changes it before it has been upgraded as shown below:

//  ```html
//    <!-- this component has _not_ been upgraded yet -->
//    <my-component id="test" some-attribute="some-value"></my-component>
//    <script>
//      // grab non-upgraded component
//      el = document.querySelector("#test");
//      el.someAttribute = "another-value";
//      // upgrade component
//      customElements.define('my-component', MyComponent);
//    <\/script>
//  ```
//  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback
//  will be called with `newValue = "some-value"` and will set the shadowed property (this.someAttribute = "another-value")
//  to the value that was set inline i.e. "some-value" from above example. When
//  the connectedCallback attempts to unshadow it will use "some-value" as the initial value rather than "another-value"

//  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed
//  by connectedCallback as this attributeChangedCallback will not fire.

//  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties

//  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to
//  properties here given that this goes against best practices outlined here
//  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy
if(this.hasOwnProperty(propName))newValue=this[propName],delete this[propName];else if(prototype.hasOwnProperty(propName)&&"number"===typeof this[propName]&&this[propName]==newValue)
// if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native
// APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in
// `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.
return;this[propName]=(null!==newValue||"boolean"!==typeof this[propName])&&newValue}))},// create an array of attributes to observe
// and also create a map of html attribute name to js property name
Cstr.observedAttributes=members.filter((([_,m])=>15
/* HasAttribute */&m[0]// filter to only keep props that should match attributes
)).map((([propName,m])=>{const attrName=m[1]||propName;return attrNameToPropName.set(attrName,propName),attrName}))}}return Cstr},initializeComponent$1=async(elm,hostRef,cmpMeta,hmrVersionId,Cstr)=>{
// initializeComponent
if(0===(32
/* hasInitializedComponent */&hostRef.$flags$)){{if(
// we haven't initialized this element yet
hostRef.$flags$|=32
/* hasInitializedComponent */,// lazy loaded components
// request the component's implementation to be
// wired up with the host element
Cstr=loadModule$1(cmpMeta),Cstr.then){
// Await creates a micro-task avoid if possible
const endLoad=uniqueTime$1();Cstr=await Cstr,endLoad()}Cstr.isProxied||(cmpMeta.$watchers$=Cstr.watchers,proxyComponent$1(Cstr,cmpMeta,2
/* proxyState */),Cstr.isProxied=!0);const endNewInstance=createTime$1("createInstance",cmpMeta.$tagName$);// ok, time to construct the instance
// but let's keep track of when we start and stop
// so that the getters/setters don't incorrectly step on data
hostRef.$flags$|=8
/* isConstructingInstance */;// construct the lazy-loaded component implementation
// passing the hostRef is very important during
// construction in order to directly wire together the
// host element and the lazy-loaded instance
try{new Cstr(hostRef)}catch(e){consoleError$1(e)}hostRef.$flags$&=-9
/* isConstructingInstance */,hostRef.$flags$|=128
/* isWatchReady */,endNewInstance()}if(Cstr.style){
// this component has styles but we haven't registered them yet
let style=Cstr.style;const scopeId=getScopeId$1(cmpMeta);if(!styles$3.has(scopeId)){const endRegisterStyles=createTime$1("registerStyles",cmpMeta.$tagName$);registerStyle$1(scopeId,style,!!(1
/* shadowDomEncapsulation */&cmpMeta.$flags$)),endRegisterStyles()}}}// we've successfully created a lazy instance
const ancestorComponent=hostRef.$ancestorComponent$,schedule=()=>scheduleUpdate$1(hostRef,!0);ancestorComponent&&ancestorComponent["s-rc"]?
// this is the initial load and this component it has an ancestor component
// but the ancestor component has NOT fired its will update lifecycle yet
// so let's just cool our jets and wait for the ancestor to continue first
// this will get fired off when the ancestor component
// finally gets around to rendering its lazy self
// fire off the initial update
ancestorComponent["s-rc"].push(schedule):schedule()},connectedCallback$1=elm=>{if(0===(1
/* isTmpDisconnected */&plt$1.$flags$)){const hostRef=getHostRef$1(elm),cmpMeta=hostRef.$cmpMeta$,endConnected=createTime$1("connectedCallback",cmpMeta.$tagName$);if(!(1
/* hasConnected */&hostRef.$flags$)){
// first time this component has connected
hostRef.$flags$|=1
/* hasConnected */;{
// find the first ancestor component (if there is one) and register
// this component as one of the actively loading child components for its ancestor
let ancestorComponent=elm;while(ancestorComponent=ancestorComponent.parentNode||ancestorComponent.host)
// climb up the ancestors looking for the first
// component that hasn't finished its lifecycle update yet
if(ancestorComponent["s-p"]){
// we found this components first ancestor component
// keep a reference to this component's ancestor component
attachToAncestor$1(hostRef,hostRef.$ancestorComponent$=ancestorComponent);break}}// Lazy properties
// https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
cmpMeta.$members$&&Object.entries(cmpMeta.$members$).map((([memberName,[memberFlags]])=>{if(31
/* Prop */&memberFlags&&elm.hasOwnProperty(memberName)){const value=elm[memberName];delete elm[memberName],elm[memberName]=value}})),initializeComponent$1(elm,hostRef,cmpMeta)}endConnected()}},disconnectedCallback$1=elm=>{0===(1
/* isTmpDisconnected */&plt$1.$flags$)&&getHostRef$1(elm)},bootstrapLazy$1=(lazyBundles,options={})=>{const endBootstrap=createTime$1(),cmpTags=[],exclude=options.exclude||[],customElements=win$1.customElements,head=doc$4.head,metaCharset=head.querySelector("meta[charset]"),visibilityStyle=doc$4.createElement("style"),deferredConnectedCallbacks=[];let appLoadFallback,isBootstrapping=!0;Object.assign(plt$1,options),plt$1.$resourcesUrl$=new URL(options.resourcesUrl||"./",doc$4.baseURI).href,lazyBundles.map((lazyBundle=>{lazyBundle[1].map((compactMeta=>{const cmpMeta={$flags$:compactMeta[0],$tagName$:compactMeta[1],$members$:compactMeta[2],$listeners$:compactMeta[3]};cmpMeta.$members$=compactMeta[2],cmpMeta.$watchers$={};const tagName=cmpMeta.$tagName$,HostElement=class extends HTMLElement{
// StencilLazyHost
constructor(self){
// @ts-ignore
super(self),self=this,registerHost$1(self,cmpMeta),1
/* shadowDomEncapsulation */&cmpMeta.$flags$&&self.attachShadow({mode:"open"})}connectedCallback(){appLoadFallback&&(clearTimeout(appLoadFallback),appLoadFallback=null),isBootstrapping?
// connectedCallback will be processed once all components have been registered
deferredConnectedCallbacks.push(this):plt$1.jmp((()=>connectedCallback$1(this)))}disconnectedCallback(){plt$1.jmp((()=>disconnectedCallback$1(this)))}componentOnReady(){return getHostRef$1(this).$onReadyPromise$}};cmpMeta.$lazyBundleId$=lazyBundle[0],exclude.includes(tagName)||customElements.get(tagName)||(cmpTags.push(tagName),customElements.define(tagName,proxyComponent$1(HostElement,cmpMeta,1
/* isElementConstructor */)))}))})),visibilityStyle.innerHTML=cmpTags+HYDRATED_CSS$1,visibilityStyle.setAttribute("data-styles",""),head.insertBefore(visibilityStyle,metaCharset?metaCharset.nextSibling:head.firstChild),// Process deferred connectedCallbacks now all components have been registered
isBootstrapping=!1,deferredConnectedCallbacks.length?deferredConnectedCallbacks.map((host=>host.connectedCallback())):plt$1.jmp((()=>appLoadFallback=setTimeout(appDidLoad$1,30))),// Fallback appLoad event
endBootstrap()},hostRefs$1=new WeakMap,getHostRef$1=ref=>hostRefs$1.get(ref),registerHost$1=(elm,cmpMeta)=>{const hostRef={$flags$:0,$hostElement$:elm,$cmpMeta$:cmpMeta,$instanceValues$:new Map};return hostRef.$onReadyPromise$=new Promise((r=>hostRef.$onReadyResolve$=r)),elm["s-p"]=[],elm["s-rc"]=[],hostRefs$1.set(elm,hostRef)},isMemberInElement$1=(elm,memberName)=>memberName in elm,consoleError$1=(e,el)=>(0,console.error)(e,el),cmpModules$1=new Map,loadModule$1=(cmpMeta,hostRef,hmrVersionId)=>{
// loadModuleImport
const exportName=cmpMeta.$tagName$.replace(/-/g,"_"),bundleId=cmpMeta.$lazyBundleId$,module=cmpModules$1.get(bundleId);return module?module[exportName]:__webpack_require__(102650)(`./${bundleId}.entry.js`).then((importedModule=>(cmpModules$1.set(bundleId,importedModule),importedModule[exportName])),consoleError$1)
/*!__STENCIL_STATIC_IMPORT_SWITCH__*/},styles$3=new Map,queueDomReads$1=[],queueDomWrites$1=[],queueTask$1=(queue,write)=>cb=>{queue.push(cb),queuePending$1||(queuePending$1=!0,write&&4
/* queueSync */&plt$1.$flags$?nextTick$1(flush$1):plt$1.raf(flush$1))},consume$1=queue=>{for(let i=0;i<queue.length;i++)try{queue[i](performance.now())}catch(e){consoleError$1(e)}queue.length=0},flush$1=()=>{
// always force a bunch of medium callbacks to run, but still have
// a throttle on how many can run in a certain time
// DOM READS!!!
consume$1(queueDomReads$1),consume$1(queueDomWrites$1),(queuePending$1=queueDomReads$1.length>0)&&
// still more to do yet, but we've run out of time
// let's let this thing cool off and try again in the next tick
plt$1.raf(flush$1)},nextTick$1=cb=>promiseResolve$1().then(cb),writeTask$1=queueTask$1(queueDomWrites$1,!0),patchEsm$1=()=>promiseResolve$1(),defineCustomElements$1=(win,options)=>"undefined"===typeof window?Promise.resolve():patchEsm$1().then((()=>bootstrapLazy$1([["fc-icon",[[1,"fc-icon",{name:[1],group:[1],size:[1],color:[1],svgContent:[32],iconClass:[32],icon:[32],baseURL:[32],sym:[32]}]]]],options)));(function(){if("undefined"!==typeof window&&void 0!==window.Reflect&&void 0!==window.customElements){var a=HTMLElement;window.HTMLElement=function(){return Reflect.construct(a,[],this.constructor)},HTMLElement.prototype=a.prototype,HTMLElement.prototype.constructor=HTMLElement,Object.setPrototypeOf(HTMLElement,a)}})(),
defineCustomElements$1();var EmptyIcon$1={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{width:"87",height:"66",viewBox:"0 0 87 66",xmlns:"http://www.w3.org/2000/svg"}},[_c("g",{attrs:{transform:"translate(0 .87)",fill:"none","fill-rule":"evenodd"}},[_c("path",{attrs:{stroke:"#7176C4",fill:"#FFF","stroke-linecap":"round","stroke-linejoin":"round",d:"M76.196 57.682l-2.284-3.27 5.511-3.86 5.002 7.144"}}),_c("path",{attrs:{fill:"#DBDBF3",d:"M75.243 54.064l3.99-2.793 4.646 6.636-5.915.044z"}}),_c("path",{attrs:{fill:"#FFF",d:"M77.846 52.252l.926-.649 3.96 5.657-.925.648zm-1.073.746l.819-.573 3.461 4.943-.819.574z"}}),_c("path",{attrs:{stroke:"#7176C4","stroke-linecap":"round","stroke-linejoin":"round",d:"M.5 57.682h85.874m-31.686 6.635h10.86m-44.222 0h24.253"}}),_c("path",{attrs:{stroke:"#FFF","stroke-linecap":"round","stroke-linejoin":"round",d:"M57.377 33.73h0m10.875 0h0"}}),_c("path",{attrs:{stroke:"#7176C4","stroke-linecap":"round","stroke-linejoin":"round",d:"M25.525 57.111V.5h35.062l7.666 7.725v48.887"}}),_c("path",{attrs:{stroke:"#7176C4","stroke-linecap":"round","stroke-linejoin":"round",d:"M60.682.5l7.571 7.57h-7.57z"}}),_c("path",{attrs:{fill:"#DBDBF3",d:"M67.806 15.954l-7.57-7.57h7.57zM21.507 6.16h3.509v50.952h-3.509z"}}),_c("path",{attrs:{stroke:"#7176C4","stroke-linecap":"round","stroke-linejoin":"round",d:"M7.482 57.16v-51h18.043"}}),_c("path",{attrs:{d:"M72.705 22.132a18.131 18.131 0 018.923 9.319M73.27 19.113c.4.2.795.413 1.182.638m1.443.912a21.96 21.96 0 013.622 3.122",stroke:"#BCBCE2","stroke-linecap":"round","stroke-linejoin":"round"}}),_c("path",{attrs:{fill:"#AAAAE2",opacity:".5",d:"M33.001 35.954h28.027V34.13H33.001zm0-5h28.027V29.13H33.001z"}}),_c("path",{attrs:{"fill-opacity":".5",fill:"#DBDBF3",d:"M33.001 40.954h28.027V39.13H33.001zM33 45.977h14.014v-1.823H33z"}}),_c("path",{attrs:{fill:"#AAAAE2",opacity:".5",d:"M33.001 9.954h25.34V8.13h-25.34z"}}),_c("path",{attrs:{"fill-opacity":".5",fill:"#DBDBF3",d:"M33.001 14.954h25.34V13.13h-25.34zM33 19.977h14.014v-1.823H33z"}}),_c("path",{attrs:{fill:"#AAAAE2",opacity:".5",d:"M12 14.954h9.551V13.13h-9.55z"}}),_c("path",{attrs:{"fill-opacity":".5",fill:"#DBDBF3",d:"M12 19.954h9.551V18.13h-9.55z"}}),_c("path",{attrs:{stroke:"#7176C4",fill:"#FFF","stroke-linecap":"round","stroke-linejoin":"round",d:"M69.658 45.844l3.277-2.294 5.725 8.176-3.276 2.295z"}}),_c("path",{attrs:{"fill-opacity":".3",fill:"#7176C4",d:"M70.218 47.319l3.898-2.73 1.98 2.83-3.897 2.728z"}}),_c("path",{attrs:{d:"M64.459 52.077c1.146 0 2.257-.148 3.316-.425.088-25.227.088-24.887.088-25.227a13.067 13.067 0 00-3.404-.448c-7.208 0-13.05 5.842-13.05 13.05 0 7.207 5.842 13.05 13.05 13.05z","fill-opacity":".3",fill:"#BCBCE2"}}),_c("circle",{attrs:{stroke:"#7176C4",fill:"#FFF","stroke-linecap":"round","stroke-linejoin":"round",cx:"65.99",cy:"37.431",r:"11.302"}}),_c("path",{attrs:{"fill-opacity":".5",fill:"#DBDBF3",d:"M12 24.977h7.112v-1.823H12z"}}),_c("circle",{attrs:{fill:"#DBDBF3",cx:"66.262",cy:"37.704",r:"10.489"}}),_c("circle",{attrs:{fill:"#FFF",cx:"65.99",cy:"37.431",r:"8.127"}}),_c("path",{attrs:{d:"M74.117 37.431c0-.687-.086-1.355-.246-1.992m-.685-1.788a8.127 8.127 0 10-7.196 11.907h0m7.167 1.072l1.29 1.815m1.013 1.424l.253.357",stroke:"#7176C4",fill:"#FFF","stroke-linecap":"round","stroke-linejoin":"round"}}),_c("circle",{attrs:{fill:"#EDEDF9",cx:"66.829",cy:"33.959",r:"2.829"}}),_c("circle",{attrs:{fill:"#EDEDF9",cx:"70.75",cy:"37.959",r:"1.171"}})])])}},AdvancedFilterIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",width:"13",height:"10",viewBox:"0 0 13 10"}},[_c("path",{attrs:{fill:"#6C6A91",d:"M7.966 8.738c.351 0 .635.282.635.63 0 .35-.284.632-.635.632H5.034a.633.633 0 01-.635-.631c0-.349.284-.631.635-.631h2.932zm1.955-4.38a.632.632 0 110 1.263H3.079a.633.633 0 01-.635-.631c0-.349.284-.631.635-.631h6.842zM12.365 0c.35 0 .635.283.635.631a.632.632 0 01-.635.631H.635A.632.632 0 11.635 0h11.73z"}})])}};function styleInject$1$1(css,ref){void 0===ref&&(ref={});var insertAt=ref.insertAt;if(css&&"undefined"!==typeof document){var head=document.head||document.getElementsByTagName("head")[0],style=document.createElement("style");style.type="text/css","top"===insertAt&&head.firstChild?head.insertBefore(style,head.firstChild):head.appendChild(style),style.styleSheet?style.styleSheet.cssText=css:style.appendChild(document.createTextNode(css))}}var css_248z$2="*, ::before, ::after {\n  --tw-border-opacity: 1;\n  border-color: rgba(229, 231, 235, var(--tw-border-opacity))\n}\n\n.fixed {\n  position: fixed\n}\n\n.float-right {\n  float: right\n}\n\n.m-0 {\n  margin: 0px\n}\n\n.m-0\\.5 {\n  margin: 0.125rem\n}\n\n.my-1 {\n  margin-top: 0.25rem;\n  margin-bottom: 0.25rem\n}\n\n.my-4 {\n  margin-top: 1rem;\n  margin-bottom: 1rem\n}\n\n.mt-auto {\n  margin-top: auto\n}\n\n.mr-1 {\n  margin-right: 0.25rem\n}\n\n.mr-2 {\n  margin-right: 0.5rem\n}\n\n.mr-3 {\n  margin-right: 0.75rem\n}\n\n.mr-1\\.5 {\n  margin-right: 0.375rem\n}\n\n.mb-2 {\n  margin-bottom: 0.5rem\n}\n\n.mb-2\\.5 {\n  margin-bottom: 0.625rem\n}\n\n.ml-5 {\n  margin-left: 1.25rem\n}\n\n.ml-auto {\n  margin-left: auto\n}\n\n.flex {\n  display: flex\n}\n\n.table {\n  display: table\n}\n\n.hidden {\n  display: none\n}\n\n.h-4 {\n  height: 1rem\n}\n\n.h-6 {\n  height: 1.5rem\n}\n\n.h-9 {\n  height: 2.25rem\n}\n\n.h-10 {\n  height: 2.5rem\n}\n\n.h-20 {\n  height: 5rem\n}\n\n.h-40 {\n  height: 10rem\n}\n\n.h-full {\n  height: 100%\n}\n\n.w-4 {\n  width: 1rem\n}\n\n.w-6 {\n  width: 1.5rem\n}\n\n.w-9 {\n  width: 2.25rem\n}\n\n.w-10 {\n  width: 2.5rem\n}\n\n.w-12 {\n  width: 3rem\n}\n\n.w-28 {\n  width: 7rem\n}\n\n.w-40 {\n  width: 10rem\n}\n\n.w-10\\/12 {\n  width: 83.333333%\n}\n\n.w-full {\n  width: 100%\n}\n\n.border-collapse {\n  border-collapse: collapse\n}\n\n.transform {\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  transform: translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))\n}\n\n@keyframes spin {\n  to {\n    transform: rotate(360deg)\n  }\n}\n\n@keyframes ping {\n  75%, 100% {\n    transform: scale(2);\n    opacity: 0\n  }\n}\n\n@keyframes pulse {\n  50% {\n    opacity: .5\n  }\n}\n\n@keyframes bounce {\n  0%, 100% {\n    transform: translateY(-25%);\n    animation-timing-function: cubic-bezier(0.8,0,1,1)\n  }\n\n  50% {\n    transform: none;\n    animation-timing-function: cubic-bezier(0,0,0.2,1)\n  }\n}\n\n.cursor-pointer {\n  cursor: pointer\n}\n\n.flex-col {\n  flex-direction: column\n}\n\n.flex-wrap {\n  flex-wrap: wrap\n}\n\n.flex-nowrap {\n  flex-wrap: nowrap\n}\n\n.items-center {\n  align-items: center\n}\n\n.justify-center {\n  justify-content: center\n}\n\n.justify-between {\n  justify-content: space-between\n}\n\n.self-center {\n  align-self: center\n}\n\n.border {\n  border-width: 1px\n}\n\n.py-1 {\n  padding-top: 0.25rem;\n  padding-bottom: 0.25rem\n}\n\n.py-2 {\n  padding-top: 0.5rem;\n  padding-bottom: 0.5rem\n}\n\n.py-1\\.5 {\n  padding-top: 0.375rem;\n  padding-bottom: 0.375rem\n}\n\n.pr-3 {\n  padding-right: 0.75rem\n}\n\n.pl-1 {\n  padding-left: 0.25rem\n}\n\n.text-left {\n  text-align: left\n}\n\n.text-center {\n  text-align: center\n}\n\n.text-xs {\n  font-size: 0.75rem;\n  line-height: 1rem\n}\n\n.italic {\n  font-style: italic\n}\n\n.underline {\n  text-decoration: underline\n}\n\n*, ::before, ::after {\n  --tw-shadow: 0 0 #0000\n}\n\n*, ::before, ::after {\n  --tw-ring-inset: var(--tw-empty,/*!*/ /*!*/);\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgba(59, 130, 246, 0.5);\n  --tw-ring-offset-shadow: 0 0 #0000;\n  --tw-ring-shadow: 0 0 #0000\n}\n\n.filter {\n  --tw-blur: var(--tw-empty,/*!*/ /*!*/);\n  --tw-brightness: var(--tw-empty,/*!*/ /*!*/);\n  --tw-contrast: var(--tw-empty,/*!*/ /*!*/);\n  --tw-grayscale: var(--tw-empty,/*!*/ /*!*/);\n  --tw-hue-rotate: var(--tw-empty,/*!*/ /*!*/);\n  --tw-invert: var(--tw-empty,/*!*/ /*!*/);\n  --tw-saturate: var(--tw-empty,/*!*/ /*!*/);\n  --tw-sepia: var(--tw-empty,/*!*/ /*!*/);\n  --tw-drop-shadow: var(--tw-empty,/*!*/ /*!*/);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)\n}\n\n.blur {\n  --tw-blur: blur(8px)\n}\n\n.transition {\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms\n}\n\n.ease-in-out {\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1)\n}\n\n@media (min-width: 640px) {\n}\n\n@media (min-width: 768px) {\n}\n\n@media (min-width: 1024px) {\n}\n\n@media (min-width: 1280px) {\n}\n\n@media (min-width: 1536px) {\n}\n";styleInject$1$1(css_248z$2);var css_248z$1$1="/*purgecss start ignore*/\n\n.f-ui-base-text-input .el-input__inner, .f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input__inner,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input__inner, .f-ui-forms .f-ui-date-picker .el-input__inner, .f-ui-forms .f-ui-time-picker .el-input__inner, .f-ui-forms .f-ui-select .el-input__inner, .f-ui-forms .f-ui-text-input .el-input__inner {\n  height: 40px;\n  line-height: 40px;\n  padding-left: 15px;\n  padding-right: 15px;\n  border-radius: 3px;\n  background-color: #fff;\n  border: 1px solid #d0d9e2;\n  font-size: 14px;\n  letter-spacing: 0.4px;\n  color: #324056;\n  text-overflow: ellipsis;\n  font-weight: 400;\n  padding-right: 30px;\n  white-space: nowrap;\n}\n\n.f-ui-base-text-input .el-input__inner:hover, .f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input__inner:hover,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input__inner:hover, .f-ui-forms .f-ui-date-picker .el-input__inner:hover, .f-ui-forms .f-ui-time-picker .el-input__inner:hover, .f-ui-forms .f-ui-select .el-input__inner:hover, .f-ui-forms .f-ui-text-input .el-input__inner:hover,\n.f-ui-base-text-input .el-input__inner:focus,\n.f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input__inner:focus,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input__inner:focus,\n.f-ui-forms .f-ui-date-picker .el-input__inner:focus,\n.f-ui-forms .f-ui-time-picker .el-input__inner:focus,\n.f-ui-forms .f-ui-select .el-input__inner:focus,\n.f-ui-forms .f-ui-text-input .el-input__inner:focus {\n  border-color: #39b2c2;\n}\n\n.f-ui-base-text-input .el-input.is-focus .el-input__inner, .f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input.is-focus .el-input__inner,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input.is-focus .el-input__inner, .f-ui-forms .f-ui-date-picker .el-input.is-focus .el-input__inner, .f-ui-forms .f-ui-time-picker .el-input.is-focus .el-input__inner, .f-ui-forms .f-ui-select .el-input.is-focus .el-input__inner, .f-ui-forms .f-ui-text-input .el-input.is-focus .el-input__inner {\n  border-color: #39b2c2;\n}\n\n.f-ui-base-text-input .el-input__inner[disabled=disabled], .f-date-picker-popper .el-date-picker__editor-wrap .el-input .el-input__inner[disabled=disabled],\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input .el-input__inner[disabled=disabled], .f-ui-forms .f-ui-date-picker .el-input__inner[disabled=disabled], .f-ui-forms .f-ui-time-picker .el-input__inner[disabled=disabled], .f-ui-forms .f-ui-select .el-input__inner[disabled=disabled], .f-ui-forms .f-ui-text-input .el-input__inner[disabled=disabled] {\n  background-color: #f5f7fa;\n  border-color: #e4e7ed;\n  color: #c0c4cc;\n}\n\n.f-ui-base-text-input input::-webkit-outer-spin-button, .f-date-picker-popper .el-date-picker__editor-wrap .el-input input::-webkit-outer-spin-button,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input input::-webkit-outer-spin-button, .f-ui-forms .f-ui-date-picker input::-webkit-outer-spin-button, .f-ui-forms .f-ui-time-picker input::-webkit-outer-spin-button, .f-ui-forms .f-ui-select input::-webkit-outer-spin-button, .f-ui-forms .f-ui-text-input input::-webkit-outer-spin-button,\n.f-ui-base-text-input input::-webkit-inner-spin-button,\n.f-date-picker-popper .el-date-picker__editor-wrap .el-input input::-webkit-inner-spin-button,\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input input::-webkit-inner-spin-button,\n.f-ui-forms .f-ui-date-picker input::-webkit-inner-spin-button,\n.f-ui-forms .f-ui-time-picker input::-webkit-inner-spin-button,\n.f-ui-forms .f-ui-select input::-webkit-inner-spin-button,\n.f-ui-forms .f-ui-text-input input::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n\n.f-ui-base-text-input input[type=number], .f-date-picker-popper .el-date-picker__editor-wrap .el-input input[type=number],\n.f-date-picker-popper .el-date-range-picker__time-picker-wrap .el-input input[type=number], .f-ui-forms .f-ui-date-picker input[type=number], .f-ui-forms .f-ui-time-picker input[type=number], .f-ui-forms .f-ui-select input[type=number], .f-ui-forms .f-ui-text-input input[type=number] {\n  -moz-appearance: textfield;\n}\n\n.f-ui-forms .f-ui-select-tag .el-tag,\n.f-ui-forms .f-ui-lookup-container .el-tag {\n  border-radius: 50px;\n  border: solid 1px #39b2c2;\n  letter-spacing: 0.4px;\n  color: #39b2c2;\n  line-height: 25px;\n  height: 25px;\n  background: #fff;\n}\n\n.f-ui-forms .f-ui-select-tag .el-tag .el-icon-close,\n.f-ui-forms .f-ui-lookup-container .el-tag .el-icon-close {\n  color: #39b2c2;\n  background: transparent;\n  font-size: 16px;\n  padding-right: 10px;\n  font-weight: 600;\n  margin-right: 5px;\n  line-height: 15px;\n}\n\n.f-ui-forms .f-ui-select-tag .el-tag .el-icon-close:hover,\n.f-ui-forms .f-ui-lookup-container .el-tag .el-icon-close:hover {\n  background: transparent;\n  color: #39b2c2;\n}\n\n.f-ui-forms .f-ui-select-tag .el-select__tags,\n.f-ui-forms .f-ui-lookup-container .el-select__tags {\n  padding-left: 0;\n}\n\n.f-ui-forms .f-ui-select-tag .el-select__tags-text,\n.f-ui-forms .f-ui-lookup-container .el-select__tags-text {\n  max-width: 70px;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n  display: block;\n}\n\n.f-ui-forms .f-ui-time-picker {\n  width: 100%;\n}\n\n.f-ui-forms .f-ui-time-picker .el-input__inner {\n  padding-left: 30px;\n}\n\n.f-ui-forms .f-ui-date-picker {\n  width: 100%;\n}\n\n.f-ui-forms .f-ui-date-picker .el-input__inner {\n  padding-left: 30px;\n}\n\n.f-ui-forms .f-ui-date-picker.is-active,\n.f-ui-forms .f-ui-date-picker.is-active:hover {\n  border-color: #39b2c2;\n}\n\n.f-ui-forms .f-ui-tag {\n  border-radius: 50px;\n  border: solid 1px #39b2c2;\n  letter-spacing: 0.4px;\n  color: #39b2c2;\n  line-height: 25px;\n  height: 25px;\n  background: #fff;\n}\n\n.f-ui-forms .f-ui-tag .el-icon-close {\n  color: #39b2c2;\n  background: transparent;\n  font-size: 14px;\n  padding-right: 10px;\n  font-weight: 600;\n  margin-right: 5px;\n  line-height: 15px;\n  margin-top: 3px;\n}\n\n.f-ui-forms .f-ui-tag .el-icon-close:hover {\n  background: transparent;\n  color: #39b2c2;\n}\n\n.f-ui-forms .f-ui-icon-hover {\n  border: solid 1px transparent;\n  border-radius: 4px;\n}\n\n.f-ui-forms .f-ui-icon-hover:hover {\n  color: #615e88;\n  background: #f5f6f8;\n  border: 1px solid #dae0e8;\n}\n\n.f-ui-select-popper .f-ui-select-item {\n  display: flex;\n}\n\n.f-ui-select-popper .f-ui-select-item.selected {\n  font-weight: 400 !important;\n  /*color: #ef4f8f;*/\n  color: #ff3184;\n  letter-spacing: 1px !important;\n  font-size: 14px !important;\n}\n\n.f-ui-select-popper.is-multiple .f-ui-select-item {\n  display: flex;\n}\n\n.f-ui-select-popper.is-multiple .f-ui-select-item.selected {\n  color: #39b2c2 !important;\n}\n\n.f-date-picker-popper .el-picker-panel__footer .el-button--text {\n  color: #39b2c2;\n}\n\n.f-date-picker-popper .el-date-table td.available:hover,\n.f-date-picker-popper .el-date-table td.today span,\n.f-date-picker-popper .el-month-table td .cell:hover,\n.f-date-picker-popper .el-month-table td.today .cell,\n.f-date-picker-popper .el-year-table td .cell:hover,\n.f-date-picker-popper .el-year-table td.current:not(.disabled) .cell,\n.f-date-picker-popper .el-year-table td.today .cell,\n.f-date-picker-popper .el-time-panel__btn.confirm {\n  color: #39b2c2;\n}\n\n.f-date-picker-popper .el-date-table td.current:not(.disabled) span,\n.f-date-picker-popper .el-date-table td.end-date span,\n.f-date-picker-popper .el-date-table td.start-date span {\n  color: #fff;\n  background-color: #39b2c2;\n}\n\n.f-date-picker-popper .el-date-picker__header-label.active,\n.f-date-picker-popper .el-date-picker__header-label:hover {\n  color: #ff3184;\n}\n\n/*purgecss end ignore*/";styleInject$1$1(css_248z$1$1);
var script$e={name:"TextInput",components:{Input:element_ui_common.Input},props:["value","disabled","readonly"],data(){return{props:{},inputValue:""}},watch:{value:{handler(newVal,oldVal){newVal!==oldVal&&(this.inputValue=newVal)},immediate:!0}},mounted(){this.getProps()},methods:{getProps(){let props=this.$vnode.elm.attributes;Object.keys(props).forEach((key=>{this.$set(this.props,props[key].name,props[key].nodeValue)}))},change(value){this.$emit("input",value),this.$emit("change",value)},blur(...args){this.$emit("blur",args)},input(value){this.$emit("input",value)}}};function normalizeComponent$3$1(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);
// Vue.extend constructor export interop.
const options="function"===typeof script?script.options:script;
// render functions
let hook;if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,
// functional template
isFunctionalTemplate&&(options.functional=!0)),
// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),
// inject component styles
style&&style.call(this,createInjectorSSR(context)),
// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},
// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(context){style.call(this,createInjectorShadow(context,this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
const originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
const existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}const isOldIE$1="undefined"!==typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());function createInjector$1(context){return(id,style)=>addStyle$1(id,style)}let HEAD$1;const styles$1={};function addStyle$1(id,css){const group=isOldIE$1?css.media||"default":id,style=styles$1[group]||(styles$1[group]={ids:new Set,styles:[]});if(!style.ids.has(id)){style.ids.add(id);let code=css.source;if(css.map&&(
// https://developer.chrome.com/devtools/docs/javascript-debugging
// this makes source maps inside style tags work properly in Chrome
code+="\n/*# sourceURL="+css.map.sources[0]+" */",
// http://stackoverflow.com/a/26603875
code+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(css.map))))+" */"),style.element||(style.element=document.createElement("style"),style.element.type="text/css",css.media&&style.element.setAttribute("media",css.media),void 0===HEAD$1&&(HEAD$1=document.head||document.getElementsByTagName("head")[0]),HEAD$1.appendChild(style.element)),"styleSheet"in style.element)style.styles.push(code),style.element.styleSheet.cssText=style.styles.filter(Boolean).join("\n");else{const index=style.ids.size-1,textNode=document.createTextNode(code),nodes=style.element.childNodes;nodes[index]&&style.element.removeChild(nodes[index]),nodes.length?style.element.insertBefore(textNode,nodes[index]):style.element.appendChild(textNode)}}}
/* script */const __vue_script__$e=script$e;
/* template */var __vue_render__$d=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"f-ui-forms"},[_c("Input",_vm._b({staticClass:"f-ui-text-input",attrs:{disabled:_vm.disabled,readonly:_vm.readonly},on:{change:_vm.change,blur:_vm.blur,input:_vm.input},model:{value:_vm.inputValue,callback:function($$v){_vm.inputValue=$$v},expression:"inputValue"}},"Input",_vm.props,!1))],1)},__vue_staticRenderFns__$d=[];
/* style */
const __vue_inject_styles__$e=function(inject){inject&&inject("data-v-1c999eb9_0",{source:".f-ui-text-input .el-input__inner{height:40px;line-height:40px;padding-left:15px;padding-right:15px;border-radius:3px;background-color:#fff;border:1px solid #d0d9e2;font-size:14px;letter-spacing:.4px;color:#324056;text-overflow:ellipsis;font-weight:400;padding-right:30px;white-space:nowrap}",map:void 0,media:void 0})},__vue_scope_id__$e=void 0,__vue_module_identifier__$e=void 0,__vue_is_functional_template__$e=!1,__vue_component__$d=normalizeComponent$3$1({render:__vue_render__$d,staticRenderFns:__vue_staticRenderFns__$d},__vue_inject_styles__$e,__vue_script__$e,__vue_scope_id__$e,__vue_is_functional_template__$e,__vue_module_identifier__$e,!1,createInjector$1,void 0,void 0),isEmpty$2=value=>void 0===value||null===value||-1===Number(value)||"object"===typeof value&&!(value instanceof Blob)&&0===Object.keys(value).length||"string"===typeof value&&0===value.trim().length,isNull=value=>null===value,isArray=value=>value&&value.constructor===Array;
/* scoped */var Constants={FIELD_PLACEHOLDERS:["${CURRENT_DATE}","${CURRENT_TIME}","${LOGGED_USER}","${LOGGED_TENANT}","${LOGGED_VENDOR}"],LOOKUP_FILTER_ENABLED_FIELDS:["resource","people"],LOOKUP_FILTERS_MAP:{1:"building",2:"asset",3:"tenantcontact",4:"clientcontact",5:"vendorcontact",6:"employee"},QUICK_FILTERS:[{value:null,key:"category",placeHolderText:"Category",lookupModule:{name:null},disabled:!1,options:[]},{spaceType:1,value:null,key:"site",placeHolderText:"Site",lookupModule:{name:"site"},disabled:!1,options:[]},{spaceType:2,value:null,key:"building",placeHolderText:"Building",lookupModule:{name:"building"},disabled:!1,options:[]},{spaceType:3,value:null,key:"floor",placeHolderText:"Floor",lookupModule:{name:"floor"},disabled:!0,options:[]},{spaceType:4,value:null,key:"space",placeHolderText:"Space",lookupModule:{name:"basespace"},disabled:!0,options:[]}]};const constructOptionsToMap=valueArr=>{let optionsObj=valueArr.reduce(((optionsObj,option)=>{let{label:label,value:value}=option||{};return optionsObj[value]=label,optionsObj}),{});return optionsObj},getFieldOptions=async props=>{let{field:field,siteId:siteId,searchText:searchText,page:page,perPage:perPage,defaultIds:defaultIds,customOptions:customOptions}=props,{filters:filters={},field:fieldObj,clientCriteria:clientCriteria={},lookupModule:lookupModule,resourceLookupModuleName:resourceLookupModuleName,lookupModuleName:lookupModuleName,skipDeserialize:skipDeserialize,operatorLookupModule:operatorLookupModule,additionalParams:additionalParams={}}=field||{},{name:name}=lookupModule||{},{name:operatorLookupModuleName}=operatorLookupModule||{},moduleName=resourceLookupModuleName||lookupModuleName||name;isEmpty$2(operatorLookupModuleName)||(moduleName=operatorLookupModuleName);let{filters:lookupModuleFilters}=lookupModule||{};isEmpty$2(lookupModuleFilters)||(filters={...filters,...lookupModuleFilters}),isEmpty$2(siteId)||(filters={...filters,siteId:{operatorId:36,value:[`${siteId}`]}}),"quote"===dlv_umd(fieldObj,"module.name")&&"workorder"===moduleName&&(filters={...filters,isQuotationNeeded:{operatorId:15,value:[String(!0)]}});let defaultIdsStr=isEmpty$2(defaultIds)?"":defaultIds.toString(),payload={moduleName:moduleName,searchText:searchText,page:page,perPage:perPage,filters:isEmpty$2(filters)?null:JSON.stringify(filters),clientCriteria:isEmpty$2(clientCriteria)?null:JSON.stringify(clientCriteria),defaultIds:defaultIdsStr||null,additionalParams:additionalParams},{error:error,options:options=[],meta:meta}=await fetchFieldOptions(payload)||{};if(error)return{error:error};if(isEmpty$2(customOptions)||(options=[...options,...customOptions]),skipDeserialize){let optionsObj=constructOptionsToMap(options||[]);return{options:optionsObj,meta:meta}}return{options:options,meta:meta}},fetchFieldOptions=async payload=>{let{moduleName:moduleName,searchText:searchText,page:page,perPage:perPage,filters:filters,clientCriteria:clientCriteria,defaultIds:defaultIds,additionalParams:additionalParams}=payload,url=`/v3/picklist/${moduleName}`,params={page:page,perPage:perPage,clientCriteria:clientCriteria,filters:filters,search:searchText,default:defaultIds,viewName:"hidden-all",...additionalParams},{error:error,data:data,meta:meta={}}=await api/* API */.bl.get(url,params)||{};if(error)return{error:error};{let{pickList:options}=data||{};return{options:options||[],meta:meta}}};var LookupIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{width:"512",height:"512",viewBox:"0 0 512 512",xmlns:"http://www.w3.org/2000/svg"}},[_c("path",{attrs:{d:"M215.466 481.432c0 10.704-8.71 15.247-19.492 15.247h-85.892C52.151 496.679 32 481.432 32 419.15V78.028C32 17.754 47.553.5 110.082.5h239.999c62.999 0 78.082 14.659 78.082 77.528v185.098c0 10.705-4.305 20.37-15.083 20.37-10.782 0-14.915-9.665-14.915-20.37V78.028c0-38.847-5.615-47.576-48.084-47.576H110.082c-39.68 0-47.917 13.097-47.917 47.576V419.15c0 40.768 6.732 47.518 47.917 47.518h85.892c10.782 0 19.492 4.058 19.492 14.763z"}}),_c("path",{attrs:{d:"M330.56 116.792H129.497c-10.782 0-19.52 6.637-19.52 14.827 0 8.19 8.738 14.828 19.52 14.828H330.56c10.78 0 19.522-6.638 19.522-14.828s-8.743-14.827-19.522-14.827zm19.522 92.355c0-8.19-8.744-14.827-19.523-14.827H129.498c-10.782 0-19.52 6.637-19.52 14.827 0 8.19 8.738 14.827 19.52 14.827H330.56c10.78 0 19.522-6.637 19.522-14.827zm-220.584 62.7c-10.783 0-19.522 6.639-19.522 14.828 0 8.19 8.739 14.827 19.52 14.827h102.592c10.782 0 19.52-6.637 19.52-14.827 0-8.19-8.74-14.827-19.52-14.827H129.497zm215.809 21.927c31.684 0 62.96 12.212 92.762 35.826a230.97 230.97 0 0111.047 9.343c13.134 11.819 22.4 22.164 33.691 36.212l.773.963c.603.753 1.29 1.656 2.058 2.693l.897 1.222.937 1.295 1.133 1.59c8.391 11.835 8.391 27.68.026 39.48l-1.116 1.57a159.25 159.25 0 01-3.376 4.56l-.558.709-1.538 1.914c-10.94 13.558-20.096 23.715-32.938 35.267a231.043 231.043 0 01-11.036 9.333c-29.8 23.615-61.078 35.827-92.762 35.827-31.683 0-62.96-12.211-92.761-35.826a230.993 230.993 0 01-11.047-9.343c-12.837-11.55-21.989-21.705-32.928-35.264l-1.54-1.914-.466-.592a121.78 121.78 0 01-2.179-2.9l-.745-1.024c-.288-.398-.569-.789-.841-1.17l-.792-1.113a34.168 34.168 0 01-.003-39.513l.802-1.126.412-.575.859-1.187.899-1.225a91.05 91.05 0 012.059-2.693l.792-.988c14.496-18.03 27.043-31.52 44.717-45.524 29.801-23.615 61.079-35.827 92.762-35.827zm0 29.8c-24.536 0-49.45 9.727-74.255 29.383-15.22 12.06-26.349 23.94-39.232 39.888l-1.671 2.08-.324.417c-.743.966-1.739 2.33-2.78 3.786l-.725 1.02a4.37 4.37 0 00.002 5.056l1.089 1.526a138.74 138.74 0 002.414 3.276l.473.605 1.479 1.84c10.016 12.41 18.255 21.549 29.654 31.806a201.246 201.246 0 009.621 8.139c24.806 19.655 49.72 29.383 74.255 29.383 24.536 0 49.45-9.728 74.255-29.384a201.302 201.302 0 009.613-8.13c11.675-10.504 20.036-19.834 30.372-32.69l.911-1.14.34-.438c.664-.867 1.54-2.06 2.385-3.236l1.112-1.562a4.368 4.368 0 00-.01-5.06l-.931-1.309c-1.171-1.633-2.325-3.2-3.036-4.087l-.744-.927-1.54-1.908c-9.667-11.92-17.758-20.832-28.85-30.813a201.224 201.224 0 00-9.622-8.138c-24.806-19.656-49.719-29.383-74.255-29.383z"}}),_c("path",{attrs:{d:"M345.6 365.85c-16.497 0-29.867 13.276-29.867 29.655 0 16.378 13.37 29.654 29.867 29.654s29.867-13.276 29.867-29.654c0-16.379-13.37-29.654-29.867-29.654z"}})])}},AddPinkIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{width:"14",height:"14",viewBox:"0 0 14 14",xmlns:"http://www.w3.org/2000/svg"}},[_c("path",{attrs:{d:"M7.6 6.4h4.9a.6.6 0 110 1.2H7.6v4.9a.6.6 0 11-1.2 0V7.6H1.5a.6.6 0 110-1.2h4.9V1.5a.6.6 0 111.2 0v4.9z",fill:"#EF508F","fill-rule":"evenodd"}})])}},script$c$1={name:"Lookup",components:{Select:element_ui_common.Select,Option:element_ui_common.Option,Tooltip:element_ui_common.Tooltip,LookupIcon:LookupIcon,AddPinkIcon:AddPinkIcon},props:{customOptions:{type:Array,default:()=>[]},value:void 0,field:{type:Object,default:null},disabled:{type:Boolean},siteId:{type:Number,default:null},categoryId:{type:Number,default:null},hideLookupIcon:{type:Boolean,default:!1},popperAppendToBody:{required:!1,type:Boolean,default:!1},fetchOptionsOnLoad:{type:Boolean,default:!0},fetchOptionsMethod:{type:Function,default:null},preHookFilterConstruction:{type:Function,default:field=>field.filters},hideDropDown:{type:Boolean,default:!1},skipLoading:{type:Boolean,default:!1},isClearable:{type:Boolean,default:!0},userfilmoduleEnum:{type:String,default:""}},data(){return{localSearch:!1,isLoadedOnce:!1,currentModelValue:!1,showQuickCreateData:!1,isEmpty:isEmpty$2}},computed:{modelObj:{get(){return this.value},set(val){this.currentModelValue=val,this.$emit("input",val)}},moduleDisplayName(){let{field:field}=this,{lookupModule:lookupModule}=field.field||{},{displayName:displayName}=lookupModule||{};return displayName},isFieldLoading(){let{field:field,defaultIds:defaultIds,skipLoading:skipLoading,isLoadedOnce:isLoadedOnce}=this;return!skipLoading&&!isLoadedOnce&&!isEmpty$2(defaultIds)&&field.isDataLoading},isPickListTypeModule(){let{field:field}=this,{field:fieldObj}=field,{lookupModule:lookupModule}=fieldObj||field,{type:type}=lookupModule||{};// type 1 is for base entity modules
return!!type&&1!==type},isRemote(){let{localSearch:localSearch}=this;return!localSearch},canHideLookupIcon(){let{hideLookupIcon:hideLookupIcon,isPickListTypeModule:isPickListTypeModule,hideDropDown:hideDropDown,field:field,userfilmoduleEnum:userfilmoduleEnum}=this,{config:config}=field||{},canHide=!1;if(!isEmpty$2(config)){let canShowLookupWizard=dlv_umd(config,"canShowLookupWizard",null);isNull(canShowLookupWizard)||(canHide=!canShowLookupWizard)}return!hideDropDown&&("PICK_LIST"===userfilmoduleEnum||(canHide||hideLookupIcon||isPickListTypeModule))},canShowQuickCreateIcon(){let{disabled:disabled,field:field}=this,{config:config}=field||{},canShow=!1;return isEmpty$2(config)||(canShow=dlv_umd(config,"canShowQuickCreate")),disabled&&(canShow=!1),canShow},isSiteEnabled(){let siteId=Number(this.$cookie.get("fc.currentSite")),currentSiteId=siteId>0?siteId:-1;return!isEmpty$2(currentSiteId)},isMultiple(){let{field:field}=this;return!!field.multiple},resourceModuleName(){let{field:field}=this,{config:config,lookupModuleName:lookupModuleName}=field,{isFiltersEnabled:isFiltersEnabled,filterValue:filterValue}=config||{};if(isFiltersEnabled&&Constants.LOOKUP_FILTER_ENABLED_FIELDS.includes(lookupModuleName)){let moduleName=Constants.LOOKUP_FILTERS_MAP[filterValue];return moduleName}return null},isResourceField(){let{field:field}=this,{name:name}=field,isResourceField=this.isChooserTypeField(field)||"resource"===name;return isResourceField},
// To prefill the existing values, we have to send default ids in picklist api
defaultIds(){let{modelObj:modelObj}=this,isPlaceHoldersEnabled=Constants.FIELD_PLACEHOLDERS.includes(modelObj)||!1,defaultIds=[];return isEmpty$2(modelObj)||isPlaceHoldersEnabled||(defaultIds=isArray(modelObj)?[...modelObj]:[modelObj]),defaultIds=(defaultIds||[]).filter((id=>!`${id}`.includes("${"))),defaultIds},operatorLookupModule(){let{field:field}=this,{operatorLookupModule:operatorLookupModule}=field||{};return operatorLookupModule||{}},skipSiteFilter(){let{field:field}=this,{config:config}=field||{},{skipSiteFilter:skipSiteFilter=!1}=config||{};return skipSiteFilter},canShowSystemClear(){let{canHideLookupIcon:canHideLookupIcon,isClearable:isClearable,modelObj:modelObj}=this;return!canHideLookupIcon&&(isClearable&&!isEmpty$2(modelObj))}},watch:{value(newVal){let{currentModelValue:currentModelValue,isRemote:isRemote}=this;lodash_isEqual(newVal,currentModelValue)||(isRemote&&this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options)})),this.$set(this,"modelObj",newVal))},siteId:{handler(newVal,oldVal){let{isSiteEnabled:isSiteEnabled,skipSiteFilter:skipSiteFilter}=this;skipSiteFilter||isSiteEnabled||newVal===oldVal||this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options)}))}},operatorLookupModule:{handler(newVal,oldVal){lodash_isEqual(newVal,oldVal)||this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options)}))}},"field.clientCriteria":{handler(newVal,oldVal){lodash_isEqual(newVal,oldVal)||this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options)}))}},categoryId:{handler(newVal,oldVal){lodash_isEqual(newVal,oldVal)||this.getOptions({initialFetch:!0}).then((options=>{this.$set(this.field,"options",options)}))}},"field.options":{handler(value){let{modelObj:modelObj}=this;if(!isEmpty$2(value))if(isEmpty$2(modelObj))
// eslint-disable-next-line vue/no-mutating-props
this.field.selectedItems=[];else if(isArray(modelObj)){let selectedItems=value.filter((option=>modelObj.includes(option.value)));// eslint-disable-next-line vue/no-mutating-props
this.field.selectedItems=selectedItems}else{let selectedItem=value.find((option=>option.value===modelObj));// eslint-disable-next-line vue/no-mutating-props
this.field.selectedItems=[selectedItem]}},immediate:!0}},async created(){let{fetchOptionsOnLoad:fetchOptionsOnLoad,field:field,modelObj:modelObj}=this;// Have to skip fetching options initially, when module is 'resource' and filters is not enabled
if(this.currentModelValue=modelObj,fetchOptionsOnLoad){let options=await this.getOptions({initialFetch:!0})||[];this.$set(this.field,"options",options),this.$set(this,"isLoadedOnce",!0)}this.remoteMethod=debounce((async searchText=>{let{isDataLoading:isDataLoading}=field;if(!isDataLoading){let options=await this.getOptions({searchText:searchText});this.$set(this.field,"options",options)}}),1e3)},methods:{isChooserTypeField(field){let{displayTypeEnum:displayTypeEnum}=field;// temp have to use a global constant
return["WOASSETSPACECHOOSER","SPACECHOOSER"].includes(displayTypeEnum)},focus(){isEmpty$2(this.$refs["selectBox"])||this.$refs["selectBox"].focus()},async getOptions(params){let{searchText:searchText,initialFetch:initialFetch}=params,{fetchOptionsMethod:fetchOptionsMethod,field:field,siteId:siteId,categoryId:categoryId,isRemote:isRemote,defaultIds:defaultIds,resourceModuleName:resourceModuleName,isResourceField:isResourceField,skipSiteFilter:skipSiteFilter,customOptions:customOptions}=this,options=[];isEmpty$2(resourceModuleName)||(field.resourceLookupModuleName=resourceModuleName),field.filters=this.preHookFilterConstruction(field),isEmpty$2(categoryId)||(field.filters={...field.filters,category:{operator:"is",value:[`${categoryId}`]}});let props={field:field,searchText:searchText};
/*
        Have to return empty options if field is of resourcetype, if filters havent be enabled
        and if no values selected already
      */
if(skipSiteFilter||(props={...props,siteId:siteId}),isResourceField&&isEmpty$2(resourceModuleName)&&isEmpty$2(defaultIds))return options;if(initialFetch&&isRemote&&(props={...props,page:1,perPage:50,defaultIds:defaultIds},isEmpty$2(resourceModuleName)&&isResourceField&&(
// Have to fetch only selected values, which is same as the number of defaultids
props={...props,perPage:defaultIds.length})),isEmpty$2(customOptions)||(props={...props,customOptions:customOptions}),this.$set(field,"isDataLoading",!0),isEmpty$2(fetchOptionsMethod)){let{options:optionsArr=[],error:error,meta:meta}=await getFieldOptions(props);if(error){let{message:message}=error||{};this.$message.error(message||"Error Occured")}if(meta&&isEmpty$2(searchText)){let{localSearch:localSearch=!1}=meta;this.$set(this,"localSearch",localSearch)}options=optionsArr}else{let{options:optionsArr=[],error:error}=await this.fetchOptionsMethod(props);if(error){let{message:message}=error||{};this.$message.error(message||"Error Occured")}options=optionsArr}return this.$set(field,"isDataLoading",!1),options},clearData(){this.$emit("input",""),this.recordSelected("")},recordSelected(value){let{field:field,field:{options:options=[]},isMultiple:isMultiple}=this,selectedValues=null;isMultiple?(selectedValues=options.filter((e=>(value||[]).includes(e.value))),field.selectedItems=selectedValues):(selectedValues=options.find((e=>e.value==value))||{},field.selectedItems=[],isEmpty$2(selectedValues)||(field.selectedItems=[selectedValues])),this.$emit("recordSelected",selectedValues,field)},openLookupFieldWizard(field){let{disabled:disabled}=this;disabled||this.$emit("showLookupWizard",field,!0)},openQuickCreate(){let{disabled:disabled}=this;disabled||(this.showQuickCreateData=!0)},setAddedRecord(props){let{record:record}=props,{id:id}=record||{},name=record.displayName||record.name||record.subject,{field:field}=this;field.selectedItems=[{value:id,label:name}],this.$emit("setLookupFieldValue",{field:{...field}})}}};
/* script */
const __vue_script__$c$1=script$c$1;
/* template */var __vue_render__$b$1=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _vm.isFieldLoading?_c("div",{staticClass:"field-loading loading-shimmer"}):_c("div",{staticClass:"f-ui-forms f-ui-lookup-container"},[_c("Select",{ref:"selectBox",class:["f-ui-forms f-ui-select w-full",!_vm.canHideLookupIcon||_vm.canShowQuickCreateIcon?"field-icons-visible":"select-icon-visible",_vm.isMultiple&&"f-ui-select-tag",_vm.hideDropDown&&!_vm.disabled&&"skip-disable"],attrs:{"collapse-tags":"",remote:_vm.isRemote,filterable:"",clearable:_vm.canHideLookupIcon,multiple:_vm.isMultiple,popperAppendToBody:_vm.popperAppendToBody,"remote-method":function(searchText){return _vm.remoteMethod(searchText)},loading:_vm.field.isDataLoading,"loading-text":"Searching",disabled:_vm.disabled||_vm.hideDropDown,placeholder:_vm.field.placeHolderText||"Select","popper-class":"f-ui-select-popper"},on:{change:_vm.recordSelected},model:{value:_vm.modelObj,callback:function($$v){_vm.modelObj=$$v},expression:"modelObj"}},[_c("div",{staticClass:"float-right h-full flex flex-nowrap cursor-pointer",class:!_vm.disabled&&"pointer",attrs:{slot:"prefix"},slot:"prefix"},[_vm.canShowSystemClear?_c("div",{staticClass:"prefix-icon-container flookup-remove-icon",on:{click:_vm.clearData}},[_c("i",{staticClass:"el-icon-circle-close pointer fc-lookup-icon f13"})]):_vm._e(),_vm._v(" "),_vm.canHideLookupIcon?_vm._e():_c("div",{staticClass:"prefix-icon-container flex flex-nowrap",on:{click:function($event){return $event.stopPropagation(),_vm.openLookupFieldWizard(_vm.field)}}},[_c("div",{staticClass:"lookup-icon f-ui-icon-hover"},[_c("LookupIcon",{staticClass:"w-4 h-4"})],1)]),_vm._v(" "),_vm.canShowQuickCreateIcon?_c("div",{staticClass:"prefix-icon-container flex flex-nowrap",on:{click:function($event){return $event.stopPropagation(),function(){return _vm.openQuickCreate()}.apply(null,arguments)}}},[_c("Tooltip",{attrs:{effect:"dark",content:"Add\n          "+_vm.moduleDisplayName,placement:"top"}},[_c("AddPinkIcon",{staticClass:"icon"})],1)],1):_vm._e()]),_vm._v(" "),_vm._l(_vm.field.options,(function(option,index){return _c("Option",{key:option.value+" "+index,staticClass:"f-ui-select-item width100",attrs:{label:option.label,value:option.value}},[_vm.isEmpty(option.secondaryLabel)?_vm._e():_c("span",{staticClass:"fL"},[_vm._v(_vm._s(option.label))]),_vm._v(" "),_vm.isEmpty(option.secondaryLabel)?_vm._e():_c("span",{staticClass:"select-float-right-text13"},[_vm._v(_vm._s(option.secondaryLabel))])])}))],2),_vm._v(" "),_vm.showQuickCreateData?_c("div",[_vm._v("Testing")]):_vm._e()],1)},__vue_staticRenderFns__$b$1=[];
/* style */
const __vue_inject_styles__$c$1=function(inject){inject&&(inject("data-v-4bcf6127_0",{source:".field-loading[data-v-4bcf6127]{height:40px;display:flex;flex:1;border-radius:3px}",map:void 0,media:void 0}),inject("data-v-4bcf6127_1",{source:".search-input-comp .field-icons-visible .el-input__inner{padding-left:15px!important}.f-ui-lookup-container{position:relative}.f-ui-lookup-container .el-icon-arrow-up:before{visibility:hidden}.f-ui-lookup-container .select-icon-visible .el-icon-arrow-up:before{visibility:visible}.f-ui-lookup-container .field-icons-visible .el-input .el-input__prefix{right:5px;left:88%;z-index:10}.f-ui-lookup-container .skip-disable .el-input__inner:disabled{cursor:auto!important;background-color:#fff;color:#324056}.f-ui-lookup-container .lookup-icon{display:flex;position:relative;padding:5px}.f-ui-lookup-container:hover .flookup-remove-icon{display:flex}.f-ui-lookup-container .flookup-remove-icon{display:none}.f-ui-lookup-container .prefix-icon-container{height:100%;align-items:center;justify-content:center;margin:1px 3px}",map:void 0,media:void 0}))},__vue_scope_id__$c$1="data-v-4bcf6127",__vue_module_identifier__$c$1=void 0,__vue_is_functional_template__$c$1=!1,__vue_component__$b$1=normalizeComponent$3$1({render:__vue_render__$b$1,staticRenderFns:__vue_staticRenderFns__$b$1},__vue_inject_styles__$c$1,__vue_script__$c$1,__vue_scope_id__$c$1,__vue_is_functional_template__$c$1,__vue_module_identifier__$c$1,!1,createInjector$1,void 0,void 0);
/* scoped */
var script$b$1={components:{Select:element_ui_common.Select,Option:element_ui_common.Option},props:["value","options","filterable","multiple","labelName","valueName","disabled","placeholder","allowCreate"],mounted(){this.getProps()},data(){return{props:{},inputValue:""}},watch:{value:{handler(newVal,oldVal){newVal!==oldVal&&(this.inputValue=newVal)},immediate:!0}},computed:{optionsLabelString(){let{labelName:labelName}=this||{};return labelName||"label"},optionsValueString(){let{valueName:valueName}=this||{};return valueName||"value"}},methods:{getProps(){let props=this.$vnode.elm.attributes;Object.keys(props).forEach((key=>{this.$set(this.props,props[key].name,props[key].nodeValue)}))},selectValueChange(value){this.$emit("input",value),this.$emit("change",value)},onClear(){this.$emit("clear")}}};
/* script */const __vue_script__$b$1=script$b$1;
/* template */var __vue_render__$a$1=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"f-ui-forms"},[_c("Select",_vm._b({staticClass:"f-ui-select w-full f-ui-select-tag",attrs:{placeholder:_vm.placeholder||"Select","collapse-tags":"",filterable:_vm.filterable,multiple:_vm.multiple,disabled:_vm.disabled,"allow-create":_vm.allowCreate,"popper-class":"f-ui-select-popper"},on:{change:_vm.selectValueChange,clear:_vm.onClear},model:{value:_vm.inputValue,callback:function($$v){_vm.inputValue=$$v},expression:"inputValue"}},"Select",_vm.props,!1),_vm._l(_vm.options,(function(item){return _c("Option",{key:item[_vm.optionsValueString],staticClass:"f-ui-select-item width100",attrs:{label:item[_vm.optionsLabelString],value:item[_vm.optionsValueString]}})})),1)],1)},__vue_staticRenderFns__$a$1=[];
/* style */
const __vue_inject_styles__$b$1=void 0,__vue_scope_id__$b$1=void 0,__vue_module_identifier__$b$1=void 0,__vue_is_functional_template__$b$1=!1,__vue_component__$a$1$1=normalizeComponent$3$1({render:__vue_render__$a$1,staticRenderFns:__vue_staticRenderFns__$a$1},__vue_inject_styles__$b$1,__vue_script__$b$1,__vue_scope_id__$b$1,__vue_is_functional_template__$b$1,__vue_module_identifier__$b$1,!1,void 0,void 0,void 0);
/* scoped */function _extends$3(){return _extends$3=Object.assign||function(a){for(var b,c=1;c<arguments.length;c++)for(var d in b=arguments[c],b)Object.prototype.hasOwnProperty.call(b,d)&&(a[d]=b[d]);return a},_extends$3.apply(this,arguments)}var normalMerge=["attrs","props","domProps"],toArrayMerge=["class","style","directives"],functionalMerge=["on","nativeOn"],mergeJsxProps=function(a){return a.reduce((function(c,a){for(var b in a)if(c[b])if(-1!==normalMerge.indexOf(b))c[b]=_extends$3({},c[b],a[b]);else if(-1!==toArrayMerge.indexOf(b)){var d=c[b]instanceof Array?c[b]:[c[b]],e=a[b]instanceof Array?a[b]:[a[b]];c[b]=d.concat(e)}else if(-1!==functionalMerge.indexOf(b))for(var f in a[b])if(c[b][f]){var g=c[b][f]instanceof Array?c[b][f]:[c[b][f]],h=a[b][f]instanceof Array?a[b][f]:[a[b][f]];c[b][f]=g.concat(h)}else c[b][f]=a[b][f];else if("hook"==b)for(var i in a[b])c[b][i]=c[b][i]?mergeFn(c[b][i],a[b][i]):a[b][i];else c[b]=a[b];else c[b]=a[b];return c}),{})},mergeFn=function(a,b){return function(){a&&a.apply(this,arguments),b&&b.apply(this,arguments)}},helper=mergeJsxProps;const isEmpty$1=value=>void 0===value||null===value||-1===Number(value)||"object"===typeof value&&!(value instanceof Blob)&&0===Object.keys(value).length||"string"===typeof value&&0===value.trim().length,isObject=obj=>null!==obj&&"object"===typeof obj&&!1===Array.isArray(obj);vue_runtime_esm["default"].component(element_ui_common.Checkbox.name,element_ui_common.Checkbox);const formatDate$3=(date,excludeTime,onlyTime)=>{let dateformat="DD-MMM-YYYY",timeformat="HH:mm";// let orgformatArray = orgformat.match(/DD-MMM-YYYY (HH:mm)/)
return onlyTime?moment_timezone(date).format(timeformat):excludeTime?moment_timezone(date).format(dateformat):moment_timezone(date).format(dateformat+" "+timeformat)},getFormattedDuration$3=(value,format="milliseconds",skipDurationCreation=!1)=>{if(!value)return"00:00 Hrs";let duration;duration=skipDurationCreation?value:moment_timezone.duration(parseInt(value,10),format);let days=parseInt(duration.asDays(),10),hours=duration.hours(),minutes=duration.minutes(),seconds=duration.seconds();return days>0?1===days?hours?`${days} Day ${hours} Hrs`:`${days} Day`:hours?`${days} Days ${hours} Hrs`:`${days} Days`:hours>0?minutes?`${hours} Hrs ${minutes} Mins`:`${hours} Hrs`:minutes>0?seconds?`${minutes} Mins ${seconds} Secs`:`${minutes} Mins`:`${seconds} Secs`},DATA_TYPE_VALUE_HASH$3={LOOKUP(field,data){let{name:fieldName}=field,{primaryValue:primaryValue,name:name,displayName:displayName,subject:subject}=data[fieldName]||{},value=displayName||name||subject;return isEmpty$1(primaryValue)?value:primaryValue},FILE(field,data){let filename=data[`${field.name}FileName`];return filename},DATE(field,data){let{name:name}=field||{},value=data[name];return value&&-1!==value?formatDate$3(value,!0):""},DATE_TIME(field,data){let{name:name}=field||{},value=data[name];return value&&-1!==value?formatDate$3(value):""},ENUM(field,data){let{name:name}=field||{},value=data[name],fieldObj=field.field;return value=value?fieldObj.enumMap[data[fieldObj.name]]:value,value},SYSTEM_ENUM(field,data){let{name:name}=field||{},value=data[name],fieldObj=field.field;return value=value?fieldObj.enumMap[data[fieldObj.name]]:value,value},MULTI_ENUM(field,data){let{name:name,enumMap:enumMap}=field.field||{},values=data[name]||[],valueStr=values.reduce(((accStr,value)=>{let str=enumMap[value]||"";return isEmpty$1(accStr)?`${str}`:`${accStr}, ${str}`}),"");return isEmpty$1(valueStr)?"---":valueStr},BOOLEAN(field,data){let{name:name}=field||{},value=data[name]?field.trueVal||"Yes":field.falseVal||"No";return value},MULTI_LOOKUP(field,data){let{name:name}=field,value=data[name]||[],lookupRecordNames=(value||[]).map((currRecord=>currRecord.displayName||currRecord.name||currRecord.subject));return lookupRecordNames.length>2?`${lookupRecordNames.slice(0,2).join(", ")} +${Math.abs(lookupRecordNames.length-2)}`:isEmpty$1(lookupRecordNames)?"---":`${lookupRecordNames.join(", ")}`},OTHERS(field,data){let{name:name}=field||{};if(!isObject(data[name]))return data[name];{let{name:name}=data[name]||{};if(!isEmpty$1(name))return name;data[name]}}},DISPLAY_TYPE_HASH$3={DURATION(field,record){const h=this.$createElement;let{name:name}=field,value=record[name]||[];return h("div",[isEmpty$1(value)||"---"===value?"---":getFormattedDuration$3(value,isEmpty$1(field.unit)?"s":field.unit)])},URL_FIELD(field,record){const h=this.$createElement;let{name:name}=field||{};if(isEmpty$1(record[name]))return"---";{let{name:displayName,href:href,target:target}=record[name]||{},value=isEmpty$1(displayName)?href:displayName;return h(element_ui_common.Tooltip,{attrs:{effect:"dark",content:value,placement:"bottom-start"}},[h("a",{attrs:{rel:"nofollow",referrerpolicy:"no-referrer",href:href,target:target},class:"url-field-display truncate-text"},[h("span",{class:"textoverflow-ellipsis"},[value])])])}},OTHERS(field,record){const h=this.$createElement;return h("div",{class:"truncate-text"},[this.getColumnDisplayValue(field,record)])}};var script$a$1$1={props:["viewDetail","records","moduleName","redirectToOverview","columnConfig","slotList","hideListSelect","customButtonList","canShowCustomButton","refreshList","metaInfo"],computed:{viewColumns(){let columns=[],{viewDetail:viewDetail}=this,{fields:viewDetailFields=[]}=viewDetail;isEmpty$1(viewDetail)||isEmpty$1(viewDetailFields)||(columns=viewDetailFields.map((viewField=>{let{field:field,fieldName:fieldName}=viewField||{};field=field||{};let name=field.name||fieldName,fieldId=field.fieldId,defaultColumnName=viewDetail.defaultModuleFields&&viewDetail.defaultModuleFields[viewField.name]?viewDetail.defaultModuleFields[viewField.name].columnDisplayName:null,displayName=viewField.columnDisplayName||defaultColumnName||field.displayName;return viewField={...viewField,name:name,fieldId:fieldId,displayName:displayName},viewField})));let{columnConfig:columnConfig}=this,{fixedSelectableColumns:fixedSelectableColumns}=columnConfig||{};return isEmpty$1(columns)?[]:columns.filter((column=>!(fixedSelectableColumns||[]).includes(column.name)))},customFieldValueSlots(){let{slotList:slotList}=this;return isEmpty$1(slotList)?[]:slotList.filter((slotObj=>!slotObj.isActionColumn))},actionColumnSlots(){let{slotList:slotList}=this;return isEmpty$1(slotList)?[]:slotList.filter((slotObj=>slotObj.isActionColumn))},hardCodedSlots(){let{slotList:slotList}=this;return isEmpty$1(slotList)?[]:slotList.filter((slotObj=>slotObj.isHardcodedColumn))}},methods:{
// field type checks
isDecimalField(field){let{dataTypeEnum:dataTypeEnum}=field.field||{};return field.field&&"DECIMAL"===dataTypeEnum},isFixedColumn(name){let{columnConfig:{fixedColumns:fixedColumns}={}}=this;return(fixedColumns||[]).includes(name)},
// column display related methods
getColumnHeaderLabel(column){let{displayName:displayName,field:field}=column;if(!isEmpty$1(field)&&!isEmpty$1(field.unit)){let{unit:unit}=field;return`${displayName} (${unit})`}return displayName},getColumnDisplayValue(field,record){let value,{parentField:parentField}=field,fieldObj=field.field||field,{dataTypeEnum:dataTypeEnum}=fieldObj||{};// first level lookup value, related handling
if(!isEmpty$1(parentField)){let{name:lookupModuleName}=parentField||{};isEmpty$1(lookupModuleName)||isEmpty$1(record[lookupModuleName])||(record=record[lookupModuleName])}return isEmpty$1(DATA_TYPE_VALUE_HASH$3[dataTypeEnum])?value=DATA_TYPE_VALUE_HASH$3["OTHERS"](field,record,this):(dataTypeEnum=dataTypeEnum||dataTypeEnum._name,value=DATA_TYPE_VALUE_HASH$3[dataTypeEnum](field,record,this)),isEmpty$1(value)?"---":value},getColumnDisplayComponent(field,record){let fieldObj=field.field||field,{displayType:displayType}=fieldObj||{},{criteriaCheckForSlot:criteriaCheckForSlot}=this||{},{canRenderSlot:canRenderSlot,slotName:slotName}=criteriaCheckForSlot(field);return canRenderSlot&&!isEmpty$1(this.$scopedSlots[slotName])?this.$scopedSlots[slotName]({record:record}):isEmpty$1(this[displayType])?this["OTHERS"](field,record,this.getColumnDisplayValue):this[displayType](field,record,this.getColumnDisplayValue)},criteriaCheckForSlot(field){let{customFieldValueSlots:customFieldValueSlots}=this,canRenderSlot=!0,slotName="",fieldObj=field.field||field;if(!isEmpty$1(customFieldValueSlots))for(let currSlot of customFieldValueSlots){let{criteria:criteria}=currSlot||{};if(!isEmpty$1(criteria)){let slotCriteria=JSON.parse(criteria);if(isObject(slotCriteria)&&Object.keys(slotCriteria).forEach((fieldName=>{canRenderSlot=fieldObj[fieldName]===slotCriteria[fieldName]})),canRenderSlot){slotName=criteria;break}}}return{canRenderSlot:canRenderSlot,slotName:slotName}},
// redirects and event emiters
selectionChange(selected){this.$emit("selection-change",selected)},toggleVisibility(id,val){let{$el:$el}=this.$refs[`custom-btn-${id}`]||{},{classList:classList}=$el||{};val?classList.remove("visibility-hide-actions"):classList.add("visibility-hide-actions")},toggleRowSelection(item,val){let{moduleName:moduleName}=this||{},ref=this.$refs[`${moduleName}-list`];ref.toggleRowSelection(item,val)},clearSelection(){let{moduleName:moduleName}=this||{},ref=this.$refs[`${moduleName}-list`];ref.clearSelection()},
// display type hash
...DISPLAY_TYPE_HASH$3},render(){const h=arguments[0];return h(element_ui_common.Table,{attrs:{data:this.records,height:"100%",fit:!0,"row-class-name":"no-hover"},ref:`${this.moduleName}-list`,style:"width: 100%;",class:"table-border",on:{"selection-change":this.selectionChange}},[!this.hideListSelect&&h(element_ui_common.TableColumn,{attrs:{fixed:!0,align:"left",type:"selection",width:"60"}}),this.hardCodedSlots.map(((slotObj,index)=>h(element_ui_common.TableColumn,helper([{key:`${slotObj.name}-${index}`},{scopedSlots:{default:data=>this.$scopedSlots[slotObj.name]({record:data.row})}},{attrs:{...slotObj.columnAttrs||{}}}])))),this.viewColumns.map(((field,index)=>h(element_ui_common.TableColumn,helper([{attrs:{fixed:this.isFixedColumn(field.name),prop:field.name,label:this.getColumnHeaderLabel(field),align:this.isDecimalField(field)?"right":"left","min-width":"230"},key:index},{scopedSlots:{default:data=>this.getColumnDisplayComponent(field,data.row)}},{attrs:{...field.columnAttrs||{}}}])))),this.actionColumnSlots.map(((slotObj,index)=>h(element_ui_common.TableColumn,helper([{key:`${slotObj.name}-${index}`},{scopedSlots:{default:data=>this.$scopedSlots[slotObj.name]({record:data.row})}},{attrs:{...slotObj.columnAttrs||{}}}]))))])}};
/* script */const __vue_script__$a$1$1=script$a$1$1,__vue_inject_styles__$a$1$1=function(inject){inject&&inject("data-v-64fad4c9_0",{source:".url-field-display[data-v-64fad4c9]{color:#46a2bf}.url-field-display[data-v-64fad4c9]:hover{text-decoration:underline;text-underline-offset:3px;color:#46a2bf}",map:void 0,media:void 0})},__vue_scope_id__$a$1$1="data-v-64fad4c9",__vue_module_identifier__$a$1$1=void 0,__vue_is_functional_template__$a$1$1=void 0,__vue_component__$9$1=normalizeComponent$3$1({},__vue_inject_styles__$a$1$1,__vue_script__$a$1$1,__vue_scope_id__$a$1$1,__vue_is_functional_template__$a$1$1,__vue_module_identifier__$a$1$1,!1,createInjector$1,void 0,void 0);
/* template */
/* style */
var script$9$1={props:["currentPage","perPage","total","hideToggle"],data(){return{from:0,to:0,page:1}},mounted(){this.init()},watch:{total(){this.init()},currentPage(val){val!==this.page&&this.init()}},methods:{init(){this.page=this.currentPage||1,this.from=(this.page-1)*this.perPage+1;let to=this.from+this.perPage-1;this.to=this.total>to?to:this.total},next(){this.from=this.to+1,this.to+=this.perPage,this.to>this.total&&(this.to=this.total),this.page++,// Update currentPage value
this.$emit("update:currentPage",this.page)},prev(){this.to=this.from-1,this.from-=this.perPage,this.from<=1?this.from=this.page=1:this.page--,// Update currentPage value
this.$emit("update:currentPage",this.page)}}};
/* script */const __vue_script__$9$1=script$9$1;
/* template */var __vue_render__$9$1=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _vm.total>0?_c("div",{staticClass:"f-ui-widget-pagination"},[_vm.from!==_vm.to?_c("span",[_vm._v(_vm._s(_vm.from)+" -")]):_vm._e(),_vm._v(" "),_c("span",[_vm._v(_vm._s(_vm.to))]),_vm._v(" "),_vm.hideToggle?_vm._e():[_c("span",{staticClass:"pl-1 pr-3"},[_vm._v("of "+_vm._s(_vm.total))]),_vm._v(" "),_c("span",{staticClass:"el-icon-arrow-left arrow-icons cursor-pointer",class:{disable:_vm.from<=1},on:{click:function($event){_vm.from>1&&_vm.prev()}}}),_vm._v(" "),_c("span",{staticClass:"el-icon-arrow-right arrow-icons cursor-pointer",class:{disable:_vm.to===_vm.total},on:{click:function($event){_vm.to!==_vm.total&&_vm.next()}}})]],2):_vm._e()},__vue_staticRenderFns__$9$1=[];
/* style */
const __vue_inject_styles__$9$1=function(inject){inject&&inject("data-v-dec3861c_0",{source:".f-ui-widget-pagination{display:flex;align-items:center;font-size:12px;font-weight:500;font-style:normal;letter-spacing:1px;color:#50506c}.f-ui-widget-pagination .arrow-icons{font-size:15px}.f-ui-widget-pagination .disable{opacity:.5;cursor:not-allowed}.f-ui-widget-pagination .el-icon-arrow-left{padding:4px 3px;border-radius:4px;border:1px solid transparent}.f-ui-widget-pagination .el-icon-arrow-left:hover{color:#615e88;background:#f5f6f8;border:1px solid #dae0e8}.f-ui-widget-pagination .el-icon-arrow-right{padding:4px 3px;border-radius:4px;border:1px solid transparent}.f-ui-widget-pagination .el-icon-arrow-right:hover{color:#615e88;background:#f5f6f8;border:1px solid #dae0e8}",map:void 0,media:void 0})},__vue_scope_id__$9$1=void 0,__vue_module_identifier__$9$1=void 0,__vue_is_functional_template__$9$1=!1,__vue_component__$8$1=normalizeComponent$3$1({render:__vue_render__$9$1,staticRenderFns:__vue_staticRenderFns__$9$1},__vue_inject_styles__$9$1,__vue_script__$9$1,__vue_scope_id__$9$1,__vue_is_functional_template__$9$1,__vue_module_identifier__$9$1,!1,createInjector$1,void 0,void 0);
/* scoped */
var script$8$1={name:"spinner",props:["show","size","colour"],computed:{spinnerSize(){return this.size?this.size+"px":"50px"},strokeColor(){return this.colour?this.colour:"#fd4b92"}}};
/* script */const __vue_script__$8$1=script$8$1;
/* template */var __vue_render__$8$1=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("transition",[_c("svg",{directives:[{name:"show",rawName:"v-show",value:_vm.show,expression:"show"}],staticClass:"spinner",class:{show:_vm.show},attrs:{width:_vm.spinnerSize,height:_vm.spinnerSize,viewBox:"0 0 44 44"}},[_c("circle",{staticClass:"path",style:{stroke:_vm.strokeColor},attrs:{fill:"none","stroke-width":"4","stroke-linecap":"round",cx:"22",cy:"22",r:"20"}})])])},__vue_staticRenderFns__$8$1=[];
/* style */
const __vue_inject_styles__$8$1=function(inject){inject&&inject("data-v-3994ea33_0",{source:".spinner[data-v-3994ea33]{transition:opacity .15s ease;animation:rotator-data-v-3994ea33 1.4s linear infinite;animation-play-state:paused}.spinner.show[data-v-3994ea33]{animation-play-state:running}.spinner.v-enter[data-v-3994ea33],.spinner.v-leave-active[data-v-3994ea33]{opacity:0}.spinner.v-enter-active[data-v-3994ea33],.spinner.v-leave[data-v-3994ea33]{opacity:1}.spinner .path[data-v-3994ea33]{stroke-dasharray:126;stroke-dashoffset:0;transform-origin:center;animation:dash-data-v-3994ea33 1.4s ease-in-out infinite}@-moz-keyframes rotator-data-v-3994ea33{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-webkit-keyframes rotator-data-v-3994ea33{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-o-keyframes rotator-data-v-3994ea33{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@keyframes rotator-data-v-3994ea33{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-moz-keyframes dash-data-v-3994ea33{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@-webkit-keyframes dash-data-v-3994ea33{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@-o-keyframes dash-data-v-3994ea33{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@keyframes dash-data-v-3994ea33{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}",map:void 0,media:void 0})},__vue_scope_id__$8$1="data-v-3994ea33",__vue_module_identifier__$8$1=void 0,__vue_is_functional_template__$8$1=!1,__vue_component__$7$1=normalizeComponent$3$1({render:__vue_render__$8$1,staticRenderFns:__vue_staticRenderFns__$8$1},__vue_inject_styles__$8$1,__vue_script__$8$1,__vue_scope_id__$8$1,__vue_is_functional_template__$8$1,__vue_module_identifier__$8$1,!1,createInjector$1,void 0,void 0),NAMESPACE="facicons-ui";
/* scoped */let scopeId,hostTagName,isSvgMode=!1,queuePending=!1;const win="undefined"!==typeof window?window:{},doc$2=win.document||{head:{}},plt={$flags$:0,$resourcesUrl$:"",jmp:h=>h(),raf:h=>requestAnimationFrame(h),ael:(el,eventName,listener,opts)=>el.addEventListener(eventName,listener,opts),rel:(el,eventName,listener,opts)=>el.removeEventListener(eventName,listener,opts),ce:(eventName,opts)=>new CustomEvent(eventName,opts)},promiseResolve=v=>Promise.resolve(v),supportsConstructibleStylesheets=(()=>{try{return new CSSStyleSheet,"function"===typeof(new CSSStyleSheet).replace}catch(e){}return!1})(),HYDRATED_CSS="{visibility:hidden}.hydrated{visibility:inherit}",createTime=(fnName,tagName="")=>()=>{},uniqueTime=(key,measureText)=>()=>{},rootAppliedStyles=new WeakMap,registerStyle=(scopeId,cssText,allowCS)=>{let style=styles$2.get(scopeId);supportsConstructibleStylesheets&&allowCS?(style=style||new CSSStyleSheet,style.replace(cssText)):style=cssText,styles$2.set(scopeId,style)},addStyle$2=(styleContainerNode,cmpMeta,mode,hostElm)=>{let scopeId=getScopeId(cmpMeta);const style=styles$2.get(scopeId);// if an element is NOT connected then getRootNode() will return the wrong root node
// so the fallback is to always use the document for the root node in those cases
if(styleContainerNode=11
/* DocumentFragment */===styleContainerNode.nodeType?styleContainerNode:doc$2,style)if("string"===typeof style){styleContainerNode=styleContainerNode.head||styleContainerNode;let styleElm,appliedStyles=rootAppliedStyles.get(styleContainerNode);appliedStyles||rootAppliedStyles.set(styleContainerNode,appliedStyles=new Set),appliedStyles.has(scopeId)||(styleElm=doc$2.createElement("style"),styleElm.innerHTML=style,styleContainerNode.insertBefore(styleElm,styleContainerNode.querySelector("link")),appliedStyles&&appliedStyles.add(scopeId))}else styleContainerNode.adoptedStyleSheets.includes(style)||(styleContainerNode.adoptedStyleSheets=[...styleContainerNode.adoptedStyleSheets,style]);return scopeId},attachStyles=hostRef=>{const cmpMeta=hostRef.$cmpMeta$,elm=hostRef.$hostElement$,flags=cmpMeta.$flags$,endAttachStyles=createTime("attachStyles",cmpMeta.$tagName$),scopeId=addStyle$2(elm.shadowRoot?elm.shadowRoot:elm.getRootNode(),cmpMeta);10
/* needsScopedEncapsulation */&flags&&(
// only required when we're NOT using native shadow dom (slot)
// or this browser doesn't support native shadow dom
// and this host element was NOT created with SSR
// let's pick out the inner content for slot projection
// create a node to represent where the original
// content was first placed, which is useful later on
// DOM WRITE!!
elm["s-sc"]=scopeId,elm.classList.add(scopeId+"-h")),endAttachStyles()},getScopeId=(cmp,mode)=>"sc-"+cmp.$tagName$
/**
 * Default style mode id
 */
/**
 * Reusable empty obj/array
 * Don't add values to these!!
 */,EMPTY_OBJ={},isDef=v=>null!=v,isComplexType=o=>(
// https://jsperf.com/typeof-fn-object/5
o=typeof o,"object"===o||"function"===o),h=(nodeName,vnodeData,...children)=>{let child=null,simple=!1,lastSimple=!1;const vNodeChildren=[],walk=c=>{for(let i=0;i<c.length;i++)child=c[i],Array.isArray(child)?walk(child):null!=child&&"boolean"!==typeof child&&((simple="function"!==typeof nodeName&&!isComplexType(child))&&(child=String(child)),simple&&lastSimple?
// If the previous child was simple (string), we merge both
vNodeChildren[vNodeChildren.length-1].$text$+=child:
// Append a new vNode, if it's text, we create a text vNode
vNodeChildren.push(simple?newVNode(null,child):child),lastSimple=simple)};if(walk(children),vnodeData){const classData=vnodeData.className||vnodeData.class;classData&&(vnodeData.class="object"!==typeof classData?classData:Object.keys(classData).filter((k=>classData[k])).join(" "))}const vnode=newVNode(nodeName,null);return vnode.$attrs$=vnodeData,vNodeChildren.length>0&&(vnode.$children$=vNodeChildren),vnode},newVNode=(tag,text)=>{const vnode={$flags$:0,$tag$:tag,$text$:text,$elm$:null,$children$:null,$attrs$:null};return vnode},Host={},isHost=node=>node&&node.$tag$===Host
/**
 * Production setAccessor() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */,setAccessor=(elm,memberName,oldValue,newValue,isSvg,flags)=>{if(oldValue!==newValue){let isProp=isMemberInElement(elm,memberName);if(memberName.toLowerCase(),"class"===memberName){const classList=elm.classList,oldClasses=parseClassList(oldValue),newClasses=parseClassList(newValue);classList.remove(...oldClasses.filter((c=>c&&!newClasses.includes(c)))),classList.add(...newClasses.filter((c=>c&&!oldClasses.includes(c))))}else{
// Set property if it exists and it's not a SVG
const isComplex=isComplexType(newValue);if((isProp||isComplex&&null!==newValue)&&!isSvg)try{if(elm.tagName.includes("-"))elm[memberName]=newValue;else{const n=null==newValue?"":newValue;// Workaround for Safari, moving the <input> caret when re-assigning the same valued
"list"===memberName?isProp=!1:null!=oldValue&&elm[memberName]==n||(elm[memberName]=n)}}catch(e){}null==newValue||!1===newValue?!1===newValue&&""!==elm.getAttribute(memberName)||elm.removeAttribute(memberName):(!isProp||4
/* isHost */&flags||isSvg)&&!isComplex&&(newValue=!0===newValue?"":newValue,elm.setAttribute(memberName,newValue))}}},parseClassListRegex=/\s/,parseClassList=value=>value?value.split(parseClassListRegex):[],updateElement=(oldVnode,newVnode,isSvgMode,memberName)=>{
// if the element passed in is a shadow root, which is a document fragment
// then we want to be adding attrs/props to the shadow root's "host" element
// if it's not a shadow root, then we add attrs/props to the same element
const elm=11
/* DocumentFragment */===newVnode.$elm$.nodeType&&newVnode.$elm$.host?newVnode.$elm$.host:newVnode.$elm$,oldVnodeAttrs=oldVnode&&oldVnode.$attrs$||EMPTY_OBJ,newVnodeAttrs=newVnode.$attrs$||EMPTY_OBJ;
// remove attributes no longer present on the vnode by setting them to undefined
for(memberName in oldVnodeAttrs)memberName in newVnodeAttrs||setAccessor(elm,memberName,oldVnodeAttrs[memberName],void 0,isSvgMode,newVnode.$flags$);// add new & update changed attributes
for(memberName in newVnodeAttrs)setAccessor(elm,memberName,oldVnodeAttrs[memberName],newVnodeAttrs[memberName],isSvgMode,newVnode.$flags$)},createElm=(oldParentVNode,newParentVNode,childIndex,parentElm)=>{
// tslint:disable-next-line: prefer-const
const newVNode=newParentVNode.$children$[childIndex];let elm,childNode,i=0;if(
// create element
elm=newVNode.$elm$=doc$2.createElement(newVNode.$tag$),updateElement(null,newVNode,isSvgMode),isDef(scopeId)&&elm["s-si"]!==scopeId&&
// if there is a scopeId and this is the initial render
// then let's add the scopeId as a css class
elm.classList.add(elm["s-si"]=scopeId),newVNode.$children$)for(i=0;i<newVNode.$children$.length;++i)
// create the node
childNode=createElm(oldParentVNode,newVNode,i),// return node could have been null
childNode&&
// append our new node
elm.appendChild(childNode);return elm},addVnodes=(parentElm,before,parentVNode,vnodes,startIdx,endIdx)=>{let childNode,containerElm=parentElm;for(containerElm.shadowRoot&&containerElm.tagName===hostTagName&&(containerElm=containerElm.shadowRoot);startIdx<=endIdx;++startIdx)vnodes[startIdx]&&(childNode=createElm(null,parentVNode,startIdx),childNode&&(vnodes[startIdx].$elm$=childNode,containerElm.insertBefore(childNode,before)))},removeVnodes=(vnodes,startIdx,endIdx,vnode,elm)=>{for(;startIdx<=endIdx;++startIdx)(vnode=vnodes[startIdx])&&(elm=vnode.$elm$,// remove the vnode's element from the dom
elm.remove())},updateChildren=(parentElm,oldCh,newVNode,newCh)=>{let node,oldStartIdx=0,newStartIdx=0,oldEndIdx=oldCh.length-1,oldStartVnode=oldCh[0],oldEndVnode=oldCh[oldEndIdx],newEndIdx=newCh.length-1,newStartVnode=newCh[0],newEndVnode=newCh[newEndIdx];while(oldStartIdx<=oldEndIdx&&newStartIdx<=newEndIdx)null==oldStartVnode?
// Vnode might have been moved left
oldStartVnode=oldCh[++oldStartIdx]:null==oldEndVnode?oldEndVnode=oldCh[--oldEndIdx]:null==newStartVnode?newStartVnode=newCh[++newStartIdx]:null==newEndVnode?newEndVnode=newCh[--newEndIdx]:isSameVnode(oldStartVnode,newStartVnode)?(patch(oldStartVnode,newStartVnode),oldStartVnode=oldCh[++oldStartIdx],newStartVnode=newCh[++newStartIdx]):isSameVnode(oldEndVnode,newEndVnode)?(patch(oldEndVnode,newEndVnode),oldEndVnode=oldCh[--oldEndIdx],newEndVnode=newCh[--newEndIdx]):isSameVnode(oldStartVnode,newEndVnode)?(patch(oldStartVnode,newEndVnode),parentElm.insertBefore(oldStartVnode.$elm$,oldEndVnode.$elm$.nextSibling),oldStartVnode=oldCh[++oldStartIdx],newEndVnode=newCh[--newEndIdx]):isSameVnode(oldEndVnode,newStartVnode)?(patch(oldEndVnode,newStartVnode),parentElm.insertBefore(oldEndVnode.$elm$,oldStartVnode.$elm$),oldEndVnode=oldCh[--oldEndIdx],newStartVnode=newCh[++newStartIdx]):(
// new element
node=createElm(oldCh&&oldCh[newStartIdx],newVNode,newStartIdx),newStartVnode=newCh[++newStartIdx],node&&oldStartVnode.$elm$.parentNode.insertBefore(node,oldStartVnode.$elm$));oldStartIdx>oldEndIdx?addVnodes(parentElm,null==newCh[newEndIdx+1]?null:newCh[newEndIdx+1].$elm$,newVNode,newCh,newStartIdx,newEndIdx):newStartIdx>newEndIdx&&removeVnodes(oldCh,oldStartIdx,oldEndIdx)},isSameVnode=(vnode1,vnode2)=>vnode1.$tag$===vnode2.$tag$,patch=(oldVNode,newVNode)=>{const elm=newVNode.$elm$=oldVNode.$elm$,oldChildren=oldVNode.$children$,newChildren=newVNode.$children$;
// either this is the first render of an element OR it's an update
// AND we already know it's possible it could have changed
// this updates the element's css classes, attrs, props, listeners, etc.
updateElement(oldVNode,newVNode,isSvgMode),null!==oldChildren&&null!==newChildren?
// looks like there's child vnodes for both the old and new vnodes
updateChildren(elm,oldChildren,newVNode,newChildren):null!==newChildren?
// add the new vnode children
addVnodes(elm,null,newVNode,newChildren,0,newChildren.length-1):null!==oldChildren&&
// no new child vnodes, but there are old child vnodes to remove
removeVnodes(oldChildren,0,oldChildren.length-1)},renderVdom=(hostRef,renderFnResults)=>{const hostElm=hostRef.$hostElement$,oldVNode=hostRef.$vnode$||newVNode(null,null),rootVnode=isHost(renderFnResults)?renderFnResults:h(null,null,renderFnResults);hostTagName=hostElm.tagName,rootVnode.$tag$=null,rootVnode.$flags$|=4
/* isHost */,hostRef.$vnode$=rootVnode,rootVnode.$elm$=oldVNode.$elm$=hostElm.shadowRoot||hostElm,scopeId=hostElm["s-sc"],// synchronous patch
patch(oldVNode,rootVnode)},emitEvent=(elm,name,opts)=>{const ev=plt.ce(name,opts);return elm.dispatchEvent(ev),ev},attachToAncestor=(hostRef,ancestorComponent)=>{ancestorComponent&&!hostRef.$onRenderResolve$&&ancestorComponent["s-p"]&&ancestorComponent["s-p"].push(new Promise((r=>hostRef.$onRenderResolve$=r)))},scheduleUpdate=(hostRef,isInitialLoad)=>{if(hostRef.$flags$|=16
/* isQueuedForUpdate */,4
/* isWaitingForChildren */&hostRef.$flags$)return void(hostRef.$flags$|=512
/* needsRerender */);attachToAncestor(hostRef,hostRef.$ancestorComponent$);// there is no ancestor component or the ancestor component
// has already fired off its lifecycle update then
// fire off the initial update
const dispatch=()=>dispatchHooks(hostRef,isInitialLoad);return writeTask(dispatch)},dispatchHooks=(hostRef,isInitialLoad)=>{const endSchedule=createTime("scheduleUpdate",hostRef.$cmpMeta$.$tagName$),instance=hostRef.$lazyInstance$;let promise;return isInitialLoad&&(promise=safeCall(instance,"componentWillLoad")),endSchedule(),then(promise,(()=>updateComponent(hostRef,instance,isInitialLoad)))},updateComponent=async(hostRef,instance,isInitialLoad)=>{
// updateComponent
const elm=hostRef.$hostElement$,endUpdate=createTime("update",hostRef.$cmpMeta$.$tagName$),rc=elm["s-rc"];isInitialLoad&&
// DOM WRITE!
attachStyles(hostRef);const endRender=createTime("render",hostRef.$cmpMeta$.$tagName$);callRender(hostRef,instance),rc&&(
// ok, so turns out there are some child host elements
// waiting on this parent element to load
// let's fire off all update callbacks waiting
rc.map((cb=>cb())),elm["s-rc"]=void 0),endRender(),endUpdate();{const childrenPromises=elm["s-p"],postUpdate=()=>postUpdateComponent(hostRef);0===childrenPromises.length?postUpdate():(Promise.all(childrenPromises).then(postUpdate),hostRef.$flags$|=4
/* isWaitingForChildren */,childrenPromises.length=0)}},callRender=(hostRef,instance,elm)=>{try{instance=instance.render(),hostRef.$flags$&=-17
/* isQueuedForUpdate */,hostRef.$flags$|=2
/* hasRendered */,renderVdom(hostRef,instance)}catch(e){consoleError(e,hostRef.$hostElement$)}return null},postUpdateComponent=hostRef=>{const tagName=hostRef.$cmpMeta$.$tagName$,elm=hostRef.$hostElement$,endPostUpdate=createTime("postUpdate",tagName),ancestorComponent=hostRef.$ancestorComponent$;64
/* hasLoadedComponent */&hostRef.$flags$?endPostUpdate():(hostRef.$flags$|=64
/* hasLoadedComponent */,
// DOM WRITE!
addHydratedFlag(elm),endPostUpdate(),hostRef.$onReadyResolve$(elm),ancestorComponent||appDidLoad()),hostRef.$onRenderResolve$&&(hostRef.$onRenderResolve$(),hostRef.$onRenderResolve$=void 0),512
/* needsRerender */&hostRef.$flags$&&nextTick((()=>scheduleUpdate(hostRef,!1))),hostRef.$flags$&=-517
/* needsRerender */;// load events fire from bottom to top
// the deepest elements load first then bubbles up
}// ( •_•)
// ( •_•)>⌐■-■
// (⌐■_■)
,appDidLoad=who=>{addHydratedFlag(doc$2.documentElement),nextTick((()=>emitEvent(win,"appload",{detail:{namespace:NAMESPACE}})))},safeCall=(instance,method,arg)=>{if(instance&&instance[method])try{return instance[method](arg)}catch(e){consoleError(e)}},then=(promise,thenFn)=>promise&&promise.then?promise.then(thenFn):thenFn(),addHydratedFlag=elm=>elm.classList.add("hydrated")
/**
 * Parse a new property value for a given property type.
 *
 * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,
 * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:
 *   1. `any`, the type given to `propValue` in the function signature
 *   2. the type stored from `propType`.
 *
 * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.
 *
 * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to
 * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is
 * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.
 * ```tsx
 * <my-cmp prop-val={0}></my-cmp>
 * ```
 *
 * HTML prop values on the other hand, will always a string
 *
 * @param propValue the new value to coerce to some type
 * @param propType the type of the prop, expressed as a binary number
 * @returns the parsed/coerced value
 */,parsePropertyValue=(propValue,propType)=>
// ensure this value is of the correct prop type
null==propValue||isComplexType(propValue)?propValue:1
/* String */&propType?String(propValue):propValue,getValue$1=(ref,propName)=>getHostRef(ref).$instanceValues$.get(propName),setValue=(ref,propName,newVal,cmpMeta)=>{
// check our new property value against our internal value
const hostRef=getHostRef(ref),elm=hostRef.$hostElement$,oldVal=hostRef.$instanceValues$.get(propName),flags=hostRef.$flags$,instance=hostRef.$lazyInstance$;newVal=parsePropertyValue(newVal,cmpMeta.$members$[propName][0]);// explicitly check for NaN on both sides, as `NaN === NaN` is always false
const areBothNaN=Number.isNaN(oldVal)&&Number.isNaN(newVal),didValueChange=newVal!==oldVal&&!areBothNaN;if((!(8
/* isConstructingInstance */&flags)||void 0===oldVal)&&didValueChange&&(
// gadzooks! the property's value has changed!!
// set our new value!
hostRef.$instanceValues$.set(propName,newVal),instance)){
// get an array of method names of watch functions to call
if(cmpMeta.$watchers$&&128
/* isWatchReady */&flags){const watchMethods=cmpMeta.$watchers$[propName];watchMethods&&
// this instance is watching for when this property changed
watchMethods.map((watchMethodName=>{try{
// fire off each of the watch methods that are watching this property
instance[watchMethodName](newVal,oldVal,propName)}catch(e){consoleError(e,elm)}}))}2
/* hasRendered */===(18
/* isQueuedForUpdate */&flags)&&
// looks like this value actually changed, so we've got work to do!
// but only if we've already rendered, otherwise just chill out
// queue that we need to do an update, but don't worry about queuing
// up millions cuz this function ensures it only runs once
scheduleUpdate(hostRef,!1)}},proxyComponent=(Cstr,cmpMeta,flags)=>{if(cmpMeta.$members$){Cstr.watchers&&(cmpMeta.$watchers$=Cstr.watchers);// It's better to have a const than two Object.entries()
const members=Object.entries(cmpMeta.$members$),prototype=Cstr.prototype;if(members.map((([memberName,[memberFlags]])=>{(31
/* Prop */&memberFlags||2
/* proxyState */&flags&&32
/* State */&memberFlags)&&
// proxyComponent - prop
Object.defineProperty(prototype,memberName,{get(){
// proxyComponent, get value
return getValue$1(this,memberName)},set(newValue){
// proxyComponent, set value
setValue(this,memberName,newValue,cmpMeta)},configurable:!0,enumerable:!0})})),1
/* isElementConstructor */&flags){const attrNameToPropName=new Map;prototype.attributeChangedCallback=function(attrName,_oldValue,newValue){plt.jmp((()=>{const propName=attrNameToPropName.get(attrName);//  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback
//  in the case where an attribute was set inline.
//  ```html
//    <my-component some-attribute="some-value"></my-component>
//  ```

//  There is an edge case where a developer sets the attribute inline on a custom element and then
//  programmatically changes it before it has been upgraded as shown below:

//  ```html
//    <!-- this component has _not_ been upgraded yet -->
//    <my-component id="test" some-attribute="some-value"></my-component>
//    <script>
//      // grab non-upgraded component
//      el = document.querySelector("#test");
//      el.someAttribute = "another-value";
//      // upgrade component
//      customElements.define('my-component', MyComponent);
//    <\/script>
//  ```
//  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback
//  will be called with `newValue = "some-value"` and will set the shadowed property (this.someAttribute = "another-value")
//  to the value that was set inline i.e. "some-value" from above example. When
//  the connectedCallback attempts to unshadow it will use "some-value" as the initial value rather than "another-value"

//  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed
//  by connectedCallback as this attributeChangedCallback will not fire.

//  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties

//  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to
//  properties here given that this goes against best practices outlined here
//  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy
if(this.hasOwnProperty(propName))newValue=this[propName],delete this[propName];else if(prototype.hasOwnProperty(propName)&&"number"===typeof this[propName]&&this[propName]==newValue)
// if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native
// APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in
// `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.
return;this[propName]=(null!==newValue||"boolean"!==typeof this[propName])&&newValue}))},// create an array of attributes to observe
// and also create a map of html attribute name to js property name
Cstr.observedAttributes=members.filter((([_,m])=>15
/* HasAttribute */&m[0]// filter to only keep props that should match attributes
)).map((([propName,m])=>{const attrName=m[1]||propName;return attrNameToPropName.set(attrName,propName),attrName}))}}return Cstr},initializeComponent=async(elm,hostRef,cmpMeta,hmrVersionId,Cstr)=>{
// initializeComponent
if(0===(32
/* hasInitializedComponent */&hostRef.$flags$)){{if(
// we haven't initialized this element yet
hostRef.$flags$|=32
/* hasInitializedComponent */,// lazy loaded components
// request the component's implementation to be
// wired up with the host element
Cstr=loadModule(cmpMeta),Cstr.then){
// Await creates a micro-task avoid if possible
const endLoad=uniqueTime();Cstr=await Cstr,endLoad()}Cstr.isProxied||(cmpMeta.$watchers$=Cstr.watchers,proxyComponent(Cstr,cmpMeta,2
/* proxyState */),Cstr.isProxied=!0);const endNewInstance=createTime("createInstance",cmpMeta.$tagName$);// ok, time to construct the instance
// but let's keep track of when we start and stop
// so that the getters/setters don't incorrectly step on data
hostRef.$flags$|=8
/* isConstructingInstance */;// construct the lazy-loaded component implementation
// passing the hostRef is very important during
// construction in order to directly wire together the
// host element and the lazy-loaded instance
try{new Cstr(hostRef)}catch(e){consoleError(e)}hostRef.$flags$&=-9
/* isConstructingInstance */,hostRef.$flags$|=128
/* isWatchReady */,endNewInstance()}if(Cstr.style){
// this component has styles but we haven't registered them yet
let style=Cstr.style;const scopeId=getScopeId(cmpMeta);if(!styles$2.has(scopeId)){const endRegisterStyles=createTime("registerStyles",cmpMeta.$tagName$);registerStyle(scopeId,style,!!(1
/* shadowDomEncapsulation */&cmpMeta.$flags$)),endRegisterStyles()}}}// we've successfully created a lazy instance
const ancestorComponent=hostRef.$ancestorComponent$,schedule=()=>scheduleUpdate(hostRef,!0);ancestorComponent&&ancestorComponent["s-rc"]?
// this is the initial load and this component it has an ancestor component
// but the ancestor component has NOT fired its will update lifecycle yet
// so let's just cool our jets and wait for the ancestor to continue first
// this will get fired off when the ancestor component
// finally gets around to rendering its lazy self
// fire off the initial update
ancestorComponent["s-rc"].push(schedule):schedule()},connectedCallback=elm=>{if(0===(1
/* isTmpDisconnected */&plt.$flags$)){const hostRef=getHostRef(elm),cmpMeta=hostRef.$cmpMeta$,endConnected=createTime("connectedCallback",cmpMeta.$tagName$);if(!(1
/* hasConnected */&hostRef.$flags$)){
// first time this component has connected
hostRef.$flags$|=1
/* hasConnected */;{
// find the first ancestor component (if there is one) and register
// this component as one of the actively loading child components for its ancestor
let ancestorComponent=elm;while(ancestorComponent=ancestorComponent.parentNode||ancestorComponent.host)
// climb up the ancestors looking for the first
// component that hasn't finished its lifecycle update yet
if(ancestorComponent["s-p"]){
// we found this components first ancestor component
// keep a reference to this component's ancestor component
attachToAncestor(hostRef,hostRef.$ancestorComponent$=ancestorComponent);break}}// Lazy properties
// https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
cmpMeta.$members$&&Object.entries(cmpMeta.$members$).map((([memberName,[memberFlags]])=>{if(31
/* Prop */&memberFlags&&elm.hasOwnProperty(memberName)){const value=elm[memberName];delete elm[memberName],elm[memberName]=value}})),initializeComponent(elm,hostRef,cmpMeta)}endConnected()}},disconnectedCallback=elm=>{0===(1
/* isTmpDisconnected */&plt.$flags$)&&getHostRef(elm)},bootstrapLazy=(lazyBundles,options={})=>{const endBootstrap=createTime(),cmpTags=[],exclude=options.exclude||[],customElements=win.customElements,head=doc$2.head,metaCharset=head.querySelector("meta[charset]"),visibilityStyle=doc$2.createElement("style"),deferredConnectedCallbacks=[];let appLoadFallback,isBootstrapping=!0;Object.assign(plt,options),plt.$resourcesUrl$=new URL(options.resourcesUrl||"./",doc$2.baseURI).href,lazyBundles.map((lazyBundle=>{lazyBundle[1].map((compactMeta=>{const cmpMeta={$flags$:compactMeta[0],$tagName$:compactMeta[1],$members$:compactMeta[2],$listeners$:compactMeta[3]};cmpMeta.$members$=compactMeta[2],cmpMeta.$watchers$={};const tagName=cmpMeta.$tagName$,HostElement=class extends HTMLElement{
// StencilLazyHost
constructor(self){
// @ts-ignore
super(self),self=this,registerHost(self,cmpMeta),1
/* shadowDomEncapsulation */&cmpMeta.$flags$&&self.attachShadow({mode:"open"})}connectedCallback(){appLoadFallback&&(clearTimeout(appLoadFallback),appLoadFallback=null),isBootstrapping?
// connectedCallback will be processed once all components have been registered
deferredConnectedCallbacks.push(this):plt.jmp((()=>connectedCallback(this)))}disconnectedCallback(){plt.jmp((()=>disconnectedCallback(this)))}componentOnReady(){return getHostRef(this).$onReadyPromise$}};cmpMeta.$lazyBundleId$=lazyBundle[0],exclude.includes(tagName)||customElements.get(tagName)||(cmpTags.push(tagName),customElements.define(tagName,proxyComponent(HostElement,cmpMeta,1
/* isElementConstructor */)))}))})),visibilityStyle.innerHTML=cmpTags+HYDRATED_CSS,visibilityStyle.setAttribute("data-styles",""),head.insertBefore(visibilityStyle,metaCharset?metaCharset.nextSibling:head.firstChild),// Process deferred connectedCallbacks now all components have been registered
isBootstrapping=!1,deferredConnectedCallbacks.length?deferredConnectedCallbacks.map((host=>host.connectedCallback())):plt.jmp((()=>appLoadFallback=setTimeout(appDidLoad,30))),// Fallback appLoad event
endBootstrap()},hostRefs=new WeakMap,getHostRef=ref=>hostRefs.get(ref),registerHost=(elm,cmpMeta)=>{const hostRef={$flags$:0,$hostElement$:elm,$cmpMeta$:cmpMeta,$instanceValues$:new Map};return hostRef.$onReadyPromise$=new Promise((r=>hostRef.$onReadyResolve$=r)),elm["s-p"]=[],elm["s-rc"]=[],hostRefs.set(elm,hostRef)},isMemberInElement=(elm,memberName)=>memberName in elm,consoleError=(e,el)=>(0,console.error)(e,el),cmpModules=new Map,loadModule=(cmpMeta,hostRef,hmrVersionId)=>{
// loadModuleImport
const exportName=cmpMeta.$tagName$.replace(/-/g,"_"),bundleId=cmpMeta.$lazyBundleId$,module=cmpModules.get(bundleId);return module?module[exportName]:__webpack_require__(102650)(`./${bundleId}.entry.js`).then((importedModule=>(cmpModules.set(bundleId,importedModule),importedModule[exportName])),consoleError)
/*!__STENCIL_STATIC_IMPORT_SWITCH__*/},styles$2=new Map,queueDomReads=[],queueDomWrites=[],queueTask=(queue,write)=>cb=>{queue.push(cb),queuePending||(queuePending=!0,write&&4
/* queueSync */&plt.$flags$?nextTick(flush):plt.raf(flush))},consume=queue=>{for(let i=0;i<queue.length;i++)try{queue[i](performance.now())}catch(e){consoleError(e)}queue.length=0},flush=()=>{
// always force a bunch of medium callbacks to run, but still have
// a throttle on how many can run in a certain time
// DOM READS!!!
consume(queueDomReads),consume(queueDomWrites),(queuePending=queueDomReads.length>0)&&
// still more to do yet, but we've run out of time
// let's let this thing cool off and try again in the next tick
plt.raf(flush)},nextTick=cb=>promiseResolve().then(cb),writeTask=queueTask(queueDomWrites,!0),patchEsm=()=>promiseResolve(),defineCustomElements=(win,options)=>"undefined"===typeof window?Promise.resolve():patchEsm().then((()=>bootstrapLazy([["fc-icon",[[1,"fc-icon",{name:[1],group:[1],size:[1],color:[1],svgContent:[32],iconClass:[32],icon:[32],baseURL:[32],sym:[32]}]]]],options)));(function(){if("undefined"!==typeof window&&void 0!==window.Reflect&&void 0!==window.customElements){var a=HTMLElement;window.HTMLElement=function(){return Reflect.construct(a,[],this.constructor)},HTMLElement.prototype=a.prototype,HTMLElement.prototype.constructor=HTMLElement,Object.setPrototypeOf(HTMLElement,a)}})(),
defineCustomElements();var EmptyIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{width:"87",height:"66",viewBox:"0 0 87 66",xmlns:"http://www.w3.org/2000/svg"}},[_c("g",{attrs:{transform:"translate(0 .87)",fill:"none","fill-rule":"evenodd"}},[_c("path",{attrs:{stroke:"#7176C4",fill:"#FFF","stroke-linecap":"round","stroke-linejoin":"round",d:"M76.196 57.682l-2.284-3.27 5.511-3.86 5.002 7.144"}}),_c("path",{attrs:{fill:"#DBDBF3",d:"M75.243 54.064l3.99-2.793 4.646 6.636-5.915.044z"}}),_c("path",{attrs:{fill:"#FFF",d:"M77.846 52.252l.926-.649 3.96 5.657-.925.648zm-1.073.746l.819-.573 3.461 4.943-.819.574z"}}),_c("path",{attrs:{stroke:"#7176C4","stroke-linecap":"round","stroke-linejoin":"round",d:"M.5 57.682h85.874m-31.686 6.635h10.86m-44.222 0h24.253"}}),_c("path",{attrs:{stroke:"#FFF","stroke-linecap":"round","stroke-linejoin":"round",d:"M57.377 33.73h0m10.875 0h0"}}),_c("path",{attrs:{stroke:"#7176C4","stroke-linecap":"round","stroke-linejoin":"round",d:"M25.525 57.111V.5h35.062l7.666 7.725v48.887"}}),_c("path",{attrs:{stroke:"#7176C4","stroke-linecap":"round","stroke-linejoin":"round",d:"M60.682.5l7.571 7.57h-7.57z"}}),_c("path",{attrs:{fill:"#DBDBF3",d:"M67.806 15.954l-7.57-7.57h7.57zM21.507 6.16h3.509v50.952h-3.509z"}}),_c("path",{attrs:{stroke:"#7176C4","stroke-linecap":"round","stroke-linejoin":"round",d:"M7.482 57.16v-51h18.043"}}),_c("path",{attrs:{d:"M72.705 22.132a18.131 18.131 0 018.923 9.319M73.27 19.113c.4.2.795.413 1.182.638m1.443.912a21.96 21.96 0 013.622 3.122",stroke:"#BCBCE2","stroke-linecap":"round","stroke-linejoin":"round"}}),_c("path",{attrs:{fill:"#AAAAE2",opacity:".5",d:"M33.001 35.954h28.027V34.13H33.001zm0-5h28.027V29.13H33.001z"}}),_c("path",{attrs:{"fill-opacity":".5",fill:"#DBDBF3",d:"M33.001 40.954h28.027V39.13H33.001zM33 45.977h14.014v-1.823H33z"}}),_c("path",{attrs:{fill:"#AAAAE2",opacity:".5",d:"M33.001 9.954h25.34V8.13h-25.34z"}}),_c("path",{attrs:{"fill-opacity":".5",fill:"#DBDBF3",d:"M33.001 14.954h25.34V13.13h-25.34zM33 19.977h14.014v-1.823H33z"}}),_c("path",{attrs:{fill:"#AAAAE2",opacity:".5",d:"M12 14.954h9.551V13.13h-9.55z"}}),_c("path",{attrs:{"fill-opacity":".5",fill:"#DBDBF3",d:"M12 19.954h9.551V18.13h-9.55z"}}),_c("path",{attrs:{stroke:"#7176C4",fill:"#FFF","stroke-linecap":"round","stroke-linejoin":"round",d:"M69.658 45.844l3.277-2.294 5.725 8.176-3.276 2.295z"}}),_c("path",{attrs:{"fill-opacity":".3",fill:"#7176C4",d:"M70.218 47.319l3.898-2.73 1.98 2.83-3.897 2.728z"}}),_c("path",{attrs:{d:"M64.459 52.077c1.146 0 2.257-.148 3.316-.425.088-25.227.088-24.887.088-25.227a13.067 13.067 0 00-3.404-.448c-7.208 0-13.05 5.842-13.05 13.05 0 7.207 5.842 13.05 13.05 13.05z","fill-opacity":".3",fill:"#BCBCE2"}}),_c("circle",{attrs:{stroke:"#7176C4",fill:"#FFF","stroke-linecap":"round","stroke-linejoin":"round",cx:"65.99",cy:"37.431",r:"11.302"}}),_c("path",{attrs:{"fill-opacity":".5",fill:"#DBDBF3",d:"M12 24.977h7.112v-1.823H12z"}}),_c("circle",{attrs:{fill:"#DBDBF3",cx:"66.262",cy:"37.704",r:"10.489"}}),_c("circle",{attrs:{fill:"#FFF",cx:"65.99",cy:"37.431",r:"8.127"}}),_c("path",{attrs:{d:"M74.117 37.431c0-.687-.086-1.355-.246-1.992m-.685-1.788a8.127 8.127 0 10-7.196 11.907h0m7.167 1.072l1.29 1.815m1.013 1.424l.253.357",stroke:"#7176C4",fill:"#FFF","stroke-linecap":"round","stroke-linejoin":"round"}}),_c("circle",{attrs:{fill:"#EDEDF9",cx:"66.829",cy:"33.959",r:"2.829"}}),_c("circle",{attrs:{fill:"#EDEDF9",cx:"70.75",cy:"37.959",r:"1.171"}})])])}},script$7$1={props:["canShowLookupWizard","field"],components:{Dialog:element_ui_common.Dialog,CommonList:__vue_component__$9$1,Spinner:__vue_component__$7$1,Pagination:__vue_component__$8$1,Radio:element_ui_common.Radio,Tag:element_ui_common.Tag,Button:element_ui_common.Button,TextInput:__vue_component__$d,EmptyIcon:EmptyIcon},data:()=>({isLoading:!1,viewDetail:null,moduleList:[],perPage:10,page:1,totalCount:0,selectedItem:[],search:"",resourceModuleName:"basespace"}),watch:{async page(){this.isLoading=!0,await this.fetchModuleList(),this.isLoading=!1},moduleName:{handler(){this.loadData()},immediate:!0},isLoading(newVal){!newVal&&this.multiSelect&&this.toggleSelection()}},computed:{isResourceModule(){let{field:field}=this,displayName=dlv_umd(field,"field.lookupModule.name","");return isEmpty$2(displayName)&&(displayName=dlv_umd(field,"lookupModule.name","")),"resource"==displayName},mainField(){let{viewDetail:viewDetail}=this,mainField=null;if(!isEmpty$2(viewDetail)){let{fields:fields}=viewDetail;mainField=(fields||[]).find((field=>{let{field:fieldObj}=field;return(fieldObj||{}).mainField}))}return isEmpty$2(mainField)&&(mainField={name:"name",displayName:"Name",field:{name:"name",dataTypeEnum:"STRING"}}),mainField},mainFieldName(){let{mainField:mainField}=this||{},{name:name}=mainField||{};return isEmpty$2(name)&&(name=dlv_umd(mainField,"field.name","")),name},canShowWizard:{get(){return this.canShowLookupWizard},set(value){this.$emit("update:canShowLookupWizard",value)}},moduleDisplayName(){let{field:field}=this,displayName=dlv_umd(field,"field.lookupModule.displayName","");return isEmpty$2(displayName)&&(displayName=dlv_umd(field,"lookupModule.displayName","")),displayName},moduleName(){let{field:field,resourceModuleName:resourceModuleName}=this,displayName=dlv_umd(field,"field.lookupModule.name","");return isEmpty$2(displayName)&&(displayName=dlv_umd(field,"lookupModule.name","")),"resource"===displayName&&(displayName=resourceModuleName),displayName},title(){let{moduleDisplayName:moduleDisplayName}=this;return`Choose ${moduleDisplayName}`},multiSelect(){let{field:field}=this,{multiple:multiple}=field||{};return multiple},selectedLabel(){let{moduleDisplayName:moduleDisplayName}=this;return`Selected ${moduleDisplayName} `},selectedItemName(){let{selectedItem:selectedItem}=this||{},selectedItemNames=(selectedItem||[]).map((list=>list.label));return isEmpty$2(selectedItemNames)?null:selectedItemNames},selectedItemId:{get(){let{selectedItem:selectedItem,multiSelect:multiSelect}=this||{},selectedItemIds=(selectedItem||[]).map((list=>list.value));return multiSelect?selectedItemIds:selectedItemIds[0]},set(val){let{moduleList:moduleList,multiSelect:multiSelect}=this||{};multiSelect||Array.isArray(val)||(val=[val]);let selectedItem=moduleList.filter((item=>val.includes(item.id)));this.selectedItem=selectedItem.map((list=>{let{id:id}=list,{name:name}=this.mainField||{name:"name"},selectedItem={label:list[name],value:id};return selectedItem}))}},slotList(){let label=dlv_umd(this,"mainField.displayName","Name"),slots=[{name:"select",isHardcodedColumn:!0,columnAttrs:{fixed:"left",width:"50"}},{name:"name",isHardcodedColumn:!0,columnAttrs:{fixed:"left",label:label,width:"200"}}];return slots}},methods:{isEmpty(val){return isEmpty$2(val)},getMainFieldValue(record={}){let{mainField:mainField}=this||{},{name:name}=mainField||{};return record[name]||record.name},setResourceModule(val){let{field:field}=this||{};("basespace"==val||"asset"==val)&&(this.resourceModuleName=val),this.selectedItem=[],this.$set(field,"selectedItems",[])},loadData(){let promise=[];this.moduleName&&(this.initSelectedItem(),promise.push(this.fetchViewDetail()),promise.push(this.fetchModuleList()),this.isLoading=!0,Promise.all(promise).finally((()=>{this.isLoading=!1})))},async fetchViewDetail(){let{moduleName:moduleName}=this,url="v2/views/hidden-all",{data:data,error:error}=await api/* API */.bl.get(url,{moduleName:moduleName});if(isEmpty$2(error)){let{viewDetail:viewDetail}=data||{},{fields:fields}=viewDetail||{};fields=fields.filter((field=>{let{field:fieldObj,name:name=""}=field||{},{mainField:mainField}=fieldObj||{};return!mainField||"name"!==name})),isEmpty$2(viewDetail)||this.$set(this,"viewDetail",{...viewDetail,fields:fields})}},async fetchModuleList(props){let{moduleName:moduleName,page:page,perPage:perPage}=this||{},{filters:filters}=props||{},params={viewname:"hidden-all",includeParentFilter:!0,page:page,perPage:perPage,withCount:!0};isEmpty$2(filters)||(params["filters"]=JSON.stringify(filters));let{list:list,error:error,meta:meta}=await api/* API */.bl.fetchAll(moduleName,params);isEmpty$2(error)&&(this.moduleList=list,this.totalCount=dlv_umd(meta,"pagination.totalCount",0))},onSearchChange:debounce((async function(value){this.onSearch(value)}),700),async onSearch(value){if(this.isLoading=!0,isEmpty$2(value))await this.fetchModuleList();else{let{mainFieldName:mainFieldName}=this||{};("basespace"==this.moduleName||"asset"==this.moduleName)&&(mainFieldName="name");let filters={[mainFieldName]:{operatorId:5,value:[value]}};await this.fetchModuleList({filters:filters})}this.isLoading=!1},initSelectedItem(){let{field:field}=this,{selectedItems:selectedItems=[]}=field||{};isEmpty$2(selectedItems)||(this.selectedItem=[...selectedItems])},toggleSelection(){this.$nextTick((()=>{let{selectedItemId:selectedItemId}=this,currentSelectedList=this.moduleList.filter((list=>(selectedItemId||[]).includes((list||{}).id))),ref=this.$refs.lookupCommonList;isEmpty$2(ref)||(ref.clearSelection(),currentSelectedList.forEach((item=>{ref.toggleRowSelection(item,!0)})))}))},setSelectedItem(){let{selectedItem:selectedItem,mainField:mainField,selectedItemId:selectedItemId,multiSelect:multiSelect,field:field}=this;multiSelect||(selectedItem=[this.moduleList.find((list=>list.id===selectedItemId))],selectedItem=selectedItem.map((list=>{let{id:id}=list,{name:name}=this.mainField||{name:"name"},selectedItem={label:list[name],value:id};return selectedItem}))),isEmpty$2(mainField)&&(mainField={name:"name"}),field.selectedItems=selectedItem;let data={field:field};this.$emit("setLookupFieldValue",data),this.canShowWizard=!1},handleSelection(selectedList){let nonCurrentItems=this.getNonCurrentList(this.selectedItem),currentItems=(selectedList||[]).map((list=>{let{id:id}=list,{mainFieldName:mainFieldName}=this||{};return{label:list[mainFieldName],value:id}}));this.selectedItem=[...nonCurrentItems,...currentItems]},getNonCurrentList(selectedList){let{moduleList:moduleList}=this,currentModuleList=selectedList.filter((item=>-1===moduleList.findIndex((list=>list.id===item.value))));return currentModuleList},handleSelectedClose(item){let index=this.selectedItem.findIndex((list=>list.label===item));this.selectedItem.splice(index,1),this.toggleSelection()},closeWizard(){this.canShowWizard=!1}}};

/* script */
const __vue_script__$7$1=script$7$1;
/* template */var __vue_render__$7$1=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("Dialog",{staticClass:"f-ui-forms f-ui-lookup-wizard",attrs:{visible:_vm.canShowWizard,width:"70%",top:"5vh","append-to-body":!0,"show-close":!1,"before-close":_vm.closeWizard},on:{"update:visible":function($event){_vm.canShowWizard=$event}}},[_c("template",{slot:"title"},[_c("div",{staticClass:"flex items-center"},[_vm.isResourceModule?_c("div",{staticClass:"lookup-wizard-title"},[_c("Button",{class:"basespace"===_vm.resourceModuleName?"btn-active":"btn-not-active",staticStyle:{"margin-right":"10px"},attrs:{type:"text"},on:{click:function($event){return _vm.setResourceModule("basespace")}}},[_vm._v("SPACE")]),_vm._v(" "),_c("Button",{class:"asset"===_vm.resourceModuleName?"btn-active":"btn-not-active",attrs:{type:"text"},on:{click:function($event){return _vm.setResourceModule("asset")}}},[_vm._v("ASSET")])],1):_c("div",{staticClass:"lookup-wizard-title"},[_vm._v("\n        "+_vm._s(_vm.title)+"\n      ")]),_vm._v(" "),_c("div",{staticClass:"ml-auto flex items-center"},[[_c("div",{staticClass:"wizard-search-container"},[_c("TextInput",{staticClass:"wizard-search",attrs:{disabled:_vm.isLoading,"prefix-icon":"el-icon-search",placeholder:"Search"},on:{input:_vm.onSearchChange},model:{value:_vm.search,callback:function($$v){_vm.search=$$v},expression:"search"}})],1),_vm._v(" "),_c("span",{staticClass:"separator"},[_vm._v("|")])],_vm._v(" "),_c("Pagination",{staticClass:"self-center",attrs:{currentPage:_vm.page,total:_vm.totalCount,perPage:_vm.perPage},on:{"update:currentPage":function($event){_vm.page=$event},"update:current-page":function($event){_vm.page=$event}}}),_vm._v(" "),_vm.totalCount?_c("span",{staticClass:"separator"},[_vm._v("|")]):_vm._e(),_vm._v(" "),_c("div",{staticClass:"el-dialog__close el-icon el-icon-close close-icon cursor-pointer",on:{click:_vm.closeWizard}})],2)])]),_vm._v(" "),_vm.isLoading?_c("div",{staticClass:"flex justify-center"},[_c("Spinner",{attrs:{show:_vm.isLoading}})],1):_vm.isEmpty(_vm.moduleList)?_c("div",{staticClass:"f-ui-lookup-empty"},[_c("EmptyIcon",{staticClass:"w-40 h-40"}),_vm._v(" "),_c("div",{staticClass:"mT10 label-txt-black text-md"},[_vm._v("\n      No "+_vm._s(_vm.moduleDisplayName?_vm.moduleDisplayName:_vm.moduleName)+"s available\n    ")])],1):_c("div",{staticClass:"f-ui-lookup-table-container"},[_vm.isEmpty(_vm.selectedItemName)?_vm._e():_c("div",{staticClass:"flex items-center ml-5 my-4"},[_c("div",{staticClass:"mr-3"},[_vm._v(_vm._s(_vm.selectedLabel)+":")]),_vm._v(" "),_c("div",{staticClass:"flex flex-wrap w-10/12"},_vm._l(_vm.selectedItemName,(function(name,index){return _c("Tag",{key:index,staticClass:"f-ui-tag flex items-center mr-2 my-1",on:{click:function(){return _vm.handleSelectedClose(name)}}},[_c("span",[_vm._v(_vm._s(name))]),_vm._v(" "),_vm.multiSelect?_c("i",{staticClass:"el-icon-close pointer"}):_vm._e()])})),1)]),_vm._v(" "),_vm.isEmpty(_vm.moduleList)?_vm._e():_c("CommonList",{ref:"lookupCommonList",attrs:{viewDetail:_vm.viewDetail,records:_vm.moduleList,moduleName:_vm.moduleName,slotList:_vm.slotList,hideListSelect:!_vm.multiSelect},on:{"selection-change":_vm.handleSelection},scopedSlots:_vm._u([{key:"select",fn:function(ref){var record=ref.record;return[_vm.multiSelect?_vm._e():_c("Radio",{attrs:{label:record.id},on:{change:_vm.setSelectedItem},model:{value:_vm.selectedItemId,callback:function($$v){_vm.selectedItemId=$$v},expression:"selectedItemId"}})]}},{key:_vm.slotList[1].name,fn:function(ref){var record=ref.record;return[_vm._v("\n        "+_vm._s(_vm.getMainFieldValue(record)))]}}],null,!0)}),_vm._v(" "),_vm.multiSelect?_c("div",{staticClass:"flex mt-auto"},[_c("Button",{staticClass:"modal-btn-cancel modal-btn",on:{click:_vm.closeWizard}},[_vm._v("\n        Cancel\n      ")]),_vm._v(" "),_c("Button",{staticClass:"modal-btn-save modal-btn",attrs:{type:"primary"},on:{click:_vm.setSelectedItem}},[_vm._v("\n        Save\n      ")])],1):_vm._e()],1)],2)},__vue_staticRenderFns__$7$1=[];
/* style */
const __vue_inject_styles__$7$1=function(inject){inject&&inject("data-v-1085709e_0",{source:".f-ui-lookup-wizard .f-ui-lookup-empty{height:600px;display:flex;flex-direction:column;justify-content:center;align-items:center}.f-ui-lookup-wizard .btn-active{font-size:14px;font-weight:700;letter-spacing:.5px;color:#324056}.f-ui-lookup-wizard .btn-not-active{color:#ccc;font-weight:50}.f-ui-lookup-wizard .el-radio__label{visibility:hidden}.f-ui-lookup-wizard .lookup-wizard-title{font-size:14px;font-weight:700;color:#324056;text-transform:uppercase;line-height:24px}.f-ui-lookup-wizard .el-table__cell{padding:12px 20px!important}.f-ui-lookup-wizard .el-table__cell:first-child{padding:0 10px!important}.f-ui-lookup-wizard .separator{font-weight:300;color:#d8d8d8!important;padding-right:10px;padding-left:10px;padding-bottom:2px}.f-ui-lookup-wizard .close-icon{font-size:15px;padding:4px 3px;border-radius:4px;border:1px solid transparent}.f-ui-lookup-wizard .close-icon:hover{color:#615e88;background:#f5f6f8;border:1px solid #dae0e8}.f-ui-lookup-wizard .el-dialog__header{border-bottom:1px solid #eee}.f-ui-lookup-wizard .el-dialog__body{padding:0}.f-ui-lookup-wizard .el-dialog__body .f-ui-lookup-table-container{height:550px}.f-ui-lookup-wizard .el-dialog__body .f-ui-lookup-table-container .el-table th>.cell{font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:.5px;color:#333;white-space:nowrap}.f-ui-lookup-wizard .el-checkbox__input.is-checked .el-checkbox__inner,.f-ui-lookup-wizard .el-checkbox__input.is-indeterminate .el-checkbox__inner,.f-ui-lookup-wizard .el-radio__input.is-checked .el-radio__inner{background-color:#39b2c2;border-color:#39b2c2}.f-ui-lookup-wizard .el-checkbox__input.is-indeterminate .el-checkbox__inner{margin-left:5px}.f-ui-lookup-wizard .modal-btn-cancel{color:#8f8f8f;border-color:#8f8f8f;background-color:#f4f4f4}.f-ui-lookup-wizard .modal-btn-save{background-color:#39b2c2;color:#fff}.f-ui-lookup-wizard .modal-btn{width:50%;padding-top:18px;padding-bottom:18px;cursor:pointer;border:transparent;letter-spacing:1.1px;text-align:center;text-transform:uppercase;font-weight:500;border-radius:0;float:right;line-height:16px;cursor:pointer;margin:0}.f-ui-lookup-wizard .wizard-search-container{margin-right:5px}.f-ui-lookup-wizard .wizard-search-container .f-ui-forms .el-input__icon{display:flex;align-items:center;justify-content:center}.f-ui-lookup-wizard .wizard-search-container .f-ui-forms .f-ui-text-input .el-input__inner{height:30px;padding-left:30px}",map:void 0,media:void 0})},__vue_scope_id__$7$1=void 0,__vue_module_identifier__$7$1=void 0,__vue_is_functional_template__$7$1=!1,__vue_component__$6$1=normalizeComponent$3$1({render:__vue_render__$7$1,staticRenderFns:__vue_staticRenderFns__$7$1},__vue_inject_styles__$7$1,__vue_script__$7$1,__vue_scope_id__$7$1,__vue_is_functional_template__$7$1,__vue_module_identifier__$7$1,!1,createInjector$1,void 0,void 0);
/* scoped */var _default$2$1={el:{colorpicker:{confirm:"OK",clear:"Clear"},datepicker:{now:"Now",today:"Today",cancel:"Cancel",clear:"Clear",confirm:"OK",selectDate:"Select date",selectTime:"Select time",startDate:"Start Date",startTime:"Start Time",endDate:"End Date",endTime:"End Time",prevYear:"Previous Year",nextYear:"Next Year",prevMonth:"Previous Month",nextMonth:"Next Month",year:"",month1:"January",month2:"February",month3:"March",month4:"April",month5:"May",month6:"June",month7:"July",month8:"August",month9:"September",month10:"October",month11:"November",month12:"December",week:"week",weeks:{sun:"Sun",mon:"Mon",tue:"Tue",wed:"Wed",thu:"Thu",fri:"Fri",sat:"Sat"},months:{jan:"Jan",feb:"Feb",mar:"Mar",apr:"Apr",may:"May",jun:"Jun",jul:"Jul",aug:"Aug",sep:"Sep",oct:"Oct",nov:"Nov",dec:"Dec"}},select:{loading:"Loading",noMatch:"No matching data",noData:"No data",placeholder:"Select"},cascader:{noMatch:"No matching data",loading:"Loading",placeholder:"Select",noData:"No data"},pagination:{goto:"Go to",pagesize:"/page",total:"Total {total}",pageClassifier:""},messagebox:{title:"Message",confirm:"OK",cancel:"Cancel",error:"Illegal input"},upload:{deleteTip:"press delete to remove",delete:"Delete",preview:"Preview",continue:"Continue"},table:{emptyText:"No Data",confirmFilter:"Confirm",resetFilter:"Reset",clearFilter:"All",sumText:"Sum"},tree:{emptyText:"No Data"},transfer:{noMatch:"No matching data",noData:"No data",titles:["List 1","List 2"],// to be translated
filterPlaceholder:"Enter keyword",// to be translated
noCheckedFormat:"{total} items",// to be translated
hasCheckedFormat:"{checked}/{total} checked"},image:{error:"FAILED"},pageHeader:{title:"Back"},popconfirm:{confirmButtonText:"Yes",cancelButtonText:"No"},empty:{description:"No Data"}}};function getDefaultExportFromCjs$1(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,"default")?x["default"]:x}function getAugmentedNamespace$1(n){if(n.__esModule)return n;var a=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(n).forEach((function(k){var d=Object.getOwnPropertyDescriptor(n,k);Object.defineProperty(a,k,d.get?d:{enumerable:!0,get:function(){return n[k]}})})),a}function createCommonjsModule$1$1(fn){var module={exports:{}};return fn(module,module.exports),module.exports}var _default$1$1={el:{colorpicker:{confirm:"确定",clear:"清空"},datepicker:{now:"此刻",today:"今天",cancel:"取消",clear:"清空",confirm:"确定",selectDate:"选择日期",selectTime:"选择时间",startDate:"开始日期",startTime:"开始时间",endDate:"结束日期",endTime:"结束时间",prevYear:"前一年",nextYear:"后一年",prevMonth:"上个月",nextMonth:"下个月",year:"年",month1:"1 月",month2:"2 月",month3:"3 月",month4:"4 月",month5:"5 月",month6:"6 月",month7:"7 月",month8:"8 月",month9:"9 月",month10:"10 月",month11:"11 月",month12:"12 月",
// week: '周次',
weeks:{sun:"日",mon:"一",tue:"二",wed:"三",thu:"四",fri:"五",sat:"六"},months:{jan:"一月",feb:"二月",mar:"三月",apr:"四月",may:"五月",jun:"六月",jul:"七月",aug:"八月",sep:"九月",oct:"十月",nov:"十一月",dec:"十二月"}},select:{loading:"加载中",noMatch:"无匹配数据",noData:"无数据",placeholder:"请选择"},cascader:{noMatch:"无匹配数据",loading:"加载中",placeholder:"请选择",noData:"暂无数据"},pagination:{goto:"前往",pagesize:"条/页",total:"共 {total} 条",pageClassifier:"页"},messagebox:{title:"提示",confirm:"确定",cancel:"取消",error:"输入的数据不合法!"},upload:{deleteTip:"按 delete 键可删除",delete:"删除",preview:"查看图片",continue:"继续上传"},table:{emptyText:"暂无数据",confirmFilter:"筛选",resetFilter:"重置",clearFilter:"全部",sumText:"合计"},tree:{emptyText:"暂无数据"},transfer:{noMatch:"无匹配数据",noData:"无数据",titles:["列表 1","列表 2"],filterPlaceholder:"请输入搜索内容",noCheckedFormat:"共 {total} 项",hasCheckedFormat:"已选 {checked}/{total} 项"},image:{error:"加载失败"},pageHeader:{title:"返回"},popconfirm:{confirmButtonText:"确定",cancelButtonText:"取消"},empty:{description:"暂无数据"}}},zhCN$1=Object.defineProperty({default:_default$1$1},"__esModule",{value:!0}),isMergeableObject$1=function(value){return isNonNullObject$1(value)&&!isSpecial$1(value)};function isNonNullObject$1(value){return!!value&&"object"===typeof value}function isSpecial$1(value){var stringValue=Object.prototype.toString.call(value);return"[object RegExp]"===stringValue||"[object Date]"===stringValue||isReactElement$1(value)}
// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol$1="function"===typeof Symbol&&Symbol.for,REACT_ELEMENT_TYPE$1=canUseSymbol$1?Symbol.for("react.element"):60103;function isReactElement$1(value){return value.$$typeof===REACT_ELEMENT_TYPE$1}function emptyTarget$1(val){return Array.isArray(val)?[]:{}}function cloneIfNecessary$1(value,optionsArgument){var clone=optionsArgument&&!0===optionsArgument.clone;return clone&&isMergeableObject$1(value)?deepmerge$1(emptyTarget$1(value),value,optionsArgument):value}function defaultArrayMerge$1(target,source,optionsArgument){var destination=target.slice();return source.forEach((function(e,i){"undefined"===typeof destination[i]?destination[i]=cloneIfNecessary$1(e,optionsArgument):isMergeableObject$1(e)?destination[i]=deepmerge$1(target[i],e,optionsArgument):-1===target.indexOf(e)&&destination.push(cloneIfNecessary$1(e,optionsArgument))})),destination}function mergeObject$1(target,source,optionsArgument){var destination={};return isMergeableObject$1(target)&&Object.keys(target).forEach((function(key){destination[key]=cloneIfNecessary$1(target[key],optionsArgument)})),Object.keys(source).forEach((function(key){isMergeableObject$1(source[key])&&target[key]?destination[key]=deepmerge$1(target[key],source[key],optionsArgument):destination[key]=cloneIfNecessary$1(source[key],optionsArgument)})),destination}function deepmerge$1(target,source,optionsArgument){var sourceIsArray=Array.isArray(source),targetIsArray=Array.isArray(target),options=optionsArgument||{arrayMerge:defaultArrayMerge$1},sourceAndTargetTypesMatch=sourceIsArray===targetIsArray;if(sourceAndTargetTypesMatch){if(sourceIsArray){var arrayMerge=options.arrayMerge||defaultArrayMerge$1;return arrayMerge(target,source,optionsArgument)}return mergeObject$1(target,source,optionsArgument)}return cloneIfNecessary$1(source,optionsArgument)}deepmerge$1.all=function(array,optionsArgument){if(!Array.isArray(array)||array.length<2)throw new Error("first argument should be an array with at least two elements");
// we are sure there are at least 2 values, so it is safe to have no initial value
return array.reduce((function(prev,next){return deepmerge$1(prev,next,optionsArgument)}))};var deepmerge_1$1=deepmerge$1,es$1=Object.freeze({__proto__:null,default:deepmerge_1$1}),types$1=createCommonjsModule$1$1((function(module,exports){exports.__esModule=!0,exports.isDefined=exports.isUndefined=exports.isFunction=void 0;var _typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj};exports.isString=isString,exports.isObject=isObject,exports.isHtmlElement=isHtmlElement;var _vue2=_interopRequireDefault(vue_runtime_esm["default"]);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function isString(obj){return"[object String]"===Object.prototype.toString.call(obj)}function isObject(obj){return"[object Object]"===Object.prototype.toString.call(obj)}function isHtmlElement(node){return node&&node.nodeType===Node.ELEMENT_NODE}
/**
 *  - Inspired:
 *    https://github.com/jashkenas/underscore/blob/master/modules/isFunction.js
 */var isFunction=function(functionToCheck){var getType={};return functionToCheck&&"[object Function]"===getType.toString.call(functionToCheck)};"object"===("undefined"===typeof Int8Array?"undefined":_typeof(Int8Array))||!_vue2.default.prototype.$isServer&&"function"===typeof document.childNodes||(exports.isFunction=isFunction=function(obj){return"function"===typeof obj||!1}),exports.isFunction=isFunction,exports.isUndefined=function(val){return void 0===val},exports.isDefined=function(val){return void 0!==val&&null!==val}})),util$1=createCommonjsModule$1$1((function(module,exports){exports.__esModule=!0,exports.isEmpty=exports.isEqual=exports.arrayEquals=exports.looseEqual=exports.capitalize=exports.kebabCase=exports.autoprefixer=exports.isFirefox=exports.isEdge=exports.isIE=exports.coerceTruthyValueToArray=exports.arrayFind=exports.arrayFindIndex=exports.escapeRegexpString=exports.valueEquals=exports.generateId=exports.getValueByPath=void 0;var _typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj};exports.noop=noop,exports.hasOwn=hasOwn,exports.toObject=toObject,exports.getPropByPath=getPropByPath,exports.rafThrottle=rafThrottle,exports.objToArray=objToArray;var _vue2=_interopRequireDefault(vue_runtime_esm["default"]);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}var hasOwnProperty=Object.prototype.hasOwnProperty;function noop(){}function hasOwn(obj,key){return hasOwnProperty.call(obj,key)}function extend(to,_from){for(var key in _from)to[key]=_from[key];return to}function toObject(arr){for(var res={},i=0;i<arr.length;i++)arr[i]&&extend(res,arr[i]);return res}function getPropByPath(obj,path,strict){var tempObj=obj;path=path.replace(/\[(\w+)\]/g,".$1"),path=path.replace(/^\./,"");for(var keyArr=path.split("."),i=0,len=keyArr.length;i<len-1;++i){if(!tempObj&&!strict)break;var key=keyArr[i];if(!(key in tempObj)){if(strict)throw new Error("please transfer a valid prop path to form item!");break}tempObj=tempObj[key]}return{o:tempObj,k:keyArr[i],v:tempObj?tempObj[keyArr[i]]:null}}exports.getValueByPath=function(object,prop){prop=prop||"";for(var paths=prop.split("."),current=object,result=null,i=0,j=paths.length;i<j;i++){var path=paths[i];if(!current)break;if(i===j-1){result=current[path];break}current=current[path]}return result},exports.generateId=function(){return Math.floor(1e4*Math.random())},exports.valueEquals=function(a,b){
// see: https://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript
if(a===b)return!0;if(!(a instanceof Array))return!1;if(!(b instanceof Array))return!1;if(a.length!==b.length)return!1;for(var i=0;i!==a.length;++i)if(a[i]!==b[i])return!1;return!0},exports.escapeRegexpString=function(){var value=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return String(value).replace(/[|\\{}()[\]^$+*?.]/g,"\\$&")};
// TODO: use native Array.find, Array.findIndex when IE support is dropped
var arrayFindIndex=exports.arrayFindIndex=function(arr,pred){for(var i=0;i!==arr.length;++i)if(pred(arr[i]))return i;return-1};exports.arrayFind=function(arr,pred){var idx=arrayFindIndex(arr,pred);return-1!==idx?arr[idx]:void 0},
// coerce truthy value to array
exports.coerceTruthyValueToArray=function(val){return Array.isArray(val)?val:val?[val]:[]},exports.isIE=function(){return!_vue2.default.prototype.$isServer&&!isNaN(Number(document.documentMode))},exports.isEdge=function(){return!_vue2.default.prototype.$isServer&&navigator.userAgent.indexOf("Edge")>-1},exports.isFirefox=function(){return!_vue2.default.prototype.$isServer&&!!window.navigator.userAgent.match(/firefox/i)},exports.autoprefixer=function(style){if("object"!==("undefined"===typeof style?"undefined":_typeof(style)))return style;var rules=["transform","transition","animation"],prefixes=["ms-","webkit-"];return rules.forEach((function(rule){var value=style[rule];rule&&value&&prefixes.forEach((function(prefix){style[prefix+rule]=value}))})),style},exports.kebabCase=function(str){var hyphenateRE=/([^-])([A-Z])/g;return str.replace(hyphenateRE,"$1-$2").replace(hyphenateRE,"$1-$2").toLowerCase()},exports.capitalize=function(str){return(0,types$1.isString)(str)?str.charAt(0).toUpperCase()+str.slice(1):str};var looseEqual=exports.looseEqual=function(a,b){var isObjectA=(0,types$1.isObject)(a),isObjectB=(0,types$1.isObject)(b);return isObjectA&&isObjectB?JSON.stringify(a)===JSON.stringify(b):!isObjectA&&!isObjectB&&String(a)===String(b)},arrayEquals=exports.arrayEquals=function(arrayA,arrayB){if(arrayA=arrayA||[],arrayB=arrayB||[],arrayA.length!==arrayB.length)return!1;for(var i=0;i<arrayA.length;i++)if(!looseEqual(arrayA[i],arrayB[i]))return!1;return!0};exports.isEqual=function(value1,value2){return Array.isArray(value1)&&Array.isArray(value2)?arrayEquals(value1,value2):looseEqual(value1,value2)};var isEmpty=exports.isEmpty=function(val){
// null or undefined
if(null==val)return!0;if("boolean"===typeof val)return!1;if("number"===typeof val)return!val;if(val instanceof Error)return""===val.message;switch(Object.prototype.toString.call(val)){
// String or Array
case"[object String]":case"[object Array]":return!val.length;
// Map or Set or File
case"[object File]":case"[object Map]":case"[object Set]":return!val.size;
// Plain Object
case"[object Object]":return!Object.keys(val).length}return!1};function rafThrottle(fn){var locked=!1;return function(){for(var _this=this,_len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];locked||(locked=!0,window.requestAnimationFrame((function(_){fn.apply(_this,args),locked=!1})))}}function objToArray(obj){return Array.isArray(obj)?obj:isEmpty(obj)?[]:[obj]}})),_typeof$3$1="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_default$3=function(Vue){
/**
   * template
   *
   * @param {String} string
   * @param {Array} ...args
   * @return {String}
   */
function template(string){for(var _len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];return 1===args.length&&"object"===_typeof$3$1(args[0])&&(args=args[0]),args&&args.hasOwnProperty||(args={}),string.replace(RE_NARGS$1,(function(match,prefix,i,index){var result=void 0;return"{"===string[index-1]&&"}"===string[index+match.length]?i:(result=(0,util$1.hasOwn)(args,i)?args[i]:null,null===result||void 0===result?"":result)}))}return template},RE_NARGS$1=/(%|)\{([0-9a-zA-Z_]+)\}/g,format$1=Object.defineProperty({default:_default$3},"__esModule",{value:!0}),_deepmerge$1=getAugmentedNamespace$1(es$1),locale$2=createCommonjsModule$1$1((function(module,exports){exports.__esModule=!0,exports.i18n=exports.use=exports.t=void 0;var _zhCN2=_interopRequireDefault(zhCN$1),_vue2=_interopRequireDefault(vue_runtime_esm["default"]),_deepmerge2=_interopRequireDefault(_deepmerge$1),_format2=_interopRequireDefault(format$1);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}var format$1$1=(0,_format2.default)(_vue2.default),lang=_zhCN2.default,merged=!1,i18nHandler=function(){var vuei18n=Object.getPrototypeOf(this||_vue2.default).$t;if("function"===typeof vuei18n&&_vue2.default.locale)return merged||(merged=!0,_vue2.default.locale(_vue2.default.config.lang,(0,_deepmerge2.default)(lang,_vue2.default.locale(_vue2.default.config.lang)||{},{clone:!0}))),vuei18n.apply(this,arguments)},t=exports.t=function(path,options){var value=i18nHandler.apply(this,arguments);if(null!==value&&void 0!==value)return value;for(var array=path.split("."),current=lang,i=0,j=array.length;i<j;i++){var property=array[i];if(value=current[property],i===j-1)return format$1$1(value,options);if(!value)return"";current=value}return""},use=exports.use=function(l){lang=l||lang},i18n=exports.i18n=function(fn){i18nHandler=fn||i18nHandler};exports.default={use:use,t:t,i18n:i18n}})),locale$1$1=getDefaultExportFromCjs$1(locale$2);
locale$1$1.use(_default$2$1);var script$6$1={name:"Datepicker",props:["appendToBody","value","value-format","format","default-value","placeholder","disabled","editable","picker-options","type","prefix-icon","clear-icon","start-placeholder","end-placeholder","hideClear","account"],components:{DatePicker:element_ui_common.DatePicker},mounted(){this.init()},data(){return{timeinorg:[]}},computed:{isRangeType(){let{type:type}=this||{};return["daterange","datetimerange"].includes(type)},defaultFormats(){let{timeformat:timeformat,dateformat:dateformat}=this;return dateformat=dateformat.replaceAll("Y","y"),dateformat=dateformat.replaceAll("D","d"),{date:dateformat,month:"yyyy-MM",datetime:`${dateformat} ${timeformat}`,time:`${timeformat}`,week:"yyyywWW",timerange:`${timeformat}`,daterange:`${dateformat}`,monthrange:"yyyy-MM",datetimerange:`${dateformat} ${timeformat}`,year:"yyyy"}},pickerFormat(){let{defaultFormats:defaultFormats,type:type,format:format}=this||{};return isEmpty$2(format)&&!isEmpty$2(defaultFormats[type])?defaultFormats[type]:format},ttime:{get(){let{value:value,isRangeType:isRangeType}=this||{};return isEmpty$2(value)?isRangeType?[]:"":isRangeType?value.map((val=>this.getTimeInSystemZone(val))):this.getTimeInSystemZone(value)},set(value){let{isRangeType:isRangeType}=this,timeInOrg=[];if(isRangeType){if(isEmpty$2(value))timeInOrg=[];else for(let time in value)timeInOrg[time]=this.getDateInOrg(value[time]);this.$emit("input",timeInOrg),this.$emit("change",timeInOrg)}else{let modifiedTimeFormat=this.getDateInOrg(value);this.$emit("input",modifiedTimeFormat),this.$emit("change",modifiedTimeFormat)}}},dateformat(){let{account:account={}}=this||{},dateFormat=dlv_umd(account,"org.dateFormat","DD-MMM-YYYY");return dateFormat||"DD-MMM-YYYY"},timeformat(){let{account:account={}}=this||{},timeFormat=dlv_umd(account,"org.timeFormat");return 2===timeFormat?"hh:mm A":"HH:mm"},timezone(){let timezone,{account:account={}}=this||{};if((account||{}).timezone){let{timezone:accountTimeZone}=account||{};timezone=accountTimeZone||"Etc/UTC"}else{let orgTimeZone=dlv_umd(account,"org.timezone");timezone=orgTimeZone||"Etc/UTC"}return timezone}},methods:{init(){let{isRangeType:isRangeType,value:value}=this,timeInOrg=[];if(isRangeType){if(isEmpty$2(value))timeInOrg=[];else for(let time in value){let timeVal=parseInt(value[time]);timeInOrg[time]=this.getDateInOrg(timeVal)}this.$emit("input",timeInOrg)}else if(!isEmpty$2(value)){let isPlaceHoldersEnabled=Constants.FIELD_PLACEHOLDERS.includes(value)||!1;isPlaceHoldersEnabled||this.$emit("input",this.getDateInOrg(parseInt(value)))}this.$emit("initialized")},focus(){this.$refs["date-picker"].focus()},getTimeInSystemZone(value){let{timezone:timezone}=this||{};return new Date(moment_timezone.tz(value,timezone||"Etc/UTC").format("YYYY-MM-DD HH:mm:ss"))},getDateInOrg(date){let{timezone:timezone}=this||{};return moment_timezone.tz(moment_timezone(date).format("YYYY-MM-DD HH:mm:ss"),timezone).valueOf()}}};
/* script */const __vue_script__$6$1=script$6$1;
/* template */var __vue_render__$6$1=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"f-ui-forms"},[_c("DatePicker",{ref:"date-picker",staticClass:"f-ui-date-picker",attrs:{appendToBody:_vm.appendToBody,clearable:!_vm.hideClear,type:_vm.type,"value-format":_vm.valueFormat,format:_vm.pickerFormat,placeholder:_vm.placeholder,disabled:_vm.disabled,editable:_vm.editable,"default-value":_vm.defaultValue,"picker-options":_vm.pickerOptions,"prefix-icon":_vm.prefixIcon,"clear-icon":_vm.clearIcon,"start-placeholder":_vm.startPlaceholder,"end-placeholder":_vm.endPlaceholder,"popper-class":"f-date-picker-popper"},model:{value:_vm.ttime,callback:function($$v){_vm.ttime=$$v},expression:"ttime"}})],1)},__vue_staticRenderFns__$6$1=[];
/* style */
const __vue_inject_styles__$6$1=void 0,__vue_scope_id__$6$1=void 0,__vue_module_identifier__$6$1=void 0,__vue_is_functional_template__$6$1=!1,__vue_component__$5$1=normalizeComponent$3$1({render:__vue_render__$6$1,staticRenderFns:__vue_staticRenderFns__$6$1},__vue_inject_styles__$6$1,__vue_script__$6$1,__vue_scope_id__$6$1,__vue_is_functional_template__$6$1,__vue_module_identifier__$6$1,!1,void 0,void 0,void 0);
/* scoped */
/*! @license DOMPurify 2.3.10 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.10/LICENSE */
function _typeof$2$1(obj){return _typeof$2$1="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof$2$1(obj)}function _setPrototypeOf$1(o,p){return _setPrototypeOf$1=Object.setPrototypeOf||function(o,p){return o.__proto__=p,o},_setPrototypeOf$1(o,p)}function _isNativeReflectConstruct$1(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}function _construct$1(Parent,args,Class){return _construct$1=_isNativeReflectConstruct$1()?Reflect.construct:function(Parent,args,Class){var a=[null];a.push.apply(a,args);var Constructor=Function.bind.apply(Parent,a),instance=new Constructor;return Class&&_setPrototypeOf$1(instance,Class.prototype),instance},_construct$1.apply(null,arguments)}function _toConsumableArray$2(arr){return _arrayWithoutHoles$2(arr)||_iterableToArray$2(arr)||_unsupportedIterableToArray$2(arr)||_nonIterableSpread$2()}function _arrayWithoutHoles$2(arr){if(Array.isArray(arr))return _arrayLikeToArray$2(arr)}function _iterableToArray$2(iter){if("undefined"!==typeof Symbol&&null!=iter[Symbol.iterator]||null!=iter["@@iterator"])return Array.from(iter)}function _unsupportedIterableToArray$2(o,minLen){if(o){if("string"===typeof o)return _arrayLikeToArray$2(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);return"Object"===n&&o.constructor&&(n=o.constructor.name),"Map"===n||"Set"===n?Array.from(o):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?_arrayLikeToArray$2(o,minLen):void 0}}function _arrayLikeToArray$2(arr,len){(null==len||len>arr.length)&&(len=arr.length);for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2}function _nonIterableSpread$2(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var hasOwnProperty$1$1=Object.hasOwnProperty,setPrototypeOf$1=Object.setPrototypeOf,isFrozen$1=Object.isFrozen,getPrototypeOf$1=Object.getPrototypeOf,getOwnPropertyDescriptor$1=Object.getOwnPropertyDescriptor,freeze$1=Object.freeze,seal$1=Object.seal,create$1=Object.create,_ref$1="undefined"!==typeof Reflect&&Reflect,apply$1$1=_ref$1.apply,construct$1=_ref$1.construct;apply$1$1||(apply$1$1=function(fun,thisValue,args){return fun.apply(thisValue,args)}),freeze$1||(freeze$1=function(x){return x}),seal$1||(seal$1=function(x){return x}),construct$1||(construct$1=function(Func,args){return _construct$1(Func,_toConsumableArray$2(args))});var arrayForEach$1=unapply$1(Array.prototype.forEach),arrayPop$1=unapply$1(Array.prototype.pop),arrayPush$1=unapply$1(Array.prototype.push),stringToLowerCase$1=unapply$1(String.prototype.toLowerCase),stringMatch$1=unapply$1(String.prototype.match),stringReplace$1=unapply$1(String.prototype.replace),stringIndexOf$1=unapply$1(String.prototype.indexOf),stringTrim$1=unapply$1(String.prototype.trim),regExpTest$1=unapply$1(RegExp.prototype.test),typeErrorCreate$1=unconstruct$1(TypeError);function unapply$1(func){return function(thisArg){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];return apply$1$1(func,thisArg,args)}}function unconstruct$1(func){return function(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++)args[_key2]=arguments[_key2];return construct$1(func,args)}}
/* Add properties to a lookup table */function addToSet$1(set,array,transformCaseFunc){transformCaseFunc=transformCaseFunc||stringToLowerCase$1,setPrototypeOf$1&&
// Make 'in' and truthy checks like Boolean(set.constructor)
// independent of any properties defined on Object.prototype.
// Prevent prototype setters from intercepting set as a this value.
setPrototypeOf$1(set,null);var l=array.length;while(l--){var element=array[l];if("string"===typeof element){var lcElement=transformCaseFunc(element);lcElement!==element&&(
// Config presets (e.g. tags.js, attrs.js) are immutable.
isFrozen$1(array)||(array[l]=lcElement),element=lcElement)}set[element]=!0}return set}
/* Shallow clone an object */function clone$1(object){var property,newObject=create$1(null);for(property in object)apply$1$1(hasOwnProperty$1$1,object,[property])&&(newObject[property]=object[property]);return newObject}
/* IE10 doesn't support __lookupGetter__ so lets'
 * simulate it. It also automatically checks
 * if the prop is function or getter and behaves
 * accordingly. */function lookupGetter$1(object,prop){while(null!==object){var desc=getOwnPropertyDescriptor$1(object,prop);if(desc){if(desc.get)return unapply$1(desc.get);if("function"===typeof desc.value)return unapply$1(desc.value)}object=getPrototypeOf$1(object)}function fallbackValue(element){return null}return fallbackValue}var html$1$1=freeze$1(["a","abbr","acronym","address","area","article","aside","audio","b","bdi","bdo","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","content","data","datalist","dd","decorator","del","details","dfn","dialog","dir","div","dl","dt","element","em","fieldset","figcaption","figure","font","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","img","input","ins","kbd","label","legend","li","main","map","mark","marquee","menu","menuitem","meter","nav","nobr","ol","optgroup","option","output","p","picture","pre","progress","q","rp","rt","ruby","s","samp","section","select","shadow","small","source","spacer","span","strike","strong","style","sub","summary","sup","table","tbody","td","template","textarea","tfoot","th","thead","time","tr","track","tt","u","ul","var","video","wbr"]),svg$1$1=freeze$1(["svg","a","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","circle","clippath","defs","desc","ellipse","filter","font","g","glyph","glyphref","hkern","image","line","lineargradient","marker","mask","metadata","mpath","path","pattern","polygon","polyline","radialgradient","rect","stop","style","switch","symbol","text","textpath","title","tref","tspan","view","vkern"]),svgFilters$1=freeze$1(["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]),svgDisallowed$1=freeze$1(["animate","color-profile","cursor","discard","fedropshadow","font-face","font-face-format","font-face-name","font-face-src","font-face-uri","foreignobject","hatch","hatchpath","mesh","meshgradient","meshpatch","meshrow","missing-glyph","script","set","solidcolor","unknown","use"]),mathMl$1$1=freeze$1(["math","menclose","merror","mfenced","mfrac","mglyph","mi","mlabeledtr","mmultiscripts","mn","mo","mover","mpadded","mphantom","mroot","mrow","ms","mspace","msqrt","mstyle","msub","msup","msubsup","mtable","mtd","mtext","mtr","munder","munderover"]),mathMlDisallowed$1=freeze$1(["maction","maligngroup","malignmark","mlongdiv","mscarries","mscarry","msgroup","mstack","msline","msrow","semantics","annotation","annotation-xml","mprescripts","none"]),text$1$1=freeze$1(["#text"]),html$2=freeze$1(["accept","action","align","alt","autocapitalize","autocomplete","autopictureinpicture","autoplay","background","bgcolor","border","capture","cellpadding","cellspacing","checked","cite","class","clear","color","cols","colspan","controls","controlslist","coords","crossorigin","datetime","decoding","default","dir","disabled","disablepictureinpicture","disableremoteplayback","download","draggable","enctype","enterkeyhint","face","for","headers","height","hidden","high","href","hreflang","id","inputmode","integrity","ismap","kind","label","lang","list","loading","loop","low","max","maxlength","media","method","min","minlength","multiple","muted","name","nonce","noshade","novalidate","nowrap","open","optimum","pattern","placeholder","playsinline","poster","preload","pubdate","radiogroup","readonly","rel","required","rev","reversed","role","rows","rowspan","spellcheck","scope","selected","shape","size","sizes","span","srclang","start","src","srcset","step","style","summary","tabindex","title","translate","type","usemap","valign","value","width","xmlns","slot"]),svg$2=freeze$1(["accent-height","accumulate","additive","alignment-baseline","ascent","attributename","attributetype","azimuth","basefrequency","baseline-shift","begin","bias","by","class","clip","clippathunits","clip-path","clip-rule","color","color-interpolation","color-interpolation-filters","color-profile","color-rendering","cx","cy","d","dx","dy","diffuseconstant","direction","display","divisor","dur","edgemode","elevation","end","fill","fill-opacity","fill-rule","filter","filterunits","flood-color","flood-opacity","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","fx","fy","g1","g2","glyph-name","glyphref","gradientunits","gradienttransform","height","href","id","image-rendering","in","in2","k","k1","k2","k3","k4","kerning","keypoints","keysplines","keytimes","lang","lengthadjust","letter-spacing","kernelmatrix","kernelunitlength","lighting-color","local","marker-end","marker-mid","marker-start","markerheight","markerunits","markerwidth","maskcontentunits","maskunits","max","mask","media","method","mode","min","name","numoctaves","offset","operator","opacity","order","orient","orientation","origin","overflow","paint-order","path","pathlength","patterncontentunits","patterntransform","patternunits","points","preservealpha","preserveaspectratio","primitiveunits","r","rx","ry","radius","refx","refy","repeatcount","repeatdur","restart","result","rotate","scale","seed","shape-rendering","specularconstant","specularexponent","spreadmethod","startoffset","stddeviation","stitchtiles","stop-color","stop-opacity","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke","stroke-width","style","surfacescale","systemlanguage","tabindex","targetx","targety","transform","transform-origin","text-anchor","text-decoration","text-rendering","textlength","type","u1","u2","unicode","values","viewbox","visibility","version","vert-adv-y","vert-origin-x","vert-origin-y","width","word-spacing","wrap","writing-mode","xchannelselector","ychannelselector","x","x1","x2","xmlns","y","y1","y2","z","zoomandpan"]),mathMl$2=freeze$1(["accent","accentunder","align","bevelled","close","columnsalign","columnlines","columnspan","denomalign","depth","dir","display","displaystyle","encoding","fence","frame","height","href","id","largeop","length","linethickness","lspace","lquote","mathbackground","mathcolor","mathsize","mathvariant","maxsize","minsize","movablelimits","notation","numalign","open","rowalign","rowlines","rowspacing","rowspan","rspace","rquote","scriptlevel","scriptminsize","scriptsizemultiplier","selection","separator","separators","stretchy","subscriptshift","supscriptshift","symmetric","voffset","width","xmlns"]),xml$1=freeze$1(["xlink:href","xml:id","xlink:title","xml:space","xmlns:xlink"]),MUSTACHE_EXPR$1=seal$1(/\{\{[\w\W]*|[\w\W]*\}\}/gm),ERB_EXPR$1=seal$1(/<%[\w\W]*|[\w\W]*%>/gm),DATA_ATTR$1=seal$1(/^data-[\-\w.\u00B7-\uFFFF]/),ARIA_ATTR$1=seal$1(/^aria-[\-\w]+$/),IS_ALLOWED_URI$1=seal$1(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i),IS_SCRIPT_OR_DATA$1=seal$1(/^(?:\w+script|data):/i),ATTR_WHITESPACE$1=seal$1(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),DOCTYPE_NAME$1=seal$1(/^html$/i),getGlobal$1=function(){return"undefined"===typeof window?null:window},_createTrustedTypesPolicy$1=function(trustedTypes,document){if("object"!==_typeof$2$1(trustedTypes)||"function"!==typeof trustedTypes.createPolicy)return null;// Allow the callers to control the unique policy name
// by adding a data-tt-policy-suffix to the script element with the DOMPurify.
// Policy creation with duplicate names throws in Trusted Types.
var suffix=null,ATTR_NAME="data-tt-policy-suffix";document.currentScript&&document.currentScript.hasAttribute(ATTR_NAME)&&(suffix=document.currentScript.getAttribute(ATTR_NAME));var policyName="dompurify"+(suffix?"#"+suffix:"");try{return trustedTypes.createPolicy(policyName,{createHTML:function(html){return html},createScriptURL:function(scriptUrl){return scriptUrl}})}catch(_){return null}};// SVG
function createDOMPurify$1(){var window=arguments.length>0&&void 0!==arguments[0]?arguments[0]:getGlobal$1(),DOMPurify=function(root){return createDOMPurify$1(root)};if(
/**
   * Version label, exposed for easier checks
   * if DOMPurify is up to date or not
   */
DOMPurify.version="2.3.10",
/**
   * Array of elements that DOMPurify removed during sanitation.
   * Empty if nothing was removed.
   */
DOMPurify.removed=[],!window||!window.document||9!==window.document.nodeType)
// Not running in a browser, provide a factory function
// so that you can pass your own Window
return DOMPurify.isSupported=!1,DOMPurify;var originalDocument=window.document,document=window.document,DocumentFragment=window.DocumentFragment,HTMLTemplateElement=window.HTMLTemplateElement,Node=window.Node,Element=window.Element,NodeFilter=window.NodeFilter,_window$NamedNodeMap=window.NamedNodeMap,NamedNodeMap=void 0===_window$NamedNodeMap?window.NamedNodeMap||window.MozNamedAttrMap:_window$NamedNodeMap,HTMLFormElement=window.HTMLFormElement,DOMParser=window.DOMParser,trustedTypes=window.trustedTypes,ElementPrototype=Element.prototype,cloneNode=lookupGetter$1(ElementPrototype,"cloneNode"),getNextSibling=lookupGetter$1(ElementPrototype,"nextSibling"),getChildNodes=lookupGetter$1(ElementPrototype,"childNodes"),getParentNode=lookupGetter$1(ElementPrototype,"parentNode");// As per issue #47, the web-components registry is inherited by a
// new document created via createHTMLDocument. As per the spec
// (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
// a new empty registry is used when creating a template contents owner
// document, so we use that as our parent document to ensure nothing
// is inherited.
if("function"===typeof HTMLTemplateElement){var template=document.createElement("template");template.content&&template.content.ownerDocument&&(document=template.content.ownerDocument)}var trustedTypesPolicy=_createTrustedTypesPolicy$1(trustedTypes,originalDocument),emptyHTML=trustedTypesPolicy?trustedTypesPolicy.createHTML(""):"",_document=document,implementation=_document.implementation,createNodeIterator=_document.createNodeIterator,createDocumentFragment=_document.createDocumentFragment,getElementsByTagName=_document.getElementsByTagName,importNode=originalDocument.importNode,documentMode={};try{documentMode=clone$1(document).documentMode?document.documentMode:{}}catch(_){}var hooks={};
/**
   * Expose whether this browser supports running the full DOMPurify.
   */DOMPurify.isSupported="function"===typeof getParentNode&&implementation&&"undefined"!==typeof implementation.createHTMLDocument&&9!==documentMode;var PARSER_MEDIA_TYPE,transformCaseFunc,MUSTACHE_EXPR$1$1=MUSTACHE_EXPR$1,ERB_EXPR$1$1=ERB_EXPR$1,DATA_ATTR$1$1=DATA_ATTR$1,ARIA_ATTR$1$1=ARIA_ATTR$1,IS_SCRIPT_OR_DATA$1$1=IS_SCRIPT_OR_DATA$1,ATTR_WHITESPACE$1$1=ATTR_WHITESPACE$1,IS_ALLOWED_URI$1$1=IS_ALLOWED_URI$1,ALLOWED_TAGS=null,DEFAULT_ALLOWED_TAGS=addToSet$1({},[].concat(_toConsumableArray$2(html$1$1),_toConsumableArray$2(svg$1$1),_toConsumableArray$2(svgFilters$1),_toConsumableArray$2(mathMl$1$1),_toConsumableArray$2(text$1$1))),ALLOWED_ATTR=null,DEFAULT_ALLOWED_ATTR=addToSet$1({},[].concat(_toConsumableArray$2(html$2),_toConsumableArray$2(svg$2),_toConsumableArray$2(mathMl$2),_toConsumableArray$2(xml$1))),CUSTOM_ELEMENT_HANDLING=Object.seal(Object.create(null,{tagNameCheck:{writable:!0,configurable:!1,enumerable:!0,value:null},attributeNameCheck:{writable:!0,configurable:!1,enumerable:!0,value:null},allowCustomizedBuiltInElements:{writable:!0,configurable:!1,enumerable:!0,value:!1}})),FORBID_TAGS=null,FORBID_ATTR=null,ALLOW_ARIA_ATTR=!0,ALLOW_DATA_ATTR=!0,ALLOW_UNKNOWN_PROTOCOLS=!1,SAFE_FOR_TEMPLATES=!1,WHOLE_DOCUMENT=!1,SET_CONFIG=!1,FORCE_BODY=!1,RETURN_DOM=!1,RETURN_DOM_FRAGMENT=!1,RETURN_TRUSTED_TYPE=!1,SANITIZE_DOM=!0,KEEP_CONTENT=!0,IN_PLACE=!1,USE_PROFILES={},FORBID_CONTENTS=null,DEFAULT_FORBID_CONTENTS=addToSet$1({},["annotation-xml","audio","colgroup","desc","foreignobject","head","iframe","math","mi","mn","mo","ms","mtext","noembed","noframes","noscript","plaintext","script","style","svg","template","thead","title","video","xmp"]),DATA_URI_TAGS=null,DEFAULT_DATA_URI_TAGS=addToSet$1({},["audio","video","img","source","image","track"]),URI_SAFE_ATTRIBUTES=null,DEFAULT_URI_SAFE_ATTRIBUTES=addToSet$1({},["alt","class","for","id","label","name","pattern","placeholder","role","summary","title","value","style","xmlns"]),MATHML_NAMESPACE="http://www.w3.org/1998/Math/MathML",SVG_NAMESPACE="http://www.w3.org/2000/svg",HTML_NAMESPACE="http://www.w3.org/1999/xhtml",NAMESPACE=HTML_NAMESPACE,IS_EMPTY_INPUT=!1,SUPPORTED_PARSER_MEDIA_TYPES=["application/xhtml+xml","text/html"],DEFAULT_PARSER_MEDIA_TYPE="text/html",CONFIG=null,formElement=document.createElement("form"),isRegexOrFunction=function(testValue){return testValue instanceof RegExp||testValue instanceof Function},_parseConfig=function(cfg){CONFIG&&CONFIG===cfg||(
/* Shield configuration object from tampering */
cfg&&"object"===_typeof$2$1(cfg)||(cfg={})
/* Shield configuration object from prototype pollution */,cfg=clone$1(cfg),PARSER_MEDIA_TYPE=// eslint-disable-next-line unicorn/prefer-includes
PARSER_MEDIA_TYPE=-1===SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE)?DEFAULT_PARSER_MEDIA_TYPE:cfg.PARSER_MEDIA_TYPE,// HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
transformCaseFunc="application/xhtml+xml"===PARSER_MEDIA_TYPE?function(x){return x}:stringToLowerCase$1,
/* Set configuration parameters */
ALLOWED_TAGS="ALLOWED_TAGS"in cfg?addToSet$1({},cfg.ALLOWED_TAGS,transformCaseFunc):DEFAULT_ALLOWED_TAGS,ALLOWED_ATTR="ALLOWED_ATTR"in cfg?addToSet$1({},cfg.ALLOWED_ATTR,transformCaseFunc):DEFAULT_ALLOWED_ATTR,URI_SAFE_ATTRIBUTES="ADD_URI_SAFE_ATTR"in cfg?addToSet$1(clone$1(DEFAULT_URI_SAFE_ATTRIBUTES),// eslint-disable-line indent
cfg.ADD_URI_SAFE_ATTR,// eslint-disable-line indent
transformCaseFunc):DEFAULT_URI_SAFE_ATTRIBUTES,DATA_URI_TAGS="ADD_DATA_URI_TAGS"in cfg?addToSet$1(clone$1(DEFAULT_DATA_URI_TAGS),// eslint-disable-line indent
cfg.ADD_DATA_URI_TAGS,// eslint-disable-line indent
transformCaseFunc):DEFAULT_DATA_URI_TAGS,FORBID_CONTENTS="FORBID_CONTENTS"in cfg?addToSet$1({},cfg.FORBID_CONTENTS,transformCaseFunc):DEFAULT_FORBID_CONTENTS,FORBID_TAGS="FORBID_TAGS"in cfg?addToSet$1({},cfg.FORBID_TAGS,transformCaseFunc):{},FORBID_ATTR="FORBID_ATTR"in cfg?addToSet$1({},cfg.FORBID_ATTR,transformCaseFunc):{},USE_PROFILES="USE_PROFILES"in cfg&&cfg.USE_PROFILES,ALLOW_ARIA_ATTR=!1!==cfg.ALLOW_ARIA_ATTR,// Default true
ALLOW_DATA_ATTR=!1!==cfg.ALLOW_DATA_ATTR,// Default true
ALLOW_UNKNOWN_PROTOCOLS=cfg.ALLOW_UNKNOWN_PROTOCOLS||!1,// Default false
SAFE_FOR_TEMPLATES=cfg.SAFE_FOR_TEMPLATES||!1,// Default false
WHOLE_DOCUMENT=cfg.WHOLE_DOCUMENT||!1,// Default false
RETURN_DOM=cfg.RETURN_DOM||!1,// Default false
RETURN_DOM_FRAGMENT=cfg.RETURN_DOM_FRAGMENT||!1,// Default false
RETURN_TRUSTED_TYPE=cfg.RETURN_TRUSTED_TYPE||!1,// Default false
FORCE_BODY=cfg.FORCE_BODY||!1,// Default false
SANITIZE_DOM=!1!==cfg.SANITIZE_DOM,// Default true
KEEP_CONTENT=!1!==cfg.KEEP_CONTENT,// Default true
IN_PLACE=cfg.IN_PLACE||!1,// Default false
IS_ALLOWED_URI$1$1=cfg.ALLOWED_URI_REGEXP||IS_ALLOWED_URI$1$1,NAMESPACE=cfg.NAMESPACE||HTML_NAMESPACE,cfg.CUSTOM_ELEMENT_HANDLING&&isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)&&(CUSTOM_ELEMENT_HANDLING.tagNameCheck=cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck),cfg.CUSTOM_ELEMENT_HANDLING&&isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)&&(CUSTOM_ELEMENT_HANDLING.attributeNameCheck=cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck),cfg.CUSTOM_ELEMENT_HANDLING&&"boolean"===typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements&&(CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements=cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements),SAFE_FOR_TEMPLATES&&(ALLOW_DATA_ATTR=!1),RETURN_DOM_FRAGMENT&&(RETURN_DOM=!0)
/* Parse profile info */,USE_PROFILES&&(ALLOWED_TAGS=addToSet$1({},_toConsumableArray$2(text$1$1)),ALLOWED_ATTR=[],!0===USE_PROFILES.html&&(addToSet$1(ALLOWED_TAGS,html$1$1),addToSet$1(ALLOWED_ATTR,html$2)),!0===USE_PROFILES.svg&&(addToSet$1(ALLOWED_TAGS,svg$1$1),addToSet$1(ALLOWED_ATTR,svg$2),addToSet$1(ALLOWED_ATTR,xml$1)),!0===USE_PROFILES.svgFilters&&(addToSet$1(ALLOWED_TAGS,svgFilters$1),addToSet$1(ALLOWED_ATTR,svg$2),addToSet$1(ALLOWED_ATTR,xml$1)),!0===USE_PROFILES.mathMl&&(addToSet$1(ALLOWED_TAGS,mathMl$1$1),addToSet$1(ALLOWED_ATTR,mathMl$2),addToSet$1(ALLOWED_ATTR,xml$1)))
/* Merge configuration parameters */,cfg.ADD_TAGS&&(ALLOWED_TAGS===DEFAULT_ALLOWED_TAGS&&(ALLOWED_TAGS=clone$1(ALLOWED_TAGS)),addToSet$1(ALLOWED_TAGS,cfg.ADD_TAGS,transformCaseFunc)),cfg.ADD_ATTR&&(ALLOWED_ATTR===DEFAULT_ALLOWED_ATTR&&(ALLOWED_ATTR=clone$1(ALLOWED_ATTR)),addToSet$1(ALLOWED_ATTR,cfg.ADD_ATTR,transformCaseFunc)),cfg.ADD_URI_SAFE_ATTR&&addToSet$1(URI_SAFE_ATTRIBUTES,cfg.ADD_URI_SAFE_ATTR,transformCaseFunc),cfg.FORBID_CONTENTS&&(FORBID_CONTENTS===DEFAULT_FORBID_CONTENTS&&(FORBID_CONTENTS=clone$1(FORBID_CONTENTS)),addToSet$1(FORBID_CONTENTS,cfg.FORBID_CONTENTS,transformCaseFunc))
/* Add #text in case KEEP_CONTENT is set to true */,KEEP_CONTENT&&(ALLOWED_TAGS["#text"]=!0)
/* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */,WHOLE_DOCUMENT&&addToSet$1(ALLOWED_TAGS,["html","head","body"])
/* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */,ALLOWED_TAGS.table&&(addToSet$1(ALLOWED_TAGS,["tbody"]),delete FORBID_TAGS.tbody),// Prevent further manipulation of configuration.
// Not available in IE8, Safari 5, etc.
freeze$1&&freeze$1(cfg),CONFIG=cfg)},MATHML_TEXT_INTEGRATION_POINTS=addToSet$1({},["mi","mo","mn","ms","mtext"]),HTML_INTEGRATION_POINTS=addToSet$1({},["foreignobject","desc","title","annotation-xml"]),COMMON_SVG_AND_HTML_ELEMENTS=addToSet$1({},["title","style","font","a","script"]),ALL_SVG_TAGS=addToSet$1({},svg$1$1);addToSet$1(ALL_SVG_TAGS,svgFilters$1),addToSet$1(ALL_SVG_TAGS,svgDisallowed$1);var ALL_MATHML_TAGS=addToSet$1({},mathMl$1$1);addToSet$1(ALL_MATHML_TAGS,mathMlDisallowed$1);
/**
   *
   *
   * @param  {Element} element a DOM element whose namespace is being checked
   * @returns {boolean} Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */
var _checkValidNamespace=function(element){var parent=getParentNode(element);// In JSDOM, if we're inside shadow DOM, then parentNode
// can be null. We just simulate parent in this case.
parent&&parent.tagName||(parent={namespaceURI:HTML_NAMESPACE,tagName:"template"});var tagName=stringToLowerCase$1(element.tagName),parentTagName=stringToLowerCase$1(parent.tagName);return element.namespaceURI===SVG_NAMESPACE?
// The only way to switch from HTML namespace to SVG
// is via <svg>. If it happens via any other tag, then
// it should be killed.
parent.namespaceURI===HTML_NAMESPACE?"svg"===tagName:// The only way to switch from MathML to SVG is via
// svg if parent is either <annotation-xml> or MathML
// text integration points.
parent.namespaceURI===MATHML_NAMESPACE?"svg"===tagName&&("annotation-xml"===parentTagName||MATHML_TEXT_INTEGRATION_POINTS[parentTagName]):Boolean(ALL_SVG_TAGS[tagName]):element.namespaceURI===MATHML_NAMESPACE?
// The only way to switch from HTML namespace to MathML
// is via <math>. If it happens via any other tag, then
// it should be killed.
parent.namespaceURI===HTML_NAMESPACE?"math"===tagName:// The only way to switch from SVG to MathML is via
// <math> and HTML integration points
parent.namespaceURI===SVG_NAMESPACE?"math"===tagName&&HTML_INTEGRATION_POINTS[parentTagName]:Boolean(ALL_MATHML_TAGS[tagName]):element.namespaceURI===HTML_NAMESPACE&&(
// The only way to switch from SVG to HTML is via
// HTML integration points, and from MathML to HTML
// is via MathML text integration points
!(parent.namespaceURI===SVG_NAMESPACE&&!HTML_INTEGRATION_POINTS[parentTagName])&&(!(parent.namespaceURI===MATHML_NAMESPACE&&!MATHML_TEXT_INTEGRATION_POINTS[parentTagName])&&(!ALL_MATHML_TAGS[tagName]&&(COMMON_SVG_AND_HTML_ELEMENTS[tagName]||!ALL_SVG_TAGS[tagName]))))},_forceRemove=function(node){arrayPush$1(DOMPurify.removed,{element:node});try{
// eslint-disable-next-line unicorn/prefer-dom-node-remove
node.parentNode.removeChild(node)}catch(_){try{node.outerHTML=emptyHTML}catch(_){node.remove()}}},_removeAttribute=function(name,node){try{arrayPush$1(DOMPurify.removed,{attribute:node.getAttributeNode(name),from:node})}catch(_){arrayPush$1(DOMPurify.removed,{attribute:null,from:node})}// We void attribute values for unremovable "is"" attributes
if(node.removeAttribute(name),"is"===name&&!ALLOWED_ATTR[name])if(RETURN_DOM||RETURN_DOM_FRAGMENT)try{_forceRemove(node)}catch(_){}else try{node.setAttribute(name,"")}catch(_){}},_initDocument=function(dirty){
/* Create a HTML document */
var doc,leadingWhitespace;if(FORCE_BODY)dirty="<remove></remove>"+dirty;else{
/* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
var matches=stringMatch$1(dirty,/^[\r\n\t ]+/);leadingWhitespace=matches&&matches[0]}"application/xhtml+xml"===PARSER_MEDIA_TYPE&&(
// Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
dirty='<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>'+dirty+"</body></html>");var dirtyPayload=trustedTypesPolicy?trustedTypesPolicy.createHTML(dirty):dirty;
/*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */if(NAMESPACE===HTML_NAMESPACE)try{doc=(new DOMParser).parseFromString(dirtyPayload,PARSER_MEDIA_TYPE)}catch(_){}
/* Use createHTMLDocument in case DOMParser is not available */if(!doc||!doc.documentElement){doc=implementation.createDocument(NAMESPACE,"template",null);try{doc.documentElement.innerHTML=IS_EMPTY_INPUT?"":dirtyPayload}catch(_){// Syntax error if dirtyPayload is invalid xml
}}var body=doc.body||doc.documentElement;
/* Work on whole document or just its body */
return dirty&&leadingWhitespace&&body.insertBefore(document.createTextNode(leadingWhitespace),body.childNodes[0]||null),NAMESPACE===HTML_NAMESPACE?getElementsByTagName.call(doc,WHOLE_DOCUMENT?"html":"body")[0]:WHOLE_DOCUMENT?doc.documentElement:body},_createIterator=function(root){return createNodeIterator.call(root.ownerDocument||root,root,// eslint-disable-next-line no-bitwise
NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT|NodeFilter.SHOW_TEXT,null,!1)},_isClobbered=function(elm){return elm instanceof HTMLFormElement&&("string"!==typeof elm.nodeName||"string"!==typeof elm.textContent||"function"!==typeof elm.removeChild||!(elm.attributes instanceof NamedNodeMap)||"function"!==typeof elm.removeAttribute||"function"!==typeof elm.setAttribute||"string"!==typeof elm.namespaceURI||"function"!==typeof elm.insertBefore)},_isNode=function(object){return"object"===_typeof$2$1(Node)?object instanceof Node:object&&"object"===_typeof$2$1(object)&&"number"===typeof object.nodeType&&"string"===typeof object.nodeName},_executeHook=function(entryPoint,currentNode,data){hooks[entryPoint]&&arrayForEach$1(hooks[entryPoint],(function(hook){hook.call(DOMPurify,currentNode,data,CONFIG)}))},_sanitizeElements=function(currentNode){var content;
/* Execute a hook if present */
/* Check if element is clobbered or can clobber */
if(_executeHook("beforeSanitizeElements",currentNode,null),_isClobbered(currentNode))return _forceRemove(currentNode),!0;
/* Check if tagname contains Unicode */if(regExpTest$1(/[\u0080-\uFFFF]/,currentNode.nodeName))return _forceRemove(currentNode),!0;
/* Now let's check the element's type and name */var tagName=transformCaseFunc(currentNode.nodeName);
/* Execute a hook if present */
/* Detect mXSS attempts abusing namespace confusion */
if(_executeHook("uponSanitizeElement",currentNode,{tagName:tagName,allowedTags:ALLOWED_TAGS}),currentNode.hasChildNodes()&&!_isNode(currentNode.firstElementChild)&&(!_isNode(currentNode.content)||!_isNode(currentNode.content.firstElementChild))&&regExpTest$1(/<[/\w]/g,currentNode.innerHTML)&&regExpTest$1(/<[/\w]/g,currentNode.textContent))return _forceRemove(currentNode),!0;
/* Mitigate a problem with templates inside select */if("select"===tagName&&regExpTest$1(/<template/i,currentNode.innerHTML))return _forceRemove(currentNode),!0;
/* Remove element if anything forbids its presence */if(!ALLOWED_TAGS[tagName]||FORBID_TAGS[tagName]){
/* Check if we have a custom element to handle */
if(!FORBID_TAGS[tagName]&&_basicCustomElementTest(tagName)){if(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp&&regExpTest$1(CUSTOM_ELEMENT_HANDLING.tagNameCheck,tagName))return!1;if(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))return!1}
/* Keep content except for bad-listed elements */if(KEEP_CONTENT&&!FORBID_CONTENTS[tagName]){var parentNode=getParentNode(currentNode)||currentNode.parentNode,childNodes=getChildNodes(currentNode)||currentNode.childNodes;if(childNodes&&parentNode)for(var childCount=childNodes.length,i=childCount-1;i>=0;--i)parentNode.insertBefore(cloneNode(childNodes[i],!0),getNextSibling(currentNode))}return _forceRemove(currentNode),!0}
/* Check whether element has a valid namespace */return currentNode instanceof Element&&!_checkValidNamespace(currentNode)?(_forceRemove(currentNode),!0):"noscript"!==tagName&&"noembed"!==tagName||!regExpTest$1(/<\/no(script|embed)/i,currentNode.innerHTML)?(
/* Sanitize element content to be template-safe */
SAFE_FOR_TEMPLATES&&3===currentNode.nodeType&&(
/* Get the element's text content */
content=currentNode.textContent,content=stringReplace$1(content,MUSTACHE_EXPR$1$1," "),content=stringReplace$1(content,ERB_EXPR$1$1," "),currentNode.textContent!==content&&(arrayPush$1(DOMPurify.removed,{element:currentNode.cloneNode()}),currentNode.textContent=content))
/* Execute a hook if present */,_executeHook("afterSanitizeElements",currentNode,null),!1):(_forceRemove(currentNode),!0)},_isValidAttribute=function(lcTag,lcName,value){
/* Make sure attribute cannot clobber */
if(SANITIZE_DOM&&("id"===lcName||"name"===lcName)&&(value in document||value in formElement))return!1;
/* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */if(ALLOW_DATA_ATTR&&!FORBID_ATTR[lcName]&&regExpTest$1(DATA_ATTR$1$1,lcName));else if(ALLOW_ARIA_ATTR&&regExpTest$1(ARIA_ATTR$1$1,lcName));else if(!ALLOWED_ATTR[lcName]||FORBID_ATTR[lcName]){if(// First condition does a very basic check if a) it's basically a valid custom element tagname AND
// b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
// and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
!(_basicCustomElementTest(lcTag)&&(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp&&regExpTest$1(CUSTOM_ELEMENT_HANDLING.tagNameCheck,lcTag)||CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag))&&(CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp&&regExpTest$1(CUSTOM_ELEMENT_HANDLING.attributeNameCheck,lcName)||CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName))||// Alternative, second condition checks if it's an `is`-attribute, AND
// the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
"is"===lcName&&CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements&&(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp&&regExpTest$1(CUSTOM_ELEMENT_HANDLING.tagNameCheck,value)||CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))))return!1;
/* Check value is safe. First, is attr inert? If so, is safe */}else if(URI_SAFE_ATTRIBUTES[lcName]);else if(regExpTest$1(IS_ALLOWED_URI$1$1,stringReplace$1(value,ATTR_WHITESPACE$1$1,"")));else if("src"!==lcName&&"xlink:href"!==lcName&&"href"!==lcName||"script"===lcTag||0!==stringIndexOf$1(value,"data:")||!DATA_URI_TAGS[lcTag]){if(ALLOW_UNKNOWN_PROTOCOLS&&!regExpTest$1(IS_SCRIPT_OR_DATA$1$1,stringReplace$1(value,ATTR_WHITESPACE$1$1,"")));else if(value)return!1}else;return!0},_basicCustomElementTest=function(tagName){return tagName.indexOf("-")>0},_sanitizeAttributes=function(currentNode){var attr,value,lcName,l;
/* Execute a hook if present */
_executeHook("beforeSanitizeAttributes",currentNode,null);var attributes=currentNode.attributes;
/* Check if we have attributes; if not we might have a text node */if(attributes){var hookEvent={attrName:"",attrValue:"",keepAttr:!0,allowedAttributes:ALLOWED_ATTR};l=attributes.length;
/* Go backwards over all attributes; safely remove bad ones */
while(l--){attr=attributes[l];var _attr=attr,name=_attr.name,namespaceURI=_attr.namespaceURI;
/* Did the hooks approve of the attribute? */
if(value="value"===name?attr.value:stringTrim$1(attr.value),lcName=transformCaseFunc(name),
/* Execute a hook if present */
hookEvent.attrName=lcName,hookEvent.attrValue=value,hookEvent.keepAttr=!0,hookEvent.forceKeepAttr=void 0,// Allows developers to see this is a property they can set
_executeHook("uponSanitizeAttribute",currentNode,hookEvent),value=hookEvent.attrValue,!hookEvent.forceKeepAttr&&(
/* Remove attribute */
_removeAttribute(name,currentNode),hookEvent.keepAttr))
/* Work around a security issue in jQuery 3.0 */
if(regExpTest$1(/\/>/i,value))_removeAttribute(name,currentNode);else{
/* Sanitize attribute content to be template-safe */
SAFE_FOR_TEMPLATES&&(value=stringReplace$1(value,MUSTACHE_EXPR$1$1," "),value=stringReplace$1(value,ERB_EXPR$1$1," "))
/* Is `value` valid for this attribute? */;var lcTag=transformCaseFunc(currentNode.nodeName);if(_isValidAttribute(lcTag,lcName,value)){
/* Handle attributes that require Trusted Types */
if(trustedTypesPolicy&&"object"===_typeof$2$1(trustedTypes)&&"function"===typeof trustedTypes.getAttributeType)if(namespaceURI);else switch(trustedTypes.getAttributeType(lcTag,lcName)){case"TrustedHTML":value=trustedTypesPolicy.createHTML(value);break;case"TrustedScriptURL":value=trustedTypesPolicy.createScriptURL(value);break}
/* Handle invalid data-* attribute set by try-catching it */try{namespaceURI?currentNode.setAttributeNS(namespaceURI,name,value):
/* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
currentNode.setAttribute(name,value),arrayPop$1(DOMPurify.removed)}catch(_){}}}}
/* Execute a hook if present */_executeHook("afterSanitizeAttributes",currentNode,null)}},_sanitizeShadowDOM=function _sanitizeShadowDOM(fragment){var shadowNode,shadowIterator=_createIterator(fragment);
/* Execute a hook if present */
_executeHook("beforeSanitizeShadowDOM",fragment,null);while(shadowNode=shadowIterator.nextNode())
/* Execute a hook if present */
_executeHook("uponSanitizeShadowNode",shadowNode,null),
/* Sanitize tags and elements */
_sanitizeElements(shadowNode)||(
/* Deep shadow DOM detected */
shadowNode.content instanceof DocumentFragment&&_sanitizeShadowDOM(shadowNode.content)
/* Check attributes, sanitize if necessary */,_sanitizeAttributes(shadowNode));
/* Execute a hook if present */_executeHook("afterSanitizeShadowDOM",fragment,null)};
/**
   * _forceRemove
   *
   * @param  {Node} node a DOM node
   */
/**
   * Sanitize
   * Public method providing core sanitation functionality
   *
   * @param {String|Node} dirty string or DOM node
   * @param {Object} configuration object
   */
// eslint-disable-next-line complexity
return DOMPurify.sanitize=function(dirty,cfg){var body,importedNode,currentNode,oldNode,returnNode;
/* Stringify, in case dirty is an object */
if(
/* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
IS_EMPTY_INPUT=!dirty,IS_EMPTY_INPUT&&(dirty="\x3c!--\x3e"),"string"!==typeof dirty&&!_isNode(dirty)){
// eslint-disable-next-line no-negated-condition
if("function"!==typeof dirty.toString)throw typeErrorCreate$1("toString is not a function");if(dirty=dirty.toString(),"string"!==typeof dirty)throw typeErrorCreate$1("dirty is not a string, aborting")}
/* Check we can run. Otherwise fall back or ignore */if(!DOMPurify.isSupported){if("object"===_typeof$2$1(window.toStaticHTML)||"function"===typeof window.toStaticHTML){if("string"===typeof dirty)return window.toStaticHTML(dirty);if(_isNode(dirty))return window.toStaticHTML(dirty.outerHTML)}return dirty}
/* Assign config vars */if(SET_CONFIG||_parseConfig(cfg)
/* Clean up removed elements */,DOMPurify.removed=[],
/* Check if dirty is correctly typed for IN_PLACE */
"string"===typeof dirty&&(IN_PLACE=!1),IN_PLACE){
/* Do some early pre-sanitization to avoid unsafe root nodes */
if(dirty.nodeName){var tagName=transformCaseFunc(dirty.nodeName);if(!ALLOWED_TAGS[tagName]||FORBID_TAGS[tagName])throw typeErrorCreate$1("root node is forbidden and cannot be sanitized in-place")}}else if(dirty instanceof Node)
/* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
body=_initDocument("\x3c!----\x3e"),importedNode=body.ownerDocument.importNode(dirty,!0),1===importedNode.nodeType&&"BODY"===importedNode.nodeName||"HTML"===importedNode.nodeName?
/* Node is already a body, use as is */
body=importedNode:
// eslint-disable-next-line unicorn/prefer-dom-node-append
body.appendChild(importedNode);else{
/* Exit directly if we have nothing to do */
if(!RETURN_DOM&&!SAFE_FOR_TEMPLATES&&!WHOLE_DOCUMENT&&// eslint-disable-next-line unicorn/prefer-includes
-1===dirty.indexOf("<"))return trustedTypesPolicy&&RETURN_TRUSTED_TYPE?trustedTypesPolicy.createHTML(dirty):dirty;
/* Initialize the document to work on */
/* Check we have a DOM node from the data */
if(body=_initDocument(dirty),!body)return RETURN_DOM?null:RETURN_TRUSTED_TYPE?emptyHTML:""}
/* Remove first element node (ours) if FORCE_BODY is set */body&&FORCE_BODY&&_forceRemove(body.firstChild)
/* Get node iterator */;var nodeIterator=_createIterator(IN_PLACE?dirty:body);
/* Now start iterating over the created document */while(currentNode=nodeIterator.nextNode())
/* Fix IE's strange behavior with manipulated textNodes #89 */
3===currentNode.nodeType&&currentNode===oldNode||_sanitizeElements(currentNode)||(
/* Shadow DOM detected, sanitize it */
currentNode.content instanceof DocumentFragment&&_sanitizeShadowDOM(currentNode.content)
/* Check attributes, sanitize if necessary */,_sanitizeAttributes(currentNode),oldNode=currentNode)
/* Sanitize tags and elements */;
/* If we sanitized `dirty` in-place, return it. */
if(oldNode=null,IN_PLACE)return dirty;
/* Return sanitized string or DOM */if(RETURN_DOM){if(RETURN_DOM_FRAGMENT){returnNode=createDocumentFragment.call(body.ownerDocument);while(body.firstChild)
// eslint-disable-next-line unicorn/prefer-dom-node-append
returnNode.appendChild(body.firstChild)}else returnNode=body;return ALLOWED_ATTR.shadowroot&&(
/*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
returnNode=importNode.call(originalDocument,returnNode,!0)),returnNode}var serializedHTML=WHOLE_DOCUMENT?body.outerHTML:body.innerHTML;
/* Serialize doctype if allowed */return WHOLE_DOCUMENT&&ALLOWED_TAGS["!doctype"]&&body.ownerDocument&&body.ownerDocument.doctype&&body.ownerDocument.doctype.name&&regExpTest$1(DOCTYPE_NAME$1,body.ownerDocument.doctype.name)&&(serializedHTML="<!DOCTYPE "+body.ownerDocument.doctype.name+">\n"+serializedHTML)
/* Sanitize final string template-safe */,SAFE_FOR_TEMPLATES&&(serializedHTML=stringReplace$1(serializedHTML,MUSTACHE_EXPR$1$1," "),serializedHTML=stringReplace$1(serializedHTML,ERB_EXPR$1$1," ")),trustedTypesPolicy&&RETURN_TRUSTED_TYPE?trustedTypesPolicy.createHTML(serializedHTML):serializedHTML},
/**
   * Public method to set the configuration once
   * setConfig
   *
   * @param {Object} cfg configuration object
   */
DOMPurify.setConfig=function(cfg){_parseConfig(cfg),SET_CONFIG=!0},
/**
   * Public method to remove the configuration
   * clearConfig
   *
   */
DOMPurify.clearConfig=function(){CONFIG=null,SET_CONFIG=!1},
/**
   * Public method to check if an attribute value is valid.
   * Uses last set config, if any. Otherwise, uses config defaults.
   * isValidAttribute
   *
   * @param  {string} tag Tag name of containing element.
   * @param  {string} attr Attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
   */
DOMPurify.isValidAttribute=function(tag,attr,value){
/* Initialize shared config vars if necessary. */
CONFIG||_parseConfig({});var lcTag=transformCaseFunc(tag),lcName=transformCaseFunc(attr);return _isValidAttribute(lcTag,lcName,value)},
/**
   * AddHook
   * Public method to add DOMPurify hooks
   *
   * @param {String} entryPoint entry point for the hook to add
   * @param {Function} hookFunction function to execute
   */
DOMPurify.addHook=function(entryPoint,hookFunction){"function"===typeof hookFunction&&(hooks[entryPoint]=hooks[entryPoint]||[],arrayPush$1(hooks[entryPoint],hookFunction))},
/**
   * RemoveHook
   * Public method to remove a DOMPurify hook at a given entryPoint
   * (pops it from the stack of hooks if more are present)
   *
   * @param {String} entryPoint entry point for the hook to remove
   * @return {Function} removed(popped) hook
   */
DOMPurify.removeHook=function(entryPoint){if(hooks[entryPoint])return arrayPop$1(hooks[entryPoint])},
/**
   * RemoveHooks
   * Public method to remove all DOMPurify hooks at a given entryPoint
   *
   * @param  {String} entryPoint entry point for the hooks to remove
   */
DOMPurify.removeHooks=function(entryPoint){hooks[entryPoint]&&(hooks[entryPoint]=[])},
/**
   * RemoveAllHooks
   * Public method to remove all DOMPurify hooks
   *
   */
DOMPurify.removeAllHooks=function(){hooks={}},DOMPurify}
// ::- Persistent data structure representing an ordered mapping from
// strings to values, with some convenient update methods.
function OrderedMap$1(content){this.content=content}function findDiffStart$1(a,b,pos){for(let i=0;;i++){if(i==a.childCount||i==b.childCount)return a.childCount==b.childCount?null:pos;let childA=a.child(i),childB=b.child(i);if(childA!=childB){if(!childA.sameMarkup(childB))return pos;if(childA.isText&&childA.text!=childB.text){for(let j=0;childA.text[j]==childB.text[j];j++)pos++;return pos}if(childA.content.size||childB.content.size){let inner=findDiffStart$1(childA.content,childB.content,pos+1);if(null!=inner)return inner}pos+=childA.nodeSize}else pos+=childA.nodeSize}}function findDiffEnd$1(a,b,posA,posB){for(let iA=a.childCount,iB=b.childCount;;){if(0==iA||0==iB)return iA==iB?null:{a:posA,b:posB};let childA=a.child(--iA),childB=b.child(--iB),size=childA.nodeSize;if(childA!=childB){if(!childA.sameMarkup(childB))return{a:posA,b:posB};if(childA.isText&&childA.text!=childB.text){let same=0,minSize=Math.min(childA.text.length,childB.text.length);while(same<minSize&&childA.text[childA.text.length-same-1]==childB.text[childB.text.length-same-1])same++,posA--,posB--;return{a:posA,b:posB}}if(childA.content.size||childB.content.size){let inner=findDiffEnd$1(childA.content,childB.content,posA-1,posB-1);if(inner)return inner}posA-=size,posB-=size}else posA-=size,posB-=size}}
/**
A fragment represents a node's collection of child nodes.

Like nodes, fragments are persistent data structures, and you
should not mutate them or their content. Rather, you create new
instances whenever needed. The API tries to make this easy.
*/createDOMPurify$1(),OrderedMap$1.prototype={constructor:OrderedMap$1,find:function(key){for(var i=0;i<this.content.length;i+=2)if(this.content[i]===key)return i;return-1},
// :: (string) → ?any
// Retrieve the value stored under `key`, or return undefined when
// no such key exists.
get:function(key){var found=this.find(key);return-1==found?void 0:this.content[found+1]},
// :: (string, any, ?string) → OrderedMap
// Create a new map by replacing the value of `key` with a new
// value, or adding a binding to the end of the map. If `newKey` is
// given, the key of the binding will be replaced with that key.
update:function(key,value,newKey){var self=newKey&&newKey!=key?this.remove(newKey):this,found=self.find(key),content=self.content.slice();return-1==found?content.push(newKey||key,value):(content[found+1]=value,newKey&&(content[found]=newKey)),new OrderedMap$1(content)},
// :: (string) → OrderedMap
// Return a map with the given key removed, if it existed.
remove:function(key){var found=this.find(key);if(-1==found)return this;var content=this.content.slice();return content.splice(found,2),new OrderedMap$1(content)},
// :: (string, any) → OrderedMap
// Add a new key to the start of the map.
addToStart:function(key,value){return new OrderedMap$1([key,value].concat(this.remove(key).content))},
// :: (string, any) → OrderedMap
// Add a new key to the end of the map.
addToEnd:function(key,value){var content=this.remove(key).content.slice();return content.push(key,value),new OrderedMap$1(content)},
// :: (string, string, any) → OrderedMap
// Add a key after the given key. If `place` is not found, the new
// key is added to the end.
addBefore:function(place,key,value){var without=this.remove(key),content=without.content.slice(),found=without.find(place);return content.splice(-1==found?content.length:found,0,key,value),new OrderedMap$1(content)},
// :: ((key: string, value: any))
// Call the given function for each key/value pair in the map, in
// order.
forEach:function(f){for(var i=0;i<this.content.length;i+=2)f(this.content[i],this.content[i+1])},
// :: (union<Object, OrderedMap>) → OrderedMap
// Create a new map by prepending the keys in this map that don't
// appear in `map` before the keys in `map`.
prepend:function(map){return map=OrderedMap$1.from(map),map.size?new OrderedMap$1(map.content.concat(this.subtract(map).content)):this},
// :: (union<Object, OrderedMap>) → OrderedMap
// Create a new map by appending the keys in this map that don't
// appear in `map` after the keys in `map`.
append:function(map){return map=OrderedMap$1.from(map),map.size?new OrderedMap$1(this.subtract(map).content.concat(map.content)):this},
// :: (union<Object, OrderedMap>) → OrderedMap
// Create a map containing all the keys in this map that don't
// appear in `map`.
subtract:function(map){var result=this;map=OrderedMap$1.from(map);for(var i=0;i<map.content.length;i+=2)result=result.remove(map.content[i]);return result},
// :: number
// The amount of keys in this map.
get size(){return this.content.length>>1}},
// :: (?union<Object, OrderedMap>) → OrderedMap
// Return a map with the given content. If null, create an empty
// map. If given an ordered map, return that map itself. If given an
// object, create a map from the object's properties.
OrderedMap$1.from=function(value){if(value instanceof OrderedMap$1)return value;var content=[];if(value)for(var prop in value)content.push(prop,value[prop]);return new OrderedMap$1(content)};class Fragment$1{
/**
    @internal
    */
constructor(
/**
    @internal
    */
content,size){if(this.content=content,this.size=size||0,null==size)for(let i=0;i<content.length;i++)this.size+=content[i].nodeSize}
/**
    Invoke a callback for all descendant nodes between the given two
    positions (relative to start of this fragment). Doesn't descend
    into a node when the callback returns `false`.
    */nodesBetween(from,to,f,nodeStart=0,parent){for(let i=0,pos=0;pos<to;i++){let child=this.content[i],end=pos+child.nodeSize;if(end>from&&!1!==f(child,nodeStart+pos,parent||null,i)&&child.content.size){let start=pos+1;child.nodesBetween(Math.max(0,from-start),Math.min(child.content.size,to-start),f,nodeStart+start)}pos=end}}
/**
    Call the given callback for every descendant node. `pos` will be
    relative to the start of the fragment. The callback may return
    `false` to prevent traversal of a given node's children.
    */descendants(f){this.nodesBetween(0,this.size,f)}
/**
    Extract the text between `from` and `to`. See the same method on
    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
    */textBetween(from,to,blockSeparator,leafText){let text="",separated=!0;return this.nodesBetween(from,to,((node,pos)=>{node.isText?(text+=node.text.slice(Math.max(from,pos)-pos,to-pos),separated=!blockSeparator):node.isLeaf?(leafText?text+="function"===typeof leafText?leafText(node):leafText:node.type.spec.leafText&&(text+=node.type.spec.leafText(node)),separated=!blockSeparator):!separated&&node.isBlock&&(text+=blockSeparator,separated=!0)}),0),text}
/**
    Create a new fragment containing the combined content of this
    fragment and the other.
    */append(other){if(!other.size)return this;if(!this.size)return other;let last=this.lastChild,first=other.firstChild,content=this.content.slice(),i=0;for(last.isText&&last.sameMarkup(first)&&(content[content.length-1]=last.withText(last.text+first.text),i=1);i<other.content.length;i++)content.push(other.content[i]);return new Fragment$1(content,this.size+other.size)}
/**
    Cut out the sub-fragment between the two given positions.
    */cut(from,to=this.size){if(0==from&&to==this.size)return this;let result=[],size=0;if(to>from)for(let i=0,pos=0;pos<to;i++){let child=this.content[i],end=pos+child.nodeSize;end>from&&((pos<from||end>to)&&(child=child.isText?child.cut(Math.max(0,from-pos),Math.min(child.text.length,to-pos)):child.cut(Math.max(0,from-pos-1),Math.min(child.content.size,to-pos-1))),result.push(child),size+=child.nodeSize),pos=end}return new Fragment$1(result,size)}
/**
    @internal
    */cutByIndex(from,to){return from==to?Fragment$1.empty:0==from&&to==this.content.length?this:new Fragment$1(this.content.slice(from,to))}
/**
    Create a new fragment in which the node at the given index is
    replaced by the given node.
    */replaceChild(index,node){let current=this.content[index];if(current==node)return this;let copy=this.content.slice(),size=this.size+node.nodeSize-current.nodeSize;return copy[index]=node,new Fragment$1(copy,size)}
/**
    Create a new fragment by prepending the given node to this
    fragment.
    */addToStart(node){return new Fragment$1([node].concat(this.content),this.size+node.nodeSize)}
/**
    Create a new fragment by appending the given node to this
    fragment.
    */addToEnd(node){return new Fragment$1(this.content.concat(node),this.size+node.nodeSize)}
/**
    Compare this fragment to another one.
    */eq(other){if(this.content.length!=other.content.length)return!1;for(let i=0;i<this.content.length;i++)if(!this.content[i].eq(other.content[i]))return!1;return!0}
/**
    The first child of the fragment, or `null` if it is empty.
    */get firstChild(){return this.content.length?this.content[0]:null}
/**
    The last child of the fragment, or `null` if it is empty.
    */get lastChild(){return this.content.length?this.content[this.content.length-1]:null}
/**
    The number of child nodes in this fragment.
    */get childCount(){return this.content.length}
/**
    Get the child node at the given index. Raise an error when the
    index is out of range.
    */child(index){let found=this.content[index];if(!found)throw new RangeError("Index "+index+" out of range for "+this);return found}
/**
    Get the child node at the given index, if it exists.
    */maybeChild(index){return this.content[index]||null}
/**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */forEach(f){for(let i=0,p=0;i<this.content.length;i++){let child=this.content[i];f(child,p,i),p+=child.nodeSize}}
/**
    Find the first position at which this fragment and another
    fragment differ, or `null` if they are the same.
    */findDiffStart(other,pos=0){return findDiffStart$1(this,other,pos)}
/**
    Find the first position, searching from the end, at which this
    fragment and the given fragment differ, or `null` if they are
    the same. Since this position will not be the same in both
    nodes, an object with two separate positions is returned.
    */findDiffEnd(other,pos=this.size,otherPos=other.size){return findDiffEnd$1(this,other,pos,otherPos)}
/**
    Find the index and inner offset corresponding to a given relative
    position in this fragment. The result object will be reused
    (overwritten) the next time the function is called. (Not public.)
    */findIndex(pos,round=-1){if(0==pos)return retIndex$1(0,pos);if(pos==this.size)return retIndex$1(this.content.length,pos);if(pos>this.size||pos<0)throw new RangeError(`Position ${pos} outside of fragment (${this})`);for(let i=0,curPos=0;;i++){let cur=this.child(i),end=curPos+cur.nodeSize;if(end>=pos)return end==pos||round>0?retIndex$1(i+1,end):retIndex$1(i,curPos);curPos=end}}
/**
    Return a debugging string that describes this fragment.
    */toString(){return"<"+this.toStringInner()+">"}
/**
    @internal
    */toStringInner(){return this.content.join(", ")}
/**
    Create a JSON-serializeable representation of this fragment.
    */toJSON(){return this.content.length?this.content.map((n=>n.toJSON())):null}
/**
    Deserialize a fragment from its JSON representation.
    */static fromJSON(schema,value){if(!value)return Fragment$1.empty;if(!Array.isArray(value))throw new RangeError("Invalid input for Fragment.fromJSON");return new Fragment$1(value.map(schema.nodeFromJSON))}
/**
    Build a fragment from an array of nodes. Ensures that adjacent
    text nodes with the same marks are joined together.
    */static fromArray(array){if(!array.length)return Fragment$1.empty;let joined,size=0;for(let i=0;i<array.length;i++){let node=array[i];size+=node.nodeSize,i&&node.isText&&array[i-1].sameMarkup(node)?(joined||(joined=array.slice(0,i)),joined[joined.length-1]=node.withText(joined[joined.length-1].text+node.text)):joined&&joined.push(node)}return new Fragment$1(joined||array,size)}
/**
    Create a fragment from something that can be interpreted as a
    set of nodes. For `null`, it returns the empty fragment. For a
    fragment, the fragment itself. For a node or array of nodes, a
    fragment containing those nodes.
    */static from(nodes){if(!nodes)return Fragment$1.empty;if(nodes instanceof Fragment$1)return nodes;if(Array.isArray(nodes))return this.fromArray(nodes);if(nodes.attrs)return new Fragment$1([nodes],nodes.nodeSize);throw new RangeError("Can not convert "+nodes+" to a Fragment"+(nodes.nodesBetween?" (looks like multiple versions of prosemirror-model were loaded)":""))}}
/**
An empty fragment. Intended to be reused whenever a node doesn't
contain anything (rather than allocating a new empty fragment for
each leaf node).
*/Fragment$1.empty=new Fragment$1([],0);const found$1={index:0,offset:0};function retIndex$1(index,offset){return found$1.index=index,found$1.offset=offset,found$1}function compareDeep$1(a,b){if(a===b)return!0;if(!a||"object"!=typeof a||!b||"object"!=typeof b)return!1;let array=Array.isArray(a);if(Array.isArray(b)!=array)return!1;if(array){if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(!compareDeep$1(a[i],b[i]))return!1}else{for(let p in a)if(!(p in b)||!compareDeep$1(a[p],b[p]))return!1;for(let p in b)if(!(p in a))return!1}return!0}
/**
A mark is a piece of information that can be attached to a node,
such as it being emphasized, in code font, or a link. It has a
type and optionally a set of attributes that provide further
information (such as the target of the link). Marks are created
through a `Schema`, which controls which types exist and which
attributes they have.
*/class Mark$1$1{
/**
    @internal
    */
constructor(
/**
    The type of this mark.
    */
type,
/**
    The attributes associated with this mark.
    */
attrs){this.type=type,this.attrs=attrs}
/**
    Given a set of marks, create a new set which contains this one as
    well, in the right position. If this mark is already in the set,
    the set itself is returned. If any marks that are set to be
    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
    those are replaced by this one.
    */addToSet(set){let copy,placed=!1;for(let i=0;i<set.length;i++){let other=set[i];if(this.eq(other))return set;if(this.type.excludes(other.type))copy||(copy=set.slice(0,i));else{if(other.type.excludes(this.type))return set;!placed&&other.type.rank>this.type.rank&&(copy||(copy=set.slice(0,i)),copy.push(this),placed=!0),copy&&copy.push(other)}}return copy||(copy=set.slice()),placed||copy.push(this),copy}
/**
    Remove this mark from the given set, returning a new set. If this
    mark is not in the set, the set itself is returned.
    */removeFromSet(set){for(let i=0;i<set.length;i++)if(this.eq(set[i]))return set.slice(0,i).concat(set.slice(i+1));return set}
/**
    Test whether this mark is in the given set of marks.
    */isInSet(set){for(let i=0;i<set.length;i++)if(this.eq(set[i]))return!0;return!1}
/**
    Test whether this mark has the same type and attributes as
    another mark.
    */eq(other){return this==other||this.type==other.type&&compareDeep$1(this.attrs,other.attrs)}
/**
    Convert this mark to a JSON-serializeable representation.
    */toJSON(){let obj={type:this.type.name};for(let _ in this.attrs){obj.attrs=this.attrs;break}return obj}
/**
    Deserialize a mark from JSON.
    */static fromJSON(schema,json){if(!json)throw new RangeError("Invalid input for Mark.fromJSON");let type=schema.marks[json.type];if(!type)throw new RangeError(`There is no mark type ${json.type} in this schema`);return type.create(json.attrs)}
/**
    Test whether two sets of marks are identical.
    */static sameSet(a,b){if(a==b)return!0;if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(!a[i].eq(b[i]))return!1;return!0}
/**
    Create a properly sorted mark set from null, a single mark, or an
    unsorted array of marks.
    */static setFrom(marks){if(!marks||Array.isArray(marks)&&0==marks.length)return Mark$1$1.none;if(marks instanceof Mark$1$1)return[marks];let copy=marks.slice();return copy.sort(((a,b)=>a.type.rank-b.type.rank)),copy}}
/**
The empty set of marks.
*/Mark$1$1.none=[];
/**
Error type raised by [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) when
given an invalid replacement.
*/
class ReplaceError$1 extends Error{}
/*
ReplaceError = function(this: any, message: string) {
  let err = Error.call(this, message)
  ;(err as any).__proto__ = ReplaceError.prototype
  return err
} as any

ReplaceError.prototype = Object.create(Error.prototype)
ReplaceError.prototype.constructor = ReplaceError
ReplaceError.prototype.name = "ReplaceError"
*/
/**
A slice represents a piece cut out of a larger document. It
stores not only a fragment, but also the depth up to which nodes on
both side are ‘open’ (cut through).
*/class Slice$1{
/**
    Create a slice. When specifying a non-zero open depth, you must
    make sure that there are nodes of at least that depth at the
    appropriate side of the fragment—i.e. if the fragment is an
    empty paragraph node, `openStart` and `openEnd` can't be greater
    than 1.
    
    It is not necessary for the content of open nodes to conform to
    the schema's content constraints, though it should be a valid
    start/end/middle for such a node, depending on which sides are
    open.
    */
constructor(
/**
    The slice's content.
    */
content,
/**
    The open depth at the start of the fragment.
    */
openStart,
/**
    The open depth at the end.
    */
openEnd){this.content=content,this.openStart=openStart,this.openEnd=openEnd}
/**
    The size this slice would add when inserted into a document.
    */get size(){return this.content.size-this.openStart-this.openEnd}
/**
    @internal
    */insertAt(pos,fragment){let content=insertInto$1(this.content,pos+this.openStart,fragment);return content&&new Slice$1(content,this.openStart,this.openEnd)}
/**
    @internal
    */removeBetween(from,to){return new Slice$1(removeRange$1(this.content,from+this.openStart,to+this.openStart),this.openStart,this.openEnd)}
/**
    Tests whether this slice is equal to another slice.
    */eq(other){return this.content.eq(other.content)&&this.openStart==other.openStart&&this.openEnd==other.openEnd}
/**
    @internal
    */toString(){return this.content+"("+this.openStart+","+this.openEnd+")"}
/**
    Convert a slice to a JSON-serializable representation.
    */toJSON(){if(!this.content.size)return null;let json={content:this.content.toJSON()};return this.openStart>0&&(json.openStart=this.openStart),this.openEnd>0&&(json.openEnd=this.openEnd),json}
/**
    Deserialize a slice from its JSON representation.
    */static fromJSON(schema,json){if(!json)return Slice$1.empty;let openStart=json.openStart||0,openEnd=json.openEnd||0;if("number"!=typeof openStart||"number"!=typeof openEnd)throw new RangeError("Invalid input for Slice.fromJSON");return new Slice$1(Fragment$1.fromJSON(schema,json.content),openStart,openEnd)}
/**
    Create a slice from a fragment by taking the maximum possible
    open value on both side of the fragment.
    */static maxOpen(fragment,openIsolating=!0){let openStart=0,openEnd=0;for(let n=fragment.firstChild;n&&!n.isLeaf&&(openIsolating||!n.type.spec.isolating);n=n.firstChild)openStart++;for(let n=fragment.lastChild;n&&!n.isLeaf&&(openIsolating||!n.type.spec.isolating);n=n.lastChild)openEnd++;return new Slice$1(fragment,openStart,openEnd)}}
/**
The empty slice.
*/function removeRange$1(content,from,to){let{index:index,offset:offset}=content.findIndex(from),child=content.maybeChild(index),{index:indexTo,offset:offsetTo}=content.findIndex(to);if(offset==from||child.isText){if(offsetTo!=to&&!content.child(indexTo).isText)throw new RangeError("Removing non-flat range");return content.cut(0,from).append(content.cut(to))}if(index!=indexTo)throw new RangeError("Removing non-flat range");return content.replaceChild(index,child.copy(removeRange$1(child.content,from-offset-1,to-offset-1)))}function insertInto$1(content,dist,insert,parent){let{index:index,offset:offset}=content.findIndex(dist),child=content.maybeChild(index);if(offset==dist||child.isText)return parent&&!parent.canReplace(index,index,insert)?null:content.cut(0,dist).append(insert).append(content.cut(dist));let inner=insertInto$1(child.content,dist-offset-1,insert);return inner&&content.replaceChild(index,child.copy(inner))}
/**
Represents a flat range of content, i.e. one that starts and
ends in the same node.
*/Slice$1.empty=new Slice$1(Fragment$1.empty,0,0);class NodeRange$1{
/**
    Construct a node range. `$from` and `$to` should point into the
    same node until at least the given `depth`, since a node range
    denotes an adjacent set of nodes in a single parent node.
    */
constructor(
/**
    A resolved position along the start of the content. May have a
    `depth` greater than this object's `depth` property, since
    these are the positions that were used to compute the range,
    not re-resolved positions directly at its boundaries.
    */
$from,
/**
    A position along the end of the content. See
    caveat for [`$from`](https://prosemirror.net/docs/ref/#model.NodeRange.$from).
    */
$to,
/**
    The depth of the node that this range points into.
    */
depth){this.$from=$from,this.$to=$to,this.depth=depth}
/**
    The position at the start of the range.
    */get start(){return this.$from.before(this.depth+1)}
/**
    The position at the end of the range.
    */get end(){return this.$to.after(this.depth+1)}
/**
    The parent node that the range points into.
    */get parent(){return this.$from.node(this.depth)}
/**
    The start index of the range in the parent node.
    */get startIndex(){return this.$from.index(this.depth)}
/**
    The end index of the range in the parent node.
    */get endIndex(){return this.$to.indexAfter(this.depth)}}
// For node types where all attrs have a default value (or which don't
// have any attributes), build up a single reusable default attribute
// object, and use it for all nodes that don't specify specific
// attributes.
function defaultAttrs$1(attrs){let defaults=Object.create(null);for(let attrName in attrs){let attr=attrs[attrName];if(!attr.hasDefault)return null;defaults[attrName]=attr.default}return defaults}function computeAttrs$1(attrs,value){let built=Object.create(null);for(let name in attrs){let given=value&&value[name];if(void 0===given){let attr=attrs[name];if(!attr.hasDefault)throw new RangeError("No value supplied for attribute "+name);given=attr.default}built[name]=given}return built}function initAttrs$1(attrs){let result=Object.create(null);if(attrs)for(let name in attrs)result[name]=new Attribute$1(attrs[name]);return result}
// Attribute descriptors
class Attribute$1{constructor(options){this.hasDefault=Object.prototype.hasOwnProperty.call(options,"default"),this.default=options.default}get isRequired(){return!this.hasDefault}}
// Marks
/**
Like nodes, marks (which are associated with nodes to signify
things like emphasis or being part of a link) are
[tagged](https://prosemirror.net/docs/ref/#model.Mark.type) with type objects, which are
instantiated once per `Schema`.
*/class MarkType$1{
/**
    @internal
    */
constructor(
/**
    The name of the mark type.
    */
name,
/**
    @internal
    */
rank,
/**
    The schema that this mark type instance is part of.
    */
schema,
/**
    The spec on which the type is based.
    */
spec){this.name=name,this.rank=rank,this.schema=schema,this.spec=spec,this.attrs=initAttrs$1(spec.attrs),this.excluded=null;let defaults=defaultAttrs$1(this.attrs);this.instance=defaults?new Mark$1$1(this,defaults):null}
/**
    Create a mark of this type. `attrs` may be `null` or an object
    containing only some of the mark's attributes. The others, if
    they have defaults, will be added.
    */create(attrs=null){return!attrs&&this.instance?this.instance:new Mark$1$1(this,computeAttrs$1(this.attrs,attrs))}
/**
    @internal
    */static compile(marks,schema){let result=Object.create(null),rank=0;return marks.forEach(((name,spec)=>result[name]=new MarkType$1(name,rank++,schema,spec))),result}
/**
    When there is a mark of this type in the given set, a new set
    without it is returned. Otherwise, the input set is returned.
    */removeFromSet(set){for(var i=0;i<set.length;i++)set[i].type==this&&(set=set.slice(0,i).concat(set.slice(i+1)),i--);return set}
/**
    Tests whether there is a mark of this type in the given set.
    */isInSet(set){for(let i=0;i<set.length;i++)if(set[i].type==this)return set[i]}
/**
    Queries whether a given mark type is
    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
    */excludes(other){return this.excluded.indexOf(other)>-1}}
/**
A DOM parser represents a strategy for parsing DOM content into a
ProseMirror document conforming to a given schema. Its behavior is
defined by an array of [rules](https://prosemirror.net/docs/ref/#model.ParseRule).
*/class DOMParser$1$1{
/**
    Create a parser that targets the given schema, using the given
    parsing rules.
    */
constructor(
/**
    The schema into which the parser parses.
    */
schema,
/**
    The set of [parse rules](https://prosemirror.net/docs/ref/#model.ParseRule) that the parser
    uses, in order of precedence.
    */
rules){this.schema=schema,this.rules=rules,
/**
        @internal
        */
this.tags=[],
/**
        @internal
        */
this.styles=[],rules.forEach((rule=>{rule.tag?this.tags.push(rule):rule.style&&this.styles.push(rule)})),
// Only normalize list elements when lists in the schema can't directly contain themselves
this.normalizeLists=!this.tags.some((r=>{if(!/^(ul|ol)\b/.test(r.tag)||!r.node)return!1;let node=schema.nodes[r.node];return node.contentMatch.matchType(node)}))}
/**
    Parse a document from the content of a DOM node.
    */parse(dom,options={}){let context=new ParseContext$1(this,options,!1);return context.addAll(dom,options.from,options.to),context.finish()}
/**
    Parses the content of the given DOM node, like
    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
    options. But unlike that method, which produces a whole node,
    this one returns a slice that is open at the sides, meaning that
    the schema constraints aren't applied to the start of nodes to
    the left of the input and the end of nodes at the end.
    */parseSlice(dom,options={}){let context=new ParseContext$1(this,options,!0);return context.addAll(dom,options.from,options.to),Slice$1.maxOpen(context.finish())}
/**
    @internal
    */matchTag(dom,context,after){for(let i=after?this.tags.indexOf(after)+1:0;i<this.tags.length;i++){let rule=this.tags[i];if(matches$1$1(dom,rule.tag)&&(void 0===rule.namespace||dom.namespaceURI==rule.namespace)&&(!rule.context||context.matchesContext(rule.context))){if(rule.getAttrs){let result=rule.getAttrs(dom);if(!1===result)continue;rule.attrs=result||void 0}return rule}}}
/**
    @internal
    */matchStyle(prop,value,context,after){for(let i=after?this.styles.indexOf(after)+1:0;i<this.styles.length;i++){let rule=this.styles[i],style=rule.style;if(!(0!=style.indexOf(prop)||rule.context&&!context.matchesContext(rule.context)||
// Test that the style string either precisely matches the prop,
// or has an '=' sign after the prop, followed by the given
// value.
style.length>prop.length&&(61!=style.charCodeAt(prop.length)||style.slice(prop.length+1)!=value))){if(rule.getAttrs){let result=rule.getAttrs(value);if(!1===result)continue;rule.attrs=result||void 0}return rule}}}
/**
    @internal
    */static schemaRules(schema){let result=[];function insert(rule){let priority=null==rule.priority?50:rule.priority,i=0;for(;i<result.length;i++){let next=result[i],nextPriority=null==next.priority?50:next.priority;if(nextPriority<priority)break}result.splice(i,0,rule)}for(let name in schema.marks){let rules=schema.marks[name].spec.parseDOM;rules&&rules.forEach((rule=>{insert(rule=copy$1(rule)),rule.mark=name}))}for(let name in schema.nodes){let rules=schema.nodes[name].spec.parseDOM;rules&&rules.forEach((rule=>{insert(rule=copy$1(rule)),rule.node=name}))}return result}
/**
    Construct a DOM parser using the parsing rules listed in a
    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
    */static fromSchema(schema){return schema.cached.domParser||(schema.cached.domParser=new DOMParser$1$1(schema,DOMParser$1$1.schemaRules(schema)))}}const blockTags$1={address:!0,article:!0,aside:!0,blockquote:!0,canvas:!0,dd:!0,div:!0,dl:!0,fieldset:!0,figcaption:!0,figure:!0,footer:!0,form:!0,h1:!0,h2:!0,h3:!0,h4:!0,h5:!0,h6:!0,header:!0,hgroup:!0,hr:!0,li:!0,noscript:!0,ol:!0,output:!0,p:!0,pre:!0,section:!0,table:!0,tfoot:!0,ul:!0},ignoreTags$1={head:!0,noscript:!0,object:!0,script:!0,style:!0,title:!0},listTags$1={ol:!0,ul:!0},OPT_PRESERVE_WS$1=1,OPT_PRESERVE_WS_FULL$1=2,OPT_OPEN_LEFT$1=4;function wsOptionsFor$1(type,preserveWhitespace,base){return null!=preserveWhitespace?(preserveWhitespace?OPT_PRESERVE_WS$1:0)|("full"===preserveWhitespace?OPT_PRESERVE_WS_FULL$1:0):type&&"pre"==type.whitespace?OPT_PRESERVE_WS$1|OPT_PRESERVE_WS_FULL$1:base&~OPT_OPEN_LEFT$1}class NodeContext$1{constructor(type,attrs,
// Marks applied to this node itself
marks,
// Marks that can't apply here, but will be used in children if possible
pendingMarks,solid,match,options){this.type=type,this.attrs=attrs,this.marks=marks,this.pendingMarks=pendingMarks,this.solid=solid,this.options=options,this.content=[],
// Marks applied to the node's children
this.activeMarks=Mark$1$1.none,
// Nested Marks with same type
this.stashMarks=[],this.match=match||(options&OPT_OPEN_LEFT$1?null:type.contentMatch)}findWrapping(node){if(!this.match){if(!this.type)return[];let fill=this.type.contentMatch.fillBefore(Fragment$1.from(node));if(!fill){let wrap,start=this.type.contentMatch;return(wrap=start.findWrapping(node.type))?(this.match=start,wrap):null}this.match=this.type.contentMatch.matchFragment(fill)}return this.match.findWrapping(node.type)}finish(openEnd){if(!(this.options&OPT_PRESERVE_WS$1)){// Strip trailing whitespace
let m,last=this.content[this.content.length-1];if(last&&last.isText&&(m=/[ \t\r\n\u000c]+$/.exec(last.text))){let text=last;last.text.length==m[0].length?this.content.pop():this.content[this.content.length-1]=text.withText(text.text.slice(0,text.text.length-m[0].length))}}let content=Fragment$1.from(this.content);return!openEnd&&this.match&&(content=content.append(this.match.fillBefore(Fragment$1.empty,!0))),this.type?this.type.create(this.attrs,content,this.marks):content}popFromStashMark(mark){for(let i=this.stashMarks.length-1;i>=0;i--)if(mark.eq(this.stashMarks[i]))return this.stashMarks.splice(i,1)[0]}applyPending(nextType){for(let i=0,pending=this.pendingMarks;i<pending.length;i++){let mark=pending[i];(this.type?this.type.allowsMarkType(mark.type):markMayApply$1(mark.type,nextType))&&!mark.isInSet(this.activeMarks)&&(this.activeMarks=mark.addToSet(this.activeMarks),this.pendingMarks=mark.removeFromSet(this.pendingMarks))}}inlineContext(node){return this.type?this.type.inlineContent:this.content.length?this.content[0].isInline:node.parentNode&&!blockTags$1.hasOwnProperty(node.parentNode.nodeName.toLowerCase())}}class ParseContext$1{constructor(
// The parser we are using.
parser,
// The options passed to this parse.
options,isOpen){this.parser=parser,this.options=options,this.isOpen=isOpen,this.open=0;let topContext,topNode=options.topNode,topOptions=wsOptionsFor$1(null,options.preserveWhitespace,0)|(isOpen?OPT_OPEN_LEFT$1:0);topContext=topNode?new NodeContext$1(topNode.type,topNode.attrs,Mark$1$1.none,Mark$1$1.none,!0,options.topMatch||topNode.type.contentMatch,topOptions):new NodeContext$1(isOpen?null:parser.schema.topNodeType,null,Mark$1$1.none,Mark$1$1.none,!0,null,topOptions),this.nodes=[topContext],this.find=options.findPositions,this.needsBlock=!1}get top(){return this.nodes[this.open]}
// Add a DOM node to the content. Text is inserted as text node,
// otherwise, the node is passed to `addElement` or, if it has a
// `style` attribute, `addElementWithStyles`.
addDOM(dom){if(3==dom.nodeType)this.addTextNode(dom);else if(1==dom.nodeType){let style=dom.getAttribute("style"),marks=style?this.readStyles(parseStyles$1(style)):null,top=this.top;if(null!=marks)for(let i=0;i<marks.length;i++)this.addPendingMark(marks[i]);if(this.addElement(dom),null!=marks)for(let i=0;i<marks.length;i++)this.removePendingMark(marks[i],top)}}addTextNode(dom){let value=dom.nodeValue,top=this.top;if(top.options&OPT_PRESERVE_WS_FULL$1||top.inlineContext(dom)||/[^ \t\r\n\u000c]/.test(value)){if(top.options&OPT_PRESERVE_WS$1)value=top.options&OPT_PRESERVE_WS_FULL$1?value.replace(/\r\n?/g,"\n"):value.replace(/\r?\n|\r/g," ");else
// If this starts with whitespace, and there is no node before it, or
// a hard break, or a text node that ends with whitespace, strip the
// leading space.
if(value=value.replace(/[ \t\r\n\u000c]+/g," "),/^[ \t\r\n\u000c]/.test(value)&&this.open==this.nodes.length-1){let nodeBefore=top.content[top.content.length-1],domNodeBefore=dom.previousSibling;(!nodeBefore||domNodeBefore&&"BR"==domNodeBefore.nodeName||nodeBefore.isText&&/[ \t\r\n\u000c]$/.test(nodeBefore.text))&&(value=value.slice(1))}value&&this.insertNode(this.parser.schema.text(value)),this.findInText(dom)}else this.findInside(dom)}
// Try to find a handler for the given tag and use that to parse. If
// none is found, the element's content nodes are added directly.
addElement(dom,matchAfter){let ruleID,name=dom.nodeName.toLowerCase();listTags$1.hasOwnProperty(name)&&this.parser.normalizeLists&&normalizeList$1(dom);let rule=this.options.ruleFromNode&&this.options.ruleFromNode(dom)||(ruleID=this.parser.matchTag(dom,this,matchAfter));if(rule?rule.ignore:ignoreTags$1.hasOwnProperty(name))this.findInside(dom),this.ignoreFallback(dom);else if(!rule||rule.skip||rule.closeParent){rule&&rule.closeParent?this.open=Math.max(0,this.open-1):rule&&rule.skip.nodeType&&(dom=rule.skip);let sync,top=this.top,oldNeedsBlock=this.needsBlock;if(blockTags$1.hasOwnProperty(name))sync=!0,top.type||(this.needsBlock=!0);else if(!dom.firstChild)return void this.leafFallback(dom);this.addAll(dom),sync&&this.sync(top),this.needsBlock=oldNeedsBlock}else this.addElementByRule(dom,rule,!1===rule.consuming?ruleID:void 0)}
// Called for leaf DOM nodes that would otherwise be ignored
leafFallback(dom){"BR"==dom.nodeName&&this.top.type&&this.top.type.inlineContent&&this.addTextNode(dom.ownerDocument.createTextNode("\n"))}
// Called for ignored nodes
ignoreFallback(dom){
// Ignored BR nodes should at least create an inline context
"BR"!=dom.nodeName||this.top.type&&this.top.type.inlineContent||this.findPlace(this.parser.schema.text("-"))}
// Run any style parser associated with the node's styles. Either
// return an array of marks, or null to indicate some of the styles
// had a rule with `ignore` set.
readStyles(styles){let marks=Mark$1$1.none;style:for(let i=0;i<styles.length;i+=2)for(let after;;){let rule=this.parser.matchStyle(styles[i],styles[i+1],this,after);if(!rule)continue style;if(rule.ignore)return null;if(marks=this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks),!1!==rule.consuming)break;after=rule}return marks}
// Look up a handler for the given node. If none are found, return
// false. Otherwise, apply it, use its return value to drive the way
// the node's content is wrapped, and return true.
addElementByRule(dom,rule,continueAfter){let sync,nodeType,mark;if(rule.node)nodeType=this.parser.schema.nodes[rule.node],nodeType.isLeaf?this.insertNode(nodeType.create(rule.attrs))||this.leafFallback(dom):sync=this.enter(nodeType,rule.attrs||null,rule.preserveWhitespace);else{let markType=this.parser.schema.marks[rule.mark];mark=markType.create(rule.attrs),this.addPendingMark(mark)}let startIn=this.top;if(nodeType&&nodeType.isLeaf)this.findInside(dom);else if(continueAfter)this.addElement(dom,continueAfter);else if(rule.getContent)this.findInside(dom),rule.getContent(dom,this.parser.schema).forEach((node=>this.insertNode(node)));else{let contentDOM=dom;"string"==typeof rule.contentElement?contentDOM=dom.querySelector(rule.contentElement):"function"==typeof rule.contentElement?contentDOM=rule.contentElement(dom):rule.contentElement&&(contentDOM=rule.contentElement),this.findAround(dom,contentDOM,!0),this.addAll(contentDOM)}sync&&this.sync(startIn)&&this.open--,mark&&this.removePendingMark(mark,startIn)}
// Add all child nodes between `startIndex` and `endIndex` (or the
// whole node, if not given). If `sync` is passed, use it to
// synchronize after every block element.
addAll(parent,startIndex,endIndex){let index=startIndex||0;for(let dom=startIndex?parent.childNodes[startIndex]:parent.firstChild,end=null==endIndex?null:parent.childNodes[endIndex];dom!=end;dom=dom.nextSibling,++index)this.findAtPoint(parent,index),this.addDOM(dom);this.findAtPoint(parent,index)}
// Try to find a way to fit the given node type into the current
// context. May add intermediate wrappers and/or leave non-solid
// nodes that we're in.
findPlace(node){let route,sync;for(let depth=this.open;depth>=0;depth--){let cx=this.nodes[depth],found=cx.findWrapping(node);if(found&&(!route||route.length>found.length)&&(route=found,sync=cx,!found.length))break;if(cx.solid)break}if(!route)return!1;this.sync(sync);for(let i=0;i<route.length;i++)this.enterInner(route[i],null,!1);return!0}
// Try to insert the given node, adjusting the context when needed.
insertNode(node){if(node.isInline&&this.needsBlock&&!this.top.type){let block=this.textblockFromContext();block&&this.enterInner(block)}if(this.findPlace(node)){this.closeExtra();let top=this.top;top.applyPending(node.type),top.match&&(top.match=top.match.matchType(node.type));let marks=top.activeMarks;for(let i=0;i<node.marks.length;i++)top.type&&!top.type.allowsMarkType(node.marks[i].type)||(marks=node.marks[i].addToSet(marks));return top.content.push(node.mark(marks)),!0}return!1}
// Try to start a node of the given type, adjusting the context when
// necessary.
enter(type,attrs,preserveWS){let ok=this.findPlace(type.create(attrs));return ok&&this.enterInner(type,attrs,!0,preserveWS),ok}
// Open a node of the given type
enterInner(type,attrs=null,solid=!1,preserveWS){this.closeExtra();let top=this.top;top.applyPending(type),top.match=top.match&&top.match.matchType(type);let options=wsOptionsFor$1(type,preserveWS,top.options);top.options&OPT_OPEN_LEFT$1&&0==top.content.length&&(options|=OPT_OPEN_LEFT$1),this.nodes.push(new NodeContext$1(type,attrs,top.activeMarks,top.pendingMarks,solid,null,options)),this.open++}
// Make sure all nodes above this.open are finished and added to
// their parents
closeExtra(openEnd=!1){let i=this.nodes.length-1;if(i>this.open){for(;i>this.open;i--)this.nodes[i-1].content.push(this.nodes[i].finish(openEnd));this.nodes.length=this.open+1}}finish(){return this.open=0,this.closeExtra(this.isOpen),this.nodes[0].finish(this.isOpen||this.options.topOpen)}sync(to){for(let i=this.open;i>=0;i--)if(this.nodes[i]==to)return this.open=i,!0;return!1}get currentPos(){this.closeExtra();let pos=0;for(let i=this.open;i>=0;i--){let content=this.nodes[i].content;for(let j=content.length-1;j>=0;j--)pos+=content[j].nodeSize;i&&pos++}return pos}findAtPoint(parent,offset){if(this.find)for(let i=0;i<this.find.length;i++)this.find[i].node==parent&&this.find[i].offset==offset&&(this.find[i].pos=this.currentPos)}findInside(parent){if(this.find)for(let i=0;i<this.find.length;i++)null==this.find[i].pos&&1==parent.nodeType&&parent.contains(this.find[i].node)&&(this.find[i].pos=this.currentPos)}findAround(parent,content,before){if(parent!=content&&this.find)for(let i=0;i<this.find.length;i++)if(null==this.find[i].pos&&1==parent.nodeType&&parent.contains(this.find[i].node)){let pos=content.compareDocumentPosition(this.find[i].node);pos&(before?2:4)&&(this.find[i].pos=this.currentPos)}}findInText(textNode){if(this.find)for(let i=0;i<this.find.length;i++)this.find[i].node==textNode&&(this.find[i].pos=this.currentPos-(textNode.nodeValue.length-this.find[i].offset))}
// Determines whether the given context string matches this context.
matchesContext(context){if(context.indexOf("|")>-1)return context.split(/\s*\|\s*/).some(this.matchesContext,this);let parts=context.split("/"),option=this.options.context,useRoot=!this.isOpen&&(!option||option.parent.type==this.nodes[0].type),minDepth=-(option?option.depth+1:0)+(useRoot?0:1),match=(i,depth)=>{for(;i>=0;i--){let part=parts[i];if(""==part){if(i==parts.length-1||0==i)continue;for(;depth>=minDepth;depth--)if(match(i-1,depth))return!0;return!1}{let next=depth>0||0==depth&&useRoot?this.nodes[depth].type:option&&depth>=minDepth?option.node(depth-minDepth).type:null;if(!next||next.name!=part&&-1==next.groups.indexOf(part))return!1;depth--}}return!0};return match(parts.length-1,this.open)}textblockFromContext(){let $context=this.options.context;if($context)for(let d=$context.depth;d>=0;d--){let deflt=$context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;if(deflt&&deflt.isTextblock&&deflt.defaultAttrs)return deflt}for(let name in this.parser.schema.nodes){let type=this.parser.schema.nodes[name];if(type.isTextblock&&type.defaultAttrs)return type}}addPendingMark(mark){let found=findSameMarkInSet$1(mark,this.top.pendingMarks);found&&this.top.stashMarks.push(found),this.top.pendingMarks=mark.addToSet(this.top.pendingMarks)}removePendingMark(mark,upto){for(let depth=this.open;depth>=0;depth--){let level=this.nodes[depth],found=level.pendingMarks.lastIndexOf(mark);if(found>-1)level.pendingMarks=mark.removeFromSet(level.pendingMarks);else{level.activeMarks=mark.removeFromSet(level.activeMarks);let stashMark=level.popFromStashMark(mark);stashMark&&level.type&&level.type.allowsMarkType(stashMark.type)&&(level.activeMarks=stashMark.addToSet(level.activeMarks))}if(level==upto)break}}}
// Kludge to work around directly nested list nodes produced by some
// tools and allowed by browsers to mean that the nested list is
// actually part of the list item above it.
function normalizeList$1(dom){for(let child=dom.firstChild,prevItem=null;child;child=child.nextSibling){let name=1==child.nodeType?child.nodeName.toLowerCase():null;name&&listTags$1.hasOwnProperty(name)&&prevItem?(prevItem.appendChild(child),child=prevItem):"li"==name?prevItem=child:name&&(prevItem=null)}}
// Apply a CSS selector.
function matches$1$1(dom,selector){return(dom.matches||dom.msMatchesSelector||dom.webkitMatchesSelector||dom.mozMatchesSelector).call(dom,selector)}
// Tokenize a style attribute into property/value pairs.
function parseStyles$1(style){let m,re=/\s*([\w-]+)\s*:\s*([^;]+)/g,result=[];while(m=re.exec(style))result.push(m[1],m[2].trim());return result}function copy$1(obj){let copy={};for(let prop in obj)copy[prop]=obj[prop];return copy}
// Used when finding a mark at the top level of a fragment parse.
// Checks whether it would be reasonable to apply a given mark type to
// a given node, by looking at the way the mark occurs in the schema.
function markMayApply$1(markType,nodeType){let nodes=nodeType.schema.nodes;for(let name in nodes){let parent=nodes[name];if(!parent.allowsMarkType(markType))continue;let seen=[],scan=match=>{seen.push(match);for(let i=0;i<match.edgeCount;i++){let{type:type,next:next}=match.edge(i);if(type==nodeType)return!0;if(seen.indexOf(next)<0&&scan(next))return!0}};if(scan(parent.contentMatch))return!0}}function findSameMarkInSet$1(mark,set){for(let i=0;i<set.length;i++)if(mark.eq(set[i]))return set[i]}
/**
A DOM serializer knows how to convert ProseMirror nodes and
marks of various types to DOM nodes.
*/class DOMSerializer$1{
/**
    Create a serializer. `nodes` should map node names to functions
    that take a node and return a description of the corresponding
    DOM. `marks` does the same for mark names, but also gets an
    argument that tells it whether the mark's content is block or
    inline content (for typical use, it'll always be inline). A mark
    serializer may be `null` to indicate that marks of that type
    should not be serialized.
    */
constructor(
/**
    The node serialization functions.
    */
nodes,
/**
    The mark serialization functions.
    */
marks){this.nodes=nodes,this.marks=marks}
/**
    Serialize the content of this fragment to a DOM fragment. When
    not in the browser, the `document` option, containing a DOM
    document, should be passed so that the serializer can create
    nodes.
    */serializeFragment(fragment,options={},target){target||(target=doc$1$1(options).createDocumentFragment());let top=target,active=[];return fragment.forEach((node=>{if(active.length||node.marks.length){let keep=0,rendered=0;while(keep<active.length&&rendered<node.marks.length){let next=node.marks[rendered];if(this.marks[next.type.name]){if(!next.eq(active[keep][0])||!1===next.type.spec.spanning)break;keep++,rendered++}else rendered++}while(keep<active.length)top=active.pop()[1];while(rendered<node.marks.length){let add=node.marks[rendered++],markDOM=this.serializeMark(add,node.isInline,options);markDOM&&(active.push([add,top]),top.appendChild(markDOM.dom),top=markDOM.contentDOM||markDOM.dom)}}top.appendChild(this.serializeNodeInner(node,options))})),target}
/**
    @internal
    */serializeNodeInner(node,options){let{dom:dom,contentDOM:contentDOM}=DOMSerializer$1.renderSpec(doc$1$1(options),this.nodes[node.type.name](node));if(contentDOM){if(node.isLeaf)throw new RangeError("Content hole not allowed in a leaf node spec");this.serializeFragment(node.content,options,contentDOM)}return dom}
/**
    Serialize this node to a DOM node. This can be useful when you
    need to serialize a part of a document, as opposed to the whole
    document. To serialize a whole document, use
    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
    its [content](https://prosemirror.net/docs/ref/#model.Node.content).
    */serializeNode(node,options={}){let dom=this.serializeNodeInner(node,options);for(let i=node.marks.length-1;i>=0;i--){let wrap=this.serializeMark(node.marks[i],node.isInline,options);wrap&&((wrap.contentDOM||wrap.dom).appendChild(dom),dom=wrap.dom)}return dom}
/**
    @internal
    */serializeMark(mark,inline,options={}){let toDOM=this.marks[mark.type.name];return toDOM&&DOMSerializer$1.renderSpec(doc$1$1(options),toDOM(mark,inline))}
/**
    Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
    the spec has a hole (zero) in it, `contentDOM` will point at the
    node with the hole.
    */static renderSpec(doc,structure,xmlNS=null){if("string"==typeof structure)return{dom:doc.createTextNode(structure)};if(null!=structure.nodeType)return{dom:structure};if(structure.dom&&null!=structure.dom.nodeType)return structure;let contentDOM,tagName=structure[0],space=tagName.indexOf(" ");space>0&&(xmlNS=tagName.slice(0,space),tagName=tagName.slice(space+1));let dom=xmlNS?doc.createElementNS(xmlNS,tagName):doc.createElement(tagName),attrs=structure[1],start=1;if(attrs&&"object"==typeof attrs&&null==attrs.nodeType&&!Array.isArray(attrs)){start=2;for(let name in attrs)if(null!=attrs[name]){let space=name.indexOf(" ");space>0?dom.setAttributeNS(name.slice(0,space),name.slice(space+1),attrs[name]):dom.setAttribute(name,attrs[name])}}for(let i=start;i<structure.length;i++){let child=structure[i];if(0===child){if(i<structure.length-1||i>start)throw new RangeError("Content hole must be the only child of its parent node");return{dom:dom,contentDOM:dom}}{let{dom:inner,contentDOM:innerContent}=DOMSerializer$1.renderSpec(doc,child,xmlNS);if(dom.appendChild(inner),innerContent){if(contentDOM)throw new RangeError("Multiple content holes");contentDOM=innerContent}}}return{dom:dom,contentDOM:contentDOM}}
/**
    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
    properties in a schema's node and mark specs.
    */static fromSchema(schema){return schema.cached.domSerializer||(schema.cached.domSerializer=new DOMSerializer$1(this.nodesFromSchema(schema),this.marksFromSchema(schema)))}
/**
    Gather the serializers in a schema's node specs into an object.
    This can be useful as a base to build a custom serializer from.
    */static nodesFromSchema(schema){let result=gatherToDOM$1(schema.nodes);return result.text||(result.text=node=>node.text),result}
/**
    Gather the serializers in a schema's mark specs into an object.
    */static marksFromSchema(schema){return gatherToDOM$1(schema.marks)}}function gatherToDOM$1(obj){let result={};for(let name in obj){let toDOM=obj[name].spec.toDOM;toDOM&&(result[name]=toDOM)}return result}function doc$1$1(options){return options.document||window.document}
// Recovery values encode a range index and an offset. They are
// represented as numbers, because tons of them will be created when
// mapping, for example, a large number of decorations. The number's
// lower 16 bits provide the index, the remaining bits the offset.

// Note: We intentionally don't use bit shift operators to en- and
// decode these, since those clip to 32 bits, which we might in rare
// cases want to overflow. A 64-bit float can represent 48-bit
// integers precisely.
const lower16$1=65535,factor16$1=Math.pow(2,16);function makeRecover$1(index,offset){return index+offset*factor16$1}function recoverIndex$1(value){return value&lower16$1}function recoverOffset$1(value){return(value-(value&lower16$1))/factor16$1}const DEL_BEFORE$1=1,DEL_AFTER$1=2,DEL_ACROSS$1=4,DEL_SIDE$1=8;
/**
An object representing a mapped position with extra
information.
*/class MapResult$1{
/**
    @internal
    */
constructor(
/**
    The mapped version of the position.
    */
pos,
/**
    @internal
    */
delInfo,
/**
    @internal
    */
recover){this.pos=pos,this.delInfo=delInfo,this.recover=recover}
/**
    Tells you whether the position was deleted, that is, whether the
    step removed the token on the side queried (via the `assoc`)
    argument from the document.
    */get deleted(){return(this.delInfo&DEL_SIDE$1)>0}
/**
    Tells you whether the token before the mapped position was deleted.
    */get deletedBefore(){return(this.delInfo&(DEL_BEFORE$1|DEL_ACROSS$1))>0}
/**
    True when the token after the mapped position was deleted.
    */get deletedAfter(){return(this.delInfo&(DEL_AFTER$1|DEL_ACROSS$1))>0}
/**
    Tells whether any of the steps mapped through deletes across the
    position (including both the token before and after the
    position).
    */get deletedAcross(){return(this.delInfo&DEL_ACROSS$1)>0}}
/**
A map describing the deletions and insertions made by a step, which
can be used to find the correspondence between positions in the
pre-step version of a document and the same position in the
post-step version.
*/class StepMap$1{
/**
    Create a position map. The modifications to the document are
    represented as an array of numbers, in which each group of three
    represents a modified chunk as `[start, oldSize, newSize]`.
    */
constructor(
/**
    @internal
    */
ranges,
/**
    @internal
    */
inverted=!1){if(this.ranges=ranges,this.inverted=inverted,!ranges.length&&StepMap$1.empty)return StepMap$1.empty}
/**
    @internal
    */recover(value){let diff=0,index=recoverIndex$1(value);if(!this.inverted)for(let i=0;i<index;i++)diff+=this.ranges[3*i+2]-this.ranges[3*i+1];return this.ranges[3*index]+diff+recoverOffset$1(value)}mapResult(pos,assoc=1){return this._map(pos,assoc,!1)}map(pos,assoc=1){return this._map(pos,assoc,!0)}
/**
    @internal
    */_map(pos,assoc,simple){let diff=0,oldIndex=this.inverted?2:1,newIndex=this.inverted?1:2;for(let i=0;i<this.ranges.length;i+=3){let start=this.ranges[i]-(this.inverted?diff:0);if(start>pos)break;let oldSize=this.ranges[i+oldIndex],newSize=this.ranges[i+newIndex],end=start+oldSize;if(pos<=end){let side=oldSize?pos==start?-1:pos==end?1:assoc:assoc,result=start+diff+(side<0?0:newSize);if(simple)return result;let recover=pos==(assoc<0?start:end)?null:makeRecover$1(i/3,pos-start),del=pos==start?DEL_AFTER$1:pos==end?DEL_BEFORE$1:DEL_ACROSS$1;return(assoc<0?pos!=start:pos!=end)&&(del|=DEL_SIDE$1),new MapResult$1(result,del,recover)}diff+=newSize-oldSize}return simple?pos+diff:new MapResult$1(pos+diff,0,null)}
/**
    @internal
    */touches(pos,recover){let diff=0,index=recoverIndex$1(recover),oldIndex=this.inverted?2:1,newIndex=this.inverted?1:2;for(let i=0;i<this.ranges.length;i+=3){let start=this.ranges[i]-(this.inverted?diff:0);if(start>pos)break;let oldSize=this.ranges[i+oldIndex],end=start+oldSize;if(pos<=end&&i==3*index)return!0;diff+=this.ranges[i+newIndex]-oldSize}return!1}
/**
    Calls the given function on each of the changed ranges included in
    this map.
    */forEach(f){let oldIndex=this.inverted?2:1,newIndex=this.inverted?1:2;for(let i=0,diff=0;i<this.ranges.length;i+=3){let start=this.ranges[i],oldStart=start-(this.inverted?diff:0),newStart=start+(this.inverted?0:diff),oldSize=this.ranges[i+oldIndex],newSize=this.ranges[i+newIndex];f(oldStart,oldStart+oldSize,newStart,newStart+newSize),diff+=newSize-oldSize}}
/**
    Create an inverted version of this map. The result can be used to
    map positions in the post-step document to the pre-step document.
    */invert(){return new StepMap$1(this.ranges,!this.inverted)}
/**
    @internal
    */toString(){return(this.inverted?"-":"")+JSON.stringify(this.ranges)}
/**
    Create a map that moves all positions by offset `n` (which may be
    negative). This can be useful when applying steps meant for a
    sub-document to a larger document, or vice-versa.
    */static offset(n){return 0==n?StepMap$1.empty:new StepMap$1(n<0?[0,-n,0]:[0,0,n])}}
/**
A StepMap that contains no changed ranges.
*/StepMap$1.empty=new StepMap$1([]);
/**
A mapping represents a pipeline of zero or more [step
maps](https://prosemirror.net/docs/ref/#transform.StepMap). It has special provisions for losslessly
handling mapping positions through a series of steps in which some
steps are inverted versions of earlier steps. (This comes up when
‘[rebasing](/docs/guide/#transform.rebasing)’ steps for
collaboration or history management.)
*/
class Mapping$1{
/**
    Create a new mapping with the given position maps.
    */
constructor(
/**
    The step maps in this mapping.
    */
maps=[]
/**
    @internal
    */,mirror,
/**
    The starting position in the `maps` array, used when `map` or
    `mapResult` is called.
    */
from=0
/**
    The end position in the `maps` array.
    */,to=maps.length){this.maps=maps,this.mirror=mirror,this.from=from,this.to=to}
/**
    Create a mapping that maps only through a part of this one.
    */slice(from=0,to=this.maps.length){return new Mapping$1(this.maps,this.mirror,from,to)}
/**
    @internal
    */copy(){return new Mapping$1(this.maps.slice(),this.mirror&&this.mirror.slice(),this.from,this.to)}
/**
    Add a step map to the end of this mapping. If `mirrors` is
    given, it should be the index of the step map that is the mirror
    image of this one.
    */appendMap(map,mirrors){this.to=this.maps.push(map),null!=mirrors&&this.setMirror(this.maps.length-1,mirrors)}
/**
    Add all the step maps in a given mapping to this one (preserving
    mirroring information).
    */appendMapping(mapping){for(let i=0,startSize=this.maps.length;i<mapping.maps.length;i++){let mirr=mapping.getMirror(i);this.appendMap(mapping.maps[i],null!=mirr&&mirr<i?startSize+mirr:void 0)}}
/**
    Finds the offset of the step map that mirrors the map at the
    given offset, in this mapping (as per the second argument to
    `appendMap`).
    */getMirror(n){if(this.mirror)for(let i=0;i<this.mirror.length;i++)if(this.mirror[i]==n)return this.mirror[i+(i%2?-1:1)]}
/**
    @internal
    */setMirror(n,m){this.mirror||(this.mirror=[]),this.mirror.push(n,m)}
/**
    Append the inverse of the given mapping to this one.
    */appendMappingInverted(mapping){for(let i=mapping.maps.length-1,totalSize=this.maps.length+mapping.maps.length;i>=0;i--){let mirr=mapping.getMirror(i);this.appendMap(mapping.maps[i].invert(),null!=mirr&&mirr>i?totalSize-mirr-1:void 0)}}
/**
    Create an inverted version of this mapping.
    */invert(){let inverse=new Mapping$1;return inverse.appendMappingInverted(this),inverse}
/**
    Map a position through this mapping.
    */map(pos,assoc=1){if(this.mirror)return this._map(pos,assoc,!0);for(let i=this.from;i<this.to;i++)pos=this.maps[i].map(pos,assoc);return pos}
/**
    Map a position through this mapping, returning a mapping
    result.
    */mapResult(pos,assoc=1){return this._map(pos,assoc,!1)}
/**
    @internal
    */_map(pos,assoc,simple){let delInfo=0;for(let i=this.from;i<this.to;i++){let map=this.maps[i],result=map.mapResult(pos,assoc);if(null!=result.recover){let corr=this.getMirror(i);if(null!=corr&&corr>i&&corr<this.to){i=corr,pos=this.maps[corr].recover(result.recover);continue}}delInfo|=result.delInfo,pos=result.pos}return simple?pos:new MapResult$1(pos,delInfo,null)}}const stepsByID$1=Object.create(null);
/**
A step object represents an atomic change. It generally applies
only to the document it was created for, since the positions
stored in it will only make sense for that document.

New steps are defined by creating classes that extend `Step`,
overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`
methods, and registering your class with a unique
JSON-serialization identifier using
[`Step.jsonID`](https://prosemirror.net/docs/ref/#transform.Step^jsonID).
*/class Step$1{
/**
    Get the step map that represents the changes made by this step,
    and which can be used to transform between positions in the old
    and the new document.
    */
getMap(){return StepMap$1.empty}
/**
    Try to merge this step with another one, to be applied directly
    after it. Returns the merged step when possible, null if the
    steps can't be merged.
    */merge(other){return null}
/**
    Deserialize a step from its JSON representation. Will call
    through to the step class' own implementation of this method.
    */static fromJSON(schema,json){if(!json||!json.stepType)throw new RangeError("Invalid input for Step.fromJSON");let type=stepsByID$1[json.stepType];if(!type)throw new RangeError(`No step type ${json.stepType} defined`);return type.fromJSON(schema,json)}
/**
    To be able to serialize steps to JSON, each step needs a string
    ID to attach to its JSON representation. Use this method to
    register an ID for your step classes. Try to pick something
    that's unlikely to clash with steps from other modules.
    */static jsonID(id,stepClass){if(id in stepsByID$1)throw new RangeError("Duplicate use of step JSON ID "+id);return stepsByID$1[id]=stepClass,stepClass.prototype.jsonID=id,stepClass}}
/**
The result of [applying](https://prosemirror.net/docs/ref/#transform.Step.apply) a step. Contains either a
new document or a failure value.
*/class StepResult$1{
/**
    @internal
    */
constructor(
/**
    The transformed document, if successful.
    */
doc,
/**
    The failure message, if unsuccessful.
    */
failed){this.doc=doc,this.failed=failed}
/**
    Create a successful step result.
    */static ok(doc){return new StepResult$1(doc,null)}
/**
    Create a failed step result.
    */static fail(message){return new StepResult$1(null,message)}
/**
    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
    arguments. Create a successful result if it succeeds, and a
    failed one if it throws a `ReplaceError`.
    */static fromReplace(doc,from,to,slice){try{return StepResult$1.ok(doc.replace(from,to,slice))}catch(e){if(e instanceof ReplaceError$1)return StepResult$1.fail(e.message);throw e}}}function mapFragment$1(fragment,f,parent){let mapped=[];for(let i=0;i<fragment.childCount;i++){let child=fragment.child(i);child.content.size&&(child=child.copy(mapFragment$1(child.content,f,child))),child.isInline&&(child=f(child,parent,i)),mapped.push(child)}return Fragment$1.fromArray(mapped)}
/**
Add a mark to all inline content between two positions.
*/class AddMarkStep$1 extends Step$1{
/**
    Create a mark step.
    */
constructor(
/**
    The start of the marked range.
    */
from,
/**
    The end of the marked range.
    */
to,
/**
    The mark to add.
    */
mark){super(),this.from=from,this.to=to,this.mark=mark}apply(doc){let oldSlice=doc.slice(this.from,this.to),$from=doc.resolve(this.from),parent=$from.node($from.sharedDepth(this.to)),slice=new Slice$1(mapFragment$1(oldSlice.content,((node,parent)=>node.isAtom&&parent.type.allowsMarkType(this.mark.type)?node.mark(this.mark.addToSet(node.marks)):node),parent),oldSlice.openStart,oldSlice.openEnd);return StepResult$1.fromReplace(doc,this.from,this.to,slice)}invert(){return new RemoveMarkStep$1(this.from,this.to,this.mark)}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1);return from.deleted&&to.deleted||from.pos>=to.pos?null:new AddMarkStep$1(from.pos,to.pos,this.mark)}merge(other){return other instanceof AddMarkStep$1&&other.mark.eq(this.mark)&&this.from<=other.to&&this.to>=other.from?new AddMarkStep$1(Math.min(this.from,other.from),Math.max(this.to,other.to),this.mark):null}toJSON(){return{stepType:"addMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to)throw new RangeError("Invalid input for AddMarkStep.fromJSON");return new AddMarkStep$1(json.from,json.to,schema.markFromJSON(json.mark))}}Step$1.jsonID("addMark",AddMarkStep$1);
/**
Remove a mark from all inline content between two positions.
*/
class RemoveMarkStep$1 extends Step$1{
/**
    Create a mark-removing step.
    */
constructor(
/**
    The start of the unmarked range.
    */
from,
/**
    The end of the unmarked range.
    */
to,
/**
    The mark to remove.
    */
mark){super(),this.from=from,this.to=to,this.mark=mark}apply(doc){let oldSlice=doc.slice(this.from,this.to),slice=new Slice$1(mapFragment$1(oldSlice.content,(node=>node.mark(this.mark.removeFromSet(node.marks))),doc),oldSlice.openStart,oldSlice.openEnd);return StepResult$1.fromReplace(doc,this.from,this.to,slice)}invert(){return new AddMarkStep$1(this.from,this.to,this.mark)}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1);return from.deleted&&to.deleted||from.pos>=to.pos?null:new RemoveMarkStep$1(from.pos,to.pos,this.mark)}merge(other){return other instanceof RemoveMarkStep$1&&other.mark.eq(this.mark)&&this.from<=other.to&&this.to>=other.from?new RemoveMarkStep$1(Math.min(this.from,other.from),Math.max(this.to,other.to),this.mark):null}toJSON(){return{stepType:"removeMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to)throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");return new RemoveMarkStep$1(json.from,json.to,schema.markFromJSON(json.mark))}}Step$1.jsonID("removeMark",RemoveMarkStep$1);
/**
Replace a part of the document with a slice of new content.
*/
class ReplaceStep$1 extends Step$1{
/**
    The given `slice` should fit the 'gap' between `from` and
    `to`—the depths must line up, and the surrounding nodes must be
    able to be joined with the open sides of the slice. When
    `structure` is true, the step will fail if the content between
    from and to is not just a sequence of closing and then opening
    tokens (this is to guard against rebased replace steps
    overwriting something they weren't supposed to).
    */
constructor(
/**
    The start position of the replaced range.
    */
from,
/**
    The end position of the replaced range.
    */
to,
/**
    The slice to insert.
    */
slice,
/**
    @internal
    */
structure=!1){super(),this.from=from,this.to=to,this.slice=slice,this.structure=structure}apply(doc){return this.structure&&contentBetween$1(doc,this.from,this.to)?StepResult$1.fail("Structure replace would overwrite content"):StepResult$1.fromReplace(doc,this.from,this.to,this.slice)}getMap(){return new StepMap$1([this.from,this.to-this.from,this.slice.size])}invert(doc){return new ReplaceStep$1(this.from,this.from+this.slice.size,doc.slice(this.from,this.to))}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1);return from.deletedAcross&&to.deletedAcross?null:new ReplaceStep$1(from.pos,Math.max(from.pos,to.pos),this.slice)}merge(other){if(!(other instanceof ReplaceStep$1)||other.structure||this.structure)return null;if(this.from+this.slice.size!=other.from||this.slice.openEnd||other.slice.openStart){if(other.to!=this.from||this.slice.openStart||other.slice.openEnd)return null;{let slice=this.slice.size+other.slice.size==0?Slice$1.empty:new Slice$1(other.slice.content.append(this.slice.content),other.slice.openStart,this.slice.openEnd);return new ReplaceStep$1(other.from,this.to,slice,this.structure)}}{let slice=this.slice.size+other.slice.size==0?Slice$1.empty:new Slice$1(this.slice.content.append(other.slice.content),this.slice.openStart,other.slice.openEnd);return new ReplaceStep$1(this.from,this.to+(other.to-other.from),slice,this.structure)}}toJSON(){let json={stepType:"replace",from:this.from,to:this.to};return this.slice.size&&(json.slice=this.slice.toJSON()),this.structure&&(json.structure=!0),json}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to)throw new RangeError("Invalid input for ReplaceStep.fromJSON");return new ReplaceStep$1(json.from,json.to,Slice$1.fromJSON(schema,json.slice),!!json.structure)}}Step$1.jsonID("replace",ReplaceStep$1);
/**
Replace a part of the document with a slice of content, but
preserve a range of the replaced content by moving it into the
slice.
*/
class ReplaceAroundStep$1 extends Step$1{
/**
    Create a replace-around step with the given range and gap.
    `insert` should be the point in the slice into which the content
    of the gap should be moved. `structure` has the same meaning as
    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
    */
constructor(
/**
    The start position of the replaced range.
    */
from,
/**
    The end position of the replaced range.
    */
to,
/**
    The start of preserved range.
    */
gapFrom,
/**
    The end of preserved range.
    */
gapTo,
/**
    The slice to insert.
    */
slice,
/**
    The position in the slice where the preserved range should be
    inserted.
    */
insert,
/**
    @internal
    */
structure=!1){super(),this.from=from,this.to=to,this.gapFrom=gapFrom,this.gapTo=gapTo,this.slice=slice,this.insert=insert,this.structure=structure}apply(doc){if(this.structure&&(contentBetween$1(doc,this.from,this.gapFrom)||contentBetween$1(doc,this.gapTo,this.to)))return StepResult$1.fail("Structure gap-replace would overwrite content");let gap=doc.slice(this.gapFrom,this.gapTo);if(gap.openStart||gap.openEnd)return StepResult$1.fail("Gap is not a flat range");let inserted=this.slice.insertAt(this.insert,gap.content);return inserted?StepResult$1.fromReplace(doc,this.from,this.to,inserted):StepResult$1.fail("Content does not fit in gap")}getMap(){return new StepMap$1([this.from,this.gapFrom-this.from,this.insert,this.gapTo,this.to-this.gapTo,this.slice.size-this.insert])}invert(doc){let gap=this.gapTo-this.gapFrom;return new ReplaceAroundStep$1(this.from,this.from+this.slice.size+gap,this.from+this.insert,this.from+this.insert+gap,doc.slice(this.from,this.to).removeBetween(this.gapFrom-this.from,this.gapTo-this.from),this.gapFrom-this.from,this.structure)}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1),gapFrom=mapping.map(this.gapFrom,-1),gapTo=mapping.map(this.gapTo,1);return from.deletedAcross&&to.deletedAcross||gapFrom<from.pos||gapTo>to.pos?null:new ReplaceAroundStep$1(from.pos,to.pos,gapFrom,gapTo,this.slice,this.insert,this.structure)}toJSON(){let json={stepType:"replaceAround",from:this.from,to:this.to,gapFrom:this.gapFrom,gapTo:this.gapTo,insert:this.insert};return this.slice.size&&(json.slice=this.slice.toJSON()),this.structure&&(json.structure=!0),json}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to||"number"!=typeof json.gapFrom||"number"!=typeof json.gapTo||"number"!=typeof json.insert)throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");return new ReplaceAroundStep$1(json.from,json.to,json.gapFrom,json.gapTo,Slice$1.fromJSON(schema,json.slice),json.insert,!!json.structure)}}function contentBetween$1(doc,from,to){let $from=doc.resolve(from),dist=to-from,depth=$from.depth;while(dist>0&&depth>0&&$from.indexAfter(depth)==$from.node(depth).childCount)depth--,dist--;if(dist>0){let next=$from.node(depth).maybeChild($from.indexAfter(depth));while(dist>0){if(!next||next.isLeaf)return!0;next=next.firstChild,dist--}}return!1}function addMark$1(tr,from,to,mark){let removing,adding,removed=[],added=[];tr.doc.nodesBetween(from,to,((node,pos,parent)=>{if(!node.isInline)return;let marks=node.marks;if(!mark.isInSet(marks)&&parent.type.allowsMarkType(mark.type)){let start=Math.max(pos,from),end=Math.min(pos+node.nodeSize,to),newSet=mark.addToSet(marks);for(let i=0;i<marks.length;i++)marks[i].isInSet(newSet)||(removing&&removing.to==start&&removing.mark.eq(marks[i])?removing.to=end:removed.push(removing=new RemoveMarkStep$1(start,end,marks[i])));adding&&adding.to==start?adding.to=end:added.push(adding=new AddMarkStep$1(start,end,mark))}})),removed.forEach((s=>tr.step(s))),added.forEach((s=>tr.step(s)))}function removeMark$1(tr,from,to,mark){let matched=[],step=0;tr.doc.nodesBetween(from,to,((node,pos)=>{if(!node.isInline)return;step++;let toRemove=null;if(mark instanceof MarkType$1){let found,set=node.marks;while(found=mark.isInSet(set))(toRemove||(toRemove=[])).push(found),set=found.removeFromSet(set)}else mark?mark.isInSet(node.marks)&&(toRemove=[mark]):toRemove=node.marks;if(toRemove&&toRemove.length){let end=Math.min(pos+node.nodeSize,to);for(let i=0;i<toRemove.length;i++){let found,style=toRemove[i];for(let j=0;j<matched.length;j++){let m=matched[j];m.step==step-1&&style.eq(matched[j].style)&&(found=m)}found?(found.to=end,found.step=step):matched.push({style:style,from:Math.max(pos,from),to:end,step:step})}}})),matched.forEach((m=>tr.step(new RemoveMarkStep$1(m.from,m.to,m.style))))}function clearIncompatible$1(tr,pos,parentType,match=parentType.contentMatch){let node=tr.doc.nodeAt(pos),delSteps=[],cur=pos+1;for(let i=0;i<node.childCount;i++){let child=node.child(i),end=cur+child.nodeSize,allowed=match.matchType(child.type);if(allowed){match=allowed;for(let j=0;j<child.marks.length;j++)parentType.allowsMarkType(child.marks[j].type)||tr.step(new RemoveMarkStep$1(cur,end,child.marks[j]))}else delSteps.push(new ReplaceStep$1(cur,end,Slice$1.empty));cur=end}if(!match.validEnd){let fill=match.fillBefore(Fragment$1.empty,!0);tr.replace(cur,cur,new Slice$1(fill,0,0))}for(let i=delSteps.length-1;i>=0;i--)tr.step(delSteps[i])}function canCut$1(node,start,end){return(0==start||node.canReplace(start,node.childCount))&&(end==node.childCount||node.canReplace(0,end))}
/**
Try to find a target depth to which the content in the given range
can be lifted. Will not go across
[isolating](https://prosemirror.net/docs/ref/#model.NodeSpec.isolating) parent nodes.
*/function liftTarget$1(range){let parent=range.parent,content=parent.content.cutByIndex(range.startIndex,range.endIndex);for(let depth=range.depth;;--depth){let node=range.$from.node(depth),index=range.$from.index(depth),endIndex=range.$to.indexAfter(depth);if(depth<range.depth&&node.canReplace(index,endIndex,content))return depth;if(0==depth||node.type.spec.isolating||!canCut$1(node,index,endIndex))break}return null}function lift$2$1(tr,range,target){let{$from:$from,$to:$to,depth:depth}=range,gapStart=$from.before(depth+1),gapEnd=$to.after(depth+1),start=gapStart,end=gapEnd,before=Fragment$1.empty,openStart=0;for(let d=depth,splitting=!1;d>target;d--)splitting||$from.index(d)>0?(splitting=!0,before=Fragment$1.from($from.node(d).copy(before)),openStart++):start--;let after=Fragment$1.empty,openEnd=0;for(let d=depth,splitting=!1;d>target;d--)splitting||$to.after(d+1)<$to.end(d)?(splitting=!0,after=Fragment$1.from($to.node(d).copy(after)),openEnd++):end++;tr.step(new ReplaceAroundStep$1(start,end,gapStart,gapEnd,new Slice$1(before.append(after),openStart,openEnd),before.size-openStart,!0))}
/**
Try to find a valid way to wrap the content in the given range in a
node of the given type. May introduce extra nodes around and inside
the wrapper node, if necessary. Returns null if no valid wrapping
could be found. When `innerRange` is given, that range's content is
used as the content to fit into the wrapping, instead of the
content of `range`.
*/function findWrapping$1(range,nodeType,attrs=null,innerRange=range){let around=findWrappingOutside$1(range,nodeType),inner=around&&findWrappingInside$1(innerRange,nodeType);return inner?around.map(withAttrs$1).concat({type:nodeType,attrs:attrs}).concat(inner.map(withAttrs$1)):null}function withAttrs$1(type){return{type:type,attrs:null}}function findWrappingOutside$1(range,type){let{parent:parent,startIndex:startIndex,endIndex:endIndex}=range,around=parent.contentMatchAt(startIndex).findWrapping(type);if(!around)return null;let outer=around.length?around[0]:type;return parent.canReplaceWith(startIndex,endIndex,outer)?around:null}function findWrappingInside$1(range,type){let{parent:parent,startIndex:startIndex,endIndex:endIndex}=range,inner=parent.child(startIndex),inside=type.contentMatch.findWrapping(inner.type);if(!inside)return null;let lastType=inside.length?inside[inside.length-1]:type,innerMatch=lastType.contentMatch;for(let i=startIndex;innerMatch&&i<endIndex;i++)innerMatch=innerMatch.matchType(parent.child(i).type);return innerMatch&&innerMatch.validEnd?inside:null}function wrap$1(tr,range,wrappers){let content=Fragment$1.empty;for(let i=wrappers.length-1;i>=0;i--){if(content.size){let match=wrappers[i].type.contentMatch.matchFragment(content);if(!match||!match.validEnd)throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper")}content=Fragment$1.from(wrappers[i].type.create(wrappers[i].attrs,content))}let start=range.start,end=range.end;tr.step(new ReplaceAroundStep$1(start,end,start,end,new Slice$1(content,0,0),wrappers.length,!0))}function setBlockType$1$1(tr,from,to,type,attrs){if(!type.isTextblock)throw new RangeError("Type given to setBlockType should be a textblock");let mapFrom=tr.steps.length;tr.doc.nodesBetween(from,to,((node,pos)=>{if(node.isTextblock&&!node.hasMarkup(type,attrs)&&canChangeType$1(tr.doc,tr.mapping.slice(mapFrom).map(pos),type)){
// Ensure all markup that isn't allowed in the new node type is cleared
tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos,1),type);let mapping=tr.mapping.slice(mapFrom),startM=mapping.map(pos,1),endM=mapping.map(pos+node.nodeSize,1);return tr.step(new ReplaceAroundStep$1(startM,endM,startM+1,endM-1,new Slice$1(Fragment$1.from(type.create(attrs,null,node.marks)),0,0),1,!0)),!1}}))}function canChangeType$1(doc,pos,type){let $pos=doc.resolve(pos),index=$pos.index();return $pos.parent.canReplaceWith(index,index+1,type)}
/**
Change the type, attributes, and/or marks of the node at `pos`.
When `type` isn't given, the existing node type is preserved,
*/function setNodeMarkup$1(tr,pos,type,attrs,marks){let node=tr.doc.nodeAt(pos);if(!node)throw new RangeError("No node at given position");type||(type=node.type);let newNode=type.create(attrs,null,marks||node.marks);if(node.isLeaf)return tr.replaceWith(pos,pos+node.nodeSize,newNode);if(!type.validContent(node.content))throw new RangeError("Invalid content for node type "+type.name);tr.step(new ReplaceAroundStep$1(pos,pos+node.nodeSize,pos+1,pos+node.nodeSize-1,new Slice$1(Fragment$1.from(newNode),0,0),1,!0))}
/**
Check whether splitting at the given position is allowed.
*/function canSplit$1(doc,pos,depth=1,typesAfter){let $pos=doc.resolve(pos),base=$pos.depth-depth,innerType=typesAfter&&typesAfter[typesAfter.length-1]||$pos.parent;if(base<0||$pos.parent.type.spec.isolating||!$pos.parent.canReplace($pos.index(),$pos.parent.childCount)||!innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(),$pos.parent.childCount)))return!1;for(let d=$pos.depth-1,i=depth-2;d>base;d--,i--){let node=$pos.node(d),index=$pos.index(d);if(node.type.spec.isolating)return!1;let rest=node.content.cutByIndex(index,node.childCount),after=typesAfter&&typesAfter[i]||node;if(after!=node&&(rest=rest.replaceChild(0,after.type.create(after.attrs))),!node.canReplace(index+1,node.childCount)||!after.type.validContent(rest))return!1}let index=$pos.indexAfter(base),baseType=typesAfter&&typesAfter[0];return $pos.node(base).canReplaceWith(index,index,baseType?baseType.type:$pos.node(base+1).type)}function split$1(tr,pos,depth=1,typesAfter){let $pos=tr.doc.resolve(pos),before=Fragment$1.empty,after=Fragment$1.empty;for(let d=$pos.depth,e=$pos.depth-depth,i=depth-1;d>e;d--,i--){before=Fragment$1.from($pos.node(d).copy(before));let typeAfter=typesAfter&&typesAfter[i];after=Fragment$1.from(typeAfter?typeAfter.type.create(typeAfter.attrs,after):$pos.node(d).copy(after))}tr.step(new ReplaceStep$1(pos,pos,new Slice$1(before.append(after),depth,depth),!0))}
/**
Test whether the blocks before and after a given position can be
joined.
*/function canJoin$1(doc,pos){let $pos=doc.resolve(pos),index=$pos.index();return joinable$2($pos.nodeBefore,$pos.nodeAfter)&&$pos.parent.canReplace(index,index+1)}function joinable$2(a,b){return!(!a||!b||a.isLeaf||!a.canAppend(b))}function join$1(tr,pos,depth){let step=new ReplaceStep$1(pos-depth,pos+depth,Slice$1.empty,!0);tr.step(step)}
/**
Try to find a point where a node of the given type can be inserted
near `pos`, by searching up the node hierarchy when `pos` itself
isn't a valid place but is at the start or end of a node. Return
null if no position was found.
*/function insertPoint$1(doc,pos,nodeType){let $pos=doc.resolve(pos);if($pos.parent.canReplaceWith($pos.index(),$pos.index(),nodeType))return pos;if(0==$pos.parentOffset)for(let d=$pos.depth-1;d>=0;d--){let index=$pos.index(d);if($pos.node(d).canReplaceWith(index,index,nodeType))return $pos.before(d+1);if(index>0)return null}if($pos.parentOffset==$pos.parent.content.size)for(let d=$pos.depth-1;d>=0;d--){let index=$pos.indexAfter(d);if($pos.node(d).canReplaceWith(index,index,nodeType))return $pos.after(d+1);if(index<$pos.node(d).childCount)return null}return null}
/**
Finds a position at or around the given position where the given
slice can be inserted. Will look at parent nodes' nearest boundary
and try there, even if the original position wasn't directly at the
start or end of that node. Returns null when no position was found.
*/function dropPoint$1(doc,pos,slice){let $pos=doc.resolve(pos);if(!slice.content.size)return pos;let content=slice.content;for(let i=0;i<slice.openStart;i++)content=content.firstChild.content;for(let pass=1;pass<=(0==slice.openStart&&slice.size?2:1);pass++)for(let d=$pos.depth;d>=0;d--){let bias=d==$pos.depth?0:$pos.pos<=($pos.start(d+1)+$pos.end(d+1))/2?-1:1,insertPos=$pos.index(d)+(bias>0?1:0),parent=$pos.node(d),fits=!1;if(1==pass)fits=parent.canReplace(insertPos,insertPos,content);else{let wrapping=parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);fits=wrapping&&parent.canReplaceWith(insertPos,insertPos,wrapping[0])}if(fits)return 0==bias?$pos.pos:bias<0?$pos.before(d+1):$pos.after(d+1)}return null}
/**
‘Fit’ a slice into a given position in the document, producing a
[step](https://prosemirror.net/docs/ref/#transform.Step) that inserts it. Will return null if
there's no meaningful way to insert the slice here, or inserting it
would be a no-op (an empty slice over an empty range).
*/function replaceStep$1(doc,from,to=from,slice=Slice$1.empty){if(from==to&&!slice.size)return null;let $from=doc.resolve(from),$to=doc.resolve(to);
// Optimization -- avoid work if it's obvious that it's not needed.
return fitsTrivially$1($from,$to,slice)?new ReplaceStep$1(from,to,slice):new Fitter$1($from,$to,slice).fit()}function fitsTrivially$1($from,$to,slice){return!slice.openStart&&!slice.openEnd&&$from.start()==$to.start()&&$from.parent.canReplace($from.index(),$to.index(),slice.content)}
// Algorithm for 'placing' the elements of a slice into a gap:

// We consider the content of each node that is open to the left to be
// independently placeable. I.e. in <p("foo"), p("bar")>, when the
// paragraph on the left is open, "foo" can be placed (somewhere on
// the left side of the replacement gap) independently from p("bar").

// This class tracks the state of the placement progress in the
// following properties:

//  - `frontier` holds a stack of `{type, match}` objects that
//    represent the open side of the replacement. It starts at
//    `$from`, then moves forward as content is placed, and is finally
//    reconciled with `$to`.

//  - `unplaced` is a slice that represents the content that hasn't
//    been placed yet.

//  - `placed` is a fragment of placed content. Its open-start value
//    is implicit in `$from`, and its open-end value in `frontier`.
Step$1.jsonID("replaceAround",ReplaceAroundStep$1);class Fitter$1{constructor($from,$to,unplaced){this.$from=$from,this.$to=$to,this.unplaced=unplaced,this.frontier=[],this.placed=Fragment$1.empty;for(let i=0;i<=$from.depth;i++){let node=$from.node(i);this.frontier.push({type:node.type,match:node.contentMatchAt($from.indexAfter(i))})}for(let i=$from.depth;i>0;i--)this.placed=Fragment$1.from($from.node(i).copy(this.placed))}get depth(){return this.frontier.length-1}fit(){
// As long as there's unplaced content, try to place some of it.
// If that fails, either increase the open score of the unplaced
// slice, or drop nodes from it, and then try again.
while(this.unplaced.size){let fit=this.findFittable();fit?this.placeNodes(fit):this.openMore()||this.dropNode()}
// When there's inline content directly after the frontier _and_
// directly after `this.$to`, we must generate a `ReplaceAround`
// step that pulls that content into the node after the frontier.
// That means the fitting must be done to the end of the textblock
// node after `this.$to`, not `this.$to` itself.
let moveInline=this.mustMoveInline(),placedSize=this.placed.size-this.depth-this.$from.depth,$from=this.$from,$to=this.close(moveInline<0?this.$to:$from.doc.resolve(moveInline));if(!$to)return null;
// If closing to `$to` succeeded, create a step
let content=this.placed,openStart=$from.depth,openEnd=$to.depth;while(openStart&&openEnd&&1==content.childCount)// Normalize by dropping open parent nodes
content=content.firstChild.content,openStart--,openEnd--;let slice=new Slice$1(content,openStart,openEnd);return moveInline>-1?new ReplaceAroundStep$1($from.pos,moveInline,this.$to.pos,this.$to.end(),slice,placedSize):slice.size||$from.pos!=this.$to.pos?new ReplaceStep$1($from.pos,$to.pos,slice):null}
// Find a position on the start spine of `this.unplaced` that has
// content that can be moved somewhere on the frontier. Returns two
// depths, one for the slice and one for the frontier.
findFittable(){
// Only try wrapping nodes (pass 2) after finding a place without
// wrapping failed.
for(let pass=1;pass<=2;pass++)for(let sliceDepth=this.unplaced.openStart;sliceDepth>=0;sliceDepth--){let fragment,parent=null;sliceDepth?(parent=contentAt$1(this.unplaced.content,sliceDepth-1).firstChild,fragment=parent.content):fragment=this.unplaced.content;let first=fragment.firstChild;for(let frontierDepth=this.depth;frontierDepth>=0;frontierDepth--){let wrap,{type:type,match:match}=this.frontier[frontierDepth],inject=null;
// In pass 1, if the next node matches, or there is no next
// node but the parents look compatible, we've found a
// place.
if(1==pass&&(first?match.matchType(first.type)||(inject=match.fillBefore(Fragment$1.from(first),!1)):parent&&type.compatibleContent(parent.type)))return{sliceDepth:sliceDepth,frontierDepth:frontierDepth,parent:parent,inject:inject};
// In pass 2, look for a set of wrapping nodes that make
// `first` fit here.
// Don't continue looking further up if the parent node
// would fit here.
if(2==pass&&first&&(wrap=match.findWrapping(first.type)))return{sliceDepth:sliceDepth,frontierDepth:frontierDepth,parent:parent,wrap:wrap};if(parent&&match.matchType(parent.type))break}}}openMore(){let{content:content,openStart:openStart,openEnd:openEnd}=this.unplaced,inner=contentAt$1(content,openStart);return!(!inner.childCount||inner.firstChild.isLeaf)&&(this.unplaced=new Slice$1(content,openStart+1,Math.max(openEnd,inner.size+openStart>=content.size-openEnd?openStart+1:0)),!0)}dropNode(){let{content:content,openStart:openStart,openEnd:openEnd}=this.unplaced,inner=contentAt$1(content,openStart);if(inner.childCount<=1&&openStart>0){let openAtEnd=content.size-openStart<=openStart+inner.size;this.unplaced=new Slice$1(dropFromFragment$1(content,openStart-1,1),openStart-1,openAtEnd?openStart-1:openEnd)}else this.unplaced=new Slice$1(dropFromFragment$1(content,openStart,1),openStart,openEnd)}
// Move content from the unplaced slice at `sliceDepth` to the
// frontier node at `frontierDepth`. Close that frontier node when
// applicable.
placeNodes({sliceDepth:sliceDepth,frontierDepth:frontierDepth,parent:parent,inject:inject,wrap:wrap}){while(this.depth>frontierDepth)this.closeFrontierNode();if(wrap)for(let i=0;i<wrap.length;i++)this.openFrontierNode(wrap[i]);let slice=this.unplaced,fragment=parent?parent.content:slice.content,openStart=slice.openStart-sliceDepth,taken=0,add=[],{match:match,type:type}=this.frontier[frontierDepth];if(inject){for(let i=0;i<inject.childCount;i++)add.push(inject.child(i));match=match.matchFragment(inject)}
// Computes the amount of (end) open nodes at the end of the
// fragment. When 0, the parent is open, but no more. When
// negative, nothing is open.
let openEndCount=fragment.size+sliceDepth-(slice.content.size-slice.openEnd);
// Scan over the fragment, fitting as many child nodes as
// possible.
while(taken<fragment.childCount){let next=fragment.child(taken),matches=match.matchType(next.type);if(!matches)break;taken++,(taken>1||0==openStart||next.content.size)&&(// Drop empty open nodes
match=matches,add.push(closeNodeStart$1(next.mark(type.allowedMarks(next.marks)),1==taken?openStart:0,taken==fragment.childCount?openEndCount:-1)))}let toEnd=taken==fragment.childCount;toEnd||(openEndCount=-1),this.placed=addToFragment$1(this.placed,frontierDepth,Fragment$1.from(add)),this.frontier[frontierDepth].match=match,
// If the parent types match, and the entire node was moved, and
// it's not open, close this frontier node right away.
toEnd&&openEndCount<0&&parent&&parent.type==this.frontier[this.depth].type&&this.frontier.length>1&&this.closeFrontierNode();
// Add new frontier nodes for any open nodes at the end.
for(let i=0,cur=fragment;i<openEndCount;i++){let node=cur.lastChild;this.frontier.push({type:node.type,match:node.contentMatchAt(node.childCount)}),cur=node.content}
// Update `this.unplaced`. Drop the entire node from which we
// placed it we got to its end, otherwise just drop the placed
// nodes.
this.unplaced=toEnd?0==sliceDepth?Slice$1.empty:new Slice$1(dropFromFragment$1(slice.content,sliceDepth-1,1),sliceDepth-1,openEndCount<0?slice.openEnd:sliceDepth-1):new Slice$1(dropFromFragment$1(slice.content,sliceDepth,taken),slice.openStart,slice.openEnd)}mustMoveInline(){if(!this.$to.parent.isTextblock)return-1;let level,top=this.frontier[this.depth];if(!top.type.isTextblock||!contentAfterFits$1(this.$to,this.$to.depth,top.type,top.match,!1)||this.$to.depth==this.depth&&(level=this.findCloseLevel(this.$to))&&level.depth==this.depth)return-1;let{depth:depth}=this.$to,after=this.$to.after(depth);while(depth>1&&after==this.$to.end(--depth))++after;return after}findCloseLevel($to){scan:for(let i=Math.min(this.depth,$to.depth);i>=0;i--){let{match:match,type:type}=this.frontier[i],dropInner=i<$to.depth&&$to.end(i+1)==$to.pos+($to.depth-(i+1)),fit=contentAfterFits$1($to,i,type,match,dropInner);if(fit){for(let d=i-1;d>=0;d--){let{match:match,type:type}=this.frontier[d],matches=contentAfterFits$1($to,d,type,match,!0);if(!matches||matches.childCount)continue scan}return{depth:i,fit:fit,move:dropInner?$to.doc.resolve($to.after(i+1)):$to}}}}close($to){let close=this.findCloseLevel($to);if(!close)return null;while(this.depth>close.depth)this.closeFrontierNode();close.fit.childCount&&(this.placed=addToFragment$1(this.placed,close.depth,close.fit)),$to=close.move;for(let d=close.depth+1;d<=$to.depth;d++){let node=$to.node(d),add=node.type.contentMatch.fillBefore(node.content,!0,$to.index(d));this.openFrontierNode(node.type,node.attrs,add)}return $to}openFrontierNode(type,attrs=null,content){let top=this.frontier[this.depth];top.match=top.match.matchType(type),this.placed=addToFragment$1(this.placed,this.depth,Fragment$1.from(type.create(attrs,content))),this.frontier.push({type:type,match:type.contentMatch})}closeFrontierNode(){let open=this.frontier.pop(),add=open.match.fillBefore(Fragment$1.empty,!0);add.childCount&&(this.placed=addToFragment$1(this.placed,this.frontier.length,add))}}function dropFromFragment$1(fragment,depth,count){return 0==depth?fragment.cutByIndex(count,fragment.childCount):fragment.replaceChild(0,fragment.firstChild.copy(dropFromFragment$1(fragment.firstChild.content,depth-1,count)))}function addToFragment$1(fragment,depth,content){return 0==depth?fragment.append(content):fragment.replaceChild(fragment.childCount-1,fragment.lastChild.copy(addToFragment$1(fragment.lastChild.content,depth-1,content)))}function contentAt$1(fragment,depth){for(let i=0;i<depth;i++)fragment=fragment.firstChild.content;return fragment}function closeNodeStart$1(node,openStart,openEnd){if(openStart<=0)return node;let frag=node.content;return openStart>1&&(frag=frag.replaceChild(0,closeNodeStart$1(frag.firstChild,openStart-1,1==frag.childCount?openEnd-1:0))),openStart>0&&(frag=node.type.contentMatch.fillBefore(frag).append(frag),openEnd<=0&&(frag=frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment$1.empty,!0)))),node.copy(frag)}function contentAfterFits$1($to,depth,type,match,open){let node=$to.node(depth),index=open?$to.indexAfter(depth):$to.index(depth);if(index==node.childCount&&!type.compatibleContent(node.type))return null;let fit=match.fillBefore(node.content,!0,index);return fit&&!invalidMarks$1(type,node.content,index)?fit:null}function invalidMarks$1(type,fragment,start){for(let i=start;i<fragment.childCount;i++)if(!type.allowsMarks(fragment.child(i).marks))return!0;return!1}function definesContent$1(type){return type.spec.defining||type.spec.definingForContent}function replaceRange$1(tr,from,to,slice){if(!slice.size)return tr.deleteRange(from,to);let $from=tr.doc.resolve(from),$to=tr.doc.resolve(to);if(fitsTrivially$1($from,$to,slice))return tr.step(new ReplaceStep$1(from,to,slice));let targetDepths=coveredDepths$1($from,tr.doc.resolve(to));
// Can't replace the whole document, so remove 0 if it's present
0==targetDepths[targetDepths.length-1]&&targetDepths.pop();
// Negative numbers represent not expansion over the whole node at
// that depth, but replacing from $from.before(-D) to $to.pos.
let preferredTarget=-($from.depth+1);targetDepths.unshift(preferredTarget);
// This loop picks a preferred target depth, if one of the covering
// depths is not outside of a defining node, and adds negative
// depths for any depth that has $from at its start and does not
// cross a defining node.
for(let d=$from.depth,pos=$from.pos-1;d>0;d--,pos--){let spec=$from.node(d).type.spec;if(spec.defining||spec.definingAsContext||spec.isolating)break;targetDepths.indexOf(d)>-1?preferredTarget=d:$from.before(d)==pos&&targetDepths.splice(1,0,-d)}
// Try to fit each possible depth of the slice into each possible
// target depth, starting with the preferred depths.
let preferredTargetIndex=targetDepths.indexOf(preferredTarget),leftNodes=[],preferredDepth=slice.openStart;for(let content=slice.content,i=0;;i++){let node=content.firstChild;if(leftNodes.push(node),i==slice.openStart)break;content=node.content}
// Back up preferredDepth to cover defining textblocks directly
// above it, possibly skipping a non-defining textblock.
for(let d=preferredDepth-1;d>=0;d--){let type=leftNodes[d].type,def=definesContent$1(type);if(def&&$from.node(preferredTargetIndex).type!=type)preferredDepth=d;else if(def||!type.isTextblock)break}for(let j=slice.openStart;j>=0;j--){let openDepth=(j+preferredDepth+1)%(slice.openStart+1),insert=leftNodes[openDepth];if(insert)for(let i=0;i<targetDepths.length;i++){
// Loop over possible expansion levels, starting with the
// preferred one
let targetDepth=targetDepths[(i+preferredTargetIndex)%targetDepths.length],expand=!0;targetDepth<0&&(expand=!1,targetDepth=-targetDepth);let parent=$from.node(targetDepth-1),index=$from.index(targetDepth-1);if(parent.canReplaceWith(index,index,insert.type,insert.marks))return tr.replace($from.before(targetDepth),expand?$to.after(targetDepth):to,new Slice$1(closeFragment$1(slice.content,0,slice.openStart,openDepth),openDepth,slice.openEnd))}}let startSteps=tr.steps.length;for(let i=targetDepths.length-1;i>=0;i--){if(tr.replace(from,to,slice),tr.steps.length>startSteps)break;let depth=targetDepths[i];depth<0||(from=$from.before(depth),to=$to.after(depth))}}function closeFragment$1(fragment,depth,oldOpen,newOpen,parent){if(depth<oldOpen){let first=fragment.firstChild;fragment=fragment.replaceChild(0,first.copy(closeFragment$1(first.content,depth+1,oldOpen,newOpen,first)))}if(depth>newOpen){let match=parent.contentMatchAt(0),start=match.fillBefore(fragment).append(fragment);fragment=start.append(match.matchFragment(start).fillBefore(Fragment$1.empty,!0))}return fragment}function replaceRangeWith$1(tr,from,to,node){if(!node.isInline&&from==to&&tr.doc.resolve(from).parent.content.size){let point=insertPoint$1(tr.doc,from,node.type);null!=point&&(from=to=point)}tr.replaceRange(from,to,new Slice$1(Fragment$1.from(node),0,0))}function deleteRange$1$1(tr,from,to){let $from=tr.doc.resolve(from),$to=tr.doc.resolve(to),covered=coveredDepths$1($from,$to);for(let i=0;i<covered.length;i++){let depth=covered[i],last=i==covered.length-1;if(last&&0==depth||$from.node(depth).type.contentMatch.validEnd)return tr.delete($from.start(depth),$to.end(depth));if(depth>0&&(last||$from.node(depth-1).canReplace($from.index(depth-1),$to.indexAfter(depth-1))))return tr.delete($from.before(depth),$to.after(depth))}for(let d=1;d<=$from.depth&&d<=$to.depth;d++)if(from-$from.start(d)==$from.depth-d&&to>$from.end(d)&&$to.end(d)-to!=$to.depth-d)return tr.delete($from.before(d),to);tr.delete(from,to)}
// Returns an array of all depths for which $from - $to spans the
// whole content of the nodes at that depth.
function coveredDepths$1($from,$to){let result=[],minDepth=Math.min($from.depth,$to.depth);for(let d=minDepth;d>=0;d--){let start=$from.start(d);if(start<$from.pos-($from.depth-d)||$to.end(d)>$to.pos+($to.depth-d)||$from.node(d).type.spec.isolating||$to.node(d).type.spec.isolating)break;(start==$to.start(d)||d==$from.depth&&d==$to.depth&&$from.parent.inlineContent&&$to.parent.inlineContent&&d&&$to.start(d-1)==start-1)&&result.push(d)}return result}
/**
@internal
*/let TransformError$1=class extends Error{};TransformError$1=function TransformError(message){let err=Error.call(this,message);return err.__proto__=TransformError.prototype,err},TransformError$1.prototype=Object.create(Error.prototype),TransformError$1.prototype.constructor=TransformError$1,TransformError$1.prototype.name="TransformError";
/**
Abstraction to build up and track an array of
[steps](https://prosemirror.net/docs/ref/#transform.Step) representing a document transformation.

Most transforming methods return the `Transform` object itself, so
that they can be chained.
*/
class Transform$1{
/**
    Create a transform that starts with the given document.
    */
constructor(
/**
    The current document (the result of applying the steps in the
    transform).
    */
doc){this.doc=doc,
/**
        The steps in this transform.
        */
this.steps=[],
/**
        The documents before each of the steps.
        */
this.docs=[],
/**
        A mapping with the maps for each of the steps in this transform.
        */
this.mapping=new Mapping$1}
/**
    The starting document.
    */get before(){return this.docs.length?this.docs[0]:this.doc}
/**
    Apply a new step in this transform, saving the result. Throws an
    error when the step fails.
    */step(step){let result=this.maybeStep(step);if(result.failed)throw new TransformError$1(result.failed);return this}
/**
    Try to apply a step in this transformation, ignoring it if it
    fails. Returns the step result.
    */maybeStep(step){let result=step.apply(this.doc);return result.failed||this.addStep(step,result.doc),result}
/**
    True when the document has been changed (when there are any
    steps).
    */get docChanged(){return this.steps.length>0}
/**
    @internal
    */addStep(step,doc){this.docs.push(this.doc),this.steps.push(step),this.mapping.appendMap(step.getMap()),this.doc=doc}
/**
    Replace the part of the document between `from` and `to` with the
    given `slice`.
    */replace(from,to=from,slice=Slice$1.empty){let step=replaceStep$1(this.doc,from,to,slice);return step&&this.step(step),this}
/**
    Replace the given range with the given content, which may be a
    fragment, node, or array of nodes.
    */replaceWith(from,to,content){return this.replace(from,to,new Slice$1(Fragment$1.from(content),0,0))}
/**
    Delete the content between the given positions.
    */delete(from,to){return this.replace(from,to,Slice$1.empty)}
/**
    Insert the given content at the given position.
    */insert(pos,content){return this.replaceWith(pos,pos,content)}
/**
    Replace a range of the document with a given slice, using
    `from`, `to`, and the slice's
    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
    than fixed start and end points. This method may grow the
    replaced area or close open nodes in the slice in order to get a
    fit that is more in line with WYSIWYG expectations, by dropping
    fully covered parent nodes of the replaced region when they are
    marked [non-defining as
    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
    open parent node from the slice that _is_ marked as [defining
    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
    
    This is the method, for example, to handle paste. The similar
    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
    primitive tool which will _not_ move the start and end of its given
    range, and is useful in situations where you need more precise
    control over what happens.
    */replaceRange(from,to,slice){return replaceRange$1(this,from,to,slice),this}
/**
    Replace the given range with a node, but use `from` and `to` as
    hints, rather than precise positions. When from and to are the same
    and are at the start or end of a parent node in which the given
    node doesn't fit, this method may _move_ them out towards a parent
    that does allow the given node to be placed. When the given range
    completely covers a parent node, this method may completely replace
    that parent node.
    */replaceRangeWith(from,to,node){return replaceRangeWith$1(this,from,to,node),this}
/**
    Delete the given range, expanding it to cover fully covered
    parent nodes until a valid replace is found.
    */deleteRange(from,to){return deleteRange$1$1(this,from,to),this}
/**
    Split the content in the given range off from its parent, if there
    is sibling content before or after it, and move it up the tree to
    the depth specified by `target`. You'll probably want to use
    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
    sure the lift is valid.
    */lift(range,target){return lift$2$1(this,range,target),this}
/**
    Join the blocks around the given position. If depth is 2, their
    last and first siblings are also joined, and so on.
    */join(pos,depth=1){return join$1(this,pos,depth),this}
/**
    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
    The wrappers are assumed to be valid in this position, and should
    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
    */wrap(range,wrappers){return wrap$1(this,range,wrappers),this}
/**
    Set the type of all textblocks (partly) between `from` and `to` to
    the given node type with the given attributes.
    */setBlockType(from,to=from,type,attrs=null){return setBlockType$1$1(this,from,to,type,attrs),this}
/**
    Change the type, attributes, and/or marks of the node at `pos`.
    When `type` isn't given, the existing node type is preserved,
    */setNodeMarkup(pos,type,attrs=null,marks=[]){return setNodeMarkup$1(this,pos,type,attrs,marks),this}
/**
    Split the node at the given position, and optionally, if `depth` is
    greater than one, any number of nodes above that. By default, the
    parts split off will inherit the node type of the original node.
    This can be changed by passing an array of types and attributes to
    use after the split.
    */split(pos,depth=1,typesAfter){return split$1(this,pos,depth,typesAfter),this}
/**
    Add the given mark to the inline content between `from` and `to`.
    */addMark(from,to,mark){return addMark$1(this,from,to,mark),this}
/**
    Remove marks from inline nodes between `from` and `to`. When
    `mark` is a single mark, remove precisely that mark. When it is
    a mark type, remove all marks of that type. When it is null,
    remove all marks of any type.
    */removeMark(from,to,mark){return removeMark$1(this,from,to,mark),this}
/**
    Removes all marks and nodes from the content of the node at
    `pos` that don't match the given new parent node type. Accepts
    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
    third argument.
    */clearIncompatible(pos,parentType,match){return clearIncompatible$1(this,pos,parentType,match),this}}const classesById$1=Object.create(null);
/**
Superclass for editor selections. Every selection type should
extend this. Should not be instantiated directly.
*/class Selection$1{
/**
    Initialize a selection with the head and anchor and ranges. If no
    ranges are given, constructs a single range across `$anchor` and
    `$head`.
    */
constructor(
/**
    The resolved anchor of the selection (the side that stays in
    place when the selection is modified).
    */
$anchor,
/**
    The resolved head of the selection (the side that moves when
    the selection is modified).
    */
$head,ranges){this.$anchor=$anchor,this.$head=$head,this.ranges=ranges||[new SelectionRange$1($anchor.min($head),$anchor.max($head))]}
/**
    The selection's anchor, as an unresolved position.
    */get anchor(){return this.$anchor.pos}
/**
    The selection's head.
    */get head(){return this.$head.pos}
/**
    The lower bound of the selection's main range.
    */get from(){return this.$from.pos}
/**
    The upper bound of the selection's main range.
    */get to(){return this.$to.pos}
/**
    The resolved lower  bound of the selection's main range.
    */get $from(){return this.ranges[0].$from}
/**
    The resolved upper bound of the selection's main range.
    */get $to(){return this.ranges[0].$to}
/**
    Indicates whether the selection contains any content.
    */get empty(){let ranges=this.ranges;for(let i=0;i<ranges.length;i++)if(ranges[i].$from.pos!=ranges[i].$to.pos)return!1;return!0}
/**
    Get the content of this selection as a slice.
    */content(){return this.$from.doc.slice(this.from,this.to,!0)}
/**
    Replace the selection with a slice or, if no slice is given,
    delete the selection. Will append to the given transaction.
    */replace(tr,content=Slice$1.empty){
// Put the new selection at the position after the inserted
// content. When that ended in an inline node, search backwards,
// to get the position after that node. If not, search forward.
let lastNode=content.content.lastChild,lastParent=null;for(let i=0;i<content.openEnd;i++)lastParent=lastNode,lastNode=lastNode.lastChild;let mapFrom=tr.steps.length,ranges=this.ranges;for(let i=0;i<ranges.length;i++){let{$from:$from,$to:$to}=ranges[i],mapping=tr.mapping.slice(mapFrom);tr.replaceRange(mapping.map($from.pos),mapping.map($to.pos),i?Slice$1.empty:content),0==i&&selectionToInsertionEnd$1$1(tr,mapFrom,(lastNode?lastNode.isInline:lastParent&&lastParent.isTextblock)?-1:1)}}
/**
    Replace the selection with the given node, appending the changes
    to the given transaction.
    */replaceWith(tr,node){let mapFrom=tr.steps.length,ranges=this.ranges;for(let i=0;i<ranges.length;i++){let{$from:$from,$to:$to}=ranges[i],mapping=tr.mapping.slice(mapFrom),from=mapping.map($from.pos),to=mapping.map($to.pos);i?tr.deleteRange(from,to):(tr.replaceRangeWith(from,to,node),selectionToInsertionEnd$1$1(tr,mapFrom,node.isInline?-1:1))}}
/**
    Find a valid cursor or leaf node selection starting at the given
    position and searching back if `dir` is negative, and forward if
    positive. When `textOnly` is true, only consider cursor
    selections. Will return null when no valid selection position is
    found.
    */static findFrom($pos,dir,textOnly=!1){let inner=$pos.parent.inlineContent?new TextSelection$1($pos):findSelectionIn$1($pos.node(0),$pos.parent,$pos.pos,$pos.index(),dir,textOnly);if(inner)return inner;for(let depth=$pos.depth-1;depth>=0;depth--){let found=dir<0?findSelectionIn$1($pos.node(0),$pos.node(depth),$pos.before(depth+1),$pos.index(depth),dir,textOnly):findSelectionIn$1($pos.node(0),$pos.node(depth),$pos.after(depth+1),$pos.index(depth)+1,dir,textOnly);if(found)return found}return null}
/**
    Find a valid cursor or leaf node selection near the given
    position. Searches forward first by default, but if `bias` is
    negative, it will search backwards first.
    */static near($pos,bias=1){return this.findFrom($pos,bias)||this.findFrom($pos,-bias)||new AllSelection$1($pos.node(0))}
/**
    Find the cursor or leaf node selection closest to the start of
    the given document. Will return an
    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
    exists.
    */static atStart(doc){return findSelectionIn$1(doc,doc,0,0,1)||new AllSelection$1(doc)}
/**
    Find the cursor or leaf node selection closest to the end of the
    given document.
    */static atEnd(doc){return findSelectionIn$1(doc,doc,doc.content.size,doc.childCount,-1)||new AllSelection$1(doc)}
/**
    Deserialize the JSON representation of a selection. Must be
    implemented for custom classes (as a static class method).
    */static fromJSON(doc,json){if(!json||!json.type)throw new RangeError("Invalid input for Selection.fromJSON");let cls=classesById$1[json.type];if(!cls)throw new RangeError(`No selection type ${json.type} defined`);return cls.fromJSON(doc,json)}
/**
    To be able to deserialize selections from JSON, custom selection
    classes must register themselves with an ID string, so that they
    can be disambiguated. Try to pick something that's unlikely to
    clash with classes from other modules.
    */static jsonID(id,selectionClass){if(id in classesById$1)throw new RangeError("Duplicate use of selection JSON ID "+id);return classesById$1[id]=selectionClass,selectionClass.prototype.jsonID=id,selectionClass}
/**
    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
    which is a value that can be mapped without having access to a
    current document, and later resolved to a real selection for a
    given document again. (This is used mostly by the history to
    track and restore old selections.) The default implementation of
    this method just converts the selection to a text selection and
    returns the bookmark for that.
    */getBookmark(){return TextSelection$1.between(this.$anchor,this.$head).getBookmark()}}Selection$1.prototype.visible=!0;
/**
Represents a selected range in a document.
*/
class SelectionRange$1{
/**
    Create a range.
    */
constructor(
/**
    The lower bound of the range.
    */
$from,
/**
    The upper bound of the range.
    */
$to){this.$from=$from,this.$to=$to}}let warnedAboutTextSelection$1=!1;function checkTextSelection$1($pos){warnedAboutTextSelection$1||$pos.parent.inlineContent||(warnedAboutTextSelection$1=!0)}
/**
A text selection represents a classical editor selection, with a
head (the moving side) and anchor (immobile side), both of which
point into textblock nodes. It can be empty (a regular cursor
position).
*/class TextSelection$1 extends Selection$1{
/**
    Construct a text selection between the given points.
    */
constructor($anchor,$head=$anchor){checkTextSelection$1($anchor),checkTextSelection$1($head),super($anchor,$head)}
/**
    Returns a resolved position if this is a cursor selection (an
    empty text selection), and null otherwise.
    */get $cursor(){return this.$anchor.pos==this.$head.pos?this.$head:null}map(doc,mapping){let $head=doc.resolve(mapping.map(this.head));if(!$head.parent.inlineContent)return Selection$1.near($head);let $anchor=doc.resolve(mapping.map(this.anchor));return new TextSelection$1($anchor.parent.inlineContent?$anchor:$head,$head)}replace(tr,content=Slice$1.empty){if(super.replace(tr,content),content==Slice$1.empty){let marks=this.$from.marksAcross(this.$to);marks&&tr.ensureMarks(marks)}}eq(other){return other instanceof TextSelection$1&&other.anchor==this.anchor&&other.head==this.head}getBookmark(){return new TextBookmark$1(this.anchor,this.head)}toJSON(){return{type:"text",anchor:this.anchor,head:this.head}}
/**
    @internal
    */static fromJSON(doc,json){if("number"!=typeof json.anchor||"number"!=typeof json.head)throw new RangeError("Invalid input for TextSelection.fromJSON");return new TextSelection$1(doc.resolve(json.anchor),doc.resolve(json.head))}
/**
    Create a text selection from non-resolved positions.
    */static create(doc,anchor,head=anchor){let $anchor=doc.resolve(anchor);return new this($anchor,head==anchor?$anchor:doc.resolve(head))}
/**
    Return a text selection that spans the given positions or, if
    they aren't text positions, find a text selection near them.
    `bias` determines whether the method searches forward (default)
    or backwards (negative number) first. Will fall back to calling
    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
    doesn't contain a valid text position.
    */static between($anchor,$head,bias){let dPos=$anchor.pos-$head.pos;if(bias&&!dPos||(bias=dPos>=0?1:-1),!$head.parent.inlineContent){let found=Selection$1.findFrom($head,bias,!0)||Selection$1.findFrom($head,-bias,!0);if(!found)return Selection$1.near($head,bias);$head=found.$head}return $anchor.parent.inlineContent||(0==dPos?$anchor=$head:($anchor=(Selection$1.findFrom($anchor,-bias,!0)||Selection$1.findFrom($anchor,bias,!0)).$anchor,$anchor.pos<$head.pos!=dPos<0&&($anchor=$head))),new TextSelection$1($anchor,$head)}}Selection$1.jsonID("text",TextSelection$1);class TextBookmark$1{constructor(anchor,head){this.anchor=anchor,this.head=head}map(mapping){return new TextBookmark$1(mapping.map(this.anchor),mapping.map(this.head))}resolve(doc){return TextSelection$1.between(doc.resolve(this.anchor),doc.resolve(this.head))}}
/**
A node selection is a selection that points at a single node. All
nodes marked [selectable](https://prosemirror.net/docs/ref/#model.NodeSpec.selectable) can be the
target of a node selection. In such a selection, `from` and `to`
point directly before and after the selected node, `anchor` equals
`from`, and `head` equals `to`..
*/class NodeSelection$1 extends Selection$1{
/**
    Create a node selection. Does not verify the validity of its
    argument.
    */
constructor($pos){let node=$pos.nodeAfter,$end=$pos.node(0).resolve($pos.pos+node.nodeSize);super($pos,$end),this.node=node}map(doc,mapping){let{deleted:deleted,pos:pos}=mapping.mapResult(this.anchor),$pos=doc.resolve(pos);return deleted?Selection$1.near($pos):new NodeSelection$1($pos)}content(){return new Slice$1(Fragment$1.from(this.node),0,0)}eq(other){return other instanceof NodeSelection$1&&other.anchor==this.anchor}toJSON(){return{type:"node",anchor:this.anchor}}getBookmark(){return new NodeBookmark$1(this.anchor)}
/**
    @internal
    */static fromJSON(doc,json){if("number"!=typeof json.anchor)throw new RangeError("Invalid input for NodeSelection.fromJSON");return new NodeSelection$1(doc.resolve(json.anchor))}
/**
    Create a node selection from non-resolved positions.
    */static create(doc,from){return new NodeSelection$1(doc.resolve(from))}
/**
    Determines whether the given node may be selected as a node
    selection.
    */static isSelectable(node){return!node.isText&&!1!==node.type.spec.selectable}}NodeSelection$1.prototype.visible=!1,Selection$1.jsonID("node",NodeSelection$1);class NodeBookmark$1{constructor(anchor){this.anchor=anchor}map(mapping){let{deleted:deleted,pos:pos}=mapping.mapResult(this.anchor);return deleted?new TextBookmark$1(pos,pos):new NodeBookmark$1(pos)}resolve(doc){let $pos=doc.resolve(this.anchor),node=$pos.nodeAfter;return node&&NodeSelection$1.isSelectable(node)?new NodeSelection$1($pos):Selection$1.near($pos)}}
/**
A selection type that represents selecting the whole document
(which can not necessarily be expressed with a text selection, when
there are for example leaf block nodes at the start or end of the
document).
*/class AllSelection$1 extends Selection$1{
/**
    Create an all-selection over the given document.
    */
constructor(doc){super(doc.resolve(0),doc.resolve(doc.content.size))}replace(tr,content=Slice$1.empty){if(content==Slice$1.empty){tr.delete(0,tr.doc.content.size);let sel=Selection$1.atStart(tr.doc);sel.eq(tr.selection)||tr.setSelection(sel)}else super.replace(tr,content)}toJSON(){return{type:"all"}}
/**
    @internal
    */static fromJSON(doc){return new AllSelection$1(doc)}map(doc){return new AllSelection$1(doc)}eq(other){return other instanceof AllSelection$1}getBookmark(){return AllBookmark$1}}Selection$1.jsonID("all",AllSelection$1);const AllBookmark$1={map(){return this},resolve(doc){return new AllSelection$1(doc)}};
// FIXME we'll need some awareness of text direction when scanning for selections
// Try to find a selection inside the given node. `pos` points at the
// position where the search starts. When `text` is true, only return
// text selections.
function findSelectionIn$1(doc,node,pos,index,dir,text=!1){if(node.inlineContent)return TextSelection$1.create(doc,pos);for(let i=index-(dir>0?0:1);dir>0?i<node.childCount:i>=0;i+=dir){let child=node.child(i);if(child.isAtom){if(!text&&NodeSelection$1.isSelectable(child))return NodeSelection$1.create(doc,pos-(dir<0?child.nodeSize:0))}else{let inner=findSelectionIn$1(doc,child,pos+dir,dir<0?child.childCount:0,dir,text);if(inner)return inner}pos+=child.nodeSize*dir}return null}function selectionToInsertionEnd$1$1(tr,startLen,bias){let last=tr.steps.length-1;if(last<startLen)return;let step=tr.steps[last];if(!(step instanceof ReplaceStep$1||step instanceof ReplaceAroundStep$1))return;let end,map=tr.mapping.maps[last];map.forEach(((_from,_to,_newFrom,newTo)=>{null==end&&(end=newTo)})),tr.setSelection(Selection$1.near(tr.doc.resolve(end),bias))}function bind$1$1(f,self){return self&&f?f.bind(self):f}class FieldDesc$1{constructor(name,desc,self){this.name=name,this.init=bind$1$1(desc.init,self),this.apply=bind$1$1(desc.apply,self)}}function bindProps$1(obj,self,target){for(let prop in obj){let val=obj[prop];val instanceof Function?val=val.bind(self):"handleDOMEvents"==prop&&(val=bindProps$1(val,self,{})),target[prop]=val}return target}
/**
Plugins bundle functionality that can be added to an editor.
They are part of the [editor state](https://prosemirror.net/docs/ref/#state.EditorState) and
may influence that state and the view that contains it.
*/new FieldDesc$1("doc",{init(config){return config.doc||config.schema.topNodeType.createAndFill()},apply(tr){return tr.doc}}),new FieldDesc$1("selection",{init(config,instance){return config.selection||Selection$1.atStart(instance.doc)},apply(tr){return tr.selection}}),new FieldDesc$1("storedMarks",{init(config){return config.storedMarks||null},apply(tr,_marks,_old,state){return state.selection.$cursor?tr.storedMarks:null}}),new FieldDesc$1("scrollToSelection",{init(){return 0},apply(tr,prev){return tr.scrolledIntoView?prev+1:prev}});class Plugin$1{
/**
    Create a plugin.
    */
constructor(
/**
    The plugin's [spec object](https://prosemirror.net/docs/ref/#state.PluginSpec).
    */
spec){this.spec=spec,
/**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
this.props={},spec.props&&bindProps$1(spec.props,this,this.props),this.key=spec.key?spec.key.key:createKey$1("plugin")}
/**
    Extract the plugin's state field from an editor state.
    */getState(state){return state[this.key]}}const keys$1$1=Object.create(null);function createKey$1(name){return name in keys$1$1?name+"$"+ ++keys$1$1[name]:(keys$1$1[name]=0,name+"$")}
/**
A key is used to [tag](https://prosemirror.net/docs/ref/#state.PluginSpec.key) plugins in a way
that makes it possible to find them, given an editor state.
Assigning a key does mean only one plugin of that type can be
active in a state.
*/class PluginKey$1{
/**
    Create a plugin key.
    */
constructor(name="key"){this.key=createKey$1(name)}
/**
    Get the active plugin with this key, if any, from an editor
    state.
    */get(state){return state.config.pluginsByKey[this.key]}
/**
    Get the plugin's state from an editor state.
    */getState(state){return state[this.key]}}const nav$1="undefined"!=typeof navigator?navigator:null,doc$3="undefined"!=typeof document?document:null,agent$1=nav$1&&nav$1.userAgent||"",ie_edge$1=/Edge\/(\d+)/.exec(agent$1),ie_upto10$1=/MSIE \d/.exec(agent$1),ie_11up$1=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent$1),ie$1$1=!!(ie_upto10$1||ie_11up$1||ie_edge$1),ie_version$1=ie_upto10$1?document.documentMode:ie_11up$1?+ie_11up$1[1]:ie_edge$1?+ie_edge$1[1]:0,gecko$1=!ie$1$1&&/gecko\/(\d+)/i.test(agent$1);gecko$1&&(/Firefox\/(\d+)/.exec(agent$1)||[0,0])[1];const _chrome$1=!ie$1$1&&/Chrome\/(\d+)/.exec(agent$1),chrome$1$1=!!_chrome$1,chrome_version$1=_chrome$1?+_chrome$1[1]:0,safari$1=!ie$1$1&&!!nav$1&&/Apple Computer/.test(nav$1.vendor),ios$1=safari$1&&(/Mobile\/\w+/.test(agent$1)||!!nav$1&&nav$1.maxTouchPoints>2),mac$2$1=ios$1||!!nav$1&&/Mac/.test(nav$1.platform),android$1=/Android \d/.test(agent$1),webkit$1=!!doc$3&&"webkitFontSmoothing"in doc$3.documentElement.style,webkit_version$1=webkit$1?+(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent)||[0,0])[1]:0,domIndex$1=function(node){for(var index=0;;index++)if(node=node.previousSibling,!node)return index},isEquivalentPosition$1=function(node,off,targetNode,targetOff){return targetNode&&(scanFor$1(node,off,targetNode,targetOff,-1)||scanFor$1(node,off,targetNode,targetOff,1))},atomElements$1=/^(img|br|input|textarea|hr)$/i;function scanFor$1(node,off,targetNode,targetOff,dir){for(;;){if(node==targetNode&&off==targetOff)return!0;if(off==(dir<0?0:nodeSize$1(node))){let parent=node.parentNode;if(!parent||1!=parent.nodeType||hasBlockDesc$1(node)||atomElements$1.test(node.nodeName)||"false"==node.contentEditable)return!1;off=domIndex$1(node)+(dir<0?0:1),node=parent}else{if(1!=node.nodeType)return!1;if(node=node.childNodes[off+(dir<0?-1:0)],"false"==node.contentEditable)return!1;off=dir<0?nodeSize$1(node):0}}}function nodeSize$1(node){return 3==node.nodeType?node.nodeValue.length:node.childNodes.length}function isOnEdge$1(node,offset,parent){for(let atStart=0==offset,atEnd=offset==nodeSize$1(node);atStart||atEnd;){if(node==parent)return!0;let index=domIndex$1(node);if(node=node.parentNode,!node)return!1;atStart=atStart&&0==index,atEnd=atEnd&&index==nodeSize$1(node)}}function hasBlockDesc$1(dom){let desc;for(let cur=dom;cur;cur=cur.parentNode)if(desc=cur.pmViewDesc)break;return desc&&desc.node&&desc.node.isBlock&&(desc.dom==dom||desc.contentDOM==dom)}
// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523
// (isCollapsed inappropriately returns true in shadow dom)
const selectionCollapsed$1=function(domSel){let collapsed=domSel.isCollapsed;return collapsed&&chrome$1$1&&domSel.rangeCount&&!domSel.getRangeAt(0).collapsed&&(collapsed=!1),collapsed};function keyEvent$1(keyCode,key){let event=document.createEvent("Event");return event.initEvent("keydown",!0,!0),event.keyCode=keyCode,event.key=event.code=key,event}function selectionFromDOM$1(view,origin=null){let domSel=view.domSelection(),doc=view.state.doc;if(!domSel.focusNode)return null;let nearestDesc=view.docView.nearestDesc(domSel.focusNode),inWidget=nearestDesc&&0==nearestDesc.size,head=view.docView.posFromDOM(domSel.focusNode,domSel.focusOffset,1);if(head<0)return null;let $anchor,selection,$head=doc.resolve(head);if(selectionCollapsed$1(domSel)){$anchor=$head;while(nearestDesc&&!nearestDesc.node)nearestDesc=nearestDesc.parent;let nearestDescNode=nearestDesc.node;if(nearestDesc&&nearestDescNode.isAtom&&NodeSelection$1.isSelectable(nearestDescNode)&&nearestDesc.parent&&(!nearestDescNode.isInline||!isOnEdge$1(domSel.focusNode,domSel.focusOffset,nearestDesc.dom))){let pos=nearestDesc.posBefore;selection=new NodeSelection$1(head==pos?$head:doc.resolve(pos))}}else{let anchor=view.docView.posFromDOM(domSel.anchorNode,domSel.anchorOffset,1);if(anchor<0)return null;$anchor=doc.resolve(anchor)}if(!selection){let bias="pointer"==origin||view.state.selection.head<$head.pos&&!inWidget?1:-1;selection=selectionBetween$1(view,$anchor,$head,bias)}return selection}function editorOwnsSelection$1(view){return view.editable?view.hasFocus():hasSelection$1(view)&&document.activeElement&&document.activeElement.contains(view.dom)}function selectionToDOM$1(view,force=!1){let sel=view.state.selection;if(syncNodeSelection$1(view,sel),editorOwnsSelection$1(view)){
// The delayed drag selection causes issues with Cell Selections
// in Safari. And the drag selection delay is to workarond issues
// which only present in Chrome.
if(!force&&view.input.mouseDown&&view.input.mouseDown.allowDefault&&chrome$1$1){let domSel=view.domSelection(),curSel=view.domObserver.currentSelection;if(domSel.anchorNode&&curSel.anchorNode&&isEquivalentPosition$1(domSel.anchorNode,domSel.anchorOffset,curSel.anchorNode,curSel.anchorOffset))return view.input.mouseDown.delayedSelectionSync=!0,void view.domObserver.setCurSelection()}if(view.domObserver.disconnectSelection(),view.cursorWrapper)selectCursorWrapper$1(view);else{let resetEditableFrom,resetEditableTo,{anchor:anchor,head:head}=sel;!brokenSelectBetweenUneditable$1||sel instanceof TextSelection$1||(sel.$from.parent.inlineContent||(resetEditableFrom=temporarilyEditableNear$1(view,sel.from)),sel.empty||sel.$from.parent.inlineContent||(resetEditableTo=temporarilyEditableNear$1(view,sel.to))),view.docView.setSelection(anchor,head,view.root,force),brokenSelectBetweenUneditable$1&&(resetEditableFrom&&resetEditable$1(resetEditableFrom),resetEditableTo&&resetEditable$1(resetEditableTo)),sel.visible?view.dom.classList.remove("ProseMirror-hideselection"):(view.dom.classList.add("ProseMirror-hideselection"),"onselectionchange"in document&&removeClassOnSelectionChange$1(view))}view.domObserver.setCurSelection(),view.domObserver.connectSelection()}}
// Kludge to work around Webkit not allowing a selection to start/end
// between non-editable block nodes. We briefly make something
// editable, set the selection, then set it uneditable again.
const brokenSelectBetweenUneditable$1=safari$1||chrome$1$1&&chrome_version$1<63;function temporarilyEditableNear$1(view,pos){let{node:node,offset:offset}=view.docView.domFromPos(pos,0),after=offset<node.childNodes.length?node.childNodes[offset]:null,before=offset?node.childNodes[offset-1]:null;if(safari$1&&after&&"false"==after.contentEditable)return setEditable$1(after);if((!after||"false"==after.contentEditable)&&(!before||"false"==before.contentEditable)){if(after)return setEditable$1(after);if(before)return setEditable$1(before)}}function setEditable$1(element){return element.contentEditable="true",safari$1&&element.draggable&&(element.draggable=!1,element.wasDraggable=!0),element}function resetEditable$1(element){element.contentEditable="false",element.wasDraggable&&(element.draggable=!0,element.wasDraggable=null)}function removeClassOnSelectionChange$1(view){let doc=view.dom.ownerDocument;doc.removeEventListener("selectionchange",view.input.hideSelectionGuard);let domSel=view.domSelection(),node=domSel.anchorNode,offset=domSel.anchorOffset;doc.addEventListener("selectionchange",view.input.hideSelectionGuard=()=>{domSel.anchorNode==node&&domSel.anchorOffset==offset||(doc.removeEventListener("selectionchange",view.input.hideSelectionGuard),setTimeout((()=>{editorOwnsSelection$1(view)&&!view.state.selection.visible||view.dom.classList.remove("ProseMirror-hideselection")}),20))})}function selectCursorWrapper$1(view){let domSel=view.domSelection(),range=document.createRange(),node=view.cursorWrapper.dom,img="IMG"==node.nodeName;img?range.setEnd(node.parentNode,domIndex$1(node)+1):range.setEnd(node,0),range.collapse(!1),domSel.removeAllRanges(),domSel.addRange(range),
// Kludge to kill 'control selection' in IE11 when selecting an
// invisible cursor wrapper, since that would result in those weird
// resize handles and a selection that considers the absolutely
// positioned wrapper, rather than the root editable node, the
// focused element.
!img&&!view.state.selection.visible&&ie$1$1&&ie_version$1<=11&&(node.disabled=!0,node.disabled=!1)}function syncNodeSelection$1(view,sel){if(sel instanceof NodeSelection$1){let desc=view.docView.descAt(sel.from);desc!=view.lastSelectedViewDesc&&(clearNodeSelection$1(view),desc&&desc.selectNode(),view.lastSelectedViewDesc=desc)}else clearNodeSelection$1(view)}
// Clear all DOM statefulness of the last node selection.
function clearNodeSelection$1(view){view.lastSelectedViewDesc&&(view.lastSelectedViewDesc.parent&&view.lastSelectedViewDesc.deselectNode(),view.lastSelectedViewDesc=void 0)}function selectionBetween$1(view,$anchor,$head,bias){return view.someProp("createSelectionBetween",(f=>f(view,$anchor,$head)))||TextSelection$1.between($anchor,$head,bias)}function hasSelection$1(view){let sel=view.domSelection();if(!sel.anchorNode)return!1;try{
// Firefox will raise 'permission denied' errors when accessing
// properties of `sel.anchorNode` when it's in a generated CSS
// element.
return view.dom.contains(3==sel.anchorNode.nodeType?sel.anchorNode.parentNode:sel.anchorNode)&&(view.editable||view.dom.contains(3==sel.focusNode.nodeType?sel.focusNode.parentNode:sel.focusNode))}catch(_){return!1}}function moveSelectionBlock$1(state,dir){let{$anchor:$anchor,$head:$head}=state.selection,$side=dir>0?$anchor.max($head):$anchor.min($head),$start=$side.parent.inlineContent?$side.depth?state.doc.resolve(dir>0?$side.after():$side.before()):null:$side;return $start&&Selection$1.findFrom($start,dir)}function apply$2(view,sel){return view.dispatch(view.state.tr.setSelection(sel).scrollIntoView()),!0}function selectHorizontally$1(view,dir,mods){let sel=view.state.selection;if(!(sel instanceof TextSelection$1)){if(sel instanceof NodeSelection$1&&sel.node.isInline)return apply$2(view,new TextSelection$1(dir>0?sel.$to:sel.$from));{let next=moveSelectionBlock$1(view.state,dir);return!!next&&apply$2(view,next)}}if(!sel.empty||mods.indexOf("s")>-1)return!1;if(view.endOfTextblock(dir>0?"right":"left")){let next=moveSelectionBlock$1(view.state,dir);return!!(next&&next instanceof NodeSelection$1)&&apply$2(view,next)}if(!(mac$2$1&&mods.indexOf("m")>-1)){let desc,$head=sel.$head,node=$head.textOffset?null:dir<0?$head.nodeBefore:$head.nodeAfter;if(!node||node.isText)return!1;let nodePos=dir<0?$head.pos-node.nodeSize:$head.pos;return!!(node.isAtom||(desc=view.docView.descAt(nodePos))&&!desc.contentDOM)&&(NodeSelection$1.isSelectable(node)?apply$2(view,new NodeSelection$1(dir<0?view.state.doc.resolve($head.pos-node.nodeSize):$head)):!!webkit$1&&apply$2(view,new TextSelection$1(view.state.doc.resolve(dir<0?nodePos:nodePos+node.nodeSize))))}}function nodeLen$1(node){return 3==node.nodeType?node.nodeValue.length:node.childNodes.length}function isIgnorable$1(dom){let desc=dom.pmViewDesc;return desc&&0==desc.size&&(dom.nextSibling||"BR"!=dom.nodeName)}
// Make sure the cursor isn't directly after one or more ignored
// nodes, which will confuse the browser's cursor motion logic.
function skipIgnoredNodesLeft$1(view){let sel=view.domSelection(),node=sel.focusNode,offset=sel.focusOffset;if(!node)return;let moveNode,moveOffset,force=!1;
// Gecko will do odd things when the selection is directly in front
// of a non-editable node, so in that case, move it into the next
// node if possible. Issue prosemirror/prosemirror#832.
for(gecko$1&&1==node.nodeType&&offset<nodeLen$1(node)&&isIgnorable$1(node.childNodes[offset])&&(force=!0);;)if(offset>0){if(1!=node.nodeType)break;{let before=node.childNodes[offset-1];if(isIgnorable$1(before))moveNode=node,moveOffset=--offset;else{if(3!=before.nodeType)break;node=before,offset=node.nodeValue.length}}}else{if(isBlockNode$1(node))break;{let prev=node.previousSibling;while(prev&&isIgnorable$1(prev))moveNode=node.parentNode,moveOffset=domIndex$1(prev),prev=prev.previousSibling;if(prev)node=prev,offset=nodeLen$1(node);else{if(node=node.parentNode,node==view.dom)break;offset=0}}}force?setSelFocus$1(view,sel,node,offset):moveNode&&setSelFocus$1(view,sel,moveNode,moveOffset)}
// Make sure the cursor isn't directly before one or more ignored
// nodes.
function skipIgnoredNodesRight$1(view){let sel=view.domSelection(),node=sel.focusNode,offset=sel.focusOffset;if(!node)return;let moveNode,moveOffset,len=nodeLen$1(node);for(;;)if(offset<len){if(1!=node.nodeType)break;let after=node.childNodes[offset];if(!isIgnorable$1(after))break;moveNode=node,moveOffset=++offset}else{if(isBlockNode$1(node))break;{let next=node.nextSibling;while(next&&isIgnorable$1(next))moveNode=next.parentNode,moveOffset=domIndex$1(next)+1,next=next.nextSibling;if(next)node=next,offset=0,len=nodeLen$1(node);else{if(node=node.parentNode,node==view.dom)break;offset=len=0}}}moveNode&&setSelFocus$1(view,sel,moveNode,moveOffset)}function isBlockNode$1(dom){let desc=dom.pmViewDesc;return desc&&desc.node&&desc.node.isBlock}function setSelFocus$1(view,sel,node,offset){if(selectionCollapsed$1(sel)){let range=document.createRange();range.setEnd(node,offset),range.setStart(node,offset),sel.removeAllRanges(),sel.addRange(range)}else sel.extend&&sel.extend(node,offset);view.domObserver.setCurSelection();let{state:state}=view;
// If no state update ends up happening, reset the selection.
setTimeout((()=>{view.state==state&&selectionToDOM$1(view)}),50)}
// Check whether vertical selection motion would involve node
// selections. If so, apply it (if not, the result is left to the
// browser)
function selectVertically$1(view,dir,mods){let sel=view.state.selection;if(sel instanceof TextSelection$1&&!sel.empty||mods.indexOf("s")>-1)return!1;if(mac$2$1&&mods.indexOf("m")>-1)return!1;let{$from:$from,$to:$to}=sel;if(!$from.parent.inlineContent||view.endOfTextblock(dir<0?"up":"down")){let next=moveSelectionBlock$1(view.state,dir);if(next&&next instanceof NodeSelection$1)return apply$2(view,next)}if(!$from.parent.inlineContent){let side=dir<0?$from:$to,beyond=sel instanceof AllSelection$1?Selection$1.near(side,dir):Selection$1.findFrom(side,dir);return!!beyond&&apply$2(view,beyond)}return!1}function stopNativeHorizontalDelete$1(view,dir){if(!(view.state.selection instanceof TextSelection$1))return!0;let{$head:$head,$anchor:$anchor,empty:empty}=view.state.selection;if(!$head.sameParent($anchor))return!0;if(!empty)return!1;if(view.endOfTextblock(dir>0?"forward":"backward"))return!0;let nextNode=!$head.textOffset&&(dir<0?$head.nodeBefore:$head.nodeAfter);if(nextNode&&!nextNode.isText){let tr=view.state.tr;return dir<0?tr.delete($head.pos-nextNode.nodeSize,$head.pos):tr.delete($head.pos,$head.pos+nextNode.nodeSize),view.dispatch(tr),!0}return!1}function switchEditable$1(view,node,state){view.domObserver.stop(),node.contentEditable=state,view.domObserver.start()}
// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821
// In which Safari (and at some point in the past, Chrome) does really
// wrong things when the down arrow is pressed when the cursor is
// directly at the start of a textblock and has an uneditable node
// after it
function safariDownArrowBug$1(view){if(!safari$1||view.state.selection.$head.parentOffset>0)return!1;let{focusNode:focusNode,focusOffset:focusOffset}=view.domSelection();if(focusNode&&1==focusNode.nodeType&&0==focusOffset&&focusNode.firstChild&&"false"==focusNode.firstChild.contentEditable){let child=focusNode.firstChild;switchEditable$1(view,child,"true"),setTimeout((()=>switchEditable$1(view,child,"false")),20)}return!1}
// A backdrop key mapping used to make sure we always suppress keys
// that have a dangerous default effect, even if the commands they are
// bound to return false, and to make sure that cursor-motion keys
// find a cursor (as opposed to a node selection) when pressed. For
// cursor-motion keys, the code in the handlers also takes care of
// block selections.
function getMods$1(event){let result="";return event.ctrlKey&&(result+="c"),event.metaKey&&(result+="m"),event.altKey&&(result+="a"),event.shiftKey&&(result+="s"),result}function captureKeyDown$1(view,event){let code=event.keyCode,mods=getMods$1(event);return 8==code||mac$2$1&&72==code&&"c"==mods?stopNativeHorizontalDelete$1(view,-1)||skipIgnoredNodesLeft$1(view):46==code||mac$2$1&&68==code&&"c"==mods?stopNativeHorizontalDelete$1(view,1)||skipIgnoredNodesRight$1(view):13==code||27==code||(37==code||mac$2$1&&66==code&&"c"==mods?selectHorizontally$1(view,-1,mods)||skipIgnoredNodesLeft$1(view):39==code||mac$2$1&&70==code&&"c"==mods?selectHorizontally$1(view,1,mods)||skipIgnoredNodesRight$1(view):38==code||mac$2$1&&80==code&&"c"==mods?selectVertically$1(view,-1,mods)||skipIgnoredNodesLeft$1(view):40==code||mac$2$1&&78==code&&"c"==mods?safariDownArrowBug$1(view)||selectVertically$1(view,1,mods)||skipIgnoredNodesRight$1(view):mods==(mac$2$1?"m":"c")&&(66==code||73==code||89==code||90==code))}function serializeForClipboard$1(view,slice){let context=[],{content:content,openStart:openStart,openEnd:openEnd}=slice;while(openStart>1&&openEnd>1&&1==content.childCount&&1==content.firstChild.childCount){openStart--,openEnd--;let node=content.firstChild;context.push(node.type.name,node.attrs!=node.type.defaultAttrs?node.attrs:null),content=node.content}let serializer=view.someProp("clipboardSerializer")||DOMSerializer$1.fromSchema(view.state.schema),doc=detachedDoc$1(),wrap=doc.createElement("div");wrap.appendChild(serializer.serializeFragment(content,{document:doc}));let needsWrap,firstChild=wrap.firstChild,wrappers=0;while(firstChild&&1==firstChild.nodeType&&(needsWrap=wrapMap$1[firstChild.nodeName.toLowerCase()])){for(let i=needsWrap.length-1;i>=0;i--){let wrapper=doc.createElement(needsWrap[i]);while(wrap.firstChild)wrapper.appendChild(wrap.firstChild);wrap.appendChild(wrapper),wrappers++}firstChild=wrap.firstChild}firstChild&&1==firstChild.nodeType&&firstChild.setAttribute("data-pm-slice",`${openStart} ${openEnd}${wrappers?` -${wrappers}`:""} ${JSON.stringify(context)}`);let text=view.someProp("clipboardTextSerializer",(f=>f(slice)))||slice.content.textBetween(0,slice.content.size,"\n\n");return{dom:wrap,text:text}}
// Read a slice of content from the clipboard (or drop data).
function parseFromClipboard$1(view,text,html,plainText,$context){let dom,slice,inCode=$context.parent.type.spec.code;if(!html&&!text)return null;let asText=text&&(plainText||inCode||!html);if(asText){if(view.someProp("transformPastedText",(f=>{text=f(text,inCode||plainText)})),inCode)return text?new Slice$1(Fragment$1.from(view.state.schema.text(text.replace(/\r\n?/g,"\n"))),0,0):Slice$1.empty;let parsed=view.someProp("clipboardTextParser",(f=>f(text,$context,plainText)));if(parsed)slice=parsed;else{let marks=$context.marks(),{schema:schema}=view.state,serializer=DOMSerializer$1.fromSchema(schema);dom=document.createElement("div"),text.split(/(?:\r\n?|\n)+/).forEach((block=>{let p=dom.appendChild(document.createElement("p"));block&&p.appendChild(serializer.serializeNode(schema.text(block,marks)))}))}}else view.someProp("transformPastedHTML",(f=>{html=f(html)})),dom=readHTML$1(html),webkit$1&&restoreReplacedSpaces$1(dom);let contextNode=dom&&dom.querySelector("[data-pm-slice]"),sliceData=contextNode&&/^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice")||"");if(sliceData&&sliceData[3])for(let i=+sliceData[3];i>0&&dom.firstChild;i--)dom=dom.firstChild;if(!slice){let parser=view.someProp("clipboardParser")||view.someProp("domParser")||DOMParser$1$1.fromSchema(view.state.schema);slice=parser.parseSlice(dom,{preserveWhitespace:!(!asText&&!sliceData),context:$context,ruleFromNode(dom){return"BR"!=dom.nodeName||dom.nextSibling||!dom.parentNode||inlineParents$1.test(dom.parentNode.nodeName)?null:{ignore:!0}}})}if(sliceData)slice=addContext$1(closeSlice$1(slice,+sliceData[1],+sliceData[2]),sliceData[4]);else if(// HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent
slice=Slice$1.maxOpen(normalizeSiblings$1(slice.content,$context),!0),slice.openStart||slice.openEnd){let openStart=0,openEnd=0;for(let node=slice.content.firstChild;openStart<slice.openStart&&!node.type.spec.isolating;openStart++,node=node.firstChild);for(let node=slice.content.lastChild;openEnd<slice.openEnd&&!node.type.spec.isolating;openEnd++,node=node.lastChild);slice=closeSlice$1(slice,openStart,openEnd)}return view.someProp("transformPasted",(f=>{slice=f(slice)})),slice}const inlineParents$1=/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
// Takes a slice parsed with parseSlice, which means there hasn't been
// any content-expression checking done on the top nodes, tries to
// find a parent node in the current context that might fit the nodes,
// and if successful, rebuilds the slice so that it fits into that parent.

// This addresses the problem that Transform.replace expects a
// coherent slice, and will fail to place a set of siblings that don't
// fit anywhere in the schema.
function normalizeSiblings$1(fragment,$context){if(fragment.childCount<2)return fragment;for(let d=$context.depth;d>=0;d--){let lastWrap,parent=$context.node(d),match=parent.contentMatchAt($context.index(d)),result=[];if(fragment.forEach((node=>{if(!result)return;let inLast,wrap=match.findWrapping(node.type);if(!wrap)return result=null;if(inLast=result.length&&lastWrap.length&&addToSibling$1(wrap,lastWrap,node,result[result.length-1],0))result[result.length-1]=inLast;else{result.length&&(result[result.length-1]=closeRight$1(result[result.length-1],lastWrap.length));let wrapped=withWrappers$1(node,wrap);result.push(wrapped),match=match.matchType(wrapped.type),lastWrap=wrap}})),result)return Fragment$1.from(result)}return fragment}function withWrappers$1(node,wrap,from=0){for(let i=wrap.length-1;i>=from;i--)node=wrap[i].create(null,Fragment$1.from(node));return node}
// Used to group adjacent nodes wrapped in similar parents by
// normalizeSiblings into the same parent node
function addToSibling$1(wrap,lastWrap,node,sibling,depth){if(depth<wrap.length&&depth<lastWrap.length&&wrap[depth]==lastWrap[depth]){let inner=addToSibling$1(wrap,lastWrap,node,sibling.lastChild,depth+1);if(inner)return sibling.copy(sibling.content.replaceChild(sibling.childCount-1,inner));let match=sibling.contentMatchAt(sibling.childCount);if(match.matchType(depth==wrap.length-1?node.type:wrap[depth+1]))return sibling.copy(sibling.content.append(Fragment$1.from(withWrappers$1(node,wrap,depth+1))))}}function closeRight$1(node,depth){if(0==depth)return node;let fragment=node.content.replaceChild(node.childCount-1,closeRight$1(node.lastChild,depth-1)),fill=node.contentMatchAt(node.childCount).fillBefore(Fragment$1.empty,!0);return node.copy(fragment.append(fill))}function closeRange$1(fragment,side,from,to,depth,openEnd){let node=side<0?fragment.firstChild:fragment.lastChild,inner=node.content;return depth<to-1&&(inner=closeRange$1(inner,side,from,to,depth+1,openEnd)),depth>=from&&(inner=side<0?node.contentMatchAt(0).fillBefore(inner,fragment.childCount>1||openEnd<=depth).append(inner):inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment$1.empty,!0))),fragment.replaceChild(side<0?0:fragment.childCount-1,node.copy(inner))}function closeSlice$1(slice,openStart,openEnd){return openStart<slice.openStart&&(slice=new Slice$1(closeRange$1(slice.content,-1,openStart,slice.openStart,0,slice.openEnd),openStart,slice.openEnd)),openEnd<slice.openEnd&&(slice=new Slice$1(closeRange$1(slice.content,1,openEnd,slice.openEnd,0,0),slice.openStart,openEnd)),slice}
// Trick from jQuery -- some elements must be wrapped in other
// elements for innerHTML to work. I.e. if you do `div.innerHTML =
// "<td>..</td>"` the table cells are ignored.
const wrapMap$1={thead:["table"],tbody:["table"],tfoot:["table"],caption:["table"],colgroup:["table"],col:["table","colgroup"],tr:["table","tbody"],td:["table","tbody","tr"],th:["table","tbody","tr"]};let _detachedDoc$1=null;function detachedDoc$1(){return _detachedDoc$1||(_detachedDoc$1=document.implementation.createHTMLDocument("title"))}function readHTML$1(html){let metas=/^(\s*<meta [^>]*>)*/.exec(html);metas&&(html=html.slice(metas[0].length));let wrap,elt=detachedDoc$1().createElement("div"),firstTag=/<([a-z][^>\s]+)/i.exec(html);if((wrap=firstTag&&wrapMap$1[firstTag[1].toLowerCase()])&&(html=wrap.map((n=>"<"+n+">")).join("")+html+wrap.map((n=>"</"+n+">")).reverse().join("")),elt.innerHTML=html,wrap)for(let i=0;i<wrap.length;i++)elt=elt.querySelector(wrap[i])||elt;return elt}
// Webkit browsers do some hard-to-predict replacement of regular
// spaces with non-breaking spaces when putting content on the
// clipboard. This tries to convert such non-breaking spaces (which
// will be wrapped in a plain span on Chrome, a span with class
// Apple-converted-space on Safari) back to regular spaces.
function restoreReplacedSpaces$1(dom){let nodes=dom.querySelectorAll(chrome$1$1?"span:not([class]):not([style])":"span.Apple-converted-space");for(let i=0;i<nodes.length;i++){let node=nodes[i];1==node.childNodes.length&&" "==node.textContent&&node.parentNode&&node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "),node)}}function addContext$1(slice,context){if(!slice.size)return slice;let array,schema=slice.content.firstChild.type.schema;try{array=JSON.parse(context)}catch(e){return slice}let{content:content,openStart:openStart,openEnd:openEnd}=slice;for(let i=array.length-2;i>=0;i-=2){let type=schema.nodes[array[i]];if(!type||type.hasRequiredAttrs())break;content=Fragment$1.from(type.create(array[i+1],content)),openStart++,openEnd++}return new Slice$1(content,openStart,openEnd)}
// A collection of DOM events that occur within the editor, and callback functions
// to invoke when the event fires.
const handlers$1={};let editHandlers$1={};function setSelectionOrigin$1(view,origin){view.input.lastSelectionOrigin=origin,view.input.lastSelectionTime=Date.now()}function eventCoords$1(event){return{left:event.clientX,top:event.clientY}}function isNear$1(event,click){let dx=click.x-event.clientX,dy=click.y-event.clientY;return dx*dx+dy*dy<100}function runHandlerOnContext$1(view,propName,pos,inside,event){if(-1==inside)return!1;let $pos=view.state.doc.resolve(inside);for(let i=$pos.depth+1;i>0;i--)if(view.someProp(propName,(f=>i>$pos.depth?f(view,pos,$pos.nodeAfter,$pos.before(i),event,!0):f(view,pos,$pos.node(i),$pos.before(i),event,!1))))return!0;return!1}function updateSelection$1(view,selection,origin){view.focused||view.focus();let tr=view.state.tr.setSelection(selection);"pointer"==origin&&tr.setMeta("pointer",!0),view.dispatch(tr)}function selectClickedLeaf$1(view,inside){if(-1==inside)return!1;let $pos=view.state.doc.resolve(inside),node=$pos.nodeAfter;return!!(node&&node.isAtom&&NodeSelection$1.isSelectable(node))&&(updateSelection$1(view,new NodeSelection$1($pos),"pointer"),!0)}function selectClickedNode$1(view,inside){if(-1==inside)return!1;let selectedNode,selectAt,sel=view.state.selection;sel instanceof NodeSelection$1&&(selectedNode=sel.node);let $pos=view.state.doc.resolve(inside);for(let i=$pos.depth+1;i>0;i--){let node=i>$pos.depth?$pos.nodeAfter:$pos.node(i);if(NodeSelection$1.isSelectable(node)){selectAt=selectedNode&&sel.$from.depth>0&&i>=sel.$from.depth&&$pos.before(sel.$from.depth+1)==sel.$from.pos?$pos.before(sel.$from.depth):$pos.before(i);break}}return null!=selectAt&&(updateSelection$1(view,NodeSelection$1.create(view.state.doc,selectAt),"pointer"),!0)}function handleSingleClick$1(view,pos,inside,event,selectNode){return runHandlerOnContext$1(view,"handleClickOn",pos,inside,event)||view.someProp("handleClick",(f=>f(view,pos,event)))||(selectNode?selectClickedNode$1(view,inside):selectClickedLeaf$1(view,inside))}function handleDoubleClick$1(view,pos,inside,event){return runHandlerOnContext$1(view,"handleDoubleClickOn",pos,inside,event)||view.someProp("handleDoubleClick",(f=>f(view,pos,event)))}function handleTripleClick$1$1(view,pos,inside,event){return runHandlerOnContext$1(view,"handleTripleClickOn",pos,inside,event)||view.someProp("handleTripleClick",(f=>f(view,pos,event)))||defaultTripleClick$1(view,inside,event)}function defaultTripleClick$1(view,inside,event){if(0!=event.button)return!1;let doc=view.state.doc;if(-1==inside)return!!doc.inlineContent&&(updateSelection$1(view,TextSelection$1.create(doc,0,doc.content.size),"pointer"),!0);let $pos=doc.resolve(inside);for(let i=$pos.depth+1;i>0;i--){let node=i>$pos.depth?$pos.nodeAfter:$pos.node(i),nodePos=$pos.before(i);if(node.inlineContent)updateSelection$1(view,TextSelection$1.create(doc,nodePos+1,nodePos+1+node.content.size),"pointer");else{if(!NodeSelection$1.isSelectable(node))continue;updateSelection$1(view,NodeSelection$1.create(doc,nodePos),"pointer")}return!0}}function forceDOMFlush$1(view){return endComposition$1(view)}editHandlers$1.keydown=(view,_event)=>{let event=_event;if(view.input.shiftKey=16==event.keyCode||event.shiftKey,!inOrNearComposition$1(view,event)&&(view.input.lastKeyCode=event.keyCode,view.input.lastKeyCodeTime=Date.now(),!android$1||!chrome$1$1||13!=event.keyCode))
// On iOS, if we preventDefault enter key presses, the virtual
// keyboard gets confused. So the hack here is to set a flag that
// makes the DOM change code recognize that what just happens should
// be replaced by whatever the Enter key handlers do.
if(229!=event.keyCode&&view.domObserver.forceFlush(),!ios$1||13!=event.keyCode||event.ctrlKey||event.altKey||event.metaKey)view.someProp("handleKeyDown",(f=>f(view,event)))||captureKeyDown$1(view,event)?event.preventDefault():setSelectionOrigin$1(view,"key");else{let now=Date.now();view.input.lastIOSEnter=now,view.input.lastIOSEnterFallbackTimeout=setTimeout((()=>{view.input.lastIOSEnter==now&&(view.someProp("handleKeyDown",(f=>f(view,keyEvent$1(13,"Enter")))),view.input.lastIOSEnter=0)}),200)}},editHandlers$1.keyup=(view,event)=>{16==event.keyCode&&(view.input.shiftKey=!1)},editHandlers$1.keypress=(view,_event)=>{let event=_event;if(inOrNearComposition$1(view,event)||!event.charCode||event.ctrlKey&&!event.altKey||mac$2$1&&event.metaKey)return;if(view.someProp("handleKeyPress",(f=>f(view,event))))return void event.preventDefault();let sel=view.state.selection;if(!(sel instanceof TextSelection$1)||!sel.$from.sameParent(sel.$to)){let text=String.fromCharCode(event.charCode);view.someProp("handleTextInput",(f=>f(view,sel.$from.pos,sel.$to.pos,text)))||view.dispatch(view.state.tr.insertText(text).scrollIntoView()),event.preventDefault()}};const selectNodeModifier$1=mac$2$1?"metaKey":"ctrlKey";handlers$1.mousedown=(view,_event)=>{let event=_event;view.input.shiftKey=event.shiftKey;let flushed=forceDOMFlush$1(view),now=Date.now(),type="singleClick";now-view.input.lastClick.time<500&&isNear$1(event,view.input.lastClick)&&!event[selectNodeModifier$1]&&("singleClick"==view.input.lastClick.type?type="doubleClick":"doubleClick"==view.input.lastClick.type&&(type="tripleClick")),view.input.lastClick={time:now,x:event.clientX,y:event.clientY,type:type};let pos=view.posAtCoords(eventCoords$1(event));pos&&("singleClick"==type?(view.input.mouseDown&&view.input.mouseDown.done(),view.input.mouseDown=new MouseDown$1(view,pos,event,!!flushed)):("doubleClick"==type?handleDoubleClick$1:handleTripleClick$1$1)(view,pos.pos,pos.inside,event)?event.preventDefault():setSelectionOrigin$1(view,"pointer"))};class MouseDown$1{constructor(view,pos,event,flushed){let targetNode,targetPos;if(this.view=view,this.pos=pos,this.event=event,this.flushed=flushed,this.delayedSelectionSync=!1,this.mightDrag=null,this.startDoc=view.state.doc,this.selectNode=!!event[selectNodeModifier$1],this.allowDefault=event.shiftKey,pos.inside>-1)targetNode=view.state.doc.nodeAt(pos.inside),targetPos=pos.inside;else{let $pos=view.state.doc.resolve(pos.pos);targetNode=$pos.parent,targetPos=$pos.depth?$pos.before():0}const target=flushed?null:event.target,targetDesc=target?view.docView.nearestDesc(target,!0):null;this.target=targetDesc?targetDesc.dom:null;let{selection:selection}=view.state;(0==event.button&&targetNode.type.spec.draggable&&!1!==targetNode.type.spec.selectable||selection instanceof NodeSelection$1&&selection.from<=targetPos&&selection.to>targetPos)&&(this.mightDrag={node:targetNode,pos:targetPos,addAttr:!(!this.target||this.target.draggable),setUneditable:!(!this.target||!gecko$1||this.target.hasAttribute("contentEditable"))}),this.target&&this.mightDrag&&(this.mightDrag.addAttr||this.mightDrag.setUneditable)&&(this.view.domObserver.stop(),this.mightDrag.addAttr&&(this.target.draggable=!0),this.mightDrag.setUneditable&&setTimeout((()=>{this.view.input.mouseDown==this&&this.target.setAttribute("contentEditable","false")}),20),this.view.domObserver.start()),view.root.addEventListener("mouseup",this.up=this.up.bind(this)),view.root.addEventListener("mousemove",this.move=this.move.bind(this)),setSelectionOrigin$1(view,"pointer")}done(){this.view.root.removeEventListener("mouseup",this.up),this.view.root.removeEventListener("mousemove",this.move),this.mightDrag&&this.target&&(this.view.domObserver.stop(),this.mightDrag.addAttr&&this.target.removeAttribute("draggable"),this.mightDrag.setUneditable&&this.target.removeAttribute("contentEditable"),this.view.domObserver.start()),this.delayedSelectionSync&&setTimeout((()=>selectionToDOM$1(this.view))),this.view.input.mouseDown=null}up(event){if(this.done(),!this.view.dom.contains(event.target))return;let pos=this.pos;this.view.state.doc!=this.startDoc&&(pos=this.view.posAtCoords(eventCoords$1(event))),this.allowDefault||!pos?setSelectionOrigin$1(this.view,"pointer"):handleSingleClick$1(this.view,pos.pos,pos.inside,event,this.selectNode)?event.preventDefault():0==event.button&&(this.flushed||
// Safari ignores clicks on draggable elements
safari$1&&this.mightDrag&&!this.mightDrag.node.isAtom||
// Chrome will sometimes treat a node selection as a
// cursor, but still report that the node is selected
// when asked through getSelection. You'll then get a
// situation where clicking at the point where that
// (hidden) cursor is doesn't change the selection, and
// thus doesn't get a reaction from ProseMirror. This
// works around that.
chrome$1$1&&!(this.view.state.selection instanceof TextSelection$1)&&Math.min(Math.abs(pos.pos-this.view.state.selection.from),Math.abs(pos.pos-this.view.state.selection.to))<=2)?(updateSelection$1(this.view,Selection$1.near(this.view.state.doc.resolve(pos.pos)),"pointer"),event.preventDefault()):setSelectionOrigin$1(this.view,"pointer")}move(event){!this.allowDefault&&(Math.abs(this.event.x-event.clientX)>4||Math.abs(this.event.y-event.clientY)>4)&&(this.allowDefault=!0),setSelectionOrigin$1(this.view,"pointer"),0==event.buttons&&this.done()}}function inOrNearComposition$1(view,event){return!!view.composing||
// See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
// On Japanese input method editors (IMEs), the Enter key is used to confirm character
// selection. On Safari, when Enter is pressed, compositionend and keydown events are
// emitted. The keydown event triggers newline insertion, which we don't want.
// This method returns true if the keydown event should be ignored.
// We only ignore it once, as pressing Enter a second time *should* insert a newline.
// Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.
// This guards against the case where compositionend is triggered without the keyboard
// (e.g. character confirmation may be done with the mouse), and keydown is triggered
// afterwards- we wouldn't want to ignore the keydown event in this case.
!!(safari$1&&Math.abs(event.timeStamp-view.input.compositionEndedAt)<500)&&(view.input.compositionEndedAt=-2e8,!0)}
// Drop active composition after 5 seconds of inactivity on Android
handlers$1.touchdown=view=>{forceDOMFlush$1(view),setSelectionOrigin$1(view,"pointer")},handlers$1.contextmenu=view=>forceDOMFlush$1(view);const timeoutComposition$1=android$1?5e3:-1;function scheduleComposeEnd$1(view,delay){clearTimeout(view.input.composingTimeout),delay>-1&&(view.input.composingTimeout=setTimeout((()=>endComposition$1(view)),delay))}function clearComposition$1(view){view.composing&&(view.input.composing=!1,view.input.compositionEndedAt=timestampFromCustomEvent$1());while(view.input.compositionNodes.length>0)view.input.compositionNodes.pop().markParentsDirty()}function timestampFromCustomEvent$1(){let event=document.createEvent("Event");return event.initEvent("event",!0,!0),event.timeStamp}
/**
@internal
*/function endComposition$1(view,forceUpdate=!1){if(!(android$1&&view.domObserver.flushingSoon>=0)){if(view.domObserver.forceFlush(),clearComposition$1(view),forceUpdate||view.docView&&view.docView.dirty){let sel=selectionFromDOM$1(view);return sel&&!sel.eq(view.state.selection)?view.dispatch(view.state.tr.setSelection(sel)):view.updateState(view.state),!0}return!1}}function captureCopy$1(view,dom){
// The extra wrapper is somehow necessary on IE/Edge to prevent the
// content from being mangled when it is put onto the clipboard
if(!view.dom.parentNode)return;let wrap=view.dom.parentNode.appendChild(document.createElement("div"));wrap.appendChild(dom),wrap.style.cssText="position: fixed; left: -10000px; top: 10px";let sel=getSelection(),range=document.createRange();range.selectNodeContents(dom),
// Done because IE will fire a selectionchange moving the selection
// to its start when removeAllRanges is called and the editor still
// has focus (which will mess up the editor's selection state).
view.dom.blur(),sel.removeAllRanges(),sel.addRange(range),setTimeout((()=>{wrap.parentNode&&wrap.parentNode.removeChild(wrap),view.focus()}),50)}
// This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard API—all the objects and methods are
// there, they just don't work, and they are hard to test.
editHandlers$1.compositionstart=editHandlers$1.compositionupdate=view=>{if(!view.composing){view.domObserver.flush();let{state:state}=view,$pos=state.selection.$from;if(state.selection.empty&&(state.storedMarks||!$pos.textOffset&&$pos.parentOffset&&$pos.nodeBefore.marks.some((m=>!1===m.type.spec.inclusive))))
// Need to wrap the cursor in mark nodes different from the ones in the DOM context
view.markCursor=view.state.storedMarks||$pos.marks(),endComposition$1(view,!0),view.markCursor=null;else
// In firefox, if the cursor is after but outside a marked node,
// the inserted text won't inherit the marks. So this moves it
// inside if necessary.
if(endComposition$1(view),gecko$1&&state.selection.empty&&$pos.parentOffset&&!$pos.textOffset&&$pos.nodeBefore.marks.length){let sel=view.domSelection();for(let node=sel.focusNode,offset=sel.focusOffset;node&&1==node.nodeType&&0!=offset;){let before=offset<0?node.lastChild:node.childNodes[offset-1];if(!before)break;if(3==before.nodeType){sel.collapse(before,before.nodeValue.length);break}node=before,offset=-1}}view.input.composing=!0}scheduleComposeEnd$1(view,timeoutComposition$1)},editHandlers$1.compositionend=(view,event)=>{view.composing&&(view.input.composing=!1,view.input.compositionEndedAt=event.timeStamp,scheduleComposeEnd$1(view,20))};const brokenClipboardAPI$1=ie$1$1&&ie_version$1<15||ios$1&&webkit_version$1<604;function sliceSingleNode$1(slice){return 0==slice.openStart&&0==slice.openEnd&&1==slice.content.childCount?slice.content.firstChild:null}function capturePaste$1(view,event){if(!view.dom.parentNode)return;let plainText=view.input.shiftKey||view.state.selection.$from.parent.type.spec.code,target=view.dom.parentNode.appendChild(document.createElement(plainText?"textarea":"div"));plainText||(target.contentEditable="true"),target.style.cssText="position: fixed; left: -10000px; top: 10px",target.focus(),setTimeout((()=>{view.focus(),target.parentNode&&target.parentNode.removeChild(target),plainText?doPaste$1(view,target.value,null,event):doPaste$1(view,target.textContent,target.innerHTML,event)}),50)}function doPaste$1(view,text,html,event){let slice=parseFromClipboard$1(view,text,html,view.input.shiftKey,view.state.selection.$from);if(view.someProp("handlePaste",(f=>f(view,event,slice||Slice$1.empty))))return!0;if(!slice)return!1;let singleNode=sliceSingleNode$1(slice),tr=singleNode?view.state.tr.replaceSelectionWith(singleNode,view.input.shiftKey):view.state.tr.replaceSelection(slice);return view.dispatch(tr.scrollIntoView().setMeta("paste",!0).setMeta("uiEvent","paste")),!0}handlers$1.copy=editHandlers$1.cut=(view,_event)=>{let event=_event,sel=view.state.selection,cut="cut"==event.type;if(sel.empty)return;
// IE and Edge's clipboard interface is completely broken
let data=brokenClipboardAPI$1?null:event.clipboardData,slice=sel.content(),{dom:dom,text:text}=serializeForClipboard$1(view,slice);data?(event.preventDefault(),data.clearData(),data.setData("text/html",dom.innerHTML),data.setData("text/plain",text)):captureCopy$1(view,dom),cut&&view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent","cut"))},editHandlers$1.paste=(view,_event)=>{let event=_event;
// Handling paste from JavaScript during composition is very poorly
// handled by browsers, so as a dodgy but preferable kludge, we just
// let the browser do its native thing there, except on Android,
// where the editor is almost always composing.
if(view.composing&&!android$1)return;let data=brokenClipboardAPI$1?null:event.clipboardData;data&&doPaste$1(view,data.getData("text/plain"),data.getData("text/html"),event)?event.preventDefault():capturePaste$1(view,event)};class Dragging$1{constructor(slice,move){this.slice=slice,this.move=move}}const dragCopyModifier$1=mac$2$1?"altKey":"ctrlKey";handlers$1.dragstart=(view,_event)=>{let event=_event,mouseDown=view.input.mouseDown;if(mouseDown&&mouseDown.done(),!event.dataTransfer)return;let sel=view.state.selection,pos=sel.empty?null:view.posAtCoords(eventCoords$1(event));if(pos&&pos.pos>=sel.from&&pos.pos<=(sel instanceof NodeSelection$1?sel.to-1:sel.to));else if(mouseDown&&mouseDown.mightDrag)view.dispatch(view.state.tr.setSelection(NodeSelection$1.create(view.state.doc,mouseDown.mightDrag.pos)));else if(event.target&&1==event.target.nodeType){let desc=view.docView.nearestDesc(event.target,!0);desc&&desc.node.type.spec.draggable&&desc!=view.docView&&view.dispatch(view.state.tr.setSelection(NodeSelection$1.create(view.state.doc,desc.posBefore)))}let slice=view.state.selection.content(),{dom:dom,text:text}=serializeForClipboard$1(view,slice);event.dataTransfer.clearData(),event.dataTransfer.setData(brokenClipboardAPI$1?"Text":"text/html",dom.innerHTML),
// See https://github.com/ProseMirror/prosemirror/issues/1156
event.dataTransfer.effectAllowed="copyMove",brokenClipboardAPI$1||event.dataTransfer.setData("text/plain",text),view.dragging=new Dragging$1(slice,!event[dragCopyModifier$1])},handlers$1.dragend=view=>{let dragging=view.dragging;window.setTimeout((()=>{view.dragging==dragging&&(view.dragging=null)}),50)},editHandlers$1.dragover=editHandlers$1.dragenter=(_,e)=>e.preventDefault(),editHandlers$1.drop=(view,_event)=>{let event=_event,dragging=view.dragging;if(view.dragging=null,!event.dataTransfer)return;let eventPos=view.posAtCoords(eventCoords$1(event));if(!eventPos)return;let $mouse=view.state.doc.resolve(eventPos.pos);if(!$mouse)return;let slice=dragging&&dragging.slice;slice?view.someProp("transformPasted",(f=>{slice=f(slice)})):slice=parseFromClipboard$1(view,event.dataTransfer.getData(brokenClipboardAPI$1?"Text":"text/plain"),brokenClipboardAPI$1?null:event.dataTransfer.getData("text/html"),!1,$mouse);let move=!(!dragging||event[dragCopyModifier$1]);if(view.someProp("handleDrop",(f=>f(view,event,slice||Slice$1.empty,move))))return void event.preventDefault();if(!slice)return;event.preventDefault();let insertPos=slice?dropPoint$1(view.state.doc,$mouse.pos,slice):$mouse.pos;null==insertPos&&(insertPos=$mouse.pos);let tr=view.state.tr;move&&tr.deleteSelection();let pos=tr.mapping.map(insertPos),isNode=0==slice.openStart&&0==slice.openEnd&&1==slice.content.childCount,beforeInsert=tr.doc;if(isNode?tr.replaceRangeWith(pos,pos,slice.content.firstChild):tr.replaceRange(pos,pos,slice),tr.doc.eq(beforeInsert))return;let $pos=tr.doc.resolve(pos);if(isNode&&NodeSelection$1.isSelectable(slice.content.firstChild)&&$pos.nodeAfter&&$pos.nodeAfter.sameMarkup(slice.content.firstChild))tr.setSelection(new NodeSelection$1($pos));else{let end=tr.mapping.map(insertPos);tr.mapping.maps[tr.mapping.maps.length-1].forEach(((_from,_to,_newFrom,newTo)=>end=newTo)),tr.setSelection(selectionBetween$1(view,$pos,tr.doc.resolve(end)))}view.focus(),view.dispatch(tr.setMeta("uiEvent","drop"))},handlers$1.focus=view=>{view.focused||(view.domObserver.stop(),view.dom.classList.add("ProseMirror-focused"),view.domObserver.start(),view.focused=!0,setTimeout((()=>{view.docView&&view.hasFocus()&&!view.domObserver.currentSelection.eq(view.domSelection())&&selectionToDOM$1(view)}),20))},handlers$1.blur=(view,_event)=>{let event=_event;view.focused&&(view.domObserver.stop(),view.dom.classList.remove("ProseMirror-focused"),view.domObserver.start(),event.relatedTarget&&view.dom.contains(event.relatedTarget)&&view.domObserver.currentSelection.clear(),view.focused=!1)},handlers$1.beforeinput=(view,_event)=>{let event=_event;
// We should probably do more with beforeinput events, but support
// is so spotty that I'm still waiting to see where they are going.
// Very specific hack to deal with backspace sometimes failing on
// Chrome Android when after an uneditable node.
if(chrome$1$1&&android$1&&"deleteContentBackward"==event.inputType){view.domObserver.flushSoon();let{domChangeCount:domChangeCount}=view.input;setTimeout((()=>{if(view.input.domChangeCount!=domChangeCount)return;// Event already had some effect
// This bug tends to close the virtual keyboard, so we refocus
if(view.dom.blur(),view.focus(),view.someProp("handleKeyDown",(f=>f(view,keyEvent$1(8,"Backspace")))))return;let{$cursor:$cursor}=view.state.selection;
// Crude approximation of backspace behavior when no command handled it
$cursor&&$cursor.pos>0&&view.dispatch(view.state.tr.delete($cursor.pos-1,$cursor.pos).scrollIntoView())}),50)}};
// Make sure all handlers get registered
for(let prop in editHandlers$1)handlers$1[prop]=editHandlers$1[prop];function compareObjs$1(a,b){if(a==b)return!0;for(let p in a)if(a[p]!==b[p])return!1;for(let p in b)if(!(p in a))return!1;return!0}class WidgetType$1{constructor(toDOM,spec){this.toDOM=toDOM,this.spec=spec||noSpec$1,this.side=this.spec.side||0}map(mapping,span,offset,oldOffset){let{pos:pos,deleted:deleted}=mapping.mapResult(span.from+oldOffset,this.side<0?-1:1);return deleted?null:new Decoration$1(pos-offset,pos-offset,this)}valid(){return!0}eq(other){return this==other||other instanceof WidgetType$1&&(this.spec.key&&this.spec.key==other.spec.key||this.toDOM==other.toDOM&&compareObjs$1(this.spec,other.spec))}destroy(node){this.spec.destroy&&this.spec.destroy(node)}}class InlineType$1{constructor(attrs,spec){this.attrs=attrs,this.spec=spec||noSpec$1}map(mapping,span,offset,oldOffset){let from=mapping.map(span.from+oldOffset,this.spec.inclusiveStart?-1:1)-offset,to=mapping.map(span.to+oldOffset,this.spec.inclusiveEnd?1:-1)-offset;return from>=to?null:new Decoration$1(from,to,this)}valid(_,span){return span.from<span.to}eq(other){return this==other||other instanceof InlineType$1&&compareObjs$1(this.attrs,other.attrs)&&compareObjs$1(this.spec,other.spec)}static is(span){return span.type instanceof InlineType$1}destroy(){}}class NodeType$2{constructor(attrs,spec){this.attrs=attrs,this.spec=spec||noSpec$1}map(mapping,span,offset,oldOffset){let from=mapping.mapResult(span.from+oldOffset,1);if(from.deleted)return null;let to=mapping.mapResult(span.to+oldOffset,-1);return to.deleted||to.pos<=from.pos?null:new Decoration$1(from.pos-offset,to.pos-offset,this)}valid(node,span){let child,{index:index,offset:offset}=node.content.findIndex(span.from);return offset==span.from&&!(child=node.child(index)).isText&&offset+child.nodeSize==span.to}eq(other){return this==other||other instanceof NodeType$2&&compareObjs$1(this.attrs,other.attrs)&&compareObjs$1(this.spec,other.spec)}destroy(){}}
/**
Decoration objects can be provided to the view through the
[`decorations` prop](https://prosemirror.net/docs/ref/#view.EditorProps.decorations). They come in
several variants—see the static members of this class for details.
*/class Decoration$1{
/**
    @internal
    */
constructor(
/**
    The start position of the decoration.
    */
from,
/**
    The end position. Will be the same as `from` for [widget
    decorations](https://prosemirror.net/docs/ref/#view.Decoration^widget).
    */
to,
/**
    @internal
    */
type){this.from=from,this.to=to,this.type=type}
/**
    @internal
    */copy(from,to){return new Decoration$1(from,to,this.type)}
/**
    @internal
    */eq(other,offset=0){return this.type.eq(other.type)&&this.from+offset==other.from&&this.to+offset==other.to}
/**
    @internal
    */map(mapping,offset,oldOffset){return this.type.map(mapping,this,offset,oldOffset)}
/**
    Creates a widget decoration, which is a DOM node that's shown in
    the document at the given position. It is recommended that you
    delay rendering the widget by passing a function that will be
    called when the widget is actually drawn in a view, but you can
    also directly pass a DOM node. `getPos` can be used to find the
    widget's current document position.
    */static widget(pos,toDOM,spec){return new Decoration$1(pos,pos,new WidgetType$1(toDOM,spec))}
/**
    Creates an inline decoration, which adds the given attributes to
    each inline node between `from` and `to`.
    */static inline(from,to,attrs,spec){return new Decoration$1(from,to,new InlineType$1(attrs,spec))}
/**
    Creates a node decoration. `from` and `to` should point precisely
    before and after a node in the document. That node, and only that
    node, will receive the given attributes.
    */static node(from,to,attrs,spec){return new Decoration$1(from,to,new NodeType$2(attrs,spec))}
/**
    The spec provided when creating this decoration. Can be useful
    if you've stored extra information in that object.
    */get spec(){return this.type.spec}
/**
    @internal
    */get inline(){return this.type instanceof InlineType$1}}const none$1=[],noSpec$1={};
/**
A collection of [decorations](https://prosemirror.net/docs/ref/#view.Decoration), organized in such
a way that the drawing algorithm can efficiently use and compare
them. This is a persistent data structure—it is not modified,
updates create a new value.
*/class DecorationSet$1{
/**
    @internal
    */
constructor(local,children){this.local=local.length?local:none$1,this.children=children.length?children:none$1}
/**
    Create a set of decorations, using the structure of the given
    document.
    */static create(doc,decorations){return decorations.length?buildTree$1(decorations,doc,0,noSpec$1):empty$1}
/**
    Find all decorations in this set which touch the given range
    (including decorations that start or end directly at the
    boundaries) and match the given predicate on their spec. When
    `start` and `end` are omitted, all decorations in the set are
    considered. When `predicate` isn't given, all decorations are
    assumed to match.
    */find(start,end,predicate){let result=[];return this.findInner(null==start?0:start,null==end?1e9:end,result,0,predicate),result}findInner(start,end,result,offset,predicate){for(let i=0;i<this.local.length;i++){let span=this.local[i];span.from<=end&&span.to>=start&&(!predicate||predicate(span.spec))&&result.push(span.copy(span.from+offset,span.to+offset))}for(let i=0;i<this.children.length;i+=3)if(this.children[i]<end&&this.children[i+1]>start){let childOff=this.children[i]+1;this.children[i+2].findInner(start-childOff,end-childOff,result,offset+childOff,predicate)}}
/**
    Map the set of decorations in response to a change in the
    document.
    */map(mapping,doc,options){return this==empty$1||0==mapping.maps.length?this:this.mapInner(mapping,doc,0,0,options||noSpec$1)}
/**
    @internal
    */mapInner(mapping,node,offset,oldOffset,options){let newLocal;for(let i=0;i<this.local.length;i++){let mapped=this.local[i].map(mapping,offset,oldOffset);mapped&&mapped.type.valid(node,mapped)?(newLocal||(newLocal=[])).push(mapped):options.onRemove&&options.onRemove(this.local[i].spec)}return this.children.length?mapChildren$1(this.children,newLocal||[],mapping,node,offset,oldOffset,options):newLocal?new DecorationSet$1(newLocal.sort(byPos$1),none$1):empty$1}
/**
    Add the given array of decorations to the ones in the set,
    producing a new set. Needs access to the current document to
    create the appropriate tree structure.
    */add(doc,decorations){return decorations.length?this==empty$1?DecorationSet$1.create(doc,decorations):this.addInner(doc,decorations,0):this}addInner(doc,decorations,offset){let children,childIndex=0;doc.forEach(((childNode,childOffset)=>{let found,baseOffset=childOffset+offset;if(found=takeSpansForNode$1(decorations,childNode,baseOffset)){children||(children=this.children.slice());while(childIndex<children.length&&children[childIndex]<childOffset)childIndex+=3;children[childIndex]==childOffset?children[childIndex+2]=children[childIndex+2].addInner(childNode,found,baseOffset+1):children.splice(childIndex,0,childOffset,childOffset+childNode.nodeSize,buildTree$1(found,childNode,baseOffset+1,noSpec$1)),childIndex+=3}}));let local=moveSpans$1(childIndex?withoutNulls$1(decorations):decorations,-offset);for(let i=0;i<local.length;i++)local[i].type.valid(doc,local[i])||local.splice(i--,1);return new DecorationSet$1(local.length?this.local.concat(local).sort(byPos$1):this.local,children||this.children)}
/**
    Create a new set that contains the decorations in this set, minus
    the ones in the given array.
    */remove(decorations){return 0==decorations.length||this==empty$1?this:this.removeInner(decorations,0)}removeInner(decorations,offset){let children=this.children,local=this.local;for(let i=0;i<children.length;i+=3){let found,from=children[i]+offset,to=children[i+1]+offset;for(let span,j=0;j<decorations.length;j++)(span=decorations[j])&&span.from>from&&span.to<to&&(decorations[j]=null,(found||(found=[])).push(span));if(!found)continue;children==this.children&&(children=this.children.slice());let removed=children[i+2].removeInner(found,from+1);removed!=empty$1?children[i+2]=removed:(children.splice(i,3),i-=3)}if(local.length)for(let span,i=0;i<decorations.length;i++)if(span=decorations[i])for(let j=0;j<local.length;j++)local[j].eq(span,offset)&&(local==this.local&&(local=this.local.slice()),local.splice(j--,1));return children==this.children&&local==this.local?this:local.length||children.length?new DecorationSet$1(local,children):empty$1}
/**
    @internal
    */forChild(offset,node){if(this==empty$1)return this;if(node.isLeaf)return DecorationSet$1.empty;let child,local;for(let i=0;i<this.children.length;i+=3)if(this.children[i]>=offset){this.children[i]==offset&&(child=this.children[i+2]);break}let start=offset+1,end=start+node.content.size;for(let i=0;i<this.local.length;i++){let dec=this.local[i];if(dec.from<end&&dec.to>start&&dec.type instanceof InlineType$1){let from=Math.max(start,dec.from)-start,to=Math.min(end,dec.to)-start;from<to&&(local||(local=[])).push(dec.copy(from,to))}}if(local){let localSet=new DecorationSet$1(local.sort(byPos$1),none$1);return child?new DecorationGroup$1([localSet,child]):localSet}return child||empty$1}
/**
    @internal
    */eq(other){if(this==other)return!0;if(!(other instanceof DecorationSet$1)||this.local.length!=other.local.length||this.children.length!=other.children.length)return!1;for(let i=0;i<this.local.length;i++)if(!this.local[i].eq(other.local[i]))return!1;for(let i=0;i<this.children.length;i+=3)if(this.children[i]!=other.children[i]||this.children[i+1]!=other.children[i+1]||!this.children[i+2].eq(other.children[i+2]))return!1;return!0}
/**
    @internal
    */locals(node){return removeOverlap$1(this.localsInner(node))}
/**
    @internal
    */localsInner(node){if(this==empty$1)return none$1;if(node.inlineContent||!this.local.some(InlineType$1.is))return this.local;let result=[];for(let i=0;i<this.local.length;i++)this.local[i].type instanceof InlineType$1||result.push(this.local[i]);return result}}
/**
The empty set of decorations.
*/DecorationSet$1.empty=new DecorationSet$1([],[]),
/**
@internal
*/
DecorationSet$1.removeOverlap=removeOverlap$1;const empty$1=DecorationSet$1.empty;
// An abstraction that allows the code dealing with decorations to
// treat multiple DecorationSet objects as if it were a single object
// with (a subset of) the same interface.
class DecorationGroup$1{constructor(members){this.members=members}map(mapping,doc){const mappedDecos=this.members.map((member=>member.map(mapping,doc,noSpec$1)));return DecorationGroup$1.from(mappedDecos)}forChild(offset,child){if(child.isLeaf)return DecorationSet$1.empty;let found=[];for(let i=0;i<this.members.length;i++){let result=this.members[i].forChild(offset,child);result!=empty$1&&(result instanceof DecorationGroup$1?found=found.concat(result.members):found.push(result))}return DecorationGroup$1.from(found)}eq(other){if(!(other instanceof DecorationGroup$1)||other.members.length!=this.members.length)return!1;for(let i=0;i<this.members.length;i++)if(!this.members[i].eq(other.members[i]))return!1;return!0}locals(node){let result,sorted=!0;for(let i=0;i<this.members.length;i++){let locals=this.members[i].localsInner(node);if(locals.length)if(result){sorted&&(result=result.slice(),sorted=!1);for(let j=0;j<locals.length;j++)result.push(locals[j])}else result=locals}return result?removeOverlap$1(sorted?result:result.sort(byPos$1)):none$1}
// Create a group for the given array of decoration sets, or return
// a single set when possible.
static from(members){switch(members.length){case 0:return empty$1;case 1:return members[0];default:return new DecorationGroup$1(members)}}}function mapChildren$1(oldChildren,newLocal,mapping,node,offset,oldOffset,options){let children=oldChildren.slice(),shift=(oldStart,oldEnd,newStart,newEnd)=>{for(let i=0;i<children.length;i+=3){let dSize,end=children[i+1];if(end<0||oldStart>end+oldOffset)continue;let start=children[i]+oldOffset;oldEnd>=start?children[i+1]=oldStart<=start?-2:-1:newStart>=offset&&(dSize=newEnd-newStart-(oldEnd-oldStart))&&(children[i]+=dSize,children[i+1]+=dSize)}};
// Mark the children that are directly touched by changes, and
// move those that are after the changes.
for(let i=0;i<mapping.maps.length;i++)mapping.maps[i].forEach(shift);
// Find the child nodes that still correspond to a single node,
// recursively call mapInner on them and update their positions.
let mustRebuild=!1;for(let i=0;i<children.length;i+=3)if(children[i+1]<0){// Touched nodes
if(-2==children[i+1]){mustRebuild=!0,children[i+1]=-1;continue}let from=mapping.map(oldChildren[i]+oldOffset),fromLocal=from-offset;if(fromLocal<0||fromLocal>=node.content.size){mustRebuild=!0;continue}
// Must read oldChildren because children was tagged with -1
let to=mapping.map(oldChildren[i+1]+oldOffset,-1),toLocal=to-offset,{index:index,offset:childOffset}=node.content.findIndex(fromLocal),childNode=node.maybeChild(index);if(childNode&&childOffset==fromLocal&&childOffset+childNode.nodeSize==toLocal){let mapped=children[i+2].mapInner(mapping,childNode,from+1,oldChildren[i]+oldOffset+1,options);mapped!=empty$1?(children[i]=fromLocal,children[i+1]=toLocal,children[i+2]=mapped):(children[i+1]=-2,mustRebuild=!0)}else mustRebuild=!0}
// Remaining children must be collected and rebuilt into the appropriate structure
if(mustRebuild){let decorations=mapAndGatherRemainingDecorations$1(children,oldChildren,newLocal,mapping,offset,oldOffset,options),built=buildTree$1(decorations,node,0,options);newLocal=built.local;for(let i=0;i<children.length;i+=3)children[i+1]<0&&(children.splice(i,3),i-=3);for(let i=0,j=0;i<built.children.length;i+=3){let from=built.children[i];while(j<children.length&&children[j]<from)j+=3;children.splice(j,0,built.children[i],built.children[i+1],built.children[i+2])}}return new DecorationSet$1(newLocal.sort(byPos$1),children)}function moveSpans$1(spans,offset){if(!offset||!spans.length)return spans;let result=[];for(let i=0;i<spans.length;i++){let span=spans[i];result.push(new Decoration$1(span.from+offset,span.to+offset,span.type))}return result}function mapAndGatherRemainingDecorations$1(children,oldChildren,decorations,mapping,offset,oldOffset,options){
// Gather all decorations from the remaining marked children
function gather(set,oldOffset){for(let i=0;i<set.local.length;i++){let mapped=set.local[i].map(mapping,offset,oldOffset);mapped?decorations.push(mapped):options.onRemove&&options.onRemove(set.local[i].spec)}for(let i=0;i<set.children.length;i+=3)gather(set.children[i+2],set.children[i]+oldOffset+1)}for(let i=0;i<children.length;i+=3)-1==children[i+1]&&gather(children[i+2],oldChildren[i]+oldOffset+1);return decorations}function takeSpansForNode$1(spans,node,offset){if(node.isLeaf)return null;let end=offset+node.nodeSize,found=null;for(let span,i=0;i<spans.length;i++)(span=spans[i])&&span.from>offset&&span.to<end&&((found||(found=[])).push(span),spans[i]=null);return found}function withoutNulls$1(array){let result=[];for(let i=0;i<array.length;i++)null!=array[i]&&result.push(array[i]);return result}
// Build up a tree that corresponds to a set of decorations. `offset`
// is a base offset that should be subtracted from the `from` and `to`
// positions in the spans (so that we don't have to allocate new spans
// for recursive calls).
function buildTree$1(spans,node,offset,options){let children=[],hasNulls=!1;node.forEach(((childNode,localStart)=>{let found=takeSpansForNode$1(spans,childNode,localStart+offset);if(found){hasNulls=!0;let subtree=buildTree$1(found,childNode,offset+localStart+1,options);subtree!=empty$1&&children.push(localStart,localStart+childNode.nodeSize,subtree)}}));let locals=moveSpans$1(hasNulls?withoutNulls$1(spans):spans,-offset).sort(byPos$1);for(let i=0;i<locals.length;i++)locals[i].type.valid(node,locals[i])||(options.onRemove&&options.onRemove(locals[i].spec),locals.splice(i--,1));return locals.length||children.length?new DecorationSet$1(locals,children):empty$1}
// Used to sort decorations so that ones with a low start position
// come first, and within a set with the same start position, those
// with an smaller end position come first.
function byPos$1(a,b){return a.from-b.from||a.to-b.to}
// Scan a sorted array of decorations for partially overlapping spans,
// and split those so that only fully overlapping spans are left (to
// make subsequent rendering easier). Will return the input array if
// no partially overlapping spans are found (the common case).
function removeOverlap$1(spans){let working=spans;for(let i=0;i<working.length-1;i++){let span=working[i];if(span.from!=span.to)for(let j=i+1;j<working.length;j++){let next=working[j];if(next.from!=span.from){next.from<span.to&&(working==spans&&(working=spans.slice()),
// The end of this one overlaps with a subsequent span. Split
// this one.
working[i]=span.copy(span.from,next.from),insertAhead$1(working,j,span.copy(next.from,span.to)));break}next.to!=span.to&&(working==spans&&(working=spans.slice()),
// Followed by a partially overlapping larger span. Split that
// span.
working[j]=next.copy(next.from,span.to),insertAhead$1(working,j+1,next.copy(span.to,next.to)))}}return working}function insertAhead$1(array,i,deco){while(i<array.length&&byPos$1(deco,array[i])>0)i++;array.splice(i,0,deco)}var base$1={8:"Backspace",9:"Tab",10:"Enter",12:"NumLock",13:"Enter",16:"Shift",17:"Control",18:"Alt",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",44:"PrintScreen",45:"Insert",46:"Delete",59:";",61:"=",91:"Meta",92:"Meta",106:"*",107:"+",108:",",109:"-",110:".",111:"/",144:"NumLock",145:"ScrollLock",160:"Shift",161:"Shift",162:"Control",163:"Control",164:"Alt",165:"Alt",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},shift$2$1={48:")",49:"!",50:"@",51:"#",52:"$",53:"%",54:"^",55:"&",56:"*",57:"(",59:":",61:"+",173:"_",186:":",187:"+",188:"<",189:"_",190:">",191:"?",192:"~",219:"{",220:"|",221:"}",222:'"'},chrome$2="undefined"!=typeof navigator&&/Chrome\/(\d+)/.exec(navigator.userAgent);"undefined"!=typeof navigator&&/Gecko\/\d+/.test(navigator.userAgent);
// Fill in the digit keys
for(var mac$1$1="undefined"!=typeof navigator&&/Mac/.test(navigator.platform),ie$2="undefined"!=typeof navigator&&/MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent),brokenModifierNames$1=mac$1$1||chrome$2&&+chrome$2[1]<57,i$1=0;i$1<10;i$1++)base$1[48+i$1]=base$1[96+i$1]=String(i$1);
// The function keys
for(i$1=1;i$1<=24;i$1++)base$1[i$1+111]="F"+i$1;
// And the alphabetic keys
for(i$1=65;i$1<=90;i$1++)base$1[i$1]=String.fromCharCode(i$1+32),shift$2$1[i$1]=String.fromCharCode(i$1);
// For each code that doesn't have a shift-equivalent, copy the base name
for(var code$1 in base$1)shift$2$1.hasOwnProperty(code$1)||(shift$2$1[code$1]=base$1[code$1]);function keyName$1(event){var ignoreKey=brokenModifierNames$1&&(event.ctrlKey||event.altKey||event.metaKey)||ie$2&&event.shiftKey&&event.key&&1==event.key.length||"Unidentified"==event.key,name=!ignoreKey&&event.key||(event.shiftKey?shift$2$1:base$1)[event.keyCode]||event.key||"Unidentified";
// Edge sometimes produces wrong names (Issue #3)
return"Esc"==name&&(name="Escape"),"Del"==name&&(name="Delete"),
// https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
"Left"==name&&(name="ArrowLeft"),"Up"==name&&(name="ArrowUp"),"Right"==name&&(name="ArrowRight"),"Down"==name&&(name="ArrowDown"),name}const mac$3="undefined"!=typeof navigator&&/Mac|iP(hone|[oa]d)/.test(navigator.platform);function normalizeKeyName$1$1(name){let alt,ctrl,shift,meta,parts=name.split(/-(?!$)/),result=parts[parts.length-1];"Space"==result&&(result=" ");for(let i=0;i<parts.length-1;i++){let mod=parts[i];if(/^(cmd|meta|m)$/i.test(mod))meta=!0;else if(/^a(lt)?$/i.test(mod))alt=!0;else if(/^(c|ctrl|control)$/i.test(mod))ctrl=!0;else if(/^s(hift)?$/i.test(mod))shift=!0;else{if(!/^mod$/i.test(mod))throw new Error("Unrecognized modifier name: "+mod);mac$3?meta=!0:ctrl=!0}}return alt&&(result="Alt-"+result),ctrl&&(result="Ctrl-"+result),meta&&(result="Meta-"+result),shift&&(result="Shift-"+result),result}function normalize$1(map){let copy=Object.create(null);for(let prop in map)copy[normalizeKeyName$1$1(prop)]=map[prop];return copy}function modifiers$2$1(name,event,shift){return event.altKey&&(name="Alt-"+name),event.ctrlKey&&(name="Ctrl-"+name),event.metaKey&&(name="Meta-"+name),!1!==shift&&event.shiftKey&&(name="Shift-"+name),name}
/**
Given a set of bindings (using the same format as
[`keymap`](https://prosemirror.net/docs/ref/#keymap.keymap)), return a [keydown
handler](https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyDown) that handles them.
*/function keydownHandler$1(bindings){let map=normalize$1(bindings);return function(view,event){let baseName,name=keyName$1(event),isChar=1==name.length&&" "!=name,direct=map[modifiers$2$1(name,event,!isChar)];if(direct&&direct(view.state,view.dispatch,view))return!0;if(isChar&&(event.shiftKey||event.altKey||event.metaKey||name.charCodeAt(0)>127)&&(baseName=base$1[event.keyCode])&&baseName!=name){
// Try falling back to the keyCode when there's a modifier
// active or the character produced isn't ASCII, and our table
// produces a different name from the the keyCode. See #668,
// #1060
let fromCode=map[modifiers$2$1(baseName,event,!0)];if(fromCode&&fromCode(view.state,view.dispatch,view))return!0}else if(isChar&&event.shiftKey){
// Otherwise, if shift is active, also try the binding with the
// Shift- prefix enabled. See #997
let withShift=map[modifiers$2$1(name,event,!0)];if(withShift&&withShift(view.state,view.dispatch,view))return!0}return!1}}
/**
Delete the selection, if there is one.
*/const deleteSelection$1$1=(state,dispatch)=>!state.selection.empty&&(dispatch&&dispatch(state.tr.deleteSelection().scrollIntoView()),!0),joinBackward$1$1=(state,dispatch,view)=>{let{$cursor:$cursor}=state.selection;if(!$cursor||(view?!view.endOfTextblock("backward",state):$cursor.parentOffset>0))return!1;let $cut=findCutBefore$1($cursor);
// If there is no node before this, try to lift
if(!$cut){let range=$cursor.blockRange(),target=range&&liftTarget$1(range);return null!=target&&(dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0)}let before=$cut.nodeBefore;
// Apply the joining algorithm
if(!before.type.spec.isolating&&deleteBarrier$1(state,$cut,dispatch))return!0;
// If the node below has no content and the node above is
// selectable, delete the node below and select the one above.
if(0==$cursor.parent.content.size&&(textblockAt$1(before,"end")||NodeSelection$1.isSelectable(before))){let delStep=replaceStep$1(state.doc,$cursor.before(),$cursor.after(),Slice$1.empty);if(delStep&&delStep.slice.size<delStep.to-delStep.from){if(dispatch){let tr=state.tr.step(delStep);tr.setSelection(textblockAt$1(before,"end")?Selection$1.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos,-1)),-1):NodeSelection$1.create(tr.doc,$cut.pos-before.nodeSize)),dispatch(tr.scrollIntoView())}return!0}}
// If the node before is an atom, delete it
return!(!before.isAtom||$cut.depth!=$cursor.depth-1)&&(dispatch&&dispatch(state.tr.delete($cut.pos-before.nodeSize,$cut.pos).scrollIntoView()),!0)};
/**
If the selection is empty and at the start of a textblock, try to
reduce the distance between that block and the one before it—if
there's a block directly before it that can be joined, join them.
If not, try to move the selected block closer to the next one in
the document structure by lifting it out of its parent or moving it
into a parent of the previous block. Will use the view for accurate
(bidi-aware) start-of-textblock detection if given.
*/function textblockAt$1(node,side,only=!1){for(let scan=node;scan;scan="start"==side?scan.firstChild:scan.lastChild){if(scan.isTextblock)return!0;if(only&&1!=scan.childCount)return!1}return!1}
/**
When the selection is empty and at the start of a textblock, select
the node before that textblock, if possible. This is intended to be
bound to keys like backspace, after
[`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward) or other deleting
commands, as a fall-back behavior when the schema doesn't allow
deletion at the selected point.
*/const selectNodeBackward$1$1=(state,dispatch,view)=>{let{$head:$head,empty:empty}=state.selection,$cut=$head;if(!empty)return!1;if($head.parent.isTextblock){if(view?!view.endOfTextblock("backward",state):$head.parentOffset>0)return!1;$cut=findCutBefore$1($head)}let node=$cut&&$cut.nodeBefore;return!(!node||!NodeSelection$1.isSelectable(node))&&(dispatch&&dispatch(state.tr.setSelection(NodeSelection$1.create(state.doc,$cut.pos-node.nodeSize)).scrollIntoView()),!0)};function findCutBefore$1($pos){if(!$pos.parent.type.spec.isolating)for(let i=$pos.depth-1;i>=0;i--){if($pos.index(i)>0)return $pos.doc.resolve($pos.before(i+1));if($pos.node(i).type.spec.isolating)break}return null}
/**
If the selection is empty and the cursor is at the end of a
textblock, try to reduce or remove the boundary between that block
and the one after it, either by joining them or by moving the other
block closer to this one in the tree structure. Will use the view
for accurate start-of-textblock detection if given.
*/const joinForward$1$1=(state,dispatch,view)=>{let{$cursor:$cursor}=state.selection;if(!$cursor||(view?!view.endOfTextblock("forward",state):$cursor.parentOffset<$cursor.parent.content.size))return!1;let $cut=findCutAfter$1($cursor);
// If there is no node after this, there's nothing to do
if(!$cut)return!1;let after=$cut.nodeAfter;
// Try the joining algorithm
if(deleteBarrier$1(state,$cut,dispatch))return!0;
// If the node above has no content and the node below is
// selectable, delete the node above and select the one below.
if(0==$cursor.parent.content.size&&(textblockAt$1(after,"start")||NodeSelection$1.isSelectable(after))){let delStep=replaceStep$1(state.doc,$cursor.before(),$cursor.after(),Slice$1.empty);if(delStep&&delStep.slice.size<delStep.to-delStep.from){if(dispatch){let tr=state.tr.step(delStep);tr.setSelection(textblockAt$1(after,"start")?Selection$1.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)),1):NodeSelection$1.create(tr.doc,tr.mapping.map($cut.pos))),dispatch(tr.scrollIntoView())}return!0}}
// If the next node is an atom, delete it
return!(!after.isAtom||$cut.depth!=$cursor.depth-1)&&(dispatch&&dispatch(state.tr.delete($cut.pos,$cut.pos+after.nodeSize).scrollIntoView()),!0)},selectNodeForward$1$1=(state,dispatch,view)=>{let{$head:$head,empty:empty}=state.selection,$cut=$head;if(!empty)return!1;if($head.parent.isTextblock){if(view?!view.endOfTextblock("forward",state):$head.parentOffset<$head.parent.content.size)return!1;$cut=findCutAfter$1($head)}let node=$cut&&$cut.nodeAfter;return!(!node||!NodeSelection$1.isSelectable(node))&&(dispatch&&dispatch(state.tr.setSelection(NodeSelection$1.create(state.doc,$cut.pos)).scrollIntoView()),!0)};
/**
When the selection is empty and at the end of a textblock, select
the node coming after that textblock, if possible. This is intended
to be bound to keys like delete, after
[`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward) and similar deleting
commands, to provide a fall-back behavior when the schema doesn't
allow deletion at the selected point.
*/function findCutAfter$1($pos){if(!$pos.parent.type.spec.isolating)for(let i=$pos.depth-1;i>=0;i--){let parent=$pos.node(i);if($pos.index(i)+1<parent.childCount)return $pos.doc.resolve($pos.after(i+1));if(parent.type.spec.isolating)break}return null}
/**
Lift the selected block, or the closest ancestor block of the
selection that can be lifted, out of its parent node.
*/const lift$1$1=(state,dispatch)=>{let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to),target=range&&liftTarget$1(range);return null!=target&&(dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0)},newlineInCode$1$1=(state,dispatch)=>{let{$head:$head,$anchor:$anchor}=state.selection;return!(!$head.parent.type.spec.code||!$head.sameParent($anchor))&&(dispatch&&dispatch(state.tr.insertText("\n").scrollIntoView()),!0)};
/**
If the selection is in a node whose type has a truthy
[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, replace the
selection with a newline character.
*/function defaultBlockAt$1$1(match){for(let i=0;i<match.edgeCount;i++){let{type:type}=match.edge(i);if(type.isTextblock&&!type.hasRequiredAttrs())return type}return null}
/**
When the selection is in a node with a truthy
[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, create a
default block after the code block, and move the cursor there.
*/const exitCode$1$1=(state,dispatch)=>{let{$head:$head,$anchor:$anchor}=state.selection;if(!$head.parent.type.spec.code||!$head.sameParent($anchor))return!1;let above=$head.node(-1),after=$head.indexAfter(-1),type=defaultBlockAt$1$1(above.contentMatchAt(after));if(!type||!above.canReplaceWith(after,after,type))return!1;if(dispatch){let pos=$head.after(),tr=state.tr.replaceWith(pos,pos,type.createAndFill());tr.setSelection(Selection$1.near(tr.doc.resolve(pos),1)),dispatch(tr.scrollIntoView())}return!0},createParagraphNear$1$1=(state,dispatch)=>{let sel=state.selection,{$from:$from,$to:$to}=sel;if(sel instanceof AllSelection$1||$from.parent.inlineContent||$to.parent.inlineContent)return!1;let type=defaultBlockAt$1$1($to.parent.contentMatchAt($to.indexAfter()));if(!type||!type.isTextblock)return!1;if(dispatch){let side=(!$from.parentOffset&&$to.index()<$to.parent.childCount?$from:$to).pos,tr=state.tr.insert(side,type.createAndFill());tr.setSelection(TextSelection$1.create(tr.doc,side+1)),dispatch(tr.scrollIntoView())}return!0},liftEmptyBlock$1$1=(state,dispatch)=>{let{$cursor:$cursor}=state.selection;if(!$cursor||$cursor.parent.content.size)return!1;if($cursor.depth>1&&$cursor.after()!=$cursor.end(-1)){let before=$cursor.before();if(canSplit$1(state.doc,before))return dispatch&&dispatch(state.tr.split(before).scrollIntoView()),!0}let range=$cursor.blockRange(),target=range&&liftTarget$1(range);return null!=target&&(dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0)},selectParentNode$1$1=(state,dispatch)=>{let pos,{$from:$from,to:to}=state.selection,same=$from.sharedDepth(to);return 0!=same&&(pos=$from.before(same),dispatch&&dispatch(state.tr.setSelection(NodeSelection$1.create(state.doc,pos))),!0)};
/**
If a block node is selected, create an empty paragraph before (if
it is its parent's first child) or after it.
*/function joinMaybeClear$1(state,$pos,dispatch){let before=$pos.nodeBefore,after=$pos.nodeAfter,index=$pos.index();return!!(before&&after&&before.type.compatibleContent(after.type))&&(!before.content.size&&$pos.parent.canReplace(index-1,index)?(dispatch&&dispatch(state.tr.delete($pos.pos-before.nodeSize,$pos.pos).scrollIntoView()),!0):!(!$pos.parent.canReplace(index,index+1)||!after.isTextblock&&!canJoin$1(state.doc,$pos.pos))&&(dispatch&&dispatch(state.tr.clearIncompatible($pos.pos,before.type,before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView()),!0))}function deleteBarrier$1(state,$cut,dispatch){let conn,match,before=$cut.nodeBefore,after=$cut.nodeAfter;if(before.type.spec.isolating||after.type.spec.isolating)return!1;if(joinMaybeClear$1(state,$cut,dispatch))return!0;let canDelAfter=$cut.parent.canReplace($cut.index(),$cut.index()+1);if(canDelAfter&&(conn=(match=before.contentMatchAt(before.childCount)).findWrapping(after.type))&&match.matchType(conn[0]||after.type).validEnd){if(dispatch){let end=$cut.pos+after.nodeSize,wrap=Fragment$1.empty;for(let i=conn.length-1;i>=0;i--)wrap=Fragment$1.from(conn[i].create(null,wrap));wrap=Fragment$1.from(before.copy(wrap));let tr=state.tr.step(new ReplaceAroundStep$1($cut.pos-1,end,$cut.pos,end,new Slice$1(wrap,1,0),conn.length,!0)),joinAt=end+2*conn.length;canJoin$1(tr.doc,joinAt)&&tr.join(joinAt),dispatch(tr.scrollIntoView())}return!0}let selAfter=Selection$1.findFrom($cut,1),range=selAfter&&selAfter.$from.blockRange(selAfter.$to),target=range&&liftTarget$1(range);if(null!=target&&target>=$cut.depth)return dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0;if(canDelAfter&&textblockAt$1(after,"start",!0)&&textblockAt$1(before,"end")){let at=before,wrap=[];for(;;){if(wrap.push(at),at.isTextblock)break;at=at.lastChild}let afterText=after,afterDepth=1;for(;!afterText.isTextblock;afterText=afterText.firstChild)afterDepth++;if(at.canReplace(at.childCount,at.childCount,afterText.content)){if(dispatch){let end=Fragment$1.empty;for(let i=wrap.length-1;i>=0;i--)end=Fragment$1.from(wrap[i].copy(end));let tr=state.tr.step(new ReplaceAroundStep$1($cut.pos-wrap.length,$cut.pos+after.nodeSize,$cut.pos+afterDepth,$cut.pos+after.nodeSize-afterDepth,new Slice$1(end,wrap.length,0),0,!0));dispatch(tr.scrollIntoView())}return!0}}return!1}function selectTextblockSide$1(side){return function(state,dispatch){let sel=state.selection,$pos=side<0?sel.$from:sel.$to,depth=$pos.depth;while($pos.node(depth).isInline){if(!depth)return!1;depth--}return!!$pos.node(depth).isTextblock&&(dispatch&&dispatch(state.tr.setSelection(TextSelection$1.create(state.doc,side<0?$pos.start(depth):$pos.end(depth)))),!0)}}
/**
Moves the cursor to the start of current text block.
*/const selectTextblockStart$1$1=selectTextblockSide$1(-1),selectTextblockEnd$1$1=selectTextblockSide$1(1);
/**
Moves the cursor to the end of current text block.
*/
// Parameterized commands
/**
Wrap the selection in a node of the given type with the given
attributes.
*/
function wrapIn$1$1(nodeType,attrs=null){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to),wrapping=range&&findWrapping$1(range,nodeType,attrs);return!!wrapping&&(dispatch&&dispatch(state.tr.wrap(range,wrapping).scrollIntoView()),!0)}}
/**
Returns a command that tries to set the selected textblocks to the
given node type with the given attributes.
*/function setBlockType$2(nodeType,attrs=null){return function(state,dispatch){let{from:from,to:to}=state.selection,applicable=!1;return state.doc.nodesBetween(from,to,((node,pos)=>{if(applicable)return!1;if(node.isTextblock&&!node.hasMarkup(nodeType,attrs))if(node.type==nodeType)applicable=!0;else{let $pos=state.doc.resolve(pos),index=$pos.index();applicable=$pos.parent.canReplaceWith(index,index+1,nodeType)}})),!!applicable&&(dispatch&&dispatch(state.tr.setBlockType(from,to,nodeType,attrs).scrollIntoView()),!0)}}
/**
Returns a command function that wraps the selection in a list with
the given type an attributes. If `dispatch` is null, only return a
value to indicate whether this is possible, but don't actually
perform the change.
*/
function wrapInList$1$1(listType,attrs=null){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to),doJoin=!1,outerRange=range;if(!range)return!1;
// This is at the top of an existing list item
if(range.depth>=2&&$from.node(range.depth-1).type.compatibleContent(listType)&&0==range.startIndex){
// Don't do anything if this is the top of the list
if(0==$from.index(range.depth-1))return!1;let $insert=state.doc.resolve(range.start-2);outerRange=new NodeRange$1($insert,$insert,range.depth),range.endIndex<range.parent.childCount&&(range=new NodeRange$1($from,state.doc.resolve($to.end(range.depth)),range.depth)),doJoin=!0}let wrap=findWrapping$1(outerRange,listType,attrs,range);return!!wrap&&(dispatch&&dispatch(doWrapInList$1(state.tr,range,wrap,doJoin,listType).scrollIntoView()),!0)}}function doWrapInList$1(tr,range,wrappers,joinBefore,listType){let content=Fragment$1.empty;for(let i=wrappers.length-1;i>=0;i--)content=Fragment$1.from(wrappers[i].type.create(wrappers[i].attrs,content));tr.step(new ReplaceAroundStep$1(range.start-(joinBefore?2:0),range.end,range.start,range.end,new Slice$1(content,0,0),wrappers.length,!0));let found=0;for(let i=0;i<wrappers.length;i++)wrappers[i].type==listType&&(found=i+1);let splitDepth=wrappers.length-found,splitPos=range.start+wrappers.length-(joinBefore?2:0),parent=range.parent;for(let i=range.startIndex,e=range.endIndex,first=!0;i<e;i++,first=!1)!first&&canSplit$1(tr.doc,splitPos,splitDepth)&&(tr.split(splitPos,splitDepth),splitPos+=2*splitDepth),splitPos+=parent.child(i).nodeSize;return tr}
/**
Create a command to lift the list item around the selection up into
a wrapping list.
*/function liftListItem$1$1(itemType){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to,(node=>node.childCount>0&&node.firstChild.type==itemType));return!!range&&(!dispatch||($from.node(range.depth-1).type==itemType?liftToOuterList$1(state,dispatch,itemType,range):liftOutOfList$1(state,dispatch,range)))}}function liftToOuterList$1(state,dispatch,itemType,range){let tr=state.tr,end=range.end,endOfList=range.$to.end(range.depth);return end<endOfList&&(
// There are siblings after the lifted items, which must become
// children of the last item
tr.step(new ReplaceAroundStep$1(end-1,endOfList,end,endOfList,new Slice$1(Fragment$1.from(itemType.create(null,range.parent.copy())),1,0),1,!0)),range=new NodeRange$1(tr.doc.resolve(range.$from.pos),tr.doc.resolve(endOfList),range.depth)),dispatch(tr.lift(range,liftTarget$1(range)).scrollIntoView()),!0}function liftOutOfList$1(state,dispatch,range){let tr=state.tr,list=range.parent;
// Merge the list items into a single big item
for(let pos=range.end,i=range.endIndex-1,e=range.startIndex;i>e;i--)pos-=list.child(i).nodeSize,tr.delete(pos-1,pos+1);let $start=tr.doc.resolve(range.start),item=$start.nodeAfter;if(tr.mapping.map(range.end)!=range.start+$start.nodeAfter.nodeSize)return!1;let atStart=0==range.startIndex,atEnd=range.endIndex==list.childCount,parent=$start.node(-1),indexBefore=$start.index(-1);if(!parent.canReplace(indexBefore+(atStart?0:1),indexBefore+1,item.content.append(atEnd?Fragment$1.empty:Fragment$1.from(list))))return!1;let start=$start.pos,end=start+item.nodeSize;
// Strip off the surrounding list. At the sides where we're not at
// the end of the list, the existing list is closed. At sides where
// this is the end, it is overwritten to its end.
return tr.step(new ReplaceAroundStep$1(start-(atStart?1:0),end+(atEnd?1:0),start+1,end-1,new Slice$1((atStart?Fragment$1.empty:Fragment$1.from(list.copy(Fragment$1.empty))).append(atEnd?Fragment$1.empty:Fragment$1.from(list.copy(Fragment$1.empty))),atStart?0:1,atEnd?0:1),atStart?0:1)),dispatch(tr.scrollIntoView()),!0}
/**
Create a command to sink the list item around the selection down
into an inner list.
*/function sinkListItem$1$1(itemType){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to,(node=>node.childCount>0&&node.firstChild.type==itemType));if(!range)return!1;let startIndex=range.startIndex;if(0==startIndex)return!1;let parent=range.parent,nodeBefore=parent.child(startIndex-1);if(nodeBefore.type!=itemType)return!1;if(dispatch){let nestedBefore=nodeBefore.lastChild&&nodeBefore.lastChild.type==parent.type,inner=Fragment$1.from(nestedBefore?itemType.create():null),slice=new Slice$1(Fragment$1.from(itemType.create(null,Fragment$1.from(parent.type.create(null,inner)))),nestedBefore?3:1,0),before=range.start,after=range.end;dispatch(state.tr.step(new ReplaceAroundStep$1(before-(nestedBefore?3:1),after,before,after,slice,1,!0)).scrollIntoView())}return!0}}function createChainableState$1(config){const{state:state,transaction:transaction}=config;let{selection:selection}=transaction,{doc:doc}=transaction,{storedMarks:storedMarks}=transaction;return{...state,apply:state.apply.bind(state),applyTransaction:state.applyTransaction.bind(state),filterTransaction:state.filterTransaction,plugins:state.plugins,schema:state.schema,reconfigure:state.reconfigure.bind(state),toJSON:state.toJSON.bind(state),get storedMarks(){return storedMarks},get selection(){return selection},get doc(){return doc},get tr(){return selection=transaction.selection,doc=transaction.doc,storedMarks=transaction.storedMarks,transaction}}}"undefined"!=typeof navigator?/Mac|iP(hone|[oa]d)/.test(navigator.platform):"undefined"!=typeof os&&os.platform&&os.platform();class CommandManager$1{constructor(props){this.editor=props.editor,this.rawCommands=this.editor.extensionManager.commands,this.customState=props.state}get hasCustomState(){return!!this.customState}get state(){return this.customState||this.editor.state}get commands(){const{rawCommands:rawCommands,editor:editor,state:state}=this,{view:view}=editor,{tr:tr}=state,props=this.buildProps(tr);return Object.fromEntries(Object.entries(rawCommands).map((([name,command])=>{const method=(...args)=>{const callback=command(...args)(props);return tr.getMeta("preventDispatch")||this.hasCustomState||view.dispatch(tr),callback};return[name,method]})))}get chain(){return()=>this.createChain()}get can(){return()=>this.createCan()}createChain(startTr,shouldDispatch=!0){const{rawCommands:rawCommands,editor:editor,state:state}=this,{view:view}=editor,callbacks=[],hasStartTransaction=!!startTr,tr=startTr||state.tr,run=()=>(hasStartTransaction||!shouldDispatch||tr.getMeta("preventDispatch")||this.hasCustomState||view.dispatch(tr),callbacks.every((callback=>!0===callback))),chain={...Object.fromEntries(Object.entries(rawCommands).map((([name,command])=>{const chainedCommand=(...args)=>{const props=this.buildProps(tr,shouldDispatch),callback=command(...args)(props);return callbacks.push(callback),chain};return[name,chainedCommand]}))),run:run};return chain}createCan(startTr){const{rawCommands:rawCommands,state:state}=this,dispatch=!1,tr=startTr||state.tr,props=this.buildProps(tr,dispatch),formattedCommands=Object.fromEntries(Object.entries(rawCommands).map((([name,command])=>[name,(...args)=>command(...args)({...props,dispatch:void 0})])));return{...formattedCommands,chain:()=>this.createChain(tr,dispatch)}}buildProps(tr,shouldDispatch=!0){const{rawCommands:rawCommands,editor:editor,state:state}=this,{view:view}=editor;state.storedMarks&&tr.setStoredMarks(state.storedMarks);const props={tr:tr,editor:editor,view:view,state:createChainableState$1({state:state,transaction:tr}),dispatch:shouldDispatch?()=>{}:void 0,chain:()=>this.createChain(tr),can:()=>this.createCan(tr),get commands(){return Object.fromEntries(Object.entries(rawCommands).map((([name,command])=>[name,(...args)=>command(...args)(props)])))}};return props}}function getExtensionField$1(extension,field,context){if(void 0===extension.config[field]&&extension.parent)return getExtensionField$1(extension.parent,field,context);if("function"===typeof extension.config[field]){const value=extension.config[field].bind({...context,parent:extension.parent?getExtensionField$1(extension.parent,field,context):null});return value}return extension.config[field]}function splitExtensions$1(extensions){const baseExtensions=extensions.filter((extension=>"extension"===extension.type)),nodeExtensions=extensions.filter((extension=>"node"===extension.type)),markExtensions=extensions.filter((extension=>"mark"===extension.type));return{baseExtensions:baseExtensions,nodeExtensions:nodeExtensions,markExtensions:markExtensions}}function getNodeType$1(nameOrType,schema){if("string"===typeof nameOrType){if(!schema.nodes[nameOrType])throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);return schema.nodes[nameOrType]}return nameOrType}function mergeAttributes$1(...objects){return objects.filter((item=>!!item)).reduce(((items,item)=>{const mergedAttributes={...items};return Object.entries(item).forEach((([key,value])=>{const exists=mergedAttributes[key];mergedAttributes[key]=exists?"class"===key?[mergedAttributes[key],value].join(" "):"style"===key?[mergedAttributes[key],value].join("; "):value:value})),mergedAttributes}),{})}function isFunction$2$1(value){return"function"===typeof value}
/**
 * Optionally calls `value` as a function.
 * Otherwise it is returned directly.
 * @param value Function or any value.
 * @param context Optional context to bind to function.
 * @param props Optional props to pass to function.
 */function callOrReturn$1(value,context=void 0,...props){return isFunction$2$1(value)?context?value.bind(context)(...props):value(...props):value}function isRegExp$1(value){return"[object RegExp]"===Object.prototype.toString.call(value)}class InputRule$1{constructor(config){this.find=config.find,this.handler=config.handler}}class PasteRule$1{constructor(config){this.find=config.find,this.handler=config.handler}}
// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts
function getType$1(value){return Object.prototype.toString.call(value).slice(8,-1)}function isPlainObject$1(value){return"Object"===getType$1(value)&&(value.constructor===Object&&Object.getPrototypeOf(value)===Object.prototype)}function mergeDeep$1(target,source){const output={...target};return isPlainObject$1(target)&&isPlainObject$1(source)&&Object.keys(source).forEach((key=>{isPlainObject$1(source[key])?key in target?output[key]=mergeDeep$1(target[key],source[key]):Object.assign(output,{[key]:source[key]}):Object.assign(output,{[key]:source[key]})})),output}class Extension$1{constructor(config={}){this.type="extension",this.name="extension",this.parent=null,this.child=null,this.config={name:this.name,defaultOptions:{}},this.config={...this.config,...config},this.name=this.config.name,config.defaultOptions,
// TODO: remove `addOptions` fallback
this.options=this.config.defaultOptions,this.config.addOptions&&(this.options=callOrReturn$1(getExtensionField$1(this,"addOptions",{name:this.name}))),this.storage=callOrReturn$1(getExtensionField$1(this,"addStorage",{name:this.name,options:this.options}))||{}}static create(config={}){return new Extension$1(config)}configure(options={}){
// return a new instance so we can use the same extension
// with different calls of `configure`
const extension=this.extend();return extension.options=mergeDeep$1(this.options,options),extension.storage=callOrReturn$1(getExtensionField$1(extension,"addStorage",{name:extension.name,options:extension.options})),extension}extend(extendedConfig={}){const extension=new Extension$1(extendedConfig);return extension.parent=this,this.child=extension,extension.name=extendedConfig.name?extendedConfig.name:extension.parent.name,extendedConfig.defaultOptions,extension.options=callOrReturn$1(getExtensionField$1(extension,"addOptions",{name:extension.name})),extension.storage=callOrReturn$1(getExtensionField$1(extension,"addStorage",{name:extension.name,options:extension.options})),extension}}function getTextBetween$1(startNode,range,options){const{from:from,to:to}=range,{blockSeparator:blockSeparator="\n\n",textSerializers:textSerializers={}}=options||{};let text="",separated=!0;return startNode.nodesBetween(from,to,((node,pos,parent,index)=>{var _a;const textSerializer=null===textSerializers||void 0===textSerializers?void 0:textSerializers[node.type.name];textSerializer?(node.isBlock&&!separated&&(text+=blockSeparator,separated=!0),parent&&(text+=textSerializer({node:node,pos:pos,parent:parent,index:index,range:range}))):node.isText?(text+=null===(_a=null===node||void 0===node?void 0:node.text)||void 0===_a?void 0:_a.slice(Math.max(from,pos)-pos,to-pos),// eslint-disable-line
separated=!1):node.isBlock&&!separated&&(text+=blockSeparator,separated=!0)})),text}function getTextSerializersFromSchema$1(schema){return Object.fromEntries(Object.entries(schema.nodes).filter((([,node])=>node.spec.toText)).map((([name,node])=>[name,node.spec.toText])))}Extension$1.create({name:"clipboardTextSerializer",addProseMirrorPlugins(){return[new Plugin$1({key:new PluginKey$1("clipboardTextSerializer"),props:{clipboardTextSerializer:()=>{const{editor:editor}=this,{state:state,schema:schema}=editor,{doc:doc,selection:selection}=state,{ranges:ranges}=selection,from=Math.min(...ranges.map((range=>range.$from.pos))),to=Math.max(...ranges.map((range=>range.$to.pos))),textSerializers=getTextSerializersFromSchema$1(schema),range={from:from,to:to};return getTextBetween$1(doc,range,{textSerializers:textSerializers})}}})]}});const blur$1=()=>({editor:editor,view:view})=>(requestAnimationFrame((()=>{var _a;editor.isDestroyed||(view.dom.blur(),
// Browsers should remove the caret on blur but safari does not.
// See: https://github.com/ueberdosis/tiptap/issues/2405
null===(_a=null===window||void 0===window?void 0:window.getSelection())||void 0===_a||_a.removeAllRanges())})),!0),clearContent$1=(emitUpdate=!1)=>({commands:commands})=>commands.setContent("",emitUpdate),clearNodes$1=()=>({state:state,tr:tr,dispatch:dispatch})=>{const{selection:selection}=tr,{ranges:ranges}=selection;return!dispatch||(ranges.forEach((({$from:$from,$to:$to})=>{state.doc.nodesBetween($from.pos,$to.pos,((node,pos)=>{if(node.type.isText)return;const{doc:doc,mapping:mapping}=tr,$mappedFrom=doc.resolve(mapping.map(pos)),$mappedTo=doc.resolve(mapping.map(pos+node.nodeSize)),nodeRange=$mappedFrom.blockRange($mappedTo);if(!nodeRange)return;const targetLiftDepth=liftTarget$1(nodeRange);if(node.type.isTextblock){const{defaultType:defaultType}=$mappedFrom.parent.contentMatchAt($mappedFrom.index());tr.setNodeMarkup(nodeRange.start,defaultType)}(targetLiftDepth||0===targetLiftDepth)&&tr.lift(nodeRange,targetLiftDepth)}))})),!0)},command$1=fn=>props=>fn(props),createParagraphNear$2=()=>({state:state,dispatch:dispatch})=>createParagraphNear$1$1(state,dispatch),deleteNode$1=typeOrName=>({tr:tr,state:state,dispatch:dispatch})=>{const type=getNodeType$1(typeOrName,state.schema),$pos=tr.selection.$anchor;for(let depth=$pos.depth;depth>0;depth-=1){const node=$pos.node(depth);if(node.type===type){if(dispatch){const from=$pos.before(depth),to=$pos.after(depth);tr.delete(from,to).scrollIntoView()}return!0}}return!1},deleteRange$2=range=>({tr:tr,dispatch:dispatch})=>{const{from:from,to:to}=range;return dispatch&&tr.delete(from,to),!0},deleteSelection$2=()=>({state:state,dispatch:dispatch})=>deleteSelection$1$1(state,dispatch),enter$1=()=>({commands:commands})=>commands.keyboardShortcut("Enter"),exitCode$2=()=>({state:state,dispatch:dispatch})=>exitCode$1$1(state,dispatch)
/**
 * Check if object1 includes object2
 * @param object1 Object
 * @param object2 Object
 */;function objectIncludes$1(object1,object2,options={strict:!0}){const keys=Object.keys(object2);return!keys.length||keys.every((key=>options.strict?object2[key]===object1[key]:isRegExp$1(object2[key])?object2[key].test(object1[key]):object2[key]===object1[key]))}function findMarkInSet$1(marks,type,attributes={}){return marks.find((item=>item.type===type&&objectIncludes$1(item.attrs,attributes)))}function isMarkInSet$1(marks,type,attributes={}){return!!findMarkInSet$1(marks,type,attributes)}function getMarkRange$1($pos,type,attributes={}){if(!$pos||!type)return;let start=$pos.parent.childAfter($pos.parentOffset);if($pos.parentOffset===start.offset&&0!==start.offset&&(start=$pos.parent.childBefore($pos.parentOffset)),!start.node)return;const mark=findMarkInSet$1([...start.node.marks],type,attributes);if(!mark)return;let startIndex=start.index,startPos=$pos.start()+start.offset,endIndex=startIndex+1,endPos=startPos+start.node.nodeSize;findMarkInSet$1([...start.node.marks],type,attributes);while(startIndex>0&&mark.isInSet($pos.parent.child(startIndex-1).marks))startIndex-=1,startPos-=$pos.parent.child(startIndex).nodeSize;while(endIndex<$pos.parent.childCount&&isMarkInSet$1([...$pos.parent.child(endIndex).marks],type,attributes))endPos+=$pos.parent.child(endIndex).nodeSize,endIndex+=1;return{from:startPos,to:endPos}}function getMarkType$1(nameOrType,schema){if("string"===typeof nameOrType){if(!schema.marks[nameOrType])throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);return schema.marks[nameOrType]}return nameOrType}const extendMarkRange$1=(typeOrName,attributes={})=>({tr:tr,state:state,dispatch:dispatch})=>{const type=getMarkType$1(typeOrName,state.schema),{doc:doc,selection:selection}=tr,{$from:$from,from:from,to:to}=selection;if(dispatch){const range=getMarkRange$1($from,type,attributes);if(range&&range.from<=from&&range.to>=to){const newSelection=TextSelection$1.create(doc,range.from,range.to);tr.setSelection(newSelection)}}return!0},first$1=commands=>props=>{const items="function"===typeof commands?commands(props):commands;for(let i=0;i<items.length;i+=1)if(items[i](props))return!0;return!1};function isTextSelection$1(value){return value instanceof TextSelection$1}function minMax$1(value=0,min=0,max=0){return Math.min(Math.max(value,min),max)}function resolveFocusPosition$1(doc,position=null){if(!position)return null;const selectionAtStart=Selection$1.atStart(doc),selectionAtEnd=Selection$1.atEnd(doc);if("start"===position||!0===position)return selectionAtStart;if("end"===position)return selectionAtEnd;const minPos=selectionAtStart.from,maxPos=selectionAtEnd.to;return"all"===position?TextSelection$1.create(doc,minMax$1(0,minPos,maxPos),minMax$1(doc.content.size,minPos,maxPos)):TextSelection$1.create(doc,minMax$1(position,minPos,maxPos),minMax$1(position,minPos,maxPos))}function isiOS$1(){return["iPad Simulator","iPhone Simulator","iPod Simulator","iPad","iPhone","iPod"].includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document}const focus$1=(position=null,options={})=>({editor:editor,view:view,tr:tr,dispatch:dispatch})=>{options={scrollIntoView:!0,...options};const delayedFocus=()=>{
// focus within `requestAnimationFrame` breaks focus on iOS
// so we have to call this
isiOS$1()&&view.dom.focus(),
// For React we have to focus asynchronously. Otherwise wild things happen.
// see: https://github.com/ueberdosis/tiptap/issues/1520
requestAnimationFrame((()=>{editor.isDestroyed||(view.focus(),(null===options||void 0===options?void 0:options.scrollIntoView)&&editor.commands.scrollIntoView())}))};if(view.hasFocus()&&null===position||!1===position)return!0;
// we don’t try to resolve a NodeSelection or CellSelection
if(dispatch&&null===position&&!isTextSelection$1(editor.state.selection))return delayedFocus(),!0;
// pass through tr.doc instead of editor.state.doc
// since transactions could change the editors state before this command has been run
const selection=resolveFocusPosition$1(tr.doc,position)||editor.state.selection,isSameSelection=editor.state.selection.eq(selection);return dispatch&&(isSameSelection||tr.setSelection(selection),
// `tr.setSelection` resets the stored marks
// so we’ll restore them if the selection is the same as before
isSameSelection&&tr.storedMarks&&tr.setStoredMarks(tr.storedMarks),delayedFocus()),!0},forEach$1=(items,fn)=>props=>items.every(((item,index)=>fn(item,{...props,index:index}))),insertContent$1=(value,options)=>({tr:tr,commands:commands})=>commands.insertContentAt({from:tr.selection.from,to:tr.selection.to},value,options);function elementFromString$1(value){
// add a wrapper to preserve leading and trailing whitespace
const wrappedValue=`<body>${value}</body>`;return(new window.DOMParser).parseFromString(wrappedValue,"text/html").body}function createNodeFromContent$1(content,schema,options){if(options={slice:!0,parseOptions:{},...options},"object"===typeof content&&null!==content)try{return Array.isArray(content)?Fragment$1.fromArray(content.map((item=>schema.nodeFromJSON(item)))):schema.nodeFromJSON(content)}catch(error){return createNodeFromContent$1("",schema,options)}if("string"===typeof content){const parser=DOMParser$1$1.fromSchema(schema);return options.slice?parser.parseSlice(elementFromString$1(content),options.parseOptions).content:parser.parse(elementFromString$1(content),options.parseOptions)}return createNodeFromContent$1("",schema,options)}
// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466
function selectionToInsertionEnd$2(tr,startLen,bias){const last=tr.steps.length-1;if(last<startLen)return;const step=tr.steps[last];if(!(step instanceof ReplaceStep$1||step instanceof ReplaceAroundStep$1))return;const map=tr.mapping.maps[last];let end=0;map.forEach(((_from,_to,_newFrom,newTo)=>{0===end&&(end=newTo)})),tr.setSelection(Selection$1.near(tr.doc.resolve(end),bias))}const isFragment$1=nodeOrFragment=>nodeOrFragment.toString().startsWith("<"),insertContentAt$1=(position,value,options)=>({tr:tr,dispatch:dispatch,editor:editor})=>{if(dispatch){options={parseOptions:{},updateSelection:!0,...options};const content=createNodeFromContent$1(value,editor.schema,{parseOptions:{preserveWhitespace:"full",...options.parseOptions}});
// don’t dispatch an empty fragment because this can lead to strange errors
if("<>"===content.toString())return!0;let{from:from,to:to}="number"===typeof position?{from:position,to:position}:position,isOnlyTextContent=!0,isOnlyBlockContent=!0;const nodes=isFragment$1(content)?content:[content];
// check if we can replace the wrapping node by
// the newly inserted content
// example:
// replace an empty paragraph by an inserted image
// instead of inserting the image below the paragraph
if(nodes.forEach((node=>{
// check if added node is valid
node.check(),isOnlyTextContent=!!isOnlyTextContent&&(node.isText&&0===node.marks.length),isOnlyBlockContent=!!isOnlyBlockContent&&node.isBlock})),from===to&&isOnlyBlockContent){const{parent:parent}=tr.doc.resolve(from),isEmptyTextBlock=parent.isTextblock&&!parent.type.spec.code&&!parent.childCount;isEmptyTextBlock&&(from-=1,to+=1)}
// if there is only plain text we have to use `insertText`
// because this will keep the current marks
isOnlyTextContent?tr.insertText(value,from,to):tr.replaceWith(from,to,content),
// set cursor at end of inserted content
options.updateSelection&&selectionToInsertionEnd$2(tr,tr.steps.length-1,-1)}return!0},joinBackward$2=()=>({state:state,dispatch:dispatch})=>joinBackward$1$1(state,dispatch),joinForward$2=()=>({state:state,dispatch:dispatch})=>joinForward$1$1(state,dispatch);function isMacOS$1(){return"undefined"!==typeof navigator&&/Mac/.test(navigator.platform)}function normalizeKeyName$2(name){const parts=name.split(/-(?!$)/);let alt,ctrl,shift,meta,result=parts[parts.length-1];"Space"===result&&(result=" ");for(let i=0;i<parts.length-1;i+=1){const mod=parts[i];if(/^(cmd|meta|m)$/i.test(mod))meta=!0;else if(/^a(lt)?$/i.test(mod))alt=!0;else if(/^(c|ctrl|control)$/i.test(mod))ctrl=!0;else if(/^s(hift)?$/i.test(mod))shift=!0;else{if(!/^mod$/i.test(mod))throw new Error(`Unrecognized modifier name: ${mod}`);isiOS$1()||isMacOS$1()?meta=!0:ctrl=!0}}return alt&&(result=`Alt-${result}`),ctrl&&(result=`Ctrl-${result}`),meta&&(result=`Meta-${result}`),shift&&(result=`Shift-${result}`),result}const keyboardShortcut$1=name=>({editor:editor,view:view,tr:tr,dispatch:dispatch})=>{const keys=normalizeKeyName$2(name).split(/-(?!$)/),key=keys.find((item=>!["Alt","Ctrl","Meta","Shift"].includes(item))),event=new KeyboardEvent("keydown",{key:"Space"===key?" ":key,altKey:keys.includes("Alt"),ctrlKey:keys.includes("Ctrl"),metaKey:keys.includes("Meta"),shiftKey:keys.includes("Shift"),bubbles:!0,cancelable:!0}),capturedTransaction=editor.captureTransaction((()=>{view.someProp("handleKeyDown",(f=>f(view,event)))}));return null===capturedTransaction||void 0===capturedTransaction||capturedTransaction.steps.forEach((step=>{const newStep=step.map(tr.mapping);newStep&&dispatch&&tr.maybeStep(newStep)})),!0};function isNodeActive$1(state,typeOrName,attributes={}){const{from:from,to:to,empty:empty}=state.selection,type=typeOrName?getNodeType$1(typeOrName,state.schema):null,nodeRanges=[];state.doc.nodesBetween(from,to,((node,pos)=>{if(node.isText)return;const relativeFrom=Math.max(from,pos),relativeTo=Math.min(to,pos+node.nodeSize);nodeRanges.push({node:node,from:relativeFrom,to:relativeTo})}));const selectionRange=to-from,matchedNodeRanges=nodeRanges.filter((nodeRange=>!type||type.name===nodeRange.node.type.name)).filter((nodeRange=>objectIncludes$1(nodeRange.node.attrs,attributes,{strict:!1})));if(empty)return!!matchedNodeRanges.length;const range=matchedNodeRanges.reduce(((sum,nodeRange)=>sum+nodeRange.to-nodeRange.from),0);return range>=selectionRange}const lift$3=(typeOrName,attributes={})=>({state:state,dispatch:dispatch})=>{const type=getNodeType$1(typeOrName,state.schema),isActive=isNodeActive$1(state,type,attributes);return!!isActive&&lift$1$1(state,dispatch)},liftEmptyBlock$2=()=>({state:state,dispatch:dispatch})=>liftEmptyBlock$1$1(state,dispatch),liftListItem$2=typeOrName=>({state:state,dispatch:dispatch})=>{const type=getNodeType$1(typeOrName,state.schema);return liftListItem$1$1(type)(state,dispatch)},newlineInCode$2=()=>({state:state,dispatch:dispatch})=>newlineInCode$1$1(state,dispatch);function getSchemaTypeNameByName$1(name,schema){return schema.nodes[name]?"node":schema.marks[name]?"mark":null}
/**
 * Remove a property or an array of properties from an object
 * @param obj Object
 * @param key Key to remove
 */function deleteProps$1(obj,propOrProps){const props="string"===typeof propOrProps?[propOrProps]:propOrProps;return Object.keys(obj).reduce(((newObj,prop)=>(props.includes(prop)||(newObj[prop]=obj[prop]),newObj)),{})}const resetAttributes$1=(typeOrName,attributes)=>({tr:tr,state:state,dispatch:dispatch})=>{let nodeType=null,markType=null;const schemaType=getSchemaTypeNameByName$1("string"===typeof typeOrName?typeOrName:typeOrName.name,state.schema);return!!schemaType&&("node"===schemaType&&(nodeType=getNodeType$1(typeOrName,state.schema)),"mark"===schemaType&&(markType=getMarkType$1(typeOrName,state.schema)),dispatch&&tr.selection.ranges.forEach((range=>{state.doc.nodesBetween(range.$from.pos,range.$to.pos,((node,pos)=>{nodeType&&nodeType===node.type&&tr.setNodeMarkup(pos,void 0,deleteProps$1(node.attrs,attributes)),markType&&node.marks.length&&node.marks.forEach((mark=>{markType===mark.type&&tr.addMark(pos,pos+node.nodeSize,markType.create(deleteProps$1(mark.attrs,attributes)))}))}))})),!0)},scrollIntoView$1=()=>({tr:tr,dispatch:dispatch})=>(dispatch&&tr.scrollIntoView(),!0),selectAll$1=()=>({tr:tr,commands:commands})=>commands.setTextSelection({from:0,to:tr.doc.content.size}),selectNodeBackward$2=()=>({state:state,dispatch:dispatch})=>selectNodeBackward$1$1(state,dispatch),selectNodeForward$2=()=>({state:state,dispatch:dispatch})=>selectNodeForward$1$1(state,dispatch),selectParentNode$2=()=>({state:state,dispatch:dispatch})=>selectParentNode$1$1(state,dispatch)
// @ts-ignore
,selectTextblockEnd$2=()=>({state:state,dispatch:dispatch})=>selectTextblockEnd$1$1(state,dispatch)
// @ts-ignore
,selectTextblockStart$2=()=>({state:state,dispatch:dispatch})=>selectTextblockStart$1$1(state,dispatch);function createDocument$1(content,schema,parseOptions={}){return createNodeFromContent$1(content,schema,{slice:!1,parseOptions:parseOptions})}const setContent$1$1=(content,emitUpdate=!1,parseOptions={})=>({tr:tr,editor:editor,dispatch:dispatch})=>{const{doc:doc}=tr,document=createDocument$1(content,editor.schema,parseOptions);return dispatch&&tr.replaceWith(0,doc.content.size,document).setMeta("preventUpdate",!emitUpdate),!0};function getMarkAttributes$1(state,typeOrName){const type=getMarkType$1(typeOrName,state.schema),{from:from,to:to,empty:empty}=state.selection,marks=[];empty?(state.storedMarks&&marks.push(...state.storedMarks),marks.push(...state.selection.$head.marks())):state.doc.nodesBetween(from,to,(node=>{marks.push(...node.marks)}));const mark=marks.find((markItem=>markItem.type.name===type.name));return mark?{...mark.attrs}:{}}const setMark$1=(typeOrName,attributes={})=>({tr:tr,state:state,dispatch:dispatch})=>{const{selection:selection}=tr,{empty:empty,ranges:ranges}=selection,type=getMarkType$1(typeOrName,state.schema);if(dispatch)if(empty){const oldAttributes=getMarkAttributes$1(state,type);tr.addStoredMark(type.create({...oldAttributes,...attributes}))}else ranges.forEach((range=>{const from=range.$from.pos,to=range.$to.pos;state.doc.nodesBetween(from,to,((node,pos)=>{const trimmedFrom=Math.max(pos,from),trimmedTo=Math.min(pos+node.nodeSize,to),someHasMark=node.marks.find((mark=>mark.type===type));
// if there is already a mark of this type
// we know that we have to merge its attributes
// otherwise we add a fresh new mark
someHasMark?node.marks.forEach((mark=>{type===mark.type&&tr.addMark(trimmedFrom,trimmedTo,type.create({...mark.attrs,...attributes}))})):tr.addMark(trimmedFrom,trimmedTo,type.create(attributes))}))}));return!0},setMeta$1=(key,value)=>({tr:tr})=>(tr.setMeta(key,value),!0),setNode$1=(typeOrName,attributes={})=>({state:state,dispatch:dispatch,chain:chain})=>{const type=getNodeType$1(typeOrName,state.schema);
// TODO: use a fallback like insertContent?
return!!type.isTextblock&&chain().command((({commands:commands})=>{const canSetBlock=setBlockType$2(type,attributes)(state);return!!canSetBlock||commands.clearNodes()})).command((({state:updatedState})=>setBlockType$2(type,attributes)(updatedState,dispatch))).run()},setNodeSelection$1=position=>({tr:tr,dispatch:dispatch})=>{if(dispatch){const{doc:doc}=tr,from=minMax$1(position,0,doc.content.size),selection=NodeSelection$1.create(doc,from);tr.setSelection(selection)}return!0},setTextSelection$1=position=>({tr:tr,dispatch:dispatch})=>{if(dispatch){const{doc:doc}=tr,{from:from,to:to}="number"===typeof position?{from:position,to:position}:position,minPos=TextSelection$1.atStart(doc).from,maxPos=TextSelection$1.atEnd(doc).to,resolvedFrom=minMax$1(from,minPos,maxPos),resolvedEnd=minMax$1(to,minPos,maxPos),selection=TextSelection$1.create(doc,resolvedFrom,resolvedEnd);tr.setSelection(selection)}return!0},sinkListItem$2=typeOrName=>({state:state,dispatch:dispatch})=>{const type=getNodeType$1(typeOrName,state.schema);return sinkListItem$1$1(type)(state,dispatch)};function defaultBlockAt$2(match){for(let i=0;i<match.edgeCount;i+=1){const{type:type}=match.edge(i);if(type.isTextblock&&!type.hasRequiredAttrs())return type}return null}function getSplittedAttributes$1(extensionAttributes,typeName,attributes){return Object.fromEntries(Object.entries(attributes).filter((([name])=>{const extensionAttribute=extensionAttributes.find((item=>item.type===typeName&&item.name===name));return!!extensionAttribute&&extensionAttribute.attribute.keepOnSplit})))}function ensureMarks$1(state,splittableMarks){const marks=state.storedMarks||state.selection.$to.parentOffset&&state.selection.$from.marks();if(marks){const filteredMarks=marks.filter((mark=>null===splittableMarks||void 0===splittableMarks?void 0:splittableMarks.includes(mark.type.name)));state.tr.ensureMarks(filteredMarks)}}const splitBlock$1=({keepMarks:keepMarks=!0}={})=>({tr:tr,state:state,dispatch:dispatch,editor:editor})=>{const{selection:selection,doc:doc}=tr,{$from:$from,$to:$to}=selection,extensionAttributes=editor.extensionManager.attributes,newAttributes=getSplittedAttributes$1(extensionAttributes,$from.node().type.name,$from.node().attrs);if(selection instanceof NodeSelection$1&&selection.node.isBlock)return!(!$from.parentOffset||!canSplit$1(doc,$from.pos))&&(dispatch&&(keepMarks&&ensureMarks$1(state,editor.extensionManager.splittableMarks),tr.split($from.pos).scrollIntoView()),!0);if(!$from.parent.isBlock)return!1;if(dispatch){const atEnd=$to.parentOffset===$to.parent.content.size;selection instanceof TextSelection$1&&tr.deleteSelection();const deflt=0===$from.depth?void 0:defaultBlockAt$2($from.node(-1).contentMatchAt($from.indexAfter(-1)));let types=atEnd&&deflt?[{type:deflt,attrs:newAttributes}]:void 0,can=canSplit$1(tr.doc,tr.mapping.map($from.pos),1,types);if(types||can||!canSplit$1(tr.doc,tr.mapping.map($from.pos),1,deflt?[{type:deflt}]:void 0)||(can=!0,types=deflt?[{type:deflt,attrs:newAttributes}]:void 0),can&&(tr.split(tr.mapping.map($from.pos),1,types),deflt&&!atEnd&&!$from.parentOffset&&$from.parent.type!==deflt)){const first=tr.mapping.map($from.before()),$first=tr.doc.resolve(first);$from.node(-1).canReplaceWith($first.index(),$first.index()+1,deflt)&&tr.setNodeMarkup(tr.mapping.map($from.before()),deflt)}keepMarks&&ensureMarks$1(state,editor.extensionManager.splittableMarks),tr.scrollIntoView()}return!0},splitListItem$1=typeOrName=>({tr:tr,state:state,dispatch:dispatch,editor:editor})=>{var _a;const type=getNodeType$1(typeOrName,state.schema),{$from:$from,$to:$to}=state.selection,node=state.selection.node;if(node&&node.isBlock||$from.depth<2||!$from.sameParent($to))return!1;const grandParent=$from.node(-1);if(grandParent.type!==type)return!1;const extensionAttributes=editor.extensionManager.attributes;if(0===$from.parent.content.size&&$from.node(-1).childCount===$from.indexAfter(-1)){
// In an empty block. If this is a nested list, the wrapping
// list item should be split. Otherwise, bail out and let next
// command handle lifting.
if(2===$from.depth||$from.node(-3).type!==type||$from.index(-2)!==$from.node(-2).childCount-1)return!1;if(dispatch){let wrap=Fragment$1.empty;
// eslint-disable-next-line
const depthBefore=$from.index(-1)?1:$from.index(-2)?2:3;
// Build a fragment containing empty versions of the structure
// from the outer list item to the parent node of the cursor
for(let d=$from.depth-depthBefore;d>=$from.depth-3;d-=1)wrap=Fragment$1.from($from.node(d).copy(wrap));
// eslint-disable-next-line
const depthAfter=$from.indexAfter(-1)<$from.node(-2).childCount?1:$from.indexAfter(-2)<$from.node(-3).childCount?2:3,newNextTypeAttributes=getSplittedAttributes$1(extensionAttributes,$from.node().type.name,$from.node().attrs),nextType=(null===(_a=type.contentMatch.defaultType)||void 0===_a?void 0:_a.createAndFill(newNextTypeAttributes))||void 0;
// Add a second list item with an empty default start node
wrap=wrap.append(Fragment$1.from(type.createAndFill(null,nextType)||void 0));const start=$from.before($from.depth-(depthBefore-1));tr.replace(start,$from.after(-depthAfter),new Slice$1(wrap,4-depthBefore,0));let sel=-1;tr.doc.nodesBetween(start,tr.doc.content.size,((n,pos)=>{if(sel>-1)return!1;n.isTextblock&&0===n.content.size&&(sel=pos+1)})),sel>-1&&tr.setSelection(TextSelection$1.near(tr.doc.resolve(sel))),tr.scrollIntoView()}return!0}const nextType=$to.pos===$from.end()?grandParent.contentMatchAt(0).defaultType:null,newTypeAttributes=getSplittedAttributes$1(extensionAttributes,grandParent.type.name,grandParent.attrs),newNextTypeAttributes=getSplittedAttributes$1(extensionAttributes,$from.node().type.name,$from.node().attrs);tr.delete($from.pos,$to.pos);const types=nextType?[{type:type,attrs:newTypeAttributes},{type:nextType,attrs:newNextTypeAttributes}]:[{type:type,attrs:newTypeAttributes}];return!!canSplit$1(tr.doc,$from.pos,2)&&(dispatch&&tr.split($from.pos,2,types).scrollIntoView(),!0)};function findParentNodeClosestToPos$1($pos,predicate){for(let i=$pos.depth;i>0;i-=1){const node=$pos.node(i);if(predicate(node))return{pos:i>0?$pos.before(i):0,start:$pos.start(i),depth:i,node:node}}}function findParentNode$1(predicate){return selection=>findParentNodeClosestToPos$1(selection.$from,predicate)}function isList$1(name,extensions){const{nodeExtensions:nodeExtensions}=splitExtensions$1(extensions),extension=nodeExtensions.find((item=>item.name===name));if(!extension)return!1;const context={name:extension.name,options:extension.options,storage:extension.storage},group=callOrReturn$1(getExtensionField$1(extension,"group",context));return"string"===typeof group&&group.split(" ").includes("list")}const joinListBackwards$1=(tr,listType)=>{const list=findParentNode$1((node=>node.type===listType))(tr.selection);if(!list)return!0;const before=tr.doc.resolve(Math.max(0,list.pos-1)).before(list.depth);if(void 0===before)return!0;const nodeBefore=tr.doc.nodeAt(before),canJoinBackwards=list.node.type===(null===nodeBefore||void 0===nodeBefore?void 0:nodeBefore.type)&&canJoin$1(tr.doc,list.pos);return!canJoinBackwards||(tr.join(list.pos),!0)},joinListForwards$1=(tr,listType)=>{const list=findParentNode$1((node=>node.type===listType))(tr.selection);if(!list)return!0;const after=tr.doc.resolve(list.start).after(list.depth);if(void 0===after)return!0;const nodeAfter=tr.doc.nodeAt(after),canJoinForwards=list.node.type===(null===nodeAfter||void 0===nodeAfter?void 0:nodeAfter.type)&&canJoin$1(tr.doc,after);return!canJoinForwards||(tr.join(after),!0)},toggleList$1=(listTypeOrName,itemTypeOrName)=>({editor:editor,tr:tr,state:state,dispatch:dispatch,chain:chain,commands:commands,can:can})=>{const{extensions:extensions}=editor.extensionManager,listType=getNodeType$1(listTypeOrName,state.schema),itemType=getNodeType$1(itemTypeOrName,state.schema),{selection:selection}=state,{$from:$from,$to:$to}=selection,range=$from.blockRange($to);if(!range)return!1;const parentList=findParentNode$1((node=>isList$1(node.type.name,extensions)))(selection);if(range.depth>=1&&parentList&&range.depth-parentList.depth<=1){
// remove list
if(parentList.node.type===listType)return commands.liftListItem(itemType);
// change list type
if(isList$1(parentList.node.type.name,extensions)&&listType.validContent(parentList.node.content)&&dispatch)return chain().command((()=>(tr.setNodeMarkup(parentList.pos,listType),!0))).command((()=>joinListBackwards$1(tr,listType))).command((()=>joinListForwards$1(tr,listType))).run()}return chain().command((()=>{const canWrapInList=can().wrapInList(listType);return!!canWrapInList||commands.clearNodes()})).wrapInList(listType).command((()=>joinListBackwards$1(tr,listType))).command((()=>joinListForwards$1(tr,listType))).run()};function isMarkActive$1(state,typeOrName,attributes={}){const{empty:empty,ranges:ranges}=state.selection,type=typeOrName?getMarkType$1(typeOrName,state.schema):null;if(empty)return!!(state.storedMarks||state.selection.$from.marks()).filter((mark=>!type||type.name===mark.type.name)).find((mark=>objectIncludes$1(mark.attrs,attributes,{strict:!1})));let selectionRange=0;const markRanges=[];if(ranges.forEach((({$from:$from,$to:$to})=>{const from=$from.pos,to=$to.pos;state.doc.nodesBetween(from,to,((node,pos)=>{if(!node.isText&&!node.marks.length)return;const relativeFrom=Math.max(from,pos),relativeTo=Math.min(to,pos+node.nodeSize),range=relativeTo-relativeFrom;selectionRange+=range,markRanges.push(...node.marks.map((mark=>({mark:mark,from:relativeFrom,to:relativeTo}))))}))})),0===selectionRange)return!1;
// calculate range of matched mark
const matchedRange=markRanges.filter((markRange=>!type||type.name===markRange.mark.type.name)).filter((markRange=>objectIncludes$1(markRange.mark.attrs,attributes,{strict:!1}))).reduce(((sum,markRange)=>sum+markRange.to-markRange.from),0),excludedRange=markRanges.filter((markRange=>!type||markRange.mark.type!==type&&markRange.mark.type.excludes(type))).reduce(((sum,markRange)=>sum+markRange.to-markRange.from),0),range=matchedRange>0?matchedRange+excludedRange:matchedRange;
// calculate range of marks that excludes the searched mark
// for example `code` doesn’t allow any other marks
return range>=selectionRange}const toggleMark$1=(typeOrName,attributes={},options={})=>({state:state,commands:commands})=>{const{extendEmptyMarkRange:extendEmptyMarkRange=!1}=options,type=getMarkType$1(typeOrName,state.schema),isActive=isMarkActive$1(state,type,attributes);return isActive?commands.unsetMark(type,{extendEmptyMarkRange:extendEmptyMarkRange}):commands.setMark(type,attributes)},toggleNode$1=(typeOrName,toggleTypeOrName,attributes={})=>({state:state,commands:commands})=>{const type=getNodeType$1(typeOrName,state.schema),toggleType=getNodeType$1(toggleTypeOrName,state.schema),isActive=isNodeActive$1(state,type,attributes);return isActive?commands.setNode(toggleType):commands.setNode(type,attributes)},toggleWrap$1=(typeOrName,attributes={})=>({state:state,commands:commands})=>{const type=getNodeType$1(typeOrName,state.schema),isActive=isNodeActive$1(state,type,attributes);return isActive?commands.lift(type):commands.wrapIn(type,attributes)},undoInputRule$1=()=>({state:state,dispatch:dispatch})=>{const plugins=state.plugins;for(let i=0;i<plugins.length;i+=1){const plugin=plugins[i];let undoable;
// @ts-ignore
// eslint-disable-next-line
if(plugin.spec.isInputRules&&(undoable=plugin.getState(state))){if(dispatch){const tr=state.tr,toUndo=undoable.transform;for(let j=toUndo.steps.length-1;j>=0;j-=1)tr.step(toUndo.steps[j].invert(toUndo.docs[j]));if(undoable.text){const marks=tr.doc.resolve(undoable.from).marks();tr.replaceWith(undoable.from,undoable.to,state.schema.text(undoable.text,marks))}else tr.delete(undoable.from,undoable.to)}return!0}}return!1},unsetAllMarks$1=()=>({tr:tr,dispatch:dispatch})=>{const{selection:selection}=tr,{empty:empty,ranges:ranges}=selection;return empty||dispatch&&ranges.forEach((range=>{tr.removeMark(range.$from.pos,range.$to.pos)})),!0},unsetMark$1=(typeOrName,options={})=>({tr:tr,state:state,dispatch:dispatch})=>{var _a;const{extendEmptyMarkRange:extendEmptyMarkRange=!1}=options,{selection:selection}=tr,type=getMarkType$1(typeOrName,state.schema),{$from:$from,empty:empty,ranges:ranges}=selection;if(!dispatch)return!0;if(empty&&extendEmptyMarkRange){let{from:from,to:to}=selection;const attrs=null===(_a=$from.marks().find((mark=>mark.type===type)))||void 0===_a?void 0:_a.attrs,range=getMarkRange$1($from,type,attrs);range&&(from=range.from,to=range.to),tr.removeMark(from,to,type)}else ranges.forEach((range=>{tr.removeMark(range.$from.pos,range.$to.pos,type)}));return tr.removeStoredMark(type),!0},updateAttributes$1=(typeOrName,attributes={})=>({tr:tr,state:state,dispatch:dispatch})=>{let nodeType=null,markType=null;const schemaType=getSchemaTypeNameByName$1("string"===typeof typeOrName?typeOrName:typeOrName.name,state.schema);return!!schemaType&&("node"===schemaType&&(nodeType=getNodeType$1(typeOrName,state.schema)),"mark"===schemaType&&(markType=getMarkType$1(typeOrName,state.schema)),dispatch&&tr.selection.ranges.forEach((range=>{const from=range.$from.pos,to=range.$to.pos;state.doc.nodesBetween(from,to,((node,pos)=>{nodeType&&nodeType===node.type&&tr.setNodeMarkup(pos,void 0,{...node.attrs,...attributes}),markType&&node.marks.length&&node.marks.forEach((mark=>{if(markType===mark.type){const trimmedFrom=Math.max(pos,from),trimmedTo=Math.min(pos+node.nodeSize,to);tr.addMark(trimmedFrom,trimmedTo,markType.create({...mark.attrs,...attributes}))}}))}))})),!0)},wrapIn$2=(typeOrName,attributes={})=>({state:state,dispatch:dispatch})=>{const type=getNodeType$1(typeOrName,state.schema);return wrapIn$1$1(type,attributes)(state,dispatch)},wrapInList$2=(typeOrName,attributes={})=>({state:state,dispatch:dispatch})=>{const type=getNodeType$1(typeOrName,state.schema);return wrapInList$1$1(type,attributes)(state,dispatch)};var commands$1=Object.freeze({__proto__:null,blur:blur$1,clearContent:clearContent$1,clearNodes:clearNodes$1,command:command$1,createParagraphNear:createParagraphNear$2,deleteNode:deleteNode$1,deleteRange:deleteRange$2,deleteSelection:deleteSelection$2,enter:enter$1,exitCode:exitCode$2,extendMarkRange:extendMarkRange$1,first:first$1,focus:focus$1,forEach:forEach$1,insertContent:insertContent$1,insertContentAt:insertContentAt$1,joinBackward:joinBackward$2,joinForward:joinForward$2,keyboardShortcut:keyboardShortcut$1,lift:lift$3,liftEmptyBlock:liftEmptyBlock$2,liftListItem:liftListItem$2,newlineInCode:newlineInCode$2,resetAttributes:resetAttributes$1,scrollIntoView:scrollIntoView$1,selectAll:selectAll$1,selectNodeBackward:selectNodeBackward$2,selectNodeForward:selectNodeForward$2,selectParentNode:selectParentNode$2,selectTextblockEnd:selectTextblockEnd$2,selectTextblockStart:selectTextblockStart$2,setContent:setContent$1$1,setMark:setMark$1,setMeta:setMeta$1,setNode:setNode$1,setNodeSelection:setNodeSelection$1,setTextSelection:setTextSelection$1,sinkListItem:sinkListItem$2,splitBlock:splitBlock$1,splitListItem:splitListItem$1,toggleList:toggleList$1,toggleMark:toggleMark$1,toggleNode:toggleNode$1,toggleWrap:toggleWrap$1,undoInputRule:undoInputRule$1,unsetAllMarks:unsetAllMarks$1,unsetMark:unsetMark$1,updateAttributes:updateAttributes$1,wrapIn:wrapIn$2,wrapInList:wrapInList$2});function getNodeAttributes$1(state,typeOrName){const type=getNodeType$1(typeOrName,state.schema),{from:from,to:to}=state.selection,nodes=[];state.doc.nodesBetween(from,to,(node=>{nodes.push(node)}));const node=nodes.reverse().find((nodeItem=>nodeItem.type.name===type.name));return node?{...node.attrs}:{}}function getAttributes$1(state,typeOrName){const schemaType=getSchemaTypeNameByName$1("string"===typeof typeOrName?typeOrName:typeOrName.name,state.schema);return"node"===schemaType?getNodeAttributes$1(state,typeOrName):"mark"===schemaType?getMarkAttributes$1(state,typeOrName):{}}
/**
 * Returns a new `Transform` based on all steps of the passed transactions.
 */function combineTransactionSteps$1(oldDoc,transactions){const transform=new Transform$1(oldDoc);return transactions.forEach((transaction=>{transaction.steps.forEach((step=>{transform.step(step)}))})),transform}
/**
 * Same as `findChildren` but searches only within a `range`.
 */function findChildrenInRange$1(node,range,predicate){const nodesWithPos=[];
// if (range.from === range.to) {
//   const nodeAt = node.nodeAt(range.from)
//   if (nodeAt) {
//     nodesWithPos.push({
//       node: nodeAt,
//       pos: range.from,
//     })
//   }
// }
return node.nodesBetween(range.from,range.to,((child,pos)=>{predicate(child)&&nodesWithPos.push({node:child,pos:pos})})),nodesWithPos}
/**
 * Removes duplicated values within an array.
 * Supports numbers, strings and objects.
 */function removeDuplicates$1(array,by=JSON.stringify){const seen={};return array.filter((item=>{const key=by(item);return!Object.prototype.hasOwnProperty.call(seen,key)&&(seen[key]=!0)}))}
/**
 * Removes duplicated ranges and ranges that are
 * fully captured by other ranges.
 */function simplifyChangedRanges$1(changes){const uniqueChanges=removeDuplicates$1(changes);return 1===uniqueChanges.length?uniqueChanges:uniqueChanges.filter(((change,index)=>{const rest=uniqueChanges.filter(((_,i)=>i!==index));return!rest.some((otherChange=>change.oldRange.from>=otherChange.oldRange.from&&change.oldRange.to<=otherChange.oldRange.to&&change.newRange.from>=otherChange.newRange.from&&change.newRange.to<=otherChange.newRange.to))}))}
/**
 * Returns a list of changed ranges
 * based on the first and last state of all steps.
 */function getChangedRanges$1(transform){const{mapping:mapping,steps:steps}=transform,changes=[];return mapping.maps.forEach(((stepMap,index)=>{const ranges=[];
// This accounts for step changes where no range was actually altered
// e.g. when setting a mark, node attribute, etc.
// @ts-ignore
if(stepMap.ranges.length)stepMap.forEach(((from,to)=>{ranges.push({from:from,to:to})}));else{const{from:from,to:to}=steps[index];if(void 0===from||void 0===to)return;ranges.push({from:from,to:to})}ranges.forEach((({from:from,to:to})=>{const newStart=mapping.slice(index).map(from,-1),newEnd=mapping.slice(index).map(to),oldStart=mapping.invert().map(newStart,-1),oldEnd=mapping.invert().map(newEnd);changes.push({oldRange:{from:oldStart,to:oldEnd},newRange:{from:newStart,to:newEnd}})}))})),simplifyChangedRanges$1(changes)}function getMarksBetween$1(from,to,doc){const marks=[];
// get all inclusive marks on empty selection
return from===to?doc.resolve(from).marks().forEach((mark=>{const $pos=doc.resolve(from-1),range=getMarkRange$1($pos,mark.type);range&&marks.push({mark:mark,...range})})):doc.nodesBetween(from,to,((node,pos)=>{marks.push(...node.marks.map((mark=>({from:pos,to:pos+node.nodeSize,mark:mark}))))})),marks}
/**
 * Build an input rule that adds a mark when the
 * matched text is typed into it.
 */function markInputRule$1(config){return new InputRule$1({find:config.find,handler:({state:state,range:range,match:match})=>{const attributes=callOrReturn$1(config.getAttributes,void 0,match);if(!1===attributes||null===attributes)return null;const{tr:tr}=state,captureGroup=match[match.length-1],fullMatch=match[0];let markEnd=range.to;if(captureGroup){const startSpaces=fullMatch.search(/\S/),textStart=range.from+fullMatch.indexOf(captureGroup),textEnd=textStart+captureGroup.length,excludedMarks=getMarksBetween$1(range.from,range.to,state.doc).filter((item=>{
// @ts-ignore
const excluded=item.mark.type.excluded;return excluded.find((type=>type===config.type&&type!==item.mark.type))})).filter((item=>item.to>textStart));if(excludedMarks.length)return null;textEnd<range.to&&tr.delete(textEnd,range.to),textStart>range.from&&tr.delete(range.from+startSpaces,textStart),markEnd=range.from+startSpaces+captureGroup.length,tr.addMark(range.from+startSpaces,markEnd,config.type.create(attributes||{})),tr.removeStoredMark(config.type)}}})}
/**
 * Build an input rule that adds a node when the
 * matched text is typed into it.
 */function nodeInputRule$1(config){return new InputRule$1({find:config.find,handler:({state:state,range:range,match:match})=>{const attributes=callOrReturn$1(config.getAttributes,void 0,match)||{},{tr:tr}=state,start=range.from;let end=range.to;if(match[1]){const offset=match[0].lastIndexOf(match[1]);let matchStart=start+offset;matchStart>end?matchStart=end:end=matchStart+match[1].length;
// insert last typed character
const lastChar=match[0][match[0].length-1];tr.insertText(lastChar,start+match[0].length-1),
// insert node from input rule
tr.replaceWith(matchStart,end,config.type.create(attributes))}else match[0]&&tr.replaceWith(start,end,config.type.create(attributes))}})}
/**
 * Build an input rule that changes the type of a textblock when the
 * matched text is typed into it. When using a regular expresion you’ll
 * probably want the regexp to start with `^`, so that the pattern can
 * only occur at the start of a textblock.
 */function textblockTypeInputRule$1(config){return new InputRule$1({find:config.find,handler:({state:state,range:range,match:match})=>{const $start=state.doc.resolve(range.from),attributes=callOrReturn$1(config.getAttributes,void 0,match)||{};if(!$start.node(-1).canReplaceWith($start.index(-1),$start.indexAfter(-1),config.type))return null;state.tr.delete(range.from,range.to).setBlockType(range.from,range.from,config.type,attributes)}})}
/**
 * Build an input rule for automatically wrapping a textblock when a
 * given string is typed. When using a regular expresion you’ll
 * probably want the regexp to start with `^`, so that the pattern can
 * only occur at the start of a textblock.
 *
 * `type` is the type of node to wrap in.
 *
 * By default, if there’s a node with the same type above the newly
 * wrapped node, the rule will try to join those
 * two nodes. You can pass a join predicate, which takes a regular
 * expression match and the node before the wrapped node, and can
 * return a boolean to indicate whether a join should happen.
 */function wrappingInputRule$1(config){return new InputRule$1({find:config.find,handler:({state:state,range:range,match:match})=>{const attributes=callOrReturn$1(config.getAttributes,void 0,match)||{},tr=state.tr.delete(range.from,range.to),$start=tr.doc.resolve(range.from),blockRange=$start.blockRange(),wrapping=blockRange&&findWrapping$1(blockRange,config.type,attributes);if(!wrapping)return null;tr.wrap(blockRange,wrapping);const before=tr.doc.resolve(range.from-1).nodeBefore;before&&before.type===config.type&&canJoin$1(tr.doc,range.from-1)&&(!config.joinPredicate||config.joinPredicate(match,before))&&tr.join(range.from-1)}})}Extension$1.create({name:"commands",addCommands(){return{...commands$1}}}),Extension$1.create({name:"editable",addProseMirrorPlugins(){return[new Plugin$1({key:new PluginKey$1("editable"),props:{editable:()=>this.editor.options.editable}})]}}),Extension$1.create({name:"focusEvents",addProseMirrorPlugins(){const{editor:editor}=this;return[new Plugin$1({key:new PluginKey$1("focusEvents"),props:{handleDOMEvents:{focus:(view,event)=>{editor.isFocused=!0;const transaction=editor.state.tr.setMeta("focus",{event:event}).setMeta("addToHistory",!1);return view.dispatch(transaction),!1},blur:(view,event)=>{editor.isFocused=!1;const transaction=editor.state.tr.setMeta("blur",{event:event}).setMeta("addToHistory",!1);return view.dispatch(transaction),!1}}}})]}}),Extension$1.create({name:"keymap",addKeyboardShortcuts(){const handleBackspace=()=>this.editor.commands.first((({commands:commands})=>[()=>commands.undoInputRule()
// maybe convert first text block node to default node
,()=>commands.command((({tr:tr})=>{const{selection:selection,doc:doc}=tr,{empty:empty,$anchor:$anchor}=selection,{pos:pos,parent:parent}=$anchor,isAtStart=Selection$1.atStart(doc).from===pos;return!(!(empty&&isAtStart&&parent.type.isTextblock)||parent.textContent.length)&&commands.clearNodes()})),()=>commands.deleteSelection(),()=>commands.joinBackward(),()=>commands.selectNodeBackward()])),handleDelete=()=>this.editor.commands.first((({commands:commands})=>[()=>commands.deleteSelection(),()=>commands.joinForward(),()=>commands.selectNodeForward()])),handleEnter=()=>this.editor.commands.first((({commands:commands})=>[()=>commands.newlineInCode(),()=>commands.createParagraphNear(),()=>commands.liftEmptyBlock(),()=>commands.splitBlock()])),baseKeymap={Enter:handleEnter,"Mod-Enter":()=>this.editor.commands.exitCode(),Backspace:handleBackspace,"Mod-Backspace":handleBackspace,"Shift-Backspace":handleBackspace,Delete:handleDelete,"Mod-Delete":handleDelete,"Mod-a":()=>this.editor.commands.selectAll()},pcKeymap={...baseKeymap},macKeymap={...baseKeymap,"Ctrl-h":handleBackspace,"Alt-Backspace":handleBackspace,"Ctrl-d":handleDelete,"Ctrl-Alt-Backspace":handleDelete,"Alt-Delete":handleDelete,"Alt-d":handleDelete,"Ctrl-a":()=>this.editor.commands.selectTextblockStart(),"Ctrl-e":()=>this.editor.commands.selectTextblockEnd()};return isiOS$1()||isMacOS$1()?macKeymap:pcKeymap},addProseMirrorPlugins(){return[
// With this plugin we check if the whole document was selected and deleted.
// In this case we will additionally call `clearNodes()` to convert e.g. a heading
// to a paragraph if necessary.
// This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
// with many other commands.
new Plugin$1({key:new PluginKey$1("clearDocument"),appendTransaction:(transactions,oldState,newState)=>{const docChanges=transactions.some((transaction=>transaction.docChanged))&&!oldState.doc.eq(newState.doc);if(!docChanges)return;const{empty:empty,from:from,to:to}=oldState.selection,allFrom=Selection$1.atStart(oldState.doc).from,allEnd=Selection$1.atEnd(oldState.doc).to,allWasSelected=from===allFrom&&to===allEnd,isEmpty=0===newState.doc.textBetween(0,newState.doc.content.size," "," ").length;if(empty||!allWasSelected||!isEmpty)return;const tr=newState.tr,state=createChainableState$1({state:newState,transaction:tr}),{commands:commands}=new CommandManager$1({editor:this.editor,state:state});return commands.clearNodes(),tr.steps.length?tr:void 0}})]}}),Extension$1.create({name:"tabindex",addProseMirrorPlugins(){return[new Plugin$1({key:new PluginKey$1("tabindex"),props:{attributes:this.editor.isEditable?{tabindex:"0"}:{}}})]}});class Mark$2{constructor(config={}){this.type="mark",this.name="mark",this.parent=null,this.child=null,this.config={name:this.name,defaultOptions:{}},this.config={...this.config,...config},this.name=this.config.name,config.defaultOptions,
// TODO: remove `addOptions` fallback
this.options=this.config.defaultOptions,this.config.addOptions&&(this.options=callOrReturn$1(getExtensionField$1(this,"addOptions",{name:this.name}))),this.storage=callOrReturn$1(getExtensionField$1(this,"addStorage",{name:this.name,options:this.options}))||{}}static create(config={}){return new Mark$2(config)}configure(options={}){
// return a new instance so we can use the same extension
// with different calls of `configure`
const extension=this.extend();return extension.options=mergeDeep$1(this.options,options),extension.storage=callOrReturn$1(getExtensionField$1(extension,"addStorage",{name:extension.name,options:extension.options})),extension}extend(extendedConfig={}){const extension=new Mark$2(extendedConfig);return extension.parent=this,this.child=extension,extension.name=extendedConfig.name?extendedConfig.name:extension.parent.name,extendedConfig.defaultOptions,extension.options=callOrReturn$1(getExtensionField$1(extension,"addOptions",{name:extension.name})),extension.storage=callOrReturn$1(getExtensionField$1(extension,"addStorage",{name:extension.name,options:extension.options})),extension}static handleExit({editor:editor,mark:mark}){const{tr:tr}=editor.state,currentPos=editor.state.selection.$from,isAtEnd=currentPos.pos===currentPos.end();if(isAtEnd){const currentMarks=currentPos.marks(),isInMark=!!currentMarks.find((m=>(null===m||void 0===m?void 0:m.type.name)===mark.name));if(!isInMark)return!1;const removeMark=currentMarks.find((m=>(null===m||void 0===m?void 0:m.type.name)===mark.name));return removeMark&&tr.removeStoredMark(removeMark),tr.insertText(" ",currentPos.pos),editor.view.dispatch(tr),!0}return!1}}class Node$1$1{constructor(config={}){this.type="node",this.name="node",this.parent=null,this.child=null,this.config={name:this.name,defaultOptions:{}},this.config={...this.config,...config},this.name=this.config.name,config.defaultOptions,
// TODO: remove `addOptions` fallback
this.options=this.config.defaultOptions,this.config.addOptions&&(this.options=callOrReturn$1(getExtensionField$1(this,"addOptions",{name:this.name}))),this.storage=callOrReturn$1(getExtensionField$1(this,"addStorage",{name:this.name,options:this.options}))||{}}static create(config={}){return new Node$1$1(config)}configure(options={}){
// return a new instance so we can use the same extension
// with different calls of `configure`
const extension=this.extend();return extension.options=mergeDeep$1(this.options,options),extension.storage=callOrReturn$1(getExtensionField$1(extension,"addStorage",{name:extension.name,options:extension.options})),extension}extend(extendedConfig={}){const extension=new Node$1$1(extendedConfig);return extension.parent=this,this.child=extension,extension.name=extendedConfig.name?extendedConfig.name:extension.parent.name,extendedConfig.defaultOptions,extension.options=callOrReturn$1(getExtensionField$1(extension,"addOptions",{name:extension.name})),extension.storage=callOrReturn$1(getExtensionField$1(extension,"addStorage",{name:extension.name,options:extension.options})),extension}}
/**
 * Build an paste rule that adds a mark when the
 * matched text is pasted into it.
 */function markPasteRule$1(config){return new PasteRule$1({find:config.find,handler:({state:state,range:range,match:match})=>{const attributes=callOrReturn$1(config.getAttributes,void 0,match);if(!1===attributes||null===attributes)return null;const{tr:tr}=state,captureGroup=match[match.length-1],fullMatch=match[0];let markEnd=range.to;if(captureGroup){const startSpaces=fullMatch.search(/\S/),textStart=range.from+fullMatch.indexOf(captureGroup),textEnd=textStart+captureGroup.length,excludedMarks=getMarksBetween$1(range.from,range.to,state.doc).filter((item=>{
// @ts-ignore
const excluded=item.mark.type.excluded;return excluded.find((type=>type===config.type&&type!==item.mark.type))})).filter((item=>item.to>textStart));if(excludedMarks.length)return null;textEnd<range.to&&tr.delete(textEnd,range.to),textStart>range.from&&tr.delete(range.from+startSpaces,textStart),markEnd=range.from+startSpaces+captureGroup.length,tr.addMark(range.from+startSpaces,markEnd,config.type.create(attributes||{})),tr.removeStoredMark(config.type)}}})}Node$1$1.create({name:"doc",topNode:!0,content:"block+"});const Paragraph$1=Node$1$1.create({name:"paragraph",priority:1e3,addOptions(){return{HTMLAttributes:{}}},group:"block",content:"inline*",parseHTML(){return[{tag:"p"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["p",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setParagraph:()=>({commands:commands})=>commands.setNode(this.name)}},addKeyboardShortcuts(){return{"Mod-Alt-0":()=>this.editor.commands.setParagraph()}}});Node$1$1.create({name:"text",group:"inline"});const starInputRegex$1$1=/(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/,starPasteRegex$1$1=/(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g,underscoreInputRegex$1$1=/(?:^|\s)((?:__)((?:[^__]+))(?:__))$/,underscorePasteRegex$1$1=/(?:^|\s)((?:__)((?:[^__]+))(?:__))/g;Mark$2.create({name:"bold",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"strong"},{tag:"b",getAttrs:node=>"normal"!==node.style.fontWeight&&null},{style:"font-weight",getAttrs:value=>/^(bold(er)?|[5-9]\d{2,})$/.test(value)&&null}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["strong",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setBold:()=>({commands:commands})=>commands.setMark(this.name),toggleBold:()=>({commands:commands})=>commands.toggleMark(this.name),unsetBold:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-b":()=>this.editor.commands.toggleBold(),"Mod-B":()=>this.editor.commands.toggleBold()}},addInputRules(){return[markInputRule$1({find:starInputRegex$1$1,type:this.type}),markInputRule$1({find:underscoreInputRegex$1$1,type:this.type})]},addPasteRules(){return[markPasteRule$1({find:starPasteRegex$1$1,type:this.type}),markPasteRule$1({find:underscorePasteRegex$1$1,type:this.type})]}});const starInputRegex$2=/(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/,starPasteRegex$2=/(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g,underscoreInputRegex$2=/(?:^|\s)((?:_)((?:[^_]+))(?:_))$/,underscorePasteRegex$2=/(?:^|\s)((?:_)((?:[^_]+))(?:_))/g;Mark$2.create({name:"italic",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"em"},{tag:"i",getAttrs:node=>"normal"!==node.style.fontStyle&&null},{style:"font-style=italic"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["em",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setItalic:()=>({commands:commands})=>commands.setMark(this.name),toggleItalic:()=>({commands:commands})=>commands.toggleMark(this.name),unsetItalic:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-i":()=>this.editor.commands.toggleItalic(),"Mod-I":()=>this.editor.commands.toggleItalic()}},addInputRules(){return[markInputRule$1({find:starInputRegex$2,type:this.type}),markInputRule$1({find:underscoreInputRegex$2,type:this.type})]},addPasteRules(){return[markPasteRule$1({find:starPasteRegex$2,type:this.type}),markPasteRule$1({find:underscorePasteRegex$2,type:this.type})]}}),Mark$2.create({name:"underline",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"u"},{style:"text-decoration",consuming:!1,getAttrs:style=>!!style.includes("underline")&&{}}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["u",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setUnderline:()=>({commands:commands})=>commands.setMark(this.name),toggleUnderline:()=>({commands:commands})=>commands.toggleMark(this.name),unsetUnderline:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-u":()=>this.editor.commands.toggleUnderline(),"Mod-U":()=>this.editor.commands.toggleUnderline()}}});const inputRegex$5$1=/(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/,pasteRegex$1$1=/(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g;Mark$2.create({name:"strike",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"s"},{tag:"del"},{tag:"strike"},{style:"text-decoration",consuming:!1,getAttrs:style=>!!style.includes("line-through")&&{}}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["s",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setStrike:()=>({commands:commands})=>commands.setMark(this.name),toggleStrike:()=>({commands:commands})=>commands.toggleMark(this.name),unsetStrike:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-Shift-x":()=>this.editor.commands.toggleStrike()}},addInputRules(){return[markInputRule$1({find:inputRegex$5$1,type:this.type})]},addPasteRules(){return[markPasteRule$1({find:pasteRegex$1$1,type:this.type})]}}),Node$1$1.create({name:"listItem",addOptions(){return{HTMLAttributes:{}}},content:"paragraph block*",defining:!0,parseHTML(){return[{tag:"li"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["li",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes),0]},addKeyboardShortcuts(){return{Enter:()=>this.editor.commands.splitListItem(this.name),Tab:()=>this.editor.commands.sinkListItem(this.name),"Shift-Tab":()=>this.editor.commands.liftListItem(this.name)}}});const inputRegex$4$1=/^\s*([-+*])\s$/;Node$1$1.create({name:"bulletList",addOptions(){return{itemTypeName:"listItem",HTMLAttributes:{}}},group:"block list",content(){return`${this.options.itemTypeName}+`},parseHTML(){return[{tag:"ul"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["ul",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{toggleBulletList:()=>({commands:commands})=>commands.toggleList(this.name,this.options.itemTypeName)}},addKeyboardShortcuts(){return{"Mod-Shift-8":()=>this.editor.commands.toggleBulletList()}},addInputRules(){return[wrappingInputRule$1({find:inputRegex$4$1,type:this.type})]}}),Mark$2.create({name:"textStyle",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"span",getAttrs:element=>{const hasStyles=element.hasAttribute("style");return!!hasStyles&&{}}}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["span",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{removeEmptyTextStyle:()=>({state:state,commands:commands})=>{const attributes=getMarkAttributes$1(state,this.type),hasStyles=Object.entries(attributes).some((([,value])=>!!value));return!!hasStyles||commands.unsetMark(this.name)}}}}),Extension$1.create({name:"fontFamily",addOptions(){return{types:["textStyle"]}},addGlobalAttributes(){return[{types:this.options.types,attributes:{fontFamily:{default:null,parseHTML:element=>{var _a;return null===(_a=element.style.fontFamily)||void 0===_a?void 0:_a.replace(/['"]+/g,"")},renderHTML:attributes=>attributes.fontFamily?{style:`font-family: ${attributes.fontFamily}`}:{}}}}]},addCommands(){return{setFontFamily:fontFamily=>({chain:chain})=>chain().setMark("textStyle",{fontFamily:fontFamily}).run(),unsetFontFamily:()=>({chain:chain})=>chain().setMark("textStyle",{fontFamily:null}).removeEmptyTextStyle().run()}}});const inputRegex$3$1=/^(\d+)\.\s$/;Node$1$1.create({name:"orderedList",addOptions(){return{itemTypeName:"listItem",HTMLAttributes:{}}},group:"block list",content(){return`${this.options.itemTypeName}+`},addAttributes(){return{start:{default:1,parseHTML:element=>element.hasAttribute("start")?parseInt(element.getAttribute("start")||"",10):1}}},parseHTML(){return[{tag:"ol"}]},renderHTML({HTMLAttributes:HTMLAttributes}){const{start:start,...attributesWithoutStart}=HTMLAttributes;return 1===start?["ol",mergeAttributes$1(this.options.HTMLAttributes,attributesWithoutStart),0]:["ol",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{toggleOrderedList:()=>({commands:commands})=>commands.toggleList(this.name,this.options.itemTypeName)}},addKeyboardShortcuts(){return{"Mod-Shift-7":()=>this.editor.commands.toggleOrderedList()}},addInputRules(){return[wrappingInputRule$1({find:inputRegex$3$1,type:this.type,getAttributes:match=>({start:+match[1]}),joinPredicate:(match,node)=>node.childCount+node.attrs.start===+match[1]})]}}),Node$1$1.create({name:"heading",addOptions(){return{levels:[1,2,3,4,5,6],HTMLAttributes:{}}},content:"inline*",group:"block",defining:!0,addAttributes(){return{level:{default:1,rendered:!1}}},parseHTML(){return this.options.levels.map((level=>({tag:`h${level}`,attrs:{level:level}})))},renderHTML({node:node,HTMLAttributes:HTMLAttributes}){const hasLevel=this.options.levels.includes(node.attrs.level),level=hasLevel?node.attrs.level:this.options.levels[0];return[`h${level}`,mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setHeading:attributes=>({commands:commands})=>!!this.options.levels.includes(attributes.level)&&commands.setNode(this.name,attributes),toggleHeading:attributes=>({commands:commands})=>!!this.options.levels.includes(attributes.level)&&commands.toggleNode(this.name,"paragraph",attributes)}},addKeyboardShortcuts(){return this.options.levels.reduce(((items,level)=>({...items,[`Mod-Alt-${level}`]:()=>this.editor.commands.toggleHeading({level:level})})),{})},addInputRules(){return this.options.levels.map((level=>textblockTypeInputRule$1({find:new RegExp(`^(#{1,${level}})\\s$`),type:this.type,getAttributes:{level:level}})))}});var GOOD_LEAF_SIZE$1=200,RopeSequence$1=function(){};
// :: class<T> A rope sequence is a persistent sequence data structure
// that supports appending, prepending, and slicing without doing a
// full copy. It is represented as a mostly-balanced tree.
RopeSequence$1.prototype.append=function(other){return other.length?(other=RopeSequence$1.from(other),!this.length&&other||other.length<GOOD_LEAF_SIZE$1&&this.leafAppend(other)||this.length<GOOD_LEAF_SIZE$1&&other.leafPrepend(this)||this.appendInner(other)):this},
// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>
// Prepend an array or other rope to this one, returning a new rope.
RopeSequence$1.prototype.prepend=function(other){return other.length?RopeSequence$1.from(other).append(this):this},RopeSequence$1.prototype.appendInner=function(other){return new Append$1(this,other)},
// :: (?number, ?number) → RopeSequence<T>
// Create a rope repesenting a sub-sequence of this rope.
RopeSequence$1.prototype.slice=function(from,to){return void 0===from&&(from=0),void 0===to&&(to=this.length),from>=to?RopeSequence$1.empty:this.sliceInner(Math.max(0,from),Math.min(this.length,to))},
// :: (number) → T
// Retrieve the element at the given position from this rope.
RopeSequence$1.prototype.get=function(i){if(!(i<0||i>=this.length))return this.getInner(i)},
// :: ((element: T, index: number) → ?bool, ?number, ?number)
// Call the given function for each element between the given
// indices. This tends to be more efficient than looping over the
// indices and calling `get`, because it doesn't have to descend the
// tree for every element.
RopeSequence$1.prototype.forEach=function(f,from,to){void 0===from&&(from=0),void 0===to&&(to=this.length),from<=to?this.forEachInner(f,from,to,0):this.forEachInvertedInner(f,from,to,0)},
// :: ((element: T, index: number) → U, ?number, ?number) → [U]
// Map the given functions over the elements of the rope, producing
// a flat array.
RopeSequence$1.prototype.map=function(f,from,to){void 0===from&&(from=0),void 0===to&&(to=this.length);var result=[];return this.forEach((function(elt,i){return result.push(f(elt,i))}),from,to),result},
// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>
// Create a rope representing the given array, or return the rope
// itself if a rope was given.
RopeSequence$1.from=function(values){return values instanceof RopeSequence$1?values:values&&values.length?new Leaf$1(values):RopeSequence$1.empty};var Leaf$1=function(RopeSequence){function Leaf(values){RopeSequence.call(this),this.values=values}RopeSequence&&(Leaf.__proto__=RopeSequence),Leaf.prototype=Object.create(RopeSequence&&RopeSequence.prototype),Leaf.prototype.constructor=Leaf;var prototypeAccessors={length:{configurable:!0},depth:{configurable:!0}};return Leaf.prototype.flatten=function(){return this.values},Leaf.prototype.sliceInner=function(from,to){return 0==from&&to==this.length?this:new Leaf(this.values.slice(from,to))},Leaf.prototype.getInner=function(i){return this.values[i]},Leaf.prototype.forEachInner=function(f,from,to,start){for(var i=from;i<to;i++)if(!1===f(this.values[i],start+i))return!1},Leaf.prototype.forEachInvertedInner=function(f,from,to,start){for(var i=from-1;i>=to;i--)if(!1===f(this.values[i],start+i))return!1},Leaf.prototype.leafAppend=function(other){if(this.length+other.length<=GOOD_LEAF_SIZE$1)return new Leaf(this.values.concat(other.flatten()))},Leaf.prototype.leafPrepend=function(other){if(this.length+other.length<=GOOD_LEAF_SIZE$1)return new Leaf(other.flatten().concat(this.values))},prototypeAccessors.length.get=function(){return this.values.length},prototypeAccessors.depth.get=function(){return 0},Object.defineProperties(Leaf.prototype,prototypeAccessors),Leaf}(RopeSequence$1);
// :: RopeSequence
// The empty rope sequence.
RopeSequence$1.empty=new Leaf$1([]);var Append$1=function(RopeSequence){function Append(left,right){RopeSequence.call(this),this.left=left,this.right=right,this.length=left.length+right.length,this.depth=Math.max(left.depth,right.depth)+1}return RopeSequence&&(Append.__proto__=RopeSequence),Append.prototype=Object.create(RopeSequence&&RopeSequence.prototype),Append.prototype.constructor=Append,Append.prototype.flatten=function(){return this.left.flatten().concat(this.right.flatten())},Append.prototype.getInner=function(i){return i<this.left.length?this.left.get(i):this.right.get(i-this.left.length)},Append.prototype.forEachInner=function(f,from,to,start){var leftLen=this.left.length;return!(from<leftLen&&!1===this.left.forEachInner(f,from,Math.min(to,leftLen),start))&&(!(to>leftLen&&!1===this.right.forEachInner(f,Math.max(from-leftLen,0),Math.min(this.length,to)-leftLen,start+leftLen))&&void 0)},Append.prototype.forEachInvertedInner=function(f,from,to,start){var leftLen=this.left.length;return!(from>leftLen&&!1===this.right.forEachInvertedInner(f,from-leftLen,Math.max(to,leftLen)-leftLen,start+leftLen))&&(!(to<leftLen&&!1===this.left.forEachInvertedInner(f,Math.min(from,leftLen),to,start))&&void 0)},Append.prototype.sliceInner=function(from,to){if(0==from&&to==this.length)return this;var leftLen=this.left.length;return to<=leftLen?this.left.slice(from,to):from>=leftLen?this.right.slice(from-leftLen,to-leftLen):this.left.slice(from,leftLen).append(this.right.slice(0,to-leftLen))},Append.prototype.leafAppend=function(other){var inner=this.right.leafAppend(other);if(inner)return new Append(this.left,inner)},Append.prototype.leafPrepend=function(other){var inner=this.left.leafPrepend(other);if(inner)return new Append(inner,this.right)},Append.prototype.appendInner=function(other){return this.left.depth>=Math.max(this.right.depth,other.depth)+1?new Append(this.left,new Append(this.right,other)):new Append(this,other)},Append}(RopeSequence$1),ropeSequence$1=RopeSequence$1;
// ProseMirror's history isn't simply a way to roll back to a previous
// state, because ProseMirror supports applying changes without adding
// them to the history (for example during collaboration).
// To this end, each 'Branch' (one for the undo history and one for
// the redo history) keeps an array of 'Items', which can optionally
// hold a step (an actual undoable change), and always hold a position
// map (which is needed to move changes below them to apply to the
// current document).
// An item that has both a step and a selection bookmark is the start
// of an 'event' — a group of changes that will be undone or redone at
// once. (It stores only the bookmark, since that way we don't have to
// provide a document until the selection is actually applied, which
// is useful when compressing.)
// Used to schedule history compression
const max_empty_items$1=500;class Branch$1{constructor(items,eventCount){this.items=items,this.eventCount=eventCount}
// Pop the latest event off the branch's history and apply it
// to a document transform.
popEvent(state,preserveItems){if(0==this.eventCount)return null;let remap,mapFrom,end=this.items.length;for(;;end--){let next=this.items.get(end-1);if(next.selection){--end;break}}preserveItems&&(remap=this.remapping(end,this.items.length),mapFrom=remap.maps.length);let selection,remaining,transform=state.tr,addAfter=[],addBefore=[];return this.items.forEach(((item,i)=>{if(!item.step)return remap||(remap=this.remapping(end,i+1),mapFrom=remap.maps.length),mapFrom--,void addBefore.push(item);if(remap){addBefore.push(new Item$1(item.map));let map,step=item.step.map(remap.slice(mapFrom));step&&transform.maybeStep(step).doc&&(map=transform.mapping.maps[transform.mapping.maps.length-1],addAfter.push(new Item$1(map,void 0,void 0,addAfter.length+addBefore.length))),mapFrom--,map&&remap.appendMap(map,mapFrom)}else transform.maybeStep(item.step);return item.selection?(selection=remap?item.selection.map(remap.slice(mapFrom)):item.selection,remaining=new Branch$1(this.items.slice(0,end).append(addBefore.reverse().concat(addAfter)),this.eventCount-1),!1):void 0}),this.items.length,0),{remaining:remaining,transform:transform,selection:selection}}
// Create a new branch with the given transform added.
addTransform(transform,selection,histOptions,preserveItems){let newItems=[],eventCount=this.eventCount,oldItems=this.items,lastItem=!preserveItems&&oldItems.length?oldItems.get(oldItems.length-1):null;for(let i=0;i<transform.steps.length;i++){let merged,step=transform.steps[i].invert(transform.docs[i]),item=new Item$1(transform.mapping.maps[i],step,selection);(merged=lastItem&&lastItem.merge(item))&&(item=merged,i?newItems.pop():oldItems=oldItems.slice(0,oldItems.length-1)),newItems.push(item),selection&&(eventCount++,selection=void 0),preserveItems||(lastItem=item)}let overflow=eventCount-histOptions.depth;return overflow>DEPTH_OVERFLOW$1&&(oldItems=cutOffEvents$1(oldItems,overflow),eventCount-=overflow),new Branch$1(oldItems.append(newItems),eventCount)}remapping(from,to){let maps=new Mapping$1;return this.items.forEach(((item,i)=>{let mirrorPos=null!=item.mirrorOffset&&i-item.mirrorOffset>=from?maps.maps.length-item.mirrorOffset:void 0;maps.appendMap(item.map,mirrorPos)}),from,to),maps}addMaps(array){return 0==this.eventCount?this:new Branch$1(this.items.append(array.map((map=>new Item$1(map)))),this.eventCount)}
// When the collab module receives remote changes, the history has
// to know about those, so that it can adjust the steps that were
// rebased on top of the remote changes, and include the position
// maps for the remote changes in its array of items.
rebased(rebasedTransform,rebasedCount){if(!this.eventCount)return this;let rebasedItems=[],start=Math.max(0,this.items.length-rebasedCount),mapping=rebasedTransform.mapping,newUntil=rebasedTransform.steps.length,eventCount=this.eventCount;this.items.forEach((item=>{item.selection&&eventCount--}),start);let iRebased=rebasedCount;this.items.forEach((item=>{let pos=mapping.getMirror(--iRebased);if(null==pos)return;newUntil=Math.min(newUntil,pos);let map=mapping.maps[pos];if(item.step){let step=rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]),selection=item.selection&&item.selection.map(mapping.slice(iRebased+1,pos));selection&&eventCount++,rebasedItems.push(new Item$1(map,step,selection))}else rebasedItems.push(new Item$1(map))}),start);let newMaps=[];for(let i=rebasedCount;i<newUntil;i++)newMaps.push(new Item$1(mapping.maps[i]));let items=this.items.slice(0,start).append(newMaps).append(rebasedItems),branch=new Branch$1(items,eventCount);return branch.emptyItemCount()>max_empty_items$1&&(branch=branch.compress(this.items.length-rebasedItems.length)),branch}emptyItemCount(){let count=0;return this.items.forEach((item=>{item.step||count++})),count}
// Compressing a branch means rewriting it to push the air (map-only
// items) out. During collaboration, these naturally accumulate
// because each remote change adds one. The `upto` argument is used
// to ensure that only the items below a given level are compressed,
// because `rebased` relies on a clean, untouched set of items in
// order to associate old items with rebased steps.
compress(upto=this.items.length){let remap=this.remapping(0,upto),mapFrom=remap.maps.length,items=[],events=0;return this.items.forEach(((item,i)=>{if(i>=upto)items.push(item),item.selection&&events++;else if(item.step){let step=item.step.map(remap.slice(mapFrom)),map=step&&step.getMap();if(mapFrom--,map&&remap.appendMap(map,mapFrom),step){let selection=item.selection&&item.selection.map(remap.slice(mapFrom));selection&&events++;let merged,newItem=new Item$1(map.invert(),step,selection),last=items.length-1;(merged=items.length&&items[last].merge(newItem))?items[last]=merged:items.push(newItem)}}else item.map&&mapFrom--}),this.items.length,0),new Branch$1(ropeSequence$1.from(items.reverse()),events)}}function cutOffEvents$1(items,n){let cutPoint;return items.forEach(((item,i)=>{if(item.selection&&0==n--)return cutPoint=i,!1})),items.slice(cutPoint)}Branch$1.empty=new Branch$1(ropeSequence$1.empty,0);class Item$1{constructor(
// The (forward) step map for this item.
map,
// The inverted step
step,
// If this is non-null, this item is the start of a group, and
// this selection is the starting selection for the group (the one
// that was active before the first step was applied)
selection,
// If this item is the inverse of a previous mapping on the stack,
// this points at the inverse's offset
mirrorOffset){this.map=map,this.step=step,this.selection=selection,this.mirrorOffset=mirrorOffset}merge(other){if(this.step&&other.step&&!other.selection){let step=other.step.merge(this.step);if(step)return new Item$1(step.getMap().invert(),step,this.selection)}}}
// The value of the state field that tracks undo/redo history for that
// state. Will be stored in the plugin state when the history plugin
// is active.
class HistoryState$1{constructor(done,undone,prevRanges,prevTime){this.done=done,this.undone=undone,this.prevRanges=prevRanges,this.prevTime=prevTime}}const DEPTH_OVERFLOW$1=20;
// Record a transformation in undo history.
function applyTransaction$1(history,state,tr,options){let rebased,historyTr=tr.getMeta(historyKey$1);if(historyTr)return historyTr.historyState;tr.getMeta(closeHistoryKey$1)&&(history=new HistoryState$1(history.done,history.undone,null,0));let appended=tr.getMeta("appendedTransaction");if(0==tr.steps.length)return history;if(appended&&appended.getMeta(historyKey$1))return appended.getMeta(historyKey$1).redo?new HistoryState$1(history.done.addTransform(tr,void 0,options,mustPreserveItems$1(state)),history.undone,rangesFor$1(tr.mapping.maps[tr.steps.length-1]),history.prevTime):new HistoryState$1(history.done,history.undone.addTransform(tr,void 0,options,mustPreserveItems$1(state)),null,history.prevTime);if(!1===tr.getMeta("addToHistory")||appended&&!1===appended.getMeta("addToHistory"))return(rebased=tr.getMeta("rebased"))?new HistoryState$1(history.done.rebased(tr,rebased),history.undone.rebased(tr,rebased),mapRanges$1(history.prevRanges,tr.mapping),history.prevTime):new HistoryState$1(history.done.addMaps(tr.mapping.maps),history.undone.addMaps(tr.mapping.maps),mapRanges$1(history.prevRanges,tr.mapping),history.prevTime);{
// Group transforms that occur in quick succession into one event.
let newGroup=0==history.prevTime||!appended&&(history.prevTime<(tr.time||0)-options.newGroupDelay||!isAdjacentTo$1(tr,history.prevRanges)),prevRanges=appended?mapRanges$1(history.prevRanges,tr.mapping):rangesFor$1(tr.mapping.maps[tr.steps.length-1]);return new HistoryState$1(history.done.addTransform(tr,newGroup?state.selection.getBookmark():void 0,options,mustPreserveItems$1(state)),Branch$1.empty,prevRanges,tr.time)}}function isAdjacentTo$1(transform,prevRanges){if(!prevRanges)return!1;if(!transform.docChanged)return!0;let adjacent=!1;return transform.mapping.maps[0].forEach(((start,end)=>{for(let i=0;i<prevRanges.length;i+=2)start<=prevRanges[i+1]&&end>=prevRanges[i]&&(adjacent=!0)})),adjacent}function rangesFor$1(map){let result=[];return map.forEach(((_from,_to,from,to)=>result.push(from,to))),result}function mapRanges$1(ranges,mapping){if(!ranges)return null;let result=[];for(let i=0;i<ranges.length;i+=2){let from=mapping.map(ranges[i],1),to=mapping.map(ranges[i+1],-1);from<=to&&result.push(from,to)}return result}
// Apply the latest event from one branch to the document and shift the event
// onto the other branch.
function histTransaction$1(history,state,dispatch,redo){let preserveItems=mustPreserveItems$1(state),histOptions=historyKey$1.get(state).spec.config,pop=(redo?history.undone:history.done).popEvent(state,preserveItems);if(!pop)return;let selection=pop.selection.resolve(pop.transform.doc),added=(redo?history.done:history.undone).addTransform(pop.transform,state.selection.getBookmark(),histOptions,preserveItems),newHist=new HistoryState$1(redo?added:pop.remaining,redo?pop.remaining:added,null,0);dispatch(pop.transform.setSelection(selection).setMeta(historyKey$1,{redo:redo,historyState:newHist}).scrollIntoView())}let cachedPreserveItems$1=!1,cachedPreserveItemsPlugins$1=null;
// Check whether any plugin in the given state has a
// `historyPreserveItems` property in its spec, in which case we must
// preserve steps exactly as they came in, so that they can be
// rebased.
function mustPreserveItems$1(state){let plugins=state.plugins;if(cachedPreserveItemsPlugins$1!=plugins){cachedPreserveItems$1=!1,cachedPreserveItemsPlugins$1=plugins;for(let i=0;i<plugins.length;i++)if(plugins[i].spec.historyPreserveItems){cachedPreserveItems$1=!0;break}}return cachedPreserveItems$1}const historyKey$1=new PluginKey$1("history"),closeHistoryKey$1=new PluginKey$1("closeHistory");
/**
Returns a plugin that enables the undo history for an editor. The
plugin will track undo and redo stacks, which can be used with the
[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.

You can set an `"addToHistory"` [metadata
property](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction
to prevent it from being rolled back by undo.
*/
function history$1(config={}){return config={depth:config.depth||100,newGroupDelay:config.newGroupDelay||500},new Plugin$1({key:historyKey$1,state:{init(){return new HistoryState$1(Branch$1.empty,Branch$1.empty,null,0)},apply(tr,hist,state){return applyTransaction$1(hist,state,tr,config)}},config:config,props:{handleDOMEvents:{beforeinput(view,e){let inputType=e.inputType,command="historyUndo"==inputType?undo$1:"historyRedo"==inputType?redo$1:null;return!!command&&(e.preventDefault(),command(view.state,view.dispatch))}}}})}
/**
A command function that undoes the last change, if any.
*/const undo$1=(state,dispatch)=>{let hist=historyKey$1.getState(state);return!(!hist||0==hist.done.eventCount)&&(dispatch&&histTransaction$1(hist,state,dispatch,!1),!0)},redo$1=(state,dispatch)=>{let hist=historyKey$1.getState(state);return!(!hist||0==hist.undone.eventCount)&&(dispatch&&histTransaction$1(hist,state,dispatch,!0),!0)};
/**
A command function that redoes the last undone change, if any.
*/
// Because working with row and column-spanning cells is not quite
// trivial, this code builds up a descriptive structure for a given
// table node. The structures are cached with the (persistent) table
// nodes as key, so that they only have to be recomputed when the
// content of the table changes.
// This does mean that they have to store table-relative, not
// document-relative positions. So code that uses them will typically
// compute the start position of the table and offset positions passed
// to or gotten from this structure by that amount.
let readFromCache$1,addToCache$1;// Prefer using a weak map to cache table maps. Fall back on a
// fixed-size cache if that's not supported.
if(Extension$1.create({name:"history",addOptions(){return{depth:100,newGroupDelay:500}},addCommands(){return{undo:()=>({state:state,dispatch:dispatch})=>undo$1(state,dispatch),redo:()=>({state:state,dispatch:dispatch})=>redo$1(state,dispatch)}},addProseMirrorPlugins(){return[history$1(this.options)]},addKeyboardShortcuts(){return{"Mod-z":()=>this.editor.commands.undo(),"Mod-y":()=>this.editor.commands.redo(),"Shift-Mod-z":()=>this.editor.commands.redo()
// Russian keyboard layouts
,"Mod-я":()=>this.editor.commands.undo(),"Shift-Mod-я":()=>this.editor.commands.redo()}}}),Extension$1.create({name:"textAlign",addOptions(){return{types:[],alignments:["left","center","right","justify"],defaultAlignment:"left"}},addGlobalAttributes(){return[{types:this.options.types,attributes:{textAlign:{default:this.options.defaultAlignment,parseHTML:element=>element.style.textAlign||this.options.defaultAlignment,renderHTML:attributes=>attributes.textAlign===this.options.defaultAlignment?{}:{style:`text-align: ${attributes.textAlign}`}}}}]},addCommands(){return{setTextAlign:alignment=>({commands:commands})=>!!this.options.alignments.includes(alignment)&&this.options.types.every((type=>commands.updateAttributes(type,{textAlign:alignment}))),unsetTextAlign:()=>({commands:commands})=>this.options.types.every((type=>commands.resetAttributes(type,"textAlign")))}},addKeyboardShortcuts(){return{"Mod-Shift-l":()=>this.editor.commands.setTextAlign("left"),"Mod-Shift-e":()=>this.editor.commands.setTextAlign("center"),"Mod-Shift-r":()=>this.editor.commands.setTextAlign("right"),"Mod-Shift-j":()=>this.editor.commands.setTextAlign("justify")}}}),"undefined"!=typeof WeakMap){
// eslint-disable-next-line
let cache=new WeakMap;readFromCache$1=key=>cache.get(key),addToCache$1=(key,value)=>(cache.set(key,value),value)}else{let cache=[],cacheSize=10,cachePos=0;readFromCache$1=key=>{for(let i=0;i<cache.length;i+=2)if(cache[i]==key)return cache[i+1]},addToCache$1=(key,value)=>(cachePos==cacheSize&&(cachePos=0),cache[cachePos++]=key,cache[cachePos++]=value)}class Rect$1{constructor(left,top,right,bottom){this.left=left,this.top=top,this.right=right,this.bottom=bottom}}// ::- A table map describes the structore of a given table. To avoid
// recomputing them all the time, they are cached per table node. To
// be able to do that, positions saved in the map are relative to the
// start of the table, rather than the start of the document.
class TableMap$1{constructor(width,height,map,problems){
// :: number The width of the table
this.width=width,// :: number The table's height
this.height=height,// :: [number] A width * height array with the start position of
// the cell covering that part of the table in each slot
this.map=map,// An optional array of problems (cell overlap or non-rectangular
// shape) for the table, used by the table normalizer.
this.problems=problems}// :: (number) → Rect
// Find the dimensions of the cell at the given position.
findCell(pos){for(let i=0;i<this.map.length;i++){let curPos=this.map[i];if(curPos!=pos)continue;let left=i%this.width,top=i/this.width|0,right=left+1,bottom=top+1;for(let j=1;right<this.width&&this.map[i+j]==curPos;j++)right++;for(let j=1;bottom<this.height&&this.map[i+this.width*j]==curPos;j++)bottom++;return new Rect$1(left,top,right,bottom)}throw new RangeError("No cell with offset "+pos+" found")}// :: (number) → number
// Find the left side of the cell at the given position.
colCount(pos){for(let i=0;i<this.map.length;i++)if(this.map[i]==pos)return i%this.width;throw new RangeError("No cell with offset "+pos+" found")}// :: (number, string, number) → ?number
// Find the next cell in the given direction, starting from the cell
// at `pos`, if any.
nextCell(pos,axis,dir){let{left:left,right:right,top:top,bottom:bottom}=this.findCell(pos);return"horiz"==axis?(dir<0?0==left:right==this.width)?null:this.map[top*this.width+(dir<0?left-1:right)]:(dir<0?0==top:bottom==this.height)?null:this.map[left+this.width*(dir<0?top-1:bottom)]}// :: (number, number) → Rect
// Get the rectangle spanning the two given cells.
rectBetween(a,b){let{left:leftA,right:rightA,top:topA,bottom:bottomA}=this.findCell(a),{left:leftB,right:rightB,top:topB,bottom:bottomB}=this.findCell(b);return new Rect$1(Math.min(leftA,leftB),Math.min(topA,topB),Math.max(rightA,rightB),Math.max(bottomA,bottomB))}// :: (Rect) → [number]
// Return the position of all cells that have the top left corner in
// the given rectangle.
cellsInRect(rect){let result=[],seen={};for(let row=rect.top;row<rect.bottom;row++)for(let col=rect.left;col<rect.right;col++){let index=row*this.width+col,pos=this.map[index];seen[pos]||(seen[pos]=!0,col==rect.left&&col&&this.map[index-1]==pos||row==rect.top&&row&&this.map[index-this.width]==pos||result.push(pos))}return result}// :: (number, number, Node) → number
// Return the position at which the cell at the given row and column
// starts, or would start, if a cell started there.
positionAt(row,col,table){for(let i=0,rowStart=0;;i++){let rowEnd=rowStart+table.child(i).nodeSize;if(i==row){let index=col+row*this.width,rowEndIndex=(row+1)*this.width;// Skip past cells from previous rows (via rowspan)
while(index<rowEndIndex&&this.map[index]<rowStart)index++;return index==rowEndIndex?rowEnd-1:this.map[index]}rowStart=rowEnd}}// :: (Node) → TableMap
// Find the table map for the given table node.
static get(table){return readFromCache$1(table)||addToCache$1(table,computeMap$1(table))}}// Compute a table map.
function computeMap$1(table){if("table"!=table.type.spec.tableRole)throw new RangeError("Not a table node: "+table.type.name);let width=findWidth$1(table),height=table.childCount,map=[],mapPos=0,problems=null,colWidths=[];for(let i=0,e=width*height;i<e;i++)map[i]=0;for(let row=0,pos=0;row<height;row++){let rowNode=table.child(row);pos++;for(let i=0;;i++){while(mapPos<map.length&&0!=map[mapPos])mapPos++;if(i==rowNode.childCount)break;let cellNode=rowNode.child(i),{colspan:colspan,rowspan:rowspan,colwidth:colwidth}=cellNode.attrs;for(let h=0;h<rowspan;h++){if(h+row>=height){(problems||(problems=[])).push({type:"overlong_rowspan",pos:pos,n:rowspan-h});break}let start=mapPos+h*width;for(let w=0;w<colspan;w++){0==map[start+w]?map[start+w]=pos:(problems||(problems=[])).push({type:"collision",row:row,pos:pos,n:colspan-w});let colW=colwidth&&colwidth[w];if(colW){let widthIndex=(start+w)%width*2,prev=colWidths[widthIndex];null==prev||prev!=colW&&1==colWidths[widthIndex+1]?(colWidths[widthIndex]=colW,colWidths[widthIndex+1]=1):prev==colW&&colWidths[widthIndex+1]++}}}mapPos+=colspan,pos+=cellNode.nodeSize}let expectedPos=(row+1)*width,missing=0;while(mapPos<expectedPos)0==map[mapPos++]&&missing++;missing&&(problems||(problems=[])).push({type:"missing",row:row,n:missing}),pos++}let tableMap=new TableMap$1(width,height,map,problems),badWidths=!1;// For columns that have defined widths, but whose widths disagree
// between rows, fix up the cells whose width doesn't match the
// computed one.
for(let i=0;!badWidths&&i<colWidths.length;i+=2)null!=colWidths[i]&&colWidths[i+1]<height&&(badWidths=!0);return badWidths&&findBadColWidths$1(tableMap,colWidths,table),tableMap}function findWidth$1(table){let width=-1,hasRowSpan=!1;for(let row=0;row<table.childCount;row++){let rowNode=table.child(row),rowWidth=0;if(hasRowSpan)for(let j=0;j<row;j++){let prevRow=table.child(j);for(let i=0;i<prevRow.childCount;i++){let cell=prevRow.child(i);j+cell.attrs.rowspan>row&&(rowWidth+=cell.attrs.colspan)}}for(let i=0;i<rowNode.childCount;i++){let cell=rowNode.child(i);rowWidth+=cell.attrs.colspan,cell.attrs.rowspan>1&&(hasRowSpan=!0)}-1==width?width=rowWidth:width!=rowWidth&&(width=Math.max(width,rowWidth))}return width}function findBadColWidths$1(map,colWidths,table){map.problems||(map.problems=[]);for(let i=0,seen={};i<map.map.length;i++){let pos=map.map[i];if(seen[pos])continue;seen[pos]=!0;let node=table.nodeAt(pos),updated=null;for(let j=0;j<node.attrs.colspan;j++){let col=(i+j)%map.width,colWidth=colWidths[2*col];null==colWidth||node.attrs.colwidth&&node.attrs.colwidth[j]==colWidth||((updated||(updated=freshColWidth$1(node.attrs)))[j]=colWidth)}updated&&map.problems.unshift({type:"colwidth mismatch",pos:pos,colwidth:updated})}}function freshColWidth$1(attrs){if(attrs.colwidth)return attrs.colwidth.slice();let result=[];for(let i=0;i<attrs.colspan;i++)result.push(0);return result}function tableNodeTypes$1(schema){let result=schema.cached.tableNodeTypes;if(!result){result=schema.cached.tableNodeTypes={};for(let name in schema.nodes){let type=schema.nodes[name],role=type.spec.tableRole;role&&(result[role]=type)}}return result}
// Various helper function for working with tables
const key$1$1=new PluginKey$1("selectingCells");function cellAround$1($pos){for(let d=$pos.depth-1;d>0;d--)if("row"==$pos.node(d).type.spec.tableRole)return $pos.node(0).resolve($pos.before(d+1));return null}function cellWrapping$1($pos){for(let d=$pos.depth;d>0;d--){
// Sometimes the cell can be in the same depth.
const role=$pos.node(d).type.spec.tableRole;if("cell"===role||"header_cell"===role)return $pos.node(d)}return null}function isInTable$1(state){let $head=state.selection.$head;for(let d=$head.depth;d>0;d--)if("row"==$head.node(d).type.spec.tableRole)return!0;return!1}function selectionCell$1(state){let sel=state.selection;return sel.$anchorCell?sel.$anchorCell.pos>sel.$headCell.pos?sel.$anchorCell:sel.$headCell:sel.node&&"cell"==sel.node.type.spec.tableRole?sel.$anchor:cellAround$1(sel.$head)||cellNear$1(sel.$head)}function cellNear$1($pos){for(let after=$pos.nodeAfter,pos=$pos.pos;after;after=after.firstChild,pos++){let role=after.type.spec.tableRole;if("cell"==role||"header_cell"==role)return $pos.doc.resolve(pos)}for(let before=$pos.nodeBefore,pos=$pos.pos;before;before=before.lastChild,pos--){let role=before.type.spec.tableRole;if("cell"==role||"header_cell"==role)return $pos.doc.resolve(pos-before.nodeSize)}}function pointsAtCell$1($pos){return"row"==$pos.parent.type.spec.tableRole&&$pos.nodeAfter}function moveCellForward$1($pos){return $pos.node(0).resolve($pos.pos+$pos.nodeAfter.nodeSize)}function inSameTable$1($a,$b){return $a.depth==$b.depth&&$a.pos>=$b.start(-1)&&$a.pos<=$b.end(-1)}function nextCell$1($pos,axis,dir){let start=$pos.start(-1),map=TableMap$1.get($pos.node(-1)),moved=map.nextCell($pos.pos-start,axis,dir);return null==moved?null:$pos.node(0).resolve(start+moved)}function setAttr$1(attrs,name,value){let result={};for(let prop in attrs)result[prop]=attrs[prop];return result[name]=value,result}function removeColSpan$1(attrs,pos,n=1){let result=setAttr$1(attrs,"colspan",attrs.colspan-n);return result.colwidth&&(result.colwidth=result.colwidth.slice(),result.colwidth.splice(pos,n),result.colwidth.some((w=>w>0))||(result.colwidth=null)),result}function addColSpan$1(attrs,pos,n=1){let result=setAttr$1(attrs,"colspan",attrs.colspan+n);if(result.colwidth){result.colwidth=result.colwidth.slice();for(let i=0;i<n;i++)result.colwidth.splice(pos,0,0)}return result}function columnIsHeader$1(map,table,col){let headerCell=tableNodeTypes$1(table.type.schema).header_cell;for(let row=0;row<map.height;row++)if(table.nodeAt(map.map[col+row*map.width]).type!=headerCell)return!1;return!0}
// This file defines a ProseMirror selection subclass that models
// subclass that represents a cell selection spanning part of a table.
// With the plugin enabled, these will be created when the user
// selects across cells, and will be drawn by giving selected cells a
// `selectedCell` CSS class.
class CellSelection$1 extends Selection$1{
// :: (ResolvedPos, ?ResolvedPos)
// A table selection is identified by its anchor and head cells. The
// positions given to this constructor should point _before_ two
// cells in the same table. They may be the same, to select a single
// cell.
constructor($anchorCell,$headCell=$anchorCell){let table=$anchorCell.node(-1),map=TableMap$1.get(table),start=$anchorCell.start(-1),rect=map.rectBetween($anchorCell.pos-start,$headCell.pos-start),doc=$anchorCell.node(0),cells=map.cellsInRect(rect).filter((p=>p!=$headCell.pos-start));// Make the head cell the first range, so that it counts as the
// primary part of the selection
cells.unshift($headCell.pos-start);let ranges=cells.map((pos=>{let cell=table.nodeAt(pos),from=pos+start+1;return new SelectionRange$1(doc.resolve(from),doc.resolve(from+cell.content.size))}));super(ranges[0].$from,ranges[0].$to,ranges),// :: ResolvedPos
// A resolved position pointing _in front of_ the anchor cell (the one
// that doesn't move when extending the selection).
this.$anchorCell=$anchorCell,// :: ResolvedPos
// A resolved position pointing in front of the head cell (the one
// moves when extending the selection).
this.$headCell=$headCell}map(doc,mapping){let $anchorCell=doc.resolve(mapping.map(this.$anchorCell.pos)),$headCell=doc.resolve(mapping.map(this.$headCell.pos));if(pointsAtCell$1($anchorCell)&&pointsAtCell$1($headCell)&&inSameTable$1($anchorCell,$headCell)){let tableChanged=this.$anchorCell.node(-1)!=$anchorCell.node(-1);return tableChanged&&this.isRowSelection()?CellSelection$1.rowSelection($anchorCell,$headCell):tableChanged&&this.isColSelection()?CellSelection$1.colSelection($anchorCell,$headCell):new CellSelection$1($anchorCell,$headCell)}return TextSelection$1.between($anchorCell,$headCell)}// :: () → Slice
// Returns a rectangular slice of table rows containing the selected
// cells.
content(){let table=this.$anchorCell.node(-1),map=TableMap$1.get(table),start=this.$anchorCell.start(-1),rect=map.rectBetween(this.$anchorCell.pos-start,this.$headCell.pos-start),seen={},rows=[];for(let row=rect.top;row<rect.bottom;row++){let rowContent=[];for(let index=row*map.width+rect.left,col=rect.left;col<rect.right;col++,index++){let pos=map.map[index];if(!seen[pos]){seen[pos]=!0;let cellRect=map.findCell(pos),cell=table.nodeAt(pos),extraLeft=rect.left-cellRect.left,extraRight=cellRect.right-rect.right;if(extraLeft>0||extraRight>0){let attrs=cell.attrs;extraLeft>0&&(attrs=removeColSpan$1(attrs,0,extraLeft)),extraRight>0&&(attrs=removeColSpan$1(attrs,attrs.colspan-extraRight,extraRight)),cell=cellRect.left<rect.left?cell.type.createAndFill(attrs):cell.type.create(attrs,cell.content)}if(cellRect.top<rect.top||cellRect.bottom>rect.bottom){let attrs=setAttr$1(cell.attrs,"rowspan",Math.min(cellRect.bottom,rect.bottom)-Math.max(cellRect.top,rect.top));cell=cellRect.top<rect.top?cell.type.createAndFill(attrs):cell.type.create(attrs,cell.content)}rowContent.push(cell)}}rows.push(table.child(row).copy(Fragment$1.from(rowContent)))}const fragment=this.isColSelection()&&this.isRowSelection()?table:rows;return new Slice$1(Fragment$1.from(fragment),1,1)}replace(tr,content=Slice$1.empty){let mapFrom=tr.steps.length,ranges=this.ranges;for(let i=0;i<ranges.length;i++){let{$from:$from,$to:$to}=ranges[i],mapping=tr.mapping.slice(mapFrom);tr.replace(mapping.map($from.pos),mapping.map($to.pos),i?Slice$1.empty:content)}let sel=Selection$1.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),-1);sel&&tr.setSelection(sel)}replaceWith(tr,node){this.replace(tr,new Slice$1(Fragment$1.from(node),0,0))}forEachCell(f){let table=this.$anchorCell.node(-1),map=TableMap$1.get(table),start=this.$anchorCell.start(-1),cells=map.cellsInRect(map.rectBetween(this.$anchorCell.pos-start,this.$headCell.pos-start));for(let i=0;i<cells.length;i++)f(table.nodeAt(cells[i]),start+cells[i])}// :: () → bool
// True if this selection goes all the way from the top to the
// bottom of the table.
isColSelection(){let anchorTop=this.$anchorCell.index(-1),headTop=this.$headCell.index(-1);if(Math.min(anchorTop,headTop)>0)return!1;let anchorBot=anchorTop+this.$anchorCell.nodeAfter.attrs.rowspan,headBot=headTop+this.$headCell.nodeAfter.attrs.rowspan;return Math.max(anchorBot,headBot)==this.$headCell.node(-1).childCount}// :: (ResolvedPos, ?ResolvedPos) → CellSelection
// Returns the smallest column selection that covers the given anchor
// and head cell.
static colSelection($anchorCell,$headCell=$anchorCell){let map=TableMap$1.get($anchorCell.node(-1)),start=$anchorCell.start(-1),anchorRect=map.findCell($anchorCell.pos-start),headRect=map.findCell($headCell.pos-start),doc=$anchorCell.node(0);return anchorRect.top<=headRect.top?(anchorRect.top>0&&($anchorCell=doc.resolve(start+map.map[anchorRect.left])),headRect.bottom<map.height&&($headCell=doc.resolve(start+map.map[map.width*(map.height-1)+headRect.right-1]))):(headRect.top>0&&($headCell=doc.resolve(start+map.map[headRect.left])),anchorRect.bottom<map.height&&($anchorCell=doc.resolve(start+map.map[map.width*(map.height-1)+anchorRect.right-1]))),new CellSelection$1($anchorCell,$headCell)}// :: () → bool
// True if this selection goes all the way from the left to the
// right of the table.
isRowSelection(){let map=TableMap$1.get(this.$anchorCell.node(-1)),start=this.$anchorCell.start(-1),anchorLeft=map.colCount(this.$anchorCell.pos-start),headLeft=map.colCount(this.$headCell.pos-start);if(Math.min(anchorLeft,headLeft)>0)return!1;let anchorRight=anchorLeft+this.$anchorCell.nodeAfter.attrs.colspan,headRight=headLeft+this.$headCell.nodeAfter.attrs.colspan;return Math.max(anchorRight,headRight)==map.width}eq(other){return other instanceof CellSelection$1&&other.$anchorCell.pos==this.$anchorCell.pos&&other.$headCell.pos==this.$headCell.pos}// :: (ResolvedPos, ?ResolvedPos) → CellSelection
// Returns the smallest row selection that covers the given anchor
// and head cell.
static rowSelection($anchorCell,$headCell=$anchorCell){let map=TableMap$1.get($anchorCell.node(-1)),start=$anchorCell.start(-1),anchorRect=map.findCell($anchorCell.pos-start),headRect=map.findCell($headCell.pos-start),doc=$anchorCell.node(0);return anchorRect.left<=headRect.left?(anchorRect.left>0&&($anchorCell=doc.resolve(start+map.map[anchorRect.top*map.width])),headRect.right<map.width&&($headCell=doc.resolve(start+map.map[map.width*(headRect.top+1)-1]))):(headRect.left>0&&($headCell=doc.resolve(start+map.map[headRect.top*map.width])),anchorRect.right<map.width&&($anchorCell=doc.resolve(start+map.map[map.width*(anchorRect.top+1)-1]))),new CellSelection$1($anchorCell,$headCell)}toJSON(){return{type:"cell",anchor:this.$anchorCell.pos,head:this.$headCell.pos}}static fromJSON(doc,json){return new CellSelection$1(doc.resolve(json.anchor),doc.resolve(json.head))}// :: (Node, number, ?number) → CellSelection
static create(doc,anchorCell,headCell=anchorCell){return new CellSelection$1(doc.resolve(anchorCell),doc.resolve(headCell))}getBookmark(){return new CellBookmark$1(this.$anchorCell.pos,this.$headCell.pos)}}CellSelection$1.prototype.visible=!1,Selection$1.jsonID("cell",CellSelection$1);class CellBookmark$1{constructor(anchor,head){this.anchor=anchor,this.head=head}map(mapping){return new CellBookmark$1(mapping.map(this.anchor),mapping.map(this.head))}resolve(doc){let $anchorCell=doc.resolve(this.anchor),$headCell=doc.resolve(this.head);return"row"==$anchorCell.parent.type.spec.tableRole&&"row"==$headCell.parent.type.spec.tableRole&&$anchorCell.index()<$anchorCell.parent.childCount&&$headCell.index()<$headCell.parent.childCount&&inSameTable$1($anchorCell,$headCell)?new CellSelection$1($anchorCell,$headCell):Selection$1.near($headCell,1)}}function drawCellSelection$1(state){if(!(state.selection instanceof CellSelection$1))return null;let cells=[];return state.selection.forEachCell(((node,pos)=>{cells.push(Decoration$1.node(pos,pos+node.nodeSize,{class:"selectedCell"}))})),DecorationSet$1.create(state.doc,cells)}function isCellBoundarySelection$1({$from:$from,$to:$to}){if($from.pos==$to.pos||$from.pos<$from.pos-6)return!1;// Cheap elimination
let afterFrom=$from.pos,beforeTo=$to.pos,depth=$from.depth;for(;depth>=0;depth--,afterFrom++)if($from.after(depth+1)<$from.end(depth))break;for(let d=$to.depth;d>=0;d--,beforeTo--)if($to.before(d+1)>$to.start(d))break;return afterFrom==beforeTo&&/row|table/.test($from.node(depth).type.spec.tableRole)}function isTextSelectionAcrossCells$1({$from:$from,$to:$to}){let fromCellBoundaryNode,toCellBoundaryNode;for(let i=$from.depth;i>0;i--){let node=$from.node(i);if("cell"===node.type.spec.tableRole||"header_cell"===node.type.spec.tableRole){fromCellBoundaryNode=node;break}}for(let i=$to.depth;i>0;i--){let node=$to.node(i);if("cell"===node.type.spec.tableRole||"header_cell"===node.type.spec.tableRole){toCellBoundaryNode=node;break}}return fromCellBoundaryNode!==toCellBoundaryNode&&0===$to.parentOffset}function normalizeSelection$1(state,tr,allowTableNodeSelection){let normalize,role,sel=(tr||state).selection,doc=(tr||state).doc;if(sel instanceof NodeSelection$1&&(role=sel.node.type.spec.tableRole)){if("cell"==role||"header_cell"==role)normalize=CellSelection$1.create(doc,sel.from);else if("row"==role){let $cell=doc.resolve(sel.from+1);normalize=CellSelection$1.rowSelection($cell,$cell)}else if(!allowTableNodeSelection){let map=TableMap$1.get(sel.node),start=sel.from+1,lastCell=start+map.map[map.width*map.height-1];normalize=CellSelection$1.create(doc,start+1,lastCell)}}else sel instanceof TextSelection$1&&isCellBoundarySelection$1(sel)?normalize=TextSelection$1.create(doc,sel.from):sel instanceof TextSelection$1&&isTextSelectionAcrossCells$1(sel)&&(normalize=TextSelection$1.create(doc,sel.$from.start(),sel.$from.end()));return normalize&&(tr||(tr=state.tr)).setSelection(normalize),tr}
// Utilities used for copy/paste handling.
// : (Slice) → ?{width: number, height: number, rows: [Fragment]}
// Get a rectangular area of cells from a slice, or null if the outer
// nodes of the slice aren't table cells or rows.
function pastedCells$1(slice){if(!slice.size)return null;let{content:content,openStart:openStart,openEnd:openEnd}=slice;while(1==content.childCount&&(openStart>0&&openEnd>0||"table"==content.firstChild.type.spec.tableRole))openStart--,openEnd--,content=content.firstChild.content;let first=content.firstChild,role=first.type.spec.tableRole,schema=first.type.schema,rows=[];if("row"==role)for(let i=0;i<content.childCount;i++){let cells=content.child(i).content,left=i?0:Math.max(0,openStart-1),right=i<content.childCount-1?0:Math.max(0,openEnd-1);(left||right)&&(cells=fitSlice$1(tableNodeTypes$1(schema).row,new Slice$1(cells,left,right)).content),rows.push(cells)}else{if("cell"!=role&&"header_cell"!=role)return null;rows.push(openStart||openEnd?fitSlice$1(tableNodeTypes$1(schema).row,new Slice$1(content,openStart,openEnd)).content:content)}return ensureRectangular$1(schema,rows)}// : (Schema, [Fragment]) → {width: number, height: number, rows: [Fragment]}
// Compute the width and height of a set of cells, and make sure each
// row has the same number of cells.
function ensureRectangular$1(schema,rows){let widths=[];for(let i=0;i<rows.length;i++){let row=rows[i];for(let j=row.childCount-1;j>=0;j--){let{rowspan:rowspan,colspan:colspan}=row.child(j).attrs;for(let r=i;r<i+rowspan;r++)widths[r]=(widths[r]||0)+colspan}}let width=0;for(let r=0;r<widths.length;r++)width=Math.max(width,widths[r]);for(let r=0;r<widths.length;r++)if(r>=rows.length&&rows.push(Fragment$1.empty),widths[r]<width){let empty=tableNodeTypes$1(schema).cell.createAndFill(),cells=[];for(let i=widths[r];i<width;i++)cells.push(empty);rows[r]=rows[r].append(Fragment$1.from(cells))}return{height:rows.length,width:width,rows:rows}}function fitSlice$1(nodeType,slice){let node=nodeType.createAndFill(),tr=new Transform$1(node).replace(0,node.content.size,slice);return tr.doc}// : ({width: number, height: number, rows: [Fragment]}, number, number) → {width: number, height: number, rows: [Fragment]}
// Clip or extend (repeat) the given set of cells to cover the given
// width and height. Will clip rowspan/colspan cells at the edges when
// they stick out.
function clipCells$1({width:width,height:height,rows:rows},newWidth,newHeight){if(width!=newWidth){let added=[],newRows=[];for(let row=0;row<rows.length;row++){let frag=rows[row],cells=[];for(let col=added[row]||0,i=0;col<newWidth;i++){let cell=frag.child(i%frag.childCount);col+cell.attrs.colspan>newWidth&&(cell=cell.type.create(removeColSpan$1(cell.attrs,cell.attrs.colspan,col+cell.attrs.colspan-newWidth),cell.content)),cells.push(cell),col+=cell.attrs.colspan;for(let j=1;j<cell.attrs.rowspan;j++)added[row+j]=(added[row+j]||0)+cell.attrs.colspan}newRows.push(Fragment$1.from(cells))}rows=newRows,width=newWidth}if(height!=newHeight){let newRows=[];for(let row=0,i=0;row<newHeight;row++,i++){let cells=[],source=rows[i%height];for(let j=0;j<source.childCount;j++){let cell=source.child(j);row+cell.attrs.rowspan>newHeight&&(cell=cell.type.create(setAttr$1(cell.attrs,"rowspan",Math.max(1,newHeight-cell.attrs.rowspan)),cell.content)),cells.push(cell)}newRows.push(Fragment$1.from(cells))}rows=newRows,height=newHeight}return{width:width,height:height,rows:rows}}// Make sure a table has at least the given width and height. Return
// true if something was changed.
function growTable$1(tr,map,table,start,width,height,mapFrom){let empty,emptyHead,schema=tr.doc.type.schema,types=tableNodeTypes$1(schema);if(width>map.width)for(let row=0,rowEnd=0;row<map.height;row++){let rowNode=table.child(row);rowEnd+=rowNode.nodeSize;let add,cells=[];add=null==rowNode.lastChild||rowNode.lastChild.type==types.cell?empty||(empty=types.cell.createAndFill()):emptyHead||(emptyHead=types.header_cell.createAndFill());for(let i=map.width;i<width;i++)cells.push(add);tr.insert(tr.mapping.slice(mapFrom).map(rowEnd-1+start),cells)}if(height>map.height){let cells=[];for(let i=0,start=(map.height-1)*map.width;i<Math.max(map.width,width);i++){let header=!(i>=map.width)&&table.nodeAt(map.map[start+i]).type==types.header_cell;cells.push(header?emptyHead||(emptyHead=types.header_cell.createAndFill()):empty||(empty=types.cell.createAndFill()))}let emptyRow=types.row.create(null,Fragment$1.from(cells)),rows=[];for(let i=map.height;i<height;i++)rows.push(emptyRow);tr.insert(tr.mapping.slice(mapFrom).map(start+table.nodeSize-2),rows)}return!(!empty&&!emptyHead)}// Make sure the given line (left, top) to (right, top) doesn't cross
// any rowspan cells by splitting cells that cross it. Return true if
// something changed.
function isolateHorizontal$1(tr,map,table,start,left,right,top,mapFrom){if(0==top||top==map.height)return!1;let found=!1;for(let col=left;col<right;col++){let index=top*map.width+col,pos=map.map[index];if(map.map[index-map.width]==pos){found=!0;let cell=table.nodeAt(pos),{top:cellTop,left:cellLeft}=map.findCell(pos);tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos+start),null,setAttr$1(cell.attrs,"rowspan",top-cellTop)),tr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top,cellLeft,table)),cell.type.createAndFill(setAttr$1(cell.attrs,"rowspan",cellTop+cell.attrs.rowspan-top))),col+=cell.attrs.colspan-1}}return found}// Make sure the given line (left, top) to (left, bottom) doesn't
// cross any colspan cells by splitting cells that cross it. Return
// true if something changed.
function isolateVertical$1(tr,map,table,start,top,bottom,left,mapFrom){if(0==left||left==map.width)return!1;let found=!1;for(let row=top;row<bottom;row++){let index=row*map.width+left,pos=map.map[index];if(map.map[index-1]==pos){found=!0;let cell=table.nodeAt(pos),cellLeft=map.colCount(pos),updatePos=tr.mapping.slice(mapFrom).map(pos+start);tr.setNodeMarkup(updatePos,null,removeColSpan$1(cell.attrs,left-cellLeft,cell.attrs.colspan-(left-cellLeft))),tr.insert(updatePos+cell.nodeSize,cell.type.createAndFill(removeColSpan$1(cell.attrs,0,left-cellLeft))),row+=cell.attrs.rowspan-1}}return found}// Insert the given set of cells (as returned by `pastedCells`) into a
// table, at the position pointed at by rect.
function insertCells$1(state,dispatch,tableStart,rect,cells){let table=tableStart?state.doc.nodeAt(tableStart-1):state.doc,map=TableMap$1.get(table),{top:top,left:left}=rect,right=left+cells.width,bottom=top+cells.height,tr=state.tr,mapFrom=0;function recomp(){table=tableStart?tr.doc.nodeAt(tableStart-1):tr.doc,map=TableMap$1.get(table),mapFrom=tr.mapping.maps.length}// Prepare the table to be large enough and not have any cells
// crossing the boundaries of the rectangle that we want to
// insert into. If anything about it changes, recompute the table
// map so that subsequent operations can see the current shape.
growTable$1(tr,map,table,tableStart,right,bottom,mapFrom)&&recomp(),isolateHorizontal$1(tr,map,table,tableStart,left,right,top,mapFrom)&&recomp(),isolateHorizontal$1(tr,map,table,tableStart,left,right,bottom,mapFrom)&&recomp(),isolateVertical$1(tr,map,table,tableStart,top,bottom,left,mapFrom)&&recomp(),isolateVertical$1(tr,map,table,tableStart,top,bottom,right,mapFrom)&&recomp();for(let row=top;row<bottom;row++){let from=map.positionAt(row,left,table),to=map.positionAt(row,right,table);tr.replace(tr.mapping.slice(mapFrom).map(from+tableStart),tr.mapping.slice(mapFrom).map(to+tableStart),new Slice$1(cells.rows[row-top],0,0))}recomp(),tr.setSelection(new CellSelection$1(tr.doc.resolve(tableStart+map.positionAt(top,left,table)),tr.doc.resolve(tableStart+map.positionAt(bottom-1,right-1,table)))),dispatch(tr)}
// This file defines a number of helpers for wiring up user input to
const handleKeyDown$1$1=keydownHandler$1({ArrowLeft:arrow$2$1("horiz",-1),ArrowRight:arrow$2$1("horiz",1),ArrowUp:arrow$2$1("vert",-1),ArrowDown:arrow$2$1("vert",1),"Shift-ArrowLeft":shiftArrow$1("horiz",-1),"Shift-ArrowRight":shiftArrow$1("horiz",1),"Shift-ArrowUp":shiftArrow$1("vert",-1),"Shift-ArrowDown":shiftArrow$1("vert",1),Backspace:deleteCellSelection$1,"Mod-Backspace":deleteCellSelection$1,Delete:deleteCellSelection$1,"Mod-Delete":deleteCellSelection$1});function maybeSetSelection$1(state,dispatch,selection){return!selection.eq(state.selection)&&(dispatch&&dispatch(state.tr.setSelection(selection).scrollIntoView()),!0)}function arrow$2$1(axis,dir){return(state,dispatch,view)=>{let sel=state.selection;if(sel instanceof CellSelection$1)return maybeSetSelection$1(state,dispatch,Selection$1.near(sel.$headCell,dir));if("horiz"!=axis&&!sel.empty)return!1;let end=atEndOfCell$1(view,axis,dir);if(null==end)return!1;if("horiz"==axis)return maybeSetSelection$1(state,dispatch,Selection$1.near(state.doc.resolve(sel.head+dir),dir));{let newSel,$cell=state.doc.resolve(end),$next=nextCell$1($cell,axis,dir);return newSel=$next?Selection$1.near($next,1):dir<0?Selection$1.near(state.doc.resolve($cell.before(-1)),-1):Selection$1.near(state.doc.resolve($cell.after(-1)),1),maybeSetSelection$1(state,dispatch,newSel)}}}function shiftArrow$1(axis,dir){return(state,dispatch,view)=>{let sel=state.selection;if(!(sel instanceof CellSelection$1)){let end=atEndOfCell$1(view,axis,dir);if(null==end)return!1;sel=new CellSelection$1(state.doc.resolve(end))}let $head=nextCell$1(sel.$headCell,axis,dir);return!!$head&&maybeSetSelection$1(state,dispatch,new CellSelection$1(sel.$anchorCell,$head))}}function deleteCellSelection$1(state,dispatch){let sel=state.selection;if(!(sel instanceof CellSelection$1))return!1;if(dispatch){let tr=state.tr,baseContent=tableNodeTypes$1(state.schema).cell.createAndFill().content;sel.forEachCell(((cell,pos)=>{cell.content.eq(baseContent)||tr.replace(tr.mapping.map(pos+1),tr.mapping.map(pos+cell.nodeSize-1),new Slice$1(baseContent,0,0))})),tr.docChanged&&dispatch(tr)}return!0}function handleTripleClick$2(view,pos){let doc=view.state.doc,$cell=cellAround$1(doc.resolve(pos));return!!$cell&&(view.dispatch(view.state.tr.setSelection(new CellSelection$1($cell))),!0)}function handlePaste$1(view,_,slice){if(!isInTable$1(view.state))return!1;let cells=pastedCells$1(slice),sel=view.state.selection;if(sel instanceof CellSelection$1){cells||(cells={width:1,height:1,rows:[Fragment$1.from(fitSlice$1(tableNodeTypes$1(view.state.schema).cell,slice))]});let table=sel.$anchorCell.node(-1),start=sel.$anchorCell.start(-1),rect=TableMap$1.get(table).rectBetween(sel.$anchorCell.pos-start,sel.$headCell.pos-start);return cells=clipCells$1(cells,rect.right-rect.left,rect.bottom-rect.top),insertCells$1(view.state,view.dispatch,start,rect,cells),!0}if(cells){let $cell=selectionCell$1(view.state),start=$cell.start(-1);return insertCells$1(view.state,view.dispatch,start,TableMap$1.get($cell.node(-1)).findCell($cell.pos-start),cells),!0}return!1}function handleMouseDown$1$1(view,startEvent){if(startEvent.ctrlKey||startEvent.metaKey)return;let $anchor,startDOMCell=domInCell$1(view,startEvent.target);if(startEvent.shiftKey&&view.state.selection instanceof CellSelection$1)
// Adding to an existing cell selection
setCellSelection(view.state.selection.$anchorCell,startEvent),startEvent.preventDefault();else if(startEvent.shiftKey&&startDOMCell&&null!=($anchor=cellAround$1(view.state.selection.$anchor))&&cellUnderMouse$1(view,startEvent).pos!=$anchor.pos)
// Adding to a selection that starts in another cell (causing a
// cell selection to be created).
setCellSelection($anchor,startEvent),startEvent.preventDefault();else if(!startDOMCell)
// Not in a cell, let the default behavior happen.
return;// Create and dispatch a cell selection between the given anchor and
// the position under the mouse.
function setCellSelection($anchor,event){let $head=cellUnderMouse$1(view,event),starting=null==key$1$1.getState(view.state);if(!$head||!inSameTable$1($anchor,$head)){if(!starting)return;$head=$anchor}let selection=new CellSelection$1($anchor,$head);if(starting||!view.state.selection.eq(selection)){let tr=view.state.tr.setSelection(selection);starting&&tr.setMeta(key$1$1,$anchor.pos),view.dispatch(tr)}}// Stop listening to mouse motion events.
function stop(){view.root.removeEventListener("mouseup",stop),view.root.removeEventListener("dragstart",stop),view.root.removeEventListener("mousemove",move),null!=key$1$1.getState(view.state)&&view.dispatch(view.state.tr.setMeta(key$1$1,-1))}function move(event){let $anchor,anchor=key$1$1.getState(view.state);if(null!=anchor)
// Continuing an existing cross-cell selection
$anchor=view.state.doc.resolve(anchor);else if(domInCell$1(view,event.target)!=startDOMCell&&(
// Moving out of the initial cell -- start a new cell selection
$anchor=cellUnderMouse$1(view,startEvent),!$anchor))return stop();$anchor&&setCellSelection($anchor,event)}view.root.addEventListener("mouseup",stop),view.root.addEventListener("dragstart",stop),view.root.addEventListener("mousemove",move)}// Check whether the cursor is at the end of a cell (so that further
// motion would move out of the cell)
function atEndOfCell$1(view,axis,dir){if(!(view.state.selection instanceof TextSelection$1))return null;let{$head:$head}=view.state.selection;for(let d=$head.depth-1;d>=0;d--){let parent=$head.node(d),index=dir<0?$head.index(d):$head.indexAfter(d);if(index!=(dir<0?0:parent.childCount))return null;if("cell"==parent.type.spec.tableRole||"header_cell"==parent.type.spec.tableRole){let cellPos=$head.before(d),dirStr="vert"==axis?dir>0?"down":"up":dir>0?"right":"left";return view.endOfTextblock(dirStr)?cellPos:null}}return null}function domInCell$1(view,dom){for(;dom&&dom!=view.dom;dom=dom.parentNode)if("TD"==dom.nodeName||"TH"==dom.nodeName)return dom}function cellUnderMouse$1(view,event){let mousePos=view.posAtCoords({left:event.clientX,top:event.clientY});return mousePos&&mousePos?cellAround$1(view.state.doc.resolve(mousePos.pos)):null}
// This file defines helpers for normalizing tables, making sure no
const fixTablesKey$1=new PluginKey$1("fix-tables");// Helper for iterating through the nodes in a document that changed
// compared to the given previous document. Useful for avoiding
// duplicate work on each transaction.
function changedDescendants$1(old,cur,offset,f){let oldSize=old.childCount,curSize=cur.childCount;outer:for(let i=0,j=0;i<curSize;i++){let child=cur.child(i);for(let scan=j,e=Math.min(oldSize,i+3);scan<e;scan++)if(old.child(scan)==child){j=scan+1,offset+=child.nodeSize;continue outer}f(child,offset),j<oldSize&&old.child(j).sameMarkup(child)?changedDescendants$1(old.child(j),child,offset+1,f):child.nodesBetween(0,child.content.size,f,offset+1),offset+=child.nodeSize}}// :: (EditorState, ?EditorState) → ?Transaction
// Inspect all tables in the given state's document and return a
// transaction that fixes them, if necessary. If `oldState` was
// provided, that is assumed to hold a previous, known-good state,
// which will be used to avoid re-scanning unchanged parts of the
// document.
function fixTables$1(state,oldState){let tr,check=(node,pos)=>{"table"==node.type.spec.tableRole&&(tr=fixTable$1(state,node,pos,tr))};return oldState?oldState.doc!=state.doc&&changedDescendants$1(oldState.doc,state.doc,0,check):state.doc.descendants(check),tr}// : (EditorState, Node, number, ?Transaction) → ?Transaction
// Fix the given table, if necessary. Will append to the transaction
// it was given, if non-null, or create a new one if necessary.
function fixTable$1(state,table,tablePos,tr){let map=TableMap$1.get(table);if(!map.problems)return tr;tr||(tr=state.tr);// Track which rows we must add cells to, so that we can adjust that
// when fixing collisions.
let first,last,mustAdd=[];for(let i=0;i<map.height;i++)mustAdd.push(0);for(let i=0;i<map.problems.length;i++){let prob=map.problems[i];if("collision"==prob.type){let cell=table.nodeAt(prob.pos);for(let j=0;j<cell.attrs.rowspan;j++)mustAdd[prob.row+j]+=prob.n;tr.setNodeMarkup(tr.mapping.map(tablePos+1+prob.pos),null,removeColSpan$1(cell.attrs,cell.attrs.colspan-prob.n,prob.n))}else if("missing"==prob.type)mustAdd[prob.row]+=prob.n;else if("overlong_rowspan"==prob.type){let cell=table.nodeAt(prob.pos);tr.setNodeMarkup(tr.mapping.map(tablePos+1+prob.pos),null,setAttr$1(cell.attrs,"rowspan",cell.attrs.rowspan-prob.n))}else if("colwidth mismatch"==prob.type){let cell=table.nodeAt(prob.pos);tr.setNodeMarkup(tr.mapping.map(tablePos+1+prob.pos),null,setAttr$1(cell.attrs,"colwidth",prob.colwidth))}}for(let i=0;i<mustAdd.length;i++)mustAdd[i]&&(null==first&&(first=i),last=i);// Add the necessary cells, using a heuristic for whether to add the
// cells at the start or end of the rows (if it looks like a 'bite'
// was taken out of the table, add cells at the start of the row
// after the bite. Otherwise add them at the end).
for(let i=0,pos=tablePos+1;i<map.height;i++){let row=table.child(i),end=pos+row.nodeSize,add=mustAdd[i];if(add>0){let tableNodeType="cell";row.firstChild&&(tableNodeType=row.firstChild.type.spec.tableRole);let nodes=[];for(let j=0;j<add;j++)nodes.push(tableNodeTypes$1(state.schema)[tableNodeType].createAndFill());let side=0!=i&&first!=i-1||last!=i?end-1:pos+1;tr.insert(tr.mapping.map(side),nodes)}pos=end}return tr.setMeta(fixTablesKey$1,{fixTables:!0})}
// This file defines a number of table-related commands.
// map, table node, and table start offset to the object for
// convenience.
function selectedRect$1(state){let rect,sel=state.selection,$pos=selectionCell$1(state),table=$pos.node(-1),tableStart=$pos.start(-1),map=TableMap$1.get(table);return rect=sel instanceof CellSelection$1?map.rectBetween(sel.$anchorCell.pos-tableStart,sel.$headCell.pos-tableStart):map.findCell($pos.pos-tableStart),rect.tableStart=tableStart,rect.map=map,rect.table=table,rect}// Add a column at the given position in a table.
function addColumn$1(tr,{map:map,tableStart:tableStart,table:table},col){let refColumn=col>0?-1:0;columnIsHeader$1(map,table,col+refColumn)&&(refColumn=0==col||col==map.width?null:0);for(let row=0;row<map.height;row++){let index=row*map.width+col;// If this position falls inside a col-spanning cell
if(col>0&&col<map.width&&map.map[index-1]==map.map[index]){let pos=map.map[index],cell=table.nodeAt(pos);tr.setNodeMarkup(tr.mapping.map(tableStart+pos),null,addColSpan$1(cell.attrs,col-map.colCount(pos))),// Skip ahead if rowspan > 1
row+=cell.attrs.rowspan-1}else{let type=null==refColumn?tableNodeTypes$1(table.type.schema).cell:table.nodeAt(map.map[index+refColumn]).type,pos=map.positionAt(row,col,table);tr.insert(tr.mapping.map(tableStart+pos),type.createAndFill())}}return tr}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Command to add a column before the column with the selection.
function addColumnBefore$1(state,dispatch){if(!isInTable$1(state))return!1;if(dispatch){let rect=selectedRect$1(state);dispatch(addColumn$1(state.tr,rect,rect.left))}return!0}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Command to add a column after the column with the selection.
function addColumnAfter$1(state,dispatch){if(!isInTable$1(state))return!1;if(dispatch){let rect=selectedRect$1(state);dispatch(addColumn$1(state.tr,rect,rect.right))}return!0}function removeColumn$1(tr,{map:map,table:table,tableStart:tableStart},col){let mapStart=tr.mapping.maps.length;for(let row=0;row<map.height;){let index=row*map.width+col,pos=map.map[index],cell=table.nodeAt(pos);// If this is part of a col-spanning cell
if(col>0&&map.map[index-1]==pos||col<map.width-1&&map.map[index+1]==pos)tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart+pos),null,removeColSpan$1(cell.attrs,col-map.colCount(pos)));else{let start=tr.mapping.slice(mapStart).map(tableStart+pos);tr.delete(start,start+cell.nodeSize)}row+=cell.attrs.rowspan}}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Command function that removes the selected columns from a table.
function deleteColumn$1(state,dispatch){if(!isInTable$1(state))return!1;if(dispatch){let rect=selectedRect$1(state),tr=state.tr;if(0==rect.left&&rect.right==rect.map.width)return!1;for(let i=rect.right-1;;i--){if(removeColumn$1(tr,rect,i),i==rect.left)break;rect.table=rect.tableStart?tr.doc.nodeAt(rect.tableStart-1):tr.doc,rect.map=TableMap$1.get(rect.table)}dispatch(tr)}return!0}function rowIsHeader$1(map,table,row){let headerCell=tableNodeTypes$1(table.type.schema).header_cell;for(let col=0;col<map.width;col++)if(table.nodeAt(map.map[col+row*map.width]).type!=headerCell)return!1;return!0}function addRow$1(tr,{map:map,tableStart:tableStart,table:table},row){let rowPos=tableStart;for(let i=0;i<row;i++)rowPos+=table.child(i).nodeSize;let cells=[],refRow=row>0?-1:0;rowIsHeader$1(map,table,row+refRow)&&(refRow=0==row||row==map.height?null:0);for(let col=0,index=map.width*row;col<map.width;col++,index++)
// Covered by a rowspan cell
if(row>0&&row<map.height&&map.map[index]==map.map[index-map.width]){let pos=map.map[index],attrs=table.nodeAt(pos).attrs;tr.setNodeMarkup(tableStart+pos,null,setAttr$1(attrs,"rowspan",attrs.rowspan+1)),col+=attrs.colspan-1}else{let type=null==refRow?tableNodeTypes$1(table.type.schema).cell:table.nodeAt(map.map[index+refRow*map.width]).type;cells.push(type.createAndFill())}return tr.insert(rowPos,tableNodeTypes$1(table.type.schema).row.create(null,cells)),tr}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Add a table row before the selection.
function addRowBefore$1(state,dispatch){if(!isInTable$1(state))return!1;if(dispatch){let rect=selectedRect$1(state);dispatch(addRow$1(state.tr,rect,rect.top))}return!0}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Add a table row after the selection.
function addRowAfter$1(state,dispatch){if(!isInTable$1(state))return!1;if(dispatch){let rect=selectedRect$1(state);dispatch(addRow$1(state.tr,rect,rect.bottom))}return!0}function removeRow$1(tr,{map:map,table:table,tableStart:tableStart},row){let rowPos=0;for(let i=0;i<row;i++)rowPos+=table.child(i).nodeSize;let nextRow=rowPos+table.child(row).nodeSize,mapFrom=tr.mapping.maps.length;tr.delete(rowPos+tableStart,nextRow+tableStart);for(let col=0,index=row*map.width;col<map.width;col++,index++){let pos=map.map[index];if(row>0&&pos==map.map[index-map.width]){
// If this cell starts in the row above, simply reduce its rowspan
let attrs=table.nodeAt(pos).attrs;tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos+tableStart),null,setAttr$1(attrs,"rowspan",attrs.rowspan-1)),col+=attrs.colspan-1}else if(row<map.width&&pos==map.map[index+map.width]){
// Else, if it continues in the row below, it has to be moved down
let cell=table.nodeAt(pos),copy=cell.type.create(setAttr$1(cell.attrs,"rowspan",cell.attrs.rowspan-1),cell.content),newPos=map.positionAt(row+1,col,table);tr.insert(tr.mapping.slice(mapFrom).map(tableStart+newPos),copy),col+=cell.attrs.colspan-1}}}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Remove the selected rows from a table.
function deleteRow$1(state,dispatch){if(!isInTable$1(state))return!1;if(dispatch){let rect=selectedRect$1(state),tr=state.tr;if(0==rect.top&&rect.bottom==rect.map.height)return!1;for(let i=rect.bottom-1;;i--){if(removeRow$1(tr,rect,i),i==rect.top)break;rect.table=rect.tableStart?tr.doc.nodeAt(rect.tableStart-1):tr.doc,rect.map=TableMap$1.get(rect.table)}dispatch(tr)}return!0}function isEmpty$3(cell){let c=cell.content;return 1==c.childCount&&c.firstChild.isTextblock&&0==c.firstChild.childCount}function cellsOverlapRectangle$1({width:width,height:height,map:map},rect){let indexTop=rect.top*width+rect.left,indexLeft=indexTop,indexBottom=(rect.bottom-1)*width+rect.left,indexRight=indexTop+(rect.right-rect.left-1);for(let i=rect.top;i<rect.bottom;i++){if(rect.left>0&&map[indexLeft]==map[indexLeft-1]||rect.right<width&&map[indexRight]==map[indexRight+1])return!0;indexLeft+=width,indexRight+=width}for(let i=rect.left;i<rect.right;i++){if(rect.top>0&&map[indexTop]==map[indexTop-width]||rect.bottom<height&&map[indexBottom]==map[indexBottom+width])return!0;indexTop++,indexBottom++}return!1}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Merge the selected cells into a single cell. Only available when
// the selected cells' outline forms a rectangle.
function mergeCells$1(state,dispatch){let sel=state.selection;if(!(sel instanceof CellSelection$1)||sel.$anchorCell.pos==sel.$headCell.pos)return!1;let rect=selectedRect$1(state),{map:map}=rect;if(cellsOverlapRectangle$1(map,rect))return!1;if(dispatch){let mergedPos,mergedCell,tr=state.tr,seen={},content=Fragment$1.empty;for(let row=rect.top;row<rect.bottom;row++)for(let col=rect.left;col<rect.right;col++){let cellPos=map.map[row*map.width+col],cell=rect.table.nodeAt(cellPos);if(!seen[cellPos])if(seen[cellPos]=!0,null==mergedPos)mergedPos=cellPos,mergedCell=cell;else{isEmpty$3(cell)||(content=content.append(cell.content));let mapped=tr.mapping.map(cellPos+rect.tableStart);tr.delete(mapped,mapped+cell.nodeSize)}}if(tr.setNodeMarkup(mergedPos+rect.tableStart,null,setAttr$1(addColSpan$1(mergedCell.attrs,mergedCell.attrs.colspan,rect.right-rect.left-mergedCell.attrs.colspan),"rowspan",rect.bottom-rect.top)),content.size){let end=mergedPos+1+mergedCell.content.size,start=isEmpty$3(mergedCell)?mergedPos+1:end;tr.replaceWith(start+rect.tableStart,end+rect.tableStart,content)}tr.setSelection(new CellSelection$1(tr.doc.resolve(mergedPos+rect.tableStart))),dispatch(tr)}return!0}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Split a selected cell, whose rowpan or colspan is greater than one,
// into smaller cells. Use the first cell type for the new cells.
function splitCell$1(state,dispatch){const nodeTypes=tableNodeTypes$1(state.schema);return splitCellWithType$1((({node:node})=>nodeTypes[node.type.spec.tableRole]))(state,dispatch)}// :: (getCellType: ({ row: number, col: number, node: Node}) → NodeType) → (EditorState, dispatch: ?(tr: Transaction)) → bool
// Split a selected cell, whose rowpan or colspan is greater than one,
// into smaller cells with the cell type (th, td) returned by getType function.
function splitCellWithType$1(getCellType){return(state,dispatch)=>{let cellNode,cellPos,sel=state.selection;if(sel instanceof CellSelection$1){if(sel.$anchorCell.pos!=sel.$headCell.pos)return!1;cellNode=sel.$anchorCell.nodeAfter,cellPos=sel.$anchorCell.pos}else{if(cellNode=cellWrapping$1(sel.$from),!cellNode)return!1;cellPos=cellAround$1(sel.$from).pos}if(1==cellNode.attrs.colspan&&1==cellNode.attrs.rowspan)return!1;if(dispatch){let baseAttrs=cellNode.attrs,attrs=[],colwidth=baseAttrs.colwidth;baseAttrs.rowspan>1&&(baseAttrs=setAttr$1(baseAttrs,"rowspan",1)),baseAttrs.colspan>1&&(baseAttrs=setAttr$1(baseAttrs,"colspan",1));let lastCell,rect=selectedRect$1(state),tr=state.tr;for(let i=0;i<rect.right-rect.left;i++)attrs.push(colwidth?setAttr$1(baseAttrs,"colwidth",colwidth&&colwidth[i]?[colwidth[i]]:null):baseAttrs);for(let row=rect.top;row<rect.bottom;row++){let pos=rect.map.positionAt(row,rect.left,rect.table);row==rect.top&&(pos+=cellNode.nodeSize);for(let col=rect.left,i=0;col<rect.right;col++,i++)col==rect.left&&row==rect.top||tr.insert(lastCell=tr.mapping.map(pos+rect.tableStart,1),getCellType({node:cellNode,row:row,col:col}).createAndFill(attrs[i]))}tr.setNodeMarkup(cellPos,getCellType({node:cellNode,row:rect.top,col:rect.left}),attrs[0]),sel instanceof CellSelection$1&&tr.setSelection(new CellSelection$1(tr.doc.resolve(sel.$anchorCell.pos),lastCell&&tr.doc.resolve(lastCell))),dispatch(tr)}return!0}}// :: (string, any) → (EditorState, dispatch: ?(tr: Transaction)) → bool
// Returns a command that sets the given attribute to the given value,
// and is only available when the currently selected cell doesn't
// already have that attribute set to that value.
function setCellAttr$1(name,value){return function(state,dispatch){if(!isInTable$1(state))return!1;let $cell=selectionCell$1(state);if($cell.nodeAfter.attrs[name]===value)return!1;if(dispatch){let tr=state.tr;state.selection instanceof CellSelection$1?state.selection.forEachCell(((node,pos)=>{node.attrs[name]!==value&&tr.setNodeMarkup(pos,null,setAttr$1(node.attrs,name,value))})):tr.setNodeMarkup($cell.pos,null,setAttr$1($cell.nodeAfter.attrs,name,value)),dispatch(tr)}return!0}}function deprecated_toggleHeader$1(type){return function(state,dispatch){if(!isInTable$1(state))return!1;if(dispatch){let types=tableNodeTypes$1(state.schema),rect=selectedRect$1(state),tr=state.tr,cells=rect.map.cellsInRect("column"==type?new Rect$1(rect.left,0,rect.right,rect.map.height):"row"==type?new Rect$1(0,rect.top,rect.map.width,rect.bottom):rect),nodes=cells.map((pos=>rect.table.nodeAt(pos)));for(let i=0;i<cells.length;i++)nodes[i].type==types.header_cell&&tr.setNodeMarkup(rect.tableStart+cells[i],types.cell,nodes[i].attrs);if(0==tr.steps.length)for(let i=0;i<cells.length;i++)tr.setNodeMarkup(rect.tableStart+cells[i],types.header_cell,nodes[i].attrs);dispatch(tr)}return!0}}function isHeaderEnabledByType$1(type,rect,types){
// Get cell positions for first row or first column
const cellPositions=rect.map.cellsInRect({left:0,top:0,right:"row"==type?rect.map.width:1,bottom:"column"==type?rect.map.height:1});for(let i=0;i<cellPositions.length;i++){const cell=rect.table.nodeAt(cellPositions[i]);if(cell&&cell.type!==types.header_cell)return!1}return!0}// :: (string, ?{ useDeprecatedLogic: bool }) → (EditorState, dispatch: ?(tr: Transaction)) → bool
// Toggles between row/column header and normal cells (Only applies to first row/column).
// For deprecated behavior pass `useDeprecatedLogic` in options with true.
function toggleHeader$1(type,options){return options=options||{useDeprecatedLogic:!1},options.useDeprecatedLogic?deprecated_toggleHeader$1(type):function(state,dispatch){if(!isInTable$1(state))return!1;if(dispatch){let types=tableNodeTypes$1(state.schema),rect=selectedRect$1(state),tr=state.tr,isHeaderRowEnabled=isHeaderEnabledByType$1("row",rect,types),isHeaderColumnEnabled=isHeaderEnabledByType$1("column",rect,types),isHeaderEnabled="column"===type?isHeaderRowEnabled:"row"===type&&isHeaderColumnEnabled,selectionStartsAt=isHeaderEnabled?1:0,cellsRect="column"==type?new Rect$1(0,selectionStartsAt,1,rect.map.height):"row"==type?new Rect$1(selectionStartsAt,0,rect.map.width,1):rect,newType="column"==type?isHeaderColumnEnabled?types.cell:types.header_cell:"row"==type?isHeaderRowEnabled?types.cell:types.header_cell:types.cell;rect.map.cellsInRect(cellsRect).forEach((relativeCellPos=>{const cellPos=relativeCellPos+rect.tableStart,cell=tr.doc.nodeAt(cellPos);cell&&tr.setNodeMarkup(cellPos,newType,cell.attrs)})),dispatch(tr)}return!0}}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Toggles whether the selected row contains header cells.
toggleHeader$1("row",{useDeprecatedLogic:!0}),// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Toggles whether the selected column contains header cells.
toggleHeader$1("column",{useDeprecatedLogic:!0});// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Toggles whether the selected cells are header cells.
let toggleHeaderCell$1=toggleHeader$1("cell",{useDeprecatedLogic:!0});function findNextCell$1($cell,dir){if(dir<0){let before=$cell.nodeBefore;if(before)return $cell.pos-before.nodeSize;for(let row=$cell.index(-1)-1,rowEnd=$cell.before();row>=0;row--){let rowNode=$cell.node(-1).child(row);if(rowNode.childCount)return rowEnd-1-rowNode.lastChild.nodeSize;rowEnd-=rowNode.nodeSize}}else{if($cell.index()<$cell.parent.childCount-1)return $cell.pos+$cell.nodeAfter.nodeSize;let table=$cell.node(-1);for(let row=$cell.indexAfter(-1),rowStart=$cell.after();row<table.childCount;row++){let rowNode=table.child(row);if(rowNode.childCount)return rowStart+1;rowStart+=rowNode.nodeSize}}}// :: (number) → (EditorState, dispatch: ?(tr: Transaction)) → bool
// Returns a command for selecting the next (direction=1) or previous
// (direction=-1) cell in a table.
function goToNextCell$1(direction){return function(state,dispatch){if(!isInTable$1(state))return!1;let cell=findNextCell$1(selectionCell$1(state),direction);if(null!=cell){if(dispatch){let $cell=state.doc.resolve(cell);dispatch(state.tr.setSelection(TextSelection$1.between($cell,moveCellForward$1($cell))).scrollIntoView())}return!0}}}// :: (EditorState, ?(tr: Transaction)) → bool
// Deletes the table around the selection, if any.
function deleteTable$1(state,dispatch){let $pos=state.selection.$anchor;for(let d=$pos.depth;d>0;d--){let node=$pos.node(d);if("table"==node.type.spec.tableRole)return dispatch&&dispatch(state.tr.delete($pos.before(d),$pos.after(d)).scrollIntoView()),!0}return!1}class TableView$1$1{constructor(node,cellMinWidth){this.node=node,this.cellMinWidth=cellMinWidth,this.dom=document.createElement("div"),this.dom.className="tableWrapper",this.table=this.dom.appendChild(document.createElement("table")),this.colgroup=this.table.appendChild(document.createElement("colgroup")),updateColumns$1$1(node,this.colgroup,this.table,cellMinWidth),this.contentDOM=this.table.appendChild(document.createElement("tbody"))}update(node){return node.type==this.node.type&&(this.node=node,updateColumns$1$1(node,this.colgroup,this.table,this.cellMinWidth),!0)}ignoreMutation(record){return"attributes"==record.type&&(record.target==this.table||this.colgroup.contains(record.target))}}function updateColumns$1$1(node,colgroup,table,cellMinWidth,overrideCol,overrideValue){let totalWidth=0,fixedWidth=!0,nextDOM=colgroup.firstChild,row=node.firstChild;for(let i=0,col=0;i<row.childCount;i++){let{colspan:colspan,colwidth:colwidth}=row.child(i).attrs;for(let j=0;j<colspan;j++,col++){let hasWidth=overrideCol==col?overrideValue:colwidth&&colwidth[j],cssWidth=hasWidth?hasWidth+"px":"";totalWidth+=hasWidth||cellMinWidth,hasWidth||(fixedWidth=!1),nextDOM?(nextDOM.style.width!=cssWidth&&(nextDOM.style.width=cssWidth),nextDOM=nextDOM.nextSibling):colgroup.appendChild(document.createElement("col")).style.width=cssWidth}}while(nextDOM){let after=nextDOM.nextSibling;nextDOM.parentNode.removeChild(nextDOM),nextDOM=after}fixedWidth?(table.style.width=totalWidth+"px",table.style.minWidth=""):(table.style.width="",table.style.minWidth=totalWidth+"px")}const key$2=new PluginKey$1("tableColumnResizing");function columnResizing$1({handleWidth:handleWidth=5,cellMinWidth:cellMinWidth=25,View:View=TableView$1$1,lastColumnResizable:lastColumnResizable=!0}={}){let plugin=new Plugin$1({key:key$2,state:{init(_,state){return this.spec.props.nodeViews[tableNodeTypes$1(state.schema).table.name]=(node,view)=>new View(node,cellMinWidth,view),new ResizeState$1(-1,!1)},apply(tr,prev){return prev.apply(tr)}},props:{attributes(state){let pluginState=key$2.getState(state);return pluginState.activeHandle>-1?{class:"resize-cursor"}:null},handleDOMEvents:{mousemove(view,event){handleMouseMove$1(view,event,handleWidth,cellMinWidth,lastColumnResizable)},mouseleave(view){handleMouseLeave$1(view)},mousedown(view,event){handleMouseDown$2(view,event,cellMinWidth)}},decorations(state){let pluginState=key$2.getState(state);if(pluginState.activeHandle>-1)return handleDecorations$1(state,pluginState.activeHandle)},nodeViews:{}}});return plugin}class ResizeState$1{constructor(activeHandle,dragging){this.activeHandle=activeHandle,this.dragging=dragging}apply(tr){let state=this,action=tr.getMeta(key$2);if(action&&null!=action.setHandle)return new ResizeState$1(action.setHandle,null);if(action&&void 0!==action.setDragging)return new ResizeState$1(state.activeHandle,action.setDragging);if(state.activeHandle>-1&&tr.docChanged){let handle=tr.mapping.map(state.activeHandle,-1);pointsAtCell$1(tr.doc.resolve(handle))||(handle=null),state=new ResizeState$1(handle,state.dragging)}return state}}function handleMouseMove$1(view,event,handleWidth,cellMinWidth,lastColumnResizable){let pluginState=key$2.getState(view.state);if(!pluginState.dragging){let target=domCellAround$1(event.target),cell=-1;if(target){let{left:left,right:right}=target.getBoundingClientRect();event.clientX-left<=handleWidth?cell=edgeCell$1(view,event,"left"):right-event.clientX<=handleWidth&&(cell=edgeCell$1(view,event,"right"))}if(cell!=pluginState.activeHandle){if(!lastColumnResizable&&-1!==cell){let $cell=view.state.doc.resolve(cell),table=$cell.node(-1),map=TableMap$1.get(table),start=$cell.start(-1),col=map.colCount($cell.pos-start)+$cell.nodeAfter.attrs.colspan-1;if(col==map.width-1)return}updateHandle$1(view,cell)}}}function handleMouseLeave$1(view){let pluginState=key$2.getState(view.state);pluginState.activeHandle>-1&&!pluginState.dragging&&updateHandle$1(view,-1)}function handleMouseDown$2(view,event,cellMinWidth){let pluginState=key$2.getState(view.state);if(-1==pluginState.activeHandle||pluginState.dragging)return!1;let cell=view.state.doc.nodeAt(pluginState.activeHandle),width=currentColWidth$1(view,pluginState.activeHandle,cell.attrs);function finish(event){window.removeEventListener("mouseup",finish),window.removeEventListener("mousemove",move);let pluginState=key$2.getState(view.state);pluginState.dragging&&(updateColumnWidth$1(view,pluginState.activeHandle,draggedWidth$1(pluginState.dragging,event,cellMinWidth)),view.dispatch(view.state.tr.setMeta(key$2,{setDragging:null})))}function move(event){if(!event.which)return finish(event);let pluginState=key$2.getState(view.state),dragged=draggedWidth$1(pluginState.dragging,event,cellMinWidth);displayColumnWidth$1(view,pluginState.activeHandle,dragged,cellMinWidth)}return view.dispatch(view.state.tr.setMeta(key$2,{setDragging:{startX:event.clientX,startWidth:width}})),window.addEventListener("mouseup",finish),window.addEventListener("mousemove",move),event.preventDefault(),!0}function currentColWidth$1(view,cellPos,{colspan:colspan,colwidth:colwidth}){let width=colwidth&&colwidth[colwidth.length-1];if(width)return width;let dom=view.domAtPos(cellPos),node=dom.node.childNodes[dom.offset],domWidth=node.offsetWidth,parts=colspan;if(colwidth)for(let i=0;i<colspan;i++)colwidth[i]&&(domWidth-=colwidth[i],parts--);return domWidth/parts}function domCellAround$1(target){while(target&&"TD"!=target.nodeName&&"TH"!=target.nodeName)target=target.classList.contains("ProseMirror")?null:target.parentNode;return target}function edgeCell$1(view,event,side){let found=view.posAtCoords({left:event.clientX,top:event.clientY});if(!found)return-1;let{pos:pos}=found,$cell=cellAround$1(view.state.doc.resolve(pos));if(!$cell)return-1;if("right"==side)return $cell.pos;let map=TableMap$1.get($cell.node(-1)),start=$cell.start(-1),index=map.map.indexOf($cell.pos-start);return index%map.width==0?-1:start+map.map[index-1]}function draggedWidth$1(dragging,event,cellMinWidth){let offset=event.clientX-dragging.startX;return Math.max(cellMinWidth,dragging.startWidth+offset)}function updateHandle$1(view,value){view.dispatch(view.state.tr.setMeta(key$2,{setHandle:value}))}function updateColumnWidth$1(view,cell,width){let $cell=view.state.doc.resolve(cell),table=$cell.node(-1),map=TableMap$1.get(table),start=$cell.start(-1),col=map.colCount($cell.pos-start)+$cell.nodeAfter.attrs.colspan-1,tr=view.state.tr;for(let row=0;row<map.height;row++){let mapIndex=row*map.width+col;// Rowspanning cell that has already been handled
if(row&&map.map[mapIndex]==map.map[mapIndex-map.width])continue;let pos=map.map[mapIndex],{attrs:attrs}=table.nodeAt(pos),index=1==attrs.colspan?0:col-map.colCount(pos);if(attrs.colwidth&&attrs.colwidth[index]==width)continue;let colwidth=attrs.colwidth?attrs.colwidth.slice():zeroes$1(attrs.colspan);colwidth[index]=width,tr.setNodeMarkup(start+pos,null,setAttr$1(attrs,"colwidth",colwidth))}tr.docChanged&&view.dispatch(tr)}function displayColumnWidth$1(view,cell,width,cellMinWidth){let $cell=view.state.doc.resolve(cell),table=$cell.node(-1),start=$cell.start(-1),col=TableMap$1.get(table).colCount($cell.pos-start)+$cell.nodeAfter.attrs.colspan-1,dom=view.domAtPos($cell.start(-1)).node;while("TABLE"!=dom.nodeName)dom=dom.parentNode;updateColumns$1$1(table,dom.firstChild,dom,cellMinWidth,col,width)}function zeroes$1(n){let result=[];for(let i=0;i<n;i++)result.push(0);return result}function handleDecorations$1(state,cell){let decorations=[],$cell=state.doc.resolve(cell),table=$cell.node(-1),map=TableMap$1.get(table),start=$cell.start(-1),col=map.colCount($cell.pos-start)+$cell.nodeAfter.attrs.colspan;for(let row=0;row<map.height;row++){let index=col+row*map.width-1;// For positions that are have either a different cell or the end
// of the table to their right, and either the top of the table or
// a different cell above them, add a decoration
if((col==map.width||map.map[index]!=map.map[index+1])&&(0==row||map.map[index-1]!=map.map[index-1-map.width])){let cellPos=map.map[index],pos=start+cellPos+table.nodeAt(cellPos).nodeSize-1,dom=document.createElement("div");dom.className="column-resize-handle",decorations.push(Decoration$1.widget(pos,dom))}}return DecorationSet$1.create(state.doc,decorations)}
// This file defines a plugin that handles the drawing of cell

// Creates a [plugin](http://prosemirror.net/docs/ref/#state.Plugin)
// that, when added to an editor, enables cell-selection, handles
// cell-based copy/paste, and makes sure tables stay well-formed (each
// row has the same width, and cells don't overlap).

// You should probably put this plugin near the end of your array of
// plugins, since it handles mouse and arrow key events in tables
// rather broadly, and other plugins, like the gap cursor or the
// column-width dragging plugin, might want to get a turn first to
// perform more specific behavior.
function tableEditing$1({allowTableNodeSelection:allowTableNodeSelection=!1}={}){return new Plugin$1({key:key$1$1,
// This piece of state is used to remember when a mouse-drag
// cell-selection is happening, so that it can continue even as
// transactions (which might move its anchor cell) come in.
state:{init(){return null},apply(tr,cur){let set=tr.getMeta(key$1$1);if(null!=set)return-1==set?null:set;if(null==cur||!tr.docChanged)return cur;let{deleted:deleted,pos:pos}=tr.mapping.mapResult(cur);return deleted?null:pos}},props:{decorations:drawCellSelection$1,handleDOMEvents:{mousedown:handleMouseDown$1$1},createSelectionBetween(view){if(null!=key$1$1.getState(view.state))return view.state.selection},handleTripleClick:handleTripleClick$2,handleKeyDown:handleKeyDown$1$1,handlePaste:handlePaste$1},appendTransaction(_,oldState,state){return normalizeSelection$1(state,fixTables$1(state,oldState),allowTableNodeSelection)}})}function updateColumns$2(node,colgroup,table,cellMinWidth,overrideCol,overrideValue){let totalWidth=0,fixedWidth=!0,nextDOM=colgroup.firstChild;const row=node.firstChild;for(let i=0,col=0;i<row.childCount;i+=1){const{colspan:colspan,colwidth:colwidth}=row.child(i).attrs;for(let j=0;j<colspan;j+=1,col+=1){const hasWidth=overrideCol===col?overrideValue:colwidth&&colwidth[j],cssWidth=hasWidth?`${hasWidth}px`:"";totalWidth+=hasWidth||cellMinWidth,hasWidth||(fixedWidth=!1),nextDOM?(nextDOM.style.width!==cssWidth&&(nextDOM.style.width=cssWidth),nextDOM=nextDOM.nextSibling):colgroup.appendChild(document.createElement("col")).style.width=cssWidth}}while(nextDOM){const after=nextDOM.nextSibling;nextDOM.parentNode.removeChild(nextDOM),nextDOM=after}fixedWidth?(table.style.width=`${totalWidth}px`,table.style.minWidth=""):(table.style.width="",table.style.minWidth=`${totalWidth}px`)}class TableView$2{constructor(node,cellMinWidth){this.node=node,this.cellMinWidth=cellMinWidth,this.dom=document.createElement("div"),this.dom.className="tableWrapper",this.table=this.dom.appendChild(document.createElement("table")),this.colgroup=this.table.appendChild(document.createElement("colgroup")),updateColumns$2(node,this.colgroup,this.table,cellMinWidth),this.contentDOM=this.table.appendChild(document.createElement("tbody"))}update(node){return node.type===this.node.type&&(this.node=node,updateColumns$2(node,this.colgroup,this.table,this.cellMinWidth),!0)}ignoreMutation(mutation){return"attributes"===mutation.type&&(mutation.target===this.table||this.colgroup.contains(mutation.target))}}function createCell$1(cellType,cellContent){return cellContent?cellType.createChecked(null,cellContent):cellType.createAndFill()}function getTableNodeTypes$1(schema){if(schema.cached.tableNodeTypes)return schema.cached.tableNodeTypes;const roles={};return Object.keys(schema.nodes).forEach((type=>{const nodeType=schema.nodes[type];nodeType.spec.tableRole&&(roles[nodeType.spec.tableRole]=nodeType)})),schema.cached.tableNodeTypes=roles,roles}function createTable$1(schema,rowsCount,colsCount,withHeaderRow,cellContent){const types=getTableNodeTypes$1(schema),headerCells=[],cells=[];for(let index=0;index<colsCount;index+=1){const cell=createCell$1(types.cell,cellContent);if(cell&&cells.push(cell),withHeaderRow){const headerCell=createCell$1(types.header_cell,cellContent);headerCell&&headerCells.push(headerCell)}}const rows=[];for(let index=0;index<rowsCount;index+=1)rows.push(types.row.createChecked(null,withHeaderRow&&0===index?headerCells:cells));return types.table.createChecked(null,rows)}function isCellSelection$1(value){return value instanceof CellSelection$1}const deleteTableWhenAllCellsSelected$1=({editor:editor})=>{const{selection:selection}=editor.state;if(!isCellSelection$1(selection))return!1;let cellCount=0;const table=findParentNodeClosestToPos$1(selection.ranges[0].$from,(node=>"table"===node.type.name));null===table||void 0===table||table.node.descendants((node=>{if("table"===node.type.name)return!1;["tableCell","tableHeader"].includes(node.type.name)&&(cellCount+=1)}));const allCellsSelected=cellCount===selection.ranges.length;return!!allCellsSelected&&(editor.commands.deleteTable(),!0)};Node$1$1.create({name:"table",
// @ts-ignore
addOptions(){return{HTMLAttributes:{},resizable:!1,handleWidth:5,cellMinWidth:25,
// TODO: fix
View:TableView$2,lastColumnResizable:!0,allowTableNodeSelection:!1}},content:"tableRow+",tableRole:"table",isolating:!0,group:"block",parseHTML(){return[{tag:"table"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["table",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes),["tbody",0]]},addCommands(){return{insertTable:({rows:rows=3,cols:cols=3,withHeaderRow:withHeaderRow=!0}={})=>({tr:tr,dispatch:dispatch,editor:editor})=>{const node=createTable$1(editor.schema,rows,cols,withHeaderRow);if(dispatch){const offset=tr.selection.anchor+1;tr.replaceSelectionWith(node).scrollIntoView().setSelection(TextSelection$1.near(tr.doc.resolve(offset)))}return!0},addColumnBefore:()=>({state:state,dispatch:dispatch})=>addColumnBefore$1(state,dispatch),addColumnAfter:()=>({state:state,dispatch:dispatch})=>addColumnAfter$1(state,dispatch),deleteColumn:()=>({state:state,dispatch:dispatch})=>deleteColumn$1(state,dispatch),addRowBefore:()=>({state:state,dispatch:dispatch})=>addRowBefore$1(state,dispatch),addRowAfter:()=>({state:state,dispatch:dispatch})=>addRowAfter$1(state,dispatch),deleteRow:()=>({state:state,dispatch:dispatch})=>deleteRow$1(state,dispatch),deleteTable:()=>({state:state,dispatch:dispatch})=>deleteTable$1(state,dispatch),mergeCells:()=>({state:state,dispatch:dispatch})=>mergeCells$1(state,dispatch),splitCell:()=>({state:state,dispatch:dispatch})=>splitCell$1(state,dispatch),toggleHeaderColumn:()=>({state:state,dispatch:dispatch})=>toggleHeader$1("column")(state,dispatch),toggleHeaderRow:()=>({state:state,dispatch:dispatch})=>toggleHeader$1("row")(state,dispatch),toggleHeaderCell:()=>({state:state,dispatch:dispatch})=>toggleHeaderCell$1(state,dispatch),mergeOrSplit:()=>({state:state,dispatch:dispatch})=>!!mergeCells$1(state,dispatch)||splitCell$1(state,dispatch),setCellAttribute:(name,value)=>({state:state,dispatch:dispatch})=>setCellAttr$1(name,value)(state,dispatch),goToNextCell:()=>({state:state,dispatch:dispatch})=>goToNextCell$1(1)(state,dispatch),goToPreviousCell:()=>({state:state,dispatch:dispatch})=>goToNextCell$1(-1)(state,dispatch),fixTables:()=>({state:state,dispatch:dispatch})=>(dispatch&&fixTables$1(state),!0),setCellSelection:position=>({tr:tr,dispatch:dispatch})=>{if(dispatch){const selection=CellSelection$1.create(tr.doc,position.anchorCell,position.headCell);
// @ts-ignore
tr.setSelection(selection)}return!0}}},addKeyboardShortcuts(){return{Tab:()=>!!this.editor.commands.goToNextCell()||!!this.editor.can().addRowAfter()&&this.editor.chain().addRowAfter().goToNextCell().run(),"Shift-Tab":()=>this.editor.commands.goToPreviousCell(),Backspace:deleteTableWhenAllCellsSelected$1,"Mod-Backspace":deleteTableWhenAllCellsSelected$1,Delete:deleteTableWhenAllCellsSelected$1,"Mod-Delete":deleteTableWhenAllCellsSelected$1}},addProseMirrorPlugins(){const isResizable=this.options.resizable&&this.editor.isEditable;return[...isResizable?[columnResizing$1({handleWidth:this.options.handleWidth,cellMinWidth:this.options.cellMinWidth,View:this.options.View,
// TODO: PR for @types/prosemirror-tables
// @ts-ignore (incorrect type)
lastColumnResizable:this.options.lastColumnResizable})]:[],tableEditing$1({allowTableNodeSelection:this.options.allowTableNodeSelection})]},extendNodeSchema(extension){const context={name:extension.name,options:extension.options,storage:extension.storage};return{tableRole:callOrReturn$1(getExtensionField$1(extension,"tableRole",context))}}}),Node$1$1.create({name:"tableRow",addOptions(){return{HTMLAttributes:{}}},content:"(tableCell | tableHeader)*",tableRole:"row",parseHTML(){return[{tag:"tr"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["tr",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes),0]}});const TableCell$1=Node$1$1.create({name:"tableCell",addOptions(){return{HTMLAttributes:{}}},content:"block+",addAttributes(){return{colspan:{default:1},rowspan:{default:1},colwidth:{default:null,parseHTML:element=>{const colwidth=element.getAttribute("colwidth"),value=colwidth?[parseInt(colwidth,10)]:null;return value}}}},tableRole:"cell",isolating:!0,parseHTML(){return[{tag:"td"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["td",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes),0]}}),TableHeader$1=Node$1$1.create({name:"tableHeader",addOptions(){return{HTMLAttributes:{}}},content:"block+",addAttributes(){return{colspan:{default:1},rowspan:{default:1},colwidth:{default:null,parseHTML:element=>{const colwidth=element.getAttribute("colwidth"),value=colwidth?[parseInt(colwidth,10)]:null;return value}}}},tableRole:"header_cell",isolating:!0,parseHTML(){return[{tag:"th"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["th",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes),0]}});Extension$1.create({name:"placeholder",addOptions(){return{emptyEditorClass:"is-editor-empty",emptyNodeClass:"is-empty",placeholder:"Write something …",showOnlyWhenEditable:!0,showOnlyCurrent:!0,includeChildren:!1}},addProseMirrorPlugins(){return[new Plugin$1({props:{decorations:({doc:doc,selection:selection})=>{const active=this.editor.isEditable||!this.options.showOnlyWhenEditable,{anchor:anchor}=selection,decorations=[];return active?(doc.descendants(((node,pos)=>{const hasAnchor=anchor>=pos&&anchor<=pos+node.nodeSize,isEmpty=!node.isLeaf&&!node.childCount;if((hasAnchor||!this.options.showOnlyCurrent)&&isEmpty){const classes=[this.options.emptyNodeClass];this.editor.isEmpty&&classes.push(this.options.emptyEditorClass);const decoration=Decoration$1.node(pos,pos+node.nodeSize,{class:classes.join(" "),"data-placeholder":"function"===typeof this.options.placeholder?this.options.placeholder({editor:this.editor,node:node,pos:pos,hasAnchor:hasAnchor}):this.options.placeholder});decorations.push(decoration)}return this.options.includeChildren})),DecorationSet$1.create(doc,decorations)):null}}})]}});const inputRegex$2$1=/^\s*>\s$/;Node$1$1.create({name:"blockquote",addOptions(){return{HTMLAttributes:{}}},content:"block+",group:"block",defining:!0,parseHTML(){return[{tag:"blockquote"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["blockquote",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setBlockquote:()=>({commands:commands})=>commands.wrapIn(this.name),toggleBlockquote:()=>({commands:commands})=>commands.toggleWrap(this.name),unsetBlockquote:()=>({commands:commands})=>commands.lift(this.name)}},addKeyboardShortcuts(){return{"Mod-Shift-b":()=>this.editor.commands.toggleBlockquote()}},addInputRules(){return[wrappingInputRule$1({find:inputRegex$2$1,type:this.type})]}}),Extension$1.create({name:"color",addOptions(){return{types:["textStyle"]}},addGlobalAttributes(){return[{types:this.options.types,attributes:{color:{default:null,parseHTML:element=>{var _a;return null===(_a=element.style.color)||void 0===_a?void 0:_a.replace(/['"]+/g,"")},renderHTML:attributes=>attributes.color?{style:`color: ${attributes.color}`}:{}}}}]},addCommands(){return{setColor:color=>({chain:chain})=>chain().setMark("textStyle",{color:color}).run(),unsetColor:()=>({chain:chain})=>chain().setMark("textStyle",{color:null}).removeEmptyTextStyle().run()}}});const HardBreak$1$1=Node$1$1.create({name:"hardBreak",addOptions(){return{keepMarks:!0,HTMLAttributes:{}}},inline:!0,group:"inline",selectable:!1,parseHTML(){return[{tag:"br"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["br",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes)]},renderText(){return"\n"},addCommands(){return{setHardBreak:()=>({commands:commands,chain:chain,state:state,editor:editor})=>commands.first([()=>commands.exitCode(),()=>commands.command((()=>{const{selection:selection,storedMarks:storedMarks}=state;if(selection.$from.parent.type.spec.isolating)return!1;const{keepMarks:keepMarks}=this.options,{splittableMarks:splittableMarks}=editor.extensionManager,marks=storedMarks||selection.$to.parentOffset&&selection.$from.marks();return chain().insertContent({type:this.name}).command((({tr:tr,dispatch:dispatch})=>{if(dispatch&&marks&&keepMarks){const filteredMarks=marks.filter((mark=>splittableMarks.includes(mark.type.name)));tr.ensureMarks(filteredMarks)}return!0})).run()}))])}},addKeyboardShortcuts(){return{"Mod-Enter":()=>this.editor.commands.setHardBreak(),"Shift-Enter":()=>this.editor.commands.setHardBreak()}}});HardBreak$1$1.extend({addKeyboardShortcuts(){return{Enter:()=>this.editor.commands.setHardBreak()}}}),Node$1$1.create({name:"horizontalRule",addOptions(){return{HTMLAttributes:{}}},group:"block",parseHTML(){return[{tag:"hr"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["hr",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes)]},addCommands(){return{setHorizontalRule:()=>({chain:chain})=>chain().insertContent({type:this.name}).command((({tr:tr,dispatch:dispatch})=>{var _a;if(dispatch){const{$to:$to}=tr.selection,posAfter=$to.end();if($to.nodeAfter)tr.setSelection(TextSelection$1.create(tr.doc,$to.pos));else{
// add node after horizontal rule if it’s the end of the document
const node=null===(_a=$to.parent.type.contentMatch.defaultType)||void 0===_a?void 0:_a.create();node&&(tr.insert(posAfter,node),tr.setSelection(TextSelection$1.create(tr.doc,posAfter)))}tr.scrollIntoView()}return!0})).run()}},addInputRules(){return[nodeInputRule$1({find:/^(?:---|—-|___\s|\*\*\*\s)$/,type:this.type})]}});const inputRegex$1$1=/(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/,Image$1$1=Node$1$1.create({name:"image",addOptions(){return{inline:!1,allowBase64:!1,HTMLAttributes:{}}},inline(){return this.options.inline},group(){return this.options.inline?"inline":"block"},draggable:!0,addAttributes(){return{src:{default:null},alt:{default:null},title:{default:null}}},parseHTML(){return[{tag:this.options.allowBase64?"img[src]":'img[src]:not([src^="data:"])'}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["img",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes)]},addCommands(){return{setImage:options=>({commands:commands})=>commands.insertContent({type:this.name,attrs:options})}},addInputRules(){return[nodeInputRule$1({find:inputRegex$1$1,type:this.type,getAttributes:match=>{const[,,alt,src,title]=match;return{src:src,alt:alt,title:title}}})]}});Image$1$1.extend({addOptions(){return{inline:!1,allowBase64:!0,HTMLAttributes:{}}},addAttributes(){return{src:{default:null},alt:{default:null},title:{default:null},style:{default:null}}}}),Extension$1.create({name:"fontSize",addOptions(){return{types:["textStyle"]}},addGlobalAttributes(){return[{types:this.options.types,attributes:{fontSize:{default:null,parseHTML:element=>element.style.fontSize.replace(/['"]+/g,""),renderHTML:attributes=>attributes.fontSize?{style:`font-size: ${attributes.fontSize}`}:{}}}}]},addCommands(){return{setFontSize:fontSize=>({chain:chain})=>chain().setMark("textStyle",{fontSize:fontSize+"px"}).run(),unsetFontSize:()=>({chain:chain})=>chain().setMark("textStyle",{fontSize:null}).removeEmptyTextStyle().run()}}});const inputRegex$6=/(?:^|\s)((?:==)((?:[^~=]+))(?:==))$/,pasteRegex$2=/(?:^|\s)((?:==)((?:[^~=]+))(?:==))/g;
/**
 * Finite State Machine generation utilities
 */
/**
 * Define a basic state machine state. j is the list of character transitions,
 * jr is the list of regex-match transitions, jd is the default state to
 * transition to t is the accepting token type, if any. If this is the terminal
 * state, then it does not emit a token.
 * @param {string|class} token to emit
 */
function State$1(token){this.j={},// IMPLEMENTATION 1
// this.j = []; // IMPLEMENTATION 2
this.jr=[],this.jd=null,this.t=token}
/**
 * Take the transition from this state to the next one on the given input.
 * If this state does not exist deterministically, will create it.
 *
 * @param {string} input character or token to transition on
 * @param {string|class} [token] token or multi-token to emit when reaching
 * this state
 */Mark$2.create({name:"highlight",addOptions(){return{multicolor:!1,HTMLAttributes:{}}},addAttributes(){return this.options.multicolor?{color:{default:null,parseHTML:element=>element.getAttribute("data-color")||element.style.backgroundColor,renderHTML:attributes=>attributes.color?{"data-color":attributes.color,style:`background-color: ${attributes.color}`}:{}}}:{}},parseHTML(){return[{tag:"mark"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["mark",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setHighlight:attributes=>({commands:commands})=>commands.setMark(this.name,attributes),toggleHighlight:attributes=>({commands:commands})=>commands.toggleMark(this.name,attributes),unsetHighlight:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-Shift-h":()=>this.editor.commands.toggleHighlight()}},addInputRules(){return[markInputRule$1({find:inputRegex$6,type:this.type})]},addPasteRules(){return[markPasteRule$1({find:pasteRegex$2,type:this.type})]}}),TableHeader$1.extend({addAttributes(){return{colspan:{default:1},rowspan:{default:1},colwidth:{default:null,parseHTML:element=>{const colwidth=element.getAttribute("colwidth"),value=colwidth?[parseInt(colwidth,10)]:null;return value},renderHTML:()=>({style:"border: 1px solid #d0d9e2;color: #2f4058;font-weight: 400;background-color: #fafbff;"})}}},parseHTML(){return[{tag:"th"}]}}),TableCell$1.extend({addAttributes(){return{colspan:{default:1},rowspan:{default:1},colwidth:{default:null,parseHTML:element=>{const colwidth=element.getAttribute("colwidth"),value=colwidth?[parseInt(colwidth,10)]:null;return value},renderHTML:()=>({style:"border: 1px solid #d0d9e2;color: #2f4058;font-weight: 400;"})}}},parseHTML(){return[{tag:"td"}]}}),Paragraph$1.extend({renderHTML({HTMLAttributes:HTMLAttributes}){return["p",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes),0]}}),State$1.prototype={
/**
   * @param {State} state
   */
accepts:function(){return!!this.t},
/**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * @param {string} input character or token to transition on
   * @param {Token|State} tokenOrState transition to a matching state
   * @returns State taken after the given input
   */
tt:function(input,tokenOrState){if(tokenOrState&&tokenOrState.j)
// State, default a basic transition
return this.j[input]=tokenOrState,tokenOrState;// See if there's a direct state transition (not regex or default)
var token=tokenOrState,nextState=this.j[input];if(nextState)// overrwites previous token
return token&&(nextState.t=token),nextState;// Create a new state for this input
nextState=makeState$1();// Take the transition using the usual default mechanisms
var templateState=takeT$1(this,input);return templateState?(
// Some default state transition, make a prime state based on this one
Object.assign(nextState.j,templateState.j),nextState.jr.append(templateState.jr),nextState.jr=templateState.jd,nextState.t=token||templateState.t):nextState.t=token,this.j[input]=nextState,nextState}};
/**
 * Utility function to create state without using new keyword (reduced file size
 * when minified)
 */
var makeState$1=function(){return new State$1},makeAcceptingState$1=function(token){return new State$1(token)},makeT$1=function(startState,input,nextState){
// IMPLEMENTATION 1: Add to object (fast)
startState.j[input]||(startState.j[input]=nextState);// IMPLEMENTATION 2: Add to array (slower)
// startState.j.push([input, nextState]);
},makeRegexT$1=function(startState,regex,nextState){startState.jr.push([regex,nextState])},takeT$1=function(state,input){
// IMPLEMENTATION 1: Object key lookup (faster)
var nextState=state.j[input];if(nextState)return nextState;// IMPLEMENTATION 2: List lookup (slower)
// Loop through all the state transitions and see if there's a match
// for (let i = 0; i < state.j.length; i++) {
//	const val = state.j[i][0];
//	const nextState = state.j[i][1];
// 	if (input === val) { return nextState; }
// }
for(var i=0;i<state.jr.length;i++){var regex=state.jr[i][0],_nextState=state.jr[i][1];if(regex.test(input))return _nextState}// Nowhere left to jump! Return default, if any
return state.jd},makeMultiT$1=function(startState,chars,nextState){for(var i=0;i<chars.length;i++)makeT$1(startState,chars[i],nextState)},makeBatchT$1=function(startState,transitions){for(var i=0;i<transitions.length;i++){var input=transitions[i][0],nextState=transitions[i][1];makeT$1(startState,input,nextState)}},makeChainT$1=function(state,str,endState,defaultStateFactory){var nextState,i=0,len=str.length;// Find the next state without a jump to the next character
while(i<len&&(nextState=state.j[str[i]]))state=nextState,i++;if(i>=len)return[];// no new tokens were added
while(i<len-1)nextState=defaultStateFactory(),makeT$1(state,str[i],nextState),state=nextState,i++;makeT$1(state,str[len-1],endState)},DOMAIN$1="DOMAIN",LOCALHOST$1="LOCALHOST",TLD$1="TLD",NUM$1="NUM",PROTOCOL$1="PROTOCOL",MAILTO$1="MAILTO",WS$1="WS",NL$1$1="NL",OPENBRACE$1="OPENBRACE",OPENBRACKET$1="OPENBRACKET",OPENANGLEBRACKET$1="OPENANGLEBRACKET",OPENPAREN$1="OPENPAREN",CLOSEBRACE$1="CLOSEBRACE",CLOSEBRACKET$1="CLOSEBRACKET",CLOSEANGLEBRACKET$1="CLOSEANGLEBRACKET",CLOSEPAREN$1="CLOSEPAREN",AMPERSAND$1="AMPERSAND",APOSTROPHE$1="APOSTROPHE",ASTERISK$1="ASTERISK",AT$1="AT",BACKSLASH$1="BACKSLASH",BACKTICK$1="BACKTICK",CARET$1="CARET",COLON$1="COLON",COMMA$1="COMMA",DOLLAR$1="DOLLAR",DOT$1="DOT",EQUALS$1="EQUALS",EXCLAMATION$1="EXCLAMATION",HYPHEN$1="HYPHEN",PERCENT$1="PERCENT",PIPE$1="PIPE",PLUS$1="PLUS",POUND$1="POUND",QUERY$1="QUERY",QUOTE$1="QUOTE",SEMI$1="SEMI",SLASH$1="SLASH",TILDE$1="TILDE",UNDERSCORE$1="UNDERSCORE",SYM$1="SYM",text$2=Object.freeze({__proto__:null,DOMAIN:DOMAIN$1,LOCALHOST:LOCALHOST$1,TLD:TLD$1,NUM:NUM$1,PROTOCOL:PROTOCOL$1,MAILTO:MAILTO$1,WS:WS$1,NL:NL$1$1,OPENBRACE:OPENBRACE$1,OPENBRACKET:OPENBRACKET$1,OPENANGLEBRACKET:OPENANGLEBRACKET$1,OPENPAREN:OPENPAREN$1,CLOSEBRACE:CLOSEBRACE$1,CLOSEBRACKET:CLOSEBRACKET$1,CLOSEANGLEBRACKET:CLOSEANGLEBRACKET$1,CLOSEPAREN:CLOSEPAREN$1,AMPERSAND:AMPERSAND$1,APOSTROPHE:APOSTROPHE$1,ASTERISK:ASTERISK$1,AT:AT$1,BACKSLASH:BACKSLASH$1,BACKTICK:BACKTICK$1,CARET:CARET$1,COLON:COLON$1,COMMA:COMMA$1,DOLLAR:DOLLAR$1,DOT:DOT$1,EQUALS:EQUALS$1,EXCLAMATION:EXCLAMATION$1,HYPHEN:HYPHEN$1,PERCENT:PERCENT$1,PIPE:PIPE$1,PLUS:PLUS$1,POUND:POUND$1,QUERY:QUERY$1,QUOTE:QUOTE$1,SEMI:SEMI$1,SLASH:SLASH$1,TILDE:TILDE$1,UNDERSCORE:UNDERSCORE$1,SYM:SYM$1}),tlds$1="aaa aarp abarth abb abbott abbvie abc able abogado abudhabi ac academy accenture accountant accountants aco actor ad adac ads adult ae aeg aero aetna af afamilycompany afl africa ag agakhan agency ai aig airbus airforce airtel akdn al alfaromeo alibaba alipay allfinanz allstate ally alsace alstom am amazon americanexpress americanfamily amex amfam amica amsterdam analytics android anquan anz ao aol apartments app apple aq aquarelle ar arab aramco archi army arpa art arte as asda asia associates at athleta attorney au auction audi audible audio auspost author auto autos avianca aw aws ax axa az azure ba baby baidu banamex bananarepublic band bank bar barcelona barclaycard barclays barefoot bargains baseball basketball bauhaus bayern bb bbc bbt bbva bcg bcn bd be beats beauty beer bentley berlin best bestbuy bet bf bg bh bharti bi bible bid bike bing bingo bio biz bj black blackfriday blockbuster blog bloomberg blue bm bms bmw bn bnpparibas bo boats boehringer bofa bom bond boo book booking bosch bostik boston bot boutique box br bradesco bridgestone broadway broker brother brussels bs bt budapest bugatti build builders business buy buzz bv bw by bz bzh ca cab cafe cal call calvinklein cam camera camp cancerresearch canon capetown capital capitalone car caravan cards care career careers cars casa case cash casino cat catering catholic cba cbn cbre cbs cc cd center ceo cern cf cfa cfd cg ch chanel channel charity chase chat cheap chintai christmas chrome church ci cipriani circle cisco citadel citi citic city cityeats ck cl claims cleaning click clinic clinique clothing cloud club clubmed cm cn co coach codes coffee college cologne com comcast commbank community company compare computer comsec condos construction consulting contact contractors cooking cookingchannel cool coop corsica country coupon coupons courses cpa cr credit creditcard creditunion cricket crown crs cruise cruises csc cu cuisinella cv cw cx cy cymru cyou cz dabur dad dance data date dating datsun day dclk dds de deal dealer deals degree delivery dell deloitte delta democrat dental dentist desi design dev dhl diamonds diet digital direct directory discount discover dish diy dj dk dm dnp do docs doctor dog domains dot download drive dtv dubai duck dunlop dupont durban dvag dvr dz earth eat ec eco edeka edu education ee eg email emerck energy engineer engineering enterprises epson equipment er ericsson erni es esq estate et etisalat eu eurovision eus events exchange expert exposed express extraspace fage fail fairwinds faith family fan fans farm farmers fashion fast fedex feedback ferrari ferrero fi fiat fidelity fido film final finance financial fire firestone firmdale fish fishing fit fitness fj fk flickr flights flir florist flowers fly fm fo foo food foodnetwork football ford forex forsale forum foundation fox fr free fresenius frl frogans frontdoor frontier ftr fujitsu fujixerox fun fund furniture futbol fyi ga gal gallery gallo gallup game games gap garden gay gb gbiz gd gdn ge gea gent genting george gf gg ggee gh gi gift gifts gives giving gl glade glass gle global globo gm gmail gmbh gmo gmx gn godaddy gold goldpoint golf goo goodyear goog google gop got gov gp gq gr grainger graphics gratis green gripe grocery group gs gt gu guardian gucci guge guide guitars guru gw gy hair hamburg hangout haus hbo hdfc hdfcbank health healthcare help helsinki here hermes hgtv hiphop hisamitsu hitachi hiv hk hkt hm hn hockey holdings holiday homedepot homegoods homes homesense honda horse hospital host hosting hot hoteles hotels hotmail house how hr hsbc ht hu hughes hyatt hyundai ibm icbc ice icu id ie ieee ifm ikano il im imamat imdb immo immobilien in inc industries infiniti info ing ink institute insurance insure int international intuit investments io ipiranga iq ir irish is ismaili ist istanbul it itau itv iveco jaguar java jcb je jeep jetzt jewelry jio jll jm jmp jnj jo jobs joburg jot joy jp jpmorgan jprs juegos juniper kaufen kddi ke kerryhotels kerrylogistics kerryproperties kfh kg kh ki kia kim kinder kindle kitchen kiwi km kn koeln komatsu kosher kp kpmg kpn kr krd kred kuokgroup kw ky kyoto kz la lacaixa lamborghini lamer lancaster lancia land landrover lanxess lasalle lat latino latrobe law lawyer lb lc lds lease leclerc lefrak legal lego lexus lgbt li lidl life lifeinsurance lifestyle lighting like lilly limited limo lincoln linde link lipsy live living lixil lk llc llp loan loans locker locus loft lol london lotte lotto love lpl lplfinancial lr ls lt ltd ltda lu lundbeck luxe luxury lv ly ma macys madrid maif maison makeup man management mango map market marketing markets marriott marshalls maserati mattel mba mc mckinsey md me med media meet melbourne meme memorial men menu merckmsd mg mh miami microsoft mil mini mint mit mitsubishi mk ml mlb mls mm mma mn mo mobi mobile moda moe moi mom monash money monster mormon mortgage moscow moto motorcycles mov movie mp mq mr ms msd mt mtn mtr mu museum mutual mv mw mx my mz na nab nagoya name nationwide natura navy nba nc ne nec net netbank netflix network neustar new news next nextdirect nexus nf nfl ng ngo nhk ni nico nike nikon ninja nissan nissay nl no nokia northwesternmutual norton now nowruz nowtv np nr nra nrw ntt nu nyc nz obi observer off office okinawa olayan olayangroup oldnavy ollo om omega one ong onl online onyourside ooo open oracle orange org organic origins osaka otsuka ott ovh pa page panasonic paris pars partners parts party passagens pay pccw pe pet pf pfizer pg ph pharmacy phd philips phone photo photography photos physio pics pictet pictures pid pin ping pink pioneer pizza pk pl place play playstation plumbing plus pm pn pnc pohl poker politie porn post pr pramerica praxi press prime pro prod productions prof progressive promo properties property protection pru prudential ps pt pub pw pwc py qa qpon quebec quest qvc racing radio raid re read realestate realtor realty recipes red redstone redumbrella rehab reise reisen reit reliance ren rent rentals repair report republican rest restaurant review reviews rexroth rich richardli ricoh ril rio rip rmit ro rocher rocks rodeo rogers room rs rsvp ru rugby ruhr run rw rwe ryukyu sa saarland safe safety sakura sale salon samsclub samsung sandvik sandvikcoromant sanofi sap sarl sas save saxo sb sbi sbs sc sca scb schaeffler schmidt scholarships school schule schwarz science scjohnson scot sd se search seat secure security seek select sener services ses seven sew sex sexy sfr sg sh shangrila sharp shaw shell shia shiksha shoes shop shopping shouji show showtime si silk sina singles site sj sk ski skin sky skype sl sling sm smart smile sn sncf so soccer social softbank software sohu solar solutions song sony soy spa space sport spot spreadbetting sr srl ss st stada staples star statebank statefarm stc stcgroup stockholm storage store stream studio study style su sucks supplies supply support surf surgery suzuki sv swatch swiftcover swiss sx sy sydney systems sz tab taipei talk taobao target tatamotors tatar tattoo tax taxi tc tci td tdk team tech technology tel temasek tennis teva tf tg th thd theater theatre tiaa tickets tienda tiffany tips tires tirol tj tjmaxx tjx tk tkmaxx tl tm tmall tn to today tokyo tools top toray toshiba total tours town toyota toys tr trade trading training travel travelchannel travelers travelersinsurance trust trv tt tube tui tunes tushu tv tvs tw tz ua ubank ubs ug uk unicom university uno uol ups us uy uz va vacations vana vanguard vc ve vegas ventures verisign versicherung vet vg vi viajes video vig viking villas vin vip virgin visa vision viva vivo vlaanderen vn vodka volkswagen volvo vote voting voto voyage vu vuelos wales walmart walter wang wanggou watch watches weather weatherchannel webcam weber website wed wedding weibo weir wf whoswho wien wiki williamhill win windows wine winners wme wolterskluwer woodside work works world wow ws wtc wtf xbox xerox xfinity xihuan xin xxx xyz yachts yahoo yamaxun yandex ye yodobashi yoga yokohama you youtube yt yun za zappos zara zero zip zm zone zuerich zw vermögensberater-ctb vermögensberatung-pwb ελ ευ бг бел дети ею католик ком қаз мкд мон москва онлайн орг рус рф сайт срб укр გე հայ ישראל קום ابوظبي اتصالات ارامكو الاردن البحرين الجزائر السعودية العليان المغرب امارات ایران بارت بازار بھارت بيتك پاکستان ڀارت تونس سودان سورية شبكة عراق عرب عمان فلسطين قطر كاثوليك كوم مصر مليسيا موريتانيا موقع همراه कॉम नेट भारत भारतम् भारोत संगठन বাংলা ভারত ভাৰত ਭਾਰਤ ભારત ଭାରତ இந்தியா இலங்கை சிங்கப்பூர் భారత్ ಭಾರತ ഭാരതം ලංකා คอม ไทย ລາວ 닷넷 닷컴 삼성 한국 アマゾン グーグル クラウド コム ストア セール ファッション ポイント みんな 世界 中信 中国 中國 中文网 亚马逊 企业 佛山 信息 健康 八卦 公司 公益 台湾 台灣 商城 商店 商标 嘉里 嘉里大酒店 在线 大众汽车 大拿 天主教 娱乐 家電 广东 微博 慈善 我爱你 手机 招聘 政务 政府 新加坡 新闻 时尚 書籍 机构 淡马锡 游戏 澳門 点看 移动 组织机构 网址 网店 网站 网络 联通 诺基亚 谷歌 购物 通販 集团 電訊盈科 飞利浦 食品 餐厅 香格里拉 香港".split(" "),LETTER$1=/(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/,EMOJI$1$1=/(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDD-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6])/,EMOJI_VARIATION$1=/\uFE0F/,DIGIT$1=/\d/,SPACE$1=/\s/;
/**
 * Similar to previous except it is an accepting state that emits a token
 * @param {Token} token
 */
/**
 * Initialize the scanner character-based state machine for the given start state
 * @return {State} scanner starting state
 */
function init$2$1(){var customProtocols=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],S_START=makeState$1(),S_NUM=makeAcceptingState$1(NUM$1),S_DOMAIN=makeAcceptingState$1(DOMAIN$1),S_DOMAIN_HYPHEN=makeState$1(),S_WS=makeAcceptingState$1(WS$1),DOMAIN_REGEX_TRANSITIONS=[[DIGIT$1,S_DOMAIN],[LETTER$1,S_DOMAIN],[EMOJI$1$1,S_DOMAIN],[EMOJI_VARIATION$1,S_DOMAIN]],makeDomainState=function(){var state=makeAcceptingState$1(DOMAIN$1);return state.j={"-":S_DOMAIN_HYPHEN},state.jr=[].concat(DOMAIN_REGEX_TRANSITIONS),state},makeNearDomainState=function(token){var state=makeDomainState();return state.t=token,state};
// Frequently used states
// States for special URL symbols that accept immediately after start
makeBatchT$1(S_START,[["'",makeAcceptingState$1(APOSTROPHE$1)],["{",makeAcceptingState$1(OPENBRACE$1)],["[",makeAcceptingState$1(OPENBRACKET$1)],["<",makeAcceptingState$1(OPENANGLEBRACKET$1)],["(",makeAcceptingState$1(OPENPAREN$1)],["}",makeAcceptingState$1(CLOSEBRACE$1)],["]",makeAcceptingState$1(CLOSEBRACKET$1)],[">",makeAcceptingState$1(CLOSEANGLEBRACKET$1)],[")",makeAcceptingState$1(CLOSEPAREN$1)],["&",makeAcceptingState$1(AMPERSAND$1)],["*",makeAcceptingState$1(ASTERISK$1)],["@",makeAcceptingState$1(AT$1)],["`",makeAcceptingState$1(BACKTICK$1)],["^",makeAcceptingState$1(CARET$1)],[":",makeAcceptingState$1(COLON$1)],[",",makeAcceptingState$1(COMMA$1)],["$",makeAcceptingState$1(DOLLAR$1)],[".",makeAcceptingState$1(DOT$1)],["=",makeAcceptingState$1(EQUALS$1)],["!",makeAcceptingState$1(EXCLAMATION$1)],["-",makeAcceptingState$1(HYPHEN$1)],["%",makeAcceptingState$1(PERCENT$1)],["|",makeAcceptingState$1(PIPE$1)],["+",makeAcceptingState$1(PLUS$1)],["#",makeAcceptingState$1(POUND$1)],["?",makeAcceptingState$1(QUERY$1)],['"',makeAcceptingState$1(QUOTE$1)],["/",makeAcceptingState$1(SLASH$1)],[";",makeAcceptingState$1(SEMI$1)],["~",makeAcceptingState$1(TILDE$1)],["_",makeAcceptingState$1(UNDERSCORE$1)],["\\",makeAcceptingState$1(BACKSLASH$1)]]),// Whitespace jumps
// Tokens of only non-newline whitespace are arbitrarily long
makeT$1(S_START,"\n",makeAcceptingState$1(NL$1$1)),makeRegexT$1(S_START,SPACE$1,S_WS),// If any whitespace except newline, more whitespace!
makeT$1(S_WS,"\n",makeState$1()),// non-accepting state
makeRegexT$1(S_WS,SPACE$1,S_WS);// Generates states for top-level domains
// Note that this is most accurate when tlds are in alphabetical order
for(var i=0;i<tlds$1.length;i++)makeChainT$1(S_START,tlds$1[i],makeNearDomainState(TLD$1),makeDomainState);// Collect the states generated by different protocls
var S_PROTOCOL_FILE=makeDomainState(),S_PROTOCOL_FTP=makeDomainState(),S_PROTOCOL_HTTP=makeDomainState(),S_MAILTO=makeDomainState();makeChainT$1(S_START,"file",S_PROTOCOL_FILE,makeDomainState),makeChainT$1(S_START,"ftp",S_PROTOCOL_FTP,makeDomainState),makeChainT$1(S_START,"http",S_PROTOCOL_HTTP,makeDomainState),makeChainT$1(S_START,"mailto",S_MAILTO,makeDomainState);// Protocol states
var S_PROTOCOL_SECURE=makeDomainState(),S_FULL_PROTOCOL=makeAcceptingState$1(PROTOCOL$1),S_FULL_MAILTO=makeAcceptingState$1(MAILTO$1);// Mailto ends with COLON
// Secure protocols (end with 's')
makeT$1(S_PROTOCOL_FTP,"s",S_PROTOCOL_SECURE),makeT$1(S_PROTOCOL_FTP,":",S_FULL_PROTOCOL),makeT$1(S_PROTOCOL_HTTP,"s",S_PROTOCOL_SECURE),makeT$1(S_PROTOCOL_HTTP,":",S_FULL_PROTOCOL),// Become protocol tokens after a COLON
makeT$1(S_PROTOCOL_FILE,":",S_FULL_PROTOCOL),makeT$1(S_PROTOCOL_SECURE,":",S_FULL_PROTOCOL),makeT$1(S_MAILTO,":",S_FULL_MAILTO);for(// Register custom protocols
var S_CUSTOM_PROTOCOL=makeDomainState(),_i=0;_i<customProtocols.length;_i++)makeChainT$1(S_START,customProtocols[_i],S_CUSTOM_PROTOCOL,makeDomainState);return makeT$1(S_CUSTOM_PROTOCOL,":",S_FULL_PROTOCOL),// Localhost
makeChainT$1(S_START,"localhost",makeNearDomainState(LOCALHOST$1),makeDomainState),// Everything else
// DOMAINs make more DOMAINs
// Number and character transitions
makeRegexT$1(S_START,DIGIT$1,S_NUM),makeRegexT$1(S_START,LETTER$1,S_DOMAIN),makeRegexT$1(S_START,EMOJI$1$1,S_DOMAIN),makeRegexT$1(S_START,EMOJI_VARIATION$1,S_DOMAIN),makeRegexT$1(S_NUM,DIGIT$1,S_NUM),makeRegexT$1(S_NUM,LETTER$1,S_DOMAIN),// number becomes DOMAIN
makeRegexT$1(S_NUM,EMOJI$1$1,S_DOMAIN),// number becomes DOMAIN
makeRegexT$1(S_NUM,EMOJI_VARIATION$1,S_DOMAIN),// number becomes DOMAIN
makeT$1(S_NUM,"-",S_DOMAIN_HYPHEN),// Default domain transitions
makeT$1(S_DOMAIN,"-",S_DOMAIN_HYPHEN),makeT$1(S_DOMAIN_HYPHEN,"-",S_DOMAIN_HYPHEN),makeRegexT$1(S_DOMAIN,DIGIT$1,S_DOMAIN),makeRegexT$1(S_DOMAIN,LETTER$1,S_DOMAIN),makeRegexT$1(S_DOMAIN,EMOJI$1$1,S_DOMAIN),makeRegexT$1(S_DOMAIN,EMOJI_VARIATION$1,S_DOMAIN),makeRegexT$1(S_DOMAIN_HYPHEN,DIGIT$1,S_DOMAIN),makeRegexT$1(S_DOMAIN_HYPHEN,LETTER$1,S_DOMAIN),makeRegexT$1(S_DOMAIN_HYPHEN,EMOJI$1$1,S_DOMAIN),makeRegexT$1(S_DOMAIN_HYPHEN,EMOJI_VARIATION$1,S_DOMAIN),// Set default transition for start state (some symbol)
S_START.jd=makeAcceptingState$1(SYM$1),S_START}
/**
	Given a string, returns an array of TOKEN instances representing the
	composition of that string.

	@method run
	@param {State} start scanner starting state
	@param {string} str input string to scan
	@return {{t: string, v: string, s: number, l: number}[]} list of tokens, each with a type and value
*/function run$1$2(start,str){
// State machine is not case sensitive, so input is tokenized in lowercased
// form (still returns the regular case though) Uses selective `toLowerCase`
// is used because lowercasing the entire string causes the length and
// character position to vary in some non-English strings with V8-based
// runtimes.
var iterable=stringToArray$1(str.replace(/[A-Z]/g,(function(c){return c.toLowerCase()}))),charCount=iterable.length,tokens=[],cursor=0,charCursor=0;// Tokenize the string
while(charCursor<charCount){var state=start,nextState=null,tokenLength=0,latestAccepting=null,sinceAccepts=-1,charsSinceAccepts=-1;while(charCursor<charCount&&(nextState=takeT$1(state,iterable[charCursor])))state=nextState,// Keep track of the latest accepting state
state.accepts()?(sinceAccepts=0,charsSinceAccepts=0,latestAccepting=state):sinceAccepts>=0&&(sinceAccepts+=iterable[charCursor].length,charsSinceAccepts++),tokenLength+=iterable[charCursor].length,cursor+=iterable[charCursor].length,charCursor++;// Roll back to the latest accepting state
cursor-=sinceAccepts,charCursor-=charsSinceAccepts,tokenLength-=sinceAccepts,// No more jumps, just make a new token from the last accepting one
// TODO: If possible, don't output v, instead output range where values ocur
tokens.push({t:latestAccepting.t,
// token type/name
v:str.substr(cursor-tokenLength,tokenLength),
// string value
s:cursor-tokenLength,
// start index
e:cursor})}return tokens}
/**
 * Convert a String to an Array of characters, taking into account that some
 * characters like emojis take up two string indexes.
 *
 * Adapted from core-js (MIT license)
 * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js
 *
 * @function stringToArray
 * @param {string} str
 * @returns {string[]}
 */function stringToArray$1(str){var result=[],len=str.length,index=0;while(index<len){var first=str.charCodeAt(index),second=void 0,char=first<55296||first>56319||index+1===len||(second=str.charCodeAt(index+1))<56320||second>57343?str[index]:str.slice(index,index+2);// two-index characters
result.push(char),index+=char.length}return result}
/**
 * @property {string} defaultProtocol
 * @property {{[string]: (event) => void}]} [events]
 */var defaults$1={defaultProtocol:"http",events:null,format:noop$1,formatHref:noop$1,nl2br:!1,tagName:"a",target:null,rel:null,validate:!0,truncate:0,className:null,attributes:null,ignoreTags:[]};function noop$1(val){return val}
/******************************************************************************
	Multi-Tokens
	Tokens composed of arrays of TextTokens
******************************************************************************/function inherits$1(parent,child){var props=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},extended=Object.create(parent.prototype);for(var p in props)extended[p]=props[p];return extended.constructor=child,child.prototype=extended,child}
/**
	Abstract class used for manufacturing tokens of text tokens. That is rather
	than the value for a token being a small string of text, it's value an array
	of text tokens.

	Used for grouping together URLs, emails, hashtags, and other potential
	creations.

	@class MultiToken
	@param {string} value
	@param {{t: string, v: string, s: number, e: number}[]} tokens
	@abstract
*/function MultiToken$1(){}// Base token
/**
 * Create a new token that can be emitted by the parser state machine
 * @param {string} type readable type of the token
 * @param {object} props properties to assign or override, including isLink = true or false
 * @returns {(value: string, tokens: {t: string, v: string, s: number, e: number}) => MultiToken} new token class
 */
function createTokenClass$1(type,props){function Token(value,tokens){this.t=type,this.v=value,this.tk=tokens}return inherits$1(MultiToken$1,Token,props),Token}
/**
	Represents an arbitrarily mailto email address with the prefix included
	@class MailtoEmail
	@extends MultiToken
*/MultiToken$1.prototype={
/**
  	String representing the type for this token
  	@property t
  	@default 'token'
  */
t:"token",
/**
  	Is this multitoken a link?
  	@property isLink
  	@default false
  */
isLink:!1,
/**
  	Return the string this token represents.
  	@method toString
  	@return {string}
  */
toString:function(){return this.v},
/**
  	What should the value for this token be in the `href` HTML attribute?
  	Returns the `.toString` value by default.
  		@method toHref
  	@return {string}
  */
toHref:function(){return this.toString()},
/**
   * The start index of this token in the original input string
   * @returns {number}
   */
startIndex:function(){return this.tk[0].s},
/**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
endIndex:function(){return this.tk[this.tk.length-1].e},
/**
  	Returns a hash of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
toObject:function(){var protocol=arguments.length>0&&void 0!==arguments[0]?arguments[0]:defaults$1.defaultProtocol;return{type:this.t,value:this.v,isLink:this.isLink,href:this.toHref(protocol),start:this.startIndex(),end:this.endIndex()}}};var MailtoEmail$1=createTokenClass$1("email",{isLink:!0}),Email$1=createTokenClass$1("email",{isLink:!0,toHref:function(){return"mailto:"+this.toString()}}),Text$2=createTokenClass$1("text"),Nl$1=createTokenClass$1("nl"),Url$1=createTokenClass$1("url",{isLink:!0,
/**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@method href
  	@param {string} protocol
  	@return {string}
  */
toHref:function(){var protocol=arguments.length>0&&void 0!==arguments[0]?arguments[0]:defaults$1.defaultProtocol,tokens=this.tk,hasProtocol=!1,hasSlashSlash=!1,result=[],i=0;// Make the first part of the domain lowercase
// Lowercase protocol
while(tokens[i].t===PROTOCOL$1)hasProtocol=!0,result.push(tokens[i].v),i++;// Skip slash-slash
while(tokens[i].t===SLASH$1)hasSlashSlash=!0,result.push(tokens[i].v),i++;// Continue pushing characters
for(;i<tokens.length;i++)result.push(tokens[i].v);return result=result.join(""),hasProtocol||hasSlashSlash||(result="".concat(protocol,"://").concat(result)),result},hasProtocol:function(){return this.tk[0].t===PROTOCOL$1}}),multi$1=Object.freeze({__proto__:null,MultiToken:MultiToken$1,Base:MultiToken$1,createTokenClass:createTokenClass$1,MailtoEmail:MailtoEmail$1,Email:Email$1,Text:Text$2,Nl:Nl$1,Url:Url$1});
/**
	Represents a list of tokens making up a valid email address
	@class Email
	@extends MultiToken
*/
/**
	Not exactly parser, more like the second-stage scanner (although we can
	theoretically hotswap the code here with a real parser in the future... but
	for a little URL-finding utility abstract syntax trees may be a little
	overkill).

	URL format: http://en.wikipedia.org/wiki/URI_scheme
	Email format: http://en.wikipedia.org/wiki/Email_address (links to RFC in
	reference)

	@module linkify
	@submodule parser
	@main run
*/
/**
 * Generate the parser multi token-based state machine
 * @returns {State} the starting state
 */
function init$1$1(){
// The universal starting state.
var S_START=makeState$1(),S_PROTOCOL=makeState$1(),S_MAILTO=makeState$1(),S_PROTOCOL_SLASH=makeState$1(),S_PROTOCOL_SLASH_SLASH=makeState$1(),S_DOMAIN=makeState$1(),S_DOMAIN_DOT=makeState$1(),S_TLD=makeAcceptingState$1(Url$1),S_TLD_COLON=makeState$1(),S_TLD_PORT=makeAcceptingState$1(Url$1),S_URL=makeAcceptingState$1(Url$1),S_URL_NON_ACCEPTING=makeState$1(),S_URL_OPENBRACE=makeState$1(),S_URL_OPENBRACKET=makeState$1(),S_URL_OPENANGLEBRACKET=makeState$1(),S_URL_OPENPAREN=makeState$1(),S_URL_OPENBRACE_Q=makeAcceptingState$1(Url$1),S_URL_OPENBRACKET_Q=makeAcceptingState$1(Url$1),S_URL_OPENANGLEBRACKET_Q=makeAcceptingState$1(Url$1),S_URL_OPENPAREN_Q=makeAcceptingState$1(Url$1),S_URL_OPENBRACE_SYMS=makeState$1(),S_URL_OPENBRACKET_SYMS=makeState$1(),S_URL_OPENANGLEBRACKET_SYMS=makeState$1(),S_URL_OPENPAREN_SYMS=makeState$1(),S_EMAIL_DOMAIN=makeState$1(),S_EMAIL_DOMAIN_DOT=makeState$1(),S_EMAIL=makeAcceptingState$1(Email$1),S_EMAIL_COLON=makeState$1(),S_EMAIL_PORT=makeAcceptingState$1(Email$1),S_MAILTO_EMAIL=makeAcceptingState$1(MailtoEmail$1),S_MAILTO_EMAIL_NON_ACCEPTING=makeState$1(),S_LOCALPART=makeState$1(),S_LOCALPART_AT=makeState$1(),S_LOCALPART_DOT=makeState$1(),S_NL=makeAcceptingState$1(Nl$1);// Intermediate states for URLs. Note that domains that begin with a protocol
// are treated slighly differently from those that don't.
// single new line
// Make path from start to protocol (with '//')
makeT$1(S_START,NL$1$1,S_NL),makeT$1(S_START,PROTOCOL$1,S_PROTOCOL),makeT$1(S_START,MAILTO$1,S_MAILTO),makeT$1(S_PROTOCOL,SLASH$1,S_PROTOCOL_SLASH),makeT$1(S_PROTOCOL_SLASH,SLASH$1,S_PROTOCOL_SLASH_SLASH),// The very first potential domain name
makeT$1(S_START,TLD$1,S_DOMAIN),makeT$1(S_START,DOMAIN$1,S_DOMAIN),makeT$1(S_START,LOCALHOST$1,S_TLD),makeT$1(S_START,NUM$1,S_DOMAIN),// Force URL for protocol followed by anything sane
makeT$1(S_PROTOCOL_SLASH_SLASH,TLD$1,S_URL),makeT$1(S_PROTOCOL_SLASH_SLASH,DOMAIN$1,S_URL),makeT$1(S_PROTOCOL_SLASH_SLASH,NUM$1,S_URL),makeT$1(S_PROTOCOL_SLASH_SLASH,LOCALHOST$1,S_URL),// Account for dots and hyphens
// hyphens are usually parts of domain names
makeT$1(S_DOMAIN,DOT$1,S_DOMAIN_DOT),makeT$1(S_EMAIL_DOMAIN,DOT$1,S_EMAIL_DOMAIN_DOT),// Hyphen can jump back to a domain name
// After the first domain and a dot, we can find either a URL or another domain
makeT$1(S_DOMAIN_DOT,TLD$1,S_TLD),makeT$1(S_DOMAIN_DOT,DOMAIN$1,S_DOMAIN),makeT$1(S_DOMAIN_DOT,NUM$1,S_DOMAIN),makeT$1(S_DOMAIN_DOT,LOCALHOST$1,S_DOMAIN),makeT$1(S_EMAIL_DOMAIN_DOT,TLD$1,S_EMAIL),makeT$1(S_EMAIL_DOMAIN_DOT,DOMAIN$1,S_EMAIL_DOMAIN),makeT$1(S_EMAIL_DOMAIN_DOT,NUM$1,S_EMAIL_DOMAIN),makeT$1(S_EMAIL_DOMAIN_DOT,LOCALHOST$1,S_EMAIL_DOMAIN),// S_TLD accepts! But the URL could be longer, try to find a match greedily
// The `run` function should be able to "rollback" to the accepting state
makeT$1(S_TLD,DOT$1,S_DOMAIN_DOT),makeT$1(S_EMAIL,DOT$1,S_EMAIL_DOMAIN_DOT),// Become real URLs after `SLASH` or `COLON NUM SLASH`
// Here PSS and non-PSS converge
makeT$1(S_TLD,COLON$1,S_TLD_COLON),makeT$1(S_TLD,SLASH$1,S_URL),makeT$1(S_TLD_COLON,NUM$1,S_TLD_PORT),makeT$1(S_TLD_PORT,SLASH$1,S_URL),makeT$1(S_EMAIL,COLON$1,S_EMAIL_COLON),makeT$1(S_EMAIL_COLON,NUM$1,S_EMAIL_PORT);// Types of characters the URL can definitely end in
var qsAccepting=[AMPERSAND$1,ASTERISK$1,AT$1,BACKSLASH$1,BACKTICK$1,CARET$1,DOLLAR$1,DOMAIN$1,EQUALS$1,HYPHEN$1,LOCALHOST$1,NUM$1,PERCENT$1,PIPE$1,PLUS$1,POUND$1,PROTOCOL$1,SLASH$1,SYM$1,TILDE$1,TLD$1,UNDERSCORE$1],qsNonAccepting=[APOSTROPHE$1,CLOSEANGLEBRACKET$1,CLOSEBRACE$1,CLOSEBRACKET$1,CLOSEPAREN$1,COLON$1,COMMA$1,DOT$1,EXCLAMATION$1,OPENANGLEBRACKET$1,OPENBRACE$1,OPENBRACKET$1,OPENPAREN$1,QUERY$1,QUOTE$1,SEMI$1];// Types of tokens that can follow a URL and be part of the query string
// but cannot be the very last characters
// Characters that cannot appear in the URL at all should be excluded
// These states are responsible primarily for determining whether or not to
// include the final round bracket.
// URL, followed by an opening bracket
makeT$1(S_URL,OPENBRACE$1,S_URL_OPENBRACE),makeT$1(S_URL,OPENBRACKET$1,S_URL_OPENBRACKET),makeT$1(S_URL,OPENANGLEBRACKET$1,S_URL_OPENANGLEBRACKET),makeT$1(S_URL,OPENPAREN$1,S_URL_OPENPAREN),// URL with extra symbols at the end, followed by an opening bracket
makeT$1(S_URL_NON_ACCEPTING,OPENBRACE$1,S_URL_OPENBRACE),makeT$1(S_URL_NON_ACCEPTING,OPENBRACKET$1,S_URL_OPENBRACKET),makeT$1(S_URL_NON_ACCEPTING,OPENANGLEBRACKET$1,S_URL_OPENANGLEBRACKET),makeT$1(S_URL_NON_ACCEPTING,OPENPAREN$1,S_URL_OPENPAREN),// Closing bracket component. This character WILL be included in the URL
makeT$1(S_URL_OPENBRACE,CLOSEBRACE$1,S_URL),makeT$1(S_URL_OPENBRACKET,CLOSEBRACKET$1,S_URL),makeT$1(S_URL_OPENANGLEBRACKET,CLOSEANGLEBRACKET$1,S_URL),makeT$1(S_URL_OPENPAREN,CLOSEPAREN$1,S_URL),makeT$1(S_URL_OPENBRACE_Q,CLOSEBRACE$1,S_URL),makeT$1(S_URL_OPENBRACKET_Q,CLOSEBRACKET$1,S_URL),makeT$1(S_URL_OPENANGLEBRACKET_Q,CLOSEANGLEBRACKET$1,S_URL),makeT$1(S_URL_OPENPAREN_Q,CLOSEPAREN$1,S_URL),makeT$1(S_URL_OPENBRACE_SYMS,CLOSEBRACE$1,S_URL),makeT$1(S_URL_OPENBRACKET_SYMS,CLOSEBRACKET$1,S_URL),makeT$1(S_URL_OPENANGLEBRACKET_SYMS,CLOSEANGLEBRACKET$1,S_URL),makeT$1(S_URL_OPENPAREN_SYMS,CLOSEPAREN$1,S_URL),// URL that beings with an opening bracket, followed by a symbols.
// Note that the final state can still be `S_URL_OPENBRACE_Q` (if the URL only
// has a single opening bracket for some reason).
makeMultiT$1(S_URL_OPENBRACE,qsAccepting,S_URL_OPENBRACE_Q),makeMultiT$1(S_URL_OPENBRACKET,qsAccepting,S_URL_OPENBRACKET_Q),makeMultiT$1(S_URL_OPENANGLEBRACKET,qsAccepting,S_URL_OPENANGLEBRACKET_Q),makeMultiT$1(S_URL_OPENPAREN,qsAccepting,S_URL_OPENPAREN_Q),makeMultiT$1(S_URL_OPENBRACE,qsNonAccepting,S_URL_OPENBRACE_SYMS),makeMultiT$1(S_URL_OPENBRACKET,qsNonAccepting,S_URL_OPENBRACKET_SYMS),makeMultiT$1(S_URL_OPENANGLEBRACKET,qsNonAccepting,S_URL_OPENANGLEBRACKET_SYMS),makeMultiT$1(S_URL_OPENPAREN,qsNonAccepting,S_URL_OPENPAREN_SYMS),// URL that begins with an opening bracket, followed by some symbols
makeMultiT$1(S_URL_OPENBRACE_Q,qsAccepting,S_URL_OPENBRACE_Q),makeMultiT$1(S_URL_OPENBRACKET_Q,qsAccepting,S_URL_OPENBRACKET_Q),makeMultiT$1(S_URL_OPENANGLEBRACKET_Q,qsAccepting,S_URL_OPENANGLEBRACKET_Q),makeMultiT$1(S_URL_OPENPAREN_Q,qsAccepting,S_URL_OPENPAREN_Q),makeMultiT$1(S_URL_OPENBRACE_Q,qsNonAccepting,S_URL_OPENBRACE_Q),makeMultiT$1(S_URL_OPENBRACKET_Q,qsNonAccepting,S_URL_OPENBRACKET_Q),makeMultiT$1(S_URL_OPENANGLEBRACKET_Q,qsNonAccepting,S_URL_OPENANGLEBRACKET_Q),makeMultiT$1(S_URL_OPENPAREN_Q,qsNonAccepting,S_URL_OPENPAREN_Q),makeMultiT$1(S_URL_OPENBRACE_SYMS,qsAccepting,S_URL_OPENBRACE_Q),makeMultiT$1(S_URL_OPENBRACKET_SYMS,qsAccepting,S_URL_OPENBRACKET_Q),makeMultiT$1(S_URL_OPENANGLEBRACKET_SYMS,qsAccepting,S_URL_OPENANGLEBRACKET_Q),makeMultiT$1(S_URL_OPENPAREN_SYMS,qsAccepting,S_URL_OPENPAREN_Q),makeMultiT$1(S_URL_OPENBRACE_SYMS,qsNonAccepting,S_URL_OPENBRACE_SYMS),makeMultiT$1(S_URL_OPENBRACKET_SYMS,qsNonAccepting,S_URL_OPENBRACKET_SYMS),makeMultiT$1(S_URL_OPENANGLEBRACKET_SYMS,qsNonAccepting,S_URL_OPENANGLEBRACKET_SYMS),makeMultiT$1(S_URL_OPENPAREN_SYMS,qsNonAccepting,S_URL_OPENPAREN_SYMS),// Account for the query string
makeMultiT$1(S_URL,qsAccepting,S_URL),makeMultiT$1(S_URL_NON_ACCEPTING,qsAccepting,S_URL),makeMultiT$1(S_URL,qsNonAccepting,S_URL_NON_ACCEPTING),makeMultiT$1(S_URL_NON_ACCEPTING,qsNonAccepting,S_URL_NON_ACCEPTING),// Email address-specific state definitions
// Note: We are not allowing '/' in email addresses since this would interfere
// with real URLs
// For addresses with the mailto prefix
// 'mailto:' followed by anything sane is a valid email
makeT$1(S_MAILTO,TLD$1,S_MAILTO_EMAIL),makeT$1(S_MAILTO,DOMAIN$1,S_MAILTO_EMAIL),makeT$1(S_MAILTO,NUM$1,S_MAILTO_EMAIL),makeT$1(S_MAILTO,LOCALHOST$1,S_MAILTO_EMAIL),// Greedily get more potential valid email values
makeMultiT$1(S_MAILTO_EMAIL,qsAccepting,S_MAILTO_EMAIL),makeMultiT$1(S_MAILTO_EMAIL,qsNonAccepting,S_MAILTO_EMAIL_NON_ACCEPTING),makeMultiT$1(S_MAILTO_EMAIL_NON_ACCEPTING,qsAccepting,S_MAILTO_EMAIL),makeMultiT$1(S_MAILTO_EMAIL_NON_ACCEPTING,qsNonAccepting,S_MAILTO_EMAIL_NON_ACCEPTING);// For addresses without the mailto prefix
// Tokens allowed in the localpart of the email
var localpartAccepting=[AMPERSAND$1,APOSTROPHE$1,ASTERISK$1,BACKSLASH$1,BACKTICK$1,CARET$1,CLOSEBRACE$1,DOLLAR$1,DOMAIN$1,EQUALS$1,HYPHEN$1,NUM$1,OPENBRACE$1,PERCENT$1,PIPE$1,PLUS$1,POUND$1,QUERY$1,SLASH$1,SYM$1,TILDE$1,TLD$1,UNDERSCORE$1];// Some of the tokens in `localpartAccepting` are already accounted for here and
// will not be overwritten (don't worry)
// States following `@` defined above
return makeMultiT$1(S_DOMAIN,localpartAccepting,S_LOCALPART),makeT$1(S_DOMAIN,AT$1,S_LOCALPART_AT),makeMultiT$1(S_TLD,localpartAccepting,S_LOCALPART),makeT$1(S_TLD,AT$1,S_LOCALPART_AT),makeMultiT$1(S_DOMAIN_DOT,localpartAccepting,S_LOCALPART),// Now in localpart of address
// TODO: IP addresses and what if the email starts with numbers?
makeMultiT$1(S_LOCALPART,localpartAccepting,S_LOCALPART),makeT$1(S_LOCALPART,AT$1,S_LOCALPART_AT),// close to an email address now
makeT$1(S_LOCALPART,DOT$1,S_LOCALPART_DOT),makeMultiT$1(S_LOCALPART_DOT,localpartAccepting,S_LOCALPART),makeT$1(S_LOCALPART_AT,TLD$1,S_EMAIL_DOMAIN),makeT$1(S_LOCALPART_AT,DOMAIN$1,S_EMAIL_DOMAIN),makeT$1(S_LOCALPART_AT,NUM$1,S_EMAIL_DOMAIN),makeT$1(S_LOCALPART_AT,LOCALHOST$1,S_EMAIL),S_START}
/**
 * Run the parser state machine on a list of scanned string-based tokens to
 * create a list of multi tokens, each of which represents a URL, email address,
 * plain text, etc.
 *
 * @param {State} start parser start state
 * @param {string} input the original input used to generate the given tokens
 * @param {{t: string, v: string, s: number, e: number}[]} tokens list of scanned tokens
 * @returns {MultiToken[]}
 */function run$3(start,input,tokens){var len=tokens.length,cursor=0,multis=[],textTokens=[];while(cursor<len){var state=start,secondState=null,nextState=null,multiLength=0,latestAccepting=null,sinceAccepts=-1;while(cursor<len&&!(secondState=takeT$1(state,tokens[cursor].t)))
// Starting tokens with nowhere to jump to.
// Consider these to be just plain text
textTokens.push(tokens[cursor++]);while(cursor<len&&(nextState=secondState||takeT$1(state,tokens[cursor].t)))
// Get the next state
secondState=null,state=nextState,// Keep track of the latest accepting state
state.accepts()?(sinceAccepts=0,latestAccepting=state):sinceAccepts>=0&&sinceAccepts++,cursor++,multiLength++;if(sinceAccepts<0)
// No accepting state was found, part of a regular text token
// Add all the tokens we looked at to the text tokens array
for(var i=cursor-multiLength;i<cursor;i++)textTokens.push(tokens[i]);else{
// Accepting state!
// First close off the textTokens (if available)
textTokens.length>0&&(multis.push(parserCreateMultiToken$1(Text$2,input,textTokens)),textTokens=[]),// Roll back to the latest accepting state
cursor-=sinceAccepts,multiLength-=sinceAccepts;// Create a new multitoken
var Multi=latestAccepting.t,subtokens=tokens.slice(cursor-multiLength,cursor);multis.push(parserCreateMultiToken$1(Multi,input,subtokens))}}// Finally close off the textTokens (if available)
return textTokens.length>0&&multis.push(parserCreateMultiToken$1(Text$2,input,textTokens)),multis}
/**
 * Utility function for instantiating a new multitoken with all the relevant
 * fields during parsing.
 * @param {Class<MultiToken>} Multi class to instantiate
 * @param {string} input original input string
 * @param {{t: string, v: string, s: number, e: number}[]} tokens consecutive tokens scanned from input string
 * @returns {MultiToken}
 */function parserCreateMultiToken$1(Multi,input,tokens){var startIdx=tokens[0].s,endIdx=tokens[tokens.length-1].e,value=input.substr(startIdx,endIdx-startIdx);return new Multi(value,tokens)}var warn$1="undefined"!==typeof console&&console&&console.warn||function(){},INIT$1={scanner:null,parser:null,pluginQueue:[],customProtocols:[],initialized:!1};// Side-effect initialization state
/**
 * Detect URLs with the following additional protocol. Anything following
 * "protocol:" will be considered a link.
 * @param {string} protocol
 */
function registerCustomProtocol$1(protocol){if(INIT$1.initialized&&warn$1('linkifyjs: already initialized - will not register custom protocol "'.concat(protocol,'" until you manually call linkify.init(). To avoid this warning, please register all custom protocols before invoking linkify the first time.')),!/^[a-z-]+$/.test(protocol))throw Error("linkifyjs: protocols containing characters other than a-z or - (hyphen) are not supported");INIT$1.customProtocols.push(protocol)}
/**
 * Initialize the linkify state machine. Called automatically the first time
 * linkify is called on a string, but may be called manually as well.
 */function init$3(){
// Initialize state machines
INIT$1.scanner={start:init$2$1(INIT$1.customProtocols),tokens:text$2},INIT$1.parser={start:init$1$1(),tokens:multi$1};// Initialize plugins
for(var utils={createTokenClass:createTokenClass$1},i=0;i<INIT$1.pluginQueue.length;i++)INIT$1.pluginQueue[i][1]({scanner:INIT$1.scanner,parser:INIT$1.parser,utils:utils});INIT$1.initialized=!0}
/**
	Parse a string into tokens that represent linkable and non-linkable sub-components
	@param {string} str
	@return {MultiToken[]} tokens
*/function tokenize$1(str){return INIT$1.initialized||init$3(),run$3(INIT$1.parser.start,str,run$1$2(INIT$1.scanner.start,str))}
/**
	Find a list of linkable items in the given string.
	@param {string} str string to find links in
	@param {string} [type] (optional) only find links of a specific type, e.g.,
	'url' or 'email'
*/function find$2$1(str){for(var type=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,tokens=tokenize$1(str),filtered=[],i=0;i<tokens.length;i++){var token=tokens[i];!token.isLink||type&&token.t!==type||filtered.push(token.toObject())}return filtered}
/**
 * Is the given string valid linkable text of some sort. Note that this does not
 * trim the text for you.
 *
 * Optionally pass in a second `type` param, which is the type of link to test
 * for.
 *
 * For example,
 *
 *     linkify.test(str, 'email');
 *
 * Returns `true` if str is a valid email.
 * @param {string} str string to test for links
 * @param {string} [type] optional specific link type to look for
 * @returns boolean true/false
 */function test$1(str){var type=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,tokens=tokenize$1(str);return 1===tokens.length&&tokens[0].isLink&&(!type||tokens[0].t===type)}function autolink$1(options){return new Plugin$1({key:new PluginKey$1("autolink"),appendTransaction:(transactions,oldState,newState)=>{const docChanges=transactions.some((transaction=>transaction.docChanged))&&!oldState.doc.eq(newState.doc),preventAutolink=transactions.some((transaction=>transaction.getMeta("preventAutolink")));if(!docChanges||preventAutolink)return;const{tr:tr}=newState,transform=combineTransactionSteps$1(oldState.doc,[...transactions]),{mapping:mapping}=transform,changes=getChangedRanges$1(transform);return changes.forEach((({oldRange:oldRange,newRange:newRange})=>{
// at first we check if we have to remove links
getMarksBetween$1(oldRange.from,oldRange.to,oldState.doc).filter((item=>item.mark.type===options.type)).forEach((oldMark=>{const newFrom=mapping.map(oldMark.from),newTo=mapping.map(oldMark.to),newMarks=getMarksBetween$1(newFrom,newTo,newState.doc).filter((item=>item.mark.type===options.type));if(!newMarks.length)return;const newMark=newMarks[0],oldLinkText=oldState.doc.textBetween(oldMark.from,oldMark.to,void 0," "),newLinkText=newState.doc.textBetween(newMark.from,newMark.to,void 0," "),wasLink=test$1(oldLinkText),isLink=test$1(newLinkText);
// remove only the link, if it was a link before too
// because we don’t want to remove links that were set manually
wasLink&&!isLink&&tr.removeMark(newMark.from,newMark.to,options.type)})),
// now let’s see if we can add new links
findChildrenInRange$1(newState.doc,newRange,(node=>node.isTextblock)).forEach((textBlock=>{
// we need to define a placeholder for leaf nodes
// so that the link position can be calculated correctly
const text=newState.doc.textBetween(textBlock.pos,textBlock.pos+textBlock.node.nodeSize,void 0," ");find$2$1(text).filter((link=>link.isLink)).filter((link=>!options.validate||options.validate(link.value))).map((link=>({...link,from:textBlock.pos+link.start+1,to:textBlock.pos+link.end+1})
// check if link is within the changed range
)).filter((link=>{const fromIsInRange=newRange.from>=link.from&&newRange.from<=link.to,toIsInRange=newRange.to>=link.from&&newRange.to<=link.to;return fromIsInRange||toIsInRange})).forEach((link=>{tr.addMark(link.from,link.to,options.type.create({href:link.href}))}))}))})),tr.steps.length?tr:void 0}})}function clickHandler$1(options){return new Plugin$1({key:new PluginKey$1("handleClickLink"),props:{handleClick:(view,pos,event)=>{var _a;const attrs=getAttributes$1(view.state,options.type.name),link=null===(_a=event.target)||void 0===_a?void 0:_a.closest("a");return!(!link||!attrs.href)&&(window.open(attrs.href,attrs.target),!0)}}})}function pasteHandler$1(options){return new Plugin$1({key:new PluginKey$1("handlePasteLink"),props:{handlePaste:(view,event,slice)=>{const{state:state}=view,{selection:selection}=state,{empty:empty}=selection;if(empty)return!1;let textContent="";slice.content.forEach((node=>{textContent+=node.textContent}));const link=find$2$1(textContent).find((item=>item.isLink&&item.value===textContent));return!(!textContent||!link)&&(options.editor.commands.setMark(options.type,{href:link.href}),!0)}}})}const Link$1$1=Mark$2.create({name:"link",priority:1e3,keepOnSplit:!1,onCreate(){this.options.protocols.forEach(registerCustomProtocol$1)},inclusive(){return this.options.autolink},addOptions(){return{openOnClick:!0,linkOnPaste:!0,autolink:!0,protocols:[],HTMLAttributes:{target:"_blank",rel:"noopener noreferrer nofollow",class:null},validate:void 0}},addAttributes(){return{href:{default:null},target:{default:this.options.HTMLAttributes.target},class:{default:this.options.HTMLAttributes.class}}},parseHTML(){return[{tag:'a[href]:not([href *= "javascript:" i])'}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["a",mergeAttributes$1(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setLink:attributes=>({chain:chain})=>chain().setMark(this.name,attributes).setMeta("preventAutolink",!0).run(),toggleLink:attributes=>({chain:chain})=>chain().toggleMark(this.name,attributes,{extendEmptyMarkRange:!0}).setMeta("preventAutolink",!0).run(),unsetLink:()=>({chain:chain})=>chain().unsetMark(this.name,{extendEmptyMarkRange:!0}).setMeta("preventAutolink",!0).run()}},addPasteRules(){return[markPasteRule$1({find:text=>find$2$1(text).filter((link=>!this.options.validate||this.options.validate(link.value))).filter((link=>link.isLink)).map((link=>({text:link.value,index:link.start,data:link}))),type:this.type,getAttributes:match=>{var _a;return{href:null===(_a=match.data)||void 0===_a?void 0:_a.href}}})]},addProseMirrorPlugins(){const plugins=[];return this.options.autolink&&plugins.push(autolink$1({type:this.type,validate:this.options.validate})),this.options.openOnClick&&plugins.push(clickHandler$1({type:this.type})),this.options.linkOnPaste&&plugins.push(pasteHandler$1({editor:this.editor,type:this.type})),plugins}});function _typeof$5(obj){return _typeof$5="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof$5(obj)}function _defineProperty$1$1(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _classCallCheck$1(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _defineProperties$1(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass$1(Constructor,protoProps,staticProps){return protoProps&&_defineProperties$1(Constructor.prototype,protoProps),staticProps&&_defineProperties$1(Constructor,staticProps),Object.defineProperty(Constructor,"prototype",{writable:!1}),Constructor}
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */Link$1$1.extend({addAttributes(){return{href:{default:null},target:{default:this.options.HTMLAttributes.target},style:{default:null}}}});var isBrowser$2$1="undefined"!==typeof window&&"undefined"!==typeof document&&"undefined"!==typeof navigator,timeoutDuration$1$1=function(){for(var longerTimeoutBrowsers=["Edge","Trident","Firefox"],i=0;i<longerTimeoutBrowsers.length;i+=1)if(isBrowser$2$1&&navigator.userAgent.indexOf(longerTimeoutBrowsers[i])>=0)return 1;return 0}();function microtaskDebounce$1$1(fn){var called=!1;return function(){called||(called=!0,window.Promise.resolve().then((function(){called=!1,fn()})))}}function taskDebounce$1$1(fn){var scheduled=!1;return function(){scheduled||(scheduled=!0,setTimeout((function(){scheduled=!1,fn()}),timeoutDuration$1$1))}}var supportsMicroTasks$1$1=isBrowser$2$1&&window.Promise,debounce$2$1=supportsMicroTasks$1$1?microtaskDebounce$1$1:taskDebounce$1$1;
/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction$1$1(functionToCheck){var getType={};return functionToCheck&&"[object Function]"===getType.toString.call(functionToCheck)}
/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */function getStyleComputedProperty$1$1(element,property){if(1!==element.nodeType)return[];
// NOTE: 1 DOM access here
var window=element.ownerDocument.defaultView,css=window.getComputedStyle(element,null);return property?css[property]:css}
/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */function getParentNode$1$1(element){return"HTML"===element.nodeName?element:element.parentNode||element.host}
/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */function getScrollParent$1$1(element){
// Return body, `getScroll` will take care to get the correct `scrollTop` from it
if(!element)return document.body;switch(element.nodeName){case"HTML":case"BODY":return element.ownerDocument.body;case"#document":return element.body}
// Firefox want us to check `-x` and `-y` variations as well
var _getStyleComputedProp=getStyleComputedProperty$1$1(element),overflow=_getStyleComputedProp.overflow,overflowX=_getStyleComputedProp.overflowX,overflowY=_getStyleComputedProp.overflowY;return/(auto|scroll|overlay)/.test(overflow+overflowY+overflowX)?element:getScrollParent$1$1(getParentNode$1$1(element))}
/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */function getReferenceNode$1$1(reference){return reference&&reference.referenceNode?reference.referenceNode:reference}var isIE11$1$1=isBrowser$2$1&&!(!window.MSInputMethodContext||!document.documentMode),isIE10$1$1=isBrowser$2$1&&/MSIE 10/.test(navigator.userAgent);
/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE$3$1(version){return 11===version?isIE11$1$1:10===version?isIE10$1$1:isIE11$1$1||isIE10$1$1}
/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */function getOffsetParent$1$1(element){if(!element)return document.documentElement;var noOffsetParent=isIE$3$1(10)?document.body:null,offsetParent=element.offsetParent||null;
// NOTE: 1 DOM access here
// Skip hidden elements which don't have an offsetParent
while(offsetParent===noOffsetParent&&element.nextElementSibling)offsetParent=(element=element.nextElementSibling).offsetParent;var nodeName=offsetParent&&offsetParent.nodeName;return nodeName&&"BODY"!==nodeName&&"HTML"!==nodeName?
// .offsetParent will return the closest TH, TD or TABLE in case
// no offsetParent is present, I hate this job...
-1!==["TH","TD","TABLE"].indexOf(offsetParent.nodeName)&&"static"===getStyleComputedProperty$1$1(offsetParent,"position")?getOffsetParent$1$1(offsetParent):offsetParent:element?element.ownerDocument.documentElement:document.documentElement}function isOffsetContainer$1$1(element){var nodeName=element.nodeName;return"BODY"!==nodeName&&("HTML"===nodeName||getOffsetParent$1$1(element.firstElementChild)===element)}
/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */function getRoot$1$1(node){return null!==node.parentNode?getRoot$1$1(node.parentNode):node}
/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */function findCommonOffsetParent$1$1(element1,element2){
// This check is needed to avoid errors in case one of the elements isn't defined for any reason
if(!element1||!element1.nodeType||!element2||!element2.nodeType)return document.documentElement;
// Here we make sure to give as "start" the element that comes first in the DOM
var order=element1.compareDocumentPosition(element2)&Node.DOCUMENT_POSITION_FOLLOWING,start=order?element1:element2,end=order?element2:element1,range=document.createRange();range.setStart(start,0),range.setEnd(end,0);var commonAncestorContainer=range.commonAncestorContainer;
// Both nodes are inside #document
if(element1!==commonAncestorContainer&&element2!==commonAncestorContainer||start.contains(end))return isOffsetContainer$1$1(commonAncestorContainer)?commonAncestorContainer:getOffsetParent$1$1(commonAncestorContainer);
// one of the nodes is inside shadowDOM, find which one
var element1root=getRoot$1$1(element1);return element1root.host?findCommonOffsetParent$1$1(element1root.host,element2):findCommonOffsetParent$1$1(element1,getRoot$1$1(element2).host)}
/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */function getScroll$1$1(element){var side=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"top",upperSide="top"===side?"scrollTop":"scrollLeft",nodeName=element.nodeName;if("BODY"===nodeName||"HTML"===nodeName){var html=element.ownerDocument.documentElement,scrollingElement=element.ownerDocument.scrollingElement||html;return scrollingElement[upperSide]}return element[upperSide]}
/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */function includeScroll$1$1(rect,element){var subtract=arguments.length>2&&void 0!==arguments[2]&&arguments[2],scrollTop=getScroll$1$1(element,"top"),scrollLeft=getScroll$1$1(element,"left"),modifier=subtract?-1:1;return rect.top+=scrollTop*modifier,rect.bottom+=scrollTop*modifier,rect.left+=scrollLeft*modifier,rect.right+=scrollLeft*modifier,rect}
/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */function getBordersSize$1$1(styles,axis){var sideA="x"===axis?"Left":"Top",sideB="Left"===sideA?"Right":"Bottom";return parseFloat(styles["border"+sideA+"Width"])+parseFloat(styles["border"+sideB+"Width"])}function getSize$1$1(axis,body,html,computedStyle){return Math.max(body["offset"+axis],body["scroll"+axis],html["client"+axis],html["offset"+axis],html["scroll"+axis],isIE$3$1(10)?parseInt(html["offset"+axis])+parseInt(computedStyle["margin"+("Height"===axis?"Top":"Left")])+parseInt(computedStyle["margin"+("Height"===axis?"Bottom":"Right")]):0)}function getWindowSizes$1$1(document){var body=document.body,html=document.documentElement,computedStyle=isIE$3$1(10)&&getComputedStyle(html);return{height:getSize$1$1("Height",body,html,computedStyle),width:getSize$1$1("Width",body,html,computedStyle)}}var classCallCheck$1$1=function(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")},createClass$1$1=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),defineProperty$1$1=function(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj},_extends$2$1=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target};
/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect$1$1(offsets){return _extends$2$1({},offsets,{right:offsets.left+offsets.width,bottom:offsets.top+offsets.height})}
/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */function getBoundingClientRect$1$1(element){var rect={};
// IE10 10 FIX: Please, don't ask, the element isn't
// considered in DOM in some circumstances...
// This isn't reproducible in IE10 compatibility mode of IE11
try{if(isIE$3$1(10)){rect=element.getBoundingClientRect();var scrollTop=getScroll$1$1(element,"top"),scrollLeft=getScroll$1$1(element,"left");rect.top+=scrollTop,rect.left+=scrollLeft,rect.bottom+=scrollTop,rect.right+=scrollLeft}else rect=element.getBoundingClientRect()}catch(e){}var result={left:rect.left,top:rect.top,width:rect.right-rect.left,height:rect.bottom-rect.top},sizes="HTML"===element.nodeName?getWindowSizes$1$1(element.ownerDocument):{},width=sizes.width||element.clientWidth||result.width,height=sizes.height||element.clientHeight||result.height,horizScrollbar=element.offsetWidth-width,vertScrollbar=element.offsetHeight-height;
// subtract scrollbar size from sizes
// if an hypothetical scrollbar is detected, we must be sure it's not a `border`
// we make this check conditional for performance reasons
if(horizScrollbar||vertScrollbar){var styles=getStyleComputedProperty$1$1(element);horizScrollbar-=getBordersSize$1$1(styles,"x"),vertScrollbar-=getBordersSize$1$1(styles,"y"),result.width-=horizScrollbar,result.height-=vertScrollbar}return getClientRect$1$1(result)}function getOffsetRectRelativeToArbitraryNode$1$1(children,parent){var fixedPosition=arguments.length>2&&void 0!==arguments[2]&&arguments[2],isIE10=isIE$3$1(10),isHTML="HTML"===parent.nodeName,childrenRect=getBoundingClientRect$1$1(children),parentRect=getBoundingClientRect$1$1(parent),scrollParent=getScrollParent$1$1(children),styles=getStyleComputedProperty$1$1(parent),borderTopWidth=parseFloat(styles.borderTopWidth),borderLeftWidth=parseFloat(styles.borderLeftWidth);
// In cases where the parent is fixed, we must ignore negative scroll in offset calc
fixedPosition&&isHTML&&(parentRect.top=Math.max(parentRect.top,0),parentRect.left=Math.max(parentRect.left,0));var offsets=getClientRect$1$1({top:childrenRect.top-parentRect.top-borderTopWidth,left:childrenRect.left-parentRect.left-borderLeftWidth,width:childrenRect.width,height:childrenRect.height});
// Subtract margins of documentElement in case it's being used as parent
// we do this only on HTML because it's the only element that behaves
// differently when margins are applied to it. The margins are included in
// the box of the documentElement, in the other cases not.
if(offsets.marginTop=0,offsets.marginLeft=0,!isIE10&&isHTML){var marginTop=parseFloat(styles.marginTop),marginLeft=parseFloat(styles.marginLeft);offsets.top-=borderTopWidth-marginTop,offsets.bottom-=borderTopWidth-marginTop,offsets.left-=borderLeftWidth-marginLeft,offsets.right-=borderLeftWidth-marginLeft,
// Attach marginTop and marginLeft because in some circumstances we may need them
offsets.marginTop=marginTop,offsets.marginLeft=marginLeft}return(isIE10&&!fixedPosition?parent.contains(scrollParent):parent===scrollParent&&"BODY"!==scrollParent.nodeName)&&(offsets=includeScroll$1$1(offsets,parent)),offsets}function getViewportOffsetRectRelativeToArtbitraryNode$1$1(element){var excludeScroll=arguments.length>1&&void 0!==arguments[1]&&arguments[1],html=element.ownerDocument.documentElement,relativeOffset=getOffsetRectRelativeToArbitraryNode$1$1(element,html),width=Math.max(html.clientWidth,window.innerWidth||0),height=Math.max(html.clientHeight,window.innerHeight||0),scrollTop=excludeScroll?0:getScroll$1$1(html),scrollLeft=excludeScroll?0:getScroll$1$1(html,"left"),offset={top:scrollTop-relativeOffset.top+relativeOffset.marginTop,left:scrollLeft-relativeOffset.left+relativeOffset.marginLeft,width:width,height:height};return getClientRect$1$1(offset)}
/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */function isFixed$1$1(element){var nodeName=element.nodeName;if("BODY"===nodeName||"HTML"===nodeName)return!1;if("fixed"===getStyleComputedProperty$1$1(element,"position"))return!0;var parentNode=getParentNode$1$1(element);return!!parentNode&&isFixed$1$1(parentNode)}
/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */function getFixedPositionOffsetParent$1$1(element){
// This check is needed to avoid errors in case one of the elements isn't defined for any reason
if(!element||!element.parentElement||isIE$3$1())return document.documentElement;var el=element.parentElement;while(el&&"none"===getStyleComputedProperty$1$1(el,"transform"))el=el.parentElement;return el||document.documentElement}
/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */function getBoundaries$1$1(popper,reference,padding,boundariesElement){var fixedPosition=arguments.length>4&&void 0!==arguments[4]&&arguments[4],boundaries={top:0,left:0},offsetParent=fixedPosition?getFixedPositionOffsetParent$1$1(popper):findCommonOffsetParent$1$1(popper,getReferenceNode$1$1(reference));
// NOTE: 1 DOM access here
// Handle viewport case
if("viewport"===boundariesElement)boundaries=getViewportOffsetRectRelativeToArtbitraryNode$1$1(offsetParent,fixedPosition);else{
// Handle other cases based on DOM element used as boundaries
var boundariesNode=void 0;"scrollParent"===boundariesElement?(boundariesNode=getScrollParent$1$1(getParentNode$1$1(reference)),"BODY"===boundariesNode.nodeName&&(boundariesNode=popper.ownerDocument.documentElement)):boundariesNode="window"===boundariesElement?popper.ownerDocument.documentElement:boundariesElement;var offsets=getOffsetRectRelativeToArbitraryNode$1$1(boundariesNode,offsetParent,fixedPosition);
// In case of HTML, we need a different computation
if("HTML"!==boundariesNode.nodeName||isFixed$1$1(offsetParent))
// for all the other DOM elements, this one is good
boundaries=offsets;else{var _getWindowSizes=getWindowSizes$1$1(popper.ownerDocument),height=_getWindowSizes.height,width=_getWindowSizes.width;boundaries.top+=offsets.top-offsets.marginTop,boundaries.bottom=height+offsets.top,boundaries.left+=offsets.left-offsets.marginLeft,boundaries.right=width+offsets.left}}
// Add paddings
padding=padding||0;var isPaddingNumber="number"===typeof padding;return boundaries.left+=isPaddingNumber?padding:padding.left||0,boundaries.top+=isPaddingNumber?padding:padding.top||0,boundaries.right-=isPaddingNumber?padding:padding.right||0,boundaries.bottom-=isPaddingNumber?padding:padding.bottom||0,boundaries}function getArea$1$1(_ref){var width=_ref.width,height=_ref.height;return width*height}
/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function computeAutoPlacement$1$1(placement,refRect,popper,reference,boundariesElement){var padding=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(-1===placement.indexOf("auto"))return placement;var boundaries=getBoundaries$1$1(popper,reference,padding,boundariesElement),rects={top:{width:boundaries.width,height:refRect.top-boundaries.top},right:{width:boundaries.right-refRect.right,height:boundaries.height},bottom:{width:boundaries.width,height:boundaries.bottom-refRect.bottom},left:{width:refRect.left-boundaries.left,height:boundaries.height}},sortedAreas=Object.keys(rects).map((function(key){return _extends$2$1({key:key},rects[key],{area:getArea$1$1(rects[key])})})).sort((function(a,b){return b.area-a.area})),filteredAreas=sortedAreas.filter((function(_ref2){var width=_ref2.width,height=_ref2.height;return width>=popper.clientWidth&&height>=popper.clientHeight})),computedPlacement=filteredAreas.length>0?filteredAreas[0].key:sortedAreas[0].key,variation=placement.split("-")[1];return computedPlacement+(variation?"-"+variation:"")}
/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */function getReferenceOffsets$1$1(state,popper,reference){var fixedPosition=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,commonOffsetParent=fixedPosition?getFixedPositionOffsetParent$1$1(popper):findCommonOffsetParent$1$1(popper,getReferenceNode$1$1(reference));return getOffsetRectRelativeToArbitraryNode$1$1(reference,commonOffsetParent,fixedPosition)}
/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */function getOuterSizes$1$1(element){var window=element.ownerDocument.defaultView,styles=window.getComputedStyle(element),x=parseFloat(styles.marginTop||0)+parseFloat(styles.marginBottom||0),y=parseFloat(styles.marginLeft||0)+parseFloat(styles.marginRight||0),result={width:element.offsetWidth+y,height:element.offsetHeight+x};return result}
/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */function getOppositePlacement$1$1(placement){var hash={left:"right",right:"left",bottom:"top",top:"bottom"};return placement.replace(/left|right|bottom|top/g,(function(matched){return hash[matched]}))}
/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */function getPopperOffsets$1$1(popper,referenceOffsets,placement){placement=placement.split("-")[0];
// Get popper node sizes
var popperRect=getOuterSizes$1$1(popper),popperOffsets={width:popperRect.width,height:popperRect.height},isHoriz=-1!==["right","left"].indexOf(placement),mainSide=isHoriz?"top":"left",secondarySide=isHoriz?"left":"top",measurement=isHoriz?"height":"width",secondaryMeasurement=isHoriz?"width":"height";
// Add position, width and height to our offsets object
return popperOffsets[mainSide]=referenceOffsets[mainSide]+referenceOffsets[measurement]/2-popperRect[measurement]/2,popperOffsets[secondarySide]=placement===secondarySide?referenceOffsets[secondarySide]-popperRect[secondaryMeasurement]:referenceOffsets[getOppositePlacement$1$1(secondarySide)],popperOffsets}
/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */function find$1$1(arr,check){
// use native find if supported
return Array.prototype.find?arr.find(check):arr.filter(check)[0];
// use `filter` to obtain the same behavior of `find`
}
/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */function findIndex$1$1(arr,prop,value){
// use native findIndex if supported
if(Array.prototype.findIndex)return arr.findIndex((function(cur){return cur[prop]===value}));
// use `find` + `indexOf` if `findIndex` isn't supported
var match=find$1$1(arr,(function(obj){return obj[prop]===value}));return arr.indexOf(match)}
/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */function runModifiers$1$1(modifiers,data,ends){var modifiersToRun=void 0===ends?modifiers:modifiers.slice(0,findIndex$1$1(modifiers,"name",ends));return modifiersToRun.forEach((function(modifier){modifier["function"];var fn=modifier["function"]||modifier.fn;// eslint-disable-line dot-notation
modifier.enabled&&isFunction$1$1(fn)&&(
// Add properties to offsets to make them a complete clientRect object
// we do this before each modifier to make sure the previous one doesn't
// mess with these values
data.offsets.popper=getClientRect$1$1(data.offsets.popper),data.offsets.reference=getClientRect$1$1(data.offsets.reference),data=fn(data,modifier))})),data}
/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */function update$1$1(){
// if popper is destroyed, don't perform any further update
if(!this.state.isDestroyed){var data={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};
// compute reference element offsets
data.offsets.reference=getReferenceOffsets$1$1(this.state,this.popper,this.reference,this.options.positionFixed),
// compute auto placement, store placement inside the data object,
// modifiers will be able to edit `placement` if needed
// and refer to originalPlacement to know the original value
data.placement=computeAutoPlacement$1$1(this.options.placement,data.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),
// store the computed placement inside `originalPlacement`
data.originalPlacement=data.placement,data.positionFixed=this.options.positionFixed,
// compute the popper offsets
data.offsets.popper=getPopperOffsets$1$1(this.popper,data.offsets.reference,data.placement),data.offsets.popper.position=this.options.positionFixed?"fixed":"absolute",
// run the modifiers
data=runModifiers$1$1(this.modifiers,data),
// the first `update` will call `onCreate` callback
// the other ones will call `onUpdate` callback
this.state.isCreated?this.options.onUpdate(data):(this.state.isCreated=!0,this.options.onCreate(data))}}
/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */function isModifierEnabled$1$1(modifiers,modifierName){return modifiers.some((function(_ref){var name=_ref.name,enabled=_ref.enabled;return enabled&&name===modifierName}))}
/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */function getSupportedPropertyName$1$1(property){for(var prefixes=[!1,"ms","Webkit","Moz","O"],upperProp=property.charAt(0).toUpperCase()+property.slice(1),i=0;i<prefixes.length;i++){var prefix=prefixes[i],toCheck=prefix?""+prefix+upperProp:property;if("undefined"!==typeof document.body.style[toCheck])return toCheck}return null}
/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */function destroy$1$1(){return this.state.isDestroyed=!0,
// touch DOM only if `applyStyle` modifier is enabled
isModifierEnabled$1$1(this.modifiers,"applyStyle")&&(this.popper.removeAttribute("x-placement"),this.popper.style.position="",this.popper.style.top="",this.popper.style.left="",this.popper.style.right="",this.popper.style.bottom="",this.popper.style.willChange="",this.popper.style[getSupportedPropertyName$1$1("transform")]=""),this.disableEventListeners(),
// remove the popper if user explicitly asked for the deletion on destroy
// do not use `remove` because IE11 doesn't support it
this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}
/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */function getWindow$1$1(element){var ownerDocument=element.ownerDocument;return ownerDocument?ownerDocument.defaultView:window}function attachToScrollParents$1$1(scrollParent,event,callback,scrollParents){var isBody="BODY"===scrollParent.nodeName,target=isBody?scrollParent.ownerDocument.defaultView:scrollParent;target.addEventListener(event,callback,{passive:!0}),isBody||attachToScrollParents$1$1(getScrollParent$1$1(target.parentNode),event,callback,scrollParents),scrollParents.push(target)}
/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */function setupEventListeners$1$1(reference,options,state,updateBound){
// Resize event listener on window
state.updateBound=updateBound,getWindow$1$1(reference).addEventListener("resize",state.updateBound,{passive:!0});
// Scroll event listener on scroll parents
var scrollElement=getScrollParent$1$1(reference);return attachToScrollParents$1$1(scrollElement,"scroll",state.updateBound,state.scrollParents),state.scrollElement=scrollElement,state.eventsEnabled=!0,state}
/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */function enableEventListeners$1$1(){this.state.eventsEnabled||(this.state=setupEventListeners$1$1(this.reference,this.options,this.state,this.scheduleUpdate))}
/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */function removeEventListeners$1$1(reference,state){
// Remove resize event listener on window
return getWindow$1$1(reference).removeEventListener("resize",state.updateBound),
// Remove scroll event listener on scroll parents
state.scrollParents.forEach((function(target){target.removeEventListener("scroll",state.updateBound)})),
// Reset state
state.updateBound=null,state.scrollParents=[],state.scrollElement=null,state.eventsEnabled=!1,state}
/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */function disableEventListeners$1$1(){this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=removeEventListeners$1$1(this.reference,this.state))}
/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */function isNumeric$1$1(n){return""!==n&&!isNaN(parseFloat(n))&&isFinite(n)}
/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */function setStyles$1$1(element,styles){Object.keys(styles).forEach((function(prop){var unit="";
// add unit if the value is numeric and is one of the following
-1!==["width","height","top","right","bottom","left"].indexOf(prop)&&isNumeric$1$1(styles[prop])&&(unit="px"),element.style[prop]=styles[prop]+unit}))}
/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */function setAttributes$1$1(element,attributes){Object.keys(attributes).forEach((function(prop){var value=attributes[prop];!1!==value?element.setAttribute(prop,attributes[prop]):element.removeAttribute(prop)}))}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */function applyStyle$1$1(data){
// any property present in `data.styles` will be applied to the popper,
// in this way we can make the 3rd party modifiers add custom styles to it
// Be aware, modifiers could override the properties defined in the previous
// lines of this modifier!
return setStyles$1$1(data.instance.popper,data.styles),
// any property present in `data.attributes` will be applied to the popper,
// they will be set as HTML attributes of the element
setAttributes$1$1(data.instance.popper,data.attributes),
// if arrowElement is defined and arrowStyles has some properties
data.arrowElement&&Object.keys(data.arrowStyles).length&&setStyles$1$1(data.arrowElement,data.arrowStyles),data}
/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */function applyStyleOnLoad$1$1(reference,popper,options,modifierOptions,state){
// compute reference element offsets
var referenceOffsets=getReferenceOffsets$1$1(state,popper,reference,options.positionFixed),placement=computeAutoPlacement$1$1(options.placement,referenceOffsets,popper,reference,options.modifiers.flip.boundariesElement,options.modifiers.flip.padding);
// compute auto placement, store placement inside the data object,
// modifiers will be able to edit `placement` if needed
// and refer to originalPlacement to know the original value
return popper.setAttribute("x-placement",placement),
// Apply `position` to popper before anything else because
// without the position applied we can't guarantee correct computations
setStyles$1$1(popper,{position:options.positionFixed?"fixed":"absolute"}),options}
/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */function getRoundedOffsets$1$1(data,shouldRound){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,round=Math.round,floor=Math.floor,noRound=function(v){return v},referenceWidth=round(reference.width),popperWidth=round(popper.width),isVertical=-1!==["left","right"].indexOf(data.placement),isVariation=-1!==data.placement.indexOf("-"),sameWidthParity=referenceWidth%2===popperWidth%2,bothOddWidth=referenceWidth%2===1&&popperWidth%2===1,horizontalToInteger=shouldRound?isVertical||isVariation||sameWidthParity?round:floor:noRound,verticalToInteger=shouldRound?round:noRound;return{left:horizontalToInteger(bothOddWidth&&!isVariation&&shouldRound?popper.left-1:popper.left),top:verticalToInteger(popper.top),bottom:verticalToInteger(popper.bottom),right:horizontalToInteger(popper.right)}}var isFirefox$1$1=isBrowser$2$1&&/Firefox/i.test(navigator.userAgent);
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function computeStyle$1$1(data,options){var x=options.x,y=options.y,popper=data.offsets.popper,legacyGpuAccelerationOption=find$1$1(data.instance.modifiers,(function(modifier){return"applyStyle"===modifier.name})).gpuAcceleration,gpuAcceleration=void 0!==legacyGpuAccelerationOption?legacyGpuAccelerationOption:options.gpuAcceleration,offsetParent=getOffsetParent$1$1(data.instance.popper),offsetParentRect=getBoundingClientRect$1$1(offsetParent),styles={position:popper.position},offsets=getRoundedOffsets$1$1(data,window.devicePixelRatio<2||!isFirefox$1$1),sideA="bottom"===x?"top":"bottom",sideB="right"===y?"left":"right",prefixedProperty=getSupportedPropertyName$1$1("transform"),left=void 0,top=void 0;if(top="bottom"===sideA?
// when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
// and not the bottom of the html element
"HTML"===offsetParent.nodeName?-offsetParent.clientHeight+offsets.bottom:-offsetParentRect.height+offsets.bottom:offsets.top,left="right"===sideB?"HTML"===offsetParent.nodeName?-offsetParent.clientWidth+offsets.right:-offsetParentRect.width+offsets.right:offsets.left,gpuAcceleration&&prefixedProperty)styles[prefixedProperty]="translate3d("+left+"px, "+top+"px, 0)",styles[sideA]=0,styles[sideB]=0,styles.willChange="transform";else{
// othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
var invertTop="bottom"===sideA?-1:1,invertLeft="right"===sideB?-1:1;styles[sideA]=top*invertTop,styles[sideB]=left*invertLeft,styles.willChange=sideA+", "+sideB}
// Attributes
var attributes={"x-placement":data.placement};
// Update `data` attributes, styles and arrowStyles
return data.attributes=_extends$2$1({},attributes,data.attributes),data.styles=_extends$2$1({},styles,data.styles),data.arrowStyles=_extends$2$1({},data.offsets.arrow,data.arrowStyles),data}
/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */function isModifierRequired$1$1(modifiers,requestingName,requestedName){var requesting=find$1$1(modifiers,(function(_ref){var name=_ref.name;return name===requestingName})),isRequired=!!requesting&&modifiers.some((function(modifier){return modifier.name===requestedName&&modifier.enabled&&modifier.order<requesting.order}));if(!isRequired);return isRequired}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function arrow$1$1(data,options){var _data$offsets$arrow;
// arrow depends on keepTogether in order to work
if(!isModifierRequired$1$1(data.instance.modifiers,"arrow","keepTogether"))return data;var arrowElement=options.element;
// if arrowElement is a string, suppose it's a CSS selector
if("string"===typeof arrowElement){
// if arrowElement is not found, don't run the modifier
if(arrowElement=data.instance.popper.querySelector(arrowElement),!arrowElement)return data}else
// if the arrowElement isn't a query selector we must check that the
// provided DOM node is child of its popper node
if(!data.instance.popper.contains(arrowElement))return data;var placement=data.placement.split("-")[0],_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,isVertical=-1!==["left","right"].indexOf(placement),len=isVertical?"height":"width",sideCapitalized=isVertical?"Top":"Left",side=sideCapitalized.toLowerCase(),altSide=isVertical?"left":"top",opSide=isVertical?"bottom":"right",arrowElementSize=getOuterSizes$1$1(arrowElement)[len];
// extends keepTogether behavior making sure the popper and its
// reference have enough pixels in conjunction
// top/left side
reference[opSide]-arrowElementSize<popper[side]&&(data.offsets.popper[side]-=popper[side]-(reference[opSide]-arrowElementSize)),
// bottom/right side
reference[side]+arrowElementSize>popper[opSide]&&(data.offsets.popper[side]+=reference[side]+arrowElementSize-popper[opSide]),data.offsets.popper=getClientRect$1$1(data.offsets.popper);
// compute center of the popper
var center=reference[side]+reference[len]/2-arrowElementSize/2,css=getStyleComputedProperty$1$1(data.instance.popper),popperMarginSide=parseFloat(css["margin"+sideCapitalized]),popperBorderSide=parseFloat(css["border"+sideCapitalized+"Width"]),sideValue=center-data.offsets.popper[side]-popperMarginSide-popperBorderSide;
// Compute the sideValue using the updated popper offsets
// take popper margin in account because we don't have this info available
// prevent arrowElement from being placed not contiguously to its popper
return sideValue=Math.max(Math.min(popper[len]-arrowElementSize,sideValue),0),data.arrowElement=arrowElement,data.offsets.arrow=(_data$offsets$arrow={},defineProperty$1$1(_data$offsets$arrow,side,Math.round(sideValue)),defineProperty$1$1(_data$offsets$arrow,altSide,""),_data$offsets$arrow),data}
/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */function getOppositeVariation$1$1(variation){return"end"===variation?"start":"start"===variation?"end":variation}
/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */var placements$1$1=["auto-start","auto","auto-end","top-start","top","top-end","right-start","right","right-end","bottom-end","bottom","bottom-start","left-end","left","left-start"],validPlacements$1$1=placements$1$1.slice(3);
// Get rid of `auto` `auto-start` and `auto-end`
/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise$1$1(placement){var counter=arguments.length>1&&void 0!==arguments[1]&&arguments[1],index=validPlacements$1$1.indexOf(placement),arr=validPlacements$1$1.slice(index+1).concat(validPlacements$1$1.slice(0,index));return counter?arr.reverse():arr}var BEHAVIORS$1$1={FLIP:"flip",CLOCKWISE:"clockwise",COUNTERCLOCKWISE:"counterclockwise"};
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function flip$1$1(data,options){
// if `inner` modifier is enabled, we can't use the `flip` modifier
if(isModifierEnabled$1$1(data.instance.modifiers,"inner"))return data;if(data.flipped&&data.placement===data.originalPlacement)
// seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
return data;var boundaries=getBoundaries$1$1(data.instance.popper,data.instance.reference,options.padding,options.boundariesElement,data.positionFixed),placement=data.placement.split("-")[0],placementOpposite=getOppositePlacement$1$1(placement),variation=data.placement.split("-")[1]||"",flipOrder=[];switch(options.behavior){case BEHAVIORS$1$1.FLIP:flipOrder=[placement,placementOpposite];break;case BEHAVIORS$1$1.CLOCKWISE:flipOrder=clockwise$1$1(placement);break;case BEHAVIORS$1$1.COUNTERCLOCKWISE:flipOrder=clockwise$1$1(placement,!0);break;default:flipOrder=options.behavior}return flipOrder.forEach((function(step,index){if(placement!==step||flipOrder.length===index+1)return data;placement=data.placement.split("-")[0],placementOpposite=getOppositePlacement$1$1(placement);var popperOffsets=data.offsets.popper,refOffsets=data.offsets.reference,floor=Math.floor,overlapsRef="left"===placement&&floor(popperOffsets.right)>floor(refOffsets.left)||"right"===placement&&floor(popperOffsets.left)<floor(refOffsets.right)||"top"===placement&&floor(popperOffsets.bottom)>floor(refOffsets.top)||"bottom"===placement&&floor(popperOffsets.top)<floor(refOffsets.bottom),overflowsLeft=floor(popperOffsets.left)<floor(boundaries.left),overflowsRight=floor(popperOffsets.right)>floor(boundaries.right),overflowsTop=floor(popperOffsets.top)<floor(boundaries.top),overflowsBottom=floor(popperOffsets.bottom)>floor(boundaries.bottom),overflowsBoundaries="left"===placement&&overflowsLeft||"right"===placement&&overflowsRight||"top"===placement&&overflowsTop||"bottom"===placement&&overflowsBottom,isVertical=-1!==["top","bottom"].indexOf(placement),flippedVariationByRef=!!options.flipVariations&&(isVertical&&"start"===variation&&overflowsLeft||isVertical&&"end"===variation&&overflowsRight||!isVertical&&"start"===variation&&overflowsTop||!isVertical&&"end"===variation&&overflowsBottom),flippedVariationByContent=!!options.flipVariationsByContent&&(isVertical&&"start"===variation&&overflowsRight||isVertical&&"end"===variation&&overflowsLeft||!isVertical&&"start"===variation&&overflowsBottom||!isVertical&&"end"===variation&&overflowsTop),flippedVariation=flippedVariationByRef||flippedVariationByContent;(overlapsRef||overflowsBoundaries||flippedVariation)&&(
// this boolean to detect any flip loop
data.flipped=!0,(overlapsRef||overflowsBoundaries)&&(placement=flipOrder[index+1]),flippedVariation&&(variation=getOppositeVariation$1$1(variation)),data.placement=placement+(variation?"-"+variation:""),
// this object contains `position`, we want to preserve it along with
// any additional property we may add in the future
data.offsets.popper=_extends$2$1({},data.offsets.popper,getPopperOffsets$1$1(data.instance.popper,data.offsets.reference,data.placement)),data=runModifiers$1$1(data.instance.modifiers,data,"flip"))})),data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function keepTogether$1$1(data){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,placement=data.placement.split("-")[0],floor=Math.floor,isVertical=-1!==["top","bottom"].indexOf(placement),side=isVertical?"right":"bottom",opSide=isVertical?"left":"top",measurement=isVertical?"width":"height";return popper[side]<floor(reference[opSide])&&(data.offsets.popper[opSide]=floor(reference[opSide])-popper[measurement]),popper[opSide]>floor(reference[side])&&(data.offsets.popper[opSide]=floor(reference[side])),data}
/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */function toValue$1$1(str,measurement,popperOffsets,referenceOffsets){
// separate value from unit
var split=str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),value=+split[1],unit=split[2];
// If it's not a number it's an operator, I guess
if(!value)return str;if(0===unit.indexOf("%")){var element=void 0;switch(unit){case"%p":element=popperOffsets;break;case"%":case"%r":default:element=referenceOffsets}var rect=getClientRect$1$1(element);return rect[measurement]/100*value}if("vh"===unit||"vw"===unit){
// if is a vh or vw, we calculate the size based on the viewport
var size=void 0;return size="vh"===unit?Math.max(document.documentElement.clientHeight,window.innerHeight||0):Math.max(document.documentElement.clientWidth,window.innerWidth||0),size/100*value}
// if is an explicit pixel unit, we get rid of the unit and keep the value
// if is an implicit unit, it's px, and we return just the value
return value}
/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */function parseOffset$1$1(offset,popperOffsets,referenceOffsets,basePlacement){var offsets=[0,0],useHeight=-1!==["right","left"].indexOf(basePlacement),fragments=offset.split(/(\+|\-)/).map((function(frag){return frag.trim()})),divider=fragments.indexOf(find$1$1(fragments,(function(frag){return-1!==frag.search(/,|\s/)})));
// Use height if placement is left or right and index is 0 otherwise use width
// in this way the first offset will use an axis and the second one
// will use the other one
fragments[divider]&&fragments[divider].indexOf(",");
// If divider is found, we divide the list of values and operands to divide
// them by ofset X and Y.
var splitRegex=/\s*,\s*|\s+/,ops=-1!==divider?[fragments.slice(0,divider).concat([fragments[divider].split(splitRegex)[0]]),[fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider+1))]:[fragments];
// Convert the values with units to absolute pixels to allow our computations
return ops=ops.map((function(op,index){
// Most of the units rely on the orientation of the popper
var measurement=(1===index?!useHeight:useHeight)?"height":"width",mergeWithPrevious=!1;return op.reduce((function(a,b){return""===a[a.length-1]&&-1!==["+","-"].indexOf(b)?(a[a.length-1]=b,mergeWithPrevious=!0,a):mergeWithPrevious?(a[a.length-1]+=b,mergeWithPrevious=!1,a):a.concat(b)}),[]).map((function(str){return toValue$1$1(str,measurement,popperOffsets,referenceOffsets)}))})),
// Loop trough the offsets arrays and execute the operations
ops.forEach((function(op,index){op.forEach((function(frag,index2){isNumeric$1$1(frag)&&(offsets[index]+=frag*("-"===op[index2-1]?-1:1))}))})),offsets}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */function offset$1$1(data,_ref){var offset=_ref.offset,placement=data.placement,_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,basePlacement=placement.split("-")[0],offsets=void 0;return offsets=isNumeric$1$1(+offset)?[+offset,0]:parseOffset$1$1(offset,popper,reference,basePlacement),"left"===basePlacement?(popper.top+=offsets[0],popper.left-=offsets[1]):"right"===basePlacement?(popper.top+=offsets[0],popper.left+=offsets[1]):"top"===basePlacement?(popper.left+=offsets[0],popper.top-=offsets[1]):"bottom"===basePlacement&&(popper.left+=offsets[0],popper.top+=offsets[1]),data.popper=popper,data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function preventOverflow$1$1(data,options){var boundariesElement=options.boundariesElement||getOffsetParent$1$1(data.instance.popper);
// If offsetParent is the reference element, we really want to
// go one step up and use the next offsetParent as reference to
// avoid to make this modifier completely useless and look like broken
data.instance.reference===boundariesElement&&(boundariesElement=getOffsetParent$1$1(boundariesElement));
// NOTE: DOM access here
// resets the popper's position so that the document size can be calculated excluding
// the size of the popper element itself
var transformProp=getSupportedPropertyName$1$1("transform"),popperStyles=data.instance.popper.style,top=popperStyles.top,left=popperStyles.left,transform=popperStyles[transformProp];popperStyles.top="",popperStyles.left="",popperStyles[transformProp]="";var boundaries=getBoundaries$1$1(data.instance.popper,data.instance.reference,options.padding,boundariesElement,data.positionFixed);
// NOTE: DOM access here
// restores the original style properties after the offsets have been computed
popperStyles.top=top,popperStyles.left=left,popperStyles[transformProp]=transform,options.boundaries=boundaries;var order=options.priority,popper=data.offsets.popper,check={primary:function(placement){var value=popper[placement];return popper[placement]<boundaries[placement]&&!options.escapeWithReference&&(value=Math.max(popper[placement],boundaries[placement])),defineProperty$1$1({},placement,value)},secondary:function(placement){var mainSide="right"===placement?"left":"top",value=popper[mainSide];return popper[placement]>boundaries[placement]&&!options.escapeWithReference&&(value=Math.min(popper[mainSide],boundaries[placement]-("right"===placement?popper.width:popper.height))),defineProperty$1$1({},mainSide,value)}};return order.forEach((function(placement){var side=-1!==["left","top"].indexOf(placement)?"primary":"secondary";popper=_extends$2$1({},popper,check[side](placement))})),data.offsets.popper=popper,data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function shift$1$1(data){var placement=data.placement,basePlacement=placement.split("-")[0],shiftvariation=placement.split("-")[1];
// if shift shiftvariation is specified, run the modifier
if(shiftvariation){var _data$offsets=data.offsets,reference=_data$offsets.reference,popper=_data$offsets.popper,isVertical=-1!==["bottom","top"].indexOf(basePlacement),side=isVertical?"left":"top",measurement=isVertical?"width":"height",shiftOffsets={start:defineProperty$1$1({},side,reference[side]),end:defineProperty$1$1({},side,reference[side]+reference[measurement]-popper[measurement])};data.offsets.popper=_extends$2$1({},popper,shiftOffsets[shiftvariation])}return data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function hide$1$1(data){if(!isModifierRequired$1$1(data.instance.modifiers,"hide","preventOverflow"))return data;var refRect=data.offsets.reference,bound=find$1$1(data.instance.modifiers,(function(modifier){return"preventOverflow"===modifier.name})).boundaries;if(refRect.bottom<bound.top||refRect.left>bound.right||refRect.top>bound.bottom||refRect.right<bound.left){
// Avoid unnecessary DOM access if visibility hasn't changed
if(!0===data.hide)return data;data.hide=!0,data.attributes["x-out-of-boundaries"]=""}else{
// Avoid unnecessary DOM access if visibility hasn't changed
if(!1===data.hide)return data;data.hide=!1,data.attributes["x-out-of-boundaries"]=!1}return data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function inner$1$1(data){var placement=data.placement,basePlacement=placement.split("-")[0],_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,isHoriz=-1!==["left","right"].indexOf(basePlacement),subtractLength=-1===["top","left"].indexOf(basePlacement);return popper[isHoriz?"left":"top"]=reference[basePlacement]-(subtractLength?popper[isHoriz?"width":"height"]:0),data.placement=getOppositePlacement$1$1(placement),data.offsets.popper=getClientRect$1$1(popper),data}
/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */
/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */var modifiers$1$1={
/**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
shift:{
/** @prop {number} order=100 - Index used to define the order of execution */
order:100,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:shift$1$1},
/**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
offset:{
/** @prop {number} order=200 - Index used to define the order of execution */
order:200,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:offset$1$1,
/** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
offset:0},
/**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
preventOverflow:{
/** @prop {number} order=300 - Index used to define the order of execution */
order:300,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:preventOverflow$1$1,
/**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
priority:["left","right","top","bottom"],
/**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
padding:5,
/**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
boundariesElement:"scrollParent"},
/**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
keepTogether:{
/** @prop {number} order=400 - Index used to define the order of execution */
order:400,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:keepTogether$1$1},
/**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
arrow:{
/** @prop {number} order=500 - Index used to define the order of execution */
order:500,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:arrow$1$1,
/** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
element:"[x-arrow]"},
/**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
flip:{
/** @prop {number} order=600 - Index used to define the order of execution */
order:600,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:flip$1$1,
/**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
behavior:"flip",
/**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
padding:5,
/**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
boundariesElement:"viewport",
/**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
flipVariations:!1,
/**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
flipVariationsByContent:!1},
/**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
inner:{
/** @prop {number} order=700 - Index used to define the order of execution */
order:700,
/** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
enabled:!1,
/** @prop {ModifierFn} */
fn:inner$1$1},
/**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
hide:{
/** @prop {number} order=800 - Index used to define the order of execution */
order:800,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:hide$1$1},
/**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
computeStyle:{
/** @prop {number} order=850 - Index used to define the order of execution */
order:850,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:computeStyle$1$1,
/**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
gpuAcceleration:!0,
/**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
x:"bottom",
/**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
y:"right"},
/**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
applyStyle:{
/** @prop {number} order=900 - Index used to define the order of execution */
order:900,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:applyStyle$1$1,
/** @prop {Function} */
onLoad:applyStyleOnLoad$1$1,
/**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
gpuAcceleration:void 0}},Defaults$1$1={
/**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
placement:"bottom",
/**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
positionFixed:!1,
/**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
eventsEnabled:!0,
/**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
removeOnDestroy:!1,
/**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
onCreate:function(){},
/**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
onUpdate:function(){},
/**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
modifiers:modifiers$1$1},Popper$1$1=function(){
/**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
function Popper(reference,popper){var _this=this,options=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};classCallCheck$1$1(this,Popper),this.scheduleUpdate=function(){return requestAnimationFrame(_this.update)},
// make update() debounced, so that it only runs at most once-per-tick
this.update=debounce$2$1(this.update.bind(this)),
// with {} we create a new object with the options inside it
this.options=_extends$2$1({},Popper.Defaults,options),
// init state
this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},
// get reference and popper elements (allow jQuery wrappers)
this.reference=reference&&reference.jquery?reference[0]:reference,this.popper=popper&&popper.jquery?popper[0]:popper,
// Deep merge modifiers options
this.options.modifiers={},Object.keys(_extends$2$1({},Popper.Defaults.modifiers,options.modifiers)).forEach((function(name){_this.options.modifiers[name]=_extends$2$1({},Popper.Defaults.modifiers[name]||{},options.modifiers?options.modifiers[name]:{})})),
// Refactoring modifiers' list (Object => Array)
this.modifiers=Object.keys(this.options.modifiers).map((function(name){return _extends$2$1({name:name},_this.options.modifiers[name])})).sort((function(a,b){return a.order-b.order})),
// modifiers have the ability to execute arbitrary code when Popper.js get inited
// such code is executed in the same order of its modifier
// they could add new properties to their options configuration
// BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
this.modifiers.forEach((function(modifierOptions){modifierOptions.enabled&&isFunction$1$1(modifierOptions.onLoad)&&modifierOptions.onLoad(_this.reference,_this.popper,_this.options,modifierOptions,_this.state)})),
// fire the first update to position the popper in the right place
this.update();var eventsEnabled=this.options.eventsEnabled;eventsEnabled&&
// setup event listeners, they will take care of update the position in specific situations
this.enableEventListeners(),this.state.eventsEnabled=eventsEnabled}
// We can't use class properties because they don't get listed in the
// class prototype and break stuff like Sinon stubs
return createClass$1$1(Popper,[{key:"update",value:function(){return update$1$1.call(this)}},{key:"destroy",value:function(){return destroy$1$1.call(this)}},{key:"enableEventListeners",value:function(){return enableEventListeners$1$1.call(this)}},{key:"disableEventListeners",value:function(){return disableEventListeners$1$1.call(this)}
/**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */
/**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */}]),Popper}();
/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */
/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */
Popper$1$1.Utils=("undefined"!==typeof window?window:global).PopperUtils,Popper$1$1.placements=placements$1$1,Popper$1$1.Defaults=Defaults$1$1;var isIE$2$1,Popper$2$1=Popper$1$1;function getInternetExplorerVersion$1(){var ua=window.navigator.userAgent,msie=ua.indexOf("MSIE ");if(msie>0)
// IE 10 or older => return version number
return parseInt(ua.substring(msie+5,ua.indexOf(".",msie)),10);var trident=ua.indexOf("Trident/");if(trident>0){
// IE 11 => return version number
var rv=ua.indexOf("rv:");return parseInt(ua.substring(rv+3,ua.indexOf(".",rv)),10)}var edge=ua.indexOf("Edge/");return edge>0?parseInt(ua.substring(edge+5,ua.indexOf(".",edge)),10):-1;// other browser
}

function initCompat$1(){initCompat$1.init||(initCompat$1.init=!0,isIE$2$1=-1!==getInternetExplorerVersion$1())}var script$4$1={name:"ResizeObserver",props:{emitOnMount:{type:Boolean,default:!1},ignoreWidth:{type:Boolean,default:!1},ignoreHeight:{type:Boolean,default:!1}},mounted:function(){var _this=this;initCompat$1(),this.$nextTick((function(){_this._w=_this.$el.offsetWidth,_this._h=_this.$el.offsetHeight,_this.emitOnMount&&_this.emitSize()}));var object=document.createElement("object");this._resizeObject=object,object.setAttribute("aria-hidden","true"),object.setAttribute("tabindex",-1),object.onload=this.addResizeHandlers,object.type="text/html",isIE$2$1&&this.$el.appendChild(object),object.data="about:blank",isIE$2$1||this.$el.appendChild(object)},beforeDestroy:function(){this.removeResizeHandlers()},methods:{compareAndNotify:function(){(!this.ignoreWidth&&this._w!==this.$el.offsetWidth||!this.ignoreHeight&&this._h!==this.$el.offsetHeight)&&(this._w=this.$el.offsetWidth,this._h=this.$el.offsetHeight,this.emitSize())},emitSize:function(){this.$emit("notify",{width:this._w,height:this._h})},addResizeHandlers:function(){this._resizeObject.contentDocument.defaultView.addEventListener("resize",this.compareAndNotify),this.compareAndNotify()},removeResizeHandlers:function(){this._resizeObject&&this._resizeObject.onload&&(!isIE$2$1&&this._resizeObject.contentDocument&&this._resizeObject.contentDocument.defaultView.removeEventListener("resize",this.compareAndNotify),this.$el.removeChild(this._resizeObject),this._resizeObject.onload=null,this._resizeObject=null)}}};function normalizeComponent$2$1(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier
/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);// Vue.extend constructor export interop.
var hook,options="function"===typeof script?script.options:script;// render functions
if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,// functional template
isFunctionalTemplate&&(options.functional=!0)),// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),// inject component styles
style&&style.call(this,createInjectorSSR(context)),// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(context){style.call(this,createInjectorShadow(context,this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
var originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
var existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}
/* script */var __vue_script__$4$1=script$4$1,__vue_render__$4$1=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"resize-observer",attrs:{tabindex:"-1"}})},__vue_staticRenderFns__$4$1=[];
/* template */__vue_render__$4$1._withStripped=!0;
/* style */
var __vue_inject_styles__$4$1=void 0,__vue_scope_id__$4$1="data-v-8859cc6c",__vue_module_identifier__$4$1=void 0,__vue_is_functional_template__$4$1=!1,__vue_component__$3$1$1=normalizeComponent$2$1({render:__vue_render__$4$1,staticRenderFns:__vue_staticRenderFns__$4$1},__vue_inject_styles__$4$1,__vue_script__$4$1,__vue_scope_id__$4$1,__vue_is_functional_template__$4$1,__vue_module_identifier__$4$1,!1,void 0,void 0,void 0);
/* scoped */function install$1$1(Vue){
// eslint-disable-next-line vue/component-definition-name-casing
Vue.component("resize-observer",__vue_component__$3$1$1),Vue.component("ResizeObserver",__vue_component__$3$1$1)}var plugin$2$1={
// eslint-disable-next-line no-undef
version:"1.0.1",install:install$1$1},GlobalVue$1$1=null;"undefined"!==typeof window?GlobalVue$1$1=window.Vue:"undefined"!==typeof global&&(GlobalVue$1$1=global.Vue),GlobalVue$1$1&&GlobalVue$1$1.use(plugin$2$1);var SVGAnimatedString$1=function(){};function convertToArray$1(value){return"string"===typeof value&&(value=value.split(" ")),value}
/**
 * Add classes to an element.
 * This method checks to ensure that the classes don't already exist before adding them.
 * It uses el.className rather than classList in order to be IE friendly.
 * @param {object} el - The element to add the classes to.
 * @param {classes} string - List of space separated classes to be added to the element.
 */function addClasses$1(el,classes){var classList,newClasses=convertToArray$1(classes);classList=el.className instanceof SVGAnimatedString$1?convertToArray$1(el.className.baseVal):convertToArray$1(el.className),newClasses.forEach((function(newClass){-1===classList.indexOf(newClass)&&classList.push(newClass)})),el instanceof SVGElement?el.setAttribute("class",classList.join(" ")):el.className=classList.join(" ")}
/**
 * Remove classes from an element.
 * It uses el.className rather than classList in order to be IE friendly.
 * @export
 * @param {any} el The element to remove the classes from.
 * @param {any} classes List of space separated classes to be removed from the element.
 */function removeClasses$1(el,classes){var classList,newClasses=convertToArray$1(classes);classList=el.className instanceof SVGAnimatedString$1?convertToArray$1(el.className.baseVal):convertToArray$1(el.className),newClasses.forEach((function(newClass){var index=classList.indexOf(newClass);-1!==index&&classList.splice(index,1)})),el instanceof SVGElement?el.setAttribute("class",classList.join(" ")):el.className=classList.join(" ")}"undefined"!==typeof window&&(SVGAnimatedString$1=window.SVGAnimatedString);var supportsPassive$1=!1;if("undefined"!==typeof window){supportsPassive$1=!1;try{var opts$1=Object.defineProperty({},"passive",{get:function(){supportsPassive$1=!0}});window.addEventListener("test",null,opts$1)}catch(e){}}function ownKeys$2$1(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread$2$1(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$2$1(Object(source),!0).forEach((function(key){_defineProperty$1$1(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$2$1(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}var DEFAULT_OPTIONS$1={container:!1,delay:0,html:!1,placement:"top",title:"",template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",offset:0},openTooltips$1=[],Tooltip$1=function(){
/**
   * Create a new Tooltip.js instance
   * @class Tooltip
   * @param {HTMLElement} reference - The DOM node used as reference of the tooltip (it can be a jQuery element).
   * @param {Object} options
   * @param {String} options.placement=bottom
   *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -end),
   *      left(-start, -end)`
   * @param {HTMLElement|String|false} options.container=false - Append the tooltip to a specific element.
   * @param {Number|Object} options.delay=0
   *      Delay showing and hiding the tooltip (ms) - does not apply to manual trigger type.
   *      If a number is supplied, delay is applied to both hide/show.
   *      Object structure is: `{ show: 500, hide: 100 }`
   * @param {Boolean} options.html=false - Insert HTML into the tooltip. If false, the content will inserted with `innerText`.
   * @param {String|PlacementFunction} options.placement='top' - One of the allowed placements, or a function returning one of them.
   * @param {String} [options.template='<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>']
   *      Base HTML to used when creating the tooltip.
   *      The tooltip's `title` will be injected into the `.tooltip-inner` or `.tooltip__inner`.
   *      `.tooltip-arrow` or `.tooltip__arrow` will become the tooltip's arrow.
   *      The outermost wrapper element should have the `.tooltip` class.
   * @param {String|HTMLElement|TitleFunction} options.title='' - Default title value if `title` attribute isn't present.
   * @param {String} [options.trigger='hover focus']
   *      How tooltip is triggered - click, hover, focus, manual.
   *      You may pass multiple triggers; separate them with a space. `manual` cannot be combined with any other trigger.
   * @param {HTMLElement} options.boundariesElement
   *      The element used as boundaries for the tooltip. For more information refer to Popper.js'
   *      [boundariesElement docs](https://popper.js.org/popper-documentation.html)
   * @param {Number|String} options.offset=0 - Offset of the tooltip relative to its reference. For more information refer to Popper.js'
   *      [offset docs](https://popper.js.org/popper-documentation.html)
   * @param {Object} options.popperOptions={} - Popper options, will be passed directly to popper instance. For more information refer to Popper.js'
   *      [options docs](https://popper.js.org/popper-documentation.html)
   * @param {string} [options.ariaId] Id used for accessibility
   * @return {Object} instance - The generated tooltip instance
   */
function Tooltip(_reference,_options){var _this=this;_classCallCheck$1(this,Tooltip),_defineProperty$1$1(this,"_events",[]),_defineProperty$1$1(this,"_setTooltipNodeEvent",(function(evt,reference,delay,options){var relatedreference=evt.relatedreference||evt.toElement||evt.relatedTarget,callback=function callback(evt2){var relatedreference2=evt2.relatedreference||evt2.toElement||evt2.relatedTarget;// Remove event listener after call
_this._tooltipNode.removeEventListener(evt.type,callback),// If the new reference is not the reference element
reference.contains(relatedreference2)||
// Schedule to hide tooltip
_this._scheduleHide(reference,options.delay,options,evt2)};return!!_this._tooltipNode.contains(relatedreference)&&(
// listen to mouseleave on the tooltip element to be able to hide the tooltip
_this._tooltipNode.addEventListener(evt.type,callback),!0)})),
// apply user options over default ones
_options=_objectSpread$2$1(_objectSpread$2$1({},DEFAULT_OPTIONS$1),_options),_reference.jquery&&(_reference=_reference[0]),this.show=this.show.bind(this),this.hide=this.hide.bind(this),// cache reference and options
this.reference=_reference,this.options=_options,// set initial state
this._isOpen=!1,this._init()}
// Public methods

/**
   * Reveals an element's tooltip. This is considered a "manual" triggering of the tooltip.
   * Tooltips with zero-length titles are never displayed.
   * @method Tooltip#show
   * @memberof Tooltip
   */return _createClass$1(Tooltip,[{key:"show",value:function(){this._show(this.reference,this.options)}
/**
     * Hides an element’s tooltip. This is considered a “manual” triggering of the tooltip.
     * @method Tooltip#hide
     * @memberof Tooltip
     */},{key:"hide",value:function(){this._hide()}
/**
     * Hides and destroys an element’s tooltip.
     * @method Tooltip#dispose
     * @memberof Tooltip
     */},{key:"dispose",value:function(){this._dispose()}
/**
     * Toggles an element’s tooltip. This is considered a “manual” triggering of the tooltip.
     * @method Tooltip#toggle
     * @memberof Tooltip
     */},{key:"toggle",value:function(){return this._isOpen?this.hide():this.show()}},{key:"setClasses",value:function(classes){this._classes=classes}},{key:"setContent",value:function(content){this.options.title=content,this._tooltipNode&&this._setContent(content,this.options)}},{key:"setOptions",value:function(options){var classesUpdated=!1,classes=options&&options.classes||directive$1.options.defaultClass;lodash_isEqual(this._classes,classes)||(this.setClasses(classes),classesUpdated=!0),options=getOptions$1(options);var needPopperUpdate=!1,needRestart=!1;for(var key in this.options.offset===options.offset&&this.options.placement===options.placement||(needPopperUpdate=!0),(this.options.template!==options.template||this.options.trigger!==options.trigger||this.options.container!==options.container||classesUpdated)&&(needRestart=!0),options)this.options[key]=options[key];if(this._tooltipNode)if(needRestart){var isOpen=this._isOpen;this.dispose(),this._init(),isOpen&&this.show()}else needPopperUpdate&&this.popperInstance.update()}
// Private methods

},{key:"_init",value:function(){
// get events list
var events="string"===typeof this.options.trigger?this.options.trigger.split(" "):[];this._isDisposed=!1,this._enableDocumentTouch=-1===events.indexOf("manual"),events=events.filter((function(trigger){return-1!==["click","hover","focus"].indexOf(trigger)})),// set event listeners
this._setEventListeners(this.reference,events,this.options),// title attribute
this.$_originalTitle=this.reference.getAttribute("title"),this.reference.removeAttribute("title"),this.reference.setAttribute("data-original-title",this.$_originalTitle)}
/**
     * Creates a new tooltip node
     * @memberof Tooltip
     * @private
     * @param {HTMLElement} reference
     * @param {String} template
     * @param {String|HTMLElement|TitleFunction} title
     * @param {Boolean} allowHtml
     * @return {HTMLelement} tooltipNode
     */},{key:"_create",value:function(reference,template){var _this2=this,tooltipGenerator=window.document.createElement("div");
// create tooltip element
tooltipGenerator.innerHTML=template.trim();var tooltipNode=tooltipGenerator.childNodes[0];// add unique ID to our tooltip (needed for accessibility reasons)
// return the generated tooltip node
return tooltipNode.id=this.options.ariaId||"tooltip_".concat(Math.random().toString(36).substr(2,10)),// Initially hide the tooltip
// The attribute will be switched in a next frame so
// CSS transitions can play
tooltipNode.setAttribute("aria-hidden","true"),this.options.autoHide&&-1!==this.options.trigger.indexOf("hover")&&(tooltipNode.addEventListener("mouseenter",(function(evt){return _this2._scheduleHide(reference,_this2.options.delay,_this2.options,evt)})),tooltipNode.addEventListener("click",(function(evt){return _this2._scheduleHide(reference,_this2.options.delay,_this2.options,evt)}))),tooltipNode}},{key:"_setContent",value:function(content,options){var _this3=this;this.asyncContent=!1,this._applyContent(content,options).then((function(){_this3.popperInstance&&_this3.popperInstance.update()}))}},{key:"_applyContent",value:function(title,options){var _this4=this;return new Promise((function(resolve,reject){var allowHtml=options.html,rootNode=_this4._tooltipNode;if(rootNode){var titleNode=rootNode.querySelector(_this4.options.innerSelector);if(1===title.nodeType){
// if title is a node, append it only if allowHtml is true
if(allowHtml){while(titleNode.firstChild)titleNode.removeChild(titleNode.firstChild);titleNode.appendChild(title)}}else{if("function"===typeof title){
// if title is a function, call it and set innerText or innerHtml depending by `allowHtml` value
var result=title();return void(result&&"function"===typeof result.then?(_this4.asyncContent=!0,options.loadingClass&&addClasses$1(rootNode,options.loadingClass),options.loadingContent&&_this4._applyContent(options.loadingContent,options),result.then((function(asyncResult){return options.loadingClass&&removeClasses$1(rootNode,options.loadingClass),_this4._applyContent(asyncResult,options)})).then(resolve).catch(reject)):_this4._applyContent(result,options).then(resolve).catch(reject))}
// if it's just a simple text, set innerText or innerHtml depending by `allowHtml` value
allowHtml?titleNode.innerHTML=title:titleNode.innerText=title}resolve()}}))}},{key:"_show",value:function(reference,options){if(options&&"string"===typeof options.container){var container=document.querySelector(options.container);if(!container)return}clearTimeout(this._disposeTimer),options=Object.assign({},options),delete options.offset;var updateClasses=!0;this._tooltipNode&&(addClasses$1(this._tooltipNode,this._classes),updateClasses=!1);var result=this._ensureShown(reference,options);return updateClasses&&this._tooltipNode&&addClasses$1(this._tooltipNode,this._classes),addClasses$1(reference,["v-tooltip-open"]),result}},{key:"_ensureShown",value:function(reference,options){var _this5=this;
// don't show if it's already visible
if(this._isOpen)return this;// if the tooltipNode already exists, just show it
if(this._isOpen=!0,openTooltips$1.push(this),this._tooltipNode)return this._tooltipNode.style.display="",this._tooltipNode.setAttribute("aria-hidden","false"),this.popperInstance.enableEventListeners(),this.popperInstance.update(),this.asyncContent&&this._setContent(options.title,options),this;// get title
var title=reference.getAttribute("title")||options.title;// don't show tooltip if no title is defined
if(!title)return this;// create tooltip node
var tooltipNode=this._create(reference,options.template);this._tooltipNode=tooltipNode,// Add `aria-describedby` to our reference element for accessibility reasons
reference.setAttribute("aria-describedby",tooltipNode.id);// append tooltip to container
var container=this._findContainer(options.container,reference);this._append(tooltipNode,container);var popperOptions=_objectSpread$2$1(_objectSpread$2$1({},options.popperOptions),{},{placement:options.placement});return popperOptions.modifiers=_objectSpread$2$1(_objectSpread$2$1({},popperOptions.modifiers),{},{arrow:{element:this.options.arrowSelector}}),options.boundariesElement&&(popperOptions.modifiers.preventOverflow={boundariesElement:options.boundariesElement}),this.popperInstance=new Popper$2$1(reference,tooltipNode,popperOptions),this._setContent(title,options),// Fix position
requestAnimationFrame((function(){!_this5._isDisposed&&_this5.popperInstance?(_this5.popperInstance.update(),// Show the tooltip
requestAnimationFrame((function(){_this5._isDisposed?_this5.dispose():_this5._isOpen&&tooltipNode.setAttribute("aria-hidden","false")}))):_this5.dispose()})),this}},{key:"_noLongerOpen",value:function(){var index=openTooltips$1.indexOf(this);-1!==index&&openTooltips$1.splice(index,1)}},{key:"_hide",value:function(){var _this6=this;
// don't hide if it's already hidden
if(!this._isOpen)return this;this._isOpen=!1,this._noLongerOpen(),// hide tooltipNode
this._tooltipNode.style.display="none",this._tooltipNode.setAttribute("aria-hidden","true"),this.popperInstance&&this.popperInstance.disableEventListeners(),clearTimeout(this._disposeTimer);var disposeTime=directive$1.options.disposeTimeout;return null!==disposeTime&&(this._disposeTimer=setTimeout((function(){_this6._tooltipNode&&(_this6._tooltipNode.removeEventListener("mouseenter",_this6.hide),_this6._tooltipNode.removeEventListener("click",_this6.hide),// Don't remove popper instance, just the HTML element
_this6._removeTooltipNode())}),disposeTime)),removeClasses$1(this.reference,["v-tooltip-open"]),this}},{key:"_removeTooltipNode",value:function(){if(this._tooltipNode){var parentNode=this._tooltipNode.parentNode;parentNode&&(parentNode.removeChild(this._tooltipNode),this.reference.removeAttribute("aria-describedby")),this._tooltipNode=null}}},{key:"_dispose",value:function(){var _this7=this;return this._isDisposed=!0,this.reference.removeAttribute("data-original-title"),this.$_originalTitle&&this.reference.setAttribute("title",this.$_originalTitle),// remove event listeners first to prevent any unexpected behaviour
this._events.forEach((function(_ref){var func=_ref.func,event=_ref.event;_this7.reference.removeEventListener(event,func)})),this._events=[],this._tooltipNode?(this._hide(),this._tooltipNode.removeEventListener("mouseenter",this.hide),this._tooltipNode.removeEventListener("click",this.hide),// destroy instance
this.popperInstance.destroy(),// destroy tooltipNode if removeOnDestroy is not set, as popperInstance.destroy() already removes the element
this.popperInstance.options.removeOnDestroy||this._removeTooltipNode()):this._noLongerOpen(),this}},{key:"_findContainer",value:function(container,reference){
// if container is a query, get the relative element
return"string"===typeof container?container=window.document.querySelector(container):!1===container&&(
// if container is `false`, set it to reference parent
container=reference.parentNode),container}
/**
     * Append tooltip to container
     * @memberof Tooltip
     * @private
     * @param {HTMLElement} tooltip
     * @param {HTMLElement|String|false} container
     */},{key:"_append",value:function(tooltipNode,container){container.appendChild(tooltipNode)}},{key:"_setEventListeners",value:function(reference,events,options){var _this8=this,directEvents=[],oppositeEvents=[];events.forEach((function(event){switch(event){case"hover":directEvents.push("mouseenter"),oppositeEvents.push("mouseleave"),_this8.options.hideOnTargetClick&&oppositeEvents.push("click");break;case"focus":directEvents.push("focus"),oppositeEvents.push("blur"),_this8.options.hideOnTargetClick&&oppositeEvents.push("click");break;case"click":directEvents.push("click"),oppositeEvents.push("click");break}})),// schedule show tooltip
directEvents.forEach((function(event){var func=function(evt){!0!==_this8._isOpen&&(evt.usedByTooltip=!0,_this8._scheduleShow(reference,options.delay,options,evt))};_this8._events.push({event:event,func:func}),reference.addEventListener(event,func)})),// schedule hide tooltip
oppositeEvents.forEach((function(event){var func=function(evt){!0!==evt.usedByTooltip&&_this8._scheduleHide(reference,options.delay,options,evt)};_this8._events.push({event:event,func:func}),reference.addEventListener(event,func)}))}},{key:"_onDocumentTouch",value:function(event){this._enableDocumentTouch&&this._scheduleHide(this.reference,this.options.delay,this.options,event)}},{key:"_scheduleShow",value:function(reference,delay,options
/*, evt */){var _this9=this,computedDelay=delay&&delay.show||delay||0;
// defaults to 0
clearTimeout(this._scheduleTimer),this._scheduleTimer=window.setTimeout((function(){return _this9._show(reference,options)}),computedDelay)}},{key:"_scheduleHide",value:function(reference,delay,options,evt){var _this10=this,computedDelay=delay&&delay.hide||delay||0;
// defaults to 0
clearTimeout(this._scheduleTimer),this._scheduleTimer=window.setTimeout((function(){if(!1!==_this10._isOpen&&_this10._tooltipNode.ownerDocument.body.contains(_this10._tooltipNode)){// if we are hiding because of a mouseleave, we must check that the new
// reference isn't the tooltip, because in this case we don't want to hide it
if("mouseleave"===evt.type){var isSet=_this10._setTooltipNodeEvent(evt,reference,delay,options);// if we set the new event, don't hide the tooltip yet
// the new event will take care to hide it if necessary
if(isSet)return}_this10._hide(reference,options)}}),computedDelay)}}]),Tooltip}();
/**
 * Placement function, its context is the Tooltip instance.
 * @memberof Tooltip
 * @callback PlacementFunction
 * @param {HTMLElement} tooltip - tooltip DOM node.
 * @param {HTMLElement} reference - reference DOM node.
 * @return {String} placement - One of the allowed placement options.
 */
/**
 * Title function, its context is the Tooltip instance.
 * @memberof Tooltip
 * @callback TitleFunction
 * @return {String} placement - The desired title.
 */
function ownKeys$1$1(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread$1$1(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$1$1(Object(source),!0).forEach((function(key){_defineProperty$1$1(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$1$1(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}// Hide tooltips on touch devices
"undefined"!==typeof document&&document.addEventListener("touchstart",(function(event){for(var i=0;i<openTooltips$1.length;i++)openTooltips$1[i]._onDocumentTouch(event)}),!supportsPassive$1||{passive:!0,capture:!0});var state$1={enabled:!0},positions$1=["top","top-start","top-end","right","right-start","right-end","bottom","bottom-start","bottom-end","left","left-start","left-end"],defaultOptions$1={
// Default tooltip placement relative to target element
defaultPlacement:"top",
// Default CSS classes applied to the tooltip element
defaultClass:"vue-tooltip-theme",
// Default CSS classes applied to the target element of the tooltip
defaultTargetClass:"has-tooltip",
// Is the content HTML by default?
defaultHtml:!0,
// Default HTML template of the tooltip element
// It must include `tooltip-arrow` & `tooltip-inner` CSS classes (can be configured, see below)
// Change if the classes conflict with other libraries (for example bootstrap)
defaultTemplate:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
// Selector used to get the arrow element in the tooltip template
defaultArrowSelector:".tooltip-arrow, .tooltip__arrow",
// Selector used to get the inner content element in the tooltip template
defaultInnerSelector:".tooltip-inner, .tooltip__inner",
// Delay (ms)
defaultDelay:0,
// Default events that trigger the tooltip
defaultTrigger:"hover focus",
// Default position offset (px)
defaultOffset:0,
// Default container where the tooltip will be appended
defaultContainer:"body",defaultBoundariesElement:void 0,defaultPopperOptions:{},
// Class added when content is loading
defaultLoadingClass:"tooltip-loading",
// Displayed when tooltip content is loading
defaultLoadingContent:"...",
// Hide on mouseover tooltip
autoHide:!0,
// Close tooltip on click on tooltip target?
defaultHideOnTargetClick:!0,
// Auto destroy tooltip DOM nodes (ms)
disposeTimeout:5e3,
// Options for popover
popover:{defaultPlacement:"bottom",
// Use the `popoverClass` prop for theming
defaultClass:"vue-popover-theme",
// Base class (change if conflicts with other libraries)
defaultBaseClass:"tooltip popover",
// Wrapper class (contains arrow and inner)
defaultWrapperClass:"wrapper",
// Inner content class
defaultInnerClass:"tooltip-inner popover-inner",
// Arrow class
defaultArrowClass:"tooltip-arrow popover-arrow",
// Class added when popover is open
defaultOpenClass:"open",defaultDelay:0,defaultTrigger:"click",defaultOffset:0,defaultContainer:"body",defaultBoundariesElement:void 0,defaultPopperOptions:{},
// Hides if clicked outside of popover
defaultAutoHide:!0,
// Update popper on content resize
defaultHandleResize:!0}};function getOptions$1(options){var result={placement:"undefined"!==typeof options.placement?options.placement:directive$1.options.defaultPlacement,delay:"undefined"!==typeof options.delay?options.delay:directive$1.options.defaultDelay,html:"undefined"!==typeof options.html?options.html:directive$1.options.defaultHtml,template:"undefined"!==typeof options.template?options.template:directive$1.options.defaultTemplate,arrowSelector:"undefined"!==typeof options.arrowSelector?options.arrowSelector:directive$1.options.defaultArrowSelector,innerSelector:"undefined"!==typeof options.innerSelector?options.innerSelector:directive$1.options.defaultInnerSelector,trigger:"undefined"!==typeof options.trigger?options.trigger:directive$1.options.defaultTrigger,offset:"undefined"!==typeof options.offset?options.offset:directive$1.options.defaultOffset,container:"undefined"!==typeof options.container?options.container:directive$1.options.defaultContainer,boundariesElement:"undefined"!==typeof options.boundariesElement?options.boundariesElement:directive$1.options.defaultBoundariesElement,autoHide:"undefined"!==typeof options.autoHide?options.autoHide:directive$1.options.autoHide,hideOnTargetClick:"undefined"!==typeof options.hideOnTargetClick?options.hideOnTargetClick:directive$1.options.defaultHideOnTargetClick,loadingClass:"undefined"!==typeof options.loadingClass?options.loadingClass:directive$1.options.defaultLoadingClass,loadingContent:"undefined"!==typeof options.loadingContent?options.loadingContent:directive$1.options.defaultLoadingContent,popperOptions:_objectSpread$1$1({},"undefined"!==typeof options.popperOptions?options.popperOptions:directive$1.options.defaultPopperOptions)};if(result.offset){var typeofOffset=_typeof$5(result.offset),offset=result.offset;// One value -> switch
("number"===typeofOffset||"string"===typeofOffset&&-1===offset.indexOf(","))&&(offset="0, ".concat(offset)),result.popperOptions.modifiers||(result.popperOptions.modifiers={}),result.popperOptions.modifiers.offset={offset:offset}}return result.trigger&&-1!==result.trigger.indexOf("click")&&(result.hideOnTargetClick=!1),result}function getPlacement$1(value,modifiers){for(var placement=value.placement,i=0;i<positions$1.length;i++){var pos=positions$1[i];modifiers[pos]&&(placement=pos)}return placement}function getContent$1(value){var type=_typeof$5(value);return"string"===type?value:!(!value||"object"!==type)&&value.content}function createTooltip$1(el,value){var modifiers=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},content=getContent$1(value),classes="undefined"!==typeof value.classes?value.classes:directive$1.options.defaultClass,opts=_objectSpread$1$1({title:content},getOptions$1(_objectSpread$1$1(_objectSpread$1$1({},"object"===_typeof$5(value)?value:{}),{},{placement:getPlacement$1(value,modifiers)}))),tooltip=el._tooltip=new Tooltip$1(el,opts);tooltip.setClasses(classes),tooltip._vueEl=el;// Class on target
var targetClasses="undefined"!==typeof value.targetClasses?value.targetClasses:directive$1.options.defaultTargetClass;return el._tooltipTargetClasses=targetClasses,addClasses$1(el,targetClasses),tooltip}function destroyTooltip$1(el){el._tooltip&&(el._tooltip.dispose(),delete el._tooltip,delete el._tooltipOldShow),el._tooltipTargetClasses&&(removeClasses$1(el,el._tooltipTargetClasses),delete el._tooltipTargetClasses)}function bind$2(el,_ref){var value=_ref.value;_ref.oldValue;var tooltip,modifiers=_ref.modifiers,content=getContent$1(value);content&&state$1.enabled?(el._tooltip?(tooltip=el._tooltip,// Content
tooltip.setContent(content),// Options
tooltip.setOptions(_objectSpread$1$1(_objectSpread$1$1({},value),{},{placement:getPlacement$1(value,modifiers)}))):tooltip=createTooltip$1(el,value,modifiers),// Manual show
"undefined"!==typeof value.show&&value.show!==el._tooltipOldShow&&(el._tooltipOldShow=value.show,value.show?tooltip.show():tooltip.hide())):destroyTooltip$1(el)}var directive$1={options:defaultOptions$1,bind:bind$2,update:bind$2,unbind:function(el){destroyTooltip$1(el)}};function addListeners$1(el){el.addEventListener("click",onClick$1),el.addEventListener("touchstart",onTouchStart$1,!!supportsPassive$1&&{passive:!0})}function removeListeners$1(el){el.removeEventListener("click",onClick$1),el.removeEventListener("touchstart",onTouchStart$1),el.removeEventListener("touchend",onTouchEnd$1),el.removeEventListener("touchcancel",onTouchCancel$1)}function onClick$1(event){var el=event.currentTarget;event.closePopover=!el.$_vclosepopover_touch,event.closeAllPopover=el.$_closePopoverModifiers&&!!el.$_closePopoverModifiers.all}function onTouchStart$1(event){if(1===event.changedTouches.length){var el=event.currentTarget;el.$_vclosepopover_touch=!0;var touch=event.changedTouches[0];el.$_vclosepopover_touchPoint=touch,el.addEventListener("touchend",onTouchEnd$1),el.addEventListener("touchcancel",onTouchCancel$1)}}function onTouchEnd$1(event){var el=event.currentTarget;if(el.$_vclosepopover_touch=!1,1===event.changedTouches.length){var touch=event.changedTouches[0],firstTouch=el.$_vclosepopover_touchPoint;event.closePopover=Math.abs(touch.screenY-firstTouch.screenY)<20&&Math.abs(touch.screenX-firstTouch.screenX)<20,event.closeAllPopover=el.$_closePopoverModifiers&&!!el.$_closePopoverModifiers.all}}function onTouchCancel$1(event){var el=event.currentTarget;el.$_vclosepopover_touch=!1}var vclosepopover$1={bind:function(el,_ref){var value=_ref.value,modifiers=_ref.modifiers;el.$_closePopoverModifiers=modifiers,("undefined"===typeof value||value)&&addListeners$1(el)},update:function(el,_ref2){var value=_ref2.value,oldValue=_ref2.oldValue,modifiers=_ref2.modifiers;el.$_closePopoverModifiers=modifiers,value!==oldValue&&("undefined"===typeof value||value?addListeners$1(el):removeListeners$1(el))},unbind:function(el){removeListeners$1(el)}};function ownKeys$3$1(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread$3(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$3$1(Object(source),!0).forEach((function(key){_defineProperty$1$1(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$3$1(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}function getDefault$1(key){var value=directive$1.options.popover[key];return"undefined"===typeof value?directive$1.options[key]:value}var isIOS$1$1=!1;"undefined"!==typeof window&&"undefined"!==typeof navigator&&(isIOS$1$1=/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream);var openPopovers$1=[],Element$1$1=function(){};"undefined"!==typeof window&&(Element$1$1=window.Element);var script$3$1$1={name:"VPopover",components:{ResizeObserver:__vue_component__$3$1$1},props:{open:{type:Boolean,default:!1},disabled:{type:Boolean,default:!1},placement:{type:String,default:function(){return getDefault$1("defaultPlacement")}},delay:{type:[String,Number,Object],default:function(){return getDefault$1("defaultDelay")}},offset:{type:[String,Number],default:function(){return getDefault$1("defaultOffset")}},trigger:{type:String,default:function(){return getDefault$1("defaultTrigger")}},container:{type:[String,Object,Element$1$1,Boolean],default:function(){return getDefault$1("defaultContainer")}},boundariesElement:{type:[String,Element$1$1],default:function(){return getDefault$1("defaultBoundariesElement")}},popperOptions:{type:Object,default:function(){return getDefault$1("defaultPopperOptions")}},popoverClass:{type:[String,Array],default:function(){return getDefault$1("defaultClass")}},popoverBaseClass:{type:[String,Array],default:function(){return directive$1.options.popover.defaultBaseClass}},popoverInnerClass:{type:[String,Array],default:function(){return directive$1.options.popover.defaultInnerClass}},popoverWrapperClass:{type:[String,Array],default:function(){return directive$1.options.popover.defaultWrapperClass}},popoverArrowClass:{type:[String,Array],default:function(){return directive$1.options.popover.defaultArrowClass}},autoHide:{type:Boolean,default:function(){return directive$1.options.popover.defaultAutoHide}},handleResize:{type:Boolean,default:function(){return directive$1.options.popover.defaultHandleResize}},openGroup:{type:String,default:null},openClass:{type:[String,Array],default:function(){return directive$1.options.popover.defaultOpenClass}},ariaId:{default:null}},data:function(){return{isOpen:!1,id:Math.random().toString(36).substr(2,10)}},computed:{cssClass:function(){return _defineProperty$1$1({},this.openClass,this.isOpen)},popoverId:function(){return"popover_".concat(null!=this.ariaId?this.ariaId:this.id)}},watch:{open:function(val){val?this.show():this.hide()},disabled:function(val,oldVal){val!==oldVal&&(val?this.hide():this.open&&this.show())},container:function(val){if(this.isOpen&&this.popperInstance){var popoverNode=this.$refs.popover,reference=this.$refs.trigger,container=this.$_findContainer(this.container,reference);if(!container)return;container.appendChild(popoverNode),this.popperInstance.scheduleUpdate()}},trigger:function(val){this.$_removeEventListeners(),this.$_addEventListeners()},placement:function(val){var _this=this;this.$_updatePopper((function(){_this.popperInstance.options.placement=val}))},offset:"$_restartPopper",boundariesElement:"$_restartPopper",popperOptions:{handler:"$_restartPopper",deep:!0}},created:function(){this.$_isDisposed=!1,this.$_mounted=!1,this.$_events=[],this.$_preventOpen=!1},mounted:function(){var popoverNode=this.$refs.popover;popoverNode.parentNode&&popoverNode.parentNode.removeChild(popoverNode),this.$_init(),this.open&&this.show()},deactivated:function(){this.hide()},beforeDestroy:function(){this.dispose()},methods:{show:function(){var _this2=this,_ref2=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},event=_ref2.event;_ref2.skipDelay;var _ref2$force=_ref2.force,force=void 0!==_ref2$force&&_ref2$force;!force&&this.disabled||(this.$_scheduleShow(event),this.$emit("show")),this.$emit("update:open",!0),this.$_beingShowed=!0,requestAnimationFrame((function(){_this2.$_beingShowed=!1}))},hide:function(){var _ref3=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},event=_ref3.event;_ref3.skipDelay,this.$_scheduleHide(event),this.$emit("hide"),this.$emit("update:open",!1)},dispose:function(){if(this.$_isDisposed=!0,this.$_removeEventListeners(),this.hide({skipDelay:!0}),this.popperInstance&&(this.popperInstance.destroy(),!this.popperInstance.options.removeOnDestroy)){var popoverNode=this.$refs.popover;popoverNode.parentNode&&popoverNode.parentNode.removeChild(popoverNode)}this.$_mounted=!1,this.popperInstance=null,this.isOpen=!1,this.$emit("dispose")},$_init:function(){-1===this.trigger.indexOf("manual")&&this.$_addEventListeners()},$_show:function(){var _this3=this,reference=this.$refs.trigger,popoverNode=this.$refs.popover;// Already open
if(clearTimeout(this.$_disposeTimer),!this.isOpen){if(// Popper is already initialized
this.popperInstance&&(this.isOpen=!0,this.popperInstance.enableEventListeners(),this.popperInstance.scheduleUpdate()),!this.$_mounted){var container=this.$_findContainer(this.container,reference);if(!container)return;container.appendChild(popoverNode),this.$_mounted=!0,this.isOpen=!1,this.popperInstance&&requestAnimationFrame((function(){_this3.hidden||(_this3.isOpen=!0)}))}if(!this.popperInstance){var popperOptions=_objectSpread$3(_objectSpread$3({},this.popperOptions),{},{placement:this.placement});if(popperOptions.modifiers=_objectSpread$3(_objectSpread$3({},popperOptions.modifiers),{},{arrow:_objectSpread$3(_objectSpread$3({},popperOptions.modifiers&&popperOptions.modifiers.arrow),{},{element:this.$refs.arrow})}),this.offset){var offset=this.$_getOffset();popperOptions.modifiers.offset=_objectSpread$3(_objectSpread$3({},popperOptions.modifiers&&popperOptions.modifiers.offset),{},{offset:offset})}this.boundariesElement&&(popperOptions.modifiers.preventOverflow=_objectSpread$3(_objectSpread$3({},popperOptions.modifiers&&popperOptions.modifiers.preventOverflow),{},{boundariesElement:this.boundariesElement})),this.popperInstance=new Popper$2$1(reference,popoverNode,popperOptions),// Fix position
requestAnimationFrame((function(){if(_this3.hidden)return _this3.hidden=!1,void _this3.$_hide();!_this3.$_isDisposed&&_this3.popperInstance?(_this3.popperInstance.scheduleUpdate(),// Show the tooltip
requestAnimationFrame((function(){if(_this3.hidden)return _this3.hidden=!1,void _this3.$_hide();_this3.$_isDisposed?_this3.dispose():_this3.isOpen=!0}))):_this3.dispose()}))}var openGroup=this.openGroup;if(openGroup)for(var popover,i=0;i<openPopovers$1.length;i++)popover=openPopovers$1[i],popover.openGroup!==openGroup&&(popover.hide(),popover.$emit("close-group"));openPopovers$1.push(this),this.$emit("apply-show")}},$_hide:function(){var _this4=this;
// Already hidden
if(this.isOpen){var index=openPopovers$1.indexOf(this);-1!==index&&openPopovers$1.splice(index,1),this.isOpen=!1,this.popperInstance&&this.popperInstance.disableEventListeners(),clearTimeout(this.$_disposeTimer);var disposeTime=directive$1.options.popover.disposeTimeout||directive$1.options.disposeTimeout;null!==disposeTime&&(this.$_disposeTimer=setTimeout((function(){var popoverNode=_this4.$refs.popover;popoverNode&&(
// Don't remove popper instance, just the HTML element
popoverNode.parentNode&&popoverNode.parentNode.removeChild(popoverNode),_this4.$_mounted=!1)}),disposeTime)),this.$emit("apply-hide")}},$_findContainer:function(container,reference){
// if container is a query, get the relative element
return"string"===typeof container?container=window.document.querySelector(container):!1===container&&(
// if container is `false`, set it to reference parent
container=reference.parentNode),container},$_getOffset:function(){var typeofOffset=_typeof$5(this.offset),offset=this.offset;// One value -> switch
return("number"===typeofOffset||"string"===typeofOffset&&-1===offset.indexOf(","))&&(offset="0, ".concat(offset)),offset},$_addEventListeners:function(){var _this5=this,reference=this.$refs.trigger,directEvents=[],oppositeEvents=[],events="string"===typeof this.trigger?this.trigger.split(" ").filter((function(trigger){return-1!==["click","hover","focus"].indexOf(trigger)})):[];events.forEach((function(event){switch(event){case"hover":directEvents.push("mouseenter"),oppositeEvents.push("mouseleave");break;case"focus":directEvents.push("focus"),oppositeEvents.push("blur");break;case"click":directEvents.push("click"),oppositeEvents.push("click");break}})),// schedule show tooltip
directEvents.forEach((function(event){var func=function(event){_this5.isOpen||(event.usedByTooltip=!0,!_this5.$_preventOpen&&_this5.show({event:event}),_this5.hidden=!1)};_this5.$_events.push({event:event,func:func}),reference.addEventListener(event,func)})),// schedule hide tooltip
oppositeEvents.forEach((function(event){var func=function(event){event.usedByTooltip||(_this5.hide({event:event}),_this5.hidden=!0)};_this5.$_events.push({event:event,func:func}),reference.addEventListener(event,func)}))},$_scheduleShow:function(){var skipDelay=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(clearTimeout(this.$_scheduleTimer),skipDelay)this.$_show();else{
// defaults to 0
var computedDelay=parseInt(this.delay&&this.delay.show||this.delay||0);this.$_scheduleTimer=setTimeout(this.$_show.bind(this),computedDelay)}},$_scheduleHide:function(){var _this6=this,event=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,skipDelay=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(clearTimeout(this.$_scheduleTimer),skipDelay)this.$_hide();else{
// defaults to 0
var computedDelay=parseInt(this.delay&&this.delay.hide||this.delay||0);this.$_scheduleTimer=setTimeout((function(){if(_this6.isOpen){// if we are hiding because of a mouseleave, we must check that the new
// reference isn't the tooltip, because in this case we don't want to hide it
if(event&&"mouseleave"===event.type){var isSet=_this6.$_setTooltipNodeEvent(event);// if we set the new event, don't hide the tooltip yet
// the new event will take care to hide it if necessary
if(isSet)return}_this6.$_hide()}}),computedDelay)}},$_setTooltipNodeEvent:function(event){var _this7=this,reference=this.$refs.trigger,popoverNode=this.$refs.popover,relatedreference=event.relatedreference||event.toElement||event.relatedTarget,callback=function callback(event2){var relatedreference2=event2.relatedreference||event2.toElement||event2.relatedTarget;// Remove event listener after call
popoverNode.removeEventListener(event.type,callback),// If the new reference is not the reference element
reference.contains(relatedreference2)||
// Schedule to hide tooltip
_this7.hide({event:event2})};return!!popoverNode.contains(relatedreference)&&(
// listen to mouseleave on the tooltip element to be able to hide the tooltip
popoverNode.addEventListener(event.type,callback),!0)},$_removeEventListeners:function(){var reference=this.$refs.trigger;this.$_events.forEach((function(_ref4){var func=_ref4.func,event=_ref4.event;reference.removeEventListener(event,func)})),this.$_events=[]},$_updatePopper:function(cb){this.popperInstance&&(cb(),this.isOpen&&this.popperInstance.scheduleUpdate())},$_restartPopper:function(){if(this.popperInstance){var isOpen=this.isOpen;this.dispose(),this.$_isDisposed=!1,this.$_init(),isOpen&&this.show({skipDelay:!0,force:!0})}},$_handleGlobalClose:function(event){var _this8=this,touch=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.$_beingShowed||(this.hide({event:event}),event.closePopover?this.$emit("close-directive"):this.$emit("auto-hide"),touch&&(this.$_preventOpen=!0,setTimeout((function(){_this8.$_preventOpen=!1}),300)))},$_handleResize:function(){this.isOpen&&this.popperInstance&&(this.popperInstance.scheduleUpdate(),this.$emit("resize"))}}};function handleGlobalClick$1(event){handleGlobalClose$1(event)}function handleGlobalTouchend$1(event){handleGlobalClose$1(event,!0)}function handleGlobalClose$1(event){
// Delay so that close directive has time to set values
for(var touch=arguments.length>1&&void 0!==arguments[1]&&arguments[1],_loop=function(i){var popover=openPopovers$1[i];if(popover.$refs.popover){var contains=popover.$refs.popover.contains(event.target);requestAnimationFrame((function(){(event.closeAllPopover||event.closePopover&&contains||popover.autoHide&&!contains)&&popover.$_handleGlobalClose(event,touch)}))}},i=0;i<openPopovers$1.length;i++)_loop(i)}function normalizeComponent$1$1(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);
// Vue.extend constructor export interop.
const options="function"===typeof script?script.options:script;
// render functions
let hook;if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,
// functional template
isFunctionalTemplate&&(options.functional=!0)),
// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),
// inject component styles
style&&style.call(this,createInjectorSSR(context)),
// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},
// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(context){style.call(this,createInjectorShadow(context,this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
const originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
const existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}
/* script */"undefined"!==typeof document&&"undefined"!==typeof window&&(isIOS$1$1?document.addEventListener("touchend",handleGlobalTouchend$1,!supportsPassive$1||{passive:!0,capture:!0}):window.addEventListener("click",handleGlobalClick$1,!0));var __vue_script__$3$1$1=script$3$1$1,__vue_render__$3$1$1=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"v-popover",class:_vm.cssClass},[_c("div",{ref:"trigger",staticClass:"trigger",staticStyle:{display:"inline-block"},attrs:{"aria-describedby":_vm.isOpen?_vm.popoverId:void 0,tabindex:-1!==_vm.trigger.indexOf("focus")?0:void 0}},[_vm._t("default")],2),_vm._v(" "),_c("div",{ref:"popover",class:[_vm.popoverBaseClass,_vm.popoverClass,_vm.cssClass],style:{visibility:_vm.isOpen?"visible":"hidden"},attrs:{id:_vm.popoverId,"aria-hidden":_vm.isOpen?"false":"true",tabindex:_vm.autoHide?0:void 0},on:{keyup:function($event){if(!$event.type.indexOf("key")&&_vm._k($event.keyCode,"esc",27,$event.key,["Esc","Escape"]))return null;_vm.autoHide&&_vm.hide()}}},[_c("div",{class:_vm.popoverWrapperClass},[_c("div",{ref:"inner",class:_vm.popoverInnerClass,staticStyle:{position:"relative"}},[_c("div",[_vm._t("popover",null,{isOpen:_vm.isOpen})],2),_vm._v(" "),_vm.handleResize?_c("ResizeObserver",{on:{notify:_vm.$_handleResize}}):_vm._e()],1),_vm._v(" "),_c("div",{ref:"arrow",class:_vm.popoverArrowClass})])])])},__vue_staticRenderFns__$3$1$1=[];
/* template */__vue_render__$3$1$1._withStripped=!0;
/* style */
var __vue_inject_styles__$3$1$1=void 0,__vue_scope_id__$3$1$1=void 0,__vue_module_identifier__$3$1$1=void 0,__vue_is_functional_template__$3$1$1=!1,__vue_component__$2$2=normalizeComponent$1$1({render:__vue_render__$3$1$1,staticRenderFns:__vue_staticRenderFns__$3$1$1},__vue_inject_styles__$3$1$1,__vue_script__$3$1$1,__vue_scope_id__$3$1$1,__vue_is_functional_template__$3$1$1,__vue_module_identifier__$3$1$1,!1,void 0,void 0,void 0);
/* scoped */function styleInject$2(css,ref){void 0===ref&&(ref={});var insertAt=ref.insertAt;if(css&&"undefined"!==typeof document){var head=document.head||document.getElementsByTagName("head")[0],style=document.createElement("style");style.type="text/css","top"===insertAt&&head.firstChild?head.insertBefore(style,head.firstChild):head.appendChild(style),style.styleSheet?style.styleSheet.cssText=css:style.appendChild(document.createTextNode(css))}}var css_248z$3=".resize-observer[data-v-8859cc6c]{position:absolute;top:0;left:0;z-index:-1;width:100%;height:100%;border:none;background-color:transparent;pointer-events:none;display:block;overflow:hidden;opacity:0}.resize-observer[data-v-8859cc6c] object{display:block;position:absolute;top:0;left:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1}";function install$2(Vue){var options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!install$2.installed){install$2.installed=!0;var finalOptions={};merge(finalOptions,defaultOptions$1,options),plugin$1$1.options=finalOptions,directive$1.options=finalOptions,Vue.directive("tooltip",directive$1),Vue.directive("close-popover",vclosepopover$1),Vue.component("VPopover",__vue_component__$2$2)}}styleInject$2(css_248z$3);var plugin$1$1={install:install$2,get enabled(){return state$1.enabled},set enabled(value){state$1.enabled=value}},GlobalVue$2=null;// Auto-install
"undefined"!==typeof window?GlobalVue$2=window.Vue:"undefined"!==typeof global&&(GlobalVue$2=global.Vue),GlobalVue$2&&GlobalVue$2.use(plugin$1$1)
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */;var isBrowser$3="undefined"!==typeof window&&"undefined"!==typeof document&&"undefined"!==typeof navigator,timeoutDuration$2=function(){for(var longerTimeoutBrowsers=["Edge","Trident","Firefox"],i=0;i<longerTimeoutBrowsers.length;i+=1)if(isBrowser$3&&navigator.userAgent.indexOf(longerTimeoutBrowsers[i])>=0)return 1;return 0}();function microtaskDebounce$2(fn){var called=!1;return function(){called||(called=!0,window.Promise.resolve().then((function(){called=!1,fn()})))}}function taskDebounce$2(fn){var scheduled=!1;return function(){scheduled||(scheduled=!0,setTimeout((function(){scheduled=!1,fn()}),timeoutDuration$2))}}var supportsMicroTasks$2=isBrowser$3&&window.Promise,debounce$3=supportsMicroTasks$2?microtaskDebounce$2:taskDebounce$2;
/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction$3(functionToCheck){var getType={};return functionToCheck&&"[object Function]"===getType.toString.call(functionToCheck)}
/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */function getStyleComputedProperty$2(element,property){if(1!==element.nodeType)return[];
// NOTE: 1 DOM access here
var window=element.ownerDocument.defaultView,css=window.getComputedStyle(element,null);return property?css[property]:css}
/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */function getParentNode$2(element){return"HTML"===element.nodeName?element:element.parentNode||element.host}
/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */function getScrollParent$2(element){
// Return body, `getScroll` will take care to get the correct `scrollTop` from it
if(!element)return document.body;switch(element.nodeName){case"HTML":case"BODY":return element.ownerDocument.body;case"#document":return element.body}
// Firefox want us to check `-x` and `-y` variations as well
var _getStyleComputedProp=getStyleComputedProperty$2(element),overflow=_getStyleComputedProp.overflow,overflowX=_getStyleComputedProp.overflowX,overflowY=_getStyleComputedProp.overflowY;return/(auto|scroll|overlay)/.test(overflow+overflowY+overflowX)?element:getScrollParent$2(getParentNode$2(element))}
/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */function getReferenceNode$2(reference){return reference&&reference.referenceNode?reference.referenceNode:reference}var isIE11$2=isBrowser$3&&!(!window.MSInputMethodContext||!document.documentMode),isIE10$2=isBrowser$3&&/MSIE 10/.test(navigator.userAgent);
/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE$4(version){return 11===version?isIE11$2:10===version?isIE10$2:isIE11$2||isIE10$2}
/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */function getOffsetParent$2(element){if(!element)return document.documentElement;var noOffsetParent=isIE$4(10)?document.body:null,offsetParent=element.offsetParent||null;
// NOTE: 1 DOM access here
// Skip hidden elements which don't have an offsetParent
while(offsetParent===noOffsetParent&&element.nextElementSibling)offsetParent=(element=element.nextElementSibling).offsetParent;var nodeName=offsetParent&&offsetParent.nodeName;return nodeName&&"BODY"!==nodeName&&"HTML"!==nodeName?
// .offsetParent will return the closest TH, TD or TABLE in case
// no offsetParent is present, I hate this job...
-1!==["TH","TD","TABLE"].indexOf(offsetParent.nodeName)&&"static"===getStyleComputedProperty$2(offsetParent,"position")?getOffsetParent$2(offsetParent):offsetParent:element?element.ownerDocument.documentElement:document.documentElement}function isOffsetContainer$2(element){var nodeName=element.nodeName;return"BODY"!==nodeName&&("HTML"===nodeName||getOffsetParent$2(element.firstElementChild)===element)}
/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */function getRoot$2(node){return null!==node.parentNode?getRoot$2(node.parentNode):node}
/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */function findCommonOffsetParent$2(element1,element2){
// This check is needed to avoid errors in case one of the elements isn't defined for any reason
if(!element1||!element1.nodeType||!element2||!element2.nodeType)return document.documentElement;
// Here we make sure to give as "start" the element that comes first in the DOM
var order=element1.compareDocumentPosition(element2)&Node.DOCUMENT_POSITION_FOLLOWING,start=order?element1:element2,end=order?element2:element1,range=document.createRange();range.setStart(start,0),range.setEnd(end,0);var commonAncestorContainer=range.commonAncestorContainer;
// Both nodes are inside #document
if(element1!==commonAncestorContainer&&element2!==commonAncestorContainer||start.contains(end))return isOffsetContainer$2(commonAncestorContainer)?commonAncestorContainer:getOffsetParent$2(commonAncestorContainer);
// one of the nodes is inside shadowDOM, find which one
var element1root=getRoot$2(element1);return element1root.host?findCommonOffsetParent$2(element1root.host,element2):findCommonOffsetParent$2(element1,getRoot$2(element2).host)}
/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */function getScroll$2(element){var side=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"top",upperSide="top"===side?"scrollTop":"scrollLeft",nodeName=element.nodeName;if("BODY"===nodeName||"HTML"===nodeName){var html=element.ownerDocument.documentElement,scrollingElement=element.ownerDocument.scrollingElement||html;return scrollingElement[upperSide]}return element[upperSide]}
/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */function includeScroll$2(rect,element){var subtract=arguments.length>2&&void 0!==arguments[2]&&arguments[2],scrollTop=getScroll$2(element,"top"),scrollLeft=getScroll$2(element,"left"),modifier=subtract?-1:1;return rect.top+=scrollTop*modifier,rect.bottom+=scrollTop*modifier,rect.left+=scrollLeft*modifier,rect.right+=scrollLeft*modifier,rect}
/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */function getBordersSize$2(styles,axis){var sideA="x"===axis?"Left":"Top",sideB="Left"===sideA?"Right":"Bottom";return parseFloat(styles["border"+sideA+"Width"])+parseFloat(styles["border"+sideB+"Width"])}function getSize$2(axis,body,html,computedStyle){return Math.max(body["offset"+axis],body["scroll"+axis],html["client"+axis],html["offset"+axis],html["scroll"+axis],isIE$4(10)?parseInt(html["offset"+axis])+parseInt(computedStyle["margin"+("Height"===axis?"Top":"Left")])+parseInt(computedStyle["margin"+("Height"===axis?"Bottom":"Right")]):0)}function getWindowSizes$2(document){var body=document.body,html=document.documentElement,computedStyle=isIE$4(10)&&getComputedStyle(html);return{height:getSize$2("Height",body,html,computedStyle),width:getSize$2("Width",body,html,computedStyle)}}var classCallCheck$2=function(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")},createClass$2=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),defineProperty$2=function(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj},_extends$4=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target};
/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect$2(offsets){return _extends$4({},offsets,{right:offsets.left+offsets.width,bottom:offsets.top+offsets.height})}
/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */function getBoundingClientRect$2(element){var rect={};
// IE10 10 FIX: Please, don't ask, the element isn't
// considered in DOM in some circumstances...
// This isn't reproducible in IE10 compatibility mode of IE11
try{if(isIE$4(10)){rect=element.getBoundingClientRect();var scrollTop=getScroll$2(element,"top"),scrollLeft=getScroll$2(element,"left");rect.top+=scrollTop,rect.left+=scrollLeft,rect.bottom+=scrollTop,rect.right+=scrollLeft}else rect=element.getBoundingClientRect()}catch(e){}var result={left:rect.left,top:rect.top,width:rect.right-rect.left,height:rect.bottom-rect.top},sizes="HTML"===element.nodeName?getWindowSizes$2(element.ownerDocument):{},width=sizes.width||element.clientWidth||result.width,height=sizes.height||element.clientHeight||result.height,horizScrollbar=element.offsetWidth-width,vertScrollbar=element.offsetHeight-height;
// subtract scrollbar size from sizes
// if an hypothetical scrollbar is detected, we must be sure it's not a `border`
// we make this check conditional for performance reasons
if(horizScrollbar||vertScrollbar){var styles=getStyleComputedProperty$2(element);horizScrollbar-=getBordersSize$2(styles,"x"),vertScrollbar-=getBordersSize$2(styles,"y"),result.width-=horizScrollbar,result.height-=vertScrollbar}return getClientRect$2(result)}function getOffsetRectRelativeToArbitraryNode$2(children,parent){var fixedPosition=arguments.length>2&&void 0!==arguments[2]&&arguments[2],isIE10=isIE$4(10),isHTML="HTML"===parent.nodeName,childrenRect=getBoundingClientRect$2(children),parentRect=getBoundingClientRect$2(parent),scrollParent=getScrollParent$2(children),styles=getStyleComputedProperty$2(parent),borderTopWidth=parseFloat(styles.borderTopWidth),borderLeftWidth=parseFloat(styles.borderLeftWidth);
// In cases where the parent is fixed, we must ignore negative scroll in offset calc
fixedPosition&&isHTML&&(parentRect.top=Math.max(parentRect.top,0),parentRect.left=Math.max(parentRect.left,0));var offsets=getClientRect$2({top:childrenRect.top-parentRect.top-borderTopWidth,left:childrenRect.left-parentRect.left-borderLeftWidth,width:childrenRect.width,height:childrenRect.height});
// Subtract margins of documentElement in case it's being used as parent
// we do this only on HTML because it's the only element that behaves
// differently when margins are applied to it. The margins are included in
// the box of the documentElement, in the other cases not.
if(offsets.marginTop=0,offsets.marginLeft=0,!isIE10&&isHTML){var marginTop=parseFloat(styles.marginTop),marginLeft=parseFloat(styles.marginLeft);offsets.top-=borderTopWidth-marginTop,offsets.bottom-=borderTopWidth-marginTop,offsets.left-=borderLeftWidth-marginLeft,offsets.right-=borderLeftWidth-marginLeft,
// Attach marginTop and marginLeft because in some circumstances we may need them
offsets.marginTop=marginTop,offsets.marginLeft=marginLeft}return(isIE10&&!fixedPosition?parent.contains(scrollParent):parent===scrollParent&&"BODY"!==scrollParent.nodeName)&&(offsets=includeScroll$2(offsets,parent)),offsets}function getViewportOffsetRectRelativeToArtbitraryNode$2(element){var excludeScroll=arguments.length>1&&void 0!==arguments[1]&&arguments[1],html=element.ownerDocument.documentElement,relativeOffset=getOffsetRectRelativeToArbitraryNode$2(element,html),width=Math.max(html.clientWidth,window.innerWidth||0),height=Math.max(html.clientHeight,window.innerHeight||0),scrollTop=excludeScroll?0:getScroll$2(html),scrollLeft=excludeScroll?0:getScroll$2(html,"left"),offset={top:scrollTop-relativeOffset.top+relativeOffset.marginTop,left:scrollLeft-relativeOffset.left+relativeOffset.marginLeft,width:width,height:height};return getClientRect$2(offset)}
/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */function isFixed$2(element){var nodeName=element.nodeName;if("BODY"===nodeName||"HTML"===nodeName)return!1;if("fixed"===getStyleComputedProperty$2(element,"position"))return!0;var parentNode=getParentNode$2(element);return!!parentNode&&isFixed$2(parentNode)}
/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */function getFixedPositionOffsetParent$2(element){
// This check is needed to avoid errors in case one of the elements isn't defined for any reason
if(!element||!element.parentElement||isIE$4())return document.documentElement;var el=element.parentElement;while(el&&"none"===getStyleComputedProperty$2(el,"transform"))el=el.parentElement;return el||document.documentElement}
/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */function getBoundaries$2(popper,reference,padding,boundariesElement){var fixedPosition=arguments.length>4&&void 0!==arguments[4]&&arguments[4],boundaries={top:0,left:0},offsetParent=fixedPosition?getFixedPositionOffsetParent$2(popper):findCommonOffsetParent$2(popper,getReferenceNode$2(reference));
// NOTE: 1 DOM access here
// Handle viewport case
if("viewport"===boundariesElement)boundaries=getViewportOffsetRectRelativeToArtbitraryNode$2(offsetParent,fixedPosition);else{
// Handle other cases based on DOM element used as boundaries
var boundariesNode=void 0;"scrollParent"===boundariesElement?(boundariesNode=getScrollParent$2(getParentNode$2(reference)),"BODY"===boundariesNode.nodeName&&(boundariesNode=popper.ownerDocument.documentElement)):boundariesNode="window"===boundariesElement?popper.ownerDocument.documentElement:boundariesElement;var offsets=getOffsetRectRelativeToArbitraryNode$2(boundariesNode,offsetParent,fixedPosition);
// In case of HTML, we need a different computation
if("HTML"!==boundariesNode.nodeName||isFixed$2(offsetParent))
// for all the other DOM elements, this one is good
boundaries=offsets;else{var _getWindowSizes=getWindowSizes$2(popper.ownerDocument),height=_getWindowSizes.height,width=_getWindowSizes.width;boundaries.top+=offsets.top-offsets.marginTop,boundaries.bottom=height+offsets.top,boundaries.left+=offsets.left-offsets.marginLeft,boundaries.right=width+offsets.left}}
// Add paddings
padding=padding||0;var isPaddingNumber="number"===typeof padding;return boundaries.left+=isPaddingNumber?padding:padding.left||0,boundaries.top+=isPaddingNumber?padding:padding.top||0,boundaries.right-=isPaddingNumber?padding:padding.right||0,boundaries.bottom-=isPaddingNumber?padding:padding.bottom||0,boundaries}function getArea$2(_ref){var width=_ref.width,height=_ref.height;return width*height}
/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function computeAutoPlacement$2(placement,refRect,popper,reference,boundariesElement){var padding=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(-1===placement.indexOf("auto"))return placement;var boundaries=getBoundaries$2(popper,reference,padding,boundariesElement),rects={top:{width:boundaries.width,height:refRect.top-boundaries.top},right:{width:boundaries.right-refRect.right,height:boundaries.height},bottom:{width:boundaries.width,height:boundaries.bottom-refRect.bottom},left:{width:refRect.left-boundaries.left,height:boundaries.height}},sortedAreas=Object.keys(rects).map((function(key){return _extends$4({key:key},rects[key],{area:getArea$2(rects[key])})})).sort((function(a,b){return b.area-a.area})),filteredAreas=sortedAreas.filter((function(_ref2){var width=_ref2.width,height=_ref2.height;return width>=popper.clientWidth&&height>=popper.clientHeight})),computedPlacement=filteredAreas.length>0?filteredAreas[0].key:sortedAreas[0].key,variation=placement.split("-")[1];return computedPlacement+(variation?"-"+variation:"")}
/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */function getReferenceOffsets$2(state,popper,reference){var fixedPosition=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,commonOffsetParent=fixedPosition?getFixedPositionOffsetParent$2(popper):findCommonOffsetParent$2(popper,getReferenceNode$2(reference));return getOffsetRectRelativeToArbitraryNode$2(reference,commonOffsetParent,fixedPosition)}
/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */function getOuterSizes$2(element){var window=element.ownerDocument.defaultView,styles=window.getComputedStyle(element),x=parseFloat(styles.marginTop||0)+parseFloat(styles.marginBottom||0),y=parseFloat(styles.marginLeft||0)+parseFloat(styles.marginRight||0),result={width:element.offsetWidth+y,height:element.offsetHeight+x};return result}
/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */function getOppositePlacement$2(placement){var hash={left:"right",right:"left",bottom:"top",top:"bottom"};return placement.replace(/left|right|bottom|top/g,(function(matched){return hash[matched]}))}
/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */function getPopperOffsets$2(popper,referenceOffsets,placement){placement=placement.split("-")[0];
// Get popper node sizes
var popperRect=getOuterSizes$2(popper),popperOffsets={width:popperRect.width,height:popperRect.height},isHoriz=-1!==["right","left"].indexOf(placement),mainSide=isHoriz?"top":"left",secondarySide=isHoriz?"left":"top",measurement=isHoriz?"height":"width",secondaryMeasurement=isHoriz?"width":"height";
// Add position, width and height to our offsets object
return popperOffsets[mainSide]=referenceOffsets[mainSide]+referenceOffsets[measurement]/2-popperRect[measurement]/2,popperOffsets[secondarySide]=placement===secondarySide?referenceOffsets[secondarySide]-popperRect[secondaryMeasurement]:referenceOffsets[getOppositePlacement$2(secondarySide)],popperOffsets}
/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */function find$3(arr,check){
// use native find if supported
return Array.prototype.find?arr.find(check):arr.filter(check)[0];
// use `filter` to obtain the same behavior of `find`
}
/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */function findIndex$2(arr,prop,value){
// use native findIndex if supported
if(Array.prototype.findIndex)return arr.findIndex((function(cur){return cur[prop]===value}));
// use `find` + `indexOf` if `findIndex` isn't supported
var match=find$3(arr,(function(obj){return obj[prop]===value}));return arr.indexOf(match)}
/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */function runModifiers$2(modifiers,data,ends){var modifiersToRun=void 0===ends?modifiers:modifiers.slice(0,findIndex$2(modifiers,"name",ends));return modifiersToRun.forEach((function(modifier){modifier["function"];var fn=modifier["function"]||modifier.fn;// eslint-disable-line dot-notation
modifier.enabled&&isFunction$3(fn)&&(
// Add properties to offsets to make them a complete clientRect object
// we do this before each modifier to make sure the previous one doesn't
// mess with these values
data.offsets.popper=getClientRect$2(data.offsets.popper),data.offsets.reference=getClientRect$2(data.offsets.reference),data=fn(data,modifier))})),data}
/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */function update$2(){
// if popper is destroyed, don't perform any further update
if(!this.state.isDestroyed){var data={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};
// compute reference element offsets
data.offsets.reference=getReferenceOffsets$2(this.state,this.popper,this.reference,this.options.positionFixed),
// compute auto placement, store placement inside the data object,
// modifiers will be able to edit `placement` if needed
// and refer to originalPlacement to know the original value
data.placement=computeAutoPlacement$2(this.options.placement,data.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),
// store the computed placement inside `originalPlacement`
data.originalPlacement=data.placement,data.positionFixed=this.options.positionFixed,
// compute the popper offsets
data.offsets.popper=getPopperOffsets$2(this.popper,data.offsets.reference,data.placement),data.offsets.popper.position=this.options.positionFixed?"fixed":"absolute",
// run the modifiers
data=runModifiers$2(this.modifiers,data),
// the first `update` will call `onCreate` callback
// the other ones will call `onUpdate` callback
this.state.isCreated?this.options.onUpdate(data):(this.state.isCreated=!0,this.options.onCreate(data))}}
/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */function isModifierEnabled$2(modifiers,modifierName){return modifiers.some((function(_ref){var name=_ref.name,enabled=_ref.enabled;return enabled&&name===modifierName}))}
/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */function getSupportedPropertyName$2(property){for(var prefixes=[!1,"ms","Webkit","Moz","O"],upperProp=property.charAt(0).toUpperCase()+property.slice(1),i=0;i<prefixes.length;i++){var prefix=prefixes[i],toCheck=prefix?""+prefix+upperProp:property;if("undefined"!==typeof document.body.style[toCheck])return toCheck}return null}
/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */function destroy$2(){return this.state.isDestroyed=!0,
// touch DOM only if `applyStyle` modifier is enabled
isModifierEnabled$2(this.modifiers,"applyStyle")&&(this.popper.removeAttribute("x-placement"),this.popper.style.position="",this.popper.style.top="",this.popper.style.left="",this.popper.style.right="",this.popper.style.bottom="",this.popper.style.willChange="",this.popper.style[getSupportedPropertyName$2("transform")]=""),this.disableEventListeners(),
// remove the popper if user explicitly asked for the deletion on destroy
// do not use `remove` because IE11 doesn't support it
this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}
/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */function getWindow$2(element){var ownerDocument=element.ownerDocument;return ownerDocument?ownerDocument.defaultView:window}function attachToScrollParents$2(scrollParent,event,callback,scrollParents){var isBody="BODY"===scrollParent.nodeName,target=isBody?scrollParent.ownerDocument.defaultView:scrollParent;target.addEventListener(event,callback,{passive:!0}),isBody||attachToScrollParents$2(getScrollParent$2(target.parentNode),event,callback,scrollParents),scrollParents.push(target)}
/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */function setupEventListeners$2(reference,options,state,updateBound){
// Resize event listener on window
state.updateBound=updateBound,getWindow$2(reference).addEventListener("resize",state.updateBound,{passive:!0});
// Scroll event listener on scroll parents
var scrollElement=getScrollParent$2(reference);return attachToScrollParents$2(scrollElement,"scroll",state.updateBound,state.scrollParents),state.scrollElement=scrollElement,state.eventsEnabled=!0,state}
/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */function enableEventListeners$2(){this.state.eventsEnabled||(this.state=setupEventListeners$2(this.reference,this.options,this.state,this.scheduleUpdate))}
/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */function removeEventListeners$2(reference,state){
// Remove resize event listener on window
return getWindow$2(reference).removeEventListener("resize",state.updateBound),
// Remove scroll event listener on scroll parents
state.scrollParents.forEach((function(target){target.removeEventListener("scroll",state.updateBound)})),
// Reset state
state.updateBound=null,state.scrollParents=[],state.scrollElement=null,state.eventsEnabled=!1,state}
/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */function disableEventListeners$2(){this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=removeEventListeners$2(this.reference,this.state))}
/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */function isNumeric$2(n){return""!==n&&!isNaN(parseFloat(n))&&isFinite(n)}
/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */function setStyles$2(element,styles){Object.keys(styles).forEach((function(prop){var unit="";
// add unit if the value is numeric and is one of the following
-1!==["width","height","top","right","bottom","left"].indexOf(prop)&&isNumeric$2(styles[prop])&&(unit="px"),element.style[prop]=styles[prop]+unit}))}
/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */function setAttributes$2(element,attributes){Object.keys(attributes).forEach((function(prop){var value=attributes[prop];!1!==value?element.setAttribute(prop,attributes[prop]):element.removeAttribute(prop)}))}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */function applyStyle$2(data){
// any property present in `data.styles` will be applied to the popper,
// in this way we can make the 3rd party modifiers add custom styles to it
// Be aware, modifiers could override the properties defined in the previous
// lines of this modifier!
return setStyles$2(data.instance.popper,data.styles),
// any property present in `data.attributes` will be applied to the popper,
// they will be set as HTML attributes of the element
setAttributes$2(data.instance.popper,data.attributes),
// if arrowElement is defined and arrowStyles has some properties
data.arrowElement&&Object.keys(data.arrowStyles).length&&setStyles$2(data.arrowElement,data.arrowStyles),data}
/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */function applyStyleOnLoad$2(reference,popper,options,modifierOptions,state){
// compute reference element offsets
var referenceOffsets=getReferenceOffsets$2(state,popper,reference,options.positionFixed),placement=computeAutoPlacement$2(options.placement,referenceOffsets,popper,reference,options.modifiers.flip.boundariesElement,options.modifiers.flip.padding);
// compute auto placement, store placement inside the data object,
// modifiers will be able to edit `placement` if needed
// and refer to originalPlacement to know the original value
return popper.setAttribute("x-placement",placement),
// Apply `position` to popper before anything else because
// without the position applied we can't guarantee correct computations
setStyles$2(popper,{position:options.positionFixed?"fixed":"absolute"}),options}
/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */function getRoundedOffsets$2(data,shouldRound){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,round=Math.round,floor=Math.floor,noRound=function(v){return v},referenceWidth=round(reference.width),popperWidth=round(popper.width),isVertical=-1!==["left","right"].indexOf(data.placement),isVariation=-1!==data.placement.indexOf("-"),sameWidthParity=referenceWidth%2===popperWidth%2,bothOddWidth=referenceWidth%2===1&&popperWidth%2===1,horizontalToInteger=shouldRound?isVertical||isVariation||sameWidthParity?round:floor:noRound,verticalToInteger=shouldRound?round:noRound;return{left:horizontalToInteger(bothOddWidth&&!isVariation&&shouldRound?popper.left-1:popper.left),top:verticalToInteger(popper.top),bottom:verticalToInteger(popper.bottom),right:horizontalToInteger(popper.right)}}var isFirefox$2=isBrowser$3&&/Firefox/i.test(navigator.userAgent);
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function computeStyle$2(data,options){var x=options.x,y=options.y,popper=data.offsets.popper,legacyGpuAccelerationOption=find$3(data.instance.modifiers,(function(modifier){return"applyStyle"===modifier.name})).gpuAcceleration,gpuAcceleration=void 0!==legacyGpuAccelerationOption?legacyGpuAccelerationOption:options.gpuAcceleration,offsetParent=getOffsetParent$2(data.instance.popper),offsetParentRect=getBoundingClientRect$2(offsetParent),styles={position:popper.position},offsets=getRoundedOffsets$2(data,window.devicePixelRatio<2||!isFirefox$2),sideA="bottom"===x?"top":"bottom",sideB="right"===y?"left":"right",prefixedProperty=getSupportedPropertyName$2("transform"),left=void 0,top=void 0;if(top="bottom"===sideA?
// when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
// and not the bottom of the html element
"HTML"===offsetParent.nodeName?-offsetParent.clientHeight+offsets.bottom:-offsetParentRect.height+offsets.bottom:offsets.top,left="right"===sideB?"HTML"===offsetParent.nodeName?-offsetParent.clientWidth+offsets.right:-offsetParentRect.width+offsets.right:offsets.left,gpuAcceleration&&prefixedProperty)styles[prefixedProperty]="translate3d("+left+"px, "+top+"px, 0)",styles[sideA]=0,styles[sideB]=0,styles.willChange="transform";else{
// othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
var invertTop="bottom"===sideA?-1:1,invertLeft="right"===sideB?-1:1;styles[sideA]=top*invertTop,styles[sideB]=left*invertLeft,styles.willChange=sideA+", "+sideB}
// Attributes
var attributes={"x-placement":data.placement};
// Update `data` attributes, styles and arrowStyles
return data.attributes=_extends$4({},attributes,data.attributes),data.styles=_extends$4({},styles,data.styles),data.arrowStyles=_extends$4({},data.offsets.arrow,data.arrowStyles),data}
/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */function isModifierRequired$2(modifiers,requestingName,requestedName){var requesting=find$3(modifiers,(function(_ref){var name=_ref.name;return name===requestingName})),isRequired=!!requesting&&modifiers.some((function(modifier){return modifier.name===requestedName&&modifier.enabled&&modifier.order<requesting.order}));if(!isRequired);return isRequired}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function arrow$3$1(data,options){var _data$offsets$arrow;
// arrow depends on keepTogether in order to work
if(!isModifierRequired$2(data.instance.modifiers,"arrow","keepTogether"))return data;var arrowElement=options.element;
// if arrowElement is a string, suppose it's a CSS selector
if("string"===typeof arrowElement){
// if arrowElement is not found, don't run the modifier
if(arrowElement=data.instance.popper.querySelector(arrowElement),!arrowElement)return data}else
// if the arrowElement isn't a query selector we must check that the
// provided DOM node is child of its popper node
if(!data.instance.popper.contains(arrowElement))return data;var placement=data.placement.split("-")[0],_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,isVertical=-1!==["left","right"].indexOf(placement),len=isVertical?"height":"width",sideCapitalized=isVertical?"Top":"Left",side=sideCapitalized.toLowerCase(),altSide=isVertical?"left":"top",opSide=isVertical?"bottom":"right",arrowElementSize=getOuterSizes$2(arrowElement)[len];
// extends keepTogether behavior making sure the popper and its
// reference have enough pixels in conjunction
// top/left side
reference[opSide]-arrowElementSize<popper[side]&&(data.offsets.popper[side]-=popper[side]-(reference[opSide]-arrowElementSize)),
// bottom/right side
reference[side]+arrowElementSize>popper[opSide]&&(data.offsets.popper[side]+=reference[side]+arrowElementSize-popper[opSide]),data.offsets.popper=getClientRect$2(data.offsets.popper);
// compute center of the popper
var center=reference[side]+reference[len]/2-arrowElementSize/2,css=getStyleComputedProperty$2(data.instance.popper),popperMarginSide=parseFloat(css["margin"+sideCapitalized]),popperBorderSide=parseFloat(css["border"+sideCapitalized+"Width"]),sideValue=center-data.offsets.popper[side]-popperMarginSide-popperBorderSide;
// Compute the sideValue using the updated popper offsets
// take popper margin in account because we don't have this info available
// prevent arrowElement from being placed not contiguously to its popper
return sideValue=Math.max(Math.min(popper[len]-arrowElementSize,sideValue),0),data.arrowElement=arrowElement,data.offsets.arrow=(_data$offsets$arrow={},defineProperty$2(_data$offsets$arrow,side,Math.round(sideValue)),defineProperty$2(_data$offsets$arrow,altSide,""),_data$offsets$arrow),data}
/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */function getOppositeVariation$2(variation){return"end"===variation?"start":"start"===variation?"end":variation}
/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */var placements$2=["auto-start","auto","auto-end","top-start","top","top-end","right-start","right","right-end","bottom-end","bottom","bottom-start","left-end","left","left-start"],validPlacements$2=placements$2.slice(3);
// Get rid of `auto` `auto-start` and `auto-end`
/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise$2(placement){var counter=arguments.length>1&&void 0!==arguments[1]&&arguments[1],index=validPlacements$2.indexOf(placement),arr=validPlacements$2.slice(index+1).concat(validPlacements$2.slice(0,index));return counter?arr.reverse():arr}var BEHAVIORS$2={FLIP:"flip",CLOCKWISE:"clockwise",COUNTERCLOCKWISE:"counterclockwise"};
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function flip$2(data,options){
// if `inner` modifier is enabled, we can't use the `flip` modifier
if(isModifierEnabled$2(data.instance.modifiers,"inner"))return data;if(data.flipped&&data.placement===data.originalPlacement)
// seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
return data;var boundaries=getBoundaries$2(data.instance.popper,data.instance.reference,options.padding,options.boundariesElement,data.positionFixed),placement=data.placement.split("-")[0],placementOpposite=getOppositePlacement$2(placement),variation=data.placement.split("-")[1]||"",flipOrder=[];switch(options.behavior){case BEHAVIORS$2.FLIP:flipOrder=[placement,placementOpposite];break;case BEHAVIORS$2.CLOCKWISE:flipOrder=clockwise$2(placement);break;case BEHAVIORS$2.COUNTERCLOCKWISE:flipOrder=clockwise$2(placement,!0);break;default:flipOrder=options.behavior}return flipOrder.forEach((function(step,index){if(placement!==step||flipOrder.length===index+1)return data;placement=data.placement.split("-")[0],placementOpposite=getOppositePlacement$2(placement);var popperOffsets=data.offsets.popper,refOffsets=data.offsets.reference,floor=Math.floor,overlapsRef="left"===placement&&floor(popperOffsets.right)>floor(refOffsets.left)||"right"===placement&&floor(popperOffsets.left)<floor(refOffsets.right)||"top"===placement&&floor(popperOffsets.bottom)>floor(refOffsets.top)||"bottom"===placement&&floor(popperOffsets.top)<floor(refOffsets.bottom),overflowsLeft=floor(popperOffsets.left)<floor(boundaries.left),overflowsRight=floor(popperOffsets.right)>floor(boundaries.right),overflowsTop=floor(popperOffsets.top)<floor(boundaries.top),overflowsBottom=floor(popperOffsets.bottom)>floor(boundaries.bottom),overflowsBoundaries="left"===placement&&overflowsLeft||"right"===placement&&overflowsRight||"top"===placement&&overflowsTop||"bottom"===placement&&overflowsBottom,isVertical=-1!==["top","bottom"].indexOf(placement),flippedVariationByRef=!!options.flipVariations&&(isVertical&&"start"===variation&&overflowsLeft||isVertical&&"end"===variation&&overflowsRight||!isVertical&&"start"===variation&&overflowsTop||!isVertical&&"end"===variation&&overflowsBottom),flippedVariationByContent=!!options.flipVariationsByContent&&(isVertical&&"start"===variation&&overflowsRight||isVertical&&"end"===variation&&overflowsLeft||!isVertical&&"start"===variation&&overflowsBottom||!isVertical&&"end"===variation&&overflowsTop),flippedVariation=flippedVariationByRef||flippedVariationByContent;(overlapsRef||overflowsBoundaries||flippedVariation)&&(
// this boolean to detect any flip loop
data.flipped=!0,(overlapsRef||overflowsBoundaries)&&(placement=flipOrder[index+1]),flippedVariation&&(variation=getOppositeVariation$2(variation)),data.placement=placement+(variation?"-"+variation:""),
// this object contains `position`, we want to preserve it along with
// any additional property we may add in the future
data.offsets.popper=_extends$4({},data.offsets.popper,getPopperOffsets$2(data.instance.popper,data.offsets.reference,data.placement)),data=runModifiers$2(data.instance.modifiers,data,"flip"))})),data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function keepTogether$2(data){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,placement=data.placement.split("-")[0],floor=Math.floor,isVertical=-1!==["top","bottom"].indexOf(placement),side=isVertical?"right":"bottom",opSide=isVertical?"left":"top",measurement=isVertical?"width":"height";return popper[side]<floor(reference[opSide])&&(data.offsets.popper[opSide]=floor(reference[opSide])-popper[measurement]),popper[opSide]>floor(reference[side])&&(data.offsets.popper[opSide]=floor(reference[side])),data}
/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */function toValue$2(str,measurement,popperOffsets,referenceOffsets){
// separate value from unit
var split=str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),value=+split[1],unit=split[2];
// If it's not a number it's an operator, I guess
if(!value)return str;if(0===unit.indexOf("%")){var element=void 0;switch(unit){case"%p":element=popperOffsets;break;case"%":case"%r":default:element=referenceOffsets}var rect=getClientRect$2(element);return rect[measurement]/100*value}if("vh"===unit||"vw"===unit){
// if is a vh or vw, we calculate the size based on the viewport
var size=void 0;return size="vh"===unit?Math.max(document.documentElement.clientHeight,window.innerHeight||0):Math.max(document.documentElement.clientWidth,window.innerWidth||0),size/100*value}
// if is an explicit pixel unit, we get rid of the unit and keep the value
// if is an implicit unit, it's px, and we return just the value
return value}
/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */function parseOffset$2(offset,popperOffsets,referenceOffsets,basePlacement){var offsets=[0,0],useHeight=-1!==["right","left"].indexOf(basePlacement),fragments=offset.split(/(\+|\-)/).map((function(frag){return frag.trim()})),divider=fragments.indexOf(find$3(fragments,(function(frag){return-1!==frag.search(/,|\s/)})));
// Use height if placement is left or right and index is 0 otherwise use width
// in this way the first offset will use an axis and the second one
// will use the other one
fragments[divider]&&fragments[divider].indexOf(",");
// If divider is found, we divide the list of values and operands to divide
// them by ofset X and Y.
var splitRegex=/\s*,\s*|\s+/,ops=-1!==divider?[fragments.slice(0,divider).concat([fragments[divider].split(splitRegex)[0]]),[fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider+1))]:[fragments];
// Convert the values with units to absolute pixels to allow our computations
return ops=ops.map((function(op,index){
// Most of the units rely on the orientation of the popper
var measurement=(1===index?!useHeight:useHeight)?"height":"width",mergeWithPrevious=!1;return op.reduce((function(a,b){return""===a[a.length-1]&&-1!==["+","-"].indexOf(b)?(a[a.length-1]=b,mergeWithPrevious=!0,a):mergeWithPrevious?(a[a.length-1]+=b,mergeWithPrevious=!1,a):a.concat(b)}),[]).map((function(str){return toValue$2(str,measurement,popperOffsets,referenceOffsets)}))})),
// Loop trough the offsets arrays and execute the operations
ops.forEach((function(op,index){op.forEach((function(frag,index2){isNumeric$2(frag)&&(offsets[index]+=frag*("-"===op[index2-1]?-1:1))}))})),offsets}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */function offset$2(data,_ref){var offset=_ref.offset,placement=data.placement,_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,basePlacement=placement.split("-")[0],offsets=void 0;return offsets=isNumeric$2(+offset)?[+offset,0]:parseOffset$2(offset,popper,reference,basePlacement),"left"===basePlacement?(popper.top+=offsets[0],popper.left-=offsets[1]):"right"===basePlacement?(popper.top+=offsets[0],popper.left+=offsets[1]):"top"===basePlacement?(popper.left+=offsets[0],popper.top-=offsets[1]):"bottom"===basePlacement&&(popper.left+=offsets[0],popper.top+=offsets[1]),data.popper=popper,data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function preventOverflow$2(data,options){var boundariesElement=options.boundariesElement||getOffsetParent$2(data.instance.popper);
// If offsetParent is the reference element, we really want to
// go one step up and use the next offsetParent as reference to
// avoid to make this modifier completely useless and look like broken
data.instance.reference===boundariesElement&&(boundariesElement=getOffsetParent$2(boundariesElement));
// NOTE: DOM access here
// resets the popper's position so that the document size can be calculated excluding
// the size of the popper element itself
var transformProp=getSupportedPropertyName$2("transform"),popperStyles=data.instance.popper.style,top=popperStyles.top,left=popperStyles.left,transform=popperStyles[transformProp];popperStyles.top="",popperStyles.left="",popperStyles[transformProp]="";var boundaries=getBoundaries$2(data.instance.popper,data.instance.reference,options.padding,boundariesElement,data.positionFixed);
// NOTE: DOM access here
// restores the original style properties after the offsets have been computed
popperStyles.top=top,popperStyles.left=left,popperStyles[transformProp]=transform,options.boundaries=boundaries;var order=options.priority,popper=data.offsets.popper,check={primary:function(placement){var value=popper[placement];return popper[placement]<boundaries[placement]&&!options.escapeWithReference&&(value=Math.max(popper[placement],boundaries[placement])),defineProperty$2({},placement,value)},secondary:function(placement){var mainSide="right"===placement?"left":"top",value=popper[mainSide];return popper[placement]>boundaries[placement]&&!options.escapeWithReference&&(value=Math.min(popper[mainSide],boundaries[placement]-("right"===placement?popper.width:popper.height))),defineProperty$2({},mainSide,value)}};return order.forEach((function(placement){var side=-1!==["left","top"].indexOf(placement)?"primary":"secondary";popper=_extends$4({},popper,check[side](placement))})),data.offsets.popper=popper,data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function shift$3(data){var placement=data.placement,basePlacement=placement.split("-")[0],shiftvariation=placement.split("-")[1];
// if shift shiftvariation is specified, run the modifier
if(shiftvariation){var _data$offsets=data.offsets,reference=_data$offsets.reference,popper=_data$offsets.popper,isVertical=-1!==["bottom","top"].indexOf(basePlacement),side=isVertical?"left":"top",measurement=isVertical?"width":"height",shiftOffsets={start:defineProperty$2({},side,reference[side]),end:defineProperty$2({},side,reference[side]+reference[measurement]-popper[measurement])};data.offsets.popper=_extends$4({},popper,shiftOffsets[shiftvariation])}return data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function hide$2(data){if(!isModifierRequired$2(data.instance.modifiers,"hide","preventOverflow"))return data;var refRect=data.offsets.reference,bound=find$3(data.instance.modifiers,(function(modifier){return"preventOverflow"===modifier.name})).boundaries;if(refRect.bottom<bound.top||refRect.left>bound.right||refRect.top>bound.bottom||refRect.right<bound.left){
// Avoid unnecessary DOM access if visibility hasn't changed
if(!0===data.hide)return data;data.hide=!0,data.attributes["x-out-of-boundaries"]=""}else{
// Avoid unnecessary DOM access if visibility hasn't changed
if(!1===data.hide)return data;data.hide=!1,data.attributes["x-out-of-boundaries"]=!1}return data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function inner$2(data){var placement=data.placement,basePlacement=placement.split("-")[0],_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,isHoriz=-1!==["left","right"].indexOf(basePlacement),subtractLength=-1===["top","left"].indexOf(basePlacement);return popper[isHoriz?"left":"top"]=reference[basePlacement]-(subtractLength?popper[isHoriz?"width":"height"]:0),data.placement=getOppositePlacement$2(placement),data.offsets.popper=getClientRect$2(popper),data}
/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */
/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */var modifiers$3={
/**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
shift:{
/** @prop {number} order=100 - Index used to define the order of execution */
order:100,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:shift$3},
/**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
offset:{
/** @prop {number} order=200 - Index used to define the order of execution */
order:200,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:offset$2,
/** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
offset:0},
/**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
preventOverflow:{
/** @prop {number} order=300 - Index used to define the order of execution */
order:300,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:preventOverflow$2,
/**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
priority:["left","right","top","bottom"],
/**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
padding:5,
/**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
boundariesElement:"scrollParent"},
/**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
keepTogether:{
/** @prop {number} order=400 - Index used to define the order of execution */
order:400,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:keepTogether$2},
/**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
arrow:{
/** @prop {number} order=500 - Index used to define the order of execution */
order:500,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:arrow$3$1,
/** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
element:"[x-arrow]"},
/**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
flip:{
/** @prop {number} order=600 - Index used to define the order of execution */
order:600,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:flip$2,
/**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
behavior:"flip",
/**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
padding:5,
/**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
boundariesElement:"viewport",
/**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
flipVariations:!1,
/**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
flipVariationsByContent:!1},
/**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
inner:{
/** @prop {number} order=700 - Index used to define the order of execution */
order:700,
/** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
enabled:!1,
/** @prop {ModifierFn} */
fn:inner$2},
/**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
hide:{
/** @prop {number} order=800 - Index used to define the order of execution */
order:800,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:hide$2},
/**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
computeStyle:{
/** @prop {number} order=850 - Index used to define the order of execution */
order:850,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:computeStyle$2,
/**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
gpuAcceleration:!0,
/**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
x:"bottom",
/**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
y:"right"},
/**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
applyStyle:{
/** @prop {number} order=900 - Index used to define the order of execution */
order:900,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:applyStyle$2,
/** @prop {Function} */
onLoad:applyStyleOnLoad$2,
/**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
gpuAcceleration:void 0}},Defaults$2={
/**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
placement:"bottom",
/**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
positionFixed:!1,
/**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
eventsEnabled:!0,
/**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
removeOnDestroy:!1,
/**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
onCreate:function(){},
/**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
onUpdate:function(){},
/**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
modifiers:modifiers$3},Popper$3=function(){
/**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
function Popper(reference,popper){var _this=this,options=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};classCallCheck$2(this,Popper),this.scheduleUpdate=function(){return requestAnimationFrame(_this.update)},
// make update() debounced, so that it only runs at most once-per-tick
this.update=debounce$3(this.update.bind(this)),
// with {} we create a new object with the options inside it
this.options=_extends$4({},Popper.Defaults,options),
// init state
this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},
// get reference and popper elements (allow jQuery wrappers)
this.reference=reference&&reference.jquery?reference[0]:reference,this.popper=popper&&popper.jquery?popper[0]:popper,
// Deep merge modifiers options
this.options.modifiers={},Object.keys(_extends$4({},Popper.Defaults.modifiers,options.modifiers)).forEach((function(name){_this.options.modifiers[name]=_extends$4({},Popper.Defaults.modifiers[name]||{},options.modifiers?options.modifiers[name]:{})})),
// Refactoring modifiers' list (Object => Array)
this.modifiers=Object.keys(this.options.modifiers).map((function(name){return _extends$4({name:name},_this.options.modifiers[name])})).sort((function(a,b){return a.order-b.order})),
// modifiers have the ability to execute arbitrary code when Popper.js get inited
// such code is executed in the same order of its modifier
// they could add new properties to their options configuration
// BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
this.modifiers.forEach((function(modifierOptions){modifierOptions.enabled&&isFunction$3(modifierOptions.onLoad)&&modifierOptions.onLoad(_this.reference,_this.popper,_this.options,modifierOptions,_this.state)})),
// fire the first update to position the popper in the right place
this.update();var eventsEnabled=this.options.eventsEnabled;eventsEnabled&&
// setup event listeners, they will take care of update the position in specific situations
this.enableEventListeners(),this.state.eventsEnabled=eventsEnabled}
// We can't use class properties because they don't get listed in the
// class prototype and break stuff like Sinon stubs
return createClass$2(Popper,[{key:"update",value:function(){return update$2.call(this)}},{key:"destroy",value:function(){return destroy$2.call(this)}},{key:"enableEventListeners",value:function(){return enableEventListeners$2.call(this)}},{key:"disableEventListeners",value:function(){return disableEventListeners$2.call(this)}
/**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */
/**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */}]),Popper}();
/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */
/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */
Popper$3.Utils=("undefined"!==typeof window?window:global).PopperUtils,Popper$3.placements=placements$2,Popper$3.Defaults=Defaults$2;
/**!
* tippy.js v4.3.5
* (c) 2017-2019 atomiks
* MIT License
*/
var css$1='.tippy-iOS{cursor:pointer!important;-webkit-tap-highlight-color:transparent}.tippy-popper{transition-timing-function:cubic-bezier(.165,.84,.44,1);max-width:calc(100% - 8px);pointer-events:none;outline:0}.tippy-popper[x-placement^=top] .tippy-backdrop{border-radius:40% 40% 0 0}.tippy-popper[x-placement^=top] .tippy-roundarrow{bottom:-7px;bottom:-6.5px;-webkit-transform-origin:50% 0;transform-origin:50% 0;margin:0 3px}.tippy-popper[x-placement^=top] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(180deg);transform:rotate(180deg)}.tippy-popper[x-placement^=top] .tippy-arrow{border-top:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;bottom:-7px;margin:0 3px;-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=top] .tippy-backdrop{-webkit-transform-origin:0 25%;transform-origin:0 25%}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-55%);transform:scale(1) translate(-50%,-55%)}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%,-45%);transform:scale(.2) translate(-50%,-45%);opacity:0}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(-20px);transform:translateY(-20px)}.tippy-popper[x-placement^=top] [data-animation=perspective]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(-10px);transform:perspective(700px) translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateX(60deg);transform:perspective(700px) rotateX(60deg)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=top] [data-animation=scale]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px) scale(.5);transform:translateY(-10px) scale(.5)}.tippy-popper[x-placement^=bottom] .tippy-backdrop{border-radius:0 0 30% 30%}.tippy-popper[x-placement^=bottom] .tippy-roundarrow{top:-7px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%;margin:0 3px}.tippy-popper[x-placement^=bottom] .tippy-roundarrow svg{position:absolute;left:0}.tippy-popper[x-placement^=bottom] .tippy-arrow{border-bottom:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;top:-7px;margin:0 3px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%}.tippy-popper[x-placement^=bottom] .tippy-backdrop{-webkit-transform-origin:0 -50%;transform-origin:0 -50%}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-45%);transform:scale(1) translate(-50%,-45%)}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%);transform:scale(.2) translate(-50%);opacity:0}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(20px);transform:translateY(20px)}.tippy-popper[x-placement^=bottom] [data-animation=perspective]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(10px);transform:perspective(700px) translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateX(-60deg);transform:perspective(700px) rotateX(-60deg)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=bottom] [data-animation=scale]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px) scale(.5);transform:translateY(10px) scale(.5)}.tippy-popper[x-placement^=left] .tippy-backdrop{border-radius:50% 0 0 50%}.tippy-popper[x-placement^=left] .tippy-roundarrow{right:-12px;-webkit-transform-origin:33.33333333% 50%;transform-origin:33.33333333% 50%;margin:3px 0}.tippy-popper[x-placement^=left] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(90deg);transform:rotate(90deg)}.tippy-popper[x-placement^=left] .tippy-arrow{border-left:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;right:-7px;margin:3px 0;-webkit-transform-origin:0 50%;transform-origin:0 50%}.tippy-popper[x-placement^=left] .tippy-backdrop{-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-75%,-50%);transform:scale(.2) translate(-75%,-50%);opacity:0}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(-20px);transform:translateX(-20px)}.tippy-popper[x-placement^=left] [data-animation=perspective]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(-10px);transform:perspective(700px) translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateY(-60deg);transform:perspective(700px) rotateY(-60deg)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=left] [data-animation=scale]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px) scale(.5);transform:translateX(-10px) scale(.5)}.tippy-popper[x-placement^=right] .tippy-backdrop{border-radius:0 50% 50% 0}.tippy-popper[x-placement^=right] .tippy-roundarrow{left:-12px;-webkit-transform-origin:66.66666666% 50%;transform-origin:66.66666666% 50%;margin:3px 0}.tippy-popper[x-placement^=right] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.tippy-popper[x-placement^=right] .tippy-arrow{border-right:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;left:-7px;margin:3px 0;-webkit-transform-origin:100% 50%;transform-origin:100% 50%}.tippy-popper[x-placement^=right] .tippy-backdrop{-webkit-transform-origin:-50% 0;transform-origin:-50% 0}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-25%,-50%);transform:scale(.2) translate(-25%,-50%);opacity:0}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(20px);transform:translateX(20px)}.tippy-popper[x-placement^=right] [data-animation=perspective]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(10px);transform:perspective(700px) translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateY(60deg);transform:perspective(700px) rotateY(60deg)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=right] [data-animation=scale]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px) scale(.5);transform:translateX(10px) scale(.5)}.tippy-tooltip{position:relative;color:#fff;border-radius:.25rem;font-size:.875rem;padding:.3125rem .5625rem;line-height:1.4;text-align:center;background-color:#333}.tippy-tooltip[data-size=small]{padding:.1875rem .375rem;font-size:.75rem}.tippy-tooltip[data-size=large]{padding:.375rem .75rem;font-size:1rem}.tippy-tooltip[data-animatefill]{overflow:hidden;background-color:initial}.tippy-tooltip[data-interactive],.tippy-tooltip[data-interactive] .tippy-roundarrow path{pointer-events:auto}.tippy-tooltip[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-tooltip[data-inertia][data-state=hidden]{transition-timing-function:ease}.tippy-arrow,.tippy-roundarrow{position:absolute;width:0;height:0}.tippy-roundarrow{width:18px;height:7px;fill:#333;pointer-events:none}.tippy-backdrop{position:absolute;background-color:#333;border-radius:50%;width:calc(110% + 2rem);left:50%;top:50%;z-index:-1;transition:all cubic-bezier(.46,.1,.52,.98);-webkit-backface-visibility:hidden;backface-visibility:hidden}.tippy-backdrop:after{content:"";float:left;padding-top:100%}.tippy-backdrop+.tippy-content{transition-property:opacity;will-change:opacity}.tippy-backdrop+.tippy-content[data-state=hidden]{opacity:0}';function _extends$1$1(){return _extends$1$1=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},_extends$1$1.apply(this,arguments)}var version$1="4.3.5",isBrowser$1$1="undefined"!==typeof window&&"undefined"!==typeof document,ua$1=isBrowser$1$1?navigator.userAgent:"",isIE$1$1=/MSIE |Trident\//.test(ua$1),isUCBrowser$1=/UCBrowser\//.test(ua$1),isIOS$2=isBrowser$1$1&&/iPhone|iPad|iPod/.test(navigator.platform)&&!window.MSStream,defaultProps$2={a11y:!0,allowHTML:!0,animateFill:!0,animation:"shift-away",appendTo:function(){return document.body},aria:"describedby",arrow:!1,arrowType:"sharp",boundary:"scrollParent",content:"",delay:0,distance:10,duration:[325,275],flip:!0,flipBehavior:"flip",flipOnUpdate:!1,followCursor:!1,hideOnClick:!0,ignoreAttributes:!1,inertia:!1,interactive:!1,interactiveBorder:2,interactiveDebounce:0,lazy:!0,maxWidth:350,multiple:!1,offset:0,onHidden:function(){},onHide:function(){},onMount:function(){},onShow:function(){},onShown:function(){},onTrigger:function(){},placement:"top",popperOptions:{},role:"tooltip",showOnInit:!1,size:"regular",sticky:!1,target:"",theme:"dark",touch:!0,touchHold:!1,trigger:"mouseenter focus",triggerTarget:null,updateDuration:0,wait:null,zIndex:9999
/**
   * If the set() method encounters one of these, the popperInstance must be
   * recreated
   */},POPPER_INSTANCE_DEPENDENCIES$1=["arrow","arrowType","boundary","distance","flip","flipBehavior","flipOnUpdate","offset","placement","popperOptions"],elementProto$1=isBrowser$1$1?Element.prototype:{},matches$2=elementProto$1.matches||elementProto$1.matchesSelector||elementProto$1.webkitMatchesSelector||elementProto$1.mozMatchesSelector||elementProto$1.msMatchesSelector;
/**
 * Ponyfill for Array.from - converts iterable values to an array
 */
function arrayFrom$1(value){return[].slice.call(value)}
/**
 * Ponyfill for Element.prototype.closest
 */function closest$1(element,selector){return closestCallback$1(element,(function(el){return matches$2.call(el,selector)}))}
/**
 * Works like Element.prototype.closest, but uses a callback instead
 */function closestCallback$1(element,callback){while(element){if(callback(element))return element;element=element.parentElement}return null}
// Passive event listener config
var PASSIVE$1={passive:!0},PADDING$1=4,PLACEMENT_ATTRIBUTE$1="x-placement",OUT_OF_BOUNDARIES_ATTRIBUTE$1="x-out-of-boundaries",IOS_CLASS$1="tippy-iOS",ACTIVE_CLASS$1="tippy-active",POPPER_CLASS$1="tippy-popper",TOOLTIP_CLASS$1="tippy-tooltip",CONTENT_CLASS$1="tippy-content",BACKDROP_CLASS$1="tippy-backdrop",ARROW_CLASS$1="tippy-arrow",ROUND_ARROW_CLASS$1="tippy-roundarrow",POPPER_SELECTOR$1=".".concat(POPPER_CLASS$1),TOOLTIP_SELECTOR$1=".".concat(TOOLTIP_CLASS$1),CONTENT_SELECTOR$1=".".concat(CONTENT_CLASS$1),BACKDROP_SELECTOR$1=".".concat(BACKDROP_CLASS$1),ARROW_SELECTOR$1=".".concat(ARROW_CLASS$1),ROUND_ARROW_SELECTOR$1=".".concat(ROUND_ARROW_CLASS$1),isUsingTouch$1=!1;function onDocumentTouch$1(){isUsingTouch$1||(isUsingTouch$1=!0,isIOS$2&&document.body.classList.add(IOS_CLASS$1),window.performance&&document.addEventListener("mousemove",onDocumentMouseMove$1))}var lastMouseMoveTime$1=0;function onDocumentMouseMove$1(){var now=performance.now();// Chrome 60+ is 1 mousemove per animation frame, use 20ms time difference
now-lastMouseMoveTime$1<20&&(isUsingTouch$1=!1,document.removeEventListener("mousemove",onDocumentMouseMove$1),isIOS$2||document.body.classList.remove(IOS_CLASS$1)),lastMouseMoveTime$1=now}function onWindowBlur$1(){var _document=document,activeElement=_document.activeElement;activeElement&&activeElement.blur&&activeElement._tippy&&activeElement.blur()}
/**
 * Adds the needed global event listeners
 */function bindGlobalEventListeners$1(){document.addEventListener("touchstart",onDocumentTouch$1,PASSIVE$1),window.addEventListener("blur",onWindowBlur$1)}var keys$2=Object.keys(defaultProps$2);
/**
 * Returns an object of optional props from data-tippy-* attributes
 */function getDataAttributeOptions$1(reference){return keys$2.reduce((function(acc,key){var valueAsString=(reference.getAttribute("data-tippy-".concat(key))||"").trim();if(!valueAsString)return acc;if("content"===key)acc[key]=valueAsString;else try{acc[key]=JSON.parse(valueAsString)}catch(e){acc[key]=valueAsString}return acc}),{})}
/**
 * Polyfills the virtual reference (plain object) with Element.prototype props
 * Mutating because DOM elements are mutated, adds `_tippy` property
 */function polyfillElementPrototypeProperties$1(virtualReference){var polyfills={isVirtual:!0,attributes:virtualReference.attributes||{},contains:function(){},setAttribute:function(key,value){virtualReference.attributes[key]=value},getAttribute:function(key){return virtualReference.attributes[key]},removeAttribute:function(key){delete virtualReference.attributes[key]},hasAttribute:function(key){return key in virtualReference.attributes},addEventListener:function(){},removeEventListener:function(){},classList:{classNames:{},add:function(key){virtualReference.classList.classNames[key]=!0},remove:function(key){delete virtualReference.classList.classNames[key]},contains:function(key){return key in virtualReference.classList.classNames}}};for(var key in polyfills)virtualReference[key]=polyfills[key]}
/**
 * Determines if a value is a "bare" virtual element (before mutations done
 * by `polyfillElementPrototypeProperties()`). JSDOM elements show up as
 * [object Object], we can check if the value is "element-like" if it has
 * `addEventListener`
 */function isBareVirtualElement$1(value){return"[object Object]"==={}.toString.call(value)&&!value.addEventListener}
/**
 * Determines if the value is a reference element
 */function isReferenceElement$1(value){return!!value._tippy&&!matches$2.call(value,POPPER_SELECTOR$1)}
/**
 * Safe .hasOwnProperty check, for prototype-less objects
 */function hasOwnProperty$2(obj,key){return{}.hasOwnProperty.call(obj,key)}
/**
 * Returns an array of elements based on the value
 */function getArrayOfElements$1(value){if(isSingular$1(value))
// TODO: VirtualReference is not compatible to type Element
return[value];if(value instanceof NodeList)return arrayFrom$1(value);if(Array.isArray(value))return value;try{return arrayFrom$1(document.querySelectorAll(value))}catch(e){return[]}}
/**
 * Returns a value at a given index depending on if it's an array or number
 */function getValue$2(value,index,defaultValue){if(Array.isArray(value)){var v=value[index];return null==v?defaultValue:v}return value}
/**
 * Debounce utility. To avoid bloating bundle size, we're only passing 1
 * argument here, a more generic function would pass all arguments. Only
 * `onMouseMove` uses this which takes the event object for now.
 */function debounce$1$1(fn,ms){
// Avoid wrapping in `setTimeout` if ms is 0 anyway
return 0===ms?fn:function(arg){clearTimeout(timeout),timeout=setTimeout((function(){fn(arg)}),ms)};var timeout}
/**
 * Prevents errors from being thrown while accessing nested modifier objects
 * in `popperOptions`
 */function getModifier$1(obj,key){return obj&&obj.modifiers&&obj.modifiers[key]}
/**
 * Determines if an array or string includes a value
 */function includes$1(a,b){return a.indexOf(b)>-1}
/**
 * Determines if the value is a real element
 */function isRealElement$1(value){return value instanceof Element}
/**
 * Determines if the value is singular-like
 */function isSingular$1(value){return!(!value||!hasOwnProperty$2(value,"isVirtual"))||isRealElement$1(value)}
/**
 * Firefox extensions don't allow setting .innerHTML directly, this will trick it
 */function innerHTML$1(){return"innerHTML"}
/**
 * Evaluates a function if one, or returns the value
 */function invokeWithArgsOrReturn$1(value,args){return"function"===typeof value?value.apply(null,args):value}
/**
 * Sets a popperInstance `flip` modifier's enabled state
 */function setFlipModifierEnabled$1(modifiers,value){modifiers.filter((function(m){return"flip"===m.name}))[0].enabled=value}
/**
 * Determines if an element can receive focus
 * Always returns true for virtual objects
 */function canReceiveFocus$1(element){return!isRealElement$1(element)||matches$2.call(element,"a[href],area[href],button,details,input,textarea,select,iframe,[tabindex]")&&!element.hasAttribute("disabled")}
/**
 * Returns a new `div` element
 */function div$1(){return document.createElement("div")}
/**
 * Applies a transition duration to a list of elements
 */function setTransitionDuration$1(els,value){els.forEach((function(el){el&&(el.style.transitionDuration="".concat(value,"ms"))}))}
/**
 * Sets the visibility state to elements so they can begin to transition
 */function setVisibilityState$1(els,state){els.forEach((function(el){el&&el.setAttribute("data-state",state)}))}
/**
 * Evaluates the props object by merging data attributes and
 * disabling conflicting options where necessary
 */function evaluateProps$1(reference,props){var out=_extends$1$1({},props,{content:invokeWithArgsOrReturn$1(props.content,[reference])},props.ignoreAttributes?{}:getDataAttributeOptions$1(reference));return(out.arrow||isUCBrowser$1)&&(out.animateFill=!1),out}
/**
 * Validates an object of options with the valid default props object
 */function validateOptions$1(options,defaultProps){Object.keys(options).forEach((function(option){if(!hasOwnProperty$2(defaultProps,option))throw new Error("[tippy]: `".concat(option,"` is not a valid option"))}))}
/**
 * Sets the innerHTML of an element
 */function setInnerHTML$1(element,html){element[innerHTML$1()]=isRealElement$1(html)?html[innerHTML$1()]:html}
/**
 * Sets the content of a tooltip
 */function setContent$2(contentEl,props){if(isRealElement$1(props.content))setInnerHTML$1(contentEl,""),contentEl.appendChild(props.content);else if("function"!==typeof props.content){var key=props.allowHTML?"innerHTML":"textContent";contentEl[key]=props.content}}
/**
 * Returns the child elements of a popper element
 */function getChildren$1(popper){return{tooltip:popper.querySelector(TOOLTIP_SELECTOR$1),backdrop:popper.querySelector(BACKDROP_SELECTOR$1),content:popper.querySelector(CONTENT_SELECTOR$1),arrow:popper.querySelector(ARROW_SELECTOR$1)||popper.querySelector(ROUND_ARROW_SELECTOR$1)}}
/**
 * Adds `data-inertia` attribute
 */function addInertia$1(tooltip){tooltip.setAttribute("data-inertia","")}
/**
 * Removes `data-inertia` attribute
 */function removeInertia$1(tooltip){tooltip.removeAttribute("data-inertia")}
/**
 * Creates an arrow element and returns it
 */function createArrowElement$1(arrowType){var arrow=div$1();return"round"===arrowType?(arrow.className=ROUND_ARROW_CLASS$1,setInnerHTML$1(arrow,'<svg viewBox="0 0 18 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z"/></svg>')):arrow.className=ARROW_CLASS$1,arrow}
/**
 * Creates a backdrop element and returns it
 */function createBackdropElement$1(){var backdrop=div$1();return backdrop.className=BACKDROP_CLASS$1,backdrop.setAttribute("data-state","hidden"),backdrop}
/**
 * Adds interactive-related attributes
 */function addInteractive$1(popper,tooltip){popper.setAttribute("tabindex","-1"),tooltip.setAttribute("data-interactive","")}
/**
 * Removes interactive-related attributes
 */function removeInteractive$1(popper,tooltip){popper.removeAttribute("tabindex"),tooltip.removeAttribute("data-interactive")}
/**
 * Add/remove transitionend listener from tooltip
 */function updateTransitionEndListener$1(tooltip,action,listener){
// UC Browser hasn't adopted the `transitionend` event despite supporting
// unprefixed transitions...
var eventName=isUCBrowser$1&&void 0!==document.body.style.webkitTransition?"webkitTransitionEnd":"transitionend";tooltip[action+"EventListener"](eventName,listener)}
/**
 * Returns the popper's placement, ignoring shifting (top-start, etc)
 */function getBasicPlacement$1(popper){var fullPlacement=popper.getAttribute(PLACEMENT_ATTRIBUTE$1);return fullPlacement?fullPlacement.split("-")[0]:""}
/**
 * Triggers reflow
 */function reflow$1(popper){popper.offsetHeight}
/**
 * Adds/removes theme from tooltip's classList
 */function updateTheme$1(tooltip,action,theme){theme.split(" ").forEach((function(themeName){tooltip.classList[action](themeName+"-theme")}))}
/**
 * Constructs the popper element and returns it
 */function createPopperElement$1(id,props){var popper=div$1();popper.className=POPPER_CLASS$1,popper.id="tippy-".concat(id),popper.style.zIndex=""+props.zIndex,popper.style.position="absolute",popper.style.top="0",popper.style.left="0",props.role&&popper.setAttribute("role",props.role);var tooltip=div$1();tooltip.className=TOOLTIP_CLASS$1,tooltip.style.maxWidth=props.maxWidth+("number"===typeof props.maxWidth?"px":""),tooltip.setAttribute("data-size",props.size),tooltip.setAttribute("data-animation",props.animation),tooltip.setAttribute("data-state","hidden"),updateTheme$1(tooltip,"add",props.theme);var content=div$1();return content.className=CONTENT_CLASS$1,content.setAttribute("data-state","hidden"),props.interactive&&addInteractive$1(popper,tooltip),props.arrow&&tooltip.appendChild(createArrowElement$1(props.arrowType)),props.animateFill&&(tooltip.appendChild(createBackdropElement$1()),tooltip.setAttribute("data-animatefill","")),props.inertia&&addInertia$1(tooltip),setContent$2(content,props),tooltip.appendChild(content),popper.appendChild(tooltip),popper}
/**
 * Updates the popper element based on the new props
 */function updatePopperElement$1(popper,prevProps,nextProps){var _getChildren=getChildren$1(popper),tooltip=_getChildren.tooltip,content=_getChildren.content,backdrop=_getChildren.backdrop,arrow=_getChildren.arrow;popper.style.zIndex=""+nextProps.zIndex,tooltip.setAttribute("data-size",nextProps.size),tooltip.setAttribute("data-animation",nextProps.animation),tooltip.style.maxWidth=nextProps.maxWidth+("number"===typeof nextProps.maxWidth?"px":""),nextProps.role?popper.setAttribute("role",nextProps.role):popper.removeAttribute("role"),prevProps.content!==nextProps.content&&setContent$2(content,nextProps),// animateFill
!prevProps.animateFill&&nextProps.animateFill?(tooltip.appendChild(createBackdropElement$1()),tooltip.setAttribute("data-animatefill","")):prevProps.animateFill&&!nextProps.animateFill&&(tooltip.removeChild(backdrop),tooltip.removeAttribute("data-animatefill")),// arrow
!prevProps.arrow&&nextProps.arrow?tooltip.appendChild(createArrowElement$1(nextProps.arrowType)):prevProps.arrow&&!nextProps.arrow&&tooltip.removeChild(arrow),// arrowType
prevProps.arrow&&nextProps.arrow&&prevProps.arrowType!==nextProps.arrowType&&tooltip.replaceChild(createArrowElement$1(nextProps.arrowType),arrow),// interactive
!prevProps.interactive&&nextProps.interactive?addInteractive$1(popper,tooltip):prevProps.interactive&&!nextProps.interactive&&removeInteractive$1(popper,tooltip),// inertia
!prevProps.inertia&&nextProps.inertia?addInertia$1(tooltip):prevProps.inertia&&!nextProps.inertia&&removeInertia$1(tooltip),// theme
prevProps.theme!==nextProps.theme&&(updateTheme$1(tooltip,"remove",prevProps.theme),updateTheme$1(tooltip,"add",nextProps.theme))}
/**
 * Hides all visible poppers on the document
 */function hideAll$1(){var _ref=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},excludedReferenceOrInstance=_ref.exclude,duration=_ref.duration;arrayFrom$1(document.querySelectorAll(POPPER_SELECTOR$1)).forEach((function(popper){var instance=popper._tippy;if(instance){var isExcluded=!1;excludedReferenceOrInstance&&(isExcluded=isReferenceElement$1(excludedReferenceOrInstance)?instance.reference===excludedReferenceOrInstance:popper===excludedReferenceOrInstance.popper),isExcluded||instance.hide(duration)}}))}
/**
 * Determines if the mouse cursor is outside of the popper's interactive border
 * region
 */function isCursorOutsideInteractiveBorder$1(popperPlacement,popperRect,event,props){if(!popperPlacement)return!0;var x=event.clientX,y=event.clientY,interactiveBorder=props.interactiveBorder,distance=props.distance,exceedsTop=popperRect.top-y>("top"===popperPlacement?interactiveBorder+distance:interactiveBorder),exceedsBottom=y-popperRect.bottom>("bottom"===popperPlacement?interactiveBorder+distance:interactiveBorder),exceedsLeft=popperRect.left-x>("left"===popperPlacement?interactiveBorder+distance:interactiveBorder),exceedsRight=x-popperRect.right>("right"===popperPlacement?interactiveBorder+distance:interactiveBorder);return exceedsTop||exceedsBottom||exceedsLeft||exceedsRight}
/**
 * Returns the distance offset, taking into account the default offset due to
 * the transform: translate() rule (10px) in CSS
 */function getOffsetDistanceInPx$1(distance){return-(distance-10)+"px"}var idCounter$1=1,mouseMoveListeners$1=[];// Workaround for IE11's lack of new MouseEvent constructor
/**
 * Creates and returns a Tippy object. We're using a closure pattern instead of
 * a class so that the exposed object API is clean without private members
 * prefixed with `_`.
 */
function createTippy$1(reference,collectionProps){var lastTriggerEventType,lastMouseMoveEvent,showTimeoutId,hideTimeoutId,scheduleHideAnimationFrameId,props=evaluateProps$1(reference,collectionProps);// If the reference shouldn't have multiple tippys, return null early
if(!props.multiple&&reference._tippy)return null;
/* ======================= 🔒 Private members 🔒 ======================= */var previousPlacement,currentMountCallback,currentTransitionEndListener,currentComputedPadding,isScheduledToShow=!1,isBeingDestroyed=!1,wasVisibleDuringPreviousUpdate=!1,hasMountCallbackRun=!1,listeners=[],debouncedOnMouseMove=debounce$1$1(onMouseMove,props.interactiveDebounce),id=idCounter$1++,popper=createPopperElement$1(id,props),popperChildren=getChildren$1(popper),popperInstance=null,state={
// Is the instance currently enabled?
isEnabled:!0,
// Is the tippy currently showing and not transitioning out?
isVisible:!1,
// Has the instance been destroyed?
isDestroyed:!1,
// Is the tippy currently mounted to the DOM?
isMounted:!1,
// Has the tippy finished transitioning in?
isShown:!1},instance={
// properties
id:id,reference:reference,popper:popper,popperChildren:popperChildren,popperInstance:popperInstance,props:props,state:state,
// methods
clearDelayTimeouts:clearDelayTimeouts,set:set,setContent:setContent,show:show,hide:hide,enable:enable,disable:disable,destroy:destroy
/* ==================== Initial instance mutations =================== */};return reference._tippy=instance,popper._tippy=instance,addTriggersToReference(),props.lazy||createPopperInstance(),props.showOnInit&&scheduleShow(),// Ensure the event listeners target can receive focus
!props.a11y||props.target||canReceiveFocus$1(getEventListenersTarget())||getEventListenersTarget().setAttribute("tabindex","0"),// Prevent a tippy with a delay from hiding if the cursor left then returned
// before it started hiding
popper.addEventListener("mouseenter",(function(event){instance.props.interactive&&instance.state.isVisible&&"mouseenter"===lastTriggerEventType&&
// We don't want props.onTrigger() to be called here, since the `event`
// object is not related to the reference element
scheduleShow(event,!0)})),popper.addEventListener("mouseleave",(function(){instance.props.interactive&&"mouseenter"===lastTriggerEventType&&document.addEventListener("mousemove",debouncedOnMouseMove)})),instance;
/* ======================= 🔒 Private methods 🔒 ======================= */
/**
   * Removes the follow cursor listener
   */function removeFollowCursorListener(){document.removeEventListener("mousemove",positionVirtualReferenceNearCursor)}
/**
   * Cleans up interactive mouse listeners
   */function cleanupInteractiveMouseListeners(){document.body.removeEventListener("mouseleave",scheduleHide),document.removeEventListener("mousemove",debouncedOnMouseMove),mouseMoveListeners$1=mouseMoveListeners$1.filter((function(listener){return listener!==debouncedOnMouseMove}))}
/**
   * Returns correct target used for event listeners
   */function getEventListenersTarget(){return instance.props.triggerTarget||reference}
/**
   * Adds the document click event listener for the instance
   */function addDocumentClickListener(){document.addEventListener("click",onDocumentClick,!0)}
/**
   * Removes the document click event listener for the instance
   */function removeDocumentClickListener(){document.removeEventListener("click",onDocumentClick,!0)}
/**
   * Returns transitionable inner elements used in show/hide methods
   */function getTransitionableElements(){return[instance.popperChildren.tooltip,instance.popperChildren.backdrop,instance.popperChildren.content]}
/**
   * Determines if the instance is in `followCursor` mode.
   * NOTE: in v5, touch devices will use `initial` behavior no matter the value.
   */function getIsInLooseFollowCursorMode(){var followCursor=instance.props.followCursor;return followCursor&&"focus"!==lastTriggerEventType||isUsingTouch$1&&"initial"===followCursor}
/**
   * Updates the tooltip's position on each animation frame
   */function makeSticky(){setTransitionDuration$1([popper],isIE$1$1?0:instance.props.updateDuration);var prevRefRect=reference.getBoundingClientRect();function updatePosition(){var currentRefRect=reference.getBoundingClientRect();// Only schedule an update if the reference rect has changed
prevRefRect.top===currentRefRect.top&&prevRefRect.right===currentRefRect.right&&prevRefRect.bottom===currentRefRect.bottom&&prevRefRect.left===currentRefRect.left||instance.popperInstance.scheduleUpdate(),prevRefRect=currentRefRect,instance.state.isMounted&&requestAnimationFrame(updatePosition)}updatePosition()}
/**
   * Invokes a callback once the tooltip has fully transitioned out
   */function onTransitionedOut(duration,callback){onTransitionEnd(duration,(function(){!instance.state.isVisible&&popper.parentNode&&popper.parentNode.contains(popper)&&callback()}))}
/**
   * Invokes a callback once the tooltip has fully transitioned in
   */function onTransitionedIn(duration,callback){onTransitionEnd(duration,callback)}
/**
   * Invokes a callback once the tooltip's CSS transition ends
   */function onTransitionEnd(duration,callback){var tooltip=instance.popperChildren.tooltip;
/**
     * Listener added as the `transitionend` handler
     */function listener(event){event.target===tooltip&&(updateTransitionEndListener$1(tooltip,"remove",listener),callback())}// Make callback synchronous if duration is 0
// `transitionend` won't fire otherwise
if(0===duration)return callback();updateTransitionEndListener$1(tooltip,"remove",currentTransitionEndListener),updateTransitionEndListener$1(tooltip,"add",listener),currentTransitionEndListener=listener}
/**
   * Adds an event listener to the reference and stores it in `listeners`
   */function on(eventType,handler){var options=arguments.length>2&&void 0!==arguments[2]&&arguments[2];getEventListenersTarget().addEventListener(eventType,handler,options),listeners.push({eventType:eventType,handler:handler,options:options})}
/**
   * Adds event listeners to the reference based on the `trigger` prop
   */function addTriggersToReference(){instance.props.touchHold&&!instance.props.target&&(on("touchstart",onTrigger,PASSIVE$1),on("touchend",onMouseLeave,PASSIVE$1)),instance.props.trigger.trim().split(" ").forEach((function(eventType){if("manual"!==eventType)// Non-delegates
if(instance.props.target)
// Delegates
switch(eventType){case"mouseenter":on("mouseover",onDelegateShow),on("mouseout",onDelegateHide);break;case"focus":on("focusin",onDelegateShow),on("focusout",onDelegateHide);break;case"click":on(eventType,onDelegateShow);break}else switch(on(eventType,onTrigger),eventType){case"mouseenter":on("mouseleave",onMouseLeave);break;case"focus":on(isIE$1$1?"focusout":"blur",onBlur);break}}))}
/**
   * Removes event listeners from the reference
   */function removeTriggersFromReference(){listeners.forEach((function(_ref){var eventType=_ref.eventType,handler=_ref.handler,options=_ref.options;getEventListenersTarget().removeEventListener(eventType,handler,options)})),listeners=[]}
/**
   * Positions the virtual reference near the cursor
   */function positionVirtualReferenceNearCursor(event){var _lastMouseMoveEvent=lastMouseMoveEvent=event,x=_lastMouseMoveEvent.clientX,y=_lastMouseMoveEvent.clientY;// Gets set once popperInstance `onCreate` has been called
if(currentComputedPadding){// If the instance is interactive, avoid updating the position unless it's
// over the reference element
var isCursorOverReference=closestCallback$1(event.target,(function(el){return el===reference})),rect=reference.getBoundingClientRect(),followCursor=instance.props.followCursor,isHorizontal="horizontal"===followCursor,isVertical="vertical"===followCursor,isVerticalPlacement=includes$1(["top","bottom"],getBasicPlacement$1(popper)),fullPlacement=popper.getAttribute(PLACEMENT_ATTRIBUTE$1),isVariation=!!fullPlacement&&!!fullPlacement.split("-")[1],size=isVerticalPlacement?popper.offsetWidth:popper.offsetHeight,halfSize=size/2,verticalIncrease=isVerticalPlacement?0:isVariation?size:halfSize,horizontalIncrease=isVerticalPlacement?isVariation?size:halfSize:0;!isCursorOverReference&&instance.props.interactive||(instance.popperInstance.reference=_extends$1$1({},instance.popperInstance.reference,{
// This will exist in next Popper.js feature release to fix #532
// @ts-ignore
referenceNode:reference,
// These `client` values don't get used by Popper.js if they are 0
clientWidth:0,clientHeight:0,getBoundingClientRect:function(){return{width:isVerticalPlacement?size:0,height:isVerticalPlacement?0:size,top:(isHorizontal?rect.top:y)-verticalIncrease,bottom:(isHorizontal?rect.bottom:y)+verticalIncrease,left:(isVertical?rect.left:x)-horizontalIncrease,right:(isVertical?rect.right:x)+horizontalIncrease}}}),instance.popperInstance.update()),"initial"===followCursor&&instance.state.isVisible&&removeFollowCursorListener()}}
/**
   * Creates the tippy instance for a delegate when it's been triggered
   */function createDelegateChildTippy(event){if(event){var targetEl=closest$1(event.target,instance.props.target);targetEl&&!targetEl._tippy&&createTippy$1(targetEl,_extends$1$1({},instance.props,{content:invokeWithArgsOrReturn$1(collectionProps.content,[targetEl]),appendTo:collectionProps.appendTo,target:"",showOnInit:!0}))}}
/**
   * Event listener invoked upon trigger
   */function onTrigger(event){instance.state.isEnabled&&!isEventListenerStopped(event)&&(instance.state.isVisible||(lastTriggerEventType=event.type,event instanceof MouseEvent&&(lastMouseMoveEvent=event,// If scrolling, `mouseenter` events can be fired if the cursor lands
// over a new target, but `mousemove` events don't get fired. This
// causes interactive tooltips to get stuck open until the cursor is
// moved
mouseMoveListeners$1.forEach((function(listener){return listener(event)})))),// Toggle show/hide when clicking click-triggered tooltips
"click"===event.type&&!1!==instance.props.hideOnClick&&instance.state.isVisible?scheduleHide():scheduleShow(event))}
/**
   * Event listener used for interactive tooltips to detect when they should
   * hide
   */function onMouseMove(event){var isCursorOverPopper=closest$1(event.target,POPPER_SELECTOR$1)===popper,isCursorOverReference=closestCallback$1(event.target,(function(el){return el===reference}));isCursorOverPopper||isCursorOverReference||isCursorOutsideInteractiveBorder$1(getBasicPlacement$1(popper),popper.getBoundingClientRect(),event,instance.props)&&(cleanupInteractiveMouseListeners(),scheduleHide())}
/**
   * Event listener invoked upon mouseleave
   */function onMouseLeave(event){if(!isEventListenerStopped(event))return instance.props.interactive?(document.body.addEventListener("mouseleave",scheduleHide),document.addEventListener("mousemove",debouncedOnMouseMove),void mouseMoveListeners$1.push(debouncedOnMouseMove)):void scheduleHide()}
/**
   * Event listener invoked upon blur
   */function onBlur(event){event.target===getEventListenersTarget()&&(instance.props.interactive&&event.relatedTarget&&popper.contains(event.relatedTarget)||scheduleHide())}
/**
   * Event listener invoked when a child target is triggered
   */function onDelegateShow(event){closest$1(event.target,instance.props.target)&&scheduleShow(event)}
/**
   * Event listener invoked when a child target should hide
   */function onDelegateHide(event){closest$1(event.target,instance.props.target)&&scheduleHide()}
/**
   * Determines if an event listener should stop further execution due to the
   * `touchHold` option
   */function isEventListenerStopped(event){var supportsTouch="ontouchstart"in window,isTouchEvent=includes$1(event.type,"touch"),touchHold=instance.props.touchHold;return supportsTouch&&isUsingTouch$1&&touchHold&&!isTouchEvent||isUsingTouch$1&&!touchHold&&isTouchEvent}
/**
   * Runs the mount callback
   */function runMountCallback(){!hasMountCallbackRun&&currentMountCallback&&(hasMountCallbackRun=!0,reflow$1(popper),currentMountCallback())}
/**
   * Creates the popper instance for the instance
   */function createPopperInstance(){var popperOptions=instance.props.popperOptions,_instance$popperChild=instance.popperChildren,tooltip=_instance$popperChild.tooltip,arrow=_instance$popperChild.arrow,preventOverflowModifier=getModifier$1(popperOptions,"preventOverflow");function applyMutations(data){instance.props.flip&&!instance.props.flipOnUpdate&&(data.flipped&&(instance.popperInstance.options.placement=data.placement),setFlipModifierEnabled$1(instance.popperInstance.modifiers,!1)),// Apply all of the popper's attributes to the tootip node as well.
// Allows users to avoid using the .tippy-popper selector for themes.
tooltip.setAttribute(PLACEMENT_ATTRIBUTE$1,data.placement),!1!==data.attributes[OUT_OF_BOUNDARIES_ATTRIBUTE$1]?tooltip.setAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE$1,""):tooltip.removeAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE$1),// Prevents a transition when changing placements (while tippy is visible)
// for scroll/resize updates
previousPlacement&&previousPlacement!==data.placement&&wasVisibleDuringPreviousUpdate&&(tooltip.style.transition="none",requestAnimationFrame((function(){tooltip.style.transition=""}))),previousPlacement=data.placement,wasVisibleDuringPreviousUpdate=instance.state.isVisible;var basicPlacement=getBasicPlacement$1(popper),styles=tooltip.style;// Account for the `distance` offset
styles.top=styles.bottom=styles.left=styles.right="",styles[basicPlacement]=getOffsetDistanceInPx$1(instance.props.distance);var padding=preventOverflowModifier&&void 0!==preventOverflowModifier.padding?preventOverflowModifier.padding:PADDING$1,isPaddingNumber="number"===typeof padding,computedPadding=_extends$1$1({top:isPaddingNumber?padding:padding.top,bottom:isPaddingNumber?padding:padding.bottom,left:isPaddingNumber?padding:padding.left,right:isPaddingNumber?padding:padding.right},!isPaddingNumber&&padding);computedPadding[basicPlacement]=isPaddingNumber?padding+instance.props.distance:(padding[basicPlacement]||0)+instance.props.distance,instance.popperInstance.modifiers.filter((function(m){return"preventOverflow"===m.name}))[0].padding=computedPadding,currentComputedPadding=computedPadding}var config=_extends$1$1({eventsEnabled:!1,placement:instance.props.placement},popperOptions,{modifiers:_extends$1$1({},popperOptions?popperOptions.modifiers:{},{preventOverflow:_extends$1$1({boundariesElement:instance.props.boundary,padding:PADDING$1},preventOverflowModifier),arrow:_extends$1$1({element:arrow,enabled:!!arrow},getModifier$1(popperOptions,"arrow")),flip:_extends$1$1({enabled:instance.props.flip,
// The tooltip is offset by 10px from the popper in CSS,
// we need to account for its distance
padding:instance.props.distance+PADDING$1,behavior:instance.props.flipBehavior},getModifier$1(popperOptions,"flip")),offset:_extends$1$1({offset:instance.props.offset},getModifier$1(popperOptions,"offset"))}),onCreate:function(data){applyMutations(data),runMountCallback(),popperOptions&&popperOptions.onCreate&&popperOptions.onCreate(data)},onUpdate:function(data){applyMutations(data),runMountCallback(),popperOptions&&popperOptions.onUpdate&&popperOptions.onUpdate(data)}});instance.popperInstance=new Popper$3(reference,popper,config)}
/**
   * Mounts the tooltip to the DOM
   */function mount(){hasMountCallbackRun=!1;var isInLooseFollowCursorMode=getIsInLooseFollowCursorMode();instance.popperInstance?(setFlipModifierEnabled$1(instance.popperInstance.modifiers,instance.props.flip),isInLooseFollowCursorMode||(instance.popperInstance.reference=reference,instance.popperInstance.enableEventListeners()),instance.popperInstance.scheduleUpdate()):(createPopperInstance(),isInLooseFollowCursorMode||instance.popperInstance.enableEventListeners());var appendTo=instance.props.appendTo,parentNode="parent"===appendTo?reference.parentNode:invokeWithArgsOrReturn$1(appendTo,[reference]);parentNode.contains(popper)||(parentNode.appendChild(popper),instance.props.onMount(instance),instance.state.isMounted=!0)}
/**
   * Setup before show() is invoked (delays, etc.)
   */function scheduleShow(event,shouldAvoidCallingOnTrigger){if(clearDelayTimeouts(),!instance.state.isVisible){// Is a delegate, create an instance for the child target
if(instance.props.target)return createDelegateChildTippy(event);if(isScheduledToShow=!0,event&&!shouldAvoidCallingOnTrigger&&instance.props.onTrigger(instance,event),instance.props.wait)return instance.props.wait(instance,event);// If the tooltip has a delay, we need to be listening to the mousemove as
// soon as the trigger event is fired, so that it's in the correct position
// upon mount.
// Edge case: if the tooltip is still mounted, but then scheduleShow() is
// called, it causes a jump.
getIsInLooseFollowCursorMode()&&!instance.state.isMounted&&(instance.popperInstance||createPopperInstance(),document.addEventListener("mousemove",positionVirtualReferenceNearCursor)),addDocumentClickListener();var delay=getValue$2(instance.props.delay,0,defaultProps$2.delay);delay?showTimeoutId=setTimeout((function(){show()}),delay):show()}}
/**
   * Setup before hide() is invoked (delays, etc.)
   */function scheduleHide(){if(clearDelayTimeouts(),!instance.state.isVisible)return removeFollowCursorListener(),void removeDocumentClickListener();isScheduledToShow=!1;var delay=getValue$2(instance.props.delay,1,defaultProps$2.delay);delay?hideTimeoutId=setTimeout((function(){instance.state.isVisible&&hide()}),delay):
// Fixes a `transitionend` problem when it fires 1 frame too
// late sometimes, we don't want hide() to be called.
scheduleHideAnimationFrameId=requestAnimationFrame((function(){hide()}))}
/**
   * Listener to handle clicks on the document to determine if the
   * instance should hide
   */function onDocumentClick(event){
// Clicked on interactive popper
if(!instance.props.interactive||!popper.contains(event.target)){// Clicked on the event listeners target
if(getEventListenersTarget().contains(event.target)){if(isUsingTouch$1)return;if(instance.state.isVisible&&includes$1(instance.props.trigger,"click"))return}!0===instance.props.hideOnClick&&(clearDelayTimeouts(),hide())}}
/* ======================= 🔑 Public methods 🔑 ======================= */
/**
   * Enables the instance to allow it to show or hide
   */function enable(){instance.state.isEnabled=!0}
/**
   * Disables the instance to disallow it to show or hide
   */function disable(){instance.state.isEnabled=!1}
/**
   * Clears pending timeouts related to the `delay` prop if any
   */function clearDelayTimeouts(){clearTimeout(showTimeoutId),clearTimeout(hideTimeoutId),cancelAnimationFrame(scheduleHideAnimationFrameId)}
/**
   * Sets new props for the instance and redraws the tooltip
   */function set(options){
// Backwards-compatible after TypeScript change
options=options||{},validateOptions$1(options,defaultProps$2),removeTriggersFromReference();var prevProps=instance.props,nextProps=evaluateProps$1(reference,_extends$1$1({},instance.props,{},options,{ignoreAttributes:!0}));nextProps.ignoreAttributes=hasOwnProperty$2(options,"ignoreAttributes")?options.ignoreAttributes||!1:prevProps.ignoreAttributes,instance.props=nextProps,addTriggersToReference(),cleanupInteractiveMouseListeners(),debouncedOnMouseMove=debounce$1$1(onMouseMove,nextProps.interactiveDebounce),updatePopperElement$1(popper,prevProps,nextProps),instance.popperChildren=getChildren$1(popper),instance.popperInstance&&(POPPER_INSTANCE_DEPENDENCIES$1.some((function(prop){return hasOwnProperty$2(options,prop)&&options[prop]!==prevProps[prop]}))?(instance.popperInstance.destroy(),createPopperInstance(),instance.state.isVisible&&instance.popperInstance.enableEventListeners(),instance.props.followCursor&&lastMouseMoveEvent&&positionVirtualReferenceNearCursor(lastMouseMoveEvent)):instance.popperInstance.update())}
/**
   * Shortcut for .set({ content: newContent })
   */function setContent(content){set({content:content})}
/**
   * Shows the tooltip
   */function show(){var duration=arguments.length>0&&void 0!==arguments[0]?arguments[0]:getValue$2(instance.props.duration,0,defaultProps$2.duration[1]);if(!instance.state.isDestroyed&&instance.state.isEnabled&&(!isUsingTouch$1||instance.props.touch)&&!getEventListenersTarget().hasAttribute("disabled")&&!1!==instance.props.onShow(instance)){addDocumentClickListener(),popper.style.visibility="visible",instance.state.isVisible=!0,instance.props.interactive&&getEventListenersTarget().classList.add(ACTIVE_CLASS$1);// Prevent a transition if the popper is at the opposite placement
var transitionableElements=getTransitionableElements();setTransitionDuration$1(transitionableElements.concat(popper),0),currentMountCallback=function(){if(instance.state.isVisible){var isInLooseFollowCursorMode=getIsInLooseFollowCursorMode();isInLooseFollowCursorMode&&lastMouseMoveEvent?positionVirtualReferenceNearCursor(lastMouseMoveEvent):isInLooseFollowCursorMode||
// Double update will apply correct mutations
instance.popperInstance.update(),instance.popperChildren.backdrop&&(instance.popperChildren.content.style.transitionDelay=Math.round(duration/12)+"ms"),instance.props.sticky&&makeSticky(),setTransitionDuration$1([popper],instance.props.updateDuration),setTransitionDuration$1(transitionableElements,duration),setVisibilityState$1(transitionableElements,"visible"),onTransitionedIn(duration,(function(){instance.props.aria&&getEventListenersTarget().setAttribute("aria-".concat(instance.props.aria),popper.id),instance.props.onShown(instance),instance.state.isShown=!0}))}},mount()}// Standardize `disabled` behavior across browsers.
// Firefox allows events on disabled elements, but Chrome doesn't.
// Using a wrapper element (i.e. <span>) is recommended.
}
/**
   * Hides the tooltip
   */function hide(){var duration=arguments.length>0&&void 0!==arguments[0]?arguments[0]:getValue$2(instance.props.duration,1,defaultProps$2.duration[1]);if(!instance.state.isDestroyed&&(instance.state.isEnabled||isBeingDestroyed)&&(!1!==instance.props.onHide(instance)||isBeingDestroyed)){removeDocumentClickListener(),popper.style.visibility="hidden",instance.state.isVisible=!1,instance.state.isShown=!1,wasVisibleDuringPreviousUpdate=!1,instance.props.interactive&&getEventListenersTarget().classList.remove(ACTIVE_CLASS$1);var transitionableElements=getTransitionableElements();setTransitionDuration$1(transitionableElements,duration),setVisibilityState$1(transitionableElements,"hidden"),onTransitionedOut(duration,(function(){isScheduledToShow||removeFollowCursorListener(),instance.props.aria&&getEventListenersTarget().removeAttribute("aria-".concat(instance.props.aria)),instance.popperInstance.disableEventListeners(),instance.popperInstance.options.placement=instance.props.placement,popper.parentNode.removeChild(popper),instance.props.onHidden(instance),instance.state.isMounted=!1}))}}
/**
   * Destroys the tooltip
   */function destroy(destroyTargetInstances){if(!instance.state.isDestroyed){isBeingDestroyed=!0,// If the popper is currently mounted to the DOM, we want to ensure it gets
// hidden and unmounted instantly upon destruction
instance.state.isMounted&&hide(0),removeTriggersFromReference(),delete reference._tippy;var target=instance.props.target;target&&destroyTargetInstances&&isRealElement$1(reference)&&arrayFrom$1(reference.querySelectorAll(target)).forEach((function(child){child._tippy&&child._tippy.destroy()})),instance.popperInstance&&instance.popperInstance.destroy(),isBeingDestroyed=!1,instance.state.isDestroyed=!0}}}
/**
 * Groups an array of instances by taking control of their props during
 * certain lifecycles.
 */function group$1(instances){var _ref=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_ref$delay=_ref.delay,delay=void 0===_ref$delay?instances[0].props.delay:_ref$delay,_ref$duration=_ref.duration,duration=void 0===_ref$duration?0:_ref$duration,isAnyTippyOpen=!1;function setIsAnyTippyOpen(value){isAnyTippyOpen=value,updateInstances()}function onShow(instance){instance._originalProps.onShow(instance),instances.forEach((function(instance){instance.set({duration:duration}),instance.state.isVisible&&instance.hide()})),setIsAnyTippyOpen(!0)}function onHide(instance){instance._originalProps.onHide(instance),setIsAnyTippyOpen(!1)}function onShown(instance){instance._originalProps.onShown(instance),instance.set({duration:instance._originalProps.duration})}function updateInstances(){instances.forEach((function(instance){instance.set({onShow:onShow,onShown:onShown,onHide:onHide,delay:isAnyTippyOpen?[0,Array.isArray(delay)?delay[1]:delay]:delay,duration:isAnyTippyOpen?duration:instance._originalProps.duration})}))}instances.forEach((function(instance){instance._originalProps?instance.set(instance._originalProps):instance._originalProps=_extends$1$1({},instance.props)})),updateInstances()}var globalEventListenersBound$1=!1;
/**
 * Exported module
 */function tippy$1(targets,options){validateOptions$1(options||{},defaultProps$2),globalEventListenersBound$1||(bindGlobalEventListeners$1(),globalEventListenersBound$1=!0);var props=_extends$1$1({},defaultProps$2,{},options);// If they are specifying a virtual positioning reference, we need to polyfill
// some native DOM props
isBareVirtualElement$1(targets)&&polyfillElementPrototypeProperties$1(targets);var instances=getArrayOfElements$1(targets).reduce((function(acc,reference){var instance=reference&&createTippy$1(reference,props);return instance&&acc.push(instance),acc}),[]);return isSingular$1(targets)?instances[0]:instances}
/**
 * Static props
 */
/**
 * Auto-init tooltips for elements with a `data-tippy="..."` attribute
 */
function autoInit$1(){arrayFrom$1(document.querySelectorAll("[data-tippy]")).forEach((function(el){var content=el.getAttribute("data-tippy");content&&tippy$1(el,{content:content})}))}
/**
 * Injects a string of CSS styles to a style node in <head>
 */
function injectCSS$1(css){if(isBrowser$1$1){var style=document.createElement("style");style.type="text/css",style.textContent=css,style.setAttribute("data-tippy-stylesheet","");var head=document.head,firstStyleOrLinkTag=head.querySelector("style,link");firstStyleOrLinkTag?head.insertBefore(style,firstStyleOrLinkTag):head.appendChild(style)}}tippy$1.version=version$1,tippy$1.defaults=defaultProps$2,
/**
 * Static methods
 */
tippy$1.setDefaults=function(partialDefaults){Object.keys(partialDefaults).forEach((function(key){
// @ts-ignore
defaultProps$2[key]=partialDefaults[key]}))},tippy$1.hideAll=hideAll$1,tippy$1.group=group$1,isBrowser$1$1&&setTimeout(autoInit$1),injectCSS$1(css$1);var commonjsGlobal$1="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof window?window:"undefined"!==typeof global?global:"undefined"!==typeof self?self:{};function createCommonjsModule$2(fn,module){return module={exports:{}},fn(module,module.exports),module.exports}var humps$1=createCommonjsModule$2((function(module){(function(global){var _processKeys=function(convert,obj,options){if(!_isObject(obj)||_isDate(obj)||_isRegExp(obj)||_isBoolean(obj)||_isFunction(obj))return obj;var output,i=0,l=0;if(_isArray(obj))for(output=[],l=obj.length;i<l;i++)output.push(_processKeys(convert,obj[i],options));else for(var key in output={},obj)Object.prototype.hasOwnProperty.call(obj,key)&&(output[convert(key,options)]=_processKeys(convert,obj[key],options));return output},separateWords=function(string,options){options=options||{};var separator=options.separator||"_",split=options.split||/(?=[A-Z])/;return string.split(split).join(separator)},camelize=function(string){return _isNumerical(string)?string:(string=string.replace(/[\-_\s]+(.)?/g,(function(match,chr){return chr?chr.toUpperCase():""})),string.substr(0,1).toLowerCase()+string.substr(1))},pascalize=function(string){var camelized=camelize(string);
// Ensure 1st char is always uppercase
return camelized.substr(0,1).toUpperCase()+camelized.substr(1)},decamelize=function(string,options){return separateWords(string,options).toLowerCase()},toString=Object.prototype.toString,_isFunction=function(obj){return"function"===typeof obj},_isObject=function(obj){return obj===Object(obj)},_isArray=function(obj){return"[object Array]"==toString.call(obj)},_isDate=function(obj){return"[object Date]"==toString.call(obj)},_isRegExp=function(obj){return"[object RegExp]"==toString.call(obj)},_isBoolean=function(obj){return"[object Boolean]"==toString.call(obj)},_isNumerical=function(obj){return obj-=0,obj===obj},_processor=function(convert,options){var callback=options&&"process"in options?options.process:options;return"function"!==typeof callback?convert:function(string,options){return callback(string,convert,options)}},humps={camelize:camelize,decamelize:decamelize,pascalize:pascalize,depascalize:decamelize,camelizeKeys:function(object,options){return _processKeys(_processor(camelize,options),object)},decamelizeKeys:function(object,options){return _processKeys(_processor(decamelize,options),object,options)},pascalizeKeys:function(object,options){return _processKeys(_processor(pascalize,options),object)},depascalizeKeys:function(){return this.decamelizeKeys.apply(this,arguments)}};
// String conversion methods
module.exports?module.exports=humps:global.humps=humps})(commonjsGlobal$1)}));function _defineProperty$3(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function ownKeys$5(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread2$2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$5(Object(source),!0).forEach((function(key){_defineProperty$3(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$5(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}var booleanProps$1={a11y:!0,allowHTML:!0,animateFill:!0,arrow:!1,flip:!0,flipOnUpdate:!1,followCursor:!1,hideOnClick:!0,ignoreAttributes:!1,inertia:!1,interactive:!1,lazy:!0,multiple:!1,showOnInit:!1,sticky:!1,touch:!0,touchHold:!1},defaultProps$1$1=_objectSpread2$2({animation:"shift-away",appendTo:function(){return document.body},aria:"describedby",arrowType:"sharp",boundary:"scrollParent",content:"",delay:0,distance:10,duration:[325,275],flipBehavior:"flip",interactiveBorder:2,interactiveDebounce:0,maxWidth:350,offset:0,onHidden:function(){},onHide:function(){},onMount:function(){},onShow:function(){},onShown:function(){},placement:"top",popperOptions:{},role:"tooltip",size:"regular",target:"",theme:"dark",trigger:"mouseenter focus",updateDuration:0,wait:null,zIndex:9999},booleanProps$1),script$2$2={props:{to:void 0,toSelector:void 0,toElement:void 0,content:void 0,enabled:void 0,visible:void 0,triggerTarget:void 0,tag:{type:String,default:"div"},triggerTag:String,contentTag:String},data:function(){return{tip:null,options:{}}},mounted:function(){this.init()},watch:{content:function(){this.tip&&this.tip.set(this.getOptions())},enabled:function(val){this.tip&&(val?this.tip.enable():(this.tip.hide(),this.tip.disable()))},visible:function(val){this.tip&&(val?this.tip.show():this.tip.hide())}},updated:function(){this.tip&&!this.content&&this.tip.set(this.getOptions())},beforeDestroy:function(){this.tip&&this.tip.destroy()},computed:{isManualTrigger:function(){return"manual"===this.options.trigger}},methods:{init:function(){if(this.tip){try{this.tip.destroy()}catch(error){}this.tip=null}var elm=this.toElement;if(null==elm&&(elm=this.to?document.querySelector("[name='".concat(this.to,"']")):this.toSelector?document.querySelector(this.toSelector):this.$refs.trigger&&this.$refs.trigger.childElementCount>0?this.$refs.trigger:this.$el.parentElement),elm){var tip=tippy$1(elm,this.getOptions());if(tip){if(Array.isArray(tip)){if(!(tip.length>0))return;this.tip=tip[0]}this.tip=tip,this.$emit("onCreate",this.tip),this.$emit("init",this.tip),!1===this.enabled&&this.tip.disable(),this.isManualTrigger&&!0===this.visible&&this.tip.show()}}},tippy:function(){return this.tip},filterOptions:function(){for(var getValue=function(key,value){if(booleanProps$1.hasOwnProperty(key)){if(""===value)return!0;if("false"===value)return!1;if("true"===value)return!0}return value},_i=0,_Object$keys=Object.keys(this.options);_i<_Object$keys.length;_i++){var key=_Object$keys[_i];defaultProps$1$1.hasOwnProperty(key)?this.options[key]=getValue(key,this.options[key]):
// We're replacing this.options anyway, we don't have to worry about modifying the object
delete this.options[key]}return this.options},getOptions:function(){var _this=this;return this.options.content=this.content?this.content:this.$refs.content,Object.assign(this.options,humps$1.camelizeKeys(this.$attrs)),this.filterOptions(),!this.options.onShow&&this.$listeners&&this.$listeners["show"]&&(this.options.onShow=function(){var _this$$listeners$show;return(_this$$listeners$show=_this.$listeners["show"]).fns.apply(_this$$listeners$show,arguments)}),!this.options.onShow&&this.$listeners&&this.$listeners["shown"]&&(this.options.onShown=function(){var _this$$listeners$show2;return(_this$$listeners$show2=_this.$listeners["shown"]).fns.apply(_this$$listeners$show2,arguments)}),!this.options.onHidden&&this.$listeners&&this.$listeners["hidden"]&&(this.options.onHidden=function(){var _this$$listeners$hidd;return(_this$$listeners$hidd=_this.$listeners["hidden"]).fns.apply(_this$$listeners$hidd,arguments)}),!this.options.onHide&&this.$listeners&&this.$listeners["hide"]&&(this.options.onHide=function(){var _this$$listeners$hide;return(_this$$listeners$hide=_this.$listeners["hide"]).fns.apply(_this$$listeners$hide,arguments)}),!this.options.onMount&&this.$listeners&&this.$listeners["mount"]&&(this.options.onMount=function(){var _this$$listeners$moun;return(_this$$listeners$moun=_this.$listeners["mount"]).fns.apply(_this$$listeners$moun,arguments)}),this.options.triggerTarget=this.triggerTarget,this.options}}};function normalizeComponent$4(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier
/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);// Vue.extend constructor export interop.
var hook,options="function"===typeof script?script.options:script;// render functions
if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,// functional template
isFunctionalTemplate&&(options.functional=!0)),// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),// inject component styles
style&&style.call(this,createInjectorSSR(context)),// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(){style.call(this,createInjectorShadow(this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
var originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
var existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}var normalizeComponent_1$1=normalizeComponent$4,__vue_script__$2$2=script$2$2,__vue_render__$2$2=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c(_vm.tag,{tag:"component",attrs:{"data-tippy-component":""}},[_c(_vm.triggerTag||_vm.tag,{ref:"trigger",tag:"component",attrs:{"data-tippy-component-trigger":""}},[_vm._t("trigger")],2),_vm._v(" "),_c(_vm.contentTag||_vm.tag,{ref:"content",tag:"component"},[_vm._t("default")],2)],1)},__vue_staticRenderFns__$2$2=[];
/* script */__vue_render__$2$2._withStripped=!0;
/* style */
var __vue_inject_styles__$2$2=void 0,__vue_scope_id__$2$2=void 0,__vue_module_identifier__$2$2=void 0,__vue_is_functional_template__$2$2=!1,TippyComponent$1=normalizeComponent_1$1({render:__vue_render__$2$2,staticRenderFns:__vue_staticRenderFns__$2$2},__vue_inject_styles__$2$2,__vue_script__$2$2,__vue_scope_id__$2$2,__vue_is_functional_template__$2$2,__vue_module_identifier__$2$2,void 0,void 0),tippyDirective$1="tippy",plugin$3={install:function(Vue){var options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};function createTippy(el,binding,vnode){var handlers=vnode.data&&vnode.data.on||vnode.componentOptions&&vnode.componentOptions.listeners;el.setAttribute("data-tippy-directive","");var opts=deriveOpts(binding),modifiers=Object.keys(binding.modifiers||{}),placement=modifiers.find((function(modifier){return"arrow"!==modifier})),withArrow=-1!==modifiers.findIndex((function(modifier){return"arrow"===modifier}));opts=Object.assign({},options,opts),placement&&(opts.placement=opts.placement||placement),withArrow&&(opts.arrow=void 0===opts.arrow||opts.arrow),handlers&&handlers["show"]&&(opts.onShow=function(){var _handlers$show;return(_handlers$show=handlers["show"]).fns.apply(_handlers$show,arguments)}),handlers&&handlers["shown"]&&(opts.onShown=function(){var _handlers$shown;(_handlers$shown=handlers["shown"]).fns.apply(_handlers$shown,arguments)}),handlers&&handlers["hidden"]&&(opts.onHidden=function(){var _handlers$hidden;(_handlers$hidden=handlers["hidden"]).fns.apply(_handlers$hidden,arguments)}),handlers&&handlers["hide"]&&(opts.onHide=function(){var _handlers$hide;return(_handlers$hide=handlers["hide"]).fns.apply(_handlers$hide,arguments)}),handlers&&handlers["mount"]&&(opts.onMount=function(){var _handlers$mount;(_handlers$mount=handlers["mount"]).fns.apply(_handlers$mount,arguments)}),el.getAttribute("title")&&!opts.content&&(opts.content=el.getAttribute("title"),el.removeAttribute("title")),el.getAttribute("content")&&!opts.content&&(opts.content=el.getAttribute("content")),tippy$1(el,opts),opts.showOnLoad&&el._tippy.show(),Vue.nextTick((function(){handlers&&handlers["init"]&&handlers["init"].fns(el._tippy,el)}))}function deriveOpts(binding){return"string"===typeof binding.value?{content:binding.value}:binding.value||{}}tippyDirective$1=options.directive||"tippy",tippy$1.setDefaults(options||{}),Vue.directive(tippyDirective$1,{inserted:function(el,binding,vnode){Vue.nextTick((function(){createTippy(el,binding,vnode)}))},unbind:function(el){el._tippy&&el._tippy.destroy()},componentUpdated:function(el,binding,vnode){if(el._tippy){var opts=deriveOpts(binding);el.getAttribute("title")&&!opts.content&&(opts.content=el.getAttribute("title"),el.removeAttribute("title")),el.getAttribute("content")&&!opts.content&&(opts.content=el.getAttribute("content")),el._tippy.set(opts)}}})}};
/* scoped */"undefined"!==typeof window&&window.Vue&&(window.Vue.use(plugin$3),window.Vue.component("tippy",TippyComponent$1));
// Unique ID creation requires a high quality random # generator.  In node.js
// this is pretty straight-forward - we use the crypto API.
for(var rng$1=function(){return crypto_ignored_.randomBytes(16)},byteToHex$1=[],i$2=0
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */;i$2<256;++i$2)byteToHex$1[i$2]=(i$2+256).toString(16).substr(1);function bytesToUuid(buf,offset){var i=offset||0,bth=byteToHex$1;// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
return[bth[buf[i++]],bth[buf[i++]],bth[buf[i++]],bth[buf[i++]],"-",bth[buf[i++]],bth[buf[i++]],"-",bth[buf[i++]],bth[buf[i++]],"-",bth[buf[i++]],bth[buf[i++]],"-",bth[buf[i++]],bth[buf[i++]],bth[buf[i++]],bth[buf[i++]],bth[buf[i++]],bth[buf[i++]]].join("")}var _nodeId,_clockseq,bytesToUuid_1=bytesToUuid,_lastMSecs=0,_lastNSecs=0;
// **`v1()` - Generate time-based UUID**

// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
// See https://github.com/uuidjs/uuid for API details
function v1(options,buf,offset){var i=buf&&offset||0,b=buf||[];options=options||{};var node=options.node||_nodeId,clockseq=void 0!==options.clockseq?options.clockseq:_clockseq;// node and clockseq need to be initialized to random values if they're not
// specified.  We do this lazily to minimize issues related to insufficient
// system entropy.  See #189
if(null==node||null==clockseq){var seedBytes=rng$1();null==node&&(
// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
node=_nodeId=[1|seedBytes[0],seedBytes[1],seedBytes[2],seedBytes[3],seedBytes[4],seedBytes[5]]),null==clockseq&&(
// Per 4.2.2, randomize (14 bit) clockseq
clockseq=_clockseq=16383&(seedBytes[6]<<8|seedBytes[7]))}// UUID timestamps are 100 nano-second units since the Gregorian epoch,
// (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
// time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
// (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
var msecs=void 0!==options.msecs?options.msecs:(new Date).getTime(),nsecs=void 0!==options.nsecs?options.nsecs:_lastNSecs+1,dt=msecs-_lastMSecs+(nsecs-_lastNSecs)/1e4;// Per 4.2.1.2, use count of uuid's generated during the current clock
// cycle to simulate higher resolution clock
// Per 4.2.1.2 Throw error if too many uuids are requested
if(// Per 4.2.1.2, Bump clockseq on clock regression
dt<0&&void 0===options.clockseq&&(clockseq=clockseq+1&16383),// Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
// time interval
(dt<0||msecs>_lastMSecs)&&void 0===options.nsecs&&(nsecs=0),nsecs>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");_lastMSecs=msecs,_lastNSecs=nsecs,_clockseq=clockseq,// Per 4.1.4 - Convert from unix epoch to Gregorian epoch
msecs+=122192928e5;// `time_low`
var tl=(1e4*(268435455&msecs)+nsecs)%4294967296;b[i++]=tl>>>24&255,b[i++]=tl>>>16&255,b[i++]=tl>>>8&255,b[i++]=255&tl;// `time_mid`
var tmh=msecs/4294967296*1e4&268435455;b[i++]=tmh>>>8&255,b[i++]=255&tmh,// `time_high_and_version`
b[i++]=tmh>>>24&15|16,// include version
b[i++]=tmh>>>16&255,// `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
b[i++]=clockseq>>>8|128,// `clock_seq_low`
b[i++]=255&clockseq;// `node`
for(var n=0;n<6;++n)b[i+n]=node[n];return buf||bytesToUuid_1(b)}var v1_1=v1;function v4$1(options,buf,offset){var i=buf&&offset||0;"string"==typeof options&&(buf="binary"===options?new Array(16):null,options=null),options=options||{};var rnds=options.random||(options.rng||rng$1)();// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
// Copy bytes to buffer, if provided
if(rnds[6]=15&rnds[6]|64,rnds[8]=63&rnds[8]|128,buf)for(var ii=0;ii<16;++ii)buf[i+ii]=rnds[ii];return buf||bytesToUuid_1(rnds)}var v4_1=v4$1,uuid=v4_1;uuid.v1=v1_1,uuid.v4=v4_1;
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex$2=[];for(let i=0;i<256;++i)byteToHex$2.push((i+256).toString(16).slice(1));function _arrayLikeToArray$1$1(arr,len){(null==len||len>arr.length)&&(len=arr.length);for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2}function _arrayWithoutHoles$1$1(arr){if(Array.isArray(arr))return _arrayLikeToArray$1$1(arr)}function _iterableToArray$1$1(iter){if("undefined"!==typeof Symbol&&null!=iter[Symbol.iterator]||null!=iter["@@iterator"])return Array.from(iter)}function _unsupportedIterableToArray$1$1(o,minLen){if(o){if("string"===typeof o)return _arrayLikeToArray$1$1(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);return"Object"===n&&o.constructor&&(n=o.constructor.name),"Map"===n||"Set"===n?Array.from(o):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?_arrayLikeToArray$1$1(o,minLen):void 0}}function _nonIterableSpread$1$1(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _toConsumableArray$1$1(arr){return _arrayWithoutHoles$1$1(arr)||_iterableToArray$1$1(arr)||_unsupportedIterableToArray$1$1(arr)||_nonIterableSpread$1$1()}function _defineProperty$2$1(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function ownKeys$4$1(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread2$1$1(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$4$1(Object(source),!0).forEach((function(key){_defineProperty$2$1(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$4$1(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}function _typeof$4$1(obj){return _typeof$4$1="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof$4$1(obj)}function _regeneratorRuntime$1(){
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
_regeneratorRuntime$1=function(){return exports};var exports={},Op=Object.prototype,hasOwn=Op.hasOwnProperty,$Symbol="function"==typeof Symbol?Symbol:{},iteratorSymbol=$Symbol.iterator||"@@iterator",asyncIteratorSymbol=$Symbol.asyncIterator||"@@asyncIterator",toStringTagSymbol=$Symbol.toStringTag||"@@toStringTag";function define(obj,key,value){return Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}),obj[key]}try{define({},"")}catch(err){define=function(obj,key,value){return obj[key]=value}}function wrap(innerFn,outerFn,self,tryLocsList){var protoGenerator=outerFn&&outerFn.prototype instanceof Generator?outerFn:Generator,generator=Object.create(protoGenerator.prototype),context=new Context(tryLocsList||[]);return generator._invoke=function(innerFn,self,context){var state="suspendedStart";return function(method,arg){if("executing"===state)throw new Error("Generator is already running");if("completed"===state){if("throw"===method)throw arg;return doneResult()}for(context.method=method,context.arg=arg;;){var delegate=context.delegate;if(delegate){var delegateResult=maybeInvokeDelegate(delegate,context);if(delegateResult){if(delegateResult===ContinueSentinel)continue;return delegateResult}}if("next"===context.method)context.sent=context._sent=context.arg;else if("throw"===context.method){if("suspendedStart"===state)throw state="completed",context.arg;context.dispatchException(context.arg)}else"return"===context.method&&context.abrupt("return",context.arg);state="executing";var record=tryCatch(innerFn,self,context);if("normal"===record.type){if(state=context.done?"completed":"suspendedYield",record.arg===ContinueSentinel)continue;return{value:record.arg,done:context.done}}"throw"===record.type&&(state="completed",context.method="throw",context.arg=record.arg)}}}(innerFn,self,context),generator}function tryCatch(fn,obj,arg){try{return{type:"normal",arg:fn.call(obj,arg)}}catch(err){return{type:"throw",arg:err}}}exports.wrap=wrap;var ContinueSentinel={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var IteratorPrototype={};define(IteratorPrototype,iteratorSymbol,(function(){return this}));var getProto=Object.getPrototypeOf,NativeIteratorPrototype=getProto&&getProto(getProto(values([])));NativeIteratorPrototype&&NativeIteratorPrototype!==Op&&hasOwn.call(NativeIteratorPrototype,iteratorSymbol)&&(IteratorPrototype=NativeIteratorPrototype);var Gp=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(IteratorPrototype);function defineIteratorMethods(prototype){["next","throw","return"].forEach((function(method){define(prototype,method,(function(arg){return this._invoke(method,arg)}))}))}function AsyncIterator(generator,PromiseImpl){function invoke(method,arg,resolve,reject){var record=tryCatch(generator[method],generator,arg);if("throw"!==record.type){var result=record.arg,value=result.value;return value&&"object"==_typeof$4$1(value)&&hasOwn.call(value,"__await")?PromiseImpl.resolve(value.__await).then((function(value){invoke("next",value,resolve,reject)}),(function(err){invoke("throw",err,resolve,reject)})):PromiseImpl.resolve(value).then((function(unwrapped){result.value=unwrapped,resolve(result)}),(function(error){return invoke("throw",error,resolve,reject)}))}reject(record.arg)}var previousPromise;this._invoke=function(method,arg){function callInvokeWithMethodAndArg(){return new PromiseImpl((function(resolve,reject){invoke(method,arg,resolve,reject)}))}return previousPromise=previousPromise?previousPromise.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}}function maybeInvokeDelegate(delegate,context){var method=delegate.iterator[context.method];if(void 0===method){if(context.delegate=null,"throw"===context.method){if(delegate.iterator["return"]&&(context.method="return",context.arg=void 0,maybeInvokeDelegate(delegate,context),"throw"===context.method))return ContinueSentinel;context.method="throw",context.arg=new TypeError("The iterator does not provide a 'throw' method")}return ContinueSentinel}var record=tryCatch(method,delegate.iterator,context.arg);if("throw"===record.type)return context.method="throw",context.arg=record.arg,context.delegate=null,ContinueSentinel;var info=record.arg;return info?info.done?(context[delegate.resultName]=info.value,context.next=delegate.nextLoc,"return"!==context.method&&(context.method="next",context.arg=void 0),context.delegate=null,ContinueSentinel):info:(context.method="throw",context.arg=new TypeError("iterator result is not an object"),context.delegate=null,ContinueSentinel)}function pushTryEntry(locs){var entry={tryLoc:locs[0]};1 in locs&&(entry.catchLoc=locs[1]),2 in locs&&(entry.finallyLoc=locs[2],entry.afterLoc=locs[3]),this.tryEntries.push(entry)}function resetTryEntry(entry){var record=entry.completion||{};record.type="normal",delete record.arg,entry.completion=record}function Context(tryLocsList){this.tryEntries=[{tryLoc:"root"}],tryLocsList.forEach(pushTryEntry,this),this.reset(!0)}function values(iterable){if(iterable){var iteratorMethod=iterable[iteratorSymbol];if(iteratorMethod)return iteratorMethod.call(iterable);if("function"==typeof iterable.next)return iterable;if(!isNaN(iterable.length)){var i=-1,next=function next(){for(;++i<iterable.length;)if(hasOwn.call(iterable,i))return next.value=iterable[i],next.done=!1,next;return next.value=void 0,next.done=!0,next};return next.next=next}}return{next:doneResult}}function doneResult(){return{value:void 0,done:!0}}return GeneratorFunction.prototype=GeneratorFunctionPrototype,define(Gp,"constructor",GeneratorFunctionPrototype),define(GeneratorFunctionPrototype,"constructor",GeneratorFunction),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,toStringTagSymbol,"GeneratorFunction"),exports.isGeneratorFunction=function(genFun){var ctor="function"==typeof genFun&&genFun.constructor;return!!ctor&&(ctor===GeneratorFunction||"GeneratorFunction"===(ctor.displayName||ctor.name))},exports.mark=function(genFun){return Object.setPrototypeOf?Object.setPrototypeOf(genFun,GeneratorFunctionPrototype):(genFun.__proto__=GeneratorFunctionPrototype,define(genFun,toStringTagSymbol,"GeneratorFunction")),genFun.prototype=Object.create(Gp),genFun},exports.awrap=function(arg){return{__await:arg}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,asyncIteratorSymbol,(function(){return this})),exports.AsyncIterator=AsyncIterator,exports.async=function(innerFn,outerFn,self,tryLocsList,PromiseImpl){void 0===PromiseImpl&&(PromiseImpl=Promise);var iter=new AsyncIterator(wrap(innerFn,outerFn,self,tryLocsList),PromiseImpl);return exports.isGeneratorFunction(outerFn)?iter:iter.next().then((function(result){return result.done?result.value:iter.next()}))},defineIteratorMethods(Gp),define(Gp,toStringTagSymbol,"Generator"),define(Gp,iteratorSymbol,(function(){return this})),define(Gp,"toString",(function(){return"[object Generator]"})),exports.keys=function(object){var keys=[];for(var key in object)keys.push(key);return keys.reverse(),function next(){for(;keys.length;){var key=keys.pop();if(key in object)return next.value=key,next.done=!1,next}return next.done=!0,next}},exports.values=values,Context.prototype={constructor:Context,reset:function(skipTempReset){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(resetTryEntry),!skipTempReset)for(var name in this)"t"===name.charAt(0)&&hasOwn.call(this,name)&&!isNaN(+name.slice(1))&&(this[name]=void 0)},stop:function(){this.done=!0;var rootRecord=this.tryEntries[0].completion;if("throw"===rootRecord.type)throw rootRecord.arg;return this.rval},dispatchException:function(exception){if(this.done)throw exception;var context=this;function handle(loc,caught){return record.type="throw",record.arg=exception,context.next=loc,caught&&(context.method="next",context.arg=void 0),!!caught}for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i],record=entry.completion;if("root"===entry.tryLoc)return handle("end");if(entry.tryLoc<=this.prev){var hasCatch=hasOwn.call(entry,"catchLoc"),hasFinally=hasOwn.call(entry,"finallyLoc");if(hasCatch&&hasFinally){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0);if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc)}else if(hasCatch){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0)}else{if(!hasFinally)throw new Error("try statement without catch or finally");if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc)}}}},abrupt:function(type,arg){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc<=this.prev&&hasOwn.call(entry,"finallyLoc")&&this.prev<entry.finallyLoc){var finallyEntry=entry;break}}finallyEntry&&("break"===type||"continue"===type)&&finallyEntry.tryLoc<=arg&&arg<=finallyEntry.finallyLoc&&(finallyEntry=null);var record=finallyEntry?finallyEntry.completion:{};return record.type=type,record.arg=arg,finallyEntry?(this.method="next",this.next=finallyEntry.finallyLoc,ContinueSentinel):this.complete(record)},complete:function(record,afterLoc){if("throw"===record.type)throw record.arg;return"break"===record.type||"continue"===record.type?this.next=record.arg:"return"===record.type?(this.rval=this.arg=record.arg,this.method="return",this.next="end"):"normal"===record.type&&afterLoc&&(this.next=afterLoc),ContinueSentinel},finish:function(finallyLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.finallyLoc===finallyLoc)return this.complete(entry.completion,entry.afterLoc),resetTryEntry(entry),ContinueSentinel}},catch:function(tryLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc===tryLoc){var record=entry.completion;if("throw"===record.type){var thrown=record.arg;resetTryEntry(entry)}return thrown}}throw new Error("illegal catch attempt")},delegateYield:function(iterable,resultName,nextLoc){return this.delegate={iterator:values(iterable),resultName:resultName,nextLoc:nextLoc},"next"===this.method&&(this.arg=void 0),ContinueSentinel}},exports}function asyncGeneratorStep$1(gen,resolve,reject,_next,_throw,key,arg){try{var info=gen[key](arg),value=info.value}catch(error){return void reject(error)}info.done?resolve(value):Promise.resolve(value).then(_next,_throw)}function _asyncToGenerator$1(fn){return function(){var self=this,args=arguments;return new Promise((function(resolve,reject){var gen=fn.apply(self,args);function _next(value){asyncGeneratorStep$1(gen,resolve,reject,_next,_throw,"next",value)}function _throw(err){asyncGeneratorStep$1(gen,resolve,reject,_next,_throw,"throw",err)}_next(void 0)}))}}function _arrayWithHoles$1(arr){if(Array.isArray(arr))return arr}function _iterableToArrayLimit$1(arr,i){var _i=null==arr?null:"undefined"!==typeof Symbol&&arr[Symbol.iterator]||arr["@@iterator"];if(null!=_i){var _s,_e,_arr=[],_n=!0,_d=!1;try{for(_i=_i.call(arr);!(_n=(_s=_i.next()).done);_n=!0)if(_arr.push(_s.value),i&&_arr.length===i)break}catch(err){_d=!0,_e=err}finally{try{_n||null==_i["return"]||_i["return"]()}finally{if(_d)throw _e}}return _arr}}function _nonIterableRest$1(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _slicedToArray$1(arr,i){return _arrayWithHoles$1(arr)||_iterableToArrayLimit$1(arr,i)||_unsupportedIterableToArray$1$1(arr,i)||_nonIterableRest$1()}"undefined"!==typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto);var isLookupTypeField$1=function(field){var _ref=field||{},displayType=_ref.displayType;return["LOOKUP_SIMPLE","MULTI_LOOKUP_SIMPLE"].includes(displayType)},isLookupPopupField$1=function(field){var _ref2=field||{},displayType=_ref2.displayType;return["LOOKUP_POPUP"].includes(displayType)},isLookupField$1=function(field){var _ref5=field||{},displayType=_ref5.displayType;return["LOOKUP_SIMPLE"].includes(displayType)},isMultiLookupField$1=function(field){var _ref6=field||{},displayType=_ref6.displayType;return["MULTI_LOOKUP_SIMPLE"].includes(displayType)},isDateTypeField$1=function(field){var _ref7=field||{},displayType=_ref7.displayType;return["DATETIME","DATE"].includes(displayType)},FIELD_VALUE_HASH$1$1={lookup:function(_ref){var _this=this,field=_ref.field,h=this.$createElement;return h("div",{class:"w-full"},[h(__vue_component__$b$1,{class:"width-full",key:"".concat(field.name," Value"),attrs:{field:field,hideLookupIcon:this.canHidePopupIcon,hideDropDown:this.hideDropDown,disabled:this.disableValueContainer,customOptions:this.getCustomOption()},on:_objectSpread2$1$1(_objectSpread2$1$1({},{input:function(val){return _this.$set(_this,"fieldValue",isEmpty$5(val)?null:val)}}),{},{showLookupWizard:this.showLookupWizard}),model:{value:_this.fieldValue,callback:function($$v){_this.fieldValue=$$v}}}),this.canShowLookupWizard&&h(__vue_component__$6$1,{attrs:{canShowLookupWizard:this.canShowLookupWizard,field:field},on:_objectSpread2$1$1({},{"update:canShowLookupWizard":function(val){return _this.canShowLookupWizard=val},setLookupFieldValue:this.setLookupFieldValue})})])},select:function(_ref2){var _this2=this,field=_ref2.field,isMultiple=_ref2.isMultiple,h=this.$createElement;return h(__vue_component__$a$1$1,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:isMultiple,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:field.options},model:{value:_this2.fieldValue,callback:function($$v){_this2.fieldValue=$$v}}})},input:function(){var _this3=this,_ref3=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},_ref3$type=_ref3.type,type=void 0===_ref3$type?"":_ref3$type,h=this.$createElement;return h(__vue_component__$d,{class:"w-full",attrs:{placeholder:"Enter a value",type:type,disabled:this.disableValueContainer},model:{value:_this3.fieldValue,callback:function($$v){_this3.fieldValue=$$v}}})},date:function(_ref4){var _this4=this,type=_ref4.type,hasTime=_ref4.hasTime,h=this.$createElement;return h(__vue_component__$5$1,{class:"w-full",attrs:{type:type,disabled:this.disableValueContainer,placeholder:"Select a date ".concat(hasTime?"time":""),account:this.account},model:{value:_this4.fieldValue,callback:function($$v){_this4.fieldValue=$$v}}})}},FIELD_DISPLAY_TYPE_HASH$1={NUMBER:function(){return this["input"]({type:"number"})},DECIMAL:function(){return this["input"]({type:"number"})},SELECTBOX:function(field){return this["select"]({field:field,isMultiple:!0})},MULTI_SELECTBOX:function(field){return this["select"]({field:field,isMultiple:!0})},DECISION_BOX:function(field){return this["select"]({field:field,isMultiple:!1})},DATE:function(){return this["date"]({type:"date"})},DATETIME:function(){return this["date"]({type:"datetime",hasTime:!0})},DURATION:function(){return this["input"]({type:"number"})},LOOKUP_SIMPLE:function(field){return this["lookup"]({field:field})},MULTI_LOOKUP_SIMPLE:function(field){return this["lookup"]({field:field})},LOOKUP_POPUP:function(field){return this["lookup"]({field:field})},DEFAULT:function(){return this["input"]()}},WEEK_DAYS_OPTIONS$1=[{label:"Monday",value:1},{label:"Tuesday",value:2},{label:"Wednesday",value:3},{label:"Thursday",value:4},{label:"Friday",value:5},{label:"Saturday",value:6},{label:"Sunday",value:7}],MONTH_OPTIONS$1=[{label:"January",value:1},{label:"February",value:2},{label:"March",value:3},{label:"April",value:4},{label:"May",value:5},{label:"June",value:6},{label:"July",value:7},{label:"August",value:8},{label:"September",value:9},{label:"October",value:10},{label:"November",value:11},{label:"December",value:12}],dateTimeOperator$1={84:"Month",85:"Day of Week",101:"Day of Month",102:"Day of Year",103:"Hours of Day",106:"Before N Days",107:"After N Days",108:"Week of Year"},WEEK_DAYS$1={1:"Monday",2:"Tuesday",3:"Wednesday",4:"Thursday",5:"Friday",6:"Saturday",7:"Sunday"},MONTHS$1=[{label:"January",value:1},{label:"February",value:2},{label:"March",value:3},{label:"April",value:4},{label:"May",value:5},{label:"June",value:6},{label:"July",value:7},{label:"August",value:8},{label:"September",value:9},{label:"October",value:10},{label:"November",value:11},{label:"December",value:12}],ordinalSuffixOf$1=function(day){var j=day%10,k=day%100;return"".concat(day,1==j&&11!=k?"st":2==j&&12!=k?"nd":3==j&&13!=k?"rd":"th")},SPECIAL_VALUE_HASH$1={SPECIAL_20:function(field){var _this=this,h=this.$createElement,_ref=field||{},_ref$displayType=_ref.displayType,displayType=void 0===_ref$displayType?"":_ref$displayType,hasTime="DATETIME"===displayType,type=displayType.toLowerCase();return h(__vue_component__$5$1,{class:"w-full",attrs:{type:"".concat(type,"range"),disabled:this.disableValueContainer,placeholder:"Select a date ".concat(hasTime?"time":""),account:this.account},model:{value:_this.fieldValue,callback:function($$v){_this.fieldValue=$$v}}})},SPECIAL_81:function(){var h=this.$createElement;
// Number - between
return h("div",{class:"flex w-full"},[h(__vue_component__$d,{class:"flex flex-grow pr-1",attrs:{type:"number",placeholder:"Enter start value"}}),h(__vue_component__$d,{class:"flex flex-grow pl-1",attrs:{type:"number",placeholder:"Enter end value"}})])},SPECIAL_84:function(field){var _this2=this,h=this.$createElement;
// Month
return h(__vue_component__$a$1$1,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:MONTH_OPTIONS$1},model:{value:_this2.fieldValue,callback:function($$v){_this2.fieldValue=$$v}}})},SPECIAL_85:function(field){var _this3=this,h=this.$createElement;
// Date - day of week
return h(__vue_component__$a$1$1,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:WEEK_DAYS_OPTIONS$1},model:{value:_this3.fieldValue,callback:function($$v){_this3.fieldValue=$$v}}})},SPECIAL_101:function(field){var _this4=this,h=this.$createElement,options=Array(30).fill().map((function(_,index){return{label:"".concat(ordinalSuffixOf$1(index+1)," day"),value:index+1}}));return h(__vue_component__$a$1$1,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:options},model:{value:_this4.fieldValue,callback:function($$v){_this4.fieldValue=$$v}}})},SPECIAL_103:function(field){var _this5=this,h=this.$createElement,options=Array(24).fill().map((function(_,index){return{label:"".concat(index+1," hour").concat(index>0?"s":""),value:index+1}}));return h(__vue_component__$a$1$1,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:options},model:{value:_this5.fieldValue,callback:function($$v){_this5.fieldValue=$$v}}})},SPECIAL_106:function(){var _this6=this,h=this.$createElement;
// Date - n days
return h(__vue_component__$d,{class:"flex flex-grow pr-1 w-full",attrs:{type:"number",placeholder:"Enter number of days"},model:{value:_this6.fieldValue,callback:function($$v){_this6.fieldValue=$$v}}})},SPECIAL_108:function(field){var _this7=this,h=this.$createElement,options=Array(52).fill().map((function(_,index){return{label:"".concat(index+1," week").concat(index>0?"s":""),value:index+1}}));return h(__vue_component__$a$1$1,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:options},model:{value:_this7.fieldValue,callback:function($$v){_this7.fieldValue=$$v}}})}},SPECIAL_OPERATOR_HASH$1={DATETIME_20:function(field){return this["SPECIAL_20"](field)},DATETIME_84:function(field){return this["SPECIAL_84"](field)},DATETIME_85:function(field){return this["SPECIAL_85"](field)},DATETIME_101:function(field){return this["SPECIAL_101"](field)},DATETIME_103:function(field){return this["SPECIAL_103"](field)},DATETIME_106:function(field){return this["SPECIAL_106"](field)},DATETIME_107:function(field){return this["SPECIAL_106"](field)},DATETIME_108:function(field){return this["SPECIAL_108"](field)},DATE_20:function(field){return this["SPECIAL_20"](field)},DATE_84:function(field){return this["SPECIAL_84"](field)},DATE_85:function(field){return this["SPECIAL_85"](field)},DATE_101:function(field){return this["SPECIAL_101"](field)},DATE_103:function(field){return this["SPECIAL_103"](field)},DATE_106:function(field){return this["SPECIAL_106"](field)},DATE_107:function(field){return this["SPECIAL_106"](field)},DATE_108:function(field){return this["SPECIAL_108"](field)},NUMBER_81:function(){return this["SPECIAL_81"]()},NUMBER_82:function(){return this["SPECIAL_81"]()}},LOOKUP_FIELD_PLACEHOLDER_MAP$1={people:{value:"${LOGGED_PEOPLE}",label:"Current User"},users:{value:"${LOGGED_USER}",label:"Current User"},tenant:{value:"${LOGGED_TENANT}",label:"Current Tenant"},vendors:{value:"${LOGGED_VENDOR}",label:"Current vendor"}},script$9$2={name:"ConditionValue",props:["field","disableValueContainer","account","isSpecialOperator","operatorObj"],data:function(){return{canShowLookupWizard:!1}},computed:{fieldValue:{get:function(){var _ref=this||{},$attrs=_ref.$attrs,field=_ref.field,operatorObj=_ref.operatorObj,_ref2=$attrs||{},value=_ref2.value,_ref3=operatorObj||{},operatorId=_ref3.operatorId,_ref4=field||{},displayType=_ref4.displayType;return"DATETIME"!==displayType&&"DATE"!==displayType||20!==operatorId?value:this.serializeDateValues(value)},set:function(value){this.$emit("input",value)}},
// lookup properties
canHidePopupIcon:function(){var field=this.field,_ref5=field||{},lookupModule=_ref5.lookupModule,_ref6=lookupModule||{},_ref6$showPopup=_ref6.showPopup,showPopup=void 0===_ref6$showPopup||_ref6$showPopup;return!showPopup},hideDropDown:function(){
// Have to hide dropdown for resource type fields
var field=this.field,name=field.name;return"resource"===name}},methods:_objectSpread2$1$1(_objectSpread2$1$1(_objectSpread2$1$1(_objectSpread2$1$1({serializeDateValues:function(value){var dateArray=String(value).split(","),dates=dateArray.map((function(date){return parseInt(date)}));return dates},getFieldValueDisplay:function(){var field=this.field,isSpecialOperator=this.isSpecialOperator,operatorObj=this.operatorObj,fieldObj=field.field||field,_ref7=fieldObj||{},displayType=_ref7.displayType,_ref8=operatorObj||{},operatorId=_ref8.operatorId,specialHashKey="".concat(displayType,"_").concat(operatorId);return isSpecialOperator&&!isEmpty$5(SPECIAL_OPERATOR_HASH$1[specialHashKey])?this[specialHashKey](field):isEmpty$5(FIELD_DISPLAY_TYPE_HASH$1[displayType])?this["DEFAULT"](field):this[displayType](field)},getCustomOption:function(){var _ref9=this||{},field=_ref9.field,_ref10=field||{},lookupModule=_ref10.lookupModule;if(isEmpty$5(lookupModule))return[];var _ref11=lookupModule||{},name=_ref11.name;return isEmpty$5(LOOKUP_FIELD_PLACEHOLDER_MAP$1[name])?[]:[LOOKUP_FIELD_PLACEHOLDER_MAP$1[name]]},resetValue:function(){this.$set(this,"fieldValue",null)},
// lookup methods
showLookupWizard:function(){this.canShowLookupWizard=!0},setLookupFieldValue:function(props){var selectedLookupField=this.field,field=props.field;isEmpty$5(selectedLookupField)&&(this.selectedLookupField=field);var _ref12=field||{},selectedItems=_ref12.selectedItems,_ref12$options=_ref12.options,options=void 0===_ref12$options?[]:_ref12$options,multiple=_ref12.multiple,selectedItemIds=[];if(!isEmpty$5(selectedItems))if(selectedItemIds=selectedItems.map((function(item){return item.value})),isEmpty$5(options))options=_toConsumableArray$1$1(selectedItems);else{var _options,ids=options.map((function(item){return item.value})),newOptions=selectedItems.filter((function(item){return!ids.includes(item.value)}));(_options=options).unshift.apply(_options,_toConsumableArray$1$1(newOptions))}this.$set(this.field,"options",options),this.fieldValue=multiple?selectedItemIds:selectedItemIds[0]}},FIELD_VALUE_HASH$1$1),FIELD_DISPLAY_TYPE_HASH$1),SPECIAL_OPERATOR_HASH$1),SPECIAL_VALUE_HASH$1),render:function(){var h=arguments[0];return h("div",{class:"criteria-value-container ml-2 w-full flex items-center"},[this.getFieldValueDisplay()])}};function normalizeComponent$3$2(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);
// Vue.extend constructor export interop.
const options="function"===typeof script?script.options:script;
// render functions
let hook;if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,
// functional template
isFunctionalTemplate&&(options.functional=!0)),
// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),
// inject component styles
style&&style.call(this,createInjectorSSR(context)),
// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},
// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(context){style.call(this,createInjectorShadow(context,this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
const originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
const existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}
/* script */const __vue_script__$9$2=script$9$2,__vue_inject_styles__$9$2=void 0,__vue_scope_id__$9$2=void 0,__vue_module_identifier__$9$2=void 0,__vue_is_functional_template__$9$2=void 0,__vue_component__$9$2=normalizeComponent$3$2({},__vue_inject_styles__$9$2,__vue_script__$9$2,__vue_scope_id__$9$2,__vue_is_functional_template__$9$2,__vue_module_identifier__$9$2,!1,void 0,void 0,void 0),isOldIE$3="undefined"!==typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
/* template */
/* style */function createInjector$3(context){return(id,style)=>addStyle$5(id,style)}let HEAD$3;const styles$5={};function addStyle$5(id,css){const group=isOldIE$3?css.media||"default":id,style=styles$5[group]||(styles$5[group]={ids:new Set,styles:[]});if(!style.ids.has(id)){style.ids.add(id);let code=css.source;if(css.map&&(
// https://developer.chrome.com/devtools/docs/javascript-debugging
// this makes source maps inside style tags work properly in Chrome
code+="\n/*# sourceURL="+css.map.sources[0]+" */",
// http://stackoverflow.com/a/26603875
code+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(css.map))))+" */"),style.element||(style.element=document.createElement("style"),style.element.type="text/css",css.media&&style.element.setAttribute("media",css.media),void 0===HEAD$3&&(HEAD$3=document.head||document.getElementsByTagName("head")[0]),HEAD$3.appendChild(style.element)),"styleSheet"in style.element)style.styles.push(code),style.element.styleSheet.cssText=style.styles.filter(Boolean).join("\n");else{const index=style.ids.size-1,textNode=document.createTextNode(code),nodes=style.element.childNodes;nodes[index]&&style.element.removeChild(nodes[index]),nodes.length?style.element.insertBefore(textNode,nodes[index]):style.element.appendChild(textNode)}}}function styleInject$1$2(css,ref){void 0===ref&&(ref={});var insertAt=ref.insertAt;if(css&&"undefined"!==typeof document){var head=document.head||document.getElementsByTagName("head")[0],style=document.createElement("style");style.type="text/css","top"===insertAt&&head.firstChild?head.insertBefore(style,head.firstChild):head.appendChild(style),style.styleSheet?style.styleSheet.cssText=css:style.appendChild(document.createTextNode(css))}}var css_248z$1$2="*, ::before, ::after {\n  --tw-border-opacity: 1;\n  border-color: rgba(229, 231, 235, var(--tw-border-opacity))\n}\n\n.relative {\n  position: relative\n}\n\n.m-2 {\n  margin: 0.5rem\n}\n\n.mt-0 {\n  margin-top: 0px\n}\n\n.mt-5 {\n  margin-top: 1.25rem\n}\n\n.mt-0\\.5 {\n  margin-top: 0.125rem\n}\n\n.mr-2 {\n  margin-right: 0.5rem\n}\n\n.mb-2 {\n  margin-bottom: 0.5rem\n}\n\n.ml-1 {\n  margin-left: 0.25rem\n}\n\n.ml-2 {\n  margin-left: 0.5rem\n}\n\n.ml-3 {\n  margin-left: 0.75rem\n}\n\n.flex {\n  display: flex\n}\n\n.table {\n  display: table\n}\n\n.h-14 {\n  height: 3.5rem\n}\n\n.w-full {\n  width: 100%\n}\n\n.flex-grow {\n  flex-grow: 1\n}\n\n@-webkit-keyframes spin {\n  to {\n    transform: rotate(360deg)\n  }\n}\n\n@keyframes spin {\n  to {\n    transform: rotate(360deg)\n  }\n}\n\n@-webkit-keyframes ping {\n  75%, 100% {\n    transform: scale(2);\n    opacity: 0\n  }\n}\n\n@keyframes ping {\n  75%, 100% {\n    transform: scale(2);\n    opacity: 0\n  }\n}\n\n@-webkit-keyframes pulse {\n  50% {\n    opacity: .5\n  }\n}\n\n@keyframes pulse {\n  50% {\n    opacity: .5\n  }\n}\n\n@-webkit-keyframes bounce {\n  0%, 100% {\n    transform: translateY(-25%);\n    -webkit-animation-timing-function: cubic-bezier(0.8,0,1,1);\n            animation-timing-function: cubic-bezier(0.8,0,1,1)\n  }\n\n  50% {\n    transform: none;\n    -webkit-animation-timing-function: cubic-bezier(0,0,0.2,1);\n            animation-timing-function: cubic-bezier(0,0,0.2,1)\n  }\n}\n\n@keyframes bounce {\n  0%, 100% {\n    transform: translateY(-25%);\n    -webkit-animation-timing-function: cubic-bezier(0.8,0,1,1);\n            animation-timing-function: cubic-bezier(0.8,0,1,1)\n  }\n\n  50% {\n    transform: none;\n    -webkit-animation-timing-function: cubic-bezier(0,0,0.2,1);\n            animation-timing-function: cubic-bezier(0,0,0.2,1)\n  }\n}\n\n.cursor-pointer {\n  cursor: pointer\n}\n\n.cursor-not-allowed {\n  cursor: not-allowed\n}\n\n.flex-col {\n  flex-direction: column\n}\n\n.flex-wrap {\n  flex-wrap: wrap\n}\n\n.flex-nowrap {\n  flex-wrap: nowrap\n}\n\n.items-center {\n  align-items: center\n}\n\n.justify-center {\n  justify-content: center\n}\n\n.self-center {\n  align-self: center\n}\n\n.border {\n  border-width: 1px\n}\n\n.text-center {\n  text-align: center\n}\n\n.leading-5 {\n  line-height: 1.25rem\n}\n\n*, ::before, ::after {\n  --tw-shadow: 0 0 #0000\n}\n\n*, ::before, ::after {\n  --tw-ring-inset: var(--tw-empty,/*!*/ /*!*/);\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgba(59, 130, 246, 0.5);\n  --tw-ring-offset-shadow: 0 0 #0000;\n  --tw-ring-shadow: 0 0 #0000\n}\n\n.filter {\n  --tw-blur: var(--tw-empty,/*!*/ /*!*/);\n  --tw-brightness: var(--tw-empty,/*!*/ /*!*/);\n  --tw-contrast: var(--tw-empty,/*!*/ /*!*/);\n  --tw-grayscale: var(--tw-empty,/*!*/ /*!*/);\n  --tw-hue-rotate: var(--tw-empty,/*!*/ /*!*/);\n  --tw-invert: var(--tw-empty,/*!*/ /*!*/);\n  --tw-saturate: var(--tw-empty,/*!*/ /*!*/);\n  --tw-sepia: var(--tw-empty,/*!*/ /*!*/);\n  --tw-drop-shadow: var(--tw-empty,/*!*/ /*!*/);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)\n}\n\n@media (min-width: 640px) {\n}\n\n@media (min-width: 768px) {\n}\n\n@media (min-width: 1024px) {\n}\n\n@media (min-width: 1280px) {\n}\n\n@media (min-width: 1536px) {\n}\n";styleInject$1$2(css_248z$1$2);var script$2$1$1={props:["field","operators","value","account"],components:{Select:__vue_component__$a$1$1,ConditionValue:__vue_component__$9$2},computed:{operatorId:{get:function(){var _this$value;return(null===(_this$value=this.value)||void 0===_this$value?void 0:_this$value.operatorId)||null},set:function(newVal){var value=this.value,updatedObj=_objectSpread2$1$1(_objectSpread2$1$1({},value),{},{operatorId:newVal});this.$emit("input",updatedObj),this.$emit("updateFilter",updatedObj)}},conditionValue:{get:function(){var _this$value2;return null===(_this$value2=this.value)||void 0===_this$value2?void 0:_this$value2.value},set:function(newVal){var inputValue=this.value,updatedObj=_objectSpread2$1$1(_objectSpread2$1$1({},inputValue),{},{value:newVal});this.$emit("input",updatedObj),this.$emit("updateFilter",updatedObj)}},errorText:function(){var field=this.field,_ref=field||{},displayName=_ref.displayName;return"Please input ".concat(displayName)},disableValueContainer:function(){var operatorId=this.operatorId,fieldOperators=this.fieldOperators,disabled=this.disabled,canDisable=!0,selectedOperator=fieldOperators.find((function(operator){return operator.id===operatorId}));return isEmpty$5(selectedOperator)||(canDisable=!(selectedOperator||{}).valueNeeded),canDisable||disabled},currentOperatorObj:function(){var _ref2=this||{},fieldOperators=_ref2.fieldOperators,operatorId=_ref2.operatorId,currentOperator=fieldOperators.find((function(operator){return operator.id===operatorId}));return currentOperator},isSpecialOperator:function(){var _ref3=this||{},currentOperatorObj=_ref3.currentOperatorObj,_ref4=currentOperatorObj||{},specialOperator=_ref4.specialOperator;return specialOperator},fieldOperators:function(){var operators=this.operators,filterOperators=this.filterOperators,field=this.field,_ref5=field||{},dataType=_ref5.dataType,fieldOperators=_ref5.operators;if(!isEmpty$5(operators)){var list=operators[dataType]||[];isEmpty$5(fieldOperators)||(list=list.concat(fieldOperators));var finalList=list.map((function(operator){var operatorId=operator.operatorId,defaultValue=operator.defaultValue,unqiueClientId=operatorId;return isEmpty$5(defaultValue)||(unqiueClientId="".concat(operatorId,"-").concat(defaultValue)),_objectSpread2$1$1(_objectSpread2$1$1({},operator),{},{id:unqiueClientId})}));// filter out special operator if special ui is not present
return finalList=finalList.filter((function(operator){var _ref6=operator||{},specialOperator=_ref6.specialOperator,operatorId=_ref6.id,_ref7=field||{},displayType=_ref7.displayType,specialHashPropName="".concat(displayType,"_").concat(operatorId);return!specialOperator||!isEmpty$5(SPECIAL_OPERATOR_HASH$1[specialHashPropName])})),!isEmpty$5(filterOperators)&&isFunction$4(filterOperators)&&(finalList=(finalList||[]).filter((function(operator){return filterOperators(operator,field)}))),finalList}return[]}},created:function(){this.init()},methods:{init:function(){var value=this.value,operatorId=value.operatorId,conditionValue=value.value;isEmpty$5(operatorId)||(this.operatorId=operatorId),isEmpty$5(conditionValue)||(this.conditionValue=conditionValue);var clonedCondition=cloneDeep(value);this.filterObj=clonedCondition},resetValue:function(){var ref=this.$refs.conditionValue;isEmpty$5(ref)||ref.resetValue()},validate:function(){var disableValueContainer=this.disableValueContainer,conditionValue=this.conditionValue,field=this.field,isValid=!0;return disableValueContainer||(isValid=!isEmpty$5(conditionValue)),this.$emit("isError",{field:field,isError:!isValid}),isValid}}};
/* script */const __vue_script__$2$1$1=script$2$1$1;
/* template */var __vue_render__$2$1$1=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"operator-value-container"},[_c("div",{staticClass:"criteria-operator-container"},[_c("Select",{staticClass:"width-full",attrs:{options:_vm.fieldOperators,labelName:"displayName",valueName:"id",filterable:!0,disabled:!1},on:{clear:_vm.resetValue},model:{value:_vm.operatorId,callback:function($$v){_vm.operatorId=$$v},expression:"operatorId"}})],1),_vm._v(" "),_c("div",{staticClass:"value-container",staticStyle:{display:"flex","flex-direction":"column"}},[_c("ConditionValue",{ref:"conditionValue",attrs:{account:_vm.account,field:_vm.field,operatorObj:_vm.currentOperatorObj,isSpecialOperator:_vm.isSpecialOperator,disableValueContainer:_vm.disableValueContainer},model:{value:_vm.conditionValue,callback:function($$v){_vm.conditionValue=$$v},expression:"conditionValue"}}),_vm._v(" "),_vm.field.isError?_c("div",{staticClass:"err-txt"},[_vm._v(_vm._s(_vm.errorText))]):_vm._e()],1)])},__vue_staticRenderFns__$2$1$1=[];
/* style */
const __vue_inject_styles__$2$1$1=function(inject){inject&&inject("data-v-77891a74_0",{source:".operator-value-container[data-v-77891a74]{display:flex;flex-wrap:nowrap}.operator-value-container .criteria-operator-container[data-v-77891a74]{flex:0 0 35%}.operator-value-container .value-container[data-v-77891a74]{flex-grow:1}.operator-value-container .value-container .err-txt[data-v-77891a74]{color:#f56c6c;font-size:12px;line-height:1;margin-top:4px;padding-left:8px}",map:void 0,media:void 0})},__vue_scope_id__$2$1$1="data-v-77891a74",__vue_module_identifier__$2$1$1=void 0,__vue_is_functional_template__$2$1$1=!1,__vue_component__$2$1$1=normalizeComponent$3$2({render:__vue_render__$2$1$1,staticRenderFns:__vue_staticRenderFns__$2$1$1},__vue_inject_styles__$2$1$1,__vue_script__$2$1$1,__vue_scope_id__$2$1$1,__vue_is_functional_template__$2$1$1,__vue_module_identifier__$2$1$1,!1,createInjector$3,void 0,void 0);
/* scoped */var script$1$1$1={components:{Checkbox:element_ui_common.Checkbox,OperatorValues:__vue_component__$2$1$1,Input:element_ui_common.Input,Button:element_ui_common.Button},props:["moduleName","searchParam","onSave","hideQuery","filterList","showAdvWizard"],data:function(){return{operators:[],fields:[],account:null,searchFilter:{},searchtext:"",filterObj:{},searchableFields:[],filtersFields:[],loading:!1}},created:function(){var _this=this;return _asyncToGenerator$1(_regeneratorRuntime$1().mark((function _callee(){return _regeneratorRuntime$1().wrap((function(_context){while(1)switch(_context.prev=_context.next){case 0:return _context.next=2,_this.init();case 2:case"end":return _context.stop()}}),_callee)})))()},computed:{filteredFields:function(){var searchtext=this.searchtext,searchableFields=this.searchableFields;return isEmpty$5(searchtext)?searchableFields:searchableFields.filter((function(field){var displayName=field.displayName,lowerCasedText=searchtext.toLowerCase(),canShow=displayName.toLowerCase().includes(lowerCasedText);return canShow}))},appliedFilters:function(){var searchParam=this.searchParam,hideQuery=this.hideQuery,filterList=this.filterList;return hideQuery?filterList:isEmpty$5(searchParam)?null:JSON.parse(searchParam)}},watch:{moduleName:function(){this.init()},filterList:function(){this.constructFilters()},showAdvWizard:function(){this.constructFilters()}},methods:{init:function(){var _this2=this;return _asyncToGenerator$1(_regeneratorRuntime$1().mark((function _callee2(){var _yield$Promise$all,_yield$Promise$all2,fields,account,operators;return _regeneratorRuntime$1().wrap((function(_context2){while(1)switch(_context2.prev=_context2.next){case 0:return _this2.loading=!0,_context2.next=3,Promise.all([_this2.loadFields(),_this2.fetchAccount(),_this2.loadOperators()]);case 3:_yield$Promise$all=_context2.sent,_yield$Promise$all2=_slicedToArray$1(_yield$Promise$all,3),fields=_yield$Promise$all2[0],account=_yield$Promise$all2[1],operators=_yield$Promise$all2[2],_this2.fields=fields,_this2.account=account,_this2.operators=operators,_this2.constructFilters(),_this2.loading=!1;case 13:case"end":return _context2.stop()}}),_callee2)})))()},fetchAccount:function(){var _this3=this;return _asyncToGenerator$1(_regeneratorRuntime$1().mark((function _callee3(){var _yield$API$get,data,error,_ref,account;return _regeneratorRuntime$1().wrap((function(_context3){while(1)switch(_context3.prev=_context3.next){case 0:return _context3.next=2,api/* API */.bl.get("/v2/fetchAccount");case 2:if(_yield$API$get=_context3.sent,data=_yield$API$get.data,error=_yield$API$get.error,!error){_context3.next=9;break}_this3.$message.error(error||"Error Occured"),_context3.next=11;break;case 9:return _ref=data||{},account=_ref.account,_context3.abrupt("return",account);case 11:case"end":return _context3.stop()}}),_callee3)})))()},loadOperators:function(){var _this4=this;return _asyncToGenerator$1(_regeneratorRuntime$1().mark((function _callee4(){var url,_yield$API$get2,data,error,_ref2,_ref2$message,message,_ref3,operators;return _regeneratorRuntime$1().wrap((function(_context4){while(1)switch(_context4.prev=_context4.next){case 0:return url="v2/filter/advanced/operators",_context4.next=3,api/* API */.bl.get(url);case 3:if(_yield$API$get2=_context4.sent,data=_yield$API$get2.data,error=_yield$API$get2.error,!error){_context4.next=11;break}_ref2=error||{},_ref2$message=_ref2.message,message=void 0===_ref2$message?"Error Occured":_ref2$message,_this4.$message.error(message),_context4.next=14;break;case 11:if(_ref3=data||{},operators=_ref3.operators,isEmpty$5(operators)){_context4.next=14;break}return _context4.abrupt("return",operators);case 14:case"end":return _context4.stop()}}),_callee4)})))()},loadFields:function(){var _this5=this;return _asyncToGenerator$1(_regeneratorRuntime$1().mark((function _callee5(){var moduleName,url,_yield$API$get3,data,error,_ref4,_ref4$message,message,_ref5,fields;return _regeneratorRuntime$1().wrap((function(_context5){while(1)switch(_context5.prev=_context5.next){case 0:return moduleName=_this5.moduleName,url="/v2/filter/advanced/fields/".concat(moduleName),_context5.next=4,api/* API */.bl.get(url);case 4:if(_yield$API$get3=_context5.sent,data=_yield$API$get3.data,error=_yield$API$get3.error,!error){_context5.next=12;break}_ref4=error||{},_ref4$message=_ref4.message,message=void 0===_ref4$message?"Error occured":_ref4$message,_this5.$message.error(message),_context5.next=14;break;case 12:return _ref5=data||{},fields=_ref5.fields,_context5.abrupt("return",fields.map((function(field){return isLookupPopupField$1(field)||isLookupTypeField$1(field)?_objectSpread2$1$1(_objectSpread2$1$1({},field),{},{multiple:!0,canShowCriteria:!1}):field})));case 14:case"end":return _context5.stop()}}),_callee5)})))()},setError:function(prop){var field=prop.field,isError=prop.isError;this.searchableFields=this.searchableFields.map((function(searchField){return searchField.name===field.name?_objectSpread2$1$1(_objectSpread2$1$1({},searchField),{},{isError:isError}):searchField}))},updateFilter:function(updatedField,filter){this.filtersFields=this.filtersFields.map((function(field){return field.name===updatedField.name?_objectSpread2$1$1(_objectSpread2$1$1({},field),{},{filterObj:filter}):field}))},removeAddFilter:function(checked,updatedField){checked||(this.filtersFields=this.filtersFields.map((function(field){return field.name===updatedField.name?_objectSpread2$1$1(_objectSpread2$1$1({},field),{},{filterObj:{}}):field})))},constructFilters:function(){var appliedFilters=this.appliedFilters,fields=this.fields,deserializedFields=fields.map((function(field){var clonedField=JSON.parse(JSON.stringify(field)),isMultiSupported=isLookupField$1(field)||isLookupPopupField$1(field)||isMultiLookupField$1(field);// Have to open multi support
if(isMultiSupported&&(
// To allow user to pick multiple values
clonedField.multiple=!0),isEmpty$5(appliedFilters))clonedField.canShowCriteria=!1,clonedField.filterObj={};else{var name=clonedField.name,filter=appliedFilters[name];clonedField.canShowCriteria=!1,isEmpty$5(filter)||(clonedField.filterObj={},clonedField.filterObj=filter,isMultiSupported||(clonedField.filterObj=_objectSpread2$1$1(_objectSpread2$1$1({},filter),{},{value:filter.value.toString()})),clonedField.canShowCriteria=!0)}return clonedField}));this.searchableFields=deserializedFields||[],this.filtersFields=JSON.parse(JSON.stringify(deserializedFields))},applyFilter:function(){var filtersFields=this.filtersFields,$refs=this.$refs,filters={},isNotValid=!1;filtersFields.forEach((function(field){var sanitizedObj,filterObj=field.filterObj,name=field.name,_ref6=$refs["".concat(name)]||[],_ref7=_slicedToArray$1(_ref6,1),criteriaComp=_ref7[0];if(isEmpty$5(criteriaComp)||(isNotValid=!criteriaComp.validate()||isNotValid),!isEmpty$5(filterObj)){var filterValue,_filterObj$value=filterObj.value,value=void 0===_filterObj$value?{}:_filterObj$value;if(isEmpty$5(value)?sanitizedObj=_objectSpread2$1$1({},filterObj):(filterValue=isArray$1(value)?value.map(String):[value],sanitizedObj=_objectSpread2$1$1(_objectSpread2$1$1({},filterObj),{},{value:filterValue})),!isEmpty$5(filterObj)){var _ref8=filterObj||{},operatorId=_ref8.operatorId;isEmpty$5(operatorId)||(filters=_objectSpread2$1$1(_objectSpread2$1$1({},filters),{},_defineProperty$2$1({},name,sanitizedObj)))}}})),isNotValid||this.$emit("applyFilters",filters)}}};
/* script */const __vue_script__$1$1$1=script$1$1$1;
/* template */var __vue_render__$1$1$1=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"f-advanced-search-container"},[_c("div",{staticClass:"f-dialog-search-container",staticStyle:{margin:"8px 0"}},[_c("Input",{staticClass:"f-search-box",attrs:{type:"search",autofocus:!1,placeholder:"Search Fields","prefix-icon":"el-icon-search"},model:{value:_vm.searchtext,callback:function($$v){_vm.searchtext=$$v},expression:"searchtext"}})],1),_vm._v(" "),_vm.loading?_vm._e():_c("div",{staticClass:"f-field-container",staticStyle:{margin:"8px"}},_vm._l(_vm.filteredFields,(function(field,index){return _c("div",{key:index,staticClass:"field-item"},[_c("div",{staticClass:"field-label"},[_c("Checkbox",{on:{change:function(checked){return _vm.removeAddFilter(checked,field)}},model:{value:field.canShowCriteria,callback:function($$v){_vm.$set(field,"canShowCriteria",$$v)},expression:"field.canShowCriteria"}},[_c("div",{staticClass:"name"},[_vm._v(_vm._s(field.displayName))])]),_vm._v(" "),field.canShowCriteria?_c("div",{staticClass:"field-search-criteria"},[_c("OperatorValues",{ref:""+field.name,refInFor:!0,attrs:{field:field,operators:_vm.operators,account:_vm.account},on:{updateFilter:function(filter){return _vm.updateFilter(field,filter)},isError:_vm.setError},model:{value:field.filterObj,callback:function($$v){_vm.$set(field,"filterObj",$$v)},expression:"field.filterObj"}})],1):_vm._e()],1)])})),0),_vm._v(" "),_c("div",{staticClass:"btn-container"},[_c("Button",{staticClass:"form-btn f13 bold secondary text-center text-uppercase",on:{click:function($event){return _vm.$emit("closeDialog")}}},[_vm._v("Cancel")]),_vm._v(" "),_c("Button",{staticClass:"form-btn f13 bold primary m0 text-center text-uppercase",attrs:{type:"primary"},on:{click:function($event){return _vm.applyFilter()}}},[_vm._v("\n      Apply\n    ")])],1)])},__vue_staticRenderFns__$1$1$1=[];
/* style */
const __vue_inject_styles__$1$1$1=function(inject){inject&&inject("data-v-7b036494_0",{source:".f-advanced-search-container{width:100%;height:100%;display:flex;flex-direction:column;flex-wrap:nowrap}.f-advanced-search-container .f-dialog-search-container .f-search-box .el-input__inner{height:40px;border-radius:0;padding:15px 40px!important;font-size:14px;letter-spacing:.4px;color:#324056;text-overflow:ellipsis;white-space:nowrap;background:#fff!important;width:100%!important;outline:0;border:1px solid #dcdfe6}.f-advanced-search-container .f-dialog-search-container .f-search-box .el-input__prefix{left:15px}.f-advanced-search-container .f-dialog-search-container .f-search-box .el-input__prefix .el-input__icon{line-height:28px!important}.f-advanced-search-container .f-field-container{overflow:scroll;height:90%!important;margin:8px 0;padding:0 8px}.f-advanced-search-container .f-field-container .field-search-criteria{margin:8px 0}.f-advanced-search-container .f-field-container .field-item{margin-bottom:25px}.f-advanced-search-container .f-field-container .field-item .field-label{display:flex;margin-bottom:10px;flex-direction:column;padding:0 4px}.f-advanced-search-container .f-field-container .field-item .field-label .el-checkbox{display:flex;cursor:pointer!important}.f-advanced-search-container .f-field-container .field-item .field-label .name{padding-left:15px;font-size:14px;letter-spacing:.5px;color:#324056}.f-advanced-search-container .btn-container{display:flex}.f-advanced-search-container .btn-container .form-btn{flex:1 1 100%;padding-top:20px;padding-bottom:20px;border:none;letter-spacing:1.1px;text-align:center;text-transform:uppercase}.f-advanced-search-container .btn-container .form-btn.primary{background-color:#39b2c2;color:#fff;border-radius:0}.f-advanced-search-container .btn-container .form-btn.secondary{background-color:#f4f4f4;color:#8f8f8f}",map:void 0,media:void 0})},__vue_scope_id__$1$1$1=void 0,__vue_module_identifier__$1$1$1=void 0,__vue_is_functional_template__$1$1$1=!1,__vue_component__$1$1$1=normalizeComponent$3$2({render:__vue_render__$1$1$1,staticRenderFns:__vue_staticRenderFns__$1$1$1},__vue_inject_styles__$1$1$1,__vue_script__$1$1$1,__vue_scope_id__$1$1$1,__vue_is_functional_template__$1$1$1,__vue_module_identifier__$1$1$1,!1,createInjector$3,void 0,void 0);
/* scoped */var CloseIcon$1={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{viewBox:"0 0 512 512",xmlns:"http://www.w3.org/2000/svg"}},[_c("path",{attrs:{d:"M309.582 257.554l185.1-188.733c14.782-15.057 14.782-39.478 0-54.534-14.767-15.072-38.702-15.072-53.484 0l-185.1 188.733L70.98 14.286c-14.75-15.073-38.718-15.073-53.484 0-14.767 15.057-14.767 39.478 0 54.534l185.116 188.734L17.088 446.721c-14.782 15.072-14.782 39.478 0 54.534 7.383 7.544 17.066 11.308 26.75 11.308 9.667 0 19.35-3.764 26.735-11.308L256.097 312.09l185.101 188.735c7.4 7.528 17.067 11.308 26.75 11.308 9.668 0 19.351-3.78 26.735-11.308 14.782-15.057 14.782-39.462 0-54.534l-185.1-188.736z"}})])}},script$8$2=_objectSpread2$1$1(_objectSpread2$1$1({components:{CloseIcon:CloseIcon$1,Tooltip:element_ui_common.Tooltip,Dropdown:element_ui_common.Dropdown,DropdownMenu:element_ui_common.DropdownMenu,DropdownItem:element_ui_common.DropdownItem},props:["moduleName","searchParam","filters","hideQuery","hideSaveAs"],computed:{checkDropDownExists:function(){var dropDownTags=this.dropDownTags;return!isEmpty$5(dropDownTags)},showTags:function(){var tagsArr=this.tagsArr;return!isEmpty$5(tagsArr)},firstThreeTags:function(){var tagsArr=this.tagsArr;return tagsArr.slice(0,3)},dropDownTags:function(){var tagsArr=this.tagsArr;return tagsArr.slice(3)},appliedFilters:function(){var searchParam=this.searchParam,hideQuery=this.hideQuery,filters=this.filters;return hideQuery?filters:isEmpty$5(searchParam)?null:JSON.parse(searchParam)}},watch:{appliedFilters:function(){this.constructTags()}},data:function(){return{tagsArr:[],fields:[],account:null,operatorsList:[]}},created:function(){var _this=this;return _asyncToGenerator$1(_regeneratorRuntime$1().mark((function _callee(){return _regeneratorRuntime$1().wrap((function(_context){while(1)switch(_context.prev=_context.next){case 0:_this.init();case 1:case"end":return _context.stop()}}),_callee)})))()},methods:{init:function(){var _this2=this;return _asyncToGenerator$1(_regeneratorRuntime$1().mark((function _callee2(){var _yield$Promise$all,_yield$Promise$all2,fields,account,operators;return _regeneratorRuntime$1().wrap((function(_context2){while(1)switch(_context2.prev=_context2.next){case 0:return _context2.next=2,Promise.all([_this2.loadFields(),_this2.fetchAccount(),_this2.loadOperators()]);case 2:_yield$Promise$all=_context2.sent,_yield$Promise$all2=_slicedToArray$1(_yield$Promise$all,3),fields=_yield$Promise$all2[0],account=_yield$Promise$all2[1],operators=_yield$Promise$all2[2],_this2.fields=fields,_this2.account=account,_this2.operatorsList=operators,_this2.constructTags();case 11:case"end":return _context2.stop()}}),_callee2)})))()},loadFields:function(){var _this3=this;return _asyncToGenerator$1(_regeneratorRuntime$1().mark((function _callee3(){var moduleName,url,_yield$API$get,data,error,_ref,_ref$message,message,_ref2,fields;return _regeneratorRuntime$1().wrap((function(_context3){while(1)switch(_context3.prev=_context3.next){case 0:return moduleName=_this3.moduleName,url="/v2/filter/advanced/fields/".concat(moduleName),_context3.next=4,api/* API */.bl.get(url);case 4:if(_yield$API$get=_context3.sent,data=_yield$API$get.data,error=_yield$API$get.error,!error){_context3.next=12;break}_ref=error||{},_ref$message=_ref.message,message=void 0===_ref$message?"Error occured":_ref$message,_this3.$message.error(message),_context3.next=14;break;case 12:return _ref2=data||{},fields=_ref2.fields,_context3.abrupt("return",fields);case 14:case"end":return _context3.stop()}}),_callee3)})))()},fetchAccount:function(){var _this4=this;return _asyncToGenerator$1(_regeneratorRuntime$1().mark((function _callee4(){var _yield$API$get2,data,error,_ref3,account;return _regeneratorRuntime$1().wrap((function(_context4){while(1)switch(_context4.prev=_context4.next){case 0:return _context4.next=2,api/* API */.bl.get("/v2/fetchAccount");case 2:if(_yield$API$get2=_context4.sent,data=_yield$API$get2.data,error=_yield$API$get2.error,!error){_context4.next=9;break}_this4.$message.error(error||"Error Occured"),_context4.next=11;break;case 9:return _ref3=data||{},account=_ref3.account,_context4.abrupt("return",account);case 11:case"end":return _context4.stop()}}),_callee4)})))()},loadOperators:function(){var _this5=this;return _asyncToGenerator$1(_regeneratorRuntime$1().mark((function _callee5(){var url,_yield$API$get3,data,error,_ref4,_ref4$message,message,_ref5,operators;return _regeneratorRuntime$1().wrap((function(_context5){while(1)switch(_context5.prev=_context5.next){case 0:return url="v2/filter/advanced/operators",_context5.next=3,api/* API */.bl.get(url);case 3:if(_yield$API$get3=_context5.sent,data=_yield$API$get3.data,error=_yield$API$get3.error,!error){_context5.next=11;break}_ref4=error||{},_ref4$message=_ref4.message,message=void 0===_ref4$message?"Error Occured":_ref4$message,_this5.$message.error(message),_context5.next=14;break;case 11:if(_ref5=data||{},operators=_ref5.operators,isEmpty$5(operators)){_context5.next=14;break}return _context5.abrupt("return",operators);case 14:case"end":return _context5.stop()}}),_callee5)})))()},checkSize:function(tag){var string="".concat(tag.fieldDisplayName," ").concat(tag.operatorDisplayName," ").concat(tag.valueStr),font="13px Arial",canvas=document.createElement("canvas"),context=canvas.getContext("2d");context.font=font;var width=context.measureText(string+", ").width,formattedWidth=Math.ceil(width);return!(formattedWidth>250)},isValueArray:function(tag){var _ref6=tag||{},valueStr=_ref6.valueStr;return isArray$1(valueStr)&&1!==valueStr.length},tagValue:function(tag){var _ref7=tag||{},valueStr=_ref7.valueStr;return isArray$1(valueStr)?valueStr[0]:valueStr},constructTags:function(){var _this6=this;return _asyncToGenerator$1(_regeneratorRuntime$1().mark((function _callee6(){var _this6$fields,fields,operatorsList,filters,labelMeta,lookupFieldsArr,tagsArr,isTagsConstructable;return _regeneratorRuntime$1().wrap((function(_context6){while(1)switch(_context6.prev=_context6.next){case 0:if(_this6$fields=_this6.fields,fields=void 0===_this6$fields?[]:_this6$fields,operatorsList=_this6.operatorsList,filters=_this6.appliedFilters,labelMeta={},lookupFieldsArr=[],tagsArr=[],isTagsConstructable=!isEmpty$5(filters)&&!isEmpty$5(operatorsList)&&!isEmpty$5(fields),isTagsConstructable&&Object.entries(filters).forEach((function(_ref8){var _ref9=_slicedToArray$1(_ref8,2),key=_ref9[0],value=_ref9[1],tagObj={};key=key.split("__")[0];var valueStr="",_ref10=value||{},valueArr=_ref10.value,operatorId=_ref10.operatorId,selectedField=_this6.getSelectedField({fields:fields,fieldName:key}),isLookupField$1$1=isLookupField$1(selectedField)||isLookupPopupField$1(selectedField)||isMultiLookupField$1(selectedField),selectedOperator=_this6.getSelectedOperator({selectedField:selectedField,operatorId:operatorId});isLookupField$1$1&&(labelMeta=_this6.constructLabelMeta({selectedField:selectedField,lookupFieldsArr:lookupFieldsArr,labelMeta:labelMeta,valueArr:valueArr,selectedOperator:selectedOperator}));var operatorDisplayName=_this6.getOperatorDisplayName({operator:selectedOperator}),isDefaultOperator=!isEmpty$5(selectedOperator.defaultValue),fieldDisplayName=selectedField.displayName;isDefaultOperator||(valueStr=_this6.getValueString({valueArr:valueArr,selectedField:selectedField,isLookupField:isLookupField$1$1,operator:selectedOperator})),tagObj={fieldName:key,fieldDisplayName:fieldDisplayName,operatorDisplayName:operatorDisplayName,valueStr:valueStr},"drillDownPattern"!=key&&tagsArr.push(tagObj)})),isEmpty$5(labelMeta)){_context6.next=10;break}return _context6.next=9,_this6.fetchLookupLabels({labelMeta:labelMeta,lookupFieldsArr:lookupFieldsArr,tagsArr:tagsArr});case 9:tagsArr=_context6.sent;case 10:_this6.tagsArr=tagsArr;case 11:case"end":return _context6.stop()}}),_callee6)})))()},getSelectedField:function(props){var fields=props.fields,fieldName=props.fieldName,selectedField=fields.find((function(field){return field.name===fieldName}));return selectedField||{}},getSelectedOperator:function(props){var operatorsList=this.operatorsList,operatorId=props.operatorId,selectedField=props.selectedField,_ref11=selectedField||{},dataType=_ref11.dataType,_ref11$operators=_ref11.operators,operators=void 0===_ref11$operators?[]:_ref11$operators,selectedOperator=operatorsList[dataType]||[];return isEmpty$5(operators)||(selectedOperator=selectedOperator.concat(operators)),selectedOperator.find((function(operator){return operator.operatorId===operatorId}))||{}},constructLabelMeta:function(props){var selectedField=props.selectedField,lookupFieldsArr=props.lookupFieldsArr,labelMeta=props.labelMeta,valueArr=props.valueArr,_props$selectedOperat=props.selectedOperator,selectedOperator=void 0===_props$selectedOperat?{}:_props$selectedOperat,name=this.getLookupModuleName({field:selectedField,operator:selectedOperator});// Have to construct the label meta keys from lookup module name
// either from the operator or from the field
lookupFieldsArr.push(selectedField);var selectedModule=labelMeta[name];if(isEmpty$5(selectedModule))labelMeta[name]=valueArr||[];else{var ids=labelMeta[name];labelMeta[name]=ids.concat(valueArr)}return labelMeta},getLookupModuleName:function(_ref12){var operator=_ref12.operator,field=_ref12.field,fieldLookupModule=dlv_umd(field,"lookupModule.name"),operatorLookupModule=dlv_umd(operator,"lookupModule.name");return isEmpty$5(operatorLookupModule)?fieldLookupModule:operatorLookupModule},getOperatorDisplayName:function(props){var operator=props.operator,_ref13=operator||{},tagDisplayName=_ref13.tagDisplayName,displayName=_ref13.displayName,operatorId=_ref13.operatorId;return[dateTimeOperator$1[operatorId]].includes(displayName)?"is":tagDisplayName||displayName},getValueString:function(props){var _this7=this,valueArr=props.valueArr,selectedField=props.selectedField,isLookupField=props.isLookupField,operator=props.operator,operatorId=operator.operatorId,operatorDisplayName=operator.displayName;if(!isEmpty$5(valueArr)){var valueStr="",isPicklistOrBoolean=this.isPicklistOrBoolean(selectedField),isDateTypeField$1$1=isDateTypeField$1(selectedField);if(isDateTypeField$1$1){if(valueStr=valueArr.reduce((function(acc,value,index){if([dateTimeOperator$1[operatorId]].includes(operatorDisplayName)){if([106,107,84,85].includes(operatorId))if(84===operatorId){var currentMonth=_this7.MONTHS.find((function(month){month.value==value&&currentMonth.push(month.label)}));acc+="".concat(currentMonth)}else acc+=85===operatorId?"".concat(_this7.WEEK_DAYS[value]):value;else acc+="".concat(value).concat(1==value?"st":2==value?"nd":3==value?"rd":"th");return acc+=index!==valueArr.length-1?", ":" ",acc}var dateStr=_this7.formatDate(Number(value),!0,!1);return isEmpty$5(acc)?"".concat(dateStr):"".concat(acc,", ").concat(dateStr)}),""),[dateTimeOperator$1[operatorId]].includes(operatorDisplayName))if([106,107].includes(operatorId)){var operatorIdKey={106:"Before",107:"After"};valueStr="".concat(operatorIdKey[operatorId]||""," ").concat(valueStr," days")}else[84,85].includes(operatorId)||(valueStr+="".concat(operatorDisplayName))}else if(isPicklistOrBoolean){var options=selectedField.options;isEmpty$5(options)||(valueStr=this.constructLabelString(valueArr,options))}else{if(isLookupField)return valueArr;valueStr=valueArr.reduce((function(acc,value){return isEmpty$5(acc)?"".concat(value):"".concat(acc,", ").concat(value)}),"")}return'"'.concat(valueStr,'"')}return""},isPicklistOrBoolean:function(field){var _ref14=field||{},displayType=_ref14.displayType;return["SELECTBOX","DECISION_BOX"].includes(displayType)},constructLabelString:function(){var valueArr=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],options=arguments.length>1?arguments[1]:void 0,valueStr="";return isArray$1(valueArr)&&(valueStr=valueArr.reduce((function(acc,value){var _ref15=options.find((function(option){return String(option.value)===value}))||{},_ref15$label=_ref15.label,label=void 0===_ref15$label?"Invalid":_ref15$label;return isEmpty$5(acc)?"".concat(label):"".concat(acc,", ").concat(label)}),"")),valueStr},fetchLookupLabels:function(props){var _this8=this;return _asyncToGenerator$1(_regeneratorRuntime$1().mark((function _callee7(){var labelMeta,lookupFieldsArr,tagsArr,_yield$API$post,data,error,_error$message,message,_ref16,label;return _regeneratorRuntime$1().wrap((function(_context7){while(1)switch(_context7.prev=_context7.next){case 0:return labelMeta=props.labelMeta,lookupFieldsArr=props.lookupFieldsArr,tagsArr=props.tagsArr,_context7.next=3,api/* API */.bl.post("/v2/picklist/label",{labelMeta:labelMeta});case 3:return _yield$API$post=_context7.sent,data=_yield$API$post.data,error=_yield$API$post.error,error?(_error$message=error.message,message=void 0===_error$message?"Error Occurred":_error$message,_this8.$message.error(message)):(_ref16=data||{},label=_ref16.label,tagsArr=tagsArr.map((function(tag){var fieldName=tag.fieldName,valueStr=tag.valueStr,lookupField=lookupFieldsArr.find((function(field){return field.name===fieldName}));if(lookupField){
// Have to get the value labels from lookup module name
// either from the operator or from the field
var fields=_this8.fields,filters=_this8.appliedFilters,field=_this8.getSelectedField({fields:fields,fieldName:fieldName}),currentFiter=filters[fieldName],operatorId=currentFiter.operatorId,operator=_this8.getSelectedOperator({selectedField:field,operatorId:operatorId}),name=_this8.getLookupModuleName({operator:operator,field:field}),moduleLabels=label[name]||[],labelArray=_this8.constructLabelString(valueStr,moduleLabels);tag.valueStr=labelArray}return tag}))),_context7.abrupt("return",tagsArr);case 8:case"end":return _context7.stop()}}),_callee7)})))()},formatDate:function(date,excludeTime,onlyTime){var dateformat=this.account.org.dateFormat,timeformat=this.account.org.timeFormat,timezone=this.account.org.timezone?this.account.org.timezone:"Etc/UTC";return onlyTime?moment_timezone(date).tz(timezone).format(timeformat):excludeTime?moment_timezone(date).tz(timezone).format(dateformat):moment_timezone(date).tz(timezone).format(dateformat+" "+timeformat)},clearFilter:function(tag){var appliedFilters=this.appliedFilters,hideQuery=this.hideQuery,filtersObj=this.filters,filters=deepClean(appliedFilters)||{},fieldName=tag.fieldName;isEmpty$5(fieldName)||delete filters[fieldName],hideQuery&&!isEmpty$5(filtersObj)?this.$emit("updateFilters",filters):isEmpty$5(filters)?this.$emit("resetFilters",filters):this.$emit("applyFilters",filters)}}},MONTHS$1),WEEK_DAYS$1);
/* script */
const __vue_script__$8$2=script$8$2;
/* template */var __vue_render__$8$2=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _vm.showTags?_c("div",{staticClass:"tags-container"},[_vm._l(_vm.firstThreeTags,(function(tag,index){return _c("div",{key:index,ref:index,refInFor:!0},[_c("Tooltip",{attrs:{placement:"bottom-start",disabled:_vm.checkSize(tag)}},[_c("div",{staticClass:"f-tag-content",attrs:{slot:"content"},slot:"content"},[_vm._v("\n        "+_vm._s(tag.fieldDisplayName)+" "+_vm._s(tag.operatorDisplayName)+"\n        "+_vm._s(tag.valueStr)+"\n      ")]),_vm._v(" "),_c("div",{staticClass:"tag"},[_c("div",[_vm._v(_vm._s(tag.fieldDisplayName))]),_vm._v(" "),_c("div",{staticClass:"ftag-operator"},[_vm._v("\n          "+_vm._s(tag.operatorDisplayName)+"\n        ")]),_vm._v(" "),_c("div",{staticClass:"ftag-value-container"},[_vm._v("\n          "+_vm._s(tag.valueStr)+"\n        ")]),_vm._v(" "),_c("span",{on:{click:function($event){return _vm.clearFilter(tag)}}},[_c("CloseIcon",{staticClass:"ftag-close-icon"})],1)])])],1)})),_vm._v(" "),_vm.checkDropDownExists?_c("div",[_c("Dropdown",[_c("div",{staticClass:"tag"},[_vm._v("+"+_vm._s(_vm.dropDownTags.length))]),_vm._v(" "),_c("DropdownMenu",{staticClass:"f-tags-dropdown",attrs:{slot:"dropdown"},slot:"dropdown"},_vm._l(_vm.dropDownTags,(function(tag,index){return _c("DropdownItem",{key:index},[_c("Tooltip",{attrs:{placement:"right",disabled:_vm.checkSize(tag)}},[_c("div",{staticClass:"f-tag-content",attrs:{slot:"content"},slot:"content"},[_vm._v("\n              "+_vm._s(tag.fieldDisplayName)+" "+_vm._s(tag.operatorDisplayName)+"\n              "+_vm._s(tag.valueStr)+"\n            ")]),_vm._v(" "),_c("div",{staticClass:"dropdown-tag"},[_c("div",[_vm._v(_vm._s(tag.fieldDisplayName))]),_vm._v(" "),_c("div",{staticClass:"ftag-operator"},[_vm._v("\n                "+_vm._s(tag.operatorDisplayName)+"\n              ")]),_vm._v(" "),_c("div",{staticClass:"ftag-value-container"},[_vm._v("\n                "+_vm._s(tag.valueStr)+"\n              ")]),_vm._v(" "),_c("span",{on:{click:function($event){return _vm.clearFilter(tag)}}},[_c("CloseIcon",{staticClass:"ftag-close-icon"})],1)])])],1)})),1)],1)],1):_vm._e(),_vm._v(" "),_c("div",{staticClass:"btn-container"},[_c("Button",{staticClass:"tag-btn",on:{click:function($event){return _vm.$emit("clearFilters",!0)}}},[_vm._v("Clear all")]),_vm._v(" "),_c("Button",{directives:[{name:"show",rawName:"v-show",value:!_vm.hideSaveAs,expression:"!hideSaveAs"}],staticClass:"tag-btn"},[_vm._v("Save As")])],1)],2):_vm._e()},__vue_staticRenderFns__$8$2=[];
/* style */
const __vue_inject_styles__$8$2=function(inject){inject&&inject("data-v-5bcf0612_0",{source:".ftag-value-container[data-v-5bcf0612]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ftag-close-icon[data-v-5bcf0612]{height:10px;width:10px;margin-left:8px;cursor:pointer}.f-tag-content[data-v-5bcf0612]{max-width:250px;font-size:13px;background:#303133;color:#fff;padding:4px 8px;border-radius:4px}.ftag-operator[data-v-5bcf0612]{margin:0 4px;color:#324056;font-size:13px;font-weight:400}.tags-container[data-v-5bcf0612]{background:#fff;border:solid 1px #ececec;margin:10px;padding:8px 4px;display:flex;flex-wrap:wrap;box-sizing:border-box;gap:12px}.tags-container .tag[data-v-5bcf0612]{cursor:pointer;display:flex;border-radius:14px;border:solid 1px #3ab2c1;background-color:#fff;color:#324056;font-size:13px;font-weight:500;height:24px;align-items:center;padding:6px 10px;box-sizing:border-box;margin-bottom:0!important;margin-right:0!important;max-width:330px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.tags-container .tag-btn[data-v-5bcf0612]{height:24px;margin:0 8px;padding:0 8px;border-radius:14px;border:solid 1px #3ab2c1;background-color:#f7feff;cursor:pointer}.el-dropdown-link[data-v-5bcf0612]{cursor:pointer}.el-dropdown-menu.el-popper.f-tags-dropdown[data-v-5bcf0612]{list-style:none;width:250px;max-height:165px;overflow:scroll;box-shadow:0 1px 5px 0 rgba(0,0,0,.16);background-color:#fff;padding-inline-start:0}.el-dropdown-menu.el-popper.f-tags-dropdown li.el-dropdown-menu__item[data-v-5bcf0612]{padding:0!important}.el-dropdown-menu.el-popper.f-tags-dropdown li .dropdown-tag[data-v-5bcf0612]{background-color:#fff;color:#324056;font-size:13px;font-weight:500;cursor:pointer;box-sizing:border-box;width:100%;height:40px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:13px;background-color:#fff;display:flex;align-items:center;padding:4px}.el-dropdown-menu.el-popper.f-tags-dropdown li .dropdown-tag[data-v-5bcf0612]:hover{background-color:#fafafa}.el-dropdown-menu.el-popper.f-tags-dropdown li .dropdown-tag span[data-v-5bcf0612]{flex-grow:1;text-align:right}",map:void 0,media:void 0})},__vue_scope_id__$8$2="data-v-5bcf0612",__vue_module_identifier__$8$2=void 0,__vue_is_functional_template__$8$2=!1,__vue_component__$7$2=normalizeComponent$3$2({render:__vue_render__$8$2,staticRenderFns:__vue_staticRenderFns__$8$2},__vue_inject_styles__$8$2,__vue_script__$8$2,__vue_scope_id__$8$2,__vue_is_functional_template__$8$2,__vue_module_identifier__$8$2,!1,createInjector$3,void 0,void 0);
/* scoped */var AdvancedSearch$1=__vue_component__$1$1$1,FTags$1=__vue_component__$7$2;const LOOKUP_FILTERS_MAP$1={1:"building",2:"asset",3:"tenantcontact",4:"clientcontact",5:"vendorcontact",6:"employee"},RESOURCE_MODULE_HASH$1={resource:["asset","site","building","floor","space"],basespace:["site","building","floor","space"]};
var script$7$2={props:["canShowLookupWizard","field","siteId"],components:{Dialog:element_ui_common.Dialog,CommonList:__vue_component__$f,Spinner:__vue_component__$c,Pagination:__vue_component__$e,Radio:element_ui_common.Radio,Tag:element_ui_common.Tag,Button:element_ui_common.Button,TextInput:__vue_component__$j,EmptyIcon:EmptyIcon$1,AdvancedFilterIcon:AdvancedFilterIcon,AdvancedSearch:AdvancedSearch$1,FTags:FTags$1,Select:element_ui_common.Select,Option:element_ui_common.Option},data:()=>({isLoading:!1,viewDetail:null,moduleList:[],perPage:10,page:1,totalCount:0,selectedItem:[],search:"",resourceModuleName:"basespace",criteria:{},showAdvWizard:!1,operators:[],filters:{},subModuleName:"",resourceSubModules:[]}),watch:{async page(){this.isLoading=!0,await this.fetchModuleList(),this.isLoading=!1},async filters(){this.loading=!0,await this.fetchModuleList(),this.loading=!1},moduleName:{handler(newVal,oldVal){isEmpty$5(RESOURCE_MODULE_HASH$1[newVal])&&this.loadData()},immediate:!0},isLoading(newVal){!newVal&&this.multiSelect&&this.toggleSelection()}},computed:{trueMainfield(){let{viewDetail:viewDetail}=this,mainField=null;if(!isEmpty$5(viewDetail)){let{fields:fields}=viewDetail;mainField=(fields||[]).find((field=>{let{field:fieldObj}=field;return(fieldObj||{}).mainField}))}return mainField},isResourceModule(){let{field:field}=this,{config:config}=field,{isFiltersEnabled:isFiltersEnabled}=config||{};if(isFiltersEnabled)return!1;let displayName=dlv_umd(field,"field.lookupModule.name","");return isEmpty$5(displayName)&&(displayName=dlv_umd(field,"lookupModule.name","")),!isEmpty$5(RESOURCE_MODULE_HASH$1[displayName])&&(this.subModuleName=RESOURCE_MODULE_HASH$1[displayName][0],this.resourceSubModules=RESOURCE_MODULE_HASH$1[displayName],!0)},mainField(){let{viewDetail:viewDetail}=this,mainField=null;if(!isEmpty$5(viewDetail)){let{fields:fields}=viewDetail;mainField=(fields||[]).find((field=>{let{field:fieldObj}=field;return(fieldObj||{}).mainField}))}return isEmpty$5(mainField)&&(mainField={name:"name",displayName:"Name",field:{name:"name",dataTypeEnum:"STRING"}}),mainField},mainFieldName(){let{mainField:mainField}=this||{},{name:name}=mainField||{};return isEmpty$5(name)&&(name=dlv_umd(mainField,"field.name","")),name},canShowWizard:{get(){return this.canShowLookupWizard},set(value){this.$emit("update:canShowLookupWizard",value)}},moduleDisplayName(){let{field:field}=this,displayName=dlv_umd(field,"field.lookupModule.displayName","");return isEmpty$5(displayName)&&(displayName=dlv_umd(field,"lookupModule.displayName","")),displayName},moduleName(){let{field:field,subModuleName:subModuleName}=this,{config:config}=field,{isFiltersEnabled:isFiltersEnabled,filterValue:filterValue,lookupModuleName:configLookupModuleName}=config||{};if(isFiltersEnabled)return configLookupModuleName||LOOKUP_FILTERS_MAP$1[filterValue];let displayName=dlv_umd(field,"field.lookupModule.name","");return isEmpty$5(displayName)&&(displayName=dlv_umd(field,"lookupModule.name","")),isEmpty$5(subModuleName)||(displayName=subModuleName),displayName},title(){let{moduleDisplayName:moduleDisplayName}=this;return`Choose ${moduleDisplayName}`},multiSelect(){let{field:field}=this,{multiple:multiple}=field||{};return multiple},selectedLabel(){let{moduleDisplayName:moduleDisplayName}=this;return`Selected ${moduleDisplayName} `},selectedItemName(){let{selectedItem:selectedItem}=this||{},selectedItemNames=(selectedItem||[]).map((list=>list.label));return isEmpty$5(selectedItemNames)?null:selectedItemNames},selectedItemId:{get(){let{selectedItem:selectedItem,multiSelect:multiSelect}=this||{},selectedItemIds=(selectedItem||[]).map((list=>list.value));return multiSelect?selectedItemIds:selectedItemIds[0]},set(val){let{moduleList:moduleList,multiSelect:multiSelect}=this||{};multiSelect||Array.isArray(val)||(val=[val]);let selectedItem=moduleList.filter((item=>val.includes(item.id)));this.selectedItem=selectedItem.map((list=>{let{id:id}=list,{name:name}=this.mainField||{name:"name"},selectedItem={label:list[name],value:id};return selectedItem}))}},slotList(){let{trueMainfield:trueMainfield}=this,label=dlv_umd(this,"trueMainfield.field.displayName","Name"),slots=[{name:"select",isHardcodedColumn:!0,columnAttrs:{fixed:"left",width:"50"}}];if(isEmpty$5(trueMainfield))slots.push({name:"name",isHardcodedColumn:!0,columnAttrs:{fixed:"left",label:label,width:"200"}});else{let{field:field}=trueMainfield,{name:mainFieldName}=field;slots.push({criteria:JSON.stringify({name:mainFieldName})})}return slots}},created(){this.loadOperatorList()},methods:{async loadOperatorList(){let url="v2/filter/advanced/operators",{data:data,error:error}=await api/* API */.bl.get(url);if(error);else{let{operators:operators}=data||{};isEmpty$5(operators)||(this.operators=operators)}},isEmpty(val){return isEmpty$5(val)},applyFilters(filters){this.filters=filters,this.showAdvWizard=!1},getMainFieldValue(record={}){let{mainField:mainField}=this||{},{field:field}=mainField||{},{name:name}=field||{};return record[name]||record.name},setResourceModule(val){this.subModuleName=val},loadData(){let promise=[];this.moduleName&&(this.initSelectedItem(),promise.push(this.fetchViewDetail()),promise.push(this.fetchModuleList()),this.isLoading=!0,Promise.all(promise).finally((()=>{this.isLoading=!1})))},async fetchViewDetail(){let{moduleName:moduleName}=this,url="v2/views/hidden-all",{data:data,error:error}=await api/* API */.bl.get(url,{moduleName:moduleName});if(isEmpty$5(error)){let{viewDetail:viewDetail}=data||{},{fields:fields}=viewDetail||{};fields=fields.map((field=>{let{field:fieldObj,name:name=""}=field||{},{mainField:mainField}=fieldObj||{};return mainField?{...field,columnAttrs:{fixed:"left",width:"200"}}:field})),isEmpty$5(viewDetail)||this.$set(this,"viewDetail",{...viewDetail,fields:fields})}},async fetchModuleList(){this.isLoading=!0;let filterObj={},{moduleName:moduleName,page:page,perPage:perPage,siteId:siteId}=this||{},{filters:filters,field:field}=this||{},{config:config,filters:fieldFilters}=field||{},{skipSiteFilter:skipSiteFilter}=config||{};skipSiteFilter||isEmpty$5(siteId)||(filterObj={siteId:{operatorId:36,value:[`${siteId}`]}}),isEmpty$5(fieldFilters)||(filterObj={...filterObj,...fieldFilters}),isEmpty$5(filters)||(filterObj={...filterObj,...filters});let params={viewname:"hidden-all",includeParentFilter:!0,page:page,perPage:perPage,withCount:!0};isEmpty$5(filterObj)||(params["filters"]=JSON.stringify(filterObj));let{list:list,error:error,meta:meta}=await api/* API */.bl.fetchAll(moduleName,params);isEmpty$5(error)&&(this.moduleList=list,this.totalCount=dlv_umd(meta,"pagination.totalCount",0)),this.isLoading=!1},onSearchChange:debounce((async function(value){this.onSearch(value)}),700),async onSearch(value){if(this.isLoading=!0,isEmpty$5(value))await this.fetchModuleList();else{let{mainFieldName:mainFieldName}=this||{};("basespace"==this.moduleName||"asset"==this.moduleName)&&(mainFieldName="name");let filters={[mainFieldName]:{operatorId:5,value:[value]}};await this.fetchModuleList({filters:filters})}this.isLoading=!1},initSelectedItem(){let{field:field}=this,{selectedItems:selectedItems=[]}=field||{};isEmpty$5(selectedItems)||(this.selectedItem=[...selectedItems])},toggleSelection(){this.$nextTick((()=>{let{selectedItemId:selectedItemId}=this,currentSelectedList=this.moduleList.filter((list=>(selectedItemId||[]).includes((list||{}).id))),ref=this.$refs.lookupCommonList;isEmpty$5(ref)||(ref.clearSelection(),currentSelectedList.forEach((item=>{ref.toggleRowSelection(item,!0)})))}))},setSelectedItem(){let{selectedItem:selectedItem,mainField:mainField,selectedItemId:selectedItemId,multiSelect:multiSelect,field:field}=this;multiSelect||(selectedItem=[this.moduleList.find((list=>list.id===selectedItemId))],selectedItem=selectedItem.map((list=>{let{id:id}=list,{name:name}=this.mainField||{name:"name"},selectedItem={label:list[name],value:id};return selectedItem}))),isEmpty$5(mainField)&&(mainField={name:"name"}),field.selectedItems=selectedItem;let data={field:field};this.$emit("setLookupFieldValue",data),this.canShowWizard=!1},handleSelection(selectedList){let nonCurrentItems=this.getNonCurrentList(this.selectedItem),currentItems=(selectedList||[]).map((list=>{let{id:id}=list,{mainFieldName:mainFieldName}=this||{};return{label:list[mainFieldName],value:id}}));this.selectedItem=[...nonCurrentItems,...currentItems]},getNonCurrentList(selectedList){let{moduleList:moduleList}=this,currentModuleList=selectedList.filter((item=>-1===moduleList.findIndex((list=>list.id===item.value))));return currentModuleList},handleSelectedClose(item){let index=this.selectedItem.findIndex((list=>list.label===item));this.selectedItem.splice(index,1),this.toggleSelection()},closeWizard(){this.canShowWizard=!1},closeAdvWizard(){this.showAdvWizard=!1},applyFilter(){let filters=this.$refs["advancedSearch"].save();this.filters=filters,this.closeAdvWizard()},updateFilters(filters){this.filters=filters}}};
/* script */const __vue_script__$7$2=script$7$2;
/* template */var __vue_render__$7$2=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("Dialog",{staticClass:"f-ui-forms f-ui-lookup-wizard",attrs:{visible:_vm.canShowWizard,width:"70%",top:"5vh","append-to-body":!0,"show-close":!1,"before-close":_vm.closeWizard},on:{"update:visible":function($event){_vm.canShowWizard=$event}}},[_c("template",{slot:"title"},[_vm.isResourceModule?_c("div",{staticClass:"resource-title-container"},[_c("div",{staticClass:"resource-title"},[_vm._v("\n        "+_vm._s(_vm.title)+"\n      ")]),_vm._v(" "),_c("div",{staticClass:"title-seperator"})]):_vm._e(),_vm._v(" "),_c("div",{staticClass:"flex items-center"},[_vm.isResourceModule?_c("div",{staticClass:"lookup-wizard-title"},[_c("Select",{staticClass:"f-ui-select w-full f-ui-select-tag",attrs:{"default-first-option":"",filterable:""},on:{change:_vm.setResourceModule},model:{value:_vm.subModuleName,callback:function($$v){_vm.subModuleName=$$v},expression:"subModuleName"}},_vm._l(_vm.resourceSubModules,(function(module,index){return _c("Option",{key:index,staticClass:"f-ui-select-item width100",attrs:{label:module.toUpperCase(),value:module}})})),1)],1):_c("div",{staticClass:"lookup-wizard-title"},[_vm._v("\n        "+_vm._s(_vm.title)+"\n      ")]),_vm._v(" "),_c("div",{staticClass:"ml-auto flex items-center"},[[_c("div",{on:{click:function($event){_vm.showAdvWizard=!0}}},[_c("AdvancedFilterIcon",{staticClass:"w-4 h-4",staticStyle:{cursor:"pointer"}}),_vm._v(" "),_c("Dialog",{attrs:{visible:_vm.showAdvWizard,"append-to-body":!0,"show-close":!0,fullscreen:!0,"custom-class":"advance-search-dialog",title:"Filter "+_vm.moduleName+" by"},on:{"update:visible":function($event){_vm.showAdvWizard=$event}}},[_c("AdvancedSearch",{ref:"advancedSearch",attrs:{moduleName:_vm.moduleName,hideQuery:!0,filterList:_vm.filters,showAdvWizard:_vm.showAdvWizard},on:{applyFilters:_vm.applyFilters,closeDialog:function($event){_vm.showAdvWizard=!1}}})],1)],1),_vm._v(" "),_c("span",{staticClass:"separator"},[_vm._v("|")])],_vm._v(" "),_c("Pagination",{staticClass:"self-center",attrs:{currentPage:_vm.page,total:_vm.totalCount,perPage:_vm.perPage},on:{"update:currentPage":function($event){_vm.page=$event},"update:current-page":function($event){_vm.page=$event}}}),_vm._v(" "),_vm.totalCount?_c("span",{staticClass:"separator"},[_vm._v("|")]):_vm._e(),_vm._v(" "),_c("div",{staticClass:"el-dialog__close el-icon el-icon-close close-icon cursor-pointer",on:{click:_vm.closeWizard}})],2)])]),_vm._v(" "),_c("div",[_c("FTags",{attrs:{moduleName:_vm.moduleName,filters:_vm.filters,hideQuery:!0,hideSaveAs:!0},on:{updateFilters:_vm.updateFilters,clearFilters:function($event){_vm.filters={}}}})],1),_vm._v(" "),_vm.isLoading?_c("div",{staticClass:"flex justify-center"},[_c("Spinner",{attrs:{show:_vm.isLoading}})],1):_vm.isEmpty(_vm.moduleList)?_c("div",{staticClass:"f-ui-lookup-empty"},[_c("EmptyIcon",{staticClass:"w-40 h-40"}),_vm._v(" "),_c("div",{staticClass:"mT10 label-txt-black text-md"},[_vm._v("\n      No "+_vm._s(_vm.moduleDisplayName?_vm.moduleDisplayName:_vm.moduleName)+"s available\n    ")])],1):_c("div",{staticClass:"f-ui-lookup-table-container"},[_vm.isEmpty(_vm.selectedItemName)?_vm._e():_c("div",{staticClass:"flex items-center ml-5 my-4"},[_c("div",{staticClass:"mr-3"},[_vm._v(_vm._s(_vm.selectedLabel)+":")]),_vm._v(" "),_c("div",{staticClass:"flex flex-wrap w-10/12"},_vm._l(_vm.selectedItemName,(function(name,index){return _c("Tag",{key:index,staticClass:"f-ui-tag flex items-center mr-2 my-1",on:{click:function(){return _vm.handleSelectedClose(name)}}},[_c("span",[_vm._v(_vm._s(name))]),_vm._v(" "),_vm.multiSelect?_c("i",{staticClass:"el-icon-close pointer"}):_vm._e()])})),1)]),_vm._v(" "),_c("span",{staticClass:"loader",attrs:{show:_vm.isLoading}}),_vm._v(" "),_vm.isEmpty(_vm.moduleList)||_vm.isLoading?_vm._e():_c("CommonList",{ref:"lookupCommonList",attrs:{viewDetail:_vm.viewDetail,records:_vm.moduleList,moduleName:_vm.moduleName,slotList:_vm.slotList,hideListSelect:!_vm.multiSelect},on:{"selection-change":_vm.handleSelection},scopedSlots:_vm._u([{key:"select",fn:function(ref){var record=ref.record;return[_vm.multiSelect?_vm._e():_c("Radio",{attrs:{label:record.id},on:{change:_vm.setSelectedItem},model:{value:_vm.selectedItemId,callback:function($$v){_vm.selectedItemId=$$v},expression:"selectedItemId"}})]}},_vm.trueMainField?{key:_vm.slotList[1].criteria,fn:function(ref){var record=ref.record;return[_vm._v("\n        "+_vm._s(_vm.getMainFieldValue(record)))]}}:{key:_vm.slotList[1].name,fn:function(ref){var record=ref.record;return[_vm._v("\n        "+_vm._s(_vm.getMainFieldValue(record)))]}}],null,!0)}),_vm._v(" "),_vm.multiSelect?_c("div",{staticClass:"flex mt-auto"},[_c("Button",{staticClass:"modal-btn-cancel modal-btn",on:{click:_vm.closeWizard}},[_vm._v("\n        Cancel\n      ")]),_vm._v(" "),_c("Button",{staticClass:"modal-btn-save modal-btn",attrs:{type:"primary"},on:{click:_vm.setSelectedItem}},[_vm._v("\n        Save\n      ")])],1):_vm._e()],1)],2)},__vue_staticRenderFns__$7$2=[];
/* style */
const __vue_inject_styles__$7$2=function(inject){inject&&inject("data-v-05178480_0",{source:'.advance-search-dialog.is-fullscreen{width:35%;overflow:hidden;height:100vh;display:flex;flex-direction:column;margin-right:0;margin-top:0}.advance-search-dialog .el-dialog__body{display:flex;flex-direction:column;overflow:scroll;height:100%;padding:0;margin-top:8px}.f-ui-lookup-wizard .resource-title-container .resource-title{height:28px;font-weight:500;font-size:16px}.f-ui-lookup-wizard .resource-title-container .title-seperator{height:1px;margin:0 0 15px;background-color:#ebeff3}.f-ui-lookup-wizard .f-ui-lookup-empty{height:600px;display:flex;flex-direction:column;justify-content:center;align-items:center}.f-ui-lookup-wizard .btn-active{font-size:14px;font-weight:700;letter-spacing:.5px;color:#324056}.f-ui-lookup-wizard .btn-not-active{color:#ccc;font-weight:50}.f-ui-lookup-wizard .el-radio__label{visibility:hidden}.f-ui-lookup-wizard .lookup-wizard-title{font-size:14px;font-weight:700;color:#324056;text-transform:uppercase;line-height:24px}.f-ui-lookup-wizard .lookup-wizard-title .uppercase{text-transform:uppercase}.f-ui-lookup-wizard .el-table__cell{padding:12px 20px!important}.f-ui-lookup-wizard .el-table__cell:first-child{padding:0 10px!important}.f-ui-lookup-wizard .separator{font-weight:300;color:#d8d8d8!important;padding-right:10px;padding-left:10px;padding-bottom:2px}.f-ui-lookup-wizard .close-icon{font-size:15px;padding:4px 3px;border-radius:4px;border:1px solid transparent}.f-ui-lookup-wizard .close-icon:hover{color:#615e88;background:#f5f6f8;border:1px solid #dae0e8}.f-ui-lookup-wizard .el-dialog__header{border-bottom:1px solid #eee}.f-ui-lookup-wizard .el-dialog__body{padding:0}.f-ui-lookup-wizard .el-dialog__body .f-ui-lookup-table-container{height:550px}.f-ui-lookup-wizard .el-dialog__body .f-ui-lookup-table-container .el-table th>.cell{font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:.5px;color:#333;white-space:nowrap}.f-ui-lookup-wizard .el-checkbox__input.is-checked .el-checkbox__inner,.f-ui-lookup-wizard .el-checkbox__input.is-indeterminate .el-checkbox__inner,.f-ui-lookup-wizard .el-radio__input.is-checked .el-radio__inner{background-color:#39b2c2;border-color:#39b2c2}.f-ui-lookup-wizard .el-checkbox__input.is-indeterminate .el-checkbox__inner{margin-left:5px}.f-ui-lookup-wizard .modal-btn-cancel{color:#8f8f8f;border-color:#8f8f8f;background-color:#f4f4f4}.f-ui-lookup-wizard .modal-btn-save{background-color:#39b2c2;color:#fff}.f-ui-lookup-wizard .modal-btn{width:50%;padding-top:18px;padding-bottom:18px;cursor:pointer;border:transparent;letter-spacing:1.1px;text-align:center;text-transform:uppercase;font-weight:500;border-radius:0;float:right;line-height:16px;cursor:pointer;margin:0}.f-ui-lookup-wizard .wizard-search-container{margin-right:5px}.f-ui-lookup-wizard .wizard-search-container .f-ui-forms .el-input__icon{display:flex;align-items:center;justify-content:center}.f-ui-lookup-wizard .wizard-search-container .f-ui-forms .f-ui-text-input .el-input__inner{height:30px;padding-left:30px}.loader{width:80px;height:80px;border-radius:50%;position:relative;animation:rotate 1s linear infinite}.loader::before{content:"";box-sizing:border-box;position:absolute;inset:0;border-radius:50%;border:5px solid red;animation:prixClipFix 2s linear infinite}@keyframes rotate{100%{transform:rotate(360deg)}}@keyframes prixClipFix{0%{clip-path:polygon(50% 50%,0 0,0 0,0 0,0 0,0 0)}25%{clip-path:polygon(50% 50%,0 0,100% 0,100% 0,100% 0,100% 0)}50%{clip-path:polygon(50% 50%,0 0,100% 0,100% 100%,100% 100%,100% 100%)}75%{clip-path:polygon(50% 50%,0 0,100% 0,100% 100%,0 100%,0 100%)}100%{clip-path:polygon(50% 50%,0 0,100% 0,100% 100%,0 100%,0 0)}}',map:void 0,media:void 0})},__vue_scope_id__$7$2=void 0,__vue_module_identifier__$7$2=void 0,__vue_is_functional_template__$7$2=!1,__vue_component__$6$2=normalizeComponent$5({render:__vue_render__$7$2,staticRenderFns:__vue_staticRenderFns__$7$2},__vue_inject_styles__$7$2,__vue_script__$7$2,__vue_scope_id__$7$2,__vue_is_functional_template__$7$2,__vue_module_identifier__$7$2,!1,createInjector$2,void 0,void 0);
/* scoped */var _default$2$2={el:{colorpicker:{confirm:"OK",clear:"Clear"},datepicker:{now:"Now",today:"Today",cancel:"Cancel",clear:"Clear",confirm:"OK",selectDate:"Select date",selectTime:"Select time",startDate:"Start Date",startTime:"Start Time",endDate:"End Date",endTime:"End Time",prevYear:"Previous Year",nextYear:"Next Year",prevMonth:"Previous Month",nextMonth:"Next Month",year:"",month1:"January",month2:"February",month3:"March",month4:"April",month5:"May",month6:"June",month7:"July",month8:"August",month9:"September",month10:"October",month11:"November",month12:"December",week:"week",weeks:{sun:"Sun",mon:"Mon",tue:"Tue",wed:"Wed",thu:"Thu",fri:"Fri",sat:"Sat"},months:{jan:"Jan",feb:"Feb",mar:"Mar",apr:"Apr",may:"May",jun:"Jun",jul:"Jul",aug:"Aug",sep:"Sep",oct:"Oct",nov:"Nov",dec:"Dec"}},select:{loading:"Loading",noMatch:"No matching data",noData:"No data",placeholder:"Select"},cascader:{noMatch:"No matching data",loading:"Loading",placeholder:"Select",noData:"No data"},pagination:{goto:"Go to",pagesize:"/page",total:"Total {total}",pageClassifier:""},messagebox:{title:"Message",confirm:"OK",cancel:"Cancel",error:"Illegal input"},upload:{deleteTip:"press delete to remove",delete:"Delete",preview:"Preview",continue:"Continue"},table:{emptyText:"No Data",confirmFilter:"Confirm",resetFilter:"Reset",clearFilter:"All",sumText:"Sum"},tree:{emptyText:"No Data"},transfer:{noMatch:"No matching data",noData:"No data",titles:["List 1","List 2"],// to be translated
filterPlaceholder:"Enter keyword",// to be translated
noCheckedFormat:"{total} items",// to be translated
hasCheckedFormat:"{checked}/{total} checked"},image:{error:"FAILED"},pageHeader:{title:"Back"},popconfirm:{confirmButtonText:"Yes",cancelButtonText:"No"},empty:{description:"No Data"}}};function getDefaultExportFromCjs$2(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,"default")?x["default"]:x}function getAugmentedNamespace$2(n){if(n.__esModule)return n;var a=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(n).forEach((function(k){var d=Object.getOwnPropertyDescriptor(n,k);Object.defineProperty(a,k,d.get?d:{enumerable:!0,get:function(){return n[k]}})})),a}function createCommonjsModule$1$2(fn){var module={exports:{}};return fn(module,module.exports),module.exports}var _default$1$2={el:{colorpicker:{confirm:"确定",clear:"清空"},datepicker:{now:"此刻",today:"今天",cancel:"取消",clear:"清空",confirm:"确定",selectDate:"选择日期",selectTime:"选择时间",startDate:"开始日期",startTime:"开始时间",endDate:"结束日期",endTime:"结束时间",prevYear:"前一年",nextYear:"后一年",prevMonth:"上个月",nextMonth:"下个月",year:"年",month1:"1 月",month2:"2 月",month3:"3 月",month4:"4 月",month5:"5 月",month6:"6 月",month7:"7 月",month8:"8 月",month9:"9 月",month10:"10 月",month11:"11 月",month12:"12 月",
// week: '周次',
weeks:{sun:"日",mon:"一",tue:"二",wed:"三",thu:"四",fri:"五",sat:"六"},months:{jan:"一月",feb:"二月",mar:"三月",apr:"四月",may:"五月",jun:"六月",jul:"七月",aug:"八月",sep:"九月",oct:"十月",nov:"十一月",dec:"十二月"}},select:{loading:"加载中",noMatch:"无匹配数据",noData:"无数据",placeholder:"请选择"},cascader:{noMatch:"无匹配数据",loading:"加载中",placeholder:"请选择",noData:"暂无数据"},pagination:{goto:"前往",pagesize:"条/页",total:"共 {total} 条",pageClassifier:"页"},messagebox:{title:"提示",confirm:"确定",cancel:"取消",error:"输入的数据不合法!"},upload:{deleteTip:"按 delete 键可删除",delete:"删除",preview:"查看图片",continue:"继续上传"},table:{emptyText:"暂无数据",confirmFilter:"筛选",resetFilter:"重置",clearFilter:"全部",sumText:"合计"},tree:{emptyText:"暂无数据"},transfer:{noMatch:"无匹配数据",noData:"无数据",titles:["列表 1","列表 2"],filterPlaceholder:"请输入搜索内容",noCheckedFormat:"共 {total} 项",hasCheckedFormat:"已选 {checked}/{total} 项"},image:{error:"加载失败"},pageHeader:{title:"返回"},popconfirm:{confirmButtonText:"确定",cancelButtonText:"取消"},empty:{description:"暂无数据"}}},zhCN$2=Object.defineProperty({default:_default$1$2},"__esModule",{value:!0}),isMergeableObject$2=function(value){return isNonNullObject$2(value)&&!isSpecial$2(value)};function isNonNullObject$2(value){return!!value&&"object"===typeof value}function isSpecial$2(value){var stringValue=Object.prototype.toString.call(value);return"[object RegExp]"===stringValue||"[object Date]"===stringValue||isReactElement$2(value)}
// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol$2="function"===typeof Symbol&&Symbol.for,REACT_ELEMENT_TYPE$2=canUseSymbol$2?Symbol.for("react.element"):60103;function isReactElement$2(value){return value.$$typeof===REACT_ELEMENT_TYPE$2}function emptyTarget$2(val){return Array.isArray(val)?[]:{}}function cloneIfNecessary$2(value,optionsArgument){var clone=optionsArgument&&!0===optionsArgument.clone;return clone&&isMergeableObject$2(value)?deepmerge$2(emptyTarget$2(value),value,optionsArgument):value}function defaultArrayMerge$2(target,source,optionsArgument){var destination=target.slice();return source.forEach((function(e,i){"undefined"===typeof destination[i]?destination[i]=cloneIfNecessary$2(e,optionsArgument):isMergeableObject$2(e)?destination[i]=deepmerge$2(target[i],e,optionsArgument):-1===target.indexOf(e)&&destination.push(cloneIfNecessary$2(e,optionsArgument))})),destination}function mergeObject$2(target,source,optionsArgument){var destination={};return isMergeableObject$2(target)&&Object.keys(target).forEach((function(key){destination[key]=cloneIfNecessary$2(target[key],optionsArgument)})),Object.keys(source).forEach((function(key){isMergeableObject$2(source[key])&&target[key]?destination[key]=deepmerge$2(target[key],source[key],optionsArgument):destination[key]=cloneIfNecessary$2(source[key],optionsArgument)})),destination}function deepmerge$2(target,source,optionsArgument){var sourceIsArray=Array.isArray(source),targetIsArray=Array.isArray(target),options=optionsArgument||{arrayMerge:defaultArrayMerge$2},sourceAndTargetTypesMatch=sourceIsArray===targetIsArray;if(sourceAndTargetTypesMatch){if(sourceIsArray){var arrayMerge=options.arrayMerge||defaultArrayMerge$2;return arrayMerge(target,source,optionsArgument)}return mergeObject$2(target,source,optionsArgument)}return cloneIfNecessary$2(source,optionsArgument)}deepmerge$2.all=function(array,optionsArgument){if(!Array.isArray(array)||array.length<2)throw new Error("first argument should be an array with at least two elements");
// we are sure there are at least 2 values, so it is safe to have no initial value
return array.reduce((function(prev,next){return deepmerge$2(prev,next,optionsArgument)}))};var deepmerge_1$2=deepmerge$2,es$2=Object.freeze({__proto__:null,default:deepmerge_1$2}),types$2=createCommonjsModule$1$2((function(module,exports){exports.__esModule=!0,exports.isDefined=exports.isUndefined=exports.isFunction=void 0;var _typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj};exports.isString=isString,exports.isObject=isObject,exports.isHtmlElement=isHtmlElement;var _vue2=_interopRequireDefault(vue_runtime_esm["default"]);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function isString(obj){return"[object String]"===Object.prototype.toString.call(obj)}function isObject(obj){return"[object Object]"===Object.prototype.toString.call(obj)}function isHtmlElement(node){return node&&node.nodeType===Node.ELEMENT_NODE}
/**
 *  - Inspired:
 *    https://github.com/jashkenas/underscore/blob/master/modules/isFunction.js
 */var isFunction=function(functionToCheck){var getType={};return functionToCheck&&"[object Function]"===getType.toString.call(functionToCheck)};"object"===("undefined"===typeof Int8Array?"undefined":_typeof(Int8Array))||!_vue2.default.prototype.$isServer&&"function"===typeof document.childNodes||(exports.isFunction=isFunction=function(obj){return"function"===typeof obj||!1}),exports.isFunction=isFunction,exports.isUndefined=function(val){return void 0===val},exports.isDefined=function(val){return void 0!==val&&null!==val}})),util$2=createCommonjsModule$1$2((function(module,exports){exports.__esModule=!0,exports.isEmpty=exports.isEqual=exports.arrayEquals=exports.looseEqual=exports.capitalize=exports.kebabCase=exports.autoprefixer=exports.isFirefox=exports.isEdge=exports.isIE=exports.coerceTruthyValueToArray=exports.arrayFind=exports.arrayFindIndex=exports.escapeRegexpString=exports.valueEquals=exports.generateId=exports.getValueByPath=void 0;var _typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj};exports.noop=noop,exports.hasOwn=hasOwn,exports.toObject=toObject,exports.getPropByPath=getPropByPath,exports.rafThrottle=rafThrottle,exports.objToArray=objToArray;var _vue2=_interopRequireDefault(vue_runtime_esm["default"]);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}var hasOwnProperty=Object.prototype.hasOwnProperty;function noop(){}function hasOwn(obj,key){return hasOwnProperty.call(obj,key)}function extend(to,_from){for(var key in _from)to[key]=_from[key];return to}function toObject(arr){for(var res={},i=0;i<arr.length;i++)arr[i]&&extend(res,arr[i]);return res}function getPropByPath(obj,path,strict){var tempObj=obj;path=path.replace(/\[(\w+)\]/g,".$1"),path=path.replace(/^\./,"");for(var keyArr=path.split("."),i=0,len=keyArr.length;i<len-1;++i){if(!tempObj&&!strict)break;var key=keyArr[i];if(!(key in tempObj)){if(strict)throw new Error("please transfer a valid prop path to form item!");break}tempObj=tempObj[key]}return{o:tempObj,k:keyArr[i],v:tempObj?tempObj[keyArr[i]]:null}}exports.getValueByPath=function(object,prop){prop=prop||"";for(var paths=prop.split("."),current=object,result=null,i=0,j=paths.length;i<j;i++){var path=paths[i];if(!current)break;if(i===j-1){result=current[path];break}current=current[path]}return result},exports.generateId=function(){return Math.floor(1e4*Math.random())},exports.valueEquals=function(a,b){
// see: https://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript
if(a===b)return!0;if(!(a instanceof Array))return!1;if(!(b instanceof Array))return!1;if(a.length!==b.length)return!1;for(var i=0;i!==a.length;++i)if(a[i]!==b[i])return!1;return!0},exports.escapeRegexpString=function(){var value=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return String(value).replace(/[|\\{}()[\]^$+*?.]/g,"\\$&")};
// TODO: use native Array.find, Array.findIndex when IE support is dropped
var arrayFindIndex=exports.arrayFindIndex=function(arr,pred){for(var i=0;i!==arr.length;++i)if(pred(arr[i]))return i;return-1};exports.arrayFind=function(arr,pred){var idx=arrayFindIndex(arr,pred);return-1!==idx?arr[idx]:void 0},
// coerce truthy value to array
exports.coerceTruthyValueToArray=function(val){return Array.isArray(val)?val:val?[val]:[]},exports.isIE=function(){return!_vue2.default.prototype.$isServer&&!isNaN(Number(document.documentMode))},exports.isEdge=function(){return!_vue2.default.prototype.$isServer&&navigator.userAgent.indexOf("Edge")>-1},exports.isFirefox=function(){return!_vue2.default.prototype.$isServer&&!!window.navigator.userAgent.match(/firefox/i)},exports.autoprefixer=function(style){if("object"!==("undefined"===typeof style?"undefined":_typeof(style)))return style;var rules=["transform","transition","animation"],prefixes=["ms-","webkit-"];return rules.forEach((function(rule){var value=style[rule];rule&&value&&prefixes.forEach((function(prefix){style[prefix+rule]=value}))})),style},exports.kebabCase=function(str){var hyphenateRE=/([^-])([A-Z])/g;return str.replace(hyphenateRE,"$1-$2").replace(hyphenateRE,"$1-$2").toLowerCase()},exports.capitalize=function(str){return(0,types$2.isString)(str)?str.charAt(0).toUpperCase()+str.slice(1):str};var looseEqual=exports.looseEqual=function(a,b){var isObjectA=(0,types$2.isObject)(a),isObjectB=(0,types$2.isObject)(b);return isObjectA&&isObjectB?JSON.stringify(a)===JSON.stringify(b):!isObjectA&&!isObjectB&&String(a)===String(b)},arrayEquals=exports.arrayEquals=function(arrayA,arrayB){if(arrayA=arrayA||[],arrayB=arrayB||[],arrayA.length!==arrayB.length)return!1;for(var i=0;i<arrayA.length;i++)if(!looseEqual(arrayA[i],arrayB[i]))return!1;return!0};exports.isEqual=function(value1,value2){return Array.isArray(value1)&&Array.isArray(value2)?arrayEquals(value1,value2):looseEqual(value1,value2)};var isEmpty=exports.isEmpty=function(val){
// null or undefined
if(null==val)return!0;if("boolean"===typeof val)return!1;if("number"===typeof val)return!val;if(val instanceof Error)return""===val.message;switch(Object.prototype.toString.call(val)){
// String or Array
case"[object String]":case"[object Array]":return!val.length;
// Map or Set or File
case"[object File]":case"[object Map]":case"[object Set]":return!val.size;
// Plain Object
case"[object Object]":return!Object.keys(val).length}return!1};function rafThrottle(fn){var locked=!1;return function(){for(var _this=this,_len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];locked||(locked=!0,window.requestAnimationFrame((function(_){fn.apply(_this,args),locked=!1})))}}function objToArray(obj){return Array.isArray(obj)?obj:isEmpty(obj)?[]:[obj]}})),_typeof$3$2="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_default$4=function(Vue){
/**
   * template
   *
   * @param {String} string
   * @param {Array} ...args
   * @return {String}
   */
function template(string){for(var _len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];return 1===args.length&&"object"===_typeof$3$2(args[0])&&(args=args[0]),args&&args.hasOwnProperty||(args={}),string.replace(RE_NARGS$2,(function(match,prefix,i,index){var result=void 0;return"{"===string[index-1]&&"}"===string[index+match.length]?i:(result=(0,util$2.hasOwn)(args,i)?args[i]:null,null===result||void 0===result?"":result)}))}return template},RE_NARGS$2=/(%|)\{([0-9a-zA-Z_]+)\}/g,format$2=Object.defineProperty({default:_default$4},"__esModule",{value:!0}),_deepmerge$2=getAugmentedNamespace$2(es$2),locale$3=createCommonjsModule$1$2((function(module,exports){exports.__esModule=!0,exports.i18n=exports.use=exports.t=void 0;var _zhCN2=_interopRequireDefault(zhCN$2),_vue2=_interopRequireDefault(vue_runtime_esm["default"]),_deepmerge2=_interopRequireDefault(_deepmerge$2),_format2=_interopRequireDefault(format$2);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}var format$1=(0,_format2.default)(_vue2.default),lang=_zhCN2.default,merged=!1,i18nHandler=function(){var vuei18n=Object.getPrototypeOf(this||_vue2.default).$t;if("function"===typeof vuei18n&&_vue2.default.locale)return merged||(merged=!0,_vue2.default.locale(_vue2.default.config.lang,(0,_deepmerge2.default)(lang,_vue2.default.locale(_vue2.default.config.lang)||{},{clone:!0}))),vuei18n.apply(this,arguments)},t=exports.t=function(path,options){var value=i18nHandler.apply(this,arguments);if(null!==value&&void 0!==value)return value;for(var array=path.split("."),current=lang,i=0,j=array.length;i<j;i++){var property=array[i];if(value=current[property],i===j-1)return format$1(value,options);if(!value)return"";current=value}return""},use=exports.use=function(l){lang=l||lang},i18n=exports.i18n=function(fn){i18nHandler=fn||i18nHandler};exports.default={use:use,t:t,i18n:i18n}})),locale$1$2=getDefaultExportFromCjs$2(locale$3);
locale$1$2.use(_default$2$2);var script$6$2={name:"Datepicker",props:["appendToBody","value","value-format","format","default-value","placeholder","disabled","editable","picker-options","type","prefix-icon","clear-icon","start-placeholder","end-placeholder","hideClear","account"],components:{DatePicker:element_ui_common.DatePicker},mounted(){this.init()},data(){return{timeinorg:[]}},computed:{isRangeType(){let{type:type}=this||{};return["daterange","datetimerange"].includes(type)},defaultFormats(){let{timeformat:timeformat,dateformat:dateformat}=this;return dateformat=dateformat.replaceAll("Y","y"),dateformat=dateformat.replaceAll("D","d"),{date:dateformat,month:"yyyy-MM",datetime:`${dateformat} ${timeformat}`,time:`${timeformat}`,week:"yyyywWW",timerange:`${timeformat}`,daterange:`${dateformat}`,monthrange:"yyyy-MM",datetimerange:`${dateformat} ${timeformat}`,year:"yyyy"}},pickerFormat(){let{defaultFormats:defaultFormats,type:type,format:format}=this||{};return isEmpty$5(format)&&!isEmpty$5(defaultFormats[type])?defaultFormats[type]:format},ttime:{get(){let{value:value,isRangeType:isRangeType}=this||{};return isEmpty$5(value)?isRangeType?[]:"":isRangeType?value.map((val=>this.getTimeInSystemZone(val))):this.getTimeInSystemZone(value)},set(value){let{isRangeType:isRangeType}=this,timeInOrg=[];if(isRangeType){if(isEmpty$5(value))timeInOrg=[];else for(let time in value)timeInOrg[time]=this.getDateInOrg(value[time]);this.$emit("input",timeInOrg),this.$emit("change",timeInOrg)}else{let modifiedTimeFormat=this.getDateInOrg(value);this.$emit("input",modifiedTimeFormat),this.$emit("change",modifiedTimeFormat)}}},dateformat(){let{account:account={}}=this||{},dateFormat=dlv_umd(account,"org.dateFormat","DD-MMM-YYYY");return dateFormat||"DD-MMM-YYYY"},timeformat(){let{account:account={}}=this||{},timeFormat=dlv_umd(account,"org.timeFormat");return 2===timeFormat?"hh:mm A":"HH:mm"},timezone(){let timezone,{account:account={}}=this||{};if((account||{}).timezone){let{timezone:accountTimeZone}=account||{};timezone=accountTimeZone||"Etc/UTC"}else{let orgTimeZone=dlv_umd(account,"org.timezone");timezone=orgTimeZone||"Etc/UTC"}return timezone}},methods:{init(){let{isRangeType:isRangeType,value:value}=this,timeInOrg=[];if(isRangeType){if(isEmpty$5(value))timeInOrg=[];else for(let time in value){let timeVal=parseInt(value[time]);timeInOrg[time]=this.getDateInOrg(timeVal)}this.$emit("input",timeInOrg)}else if(!isEmpty$5(value)){let isPlaceHoldersEnabled=Constants$1.FIELD_PLACEHOLDERS.includes(value)||!1;isPlaceHoldersEnabled||this.$emit("input",this.getDateInOrg(parseInt(value)))}this.$emit("initialized")},focus(){this.$refs["date-picker"].focus()},getTimeInSystemZone(value){let{timezone:timezone}=this||{};return new Date(moment_timezone.tz(value,timezone||"Etc/UTC").format("YYYY-MM-DD HH:mm:ss"))},getDateInOrg(date){let{timezone:timezone}=this||{};return moment_timezone.tz(moment_timezone(date).format("YYYY-MM-DD HH:mm:ss"),timezone).valueOf()}}};
/* script */const __vue_script__$6$2=script$6$2;
/* template */var __vue_render__$6$2=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"f-ui-forms"},[_c("DatePicker",{ref:"date-picker",staticClass:"f-ui-date-picker",attrs:{appendToBody:_vm.appendToBody,clearable:!_vm.hideClear,type:_vm.type,"value-format":_vm.valueFormat,format:_vm.pickerFormat,placeholder:_vm.placeholder,disabled:_vm.disabled,editable:_vm.editable,"default-value":_vm.defaultValue,"picker-options":_vm.pickerOptions,"prefix-icon":_vm.prefixIcon,"clear-icon":_vm.clearIcon,"start-placeholder":_vm.startPlaceholder,"end-placeholder":_vm.endPlaceholder,"popper-class":"f-date-picker-popper"},model:{value:_vm.ttime,callback:function($$v){_vm.ttime=$$v},expression:"ttime"}})],1)},__vue_staticRenderFns__$6$2=[];
/* style */
const __vue_inject_styles__$6$2=void 0,__vue_scope_id__$6$2=void 0,__vue_module_identifier__$6$2=void 0,__vue_is_functional_template__$6$2=!1,__vue_component__$5$2=normalizeComponent$5({render:__vue_render__$6$2,staticRenderFns:__vue_staticRenderFns__$6$2},__vue_inject_styles__$6$2,__vue_script__$6$2,__vue_scope_id__$6$2,__vue_is_functional_template__$6$2,__vue_module_identifier__$6$2,!1,void 0,void 0,void 0);
/* scoped */
/*! @license DOMPurify 2.3.10 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.10/LICENSE */
function _typeof$2$2(obj){return _typeof$2$2="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof$2$2(obj)}function _setPrototypeOf$2(o,p){return _setPrototypeOf$2=Object.setPrototypeOf||function(o,p){return o.__proto__=p,o},_setPrototypeOf$2(o,p)}function _isNativeReflectConstruct$2(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}function _construct$2(Parent,args,Class){return _construct$2=_isNativeReflectConstruct$2()?Reflect.construct:function(Parent,args,Class){var a=[null];a.push.apply(a,args);var Constructor=Function.bind.apply(Parent,a),instance=new Constructor;return Class&&_setPrototypeOf$2(instance,Class.prototype),instance},_construct$2.apply(null,arguments)}function _toConsumableArray$3(arr){return _arrayWithoutHoles$3(arr)||_iterableToArray$3(arr)||_unsupportedIterableToArray$3(arr)||_nonIterableSpread$3()}function _arrayWithoutHoles$3(arr){if(Array.isArray(arr))return _arrayLikeToArray$3(arr)}function _iterableToArray$3(iter){if("undefined"!==typeof Symbol&&null!=iter[Symbol.iterator]||null!=iter["@@iterator"])return Array.from(iter)}function _unsupportedIterableToArray$3(o,minLen){if(o){if("string"===typeof o)return _arrayLikeToArray$3(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);return"Object"===n&&o.constructor&&(n=o.constructor.name),"Map"===n||"Set"===n?Array.from(o):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?_arrayLikeToArray$3(o,minLen):void 0}}function _arrayLikeToArray$3(arr,len){(null==len||len>arr.length)&&(len=arr.length);for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2}function _nonIterableSpread$3(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var hasOwnProperty$1$2=Object.hasOwnProperty,setPrototypeOf$2=Object.setPrototypeOf,isFrozen$2=Object.isFrozen,getPrototypeOf$2=Object.getPrototypeOf,getOwnPropertyDescriptor$2=Object.getOwnPropertyDescriptor,freeze$2=Object.freeze,seal$2=Object.seal,create$2=Object.create,_ref$2="undefined"!==typeof Reflect&&Reflect,apply$1$2=_ref$2.apply,construct$2=_ref$2.construct;apply$1$2||(apply$1$2=function(fun,thisValue,args){return fun.apply(thisValue,args)}),freeze$2||(freeze$2=function(x){return x}),seal$2||(seal$2=function(x){return x}),construct$2||(construct$2=function(Func,args){return _construct$2(Func,_toConsumableArray$3(args))});var arrayForEach$2=unapply$2(Array.prototype.forEach),arrayPop$2=unapply$2(Array.prototype.pop),arrayPush$2=unapply$2(Array.prototype.push),stringToLowerCase$2=unapply$2(String.prototype.toLowerCase),stringMatch$2=unapply$2(String.prototype.match),stringReplace$2=unapply$2(String.prototype.replace),stringIndexOf$2=unapply$2(String.prototype.indexOf),stringTrim$2=unapply$2(String.prototype.trim),regExpTest$2=unapply$2(RegExp.prototype.test),typeErrorCreate$2=unconstruct$2(TypeError);function unapply$2(func){return function(thisArg){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];return apply$1$2(func,thisArg,args)}}function unconstruct$2(func){return function(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++)args[_key2]=arguments[_key2];return construct$2(func,args)}}
/* Add properties to a lookup table */function addToSet$2(set,array,transformCaseFunc){transformCaseFunc=transformCaseFunc||stringToLowerCase$2,setPrototypeOf$2&&
// Make 'in' and truthy checks like Boolean(set.constructor)
// independent of any properties defined on Object.prototype.
// Prevent prototype setters from intercepting set as a this value.
setPrototypeOf$2(set,null);var l=array.length;while(l--){var element=array[l];if("string"===typeof element){var lcElement=transformCaseFunc(element);lcElement!==element&&(
// Config presets (e.g. tags.js, attrs.js) are immutable.
isFrozen$2(array)||(array[l]=lcElement),element=lcElement)}set[element]=!0}return set}
/* Shallow clone an object */function clone$2(object){var property,newObject=create$2(null);for(property in object)apply$1$2(hasOwnProperty$1$2,object,[property])&&(newObject[property]=object[property]);return newObject}
/* IE10 doesn't support __lookupGetter__ so lets'
 * simulate it. It also automatically checks
 * if the prop is function or getter and behaves
 * accordingly. */function lookupGetter$2(object,prop){while(null!==object){var desc=getOwnPropertyDescriptor$2(object,prop);if(desc){if(desc.get)return unapply$2(desc.get);if("function"===typeof desc.value)return unapply$2(desc.value)}object=getPrototypeOf$2(object)}function fallbackValue(element){return null}return fallbackValue}var html$1$2=freeze$2(["a","abbr","acronym","address","area","article","aside","audio","b","bdi","bdo","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","content","data","datalist","dd","decorator","del","details","dfn","dialog","dir","div","dl","dt","element","em","fieldset","figcaption","figure","font","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","img","input","ins","kbd","label","legend","li","main","map","mark","marquee","menu","menuitem","meter","nav","nobr","ol","optgroup","option","output","p","picture","pre","progress","q","rp","rt","ruby","s","samp","section","select","shadow","small","source","spacer","span","strike","strong","style","sub","summary","sup","table","tbody","td","template","textarea","tfoot","th","thead","time","tr","track","tt","u","ul","var","video","wbr"]),svg$1$2=freeze$2(["svg","a","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","circle","clippath","defs","desc","ellipse","filter","font","g","glyph","glyphref","hkern","image","line","lineargradient","marker","mask","metadata","mpath","path","pattern","polygon","polyline","radialgradient","rect","stop","style","switch","symbol","text","textpath","title","tref","tspan","view","vkern"]),svgFilters$2=freeze$2(["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]),svgDisallowed$2=freeze$2(["animate","color-profile","cursor","discard","fedropshadow","font-face","font-face-format","font-face-name","font-face-src","font-face-uri","foreignobject","hatch","hatchpath","mesh","meshgradient","meshpatch","meshrow","missing-glyph","script","set","solidcolor","unknown","use"]),mathMl$1$2=freeze$2(["math","menclose","merror","mfenced","mfrac","mglyph","mi","mlabeledtr","mmultiscripts","mn","mo","mover","mpadded","mphantom","mroot","mrow","ms","mspace","msqrt","mstyle","msub","msup","msubsup","mtable","mtd","mtext","mtr","munder","munderover"]),mathMlDisallowed$2=freeze$2(["maction","maligngroup","malignmark","mlongdiv","mscarries","mscarry","msgroup","mstack","msline","msrow","semantics","annotation","annotation-xml","mprescripts","none"]),text$1$2=freeze$2(["#text"]),html$3=freeze$2(["accept","action","align","alt","autocapitalize","autocomplete","autopictureinpicture","autoplay","background","bgcolor","border","capture","cellpadding","cellspacing","checked","cite","class","clear","color","cols","colspan","controls","controlslist","coords","crossorigin","datetime","decoding","default","dir","disabled","disablepictureinpicture","disableremoteplayback","download","draggable","enctype","enterkeyhint","face","for","headers","height","hidden","high","href","hreflang","id","inputmode","integrity","ismap","kind","label","lang","list","loading","loop","low","max","maxlength","media","method","min","minlength","multiple","muted","name","nonce","noshade","novalidate","nowrap","open","optimum","pattern","placeholder","playsinline","poster","preload","pubdate","radiogroup","readonly","rel","required","rev","reversed","role","rows","rowspan","spellcheck","scope","selected","shape","size","sizes","span","srclang","start","src","srcset","step","style","summary","tabindex","title","translate","type","usemap","valign","value","width","xmlns","slot"]),svg$3=freeze$2(["accent-height","accumulate","additive","alignment-baseline","ascent","attributename","attributetype","azimuth","basefrequency","baseline-shift","begin","bias","by","class","clip","clippathunits","clip-path","clip-rule","color","color-interpolation","color-interpolation-filters","color-profile","color-rendering","cx","cy","d","dx","dy","diffuseconstant","direction","display","divisor","dur","edgemode","elevation","end","fill","fill-opacity","fill-rule","filter","filterunits","flood-color","flood-opacity","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","fx","fy","g1","g2","glyph-name","glyphref","gradientunits","gradienttransform","height","href","id","image-rendering","in","in2","k","k1","k2","k3","k4","kerning","keypoints","keysplines","keytimes","lang","lengthadjust","letter-spacing","kernelmatrix","kernelunitlength","lighting-color","local","marker-end","marker-mid","marker-start","markerheight","markerunits","markerwidth","maskcontentunits","maskunits","max","mask","media","method","mode","min","name","numoctaves","offset","operator","opacity","order","orient","orientation","origin","overflow","paint-order","path","pathlength","patterncontentunits","patterntransform","patternunits","points","preservealpha","preserveaspectratio","primitiveunits","r","rx","ry","radius","refx","refy","repeatcount","repeatdur","restart","result","rotate","scale","seed","shape-rendering","specularconstant","specularexponent","spreadmethod","startoffset","stddeviation","stitchtiles","stop-color","stop-opacity","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke","stroke-width","style","surfacescale","systemlanguage","tabindex","targetx","targety","transform","transform-origin","text-anchor","text-decoration","text-rendering","textlength","type","u1","u2","unicode","values","viewbox","visibility","version","vert-adv-y","vert-origin-x","vert-origin-y","width","word-spacing","wrap","writing-mode","xchannelselector","ychannelselector","x","x1","x2","xmlns","y","y1","y2","z","zoomandpan"]),mathMl$3=freeze$2(["accent","accentunder","align","bevelled","close","columnsalign","columnlines","columnspan","denomalign","depth","dir","display","displaystyle","encoding","fence","frame","height","href","id","largeop","length","linethickness","lspace","lquote","mathbackground","mathcolor","mathsize","mathvariant","maxsize","minsize","movablelimits","notation","numalign","open","rowalign","rowlines","rowspacing","rowspan","rspace","rquote","scriptlevel","scriptminsize","scriptsizemultiplier","selection","separator","separators","stretchy","subscriptshift","supscriptshift","symmetric","voffset","width","xmlns"]),xml$2=freeze$2(["xlink:href","xml:id","xlink:title","xml:space","xmlns:xlink"]),MUSTACHE_EXPR$2=seal$2(/\{\{[\w\W]*|[\w\W]*\}\}/gm),ERB_EXPR$2=seal$2(/<%[\w\W]*|[\w\W]*%>/gm),DATA_ATTR$2=seal$2(/^data-[\-\w.\u00B7-\uFFFF]/),ARIA_ATTR$2=seal$2(/^aria-[\-\w]+$/),IS_ALLOWED_URI$2=seal$2(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i),IS_SCRIPT_OR_DATA$2=seal$2(/^(?:\w+script|data):/i),ATTR_WHITESPACE$2=seal$2(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),DOCTYPE_NAME$2=seal$2(/^html$/i),getGlobal$2=function(){return"undefined"===typeof window?null:window},_createTrustedTypesPolicy$2=function(trustedTypes,document){if("object"!==_typeof$2$2(trustedTypes)||"function"!==typeof trustedTypes.createPolicy)return null;// Allow the callers to control the unique policy name
// by adding a data-tt-policy-suffix to the script element with the DOMPurify.
// Policy creation with duplicate names throws in Trusted Types.
var suffix=null,ATTR_NAME="data-tt-policy-suffix";document.currentScript&&document.currentScript.hasAttribute(ATTR_NAME)&&(suffix=document.currentScript.getAttribute(ATTR_NAME));var policyName="dompurify"+(suffix?"#"+suffix:"");try{return trustedTypes.createPolicy(policyName,{createHTML:function(html){return html},createScriptURL:function(scriptUrl){return scriptUrl}})}catch(_){return null}};// SVG
function createDOMPurify$2(){var window=arguments.length>0&&void 0!==arguments[0]?arguments[0]:getGlobal$2(),DOMPurify=function(root){return createDOMPurify$2(root)};if(
/**
   * Version label, exposed for easier checks
   * if DOMPurify is up to date or not
   */
DOMPurify.version="2.3.10",
/**
   * Array of elements that DOMPurify removed during sanitation.
   * Empty if nothing was removed.
   */
DOMPurify.removed=[],!window||!window.document||9!==window.document.nodeType)
// Not running in a browser, provide a factory function
// so that you can pass your own Window
return DOMPurify.isSupported=!1,DOMPurify;var originalDocument=window.document,document=window.document,DocumentFragment=window.DocumentFragment,HTMLTemplateElement=window.HTMLTemplateElement,Node=window.Node,Element=window.Element,NodeFilter=window.NodeFilter,_window$NamedNodeMap=window.NamedNodeMap,NamedNodeMap=void 0===_window$NamedNodeMap?window.NamedNodeMap||window.MozNamedAttrMap:_window$NamedNodeMap,HTMLFormElement=window.HTMLFormElement,DOMParser=window.DOMParser,trustedTypes=window.trustedTypes,ElementPrototype=Element.prototype,cloneNode=lookupGetter$2(ElementPrototype,"cloneNode"),getNextSibling=lookupGetter$2(ElementPrototype,"nextSibling"),getChildNodes=lookupGetter$2(ElementPrototype,"childNodes"),getParentNode=lookupGetter$2(ElementPrototype,"parentNode");// As per issue #47, the web-components registry is inherited by a
// new document created via createHTMLDocument. As per the spec
// (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
// a new empty registry is used when creating a template contents owner
// document, so we use that as our parent document to ensure nothing
// is inherited.
if("function"===typeof HTMLTemplateElement){var template=document.createElement("template");template.content&&template.content.ownerDocument&&(document=template.content.ownerDocument)}var trustedTypesPolicy=_createTrustedTypesPolicy$2(trustedTypes,originalDocument),emptyHTML=trustedTypesPolicy?trustedTypesPolicy.createHTML(""):"",_document=document,implementation=_document.implementation,createNodeIterator=_document.createNodeIterator,createDocumentFragment=_document.createDocumentFragment,getElementsByTagName=_document.getElementsByTagName,importNode=originalDocument.importNode,documentMode={};try{documentMode=clone$2(document).documentMode?document.documentMode:{}}catch(_){}var hooks={};
/**
   * Expose whether this browser supports running the full DOMPurify.
   */DOMPurify.isSupported="function"===typeof getParentNode&&implementation&&"undefined"!==typeof implementation.createHTMLDocument&&9!==documentMode;var PARSER_MEDIA_TYPE,transformCaseFunc,MUSTACHE_EXPR$1=MUSTACHE_EXPR$2,ERB_EXPR$1=ERB_EXPR$2,DATA_ATTR$1=DATA_ATTR$2,ARIA_ATTR$1=ARIA_ATTR$2,IS_SCRIPT_OR_DATA$1=IS_SCRIPT_OR_DATA$2,ATTR_WHITESPACE$1=ATTR_WHITESPACE$2,IS_ALLOWED_URI$1=IS_ALLOWED_URI$2,ALLOWED_TAGS=null,DEFAULT_ALLOWED_TAGS=addToSet$2({},[].concat(_toConsumableArray$3(html$1$2),_toConsumableArray$3(svg$1$2),_toConsumableArray$3(svgFilters$2),_toConsumableArray$3(mathMl$1$2),_toConsumableArray$3(text$1$2))),ALLOWED_ATTR=null,DEFAULT_ALLOWED_ATTR=addToSet$2({},[].concat(_toConsumableArray$3(html$3),_toConsumableArray$3(svg$3),_toConsumableArray$3(mathMl$3),_toConsumableArray$3(xml$2))),CUSTOM_ELEMENT_HANDLING=Object.seal(Object.create(null,{tagNameCheck:{writable:!0,configurable:!1,enumerable:!0,value:null},attributeNameCheck:{writable:!0,configurable:!1,enumerable:!0,value:null},allowCustomizedBuiltInElements:{writable:!0,configurable:!1,enumerable:!0,value:!1}})),FORBID_TAGS=null,FORBID_ATTR=null,ALLOW_ARIA_ATTR=!0,ALLOW_DATA_ATTR=!0,ALLOW_UNKNOWN_PROTOCOLS=!1,SAFE_FOR_TEMPLATES=!1,WHOLE_DOCUMENT=!1,SET_CONFIG=!1,FORCE_BODY=!1,RETURN_DOM=!1,RETURN_DOM_FRAGMENT=!1,RETURN_TRUSTED_TYPE=!1,SANITIZE_DOM=!0,KEEP_CONTENT=!0,IN_PLACE=!1,USE_PROFILES={},FORBID_CONTENTS=null,DEFAULT_FORBID_CONTENTS=addToSet$2({},["annotation-xml","audio","colgroup","desc","foreignobject","head","iframe","math","mi","mn","mo","ms","mtext","noembed","noframes","noscript","plaintext","script","style","svg","template","thead","title","video","xmp"]),DATA_URI_TAGS=null,DEFAULT_DATA_URI_TAGS=addToSet$2({},["audio","video","img","source","image","track"]),URI_SAFE_ATTRIBUTES=null,DEFAULT_URI_SAFE_ATTRIBUTES=addToSet$2({},["alt","class","for","id","label","name","pattern","placeholder","role","summary","title","value","style","xmlns"]),MATHML_NAMESPACE="http://www.w3.org/1998/Math/MathML",SVG_NAMESPACE="http://www.w3.org/2000/svg",HTML_NAMESPACE="http://www.w3.org/1999/xhtml",NAMESPACE=HTML_NAMESPACE,IS_EMPTY_INPUT=!1,SUPPORTED_PARSER_MEDIA_TYPES=["application/xhtml+xml","text/html"],DEFAULT_PARSER_MEDIA_TYPE="text/html",CONFIG=null,formElement=document.createElement("form"),isRegexOrFunction=function(testValue){return testValue instanceof RegExp||testValue instanceof Function},_parseConfig=function(cfg){CONFIG&&CONFIG===cfg||(
/* Shield configuration object from tampering */
cfg&&"object"===_typeof$2$2(cfg)||(cfg={})
/* Shield configuration object from prototype pollution */,cfg=clone$2(cfg),PARSER_MEDIA_TYPE=// eslint-disable-next-line unicorn/prefer-includes
PARSER_MEDIA_TYPE=-1===SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE)?DEFAULT_PARSER_MEDIA_TYPE:cfg.PARSER_MEDIA_TYPE,// HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
transformCaseFunc="application/xhtml+xml"===PARSER_MEDIA_TYPE?function(x){return x}:stringToLowerCase$2,
/* Set configuration parameters */
ALLOWED_TAGS="ALLOWED_TAGS"in cfg?addToSet$2({},cfg.ALLOWED_TAGS,transformCaseFunc):DEFAULT_ALLOWED_TAGS,ALLOWED_ATTR="ALLOWED_ATTR"in cfg?addToSet$2({},cfg.ALLOWED_ATTR,transformCaseFunc):DEFAULT_ALLOWED_ATTR,URI_SAFE_ATTRIBUTES="ADD_URI_SAFE_ATTR"in cfg?addToSet$2(clone$2(DEFAULT_URI_SAFE_ATTRIBUTES),// eslint-disable-line indent
cfg.ADD_URI_SAFE_ATTR,// eslint-disable-line indent
transformCaseFunc):DEFAULT_URI_SAFE_ATTRIBUTES,DATA_URI_TAGS="ADD_DATA_URI_TAGS"in cfg?addToSet$2(clone$2(DEFAULT_DATA_URI_TAGS),// eslint-disable-line indent
cfg.ADD_DATA_URI_TAGS,// eslint-disable-line indent
transformCaseFunc):DEFAULT_DATA_URI_TAGS,FORBID_CONTENTS="FORBID_CONTENTS"in cfg?addToSet$2({},cfg.FORBID_CONTENTS,transformCaseFunc):DEFAULT_FORBID_CONTENTS,FORBID_TAGS="FORBID_TAGS"in cfg?addToSet$2({},cfg.FORBID_TAGS,transformCaseFunc):{},FORBID_ATTR="FORBID_ATTR"in cfg?addToSet$2({},cfg.FORBID_ATTR,transformCaseFunc):{},USE_PROFILES="USE_PROFILES"in cfg&&cfg.USE_PROFILES,ALLOW_ARIA_ATTR=!1!==cfg.ALLOW_ARIA_ATTR,// Default true
ALLOW_DATA_ATTR=!1!==cfg.ALLOW_DATA_ATTR,// Default true
ALLOW_UNKNOWN_PROTOCOLS=cfg.ALLOW_UNKNOWN_PROTOCOLS||!1,// Default false
SAFE_FOR_TEMPLATES=cfg.SAFE_FOR_TEMPLATES||!1,// Default false
WHOLE_DOCUMENT=cfg.WHOLE_DOCUMENT||!1,// Default false
RETURN_DOM=cfg.RETURN_DOM||!1,// Default false
RETURN_DOM_FRAGMENT=cfg.RETURN_DOM_FRAGMENT||!1,// Default false
RETURN_TRUSTED_TYPE=cfg.RETURN_TRUSTED_TYPE||!1,// Default false
FORCE_BODY=cfg.FORCE_BODY||!1,// Default false
SANITIZE_DOM=!1!==cfg.SANITIZE_DOM,// Default true
KEEP_CONTENT=!1!==cfg.KEEP_CONTENT,// Default true
IN_PLACE=cfg.IN_PLACE||!1,// Default false
IS_ALLOWED_URI$1=cfg.ALLOWED_URI_REGEXP||IS_ALLOWED_URI$1,NAMESPACE=cfg.NAMESPACE||HTML_NAMESPACE,cfg.CUSTOM_ELEMENT_HANDLING&&isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)&&(CUSTOM_ELEMENT_HANDLING.tagNameCheck=cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck),cfg.CUSTOM_ELEMENT_HANDLING&&isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)&&(CUSTOM_ELEMENT_HANDLING.attributeNameCheck=cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck),cfg.CUSTOM_ELEMENT_HANDLING&&"boolean"===typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements&&(CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements=cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements),SAFE_FOR_TEMPLATES&&(ALLOW_DATA_ATTR=!1),RETURN_DOM_FRAGMENT&&(RETURN_DOM=!0)
/* Parse profile info */,USE_PROFILES&&(ALLOWED_TAGS=addToSet$2({},_toConsumableArray$3(text$1$2)),ALLOWED_ATTR=[],!0===USE_PROFILES.html&&(addToSet$2(ALLOWED_TAGS,html$1$2),addToSet$2(ALLOWED_ATTR,html$3)),!0===USE_PROFILES.svg&&(addToSet$2(ALLOWED_TAGS,svg$1$2),addToSet$2(ALLOWED_ATTR,svg$3),addToSet$2(ALLOWED_ATTR,xml$2)),!0===USE_PROFILES.svgFilters&&(addToSet$2(ALLOWED_TAGS,svgFilters$2),addToSet$2(ALLOWED_ATTR,svg$3),addToSet$2(ALLOWED_ATTR,xml$2)),!0===USE_PROFILES.mathMl&&(addToSet$2(ALLOWED_TAGS,mathMl$1$2),addToSet$2(ALLOWED_ATTR,mathMl$3),addToSet$2(ALLOWED_ATTR,xml$2)))
/* Merge configuration parameters */,cfg.ADD_TAGS&&(ALLOWED_TAGS===DEFAULT_ALLOWED_TAGS&&(ALLOWED_TAGS=clone$2(ALLOWED_TAGS)),addToSet$2(ALLOWED_TAGS,cfg.ADD_TAGS,transformCaseFunc)),cfg.ADD_ATTR&&(ALLOWED_ATTR===DEFAULT_ALLOWED_ATTR&&(ALLOWED_ATTR=clone$2(ALLOWED_ATTR)),addToSet$2(ALLOWED_ATTR,cfg.ADD_ATTR,transformCaseFunc)),cfg.ADD_URI_SAFE_ATTR&&addToSet$2(URI_SAFE_ATTRIBUTES,cfg.ADD_URI_SAFE_ATTR,transformCaseFunc),cfg.FORBID_CONTENTS&&(FORBID_CONTENTS===DEFAULT_FORBID_CONTENTS&&(FORBID_CONTENTS=clone$2(FORBID_CONTENTS)),addToSet$2(FORBID_CONTENTS,cfg.FORBID_CONTENTS,transformCaseFunc))
/* Add #text in case KEEP_CONTENT is set to true */,KEEP_CONTENT&&(ALLOWED_TAGS["#text"]=!0)
/* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */,WHOLE_DOCUMENT&&addToSet$2(ALLOWED_TAGS,["html","head","body"])
/* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */,ALLOWED_TAGS.table&&(addToSet$2(ALLOWED_TAGS,["tbody"]),delete FORBID_TAGS.tbody),// Prevent further manipulation of configuration.
// Not available in IE8, Safari 5, etc.
freeze$2&&freeze$2(cfg),CONFIG=cfg)},MATHML_TEXT_INTEGRATION_POINTS=addToSet$2({},["mi","mo","mn","ms","mtext"]),HTML_INTEGRATION_POINTS=addToSet$2({},["foreignobject","desc","title","annotation-xml"]),COMMON_SVG_AND_HTML_ELEMENTS=addToSet$2({},["title","style","font","a","script"]),ALL_SVG_TAGS=addToSet$2({},svg$1$2);addToSet$2(ALL_SVG_TAGS,svgFilters$2),addToSet$2(ALL_SVG_TAGS,svgDisallowed$2);var ALL_MATHML_TAGS=addToSet$2({},mathMl$1$2);addToSet$2(ALL_MATHML_TAGS,mathMlDisallowed$2);
/**
   *
   *
   * @param  {Element} element a DOM element whose namespace is being checked
   * @returns {boolean} Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */
var _checkValidNamespace=function(element){var parent=getParentNode(element);// In JSDOM, if we're inside shadow DOM, then parentNode
// can be null. We just simulate parent in this case.
parent&&parent.tagName||(parent={namespaceURI:HTML_NAMESPACE,tagName:"template"});var tagName=stringToLowerCase$2(element.tagName),parentTagName=stringToLowerCase$2(parent.tagName);return element.namespaceURI===SVG_NAMESPACE?
// The only way to switch from HTML namespace to SVG
// is via <svg>. If it happens via any other tag, then
// it should be killed.
parent.namespaceURI===HTML_NAMESPACE?"svg"===tagName:// The only way to switch from MathML to SVG is via
// svg if parent is either <annotation-xml> or MathML
// text integration points.
parent.namespaceURI===MATHML_NAMESPACE?"svg"===tagName&&("annotation-xml"===parentTagName||MATHML_TEXT_INTEGRATION_POINTS[parentTagName]):Boolean(ALL_SVG_TAGS[tagName]):element.namespaceURI===MATHML_NAMESPACE?
// The only way to switch from HTML namespace to MathML
// is via <math>. If it happens via any other tag, then
// it should be killed.
parent.namespaceURI===HTML_NAMESPACE?"math"===tagName:// The only way to switch from SVG to MathML is via
// <math> and HTML integration points
parent.namespaceURI===SVG_NAMESPACE?"math"===tagName&&HTML_INTEGRATION_POINTS[parentTagName]:Boolean(ALL_MATHML_TAGS[tagName]):element.namespaceURI===HTML_NAMESPACE&&(
// The only way to switch from SVG to HTML is via
// HTML integration points, and from MathML to HTML
// is via MathML text integration points
!(parent.namespaceURI===SVG_NAMESPACE&&!HTML_INTEGRATION_POINTS[parentTagName])&&(!(parent.namespaceURI===MATHML_NAMESPACE&&!MATHML_TEXT_INTEGRATION_POINTS[parentTagName])&&(!ALL_MATHML_TAGS[tagName]&&(COMMON_SVG_AND_HTML_ELEMENTS[tagName]||!ALL_SVG_TAGS[tagName]))))},_forceRemove=function(node){arrayPush$2(DOMPurify.removed,{element:node});try{
// eslint-disable-next-line unicorn/prefer-dom-node-remove
node.parentNode.removeChild(node)}catch(_){try{node.outerHTML=emptyHTML}catch(_){node.remove()}}},_removeAttribute=function(name,node){try{arrayPush$2(DOMPurify.removed,{attribute:node.getAttributeNode(name),from:node})}catch(_){arrayPush$2(DOMPurify.removed,{attribute:null,from:node})}// We void attribute values for unremovable "is"" attributes
if(node.removeAttribute(name),"is"===name&&!ALLOWED_ATTR[name])if(RETURN_DOM||RETURN_DOM_FRAGMENT)try{_forceRemove(node)}catch(_){}else try{node.setAttribute(name,"")}catch(_){}},_initDocument=function(dirty){
/* Create a HTML document */
var doc,leadingWhitespace;if(FORCE_BODY)dirty="<remove></remove>"+dirty;else{
/* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
var matches=stringMatch$2(dirty,/^[\r\n\t ]+/);leadingWhitespace=matches&&matches[0]}"application/xhtml+xml"===PARSER_MEDIA_TYPE&&(
// Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
dirty='<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>'+dirty+"</body></html>");var dirtyPayload=trustedTypesPolicy?trustedTypesPolicy.createHTML(dirty):dirty;
/*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */if(NAMESPACE===HTML_NAMESPACE)try{doc=(new DOMParser).parseFromString(dirtyPayload,PARSER_MEDIA_TYPE)}catch(_){}
/* Use createHTMLDocument in case DOMParser is not available */if(!doc||!doc.documentElement){doc=implementation.createDocument(NAMESPACE,"template",null);try{doc.documentElement.innerHTML=IS_EMPTY_INPUT?"":dirtyPayload}catch(_){// Syntax error if dirtyPayload is invalid xml
}}var body=doc.body||doc.documentElement;
/* Work on whole document or just its body */
return dirty&&leadingWhitespace&&body.insertBefore(document.createTextNode(leadingWhitespace),body.childNodes[0]||null),NAMESPACE===HTML_NAMESPACE?getElementsByTagName.call(doc,WHOLE_DOCUMENT?"html":"body")[0]:WHOLE_DOCUMENT?doc.documentElement:body},_createIterator=function(root){return createNodeIterator.call(root.ownerDocument||root,root,// eslint-disable-next-line no-bitwise
NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT|NodeFilter.SHOW_TEXT,null,!1)},_isClobbered=function(elm){return elm instanceof HTMLFormElement&&("string"!==typeof elm.nodeName||"string"!==typeof elm.textContent||"function"!==typeof elm.removeChild||!(elm.attributes instanceof NamedNodeMap)||"function"!==typeof elm.removeAttribute||"function"!==typeof elm.setAttribute||"string"!==typeof elm.namespaceURI||"function"!==typeof elm.insertBefore)},_isNode=function(object){return"object"===_typeof$2$2(Node)?object instanceof Node:object&&"object"===_typeof$2$2(object)&&"number"===typeof object.nodeType&&"string"===typeof object.nodeName},_executeHook=function(entryPoint,currentNode,data){hooks[entryPoint]&&arrayForEach$2(hooks[entryPoint],(function(hook){hook.call(DOMPurify,currentNode,data,CONFIG)}))},_sanitizeElements=function(currentNode){var content;
/* Execute a hook if present */
/* Check if element is clobbered or can clobber */
if(_executeHook("beforeSanitizeElements",currentNode,null),_isClobbered(currentNode))return _forceRemove(currentNode),!0;
/* Check if tagname contains Unicode */if(regExpTest$2(/[\u0080-\uFFFF]/,currentNode.nodeName))return _forceRemove(currentNode),!0;
/* Now let's check the element's type and name */var tagName=transformCaseFunc(currentNode.nodeName);
/* Execute a hook if present */
/* Detect mXSS attempts abusing namespace confusion */
if(_executeHook("uponSanitizeElement",currentNode,{tagName:tagName,allowedTags:ALLOWED_TAGS}),currentNode.hasChildNodes()&&!_isNode(currentNode.firstElementChild)&&(!_isNode(currentNode.content)||!_isNode(currentNode.content.firstElementChild))&&regExpTest$2(/<[/\w]/g,currentNode.innerHTML)&&regExpTest$2(/<[/\w]/g,currentNode.textContent))return _forceRemove(currentNode),!0;
/* Mitigate a problem with templates inside select */if("select"===tagName&&regExpTest$2(/<template/i,currentNode.innerHTML))return _forceRemove(currentNode),!0;
/* Remove element if anything forbids its presence */if(!ALLOWED_TAGS[tagName]||FORBID_TAGS[tagName]){
/* Check if we have a custom element to handle */
if(!FORBID_TAGS[tagName]&&_basicCustomElementTest(tagName)){if(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp&&regExpTest$2(CUSTOM_ELEMENT_HANDLING.tagNameCheck,tagName))return!1;if(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))return!1}
/* Keep content except for bad-listed elements */if(KEEP_CONTENT&&!FORBID_CONTENTS[tagName]){var parentNode=getParentNode(currentNode)||currentNode.parentNode,childNodes=getChildNodes(currentNode)||currentNode.childNodes;if(childNodes&&parentNode)for(var childCount=childNodes.length,i=childCount-1;i>=0;--i)parentNode.insertBefore(cloneNode(childNodes[i],!0),getNextSibling(currentNode))}return _forceRemove(currentNode),!0}
/* Check whether element has a valid namespace */return currentNode instanceof Element&&!_checkValidNamespace(currentNode)?(_forceRemove(currentNode),!0):"noscript"!==tagName&&"noembed"!==tagName||!regExpTest$2(/<\/no(script|embed)/i,currentNode.innerHTML)?(
/* Sanitize element content to be template-safe */
SAFE_FOR_TEMPLATES&&3===currentNode.nodeType&&(
/* Get the element's text content */
content=currentNode.textContent,content=stringReplace$2(content,MUSTACHE_EXPR$1," "),content=stringReplace$2(content,ERB_EXPR$1," "),currentNode.textContent!==content&&(arrayPush$2(DOMPurify.removed,{element:currentNode.cloneNode()}),currentNode.textContent=content))
/* Execute a hook if present */,_executeHook("afterSanitizeElements",currentNode,null),!1):(_forceRemove(currentNode),!0)},_isValidAttribute=function(lcTag,lcName,value){
/* Make sure attribute cannot clobber */
if(SANITIZE_DOM&&("id"===lcName||"name"===lcName)&&(value in document||value in formElement))return!1;
/* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */if(ALLOW_DATA_ATTR&&!FORBID_ATTR[lcName]&&regExpTest$2(DATA_ATTR$1,lcName));else if(ALLOW_ARIA_ATTR&&regExpTest$2(ARIA_ATTR$1,lcName));else if(!ALLOWED_ATTR[lcName]||FORBID_ATTR[lcName]){if(// First condition does a very basic check if a) it's basically a valid custom element tagname AND
// b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
// and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
!(_basicCustomElementTest(lcTag)&&(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp&&regExpTest$2(CUSTOM_ELEMENT_HANDLING.tagNameCheck,lcTag)||CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag))&&(CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp&&regExpTest$2(CUSTOM_ELEMENT_HANDLING.attributeNameCheck,lcName)||CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName))||// Alternative, second condition checks if it's an `is`-attribute, AND
// the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
"is"===lcName&&CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements&&(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp&&regExpTest$2(CUSTOM_ELEMENT_HANDLING.tagNameCheck,value)||CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))))return!1;
/* Check value is safe. First, is attr inert? If so, is safe */}else if(URI_SAFE_ATTRIBUTES[lcName]);else if(regExpTest$2(IS_ALLOWED_URI$1,stringReplace$2(value,ATTR_WHITESPACE$1,"")));else if("src"!==lcName&&"xlink:href"!==lcName&&"href"!==lcName||"script"===lcTag||0!==stringIndexOf$2(value,"data:")||!DATA_URI_TAGS[lcTag]){if(ALLOW_UNKNOWN_PROTOCOLS&&!regExpTest$2(IS_SCRIPT_OR_DATA$1,stringReplace$2(value,ATTR_WHITESPACE$1,"")));else if(value)return!1}else;return!0},_basicCustomElementTest=function(tagName){return tagName.indexOf("-")>0},_sanitizeAttributes=function(currentNode){var attr,value,lcName,l;
/* Execute a hook if present */
_executeHook("beforeSanitizeAttributes",currentNode,null);var attributes=currentNode.attributes;
/* Check if we have attributes; if not we might have a text node */if(attributes){var hookEvent={attrName:"",attrValue:"",keepAttr:!0,allowedAttributes:ALLOWED_ATTR};l=attributes.length;
/* Go backwards over all attributes; safely remove bad ones */
while(l--){attr=attributes[l];var _attr=attr,name=_attr.name,namespaceURI=_attr.namespaceURI;
/* Did the hooks approve of the attribute? */
if(value="value"===name?attr.value:stringTrim$2(attr.value),lcName=transformCaseFunc(name),
/* Execute a hook if present */
hookEvent.attrName=lcName,hookEvent.attrValue=value,hookEvent.keepAttr=!0,hookEvent.forceKeepAttr=void 0,// Allows developers to see this is a property they can set
_executeHook("uponSanitizeAttribute",currentNode,hookEvent),value=hookEvent.attrValue,!hookEvent.forceKeepAttr&&(
/* Remove attribute */
_removeAttribute(name,currentNode),hookEvent.keepAttr))
/* Work around a security issue in jQuery 3.0 */
if(regExpTest$2(/\/>/i,value))_removeAttribute(name,currentNode);else{
/* Sanitize attribute content to be template-safe */
SAFE_FOR_TEMPLATES&&(value=stringReplace$2(value,MUSTACHE_EXPR$1," "),value=stringReplace$2(value,ERB_EXPR$1," "))
/* Is `value` valid for this attribute? */;var lcTag=transformCaseFunc(currentNode.nodeName);if(_isValidAttribute(lcTag,lcName,value)){
/* Handle attributes that require Trusted Types */
if(trustedTypesPolicy&&"object"===_typeof$2$2(trustedTypes)&&"function"===typeof trustedTypes.getAttributeType)if(namespaceURI);else switch(trustedTypes.getAttributeType(lcTag,lcName)){case"TrustedHTML":value=trustedTypesPolicy.createHTML(value);break;case"TrustedScriptURL":value=trustedTypesPolicy.createScriptURL(value);break}
/* Handle invalid data-* attribute set by try-catching it */try{namespaceURI?currentNode.setAttributeNS(namespaceURI,name,value):
/* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
currentNode.setAttribute(name,value),arrayPop$2(DOMPurify.removed)}catch(_){}}}}
/* Execute a hook if present */_executeHook("afterSanitizeAttributes",currentNode,null)}},_sanitizeShadowDOM=function _sanitizeShadowDOM(fragment){var shadowNode,shadowIterator=_createIterator(fragment);
/* Execute a hook if present */
_executeHook("beforeSanitizeShadowDOM",fragment,null);while(shadowNode=shadowIterator.nextNode())
/* Execute a hook if present */
_executeHook("uponSanitizeShadowNode",shadowNode,null),
/* Sanitize tags and elements */
_sanitizeElements(shadowNode)||(
/* Deep shadow DOM detected */
shadowNode.content instanceof DocumentFragment&&_sanitizeShadowDOM(shadowNode.content)
/* Check attributes, sanitize if necessary */,_sanitizeAttributes(shadowNode));
/* Execute a hook if present */_executeHook("afterSanitizeShadowDOM",fragment,null)};
/**
   * _forceRemove
   *
   * @param  {Node} node a DOM node
   */
/**
   * Sanitize
   * Public method providing core sanitation functionality
   *
   * @param {String|Node} dirty string or DOM node
   * @param {Object} configuration object
   */
// eslint-disable-next-line complexity
return DOMPurify.sanitize=function(dirty,cfg){var body,importedNode,currentNode,oldNode,returnNode;
/* Stringify, in case dirty is an object */
if(
/* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
IS_EMPTY_INPUT=!dirty,IS_EMPTY_INPUT&&(dirty="\x3c!--\x3e"),"string"!==typeof dirty&&!_isNode(dirty)){
// eslint-disable-next-line no-negated-condition
if("function"!==typeof dirty.toString)throw typeErrorCreate$2("toString is not a function");if(dirty=dirty.toString(),"string"!==typeof dirty)throw typeErrorCreate$2("dirty is not a string, aborting")}
/* Check we can run. Otherwise fall back or ignore */if(!DOMPurify.isSupported){if("object"===_typeof$2$2(window.toStaticHTML)||"function"===typeof window.toStaticHTML){if("string"===typeof dirty)return window.toStaticHTML(dirty);if(_isNode(dirty))return window.toStaticHTML(dirty.outerHTML)}return dirty}
/* Assign config vars */if(SET_CONFIG||_parseConfig(cfg)
/* Clean up removed elements */,DOMPurify.removed=[],
/* Check if dirty is correctly typed for IN_PLACE */
"string"===typeof dirty&&(IN_PLACE=!1),IN_PLACE){
/* Do some early pre-sanitization to avoid unsafe root nodes */
if(dirty.nodeName){var tagName=transformCaseFunc(dirty.nodeName);if(!ALLOWED_TAGS[tagName]||FORBID_TAGS[tagName])throw typeErrorCreate$2("root node is forbidden and cannot be sanitized in-place")}}else if(dirty instanceof Node)
/* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
body=_initDocument("\x3c!----\x3e"),importedNode=body.ownerDocument.importNode(dirty,!0),1===importedNode.nodeType&&"BODY"===importedNode.nodeName||"HTML"===importedNode.nodeName?
/* Node is already a body, use as is */
body=importedNode:
// eslint-disable-next-line unicorn/prefer-dom-node-append
body.appendChild(importedNode);else{
/* Exit directly if we have nothing to do */
if(!RETURN_DOM&&!SAFE_FOR_TEMPLATES&&!WHOLE_DOCUMENT&&// eslint-disable-next-line unicorn/prefer-includes
-1===dirty.indexOf("<"))return trustedTypesPolicy&&RETURN_TRUSTED_TYPE?trustedTypesPolicy.createHTML(dirty):dirty;
/* Initialize the document to work on */
/* Check we have a DOM node from the data */
if(body=_initDocument(dirty),!body)return RETURN_DOM?null:RETURN_TRUSTED_TYPE?emptyHTML:""}
/* Remove first element node (ours) if FORCE_BODY is set */body&&FORCE_BODY&&_forceRemove(body.firstChild)
/* Get node iterator */;var nodeIterator=_createIterator(IN_PLACE?dirty:body);
/* Now start iterating over the created document */while(currentNode=nodeIterator.nextNode())
/* Fix IE's strange behavior with manipulated textNodes #89 */
3===currentNode.nodeType&&currentNode===oldNode||_sanitizeElements(currentNode)||(
/* Shadow DOM detected, sanitize it */
currentNode.content instanceof DocumentFragment&&_sanitizeShadowDOM(currentNode.content)
/* Check attributes, sanitize if necessary */,_sanitizeAttributes(currentNode),oldNode=currentNode)
/* Sanitize tags and elements */;
/* If we sanitized `dirty` in-place, return it. */
if(oldNode=null,IN_PLACE)return dirty;
/* Return sanitized string or DOM */if(RETURN_DOM){if(RETURN_DOM_FRAGMENT){returnNode=createDocumentFragment.call(body.ownerDocument);while(body.firstChild)
// eslint-disable-next-line unicorn/prefer-dom-node-append
returnNode.appendChild(body.firstChild)}else returnNode=body;return ALLOWED_ATTR.shadowroot&&(
/*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
returnNode=importNode.call(originalDocument,returnNode,!0)),returnNode}var serializedHTML=WHOLE_DOCUMENT?body.outerHTML:body.innerHTML;
/* Serialize doctype if allowed */return WHOLE_DOCUMENT&&ALLOWED_TAGS["!doctype"]&&body.ownerDocument&&body.ownerDocument.doctype&&body.ownerDocument.doctype.name&&regExpTest$2(DOCTYPE_NAME$2,body.ownerDocument.doctype.name)&&(serializedHTML="<!DOCTYPE "+body.ownerDocument.doctype.name+">\n"+serializedHTML)
/* Sanitize final string template-safe */,SAFE_FOR_TEMPLATES&&(serializedHTML=stringReplace$2(serializedHTML,MUSTACHE_EXPR$1," "),serializedHTML=stringReplace$2(serializedHTML,ERB_EXPR$1," ")),trustedTypesPolicy&&RETURN_TRUSTED_TYPE?trustedTypesPolicy.createHTML(serializedHTML):serializedHTML},
/**
   * Public method to set the configuration once
   * setConfig
   *
   * @param {Object} cfg configuration object
   */
DOMPurify.setConfig=function(cfg){_parseConfig(cfg),SET_CONFIG=!0},
/**
   * Public method to remove the configuration
   * clearConfig
   *
   */
DOMPurify.clearConfig=function(){CONFIG=null,SET_CONFIG=!1},
/**
   * Public method to check if an attribute value is valid.
   * Uses last set config, if any. Otherwise, uses config defaults.
   * isValidAttribute
   *
   * @param  {string} tag Tag name of containing element.
   * @param  {string} attr Attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
   */
DOMPurify.isValidAttribute=function(tag,attr,value){
/* Initialize shared config vars if necessary. */
CONFIG||_parseConfig({});var lcTag=transformCaseFunc(tag),lcName=transformCaseFunc(attr);return _isValidAttribute(lcTag,lcName,value)},
/**
   * AddHook
   * Public method to add DOMPurify hooks
   *
   * @param {String} entryPoint entry point for the hook to add
   * @param {Function} hookFunction function to execute
   */
DOMPurify.addHook=function(entryPoint,hookFunction){"function"===typeof hookFunction&&(hooks[entryPoint]=hooks[entryPoint]||[],arrayPush$2(hooks[entryPoint],hookFunction))},
/**
   * RemoveHook
   * Public method to remove a DOMPurify hook at a given entryPoint
   * (pops it from the stack of hooks if more are present)
   *
   * @param {String} entryPoint entry point for the hook to remove
   * @return {Function} removed(popped) hook
   */
DOMPurify.removeHook=function(entryPoint){if(hooks[entryPoint])return arrayPop$2(hooks[entryPoint])},
/**
   * RemoveHooks
   * Public method to remove all DOMPurify hooks at a given entryPoint
   *
   * @param  {String} entryPoint entry point for the hooks to remove
   */
DOMPurify.removeHooks=function(entryPoint){hooks[entryPoint]&&(hooks[entryPoint]=[])},
/**
   * RemoveAllHooks
   * Public method to remove all DOMPurify hooks
   *
   */
DOMPurify.removeAllHooks=function(){hooks={}},DOMPurify}
// ::- Persistent data structure representing an ordered mapping from
// strings to values, with some convenient update methods.
function OrderedMap$2(content){this.content=content}function findDiffStart$2(a,b,pos){for(let i=0;;i++){if(i==a.childCount||i==b.childCount)return a.childCount==b.childCount?null:pos;let childA=a.child(i),childB=b.child(i);if(childA!=childB){if(!childA.sameMarkup(childB))return pos;if(childA.isText&&childA.text!=childB.text){for(let j=0;childA.text[j]==childB.text[j];j++)pos++;return pos}if(childA.content.size||childB.content.size){let inner=findDiffStart$2(childA.content,childB.content,pos+1);if(null!=inner)return inner}pos+=childA.nodeSize}else pos+=childA.nodeSize}}function findDiffEnd$2(a,b,posA,posB){for(let iA=a.childCount,iB=b.childCount;;){if(0==iA||0==iB)return iA==iB?null:{a:posA,b:posB};let childA=a.child(--iA),childB=b.child(--iB),size=childA.nodeSize;if(childA!=childB){if(!childA.sameMarkup(childB))return{a:posA,b:posB};if(childA.isText&&childA.text!=childB.text){let same=0,minSize=Math.min(childA.text.length,childB.text.length);while(same<minSize&&childA.text[childA.text.length-same-1]==childB.text[childB.text.length-same-1])same++,posA--,posB--;return{a:posA,b:posB}}if(childA.content.size||childB.content.size){let inner=findDiffEnd$2(childA.content,childB.content,posA-1,posB-1);if(inner)return inner}posA-=size,posB-=size}else posA-=size,posB-=size}}
/**
A fragment represents a node's collection of child nodes.

Like nodes, fragments are persistent data structures, and you
should not mutate them or their content. Rather, you create new
instances whenever needed. The API tries to make this easy.
*/createDOMPurify$2(),OrderedMap$2.prototype={constructor:OrderedMap$2,find:function(key){for(var i=0;i<this.content.length;i+=2)if(this.content[i]===key)return i;return-1},
// :: (string) → ?any
// Retrieve the value stored under `key`, or return undefined when
// no such key exists.
get:function(key){var found=this.find(key);return-1==found?void 0:this.content[found+1]},
// :: (string, any, ?string) → OrderedMap
// Create a new map by replacing the value of `key` with a new
// value, or adding a binding to the end of the map. If `newKey` is
// given, the key of the binding will be replaced with that key.
update:function(key,value,newKey){var self=newKey&&newKey!=key?this.remove(newKey):this,found=self.find(key),content=self.content.slice();return-1==found?content.push(newKey||key,value):(content[found+1]=value,newKey&&(content[found]=newKey)),new OrderedMap$2(content)},
// :: (string) → OrderedMap
// Return a map with the given key removed, if it existed.
remove:function(key){var found=this.find(key);if(-1==found)return this;var content=this.content.slice();return content.splice(found,2),new OrderedMap$2(content)},
// :: (string, any) → OrderedMap
// Add a new key to the start of the map.
addToStart:function(key,value){return new OrderedMap$2([key,value].concat(this.remove(key).content))},
// :: (string, any) → OrderedMap
// Add a new key to the end of the map.
addToEnd:function(key,value){var content=this.remove(key).content.slice();return content.push(key,value),new OrderedMap$2(content)},
// :: (string, string, any) → OrderedMap
// Add a key after the given key. If `place` is not found, the new
// key is added to the end.
addBefore:function(place,key,value){var without=this.remove(key),content=without.content.slice(),found=without.find(place);return content.splice(-1==found?content.length:found,0,key,value),new OrderedMap$2(content)},
// :: ((key: string, value: any))
// Call the given function for each key/value pair in the map, in
// order.
forEach:function(f){for(var i=0;i<this.content.length;i+=2)f(this.content[i],this.content[i+1])},
// :: (union<Object, OrderedMap>) → OrderedMap
// Create a new map by prepending the keys in this map that don't
// appear in `map` before the keys in `map`.
prepend:function(map){return map=OrderedMap$2.from(map),map.size?new OrderedMap$2(map.content.concat(this.subtract(map).content)):this},
// :: (union<Object, OrderedMap>) → OrderedMap
// Create a new map by appending the keys in this map that don't
// appear in `map` after the keys in `map`.
append:function(map){return map=OrderedMap$2.from(map),map.size?new OrderedMap$2(this.subtract(map).content.concat(map.content)):this},
// :: (union<Object, OrderedMap>) → OrderedMap
// Create a map containing all the keys in this map that don't
// appear in `map`.
subtract:function(map){var result=this;map=OrderedMap$2.from(map);for(var i=0;i<map.content.length;i+=2)result=result.remove(map.content[i]);return result},
// :: number
// The amount of keys in this map.
get size(){return this.content.length>>1}},
// :: (?union<Object, OrderedMap>) → OrderedMap
// Return a map with the given content. If null, create an empty
// map. If given an ordered map, return that map itself. If given an
// object, create a map from the object's properties.
OrderedMap$2.from=function(value){if(value instanceof OrderedMap$2)return value;var content=[];if(value)for(var prop in value)content.push(prop,value[prop]);return new OrderedMap$2(content)};class Fragment$2{
/**
    @internal
    */
constructor(
/**
    @internal
    */
content,size){if(this.content=content,this.size=size||0,null==size)for(let i=0;i<content.length;i++)this.size+=content[i].nodeSize}
/**
    Invoke a callback for all descendant nodes between the given two
    positions (relative to start of this fragment). Doesn't descend
    into a node when the callback returns `false`.
    */nodesBetween(from,to,f,nodeStart=0,parent){for(let i=0,pos=0;pos<to;i++){let child=this.content[i],end=pos+child.nodeSize;if(end>from&&!1!==f(child,nodeStart+pos,parent||null,i)&&child.content.size){let start=pos+1;child.nodesBetween(Math.max(0,from-start),Math.min(child.content.size,to-start),f,nodeStart+start)}pos=end}}
/**
    Call the given callback for every descendant node. `pos` will be
    relative to the start of the fragment. The callback may return
    `false` to prevent traversal of a given node's children.
    */descendants(f){this.nodesBetween(0,this.size,f)}
/**
    Extract the text between `from` and `to`. See the same method on
    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
    */textBetween(from,to,blockSeparator,leafText){let text="",separated=!0;return this.nodesBetween(from,to,((node,pos)=>{node.isText?(text+=node.text.slice(Math.max(from,pos)-pos,to-pos),separated=!blockSeparator):node.isLeaf?(leafText?text+="function"===typeof leafText?leafText(node):leafText:node.type.spec.leafText&&(text+=node.type.spec.leafText(node)),separated=!blockSeparator):!separated&&node.isBlock&&(text+=blockSeparator,separated=!0)}),0),text}
/**
    Create a new fragment containing the combined content of this
    fragment and the other.
    */append(other){if(!other.size)return this;if(!this.size)return other;let last=this.lastChild,first=other.firstChild,content=this.content.slice(),i=0;for(last.isText&&last.sameMarkup(first)&&(content[content.length-1]=last.withText(last.text+first.text),i=1);i<other.content.length;i++)content.push(other.content[i]);return new Fragment$2(content,this.size+other.size)}
/**
    Cut out the sub-fragment between the two given positions.
    */cut(from,to=this.size){if(0==from&&to==this.size)return this;let result=[],size=0;if(to>from)for(let i=0,pos=0;pos<to;i++){let child=this.content[i],end=pos+child.nodeSize;end>from&&((pos<from||end>to)&&(child=child.isText?child.cut(Math.max(0,from-pos),Math.min(child.text.length,to-pos)):child.cut(Math.max(0,from-pos-1),Math.min(child.content.size,to-pos-1))),result.push(child),size+=child.nodeSize),pos=end}return new Fragment$2(result,size)}
/**
    @internal
    */cutByIndex(from,to){return from==to?Fragment$2.empty:0==from&&to==this.content.length?this:new Fragment$2(this.content.slice(from,to))}
/**
    Create a new fragment in which the node at the given index is
    replaced by the given node.
    */replaceChild(index,node){let current=this.content[index];if(current==node)return this;let copy=this.content.slice(),size=this.size+node.nodeSize-current.nodeSize;return copy[index]=node,new Fragment$2(copy,size)}
/**
    Create a new fragment by prepending the given node to this
    fragment.
    */addToStart(node){return new Fragment$2([node].concat(this.content),this.size+node.nodeSize)}
/**
    Create a new fragment by appending the given node to this
    fragment.
    */addToEnd(node){return new Fragment$2(this.content.concat(node),this.size+node.nodeSize)}
/**
    Compare this fragment to another one.
    */eq(other){if(this.content.length!=other.content.length)return!1;for(let i=0;i<this.content.length;i++)if(!this.content[i].eq(other.content[i]))return!1;return!0}
/**
    The first child of the fragment, or `null` if it is empty.
    */get firstChild(){return this.content.length?this.content[0]:null}
/**
    The last child of the fragment, or `null` if it is empty.
    */get lastChild(){return this.content.length?this.content[this.content.length-1]:null}
/**
    The number of child nodes in this fragment.
    */get childCount(){return this.content.length}
/**
    Get the child node at the given index. Raise an error when the
    index is out of range.
    */child(index){let found=this.content[index];if(!found)throw new RangeError("Index "+index+" out of range for "+this);return found}
/**
    Get the child node at the given index, if it exists.
    */maybeChild(index){return this.content[index]||null}
/**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */forEach(f){for(let i=0,p=0;i<this.content.length;i++){let child=this.content[i];f(child,p,i),p+=child.nodeSize}}
/**
    Find the first position at which this fragment and another
    fragment differ, or `null` if they are the same.
    */findDiffStart(other,pos=0){return findDiffStart$2(this,other,pos)}
/**
    Find the first position, searching from the end, at which this
    fragment and the given fragment differ, or `null` if they are
    the same. Since this position will not be the same in both
    nodes, an object with two separate positions is returned.
    */findDiffEnd(other,pos=this.size,otherPos=other.size){return findDiffEnd$2(this,other,pos,otherPos)}
/**
    Find the index and inner offset corresponding to a given relative
    position in this fragment. The result object will be reused
    (overwritten) the next time the function is called. (Not public.)
    */findIndex(pos,round=-1){if(0==pos)return retIndex$2(0,pos);if(pos==this.size)return retIndex$2(this.content.length,pos);if(pos>this.size||pos<0)throw new RangeError(`Position ${pos} outside of fragment (${this})`);for(let i=0,curPos=0;;i++){let cur=this.child(i),end=curPos+cur.nodeSize;if(end>=pos)return end==pos||round>0?retIndex$2(i+1,end):retIndex$2(i,curPos);curPos=end}}
/**
    Return a debugging string that describes this fragment.
    */toString(){return"<"+this.toStringInner()+">"}
/**
    @internal
    */toStringInner(){return this.content.join(", ")}
/**
    Create a JSON-serializeable representation of this fragment.
    */toJSON(){return this.content.length?this.content.map((n=>n.toJSON())):null}
/**
    Deserialize a fragment from its JSON representation.
    */static fromJSON(schema,value){if(!value)return Fragment$2.empty;if(!Array.isArray(value))throw new RangeError("Invalid input for Fragment.fromJSON");return new Fragment$2(value.map(schema.nodeFromJSON))}
/**
    Build a fragment from an array of nodes. Ensures that adjacent
    text nodes with the same marks are joined together.
    */static fromArray(array){if(!array.length)return Fragment$2.empty;let joined,size=0;for(let i=0;i<array.length;i++){let node=array[i];size+=node.nodeSize,i&&node.isText&&array[i-1].sameMarkup(node)?(joined||(joined=array.slice(0,i)),joined[joined.length-1]=node.withText(joined[joined.length-1].text+node.text)):joined&&joined.push(node)}return new Fragment$2(joined||array,size)}
/**
    Create a fragment from something that can be interpreted as a
    set of nodes. For `null`, it returns the empty fragment. For a
    fragment, the fragment itself. For a node or array of nodes, a
    fragment containing those nodes.
    */static from(nodes){if(!nodes)return Fragment$2.empty;if(nodes instanceof Fragment$2)return nodes;if(Array.isArray(nodes))return this.fromArray(nodes);if(nodes.attrs)return new Fragment$2([nodes],nodes.nodeSize);throw new RangeError("Can not convert "+nodes+" to a Fragment"+(nodes.nodesBetween?" (looks like multiple versions of prosemirror-model were loaded)":""))}}
/**
An empty fragment. Intended to be reused whenever a node doesn't
contain anything (rather than allocating a new empty fragment for
each leaf node).
*/Fragment$2.empty=new Fragment$2([],0);const found$2={index:0,offset:0};function retIndex$2(index,offset){return found$2.index=index,found$2.offset=offset,found$2}function compareDeep$2(a,b){if(a===b)return!0;if(!a||"object"!=typeof a||!b||"object"!=typeof b)return!1;let array=Array.isArray(a);if(Array.isArray(b)!=array)return!1;if(array){if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(!compareDeep$2(a[i],b[i]))return!1}else{for(let p in a)if(!(p in b)||!compareDeep$2(a[p],b[p]))return!1;for(let p in b)if(!(p in a))return!1}return!0}
/**
A mark is a piece of information that can be attached to a node,
such as it being emphasized, in code font, or a link. It has a
type and optionally a set of attributes that provide further
information (such as the target of the link). Marks are created
through a `Schema`, which controls which types exist and which
attributes they have.
*/class Mark$1$2{
/**
    @internal
    */
constructor(
/**
    The type of this mark.
    */
type,
/**
    The attributes associated with this mark.
    */
attrs){this.type=type,this.attrs=attrs}
/**
    Given a set of marks, create a new set which contains this one as
    well, in the right position. If this mark is already in the set,
    the set itself is returned. If any marks that are set to be
    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
    those are replaced by this one.
    */addToSet(set){let copy,placed=!1;for(let i=0;i<set.length;i++){let other=set[i];if(this.eq(other))return set;if(this.type.excludes(other.type))copy||(copy=set.slice(0,i));else{if(other.type.excludes(this.type))return set;!placed&&other.type.rank>this.type.rank&&(copy||(copy=set.slice(0,i)),copy.push(this),placed=!0),copy&&copy.push(other)}}return copy||(copy=set.slice()),placed||copy.push(this),copy}
/**
    Remove this mark from the given set, returning a new set. If this
    mark is not in the set, the set itself is returned.
    */removeFromSet(set){for(let i=0;i<set.length;i++)if(this.eq(set[i]))return set.slice(0,i).concat(set.slice(i+1));return set}
/**
    Test whether this mark is in the given set of marks.
    */isInSet(set){for(let i=0;i<set.length;i++)if(this.eq(set[i]))return!0;return!1}
/**
    Test whether this mark has the same type and attributes as
    another mark.
    */eq(other){return this==other||this.type==other.type&&compareDeep$2(this.attrs,other.attrs)}
/**
    Convert this mark to a JSON-serializeable representation.
    */toJSON(){let obj={type:this.type.name};for(let _ in this.attrs){obj.attrs=this.attrs;break}return obj}
/**
    Deserialize a mark from JSON.
    */static fromJSON(schema,json){if(!json)throw new RangeError("Invalid input for Mark.fromJSON");let type=schema.marks[json.type];if(!type)throw new RangeError(`There is no mark type ${json.type} in this schema`);return type.create(json.attrs)}
/**
    Test whether two sets of marks are identical.
    */static sameSet(a,b){if(a==b)return!0;if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(!a[i].eq(b[i]))return!1;return!0}
/**
    Create a properly sorted mark set from null, a single mark, or an
    unsorted array of marks.
    */static setFrom(marks){if(!marks||Array.isArray(marks)&&0==marks.length)return Mark$1$2.none;if(marks instanceof Mark$1$2)return[marks];let copy=marks.slice();return copy.sort(((a,b)=>a.type.rank-b.type.rank)),copy}}
/**
The empty set of marks.
*/Mark$1$2.none=[];
/**
Error type raised by [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) when
given an invalid replacement.
*/
class ReplaceError$2 extends Error{}
/*
ReplaceError = function(this: any, message: string) {
  let err = Error.call(this, message)
  ;(err as any).__proto__ = ReplaceError.prototype
  return err
} as any

ReplaceError.prototype = Object.create(Error.prototype)
ReplaceError.prototype.constructor = ReplaceError
ReplaceError.prototype.name = "ReplaceError"
*/
/**
A slice represents a piece cut out of a larger document. It
stores not only a fragment, but also the depth up to which nodes on
both side are ‘open’ (cut through).
*/class Slice$2{
/**
    Create a slice. When specifying a non-zero open depth, you must
    make sure that there are nodes of at least that depth at the
    appropriate side of the fragment—i.e. if the fragment is an
    empty paragraph node, `openStart` and `openEnd` can't be greater
    than 1.
    
    It is not necessary for the content of open nodes to conform to
    the schema's content constraints, though it should be a valid
    start/end/middle for such a node, depending on which sides are
    open.
    */
constructor(
/**
    The slice's content.
    */
content,
/**
    The open depth at the start of the fragment.
    */
openStart,
/**
    The open depth at the end.
    */
openEnd){this.content=content,this.openStart=openStart,this.openEnd=openEnd}
/**
    The size this slice would add when inserted into a document.
    */get size(){return this.content.size-this.openStart-this.openEnd}
/**
    @internal
    */insertAt(pos,fragment){let content=insertInto$2(this.content,pos+this.openStart,fragment);return content&&new Slice$2(content,this.openStart,this.openEnd)}
/**
    @internal
    */removeBetween(from,to){return new Slice$2(removeRange$2(this.content,from+this.openStart,to+this.openStart),this.openStart,this.openEnd)}
/**
    Tests whether this slice is equal to another slice.
    */eq(other){return this.content.eq(other.content)&&this.openStart==other.openStart&&this.openEnd==other.openEnd}
/**
    @internal
    */toString(){return this.content+"("+this.openStart+","+this.openEnd+")"}
/**
    Convert a slice to a JSON-serializable representation.
    */toJSON(){if(!this.content.size)return null;let json={content:this.content.toJSON()};return this.openStart>0&&(json.openStart=this.openStart),this.openEnd>0&&(json.openEnd=this.openEnd),json}
/**
    Deserialize a slice from its JSON representation.
    */static fromJSON(schema,json){if(!json)return Slice$2.empty;let openStart=json.openStart||0,openEnd=json.openEnd||0;if("number"!=typeof openStart||"number"!=typeof openEnd)throw new RangeError("Invalid input for Slice.fromJSON");return new Slice$2(Fragment$2.fromJSON(schema,json.content),openStart,openEnd)}
/**
    Create a slice from a fragment by taking the maximum possible
    open value on both side of the fragment.
    */static maxOpen(fragment,openIsolating=!0){let openStart=0,openEnd=0;for(let n=fragment.firstChild;n&&!n.isLeaf&&(openIsolating||!n.type.spec.isolating);n=n.firstChild)openStart++;for(let n=fragment.lastChild;n&&!n.isLeaf&&(openIsolating||!n.type.spec.isolating);n=n.lastChild)openEnd++;return new Slice$2(fragment,openStart,openEnd)}}
/**
The empty slice.
*/function removeRange$2(content,from,to){let{index:index,offset:offset}=content.findIndex(from),child=content.maybeChild(index),{index:indexTo,offset:offsetTo}=content.findIndex(to);if(offset==from||child.isText){if(offsetTo!=to&&!content.child(indexTo).isText)throw new RangeError("Removing non-flat range");return content.cut(0,from).append(content.cut(to))}if(index!=indexTo)throw new RangeError("Removing non-flat range");return content.replaceChild(index,child.copy(removeRange$2(child.content,from-offset-1,to-offset-1)))}function insertInto$2(content,dist,insert,parent){let{index:index,offset:offset}=content.findIndex(dist),child=content.maybeChild(index);if(offset==dist||child.isText)return parent&&!parent.canReplace(index,index,insert)?null:content.cut(0,dist).append(insert).append(content.cut(dist));let inner=insertInto$2(child.content,dist-offset-1,insert);return inner&&content.replaceChild(index,child.copy(inner))}
/**
Represents a flat range of content, i.e. one that starts and
ends in the same node.
*/Slice$2.empty=new Slice$2(Fragment$2.empty,0,0);class NodeRange$2{
/**
    Construct a node range. `$from` and `$to` should point into the
    same node until at least the given `depth`, since a node range
    denotes an adjacent set of nodes in a single parent node.
    */
constructor(
/**
    A resolved position along the start of the content. May have a
    `depth` greater than this object's `depth` property, since
    these are the positions that were used to compute the range,
    not re-resolved positions directly at its boundaries.
    */
$from,
/**
    A position along the end of the content. See
    caveat for [`$from`](https://prosemirror.net/docs/ref/#model.NodeRange.$from).
    */
$to,
/**
    The depth of the node that this range points into.
    */
depth){this.$from=$from,this.$to=$to,this.depth=depth}
/**
    The position at the start of the range.
    */get start(){return this.$from.before(this.depth+1)}
/**
    The position at the end of the range.
    */get end(){return this.$to.after(this.depth+1)}
/**
    The parent node that the range points into.
    */get parent(){return this.$from.node(this.depth)}
/**
    The start index of the range in the parent node.
    */get startIndex(){return this.$from.index(this.depth)}
/**
    The end index of the range in the parent node.
    */get endIndex(){return this.$to.indexAfter(this.depth)}}
// For node types where all attrs have a default value (or which don't
// have any attributes), build up a single reusable default attribute
// object, and use it for all nodes that don't specify specific
// attributes.
function defaultAttrs$2(attrs){let defaults=Object.create(null);for(let attrName in attrs){let attr=attrs[attrName];if(!attr.hasDefault)return null;defaults[attrName]=attr.default}return defaults}function computeAttrs$2(attrs,value){let built=Object.create(null);for(let name in attrs){let given=value&&value[name];if(void 0===given){let attr=attrs[name];if(!attr.hasDefault)throw new RangeError("No value supplied for attribute "+name);given=attr.default}built[name]=given}return built}function initAttrs$2(attrs){let result=Object.create(null);if(attrs)for(let name in attrs)result[name]=new Attribute$2(attrs[name]);return result}
// Attribute descriptors
class Attribute$2{constructor(options){this.hasDefault=Object.prototype.hasOwnProperty.call(options,"default"),this.default=options.default}get isRequired(){return!this.hasDefault}}
// Marks
/**
Like nodes, marks (which are associated with nodes to signify
things like emphasis or being part of a link) are
[tagged](https://prosemirror.net/docs/ref/#model.Mark.type) with type objects, which are
instantiated once per `Schema`.
*/class MarkType$2{
/**
    @internal
    */
constructor(
/**
    The name of the mark type.
    */
name,
/**
    @internal
    */
rank,
/**
    The schema that this mark type instance is part of.
    */
schema,
/**
    The spec on which the type is based.
    */
spec){this.name=name,this.rank=rank,this.schema=schema,this.spec=spec,this.attrs=initAttrs$2(spec.attrs),this.excluded=null;let defaults=defaultAttrs$2(this.attrs);this.instance=defaults?new Mark$1$2(this,defaults):null}
/**
    Create a mark of this type. `attrs` may be `null` or an object
    containing only some of the mark's attributes. The others, if
    they have defaults, will be added.
    */create(attrs=null){return!attrs&&this.instance?this.instance:new Mark$1$2(this,computeAttrs$2(this.attrs,attrs))}
/**
    @internal
    */static compile(marks,schema){let result=Object.create(null),rank=0;return marks.forEach(((name,spec)=>result[name]=new MarkType$2(name,rank++,schema,spec))),result}
/**
    When there is a mark of this type in the given set, a new set
    without it is returned. Otherwise, the input set is returned.
    */removeFromSet(set){for(var i=0;i<set.length;i++)set[i].type==this&&(set=set.slice(0,i).concat(set.slice(i+1)),i--);return set}
/**
    Tests whether there is a mark of this type in the given set.
    */isInSet(set){for(let i=0;i<set.length;i++)if(set[i].type==this)return set[i]}
/**
    Queries whether a given mark type is
    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
    */excludes(other){return this.excluded.indexOf(other)>-1}}
/**
A DOM parser represents a strategy for parsing DOM content into a
ProseMirror document conforming to a given schema. Its behavior is
defined by an array of [rules](https://prosemirror.net/docs/ref/#model.ParseRule).
*/class DOMParser$1$2{
/**
    Create a parser that targets the given schema, using the given
    parsing rules.
    */
constructor(
/**
    The schema into which the parser parses.
    */
schema,
/**
    The set of [parse rules](https://prosemirror.net/docs/ref/#model.ParseRule) that the parser
    uses, in order of precedence.
    */
rules){this.schema=schema,this.rules=rules,
/**
        @internal
        */
this.tags=[],
/**
        @internal
        */
this.styles=[],rules.forEach((rule=>{rule.tag?this.tags.push(rule):rule.style&&this.styles.push(rule)})),
// Only normalize list elements when lists in the schema can't directly contain themselves
this.normalizeLists=!this.tags.some((r=>{if(!/^(ul|ol)\b/.test(r.tag)||!r.node)return!1;let node=schema.nodes[r.node];return node.contentMatch.matchType(node)}))}
/**
    Parse a document from the content of a DOM node.
    */parse(dom,options={}){let context=new ParseContext$2(this,options,!1);return context.addAll(dom,options.from,options.to),context.finish()}
/**
    Parses the content of the given DOM node, like
    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
    options. But unlike that method, which produces a whole node,
    this one returns a slice that is open at the sides, meaning that
    the schema constraints aren't applied to the start of nodes to
    the left of the input and the end of nodes at the end.
    */parseSlice(dom,options={}){let context=new ParseContext$2(this,options,!0);return context.addAll(dom,options.from,options.to),Slice$2.maxOpen(context.finish())}
/**
    @internal
    */matchTag(dom,context,after){for(let i=after?this.tags.indexOf(after)+1:0;i<this.tags.length;i++){let rule=this.tags[i];if(matches$1$2(dom,rule.tag)&&(void 0===rule.namespace||dom.namespaceURI==rule.namespace)&&(!rule.context||context.matchesContext(rule.context))){if(rule.getAttrs){let result=rule.getAttrs(dom);if(!1===result)continue;rule.attrs=result||void 0}return rule}}}
/**
    @internal
    */matchStyle(prop,value,context,after){for(let i=after?this.styles.indexOf(after)+1:0;i<this.styles.length;i++){let rule=this.styles[i],style=rule.style;if(!(0!=style.indexOf(prop)||rule.context&&!context.matchesContext(rule.context)||
// Test that the style string either precisely matches the prop,
// or has an '=' sign after the prop, followed by the given
// value.
style.length>prop.length&&(61!=style.charCodeAt(prop.length)||style.slice(prop.length+1)!=value))){if(rule.getAttrs){let result=rule.getAttrs(value);if(!1===result)continue;rule.attrs=result||void 0}return rule}}}
/**
    @internal
    */static schemaRules(schema){let result=[];function insert(rule){let priority=null==rule.priority?50:rule.priority,i=0;for(;i<result.length;i++){let next=result[i],nextPriority=null==next.priority?50:next.priority;if(nextPriority<priority)break}result.splice(i,0,rule)}for(let name in schema.marks){let rules=schema.marks[name].spec.parseDOM;rules&&rules.forEach((rule=>{insert(rule=copy$2(rule)),rule.mark=name}))}for(let name in schema.nodes){let rules=schema.nodes[name].spec.parseDOM;rules&&rules.forEach((rule=>{insert(rule=copy$2(rule)),rule.node=name}))}return result}
/**
    Construct a DOM parser using the parsing rules listed in a
    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
    */static fromSchema(schema){return schema.cached.domParser||(schema.cached.domParser=new DOMParser$1$2(schema,DOMParser$1$2.schemaRules(schema)))}}const blockTags$2={address:!0,article:!0,aside:!0,blockquote:!0,canvas:!0,dd:!0,div:!0,dl:!0,fieldset:!0,figcaption:!0,figure:!0,footer:!0,form:!0,h1:!0,h2:!0,h3:!0,h4:!0,h5:!0,h6:!0,header:!0,hgroup:!0,hr:!0,li:!0,noscript:!0,ol:!0,output:!0,p:!0,pre:!0,section:!0,table:!0,tfoot:!0,ul:!0},ignoreTags$2={head:!0,noscript:!0,object:!0,script:!0,style:!0,title:!0},listTags$2={ol:!0,ul:!0},OPT_PRESERVE_WS$2=1,OPT_PRESERVE_WS_FULL$2=2,OPT_OPEN_LEFT$2=4;function wsOptionsFor$2(type,preserveWhitespace,base){return null!=preserveWhitespace?(preserveWhitespace?OPT_PRESERVE_WS$2:0)|("full"===preserveWhitespace?OPT_PRESERVE_WS_FULL$2:0):type&&"pre"==type.whitespace?OPT_PRESERVE_WS$2|OPT_PRESERVE_WS_FULL$2:base&~OPT_OPEN_LEFT$2}class NodeContext$2{constructor(type,attrs,
// Marks applied to this node itself
marks,
// Marks that can't apply here, but will be used in children if possible
pendingMarks,solid,match,options){this.type=type,this.attrs=attrs,this.marks=marks,this.pendingMarks=pendingMarks,this.solid=solid,this.options=options,this.content=[],
// Marks applied to the node's children
this.activeMarks=Mark$1$2.none,
// Nested Marks with same type
this.stashMarks=[],this.match=match||(options&OPT_OPEN_LEFT$2?null:type.contentMatch)}findWrapping(node){if(!this.match){if(!this.type)return[];let fill=this.type.contentMatch.fillBefore(Fragment$2.from(node));if(!fill){let wrap,start=this.type.contentMatch;return(wrap=start.findWrapping(node.type))?(this.match=start,wrap):null}this.match=this.type.contentMatch.matchFragment(fill)}return this.match.findWrapping(node.type)}finish(openEnd){if(!(this.options&OPT_PRESERVE_WS$2)){// Strip trailing whitespace
let m,last=this.content[this.content.length-1];if(last&&last.isText&&(m=/[ \t\r\n\u000c]+$/.exec(last.text))){let text=last;last.text.length==m[0].length?this.content.pop():this.content[this.content.length-1]=text.withText(text.text.slice(0,text.text.length-m[0].length))}}let content=Fragment$2.from(this.content);return!openEnd&&this.match&&(content=content.append(this.match.fillBefore(Fragment$2.empty,!0))),this.type?this.type.create(this.attrs,content,this.marks):content}popFromStashMark(mark){for(let i=this.stashMarks.length-1;i>=0;i--)if(mark.eq(this.stashMarks[i]))return this.stashMarks.splice(i,1)[0]}applyPending(nextType){for(let i=0,pending=this.pendingMarks;i<pending.length;i++){let mark=pending[i];(this.type?this.type.allowsMarkType(mark.type):markMayApply$2(mark.type,nextType))&&!mark.isInSet(this.activeMarks)&&(this.activeMarks=mark.addToSet(this.activeMarks),this.pendingMarks=mark.removeFromSet(this.pendingMarks))}}inlineContext(node){return this.type?this.type.inlineContent:this.content.length?this.content[0].isInline:node.parentNode&&!blockTags$2.hasOwnProperty(node.parentNode.nodeName.toLowerCase())}}class ParseContext$2{constructor(
// The parser we are using.
parser,
// The options passed to this parse.
options,isOpen){this.parser=parser,this.options=options,this.isOpen=isOpen,this.open=0;let topContext,topNode=options.topNode,topOptions=wsOptionsFor$2(null,options.preserveWhitespace,0)|(isOpen?OPT_OPEN_LEFT$2:0);topContext=topNode?new NodeContext$2(topNode.type,topNode.attrs,Mark$1$2.none,Mark$1$2.none,!0,options.topMatch||topNode.type.contentMatch,topOptions):new NodeContext$2(isOpen?null:parser.schema.topNodeType,null,Mark$1$2.none,Mark$1$2.none,!0,null,topOptions),this.nodes=[topContext],this.find=options.findPositions,this.needsBlock=!1}get top(){return this.nodes[this.open]}
// Add a DOM node to the content. Text is inserted as text node,
// otherwise, the node is passed to `addElement` or, if it has a
// `style` attribute, `addElementWithStyles`.
addDOM(dom){if(3==dom.nodeType)this.addTextNode(dom);else if(1==dom.nodeType){let style=dom.getAttribute("style"),marks=style?this.readStyles(parseStyles$2(style)):null,top=this.top;if(null!=marks)for(let i=0;i<marks.length;i++)this.addPendingMark(marks[i]);if(this.addElement(dom),null!=marks)for(let i=0;i<marks.length;i++)this.removePendingMark(marks[i],top)}}addTextNode(dom){let value=dom.nodeValue,top=this.top;if(top.options&OPT_PRESERVE_WS_FULL$2||top.inlineContext(dom)||/[^ \t\r\n\u000c]/.test(value)){if(top.options&OPT_PRESERVE_WS$2)value=top.options&OPT_PRESERVE_WS_FULL$2?value.replace(/\r\n?/g,"\n"):value.replace(/\r?\n|\r/g," ");else
// If this starts with whitespace, and there is no node before it, or
// a hard break, or a text node that ends with whitespace, strip the
// leading space.
if(value=value.replace(/[ \t\r\n\u000c]+/g," "),/^[ \t\r\n\u000c]/.test(value)&&this.open==this.nodes.length-1){let nodeBefore=top.content[top.content.length-1],domNodeBefore=dom.previousSibling;(!nodeBefore||domNodeBefore&&"BR"==domNodeBefore.nodeName||nodeBefore.isText&&/[ \t\r\n\u000c]$/.test(nodeBefore.text))&&(value=value.slice(1))}value&&this.insertNode(this.parser.schema.text(value)),this.findInText(dom)}else this.findInside(dom)}
// Try to find a handler for the given tag and use that to parse. If
// none is found, the element's content nodes are added directly.
addElement(dom,matchAfter){let ruleID,name=dom.nodeName.toLowerCase();listTags$2.hasOwnProperty(name)&&this.parser.normalizeLists&&normalizeList$2(dom);let rule=this.options.ruleFromNode&&this.options.ruleFromNode(dom)||(ruleID=this.parser.matchTag(dom,this,matchAfter));if(rule?rule.ignore:ignoreTags$2.hasOwnProperty(name))this.findInside(dom),this.ignoreFallback(dom);else if(!rule||rule.skip||rule.closeParent){rule&&rule.closeParent?this.open=Math.max(0,this.open-1):rule&&rule.skip.nodeType&&(dom=rule.skip);let sync,top=this.top,oldNeedsBlock=this.needsBlock;if(blockTags$2.hasOwnProperty(name))sync=!0,top.type||(this.needsBlock=!0);else if(!dom.firstChild)return void this.leafFallback(dom);this.addAll(dom),sync&&this.sync(top),this.needsBlock=oldNeedsBlock}else this.addElementByRule(dom,rule,!1===rule.consuming?ruleID:void 0)}
// Called for leaf DOM nodes that would otherwise be ignored
leafFallback(dom){"BR"==dom.nodeName&&this.top.type&&this.top.type.inlineContent&&this.addTextNode(dom.ownerDocument.createTextNode("\n"))}
// Called for ignored nodes
ignoreFallback(dom){
// Ignored BR nodes should at least create an inline context
"BR"!=dom.nodeName||this.top.type&&this.top.type.inlineContent||this.findPlace(this.parser.schema.text("-"))}
// Run any style parser associated with the node's styles. Either
// return an array of marks, or null to indicate some of the styles
// had a rule with `ignore` set.
readStyles(styles){let marks=Mark$1$2.none;style:for(let i=0;i<styles.length;i+=2)for(let after;;){let rule=this.parser.matchStyle(styles[i],styles[i+1],this,after);if(!rule)continue style;if(rule.ignore)return null;if(marks=this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks),!1!==rule.consuming)break;after=rule}return marks}
// Look up a handler for the given node. If none are found, return
// false. Otherwise, apply it, use its return value to drive the way
// the node's content is wrapped, and return true.
addElementByRule(dom,rule,continueAfter){let sync,nodeType,mark;if(rule.node)nodeType=this.parser.schema.nodes[rule.node],nodeType.isLeaf?this.insertNode(nodeType.create(rule.attrs))||this.leafFallback(dom):sync=this.enter(nodeType,rule.attrs||null,rule.preserveWhitespace);else{let markType=this.parser.schema.marks[rule.mark];mark=markType.create(rule.attrs),this.addPendingMark(mark)}let startIn=this.top;if(nodeType&&nodeType.isLeaf)this.findInside(dom);else if(continueAfter)this.addElement(dom,continueAfter);else if(rule.getContent)this.findInside(dom),rule.getContent(dom,this.parser.schema).forEach((node=>this.insertNode(node)));else{let contentDOM=dom;"string"==typeof rule.contentElement?contentDOM=dom.querySelector(rule.contentElement):"function"==typeof rule.contentElement?contentDOM=rule.contentElement(dom):rule.contentElement&&(contentDOM=rule.contentElement),this.findAround(dom,contentDOM,!0),this.addAll(contentDOM)}sync&&this.sync(startIn)&&this.open--,mark&&this.removePendingMark(mark,startIn)}
// Add all child nodes between `startIndex` and `endIndex` (or the
// whole node, if not given). If `sync` is passed, use it to
// synchronize after every block element.
addAll(parent,startIndex,endIndex){let index=startIndex||0;for(let dom=startIndex?parent.childNodes[startIndex]:parent.firstChild,end=null==endIndex?null:parent.childNodes[endIndex];dom!=end;dom=dom.nextSibling,++index)this.findAtPoint(parent,index),this.addDOM(dom);this.findAtPoint(parent,index)}
// Try to find a way to fit the given node type into the current
// context. May add intermediate wrappers and/or leave non-solid
// nodes that we're in.
findPlace(node){let route,sync;for(let depth=this.open;depth>=0;depth--){let cx=this.nodes[depth],found=cx.findWrapping(node);if(found&&(!route||route.length>found.length)&&(route=found,sync=cx,!found.length))break;if(cx.solid)break}if(!route)return!1;this.sync(sync);for(let i=0;i<route.length;i++)this.enterInner(route[i],null,!1);return!0}
// Try to insert the given node, adjusting the context when needed.
insertNode(node){if(node.isInline&&this.needsBlock&&!this.top.type){let block=this.textblockFromContext();block&&this.enterInner(block)}if(this.findPlace(node)){this.closeExtra();let top=this.top;top.applyPending(node.type),top.match&&(top.match=top.match.matchType(node.type));let marks=top.activeMarks;for(let i=0;i<node.marks.length;i++)top.type&&!top.type.allowsMarkType(node.marks[i].type)||(marks=node.marks[i].addToSet(marks));return top.content.push(node.mark(marks)),!0}return!1}
// Try to start a node of the given type, adjusting the context when
// necessary.
enter(type,attrs,preserveWS){let ok=this.findPlace(type.create(attrs));return ok&&this.enterInner(type,attrs,!0,preserveWS),ok}
// Open a node of the given type
enterInner(type,attrs=null,solid=!1,preserveWS){this.closeExtra();let top=this.top;top.applyPending(type),top.match=top.match&&top.match.matchType(type);let options=wsOptionsFor$2(type,preserveWS,top.options);top.options&OPT_OPEN_LEFT$2&&0==top.content.length&&(options|=OPT_OPEN_LEFT$2),this.nodes.push(new NodeContext$2(type,attrs,top.activeMarks,top.pendingMarks,solid,null,options)),this.open++}
// Make sure all nodes above this.open are finished and added to
// their parents
closeExtra(openEnd=!1){let i=this.nodes.length-1;if(i>this.open){for(;i>this.open;i--)this.nodes[i-1].content.push(this.nodes[i].finish(openEnd));this.nodes.length=this.open+1}}finish(){return this.open=0,this.closeExtra(this.isOpen),this.nodes[0].finish(this.isOpen||this.options.topOpen)}sync(to){for(let i=this.open;i>=0;i--)if(this.nodes[i]==to)return this.open=i,!0;return!1}get currentPos(){this.closeExtra();let pos=0;for(let i=this.open;i>=0;i--){let content=this.nodes[i].content;for(let j=content.length-1;j>=0;j--)pos+=content[j].nodeSize;i&&pos++}return pos}findAtPoint(parent,offset){if(this.find)for(let i=0;i<this.find.length;i++)this.find[i].node==parent&&this.find[i].offset==offset&&(this.find[i].pos=this.currentPos)}findInside(parent){if(this.find)for(let i=0;i<this.find.length;i++)null==this.find[i].pos&&1==parent.nodeType&&parent.contains(this.find[i].node)&&(this.find[i].pos=this.currentPos)}findAround(parent,content,before){if(parent!=content&&this.find)for(let i=0;i<this.find.length;i++)if(null==this.find[i].pos&&1==parent.nodeType&&parent.contains(this.find[i].node)){let pos=content.compareDocumentPosition(this.find[i].node);pos&(before?2:4)&&(this.find[i].pos=this.currentPos)}}findInText(textNode){if(this.find)for(let i=0;i<this.find.length;i++)this.find[i].node==textNode&&(this.find[i].pos=this.currentPos-(textNode.nodeValue.length-this.find[i].offset))}
// Determines whether the given context string matches this context.
matchesContext(context){if(context.indexOf("|")>-1)return context.split(/\s*\|\s*/).some(this.matchesContext,this);let parts=context.split("/"),option=this.options.context,useRoot=!this.isOpen&&(!option||option.parent.type==this.nodes[0].type),minDepth=-(option?option.depth+1:0)+(useRoot?0:1),match=(i,depth)=>{for(;i>=0;i--){let part=parts[i];if(""==part){if(i==parts.length-1||0==i)continue;for(;depth>=minDepth;depth--)if(match(i-1,depth))return!0;return!1}{let next=depth>0||0==depth&&useRoot?this.nodes[depth].type:option&&depth>=minDepth?option.node(depth-minDepth).type:null;if(!next||next.name!=part&&-1==next.groups.indexOf(part))return!1;depth--}}return!0};return match(parts.length-1,this.open)}textblockFromContext(){let $context=this.options.context;if($context)for(let d=$context.depth;d>=0;d--){let deflt=$context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;if(deflt&&deflt.isTextblock&&deflt.defaultAttrs)return deflt}for(let name in this.parser.schema.nodes){let type=this.parser.schema.nodes[name];if(type.isTextblock&&type.defaultAttrs)return type}}addPendingMark(mark){let found=findSameMarkInSet$2(mark,this.top.pendingMarks);found&&this.top.stashMarks.push(found),this.top.pendingMarks=mark.addToSet(this.top.pendingMarks)}removePendingMark(mark,upto){for(let depth=this.open;depth>=0;depth--){let level=this.nodes[depth],found=level.pendingMarks.lastIndexOf(mark);if(found>-1)level.pendingMarks=mark.removeFromSet(level.pendingMarks);else{level.activeMarks=mark.removeFromSet(level.activeMarks);let stashMark=level.popFromStashMark(mark);stashMark&&level.type&&level.type.allowsMarkType(stashMark.type)&&(level.activeMarks=stashMark.addToSet(level.activeMarks))}if(level==upto)break}}}
// Kludge to work around directly nested list nodes produced by some
// tools and allowed by browsers to mean that the nested list is
// actually part of the list item above it.
function normalizeList$2(dom){for(let child=dom.firstChild,prevItem=null;child;child=child.nextSibling){let name=1==child.nodeType?child.nodeName.toLowerCase():null;name&&listTags$2.hasOwnProperty(name)&&prevItem?(prevItem.appendChild(child),child=prevItem):"li"==name?prevItem=child:name&&(prevItem=null)}}
// Apply a CSS selector.
function matches$1$2(dom,selector){return(dom.matches||dom.msMatchesSelector||dom.webkitMatchesSelector||dom.mozMatchesSelector).call(dom,selector)}
// Tokenize a style attribute into property/value pairs.
function parseStyles$2(style){let m,re=/\s*([\w-]+)\s*:\s*([^;]+)/g,result=[];while(m=re.exec(style))result.push(m[1],m[2].trim());return result}function copy$2(obj){let copy={};for(let prop in obj)copy[prop]=obj[prop];return copy}
// Used when finding a mark at the top level of a fragment parse.
// Checks whether it would be reasonable to apply a given mark type to
// a given node, by looking at the way the mark occurs in the schema.
function markMayApply$2(markType,nodeType){let nodes=nodeType.schema.nodes;for(let name in nodes){let parent=nodes[name];if(!parent.allowsMarkType(markType))continue;let seen=[],scan=match=>{seen.push(match);for(let i=0;i<match.edgeCount;i++){let{type:type,next:next}=match.edge(i);if(type==nodeType)return!0;if(seen.indexOf(next)<0&&scan(next))return!0}};if(scan(parent.contentMatch))return!0}}function findSameMarkInSet$2(mark,set){for(let i=0;i<set.length;i++)if(mark.eq(set[i]))return set[i]}
/**
A DOM serializer knows how to convert ProseMirror nodes and
marks of various types to DOM nodes.
*/class DOMSerializer$2{
/**
    Create a serializer. `nodes` should map node names to functions
    that take a node and return a description of the corresponding
    DOM. `marks` does the same for mark names, but also gets an
    argument that tells it whether the mark's content is block or
    inline content (for typical use, it'll always be inline). A mark
    serializer may be `null` to indicate that marks of that type
    should not be serialized.
    */
constructor(
/**
    The node serialization functions.
    */
nodes,
/**
    The mark serialization functions.
    */
marks){this.nodes=nodes,this.marks=marks}
/**
    Serialize the content of this fragment to a DOM fragment. When
    not in the browser, the `document` option, containing a DOM
    document, should be passed so that the serializer can create
    nodes.
    */serializeFragment(fragment,options={},target){target||(target=doc$1$2(options).createDocumentFragment());let top=target,active=[];return fragment.forEach((node=>{if(active.length||node.marks.length){let keep=0,rendered=0;while(keep<active.length&&rendered<node.marks.length){let next=node.marks[rendered];if(this.marks[next.type.name]){if(!next.eq(active[keep][0])||!1===next.type.spec.spanning)break;keep++,rendered++}else rendered++}while(keep<active.length)top=active.pop()[1];while(rendered<node.marks.length){let add=node.marks[rendered++],markDOM=this.serializeMark(add,node.isInline,options);markDOM&&(active.push([add,top]),top.appendChild(markDOM.dom),top=markDOM.contentDOM||markDOM.dom)}}top.appendChild(this.serializeNodeInner(node,options))})),target}
/**
    @internal
    */serializeNodeInner(node,options){let{dom:dom,contentDOM:contentDOM}=DOMSerializer$2.renderSpec(doc$1$2(options),this.nodes[node.type.name](node));if(contentDOM){if(node.isLeaf)throw new RangeError("Content hole not allowed in a leaf node spec");this.serializeFragment(node.content,options,contentDOM)}return dom}
/**
    Serialize this node to a DOM node. This can be useful when you
    need to serialize a part of a document, as opposed to the whole
    document. To serialize a whole document, use
    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
    its [content](https://prosemirror.net/docs/ref/#model.Node.content).
    */serializeNode(node,options={}){let dom=this.serializeNodeInner(node,options);for(let i=node.marks.length-1;i>=0;i--){let wrap=this.serializeMark(node.marks[i],node.isInline,options);wrap&&((wrap.contentDOM||wrap.dom).appendChild(dom),dom=wrap.dom)}return dom}
/**
    @internal
    */serializeMark(mark,inline,options={}){let toDOM=this.marks[mark.type.name];return toDOM&&DOMSerializer$2.renderSpec(doc$1$2(options),toDOM(mark,inline))}
/**
    Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
    the spec has a hole (zero) in it, `contentDOM` will point at the
    node with the hole.
    */static renderSpec(doc,structure,xmlNS=null){if("string"==typeof structure)return{dom:doc.createTextNode(structure)};if(null!=structure.nodeType)return{dom:structure};if(structure.dom&&null!=structure.dom.nodeType)return structure;let contentDOM,tagName=structure[0],space=tagName.indexOf(" ");space>0&&(xmlNS=tagName.slice(0,space),tagName=tagName.slice(space+1));let dom=xmlNS?doc.createElementNS(xmlNS,tagName):doc.createElement(tagName),attrs=structure[1],start=1;if(attrs&&"object"==typeof attrs&&null==attrs.nodeType&&!Array.isArray(attrs)){start=2;for(let name in attrs)if(null!=attrs[name]){let space=name.indexOf(" ");space>0?dom.setAttributeNS(name.slice(0,space),name.slice(space+1),attrs[name]):dom.setAttribute(name,attrs[name])}}for(let i=start;i<structure.length;i++){let child=structure[i];if(0===child){if(i<structure.length-1||i>start)throw new RangeError("Content hole must be the only child of its parent node");return{dom:dom,contentDOM:dom}}{let{dom:inner,contentDOM:innerContent}=DOMSerializer$2.renderSpec(doc,child,xmlNS);if(dom.appendChild(inner),innerContent){if(contentDOM)throw new RangeError("Multiple content holes");contentDOM=innerContent}}}return{dom:dom,contentDOM:contentDOM}}
/**
    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
    properties in a schema's node and mark specs.
    */static fromSchema(schema){return schema.cached.domSerializer||(schema.cached.domSerializer=new DOMSerializer$2(this.nodesFromSchema(schema),this.marksFromSchema(schema)))}
/**
    Gather the serializers in a schema's node specs into an object.
    This can be useful as a base to build a custom serializer from.
    */static nodesFromSchema(schema){let result=gatherToDOM$2(schema.nodes);return result.text||(result.text=node=>node.text),result}
/**
    Gather the serializers in a schema's mark specs into an object.
    */static marksFromSchema(schema){return gatherToDOM$2(schema.marks)}}function gatherToDOM$2(obj){let result={};for(let name in obj){let toDOM=obj[name].spec.toDOM;toDOM&&(result[name]=toDOM)}return result}function doc$1$2(options){return options.document||window.document}
// Recovery values encode a range index and an offset. They are
// represented as numbers, because tons of them will be created when
// mapping, for example, a large number of decorations. The number's
// lower 16 bits provide the index, the remaining bits the offset.

// Note: We intentionally don't use bit shift operators to en- and
// decode these, since those clip to 32 bits, which we might in rare
// cases want to overflow. A 64-bit float can represent 48-bit
// integers precisely.
const lower16$2=65535,factor16$2=Math.pow(2,16);function makeRecover$2(index,offset){return index+offset*factor16$2}function recoverIndex$2(value){return value&lower16$2}function recoverOffset$2(value){return(value-(value&lower16$2))/factor16$2}const DEL_BEFORE$2=1,DEL_AFTER$2=2,DEL_ACROSS$2=4,DEL_SIDE$2=8;
/**
An object representing a mapped position with extra
information.
*/class MapResult$2{
/**
    @internal
    */
constructor(
/**
    The mapped version of the position.
    */
pos,
/**
    @internal
    */
delInfo,
/**
    @internal
    */
recover){this.pos=pos,this.delInfo=delInfo,this.recover=recover}
/**
    Tells you whether the position was deleted, that is, whether the
    step removed the token on the side queried (via the `assoc`)
    argument from the document.
    */get deleted(){return(this.delInfo&DEL_SIDE$2)>0}
/**
    Tells you whether the token before the mapped position was deleted.
    */get deletedBefore(){return(this.delInfo&(DEL_BEFORE$2|DEL_ACROSS$2))>0}
/**
    True when the token after the mapped position was deleted.
    */get deletedAfter(){return(this.delInfo&(DEL_AFTER$2|DEL_ACROSS$2))>0}
/**
    Tells whether any of the steps mapped through deletes across the
    position (including both the token before and after the
    position).
    */get deletedAcross(){return(this.delInfo&DEL_ACROSS$2)>0}}
/**
A map describing the deletions and insertions made by a step, which
can be used to find the correspondence between positions in the
pre-step version of a document and the same position in the
post-step version.
*/class StepMap$2{
/**
    Create a position map. The modifications to the document are
    represented as an array of numbers, in which each group of three
    represents a modified chunk as `[start, oldSize, newSize]`.
    */
constructor(
/**
    @internal
    */
ranges,
/**
    @internal
    */
inverted=!1){if(this.ranges=ranges,this.inverted=inverted,!ranges.length&&StepMap$2.empty)return StepMap$2.empty}
/**
    @internal
    */recover(value){let diff=0,index=recoverIndex$2(value);if(!this.inverted)for(let i=0;i<index;i++)diff+=this.ranges[3*i+2]-this.ranges[3*i+1];return this.ranges[3*index]+diff+recoverOffset$2(value)}mapResult(pos,assoc=1){return this._map(pos,assoc,!1)}map(pos,assoc=1){return this._map(pos,assoc,!0)}
/**
    @internal
    */_map(pos,assoc,simple){let diff=0,oldIndex=this.inverted?2:1,newIndex=this.inverted?1:2;for(let i=0;i<this.ranges.length;i+=3){let start=this.ranges[i]-(this.inverted?diff:0);if(start>pos)break;let oldSize=this.ranges[i+oldIndex],newSize=this.ranges[i+newIndex],end=start+oldSize;if(pos<=end){let side=oldSize?pos==start?-1:pos==end?1:assoc:assoc,result=start+diff+(side<0?0:newSize);if(simple)return result;let recover=pos==(assoc<0?start:end)?null:makeRecover$2(i/3,pos-start),del=pos==start?DEL_AFTER$2:pos==end?DEL_BEFORE$2:DEL_ACROSS$2;return(assoc<0?pos!=start:pos!=end)&&(del|=DEL_SIDE$2),new MapResult$2(result,del,recover)}diff+=newSize-oldSize}return simple?pos+diff:new MapResult$2(pos+diff,0,null)}
/**
    @internal
    */touches(pos,recover){let diff=0,index=recoverIndex$2(recover),oldIndex=this.inverted?2:1,newIndex=this.inverted?1:2;for(let i=0;i<this.ranges.length;i+=3){let start=this.ranges[i]-(this.inverted?diff:0);if(start>pos)break;let oldSize=this.ranges[i+oldIndex],end=start+oldSize;if(pos<=end&&i==3*index)return!0;diff+=this.ranges[i+newIndex]-oldSize}return!1}
/**
    Calls the given function on each of the changed ranges included in
    this map.
    */forEach(f){let oldIndex=this.inverted?2:1,newIndex=this.inverted?1:2;for(let i=0,diff=0;i<this.ranges.length;i+=3){let start=this.ranges[i],oldStart=start-(this.inverted?diff:0),newStart=start+(this.inverted?0:diff),oldSize=this.ranges[i+oldIndex],newSize=this.ranges[i+newIndex];f(oldStart,oldStart+oldSize,newStart,newStart+newSize),diff+=newSize-oldSize}}
/**
    Create an inverted version of this map. The result can be used to
    map positions in the post-step document to the pre-step document.
    */invert(){return new StepMap$2(this.ranges,!this.inverted)}
/**
    @internal
    */toString(){return(this.inverted?"-":"")+JSON.stringify(this.ranges)}
/**
    Create a map that moves all positions by offset `n` (which may be
    negative). This can be useful when applying steps meant for a
    sub-document to a larger document, or vice-versa.
    */static offset(n){return 0==n?StepMap$2.empty:new StepMap$2(n<0?[0,-n,0]:[0,0,n])}}
/**
A StepMap that contains no changed ranges.
*/StepMap$2.empty=new StepMap$2([]);
/**
A mapping represents a pipeline of zero or more [step
maps](https://prosemirror.net/docs/ref/#transform.StepMap). It has special provisions for losslessly
handling mapping positions through a series of steps in which some
steps are inverted versions of earlier steps. (This comes up when
‘[rebasing](/docs/guide/#transform.rebasing)’ steps for
collaboration or history management.)
*/
class Mapping$2{
/**
    Create a new mapping with the given position maps.
    */
constructor(
/**
    The step maps in this mapping.
    */
maps=[]
/**
    @internal
    */,mirror,
/**
    The starting position in the `maps` array, used when `map` or
    `mapResult` is called.
    */
from=0
/**
    The end position in the `maps` array.
    */,to=maps.length){this.maps=maps,this.mirror=mirror,this.from=from,this.to=to}
/**
    Create a mapping that maps only through a part of this one.
    */slice(from=0,to=this.maps.length){return new Mapping$2(this.maps,this.mirror,from,to)}
/**
    @internal
    */copy(){return new Mapping$2(this.maps.slice(),this.mirror&&this.mirror.slice(),this.from,this.to)}
/**
    Add a step map to the end of this mapping. If `mirrors` is
    given, it should be the index of the step map that is the mirror
    image of this one.
    */appendMap(map,mirrors){this.to=this.maps.push(map),null!=mirrors&&this.setMirror(this.maps.length-1,mirrors)}
/**
    Add all the step maps in a given mapping to this one (preserving
    mirroring information).
    */appendMapping(mapping){for(let i=0,startSize=this.maps.length;i<mapping.maps.length;i++){let mirr=mapping.getMirror(i);this.appendMap(mapping.maps[i],null!=mirr&&mirr<i?startSize+mirr:void 0)}}
/**
    Finds the offset of the step map that mirrors the map at the
    given offset, in this mapping (as per the second argument to
    `appendMap`).
    */getMirror(n){if(this.mirror)for(let i=0;i<this.mirror.length;i++)if(this.mirror[i]==n)return this.mirror[i+(i%2?-1:1)]}
/**
    @internal
    */setMirror(n,m){this.mirror||(this.mirror=[]),this.mirror.push(n,m)}
/**
    Append the inverse of the given mapping to this one.
    */appendMappingInverted(mapping){for(let i=mapping.maps.length-1,totalSize=this.maps.length+mapping.maps.length;i>=0;i--){let mirr=mapping.getMirror(i);this.appendMap(mapping.maps[i].invert(),null!=mirr&&mirr>i?totalSize-mirr-1:void 0)}}
/**
    Create an inverted version of this mapping.
    */invert(){let inverse=new Mapping$2;return inverse.appendMappingInverted(this),inverse}
/**
    Map a position through this mapping.
    */map(pos,assoc=1){if(this.mirror)return this._map(pos,assoc,!0);for(let i=this.from;i<this.to;i++)pos=this.maps[i].map(pos,assoc);return pos}
/**
    Map a position through this mapping, returning a mapping
    result.
    */mapResult(pos,assoc=1){return this._map(pos,assoc,!1)}
/**
    @internal
    */_map(pos,assoc,simple){let delInfo=0;for(let i=this.from;i<this.to;i++){let map=this.maps[i],result=map.mapResult(pos,assoc);if(null!=result.recover){let corr=this.getMirror(i);if(null!=corr&&corr>i&&corr<this.to){i=corr,pos=this.maps[corr].recover(result.recover);continue}}delInfo|=result.delInfo,pos=result.pos}return simple?pos:new MapResult$2(pos,delInfo,null)}}const stepsByID$2=Object.create(null);
/**
A step object represents an atomic change. It generally applies
only to the document it was created for, since the positions
stored in it will only make sense for that document.

New steps are defined by creating classes that extend `Step`,
overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`
methods, and registering your class with a unique
JSON-serialization identifier using
[`Step.jsonID`](https://prosemirror.net/docs/ref/#transform.Step^jsonID).
*/class Step$2{
/**
    Get the step map that represents the changes made by this step,
    and which can be used to transform between positions in the old
    and the new document.
    */
getMap(){return StepMap$2.empty}
/**
    Try to merge this step with another one, to be applied directly
    after it. Returns the merged step when possible, null if the
    steps can't be merged.
    */merge(other){return null}
/**
    Deserialize a step from its JSON representation. Will call
    through to the step class' own implementation of this method.
    */static fromJSON(schema,json){if(!json||!json.stepType)throw new RangeError("Invalid input for Step.fromJSON");let type=stepsByID$2[json.stepType];if(!type)throw new RangeError(`No step type ${json.stepType} defined`);return type.fromJSON(schema,json)}
/**
    To be able to serialize steps to JSON, each step needs a string
    ID to attach to its JSON representation. Use this method to
    register an ID for your step classes. Try to pick something
    that's unlikely to clash with steps from other modules.
    */static jsonID(id,stepClass){if(id in stepsByID$2)throw new RangeError("Duplicate use of step JSON ID "+id);return stepsByID$2[id]=stepClass,stepClass.prototype.jsonID=id,stepClass}}
/**
The result of [applying](https://prosemirror.net/docs/ref/#transform.Step.apply) a step. Contains either a
new document or a failure value.
*/class StepResult$2{
/**
    @internal
    */
constructor(
/**
    The transformed document, if successful.
    */
doc,
/**
    The failure message, if unsuccessful.
    */
failed){this.doc=doc,this.failed=failed}
/**
    Create a successful step result.
    */static ok(doc){return new StepResult$2(doc,null)}
/**
    Create a failed step result.
    */static fail(message){return new StepResult$2(null,message)}
/**
    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
    arguments. Create a successful result if it succeeds, and a
    failed one if it throws a `ReplaceError`.
    */static fromReplace(doc,from,to,slice){try{return StepResult$2.ok(doc.replace(from,to,slice))}catch(e){if(e instanceof ReplaceError$2)return StepResult$2.fail(e.message);throw e}}}function mapFragment$2(fragment,f,parent){let mapped=[];for(let i=0;i<fragment.childCount;i++){let child=fragment.child(i);child.content.size&&(child=child.copy(mapFragment$2(child.content,f,child))),child.isInline&&(child=f(child,parent,i)),mapped.push(child)}return Fragment$2.fromArray(mapped)}
/**
Add a mark to all inline content between two positions.
*/class AddMarkStep$2 extends Step$2{
/**
    Create a mark step.
    */
constructor(
/**
    The start of the marked range.
    */
from,
/**
    The end of the marked range.
    */
to,
/**
    The mark to add.
    */
mark){super(),this.from=from,this.to=to,this.mark=mark}apply(doc){let oldSlice=doc.slice(this.from,this.to),$from=doc.resolve(this.from),parent=$from.node($from.sharedDepth(this.to)),slice=new Slice$2(mapFragment$2(oldSlice.content,((node,parent)=>node.isAtom&&parent.type.allowsMarkType(this.mark.type)?node.mark(this.mark.addToSet(node.marks)):node),parent),oldSlice.openStart,oldSlice.openEnd);return StepResult$2.fromReplace(doc,this.from,this.to,slice)}invert(){return new RemoveMarkStep$2(this.from,this.to,this.mark)}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1);return from.deleted&&to.deleted||from.pos>=to.pos?null:new AddMarkStep$2(from.pos,to.pos,this.mark)}merge(other){return other instanceof AddMarkStep$2&&other.mark.eq(this.mark)&&this.from<=other.to&&this.to>=other.from?new AddMarkStep$2(Math.min(this.from,other.from),Math.max(this.to,other.to),this.mark):null}toJSON(){return{stepType:"addMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to)throw new RangeError("Invalid input for AddMarkStep.fromJSON");return new AddMarkStep$2(json.from,json.to,schema.markFromJSON(json.mark))}}Step$2.jsonID("addMark",AddMarkStep$2);
/**
Remove a mark from all inline content between two positions.
*/
class RemoveMarkStep$2 extends Step$2{
/**
    Create a mark-removing step.
    */
constructor(
/**
    The start of the unmarked range.
    */
from,
/**
    The end of the unmarked range.
    */
to,
/**
    The mark to remove.
    */
mark){super(),this.from=from,this.to=to,this.mark=mark}apply(doc){let oldSlice=doc.slice(this.from,this.to),slice=new Slice$2(mapFragment$2(oldSlice.content,(node=>node.mark(this.mark.removeFromSet(node.marks))),doc),oldSlice.openStart,oldSlice.openEnd);return StepResult$2.fromReplace(doc,this.from,this.to,slice)}invert(){return new AddMarkStep$2(this.from,this.to,this.mark)}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1);return from.deleted&&to.deleted||from.pos>=to.pos?null:new RemoveMarkStep$2(from.pos,to.pos,this.mark)}merge(other){return other instanceof RemoveMarkStep$2&&other.mark.eq(this.mark)&&this.from<=other.to&&this.to>=other.from?new RemoveMarkStep$2(Math.min(this.from,other.from),Math.max(this.to,other.to),this.mark):null}toJSON(){return{stepType:"removeMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to)throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");return new RemoveMarkStep$2(json.from,json.to,schema.markFromJSON(json.mark))}}Step$2.jsonID("removeMark",RemoveMarkStep$2);
/**
Replace a part of the document with a slice of new content.
*/
class ReplaceStep$2 extends Step$2{
/**
    The given `slice` should fit the 'gap' between `from` and
    `to`—the depths must line up, and the surrounding nodes must be
    able to be joined with the open sides of the slice. When
    `structure` is true, the step will fail if the content between
    from and to is not just a sequence of closing and then opening
    tokens (this is to guard against rebased replace steps
    overwriting something they weren't supposed to).
    */
constructor(
/**
    The start position of the replaced range.
    */
from,
/**
    The end position of the replaced range.
    */
to,
/**
    The slice to insert.
    */
slice,
/**
    @internal
    */
structure=!1){super(),this.from=from,this.to=to,this.slice=slice,this.structure=structure}apply(doc){return this.structure&&contentBetween$2(doc,this.from,this.to)?StepResult$2.fail("Structure replace would overwrite content"):StepResult$2.fromReplace(doc,this.from,this.to,this.slice)}getMap(){return new StepMap$2([this.from,this.to-this.from,this.slice.size])}invert(doc){return new ReplaceStep$2(this.from,this.from+this.slice.size,doc.slice(this.from,this.to))}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1);return from.deletedAcross&&to.deletedAcross?null:new ReplaceStep$2(from.pos,Math.max(from.pos,to.pos),this.slice)}merge(other){if(!(other instanceof ReplaceStep$2)||other.structure||this.structure)return null;if(this.from+this.slice.size!=other.from||this.slice.openEnd||other.slice.openStart){if(other.to!=this.from||this.slice.openStart||other.slice.openEnd)return null;{let slice=this.slice.size+other.slice.size==0?Slice$2.empty:new Slice$2(other.slice.content.append(this.slice.content),other.slice.openStart,this.slice.openEnd);return new ReplaceStep$2(other.from,this.to,slice,this.structure)}}{let slice=this.slice.size+other.slice.size==0?Slice$2.empty:new Slice$2(this.slice.content.append(other.slice.content),this.slice.openStart,other.slice.openEnd);return new ReplaceStep$2(this.from,this.to+(other.to-other.from),slice,this.structure)}}toJSON(){let json={stepType:"replace",from:this.from,to:this.to};return this.slice.size&&(json.slice=this.slice.toJSON()),this.structure&&(json.structure=!0),json}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to)throw new RangeError("Invalid input for ReplaceStep.fromJSON");return new ReplaceStep$2(json.from,json.to,Slice$2.fromJSON(schema,json.slice),!!json.structure)}}Step$2.jsonID("replace",ReplaceStep$2);
/**
Replace a part of the document with a slice of content, but
preserve a range of the replaced content by moving it into the
slice.
*/
class ReplaceAroundStep$2 extends Step$2{
/**
    Create a replace-around step with the given range and gap.
    `insert` should be the point in the slice into which the content
    of the gap should be moved. `structure` has the same meaning as
    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
    */
constructor(
/**
    The start position of the replaced range.
    */
from,
/**
    The end position of the replaced range.
    */
to,
/**
    The start of preserved range.
    */
gapFrom,
/**
    The end of preserved range.
    */
gapTo,
/**
    The slice to insert.
    */
slice,
/**
    The position in the slice where the preserved range should be
    inserted.
    */
insert,
/**
    @internal
    */
structure=!1){super(),this.from=from,this.to=to,this.gapFrom=gapFrom,this.gapTo=gapTo,this.slice=slice,this.insert=insert,this.structure=structure}apply(doc){if(this.structure&&(contentBetween$2(doc,this.from,this.gapFrom)||contentBetween$2(doc,this.gapTo,this.to)))return StepResult$2.fail("Structure gap-replace would overwrite content");let gap=doc.slice(this.gapFrom,this.gapTo);if(gap.openStart||gap.openEnd)return StepResult$2.fail("Gap is not a flat range");let inserted=this.slice.insertAt(this.insert,gap.content);return inserted?StepResult$2.fromReplace(doc,this.from,this.to,inserted):StepResult$2.fail("Content does not fit in gap")}getMap(){return new StepMap$2([this.from,this.gapFrom-this.from,this.insert,this.gapTo,this.to-this.gapTo,this.slice.size-this.insert])}invert(doc){let gap=this.gapTo-this.gapFrom;return new ReplaceAroundStep$2(this.from,this.from+this.slice.size+gap,this.from+this.insert,this.from+this.insert+gap,doc.slice(this.from,this.to).removeBetween(this.gapFrom-this.from,this.gapTo-this.from),this.gapFrom-this.from,this.structure)}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1),gapFrom=mapping.map(this.gapFrom,-1),gapTo=mapping.map(this.gapTo,1);return from.deletedAcross&&to.deletedAcross||gapFrom<from.pos||gapTo>to.pos?null:new ReplaceAroundStep$2(from.pos,to.pos,gapFrom,gapTo,this.slice,this.insert,this.structure)}toJSON(){let json={stepType:"replaceAround",from:this.from,to:this.to,gapFrom:this.gapFrom,gapTo:this.gapTo,insert:this.insert};return this.slice.size&&(json.slice=this.slice.toJSON()),this.structure&&(json.structure=!0),json}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to||"number"!=typeof json.gapFrom||"number"!=typeof json.gapTo||"number"!=typeof json.insert)throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");return new ReplaceAroundStep$2(json.from,json.to,json.gapFrom,json.gapTo,Slice$2.fromJSON(schema,json.slice),json.insert,!!json.structure)}}function contentBetween$2(doc,from,to){let $from=doc.resolve(from),dist=to-from,depth=$from.depth;while(dist>0&&depth>0&&$from.indexAfter(depth)==$from.node(depth).childCount)depth--,dist--;if(dist>0){let next=$from.node(depth).maybeChild($from.indexAfter(depth));while(dist>0){if(!next||next.isLeaf)return!0;next=next.firstChild,dist--}}return!1}function addMark$2(tr,from,to,mark){let removing,adding,removed=[],added=[];tr.doc.nodesBetween(from,to,((node,pos,parent)=>{if(!node.isInline)return;let marks=node.marks;if(!mark.isInSet(marks)&&parent.type.allowsMarkType(mark.type)){let start=Math.max(pos,from),end=Math.min(pos+node.nodeSize,to),newSet=mark.addToSet(marks);for(let i=0;i<marks.length;i++)marks[i].isInSet(newSet)||(removing&&removing.to==start&&removing.mark.eq(marks[i])?removing.to=end:removed.push(removing=new RemoveMarkStep$2(start,end,marks[i])));adding&&adding.to==start?adding.to=end:added.push(adding=new AddMarkStep$2(start,end,mark))}})),removed.forEach((s=>tr.step(s))),added.forEach((s=>tr.step(s)))}function removeMark$2(tr,from,to,mark){let matched=[],step=0;tr.doc.nodesBetween(from,to,((node,pos)=>{if(!node.isInline)return;step++;let toRemove=null;if(mark instanceof MarkType$2){let found,set=node.marks;while(found=mark.isInSet(set))(toRemove||(toRemove=[])).push(found),set=found.removeFromSet(set)}else mark?mark.isInSet(node.marks)&&(toRemove=[mark]):toRemove=node.marks;if(toRemove&&toRemove.length){let end=Math.min(pos+node.nodeSize,to);for(let i=0;i<toRemove.length;i++){let found,style=toRemove[i];for(let j=0;j<matched.length;j++){let m=matched[j];m.step==step-1&&style.eq(matched[j].style)&&(found=m)}found?(found.to=end,found.step=step):matched.push({style:style,from:Math.max(pos,from),to:end,step:step})}}})),matched.forEach((m=>tr.step(new RemoveMarkStep$2(m.from,m.to,m.style))))}function clearIncompatible$2(tr,pos,parentType,match=parentType.contentMatch){let node=tr.doc.nodeAt(pos),delSteps=[],cur=pos+1;for(let i=0;i<node.childCount;i++){let child=node.child(i),end=cur+child.nodeSize,allowed=match.matchType(child.type);if(allowed){match=allowed;for(let j=0;j<child.marks.length;j++)parentType.allowsMarkType(child.marks[j].type)||tr.step(new RemoveMarkStep$2(cur,end,child.marks[j]))}else delSteps.push(new ReplaceStep$2(cur,end,Slice$2.empty));cur=end}if(!match.validEnd){let fill=match.fillBefore(Fragment$2.empty,!0);tr.replace(cur,cur,new Slice$2(fill,0,0))}for(let i=delSteps.length-1;i>=0;i--)tr.step(delSteps[i])}function canCut$2(node,start,end){return(0==start||node.canReplace(start,node.childCount))&&(end==node.childCount||node.canReplace(0,end))}
/**
Try to find a target depth to which the content in the given range
can be lifted. Will not go across
[isolating](https://prosemirror.net/docs/ref/#model.NodeSpec.isolating) parent nodes.
*/function liftTarget$2(range){let parent=range.parent,content=parent.content.cutByIndex(range.startIndex,range.endIndex);for(let depth=range.depth;;--depth){let node=range.$from.node(depth),index=range.$from.index(depth),endIndex=range.$to.indexAfter(depth);if(depth<range.depth&&node.canReplace(index,endIndex,content))return depth;if(0==depth||node.type.spec.isolating||!canCut$2(node,index,endIndex))break}return null}function lift$2$2(tr,range,target){let{$from:$from,$to:$to,depth:depth}=range,gapStart=$from.before(depth+1),gapEnd=$to.after(depth+1),start=gapStart,end=gapEnd,before=Fragment$2.empty,openStart=0;for(let d=depth,splitting=!1;d>target;d--)splitting||$from.index(d)>0?(splitting=!0,before=Fragment$2.from($from.node(d).copy(before)),openStart++):start--;let after=Fragment$2.empty,openEnd=0;for(let d=depth,splitting=!1;d>target;d--)splitting||$to.after(d+1)<$to.end(d)?(splitting=!0,after=Fragment$2.from($to.node(d).copy(after)),openEnd++):end++;tr.step(new ReplaceAroundStep$2(start,end,gapStart,gapEnd,new Slice$2(before.append(after),openStart,openEnd),before.size-openStart,!0))}
/**
Try to find a valid way to wrap the content in the given range in a
node of the given type. May introduce extra nodes around and inside
the wrapper node, if necessary. Returns null if no valid wrapping
could be found. When `innerRange` is given, that range's content is
used as the content to fit into the wrapping, instead of the
content of `range`.
*/function findWrapping$2(range,nodeType,attrs=null,innerRange=range){let around=findWrappingOutside$2(range,nodeType),inner=around&&findWrappingInside$2(innerRange,nodeType);return inner?around.map(withAttrs$2).concat({type:nodeType,attrs:attrs}).concat(inner.map(withAttrs$2)):null}function withAttrs$2(type){return{type:type,attrs:null}}function findWrappingOutside$2(range,type){let{parent:parent,startIndex:startIndex,endIndex:endIndex}=range,around=parent.contentMatchAt(startIndex).findWrapping(type);if(!around)return null;let outer=around.length?around[0]:type;return parent.canReplaceWith(startIndex,endIndex,outer)?around:null}function findWrappingInside$2(range,type){let{parent:parent,startIndex:startIndex,endIndex:endIndex}=range,inner=parent.child(startIndex),inside=type.contentMatch.findWrapping(inner.type);if(!inside)return null;let lastType=inside.length?inside[inside.length-1]:type,innerMatch=lastType.contentMatch;for(let i=startIndex;innerMatch&&i<endIndex;i++)innerMatch=innerMatch.matchType(parent.child(i).type);return innerMatch&&innerMatch.validEnd?inside:null}function wrap$2(tr,range,wrappers){let content=Fragment$2.empty;for(let i=wrappers.length-1;i>=0;i--){if(content.size){let match=wrappers[i].type.contentMatch.matchFragment(content);if(!match||!match.validEnd)throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper")}content=Fragment$2.from(wrappers[i].type.create(wrappers[i].attrs,content))}let start=range.start,end=range.end;tr.step(new ReplaceAroundStep$2(start,end,start,end,new Slice$2(content,0,0),wrappers.length,!0))}function setBlockType$1$2(tr,from,to,type,attrs){if(!type.isTextblock)throw new RangeError("Type given to setBlockType should be a textblock");let mapFrom=tr.steps.length;tr.doc.nodesBetween(from,to,((node,pos)=>{if(node.isTextblock&&!node.hasMarkup(type,attrs)&&canChangeType$2(tr.doc,tr.mapping.slice(mapFrom).map(pos),type)){
// Ensure all markup that isn't allowed in the new node type is cleared
tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos,1),type);let mapping=tr.mapping.slice(mapFrom),startM=mapping.map(pos,1),endM=mapping.map(pos+node.nodeSize,1);return tr.step(new ReplaceAroundStep$2(startM,endM,startM+1,endM-1,new Slice$2(Fragment$2.from(type.create(attrs,null,node.marks)),0,0),1,!0)),!1}}))}function canChangeType$2(doc,pos,type){let $pos=doc.resolve(pos),index=$pos.index();return $pos.parent.canReplaceWith(index,index+1,type)}
/**
Change the type, attributes, and/or marks of the node at `pos`.
When `type` isn't given, the existing node type is preserved,
*/function setNodeMarkup$2(tr,pos,type,attrs,marks){let node=tr.doc.nodeAt(pos);if(!node)throw new RangeError("No node at given position");type||(type=node.type);let newNode=type.create(attrs,null,marks||node.marks);if(node.isLeaf)return tr.replaceWith(pos,pos+node.nodeSize,newNode);if(!type.validContent(node.content))throw new RangeError("Invalid content for node type "+type.name);tr.step(new ReplaceAroundStep$2(pos,pos+node.nodeSize,pos+1,pos+node.nodeSize-1,new Slice$2(Fragment$2.from(newNode),0,0),1,!0))}
/**
Check whether splitting at the given position is allowed.
*/function canSplit$2(doc,pos,depth=1,typesAfter){let $pos=doc.resolve(pos),base=$pos.depth-depth,innerType=typesAfter&&typesAfter[typesAfter.length-1]||$pos.parent;if(base<0||$pos.parent.type.spec.isolating||!$pos.parent.canReplace($pos.index(),$pos.parent.childCount)||!innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(),$pos.parent.childCount)))return!1;for(let d=$pos.depth-1,i=depth-2;d>base;d--,i--){let node=$pos.node(d),index=$pos.index(d);if(node.type.spec.isolating)return!1;let rest=node.content.cutByIndex(index,node.childCount),after=typesAfter&&typesAfter[i]||node;if(after!=node&&(rest=rest.replaceChild(0,after.type.create(after.attrs))),!node.canReplace(index+1,node.childCount)||!after.type.validContent(rest))return!1}let index=$pos.indexAfter(base),baseType=typesAfter&&typesAfter[0];return $pos.node(base).canReplaceWith(index,index,baseType?baseType.type:$pos.node(base+1).type)}function split$2(tr,pos,depth=1,typesAfter){let $pos=tr.doc.resolve(pos),before=Fragment$2.empty,after=Fragment$2.empty;for(let d=$pos.depth,e=$pos.depth-depth,i=depth-1;d>e;d--,i--){before=Fragment$2.from($pos.node(d).copy(before));let typeAfter=typesAfter&&typesAfter[i];after=Fragment$2.from(typeAfter?typeAfter.type.create(typeAfter.attrs,after):$pos.node(d).copy(after))}tr.step(new ReplaceStep$2(pos,pos,new Slice$2(before.append(after),depth,depth),!0))}
/**
Test whether the blocks before and after a given position can be
joined.
*/function canJoin$2(doc,pos){let $pos=doc.resolve(pos),index=$pos.index();return joinable$3($pos.nodeBefore,$pos.nodeAfter)&&$pos.parent.canReplace(index,index+1)}function joinable$3(a,b){return!(!a||!b||a.isLeaf||!a.canAppend(b))}function join$2(tr,pos,depth){let step=new ReplaceStep$2(pos-depth,pos+depth,Slice$2.empty,!0);tr.step(step)}
/**
Try to find a point where a node of the given type can be inserted
near `pos`, by searching up the node hierarchy when `pos` itself
isn't a valid place but is at the start or end of a node. Return
null if no position was found.
*/function insertPoint$2(doc,pos,nodeType){let $pos=doc.resolve(pos);if($pos.parent.canReplaceWith($pos.index(),$pos.index(),nodeType))return pos;if(0==$pos.parentOffset)for(let d=$pos.depth-1;d>=0;d--){let index=$pos.index(d);if($pos.node(d).canReplaceWith(index,index,nodeType))return $pos.before(d+1);if(index>0)return null}if($pos.parentOffset==$pos.parent.content.size)for(let d=$pos.depth-1;d>=0;d--){let index=$pos.indexAfter(d);if($pos.node(d).canReplaceWith(index,index,nodeType))return $pos.after(d+1);if(index<$pos.node(d).childCount)return null}return null}
/**
Finds a position at or around the given position where the given
slice can be inserted. Will look at parent nodes' nearest boundary
and try there, even if the original position wasn't directly at the
start or end of that node. Returns null when no position was found.
*/function dropPoint$2(doc,pos,slice){let $pos=doc.resolve(pos);if(!slice.content.size)return pos;let content=slice.content;for(let i=0;i<slice.openStart;i++)content=content.firstChild.content;for(let pass=1;pass<=(0==slice.openStart&&slice.size?2:1);pass++)for(let d=$pos.depth;d>=0;d--){let bias=d==$pos.depth?0:$pos.pos<=($pos.start(d+1)+$pos.end(d+1))/2?-1:1,insertPos=$pos.index(d)+(bias>0?1:0),parent=$pos.node(d),fits=!1;if(1==pass)fits=parent.canReplace(insertPos,insertPos,content);else{let wrapping=parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);fits=wrapping&&parent.canReplaceWith(insertPos,insertPos,wrapping[0])}if(fits)return 0==bias?$pos.pos:bias<0?$pos.before(d+1):$pos.after(d+1)}return null}
/**
‘Fit’ a slice into a given position in the document, producing a
[step](https://prosemirror.net/docs/ref/#transform.Step) that inserts it. Will return null if
there's no meaningful way to insert the slice here, or inserting it
would be a no-op (an empty slice over an empty range).
*/function replaceStep$2(doc,from,to=from,slice=Slice$2.empty){if(from==to&&!slice.size)return null;let $from=doc.resolve(from),$to=doc.resolve(to);
// Optimization -- avoid work if it's obvious that it's not needed.
return fitsTrivially$2($from,$to,slice)?new ReplaceStep$2(from,to,slice):new Fitter$2($from,$to,slice).fit()}function fitsTrivially$2($from,$to,slice){return!slice.openStart&&!slice.openEnd&&$from.start()==$to.start()&&$from.parent.canReplace($from.index(),$to.index(),slice.content)}
// Algorithm for 'placing' the elements of a slice into a gap:

// We consider the content of each node that is open to the left to be
// independently placeable. I.e. in <p("foo"), p("bar")>, when the
// paragraph on the left is open, "foo" can be placed (somewhere on
// the left side of the replacement gap) independently from p("bar").

// This class tracks the state of the placement progress in the
// following properties:

//  - `frontier` holds a stack of `{type, match}` objects that
//    represent the open side of the replacement. It starts at
//    `$from`, then moves forward as content is placed, and is finally
//    reconciled with `$to`.

//  - `unplaced` is a slice that represents the content that hasn't
//    been placed yet.

//  - `placed` is a fragment of placed content. Its open-start value
//    is implicit in `$from`, and its open-end value in `frontier`.
Step$2.jsonID("replaceAround",ReplaceAroundStep$2);class Fitter$2{constructor($from,$to,unplaced){this.$from=$from,this.$to=$to,this.unplaced=unplaced,this.frontier=[],this.placed=Fragment$2.empty;for(let i=0;i<=$from.depth;i++){let node=$from.node(i);this.frontier.push({type:node.type,match:node.contentMatchAt($from.indexAfter(i))})}for(let i=$from.depth;i>0;i--)this.placed=Fragment$2.from($from.node(i).copy(this.placed))}get depth(){return this.frontier.length-1}fit(){
// As long as there's unplaced content, try to place some of it.
// If that fails, either increase the open score of the unplaced
// slice, or drop nodes from it, and then try again.
while(this.unplaced.size){let fit=this.findFittable();fit?this.placeNodes(fit):this.openMore()||this.dropNode()}
// When there's inline content directly after the frontier _and_
// directly after `this.$to`, we must generate a `ReplaceAround`
// step that pulls that content into the node after the frontier.
// That means the fitting must be done to the end of the textblock
// node after `this.$to`, not `this.$to` itself.
let moveInline=this.mustMoveInline(),placedSize=this.placed.size-this.depth-this.$from.depth,$from=this.$from,$to=this.close(moveInline<0?this.$to:$from.doc.resolve(moveInline));if(!$to)return null;
// If closing to `$to` succeeded, create a step
let content=this.placed,openStart=$from.depth,openEnd=$to.depth;while(openStart&&openEnd&&1==content.childCount)// Normalize by dropping open parent nodes
content=content.firstChild.content,openStart--,openEnd--;let slice=new Slice$2(content,openStart,openEnd);return moveInline>-1?new ReplaceAroundStep$2($from.pos,moveInline,this.$to.pos,this.$to.end(),slice,placedSize):slice.size||$from.pos!=this.$to.pos?new ReplaceStep$2($from.pos,$to.pos,slice):null}
// Find a position on the start spine of `this.unplaced` that has
// content that can be moved somewhere on the frontier. Returns two
// depths, one for the slice and one for the frontier.
findFittable(){
// Only try wrapping nodes (pass 2) after finding a place without
// wrapping failed.
for(let pass=1;pass<=2;pass++)for(let sliceDepth=this.unplaced.openStart;sliceDepth>=0;sliceDepth--){let fragment,parent=null;sliceDepth?(parent=contentAt$2(this.unplaced.content,sliceDepth-1).firstChild,fragment=parent.content):fragment=this.unplaced.content;let first=fragment.firstChild;for(let frontierDepth=this.depth;frontierDepth>=0;frontierDepth--){let wrap,{type:type,match:match}=this.frontier[frontierDepth],inject=null;
// In pass 1, if the next node matches, or there is no next
// node but the parents look compatible, we've found a
// place.
if(1==pass&&(first?match.matchType(first.type)||(inject=match.fillBefore(Fragment$2.from(first),!1)):parent&&type.compatibleContent(parent.type)))return{sliceDepth:sliceDepth,frontierDepth:frontierDepth,parent:parent,inject:inject};
// In pass 2, look for a set of wrapping nodes that make
// `first` fit here.
// Don't continue looking further up if the parent node
// would fit here.
if(2==pass&&first&&(wrap=match.findWrapping(first.type)))return{sliceDepth:sliceDepth,frontierDepth:frontierDepth,parent:parent,wrap:wrap};if(parent&&match.matchType(parent.type))break}}}openMore(){let{content:content,openStart:openStart,openEnd:openEnd}=this.unplaced,inner=contentAt$2(content,openStart);return!(!inner.childCount||inner.firstChild.isLeaf)&&(this.unplaced=new Slice$2(content,openStart+1,Math.max(openEnd,inner.size+openStart>=content.size-openEnd?openStart+1:0)),!0)}dropNode(){let{content:content,openStart:openStart,openEnd:openEnd}=this.unplaced,inner=contentAt$2(content,openStart);if(inner.childCount<=1&&openStart>0){let openAtEnd=content.size-openStart<=openStart+inner.size;this.unplaced=new Slice$2(dropFromFragment$2(content,openStart-1,1),openStart-1,openAtEnd?openStart-1:openEnd)}else this.unplaced=new Slice$2(dropFromFragment$2(content,openStart,1),openStart,openEnd)}
// Move content from the unplaced slice at `sliceDepth` to the
// frontier node at `frontierDepth`. Close that frontier node when
// applicable.
placeNodes({sliceDepth:sliceDepth,frontierDepth:frontierDepth,parent:parent,inject:inject,wrap:wrap}){while(this.depth>frontierDepth)this.closeFrontierNode();if(wrap)for(let i=0;i<wrap.length;i++)this.openFrontierNode(wrap[i]);let slice=this.unplaced,fragment=parent?parent.content:slice.content,openStart=slice.openStart-sliceDepth,taken=0,add=[],{match:match,type:type}=this.frontier[frontierDepth];if(inject){for(let i=0;i<inject.childCount;i++)add.push(inject.child(i));match=match.matchFragment(inject)}
// Computes the amount of (end) open nodes at the end of the
// fragment. When 0, the parent is open, but no more. When
// negative, nothing is open.
let openEndCount=fragment.size+sliceDepth-(slice.content.size-slice.openEnd);
// Scan over the fragment, fitting as many child nodes as
// possible.
while(taken<fragment.childCount){let next=fragment.child(taken),matches=match.matchType(next.type);if(!matches)break;taken++,(taken>1||0==openStart||next.content.size)&&(// Drop empty open nodes
match=matches,add.push(closeNodeStart$2(next.mark(type.allowedMarks(next.marks)),1==taken?openStart:0,taken==fragment.childCount?openEndCount:-1)))}let toEnd=taken==fragment.childCount;toEnd||(openEndCount=-1),this.placed=addToFragment$2(this.placed,frontierDepth,Fragment$2.from(add)),this.frontier[frontierDepth].match=match,
// If the parent types match, and the entire node was moved, and
// it's not open, close this frontier node right away.
toEnd&&openEndCount<0&&parent&&parent.type==this.frontier[this.depth].type&&this.frontier.length>1&&this.closeFrontierNode();
// Add new frontier nodes for any open nodes at the end.
for(let i=0,cur=fragment;i<openEndCount;i++){let node=cur.lastChild;this.frontier.push({type:node.type,match:node.contentMatchAt(node.childCount)}),cur=node.content}
// Update `this.unplaced`. Drop the entire node from which we
// placed it we got to its end, otherwise just drop the placed
// nodes.
this.unplaced=toEnd?0==sliceDepth?Slice$2.empty:new Slice$2(dropFromFragment$2(slice.content,sliceDepth-1,1),sliceDepth-1,openEndCount<0?slice.openEnd:sliceDepth-1):new Slice$2(dropFromFragment$2(slice.content,sliceDepth,taken),slice.openStart,slice.openEnd)}mustMoveInline(){if(!this.$to.parent.isTextblock)return-1;let level,top=this.frontier[this.depth];if(!top.type.isTextblock||!contentAfterFits$2(this.$to,this.$to.depth,top.type,top.match,!1)||this.$to.depth==this.depth&&(level=this.findCloseLevel(this.$to))&&level.depth==this.depth)return-1;let{depth:depth}=this.$to,after=this.$to.after(depth);while(depth>1&&after==this.$to.end(--depth))++after;return after}findCloseLevel($to){scan:for(let i=Math.min(this.depth,$to.depth);i>=0;i--){let{match:match,type:type}=this.frontier[i],dropInner=i<$to.depth&&$to.end(i+1)==$to.pos+($to.depth-(i+1)),fit=contentAfterFits$2($to,i,type,match,dropInner);if(fit){for(let d=i-1;d>=0;d--){let{match:match,type:type}=this.frontier[d],matches=contentAfterFits$2($to,d,type,match,!0);if(!matches||matches.childCount)continue scan}return{depth:i,fit:fit,move:dropInner?$to.doc.resolve($to.after(i+1)):$to}}}}close($to){let close=this.findCloseLevel($to);if(!close)return null;while(this.depth>close.depth)this.closeFrontierNode();close.fit.childCount&&(this.placed=addToFragment$2(this.placed,close.depth,close.fit)),$to=close.move;for(let d=close.depth+1;d<=$to.depth;d++){let node=$to.node(d),add=node.type.contentMatch.fillBefore(node.content,!0,$to.index(d));this.openFrontierNode(node.type,node.attrs,add)}return $to}openFrontierNode(type,attrs=null,content){let top=this.frontier[this.depth];top.match=top.match.matchType(type),this.placed=addToFragment$2(this.placed,this.depth,Fragment$2.from(type.create(attrs,content))),this.frontier.push({type:type,match:type.contentMatch})}closeFrontierNode(){let open=this.frontier.pop(),add=open.match.fillBefore(Fragment$2.empty,!0);add.childCount&&(this.placed=addToFragment$2(this.placed,this.frontier.length,add))}}function dropFromFragment$2(fragment,depth,count){return 0==depth?fragment.cutByIndex(count,fragment.childCount):fragment.replaceChild(0,fragment.firstChild.copy(dropFromFragment$2(fragment.firstChild.content,depth-1,count)))}function addToFragment$2(fragment,depth,content){return 0==depth?fragment.append(content):fragment.replaceChild(fragment.childCount-1,fragment.lastChild.copy(addToFragment$2(fragment.lastChild.content,depth-1,content)))}function contentAt$2(fragment,depth){for(let i=0;i<depth;i++)fragment=fragment.firstChild.content;return fragment}function closeNodeStart$2(node,openStart,openEnd){if(openStart<=0)return node;let frag=node.content;return openStart>1&&(frag=frag.replaceChild(0,closeNodeStart$2(frag.firstChild,openStart-1,1==frag.childCount?openEnd-1:0))),openStart>0&&(frag=node.type.contentMatch.fillBefore(frag).append(frag),openEnd<=0&&(frag=frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment$2.empty,!0)))),node.copy(frag)}function contentAfterFits$2($to,depth,type,match,open){let node=$to.node(depth),index=open?$to.indexAfter(depth):$to.index(depth);if(index==node.childCount&&!type.compatibleContent(node.type))return null;let fit=match.fillBefore(node.content,!0,index);return fit&&!invalidMarks$2(type,node.content,index)?fit:null}function invalidMarks$2(type,fragment,start){for(let i=start;i<fragment.childCount;i++)if(!type.allowsMarks(fragment.child(i).marks))return!0;return!1}function definesContent$2(type){return type.spec.defining||type.spec.definingForContent}function replaceRange$2(tr,from,to,slice){if(!slice.size)return tr.deleteRange(from,to);let $from=tr.doc.resolve(from),$to=tr.doc.resolve(to);if(fitsTrivially$2($from,$to,slice))return tr.step(new ReplaceStep$2(from,to,slice));let targetDepths=coveredDepths$2($from,tr.doc.resolve(to));
// Can't replace the whole document, so remove 0 if it's present
0==targetDepths[targetDepths.length-1]&&targetDepths.pop();
// Negative numbers represent not expansion over the whole node at
// that depth, but replacing from $from.before(-D) to $to.pos.
let preferredTarget=-($from.depth+1);targetDepths.unshift(preferredTarget);
// This loop picks a preferred target depth, if one of the covering
// depths is not outside of a defining node, and adds negative
// depths for any depth that has $from at its start and does not
// cross a defining node.
for(let d=$from.depth,pos=$from.pos-1;d>0;d--,pos--){let spec=$from.node(d).type.spec;if(spec.defining||spec.definingAsContext||spec.isolating)break;targetDepths.indexOf(d)>-1?preferredTarget=d:$from.before(d)==pos&&targetDepths.splice(1,0,-d)}
// Try to fit each possible depth of the slice into each possible
// target depth, starting with the preferred depths.
let preferredTargetIndex=targetDepths.indexOf(preferredTarget),leftNodes=[],preferredDepth=slice.openStart;for(let content=slice.content,i=0;;i++){let node=content.firstChild;if(leftNodes.push(node),i==slice.openStart)break;content=node.content}
// Back up preferredDepth to cover defining textblocks directly
// above it, possibly skipping a non-defining textblock.
for(let d=preferredDepth-1;d>=0;d--){let type=leftNodes[d].type,def=definesContent$2(type);if(def&&$from.node(preferredTargetIndex).type!=type)preferredDepth=d;else if(def||!type.isTextblock)break}for(let j=slice.openStart;j>=0;j--){let openDepth=(j+preferredDepth+1)%(slice.openStart+1),insert=leftNodes[openDepth];if(insert)for(let i=0;i<targetDepths.length;i++){
// Loop over possible expansion levels, starting with the
// preferred one
let targetDepth=targetDepths[(i+preferredTargetIndex)%targetDepths.length],expand=!0;targetDepth<0&&(expand=!1,targetDepth=-targetDepth);let parent=$from.node(targetDepth-1),index=$from.index(targetDepth-1);if(parent.canReplaceWith(index,index,insert.type,insert.marks))return tr.replace($from.before(targetDepth),expand?$to.after(targetDepth):to,new Slice$2(closeFragment$2(slice.content,0,slice.openStart,openDepth),openDepth,slice.openEnd))}}let startSteps=tr.steps.length;for(let i=targetDepths.length-1;i>=0;i--){if(tr.replace(from,to,slice),tr.steps.length>startSteps)break;let depth=targetDepths[i];depth<0||(from=$from.before(depth),to=$to.after(depth))}}function closeFragment$2(fragment,depth,oldOpen,newOpen,parent){if(depth<oldOpen){let first=fragment.firstChild;fragment=fragment.replaceChild(0,first.copy(closeFragment$2(first.content,depth+1,oldOpen,newOpen,first)))}if(depth>newOpen){let match=parent.contentMatchAt(0),start=match.fillBefore(fragment).append(fragment);fragment=start.append(match.matchFragment(start).fillBefore(Fragment$2.empty,!0))}return fragment}function replaceRangeWith$2(tr,from,to,node){if(!node.isInline&&from==to&&tr.doc.resolve(from).parent.content.size){let point=insertPoint$2(tr.doc,from,node.type);null!=point&&(from=to=point)}tr.replaceRange(from,to,new Slice$2(Fragment$2.from(node),0,0))}function deleteRange$1$2(tr,from,to){let $from=tr.doc.resolve(from),$to=tr.doc.resolve(to),covered=coveredDepths$2($from,$to);for(let i=0;i<covered.length;i++){let depth=covered[i],last=i==covered.length-1;if(last&&0==depth||$from.node(depth).type.contentMatch.validEnd)return tr.delete($from.start(depth),$to.end(depth));if(depth>0&&(last||$from.node(depth-1).canReplace($from.index(depth-1),$to.indexAfter(depth-1))))return tr.delete($from.before(depth),$to.after(depth))}for(let d=1;d<=$from.depth&&d<=$to.depth;d++)if(from-$from.start(d)==$from.depth-d&&to>$from.end(d)&&$to.end(d)-to!=$to.depth-d)return tr.delete($from.before(d),to);tr.delete(from,to)}
// Returns an array of all depths for which $from - $to spans the
// whole content of the nodes at that depth.
function coveredDepths$2($from,$to){let result=[],minDepth=Math.min($from.depth,$to.depth);for(let d=minDepth;d>=0;d--){let start=$from.start(d);if(start<$from.pos-($from.depth-d)||$to.end(d)>$to.pos+($to.depth-d)||$from.node(d).type.spec.isolating||$to.node(d).type.spec.isolating)break;(start==$to.start(d)||d==$from.depth&&d==$to.depth&&$from.parent.inlineContent&&$to.parent.inlineContent&&d&&$to.start(d-1)==start-1)&&result.push(d)}return result}
/**
@internal
*/let TransformError$2=class extends Error{};TransformError$2=function TransformError(message){let err=Error.call(this,message);return err.__proto__=TransformError.prototype,err},TransformError$2.prototype=Object.create(Error.prototype),TransformError$2.prototype.constructor=TransformError$2,TransformError$2.prototype.name="TransformError";
/**
Abstraction to build up and track an array of
[steps](https://prosemirror.net/docs/ref/#transform.Step) representing a document transformation.

Most transforming methods return the `Transform` object itself, so
that they can be chained.
*/
class Transform$2{
/**
    Create a transform that starts with the given document.
    */
constructor(
/**
    The current document (the result of applying the steps in the
    transform).
    */
doc){this.doc=doc,
/**
        The steps in this transform.
        */
this.steps=[],
/**
        The documents before each of the steps.
        */
this.docs=[],
/**
        A mapping with the maps for each of the steps in this transform.
        */
this.mapping=new Mapping$2}
/**
    The starting document.
    */get before(){return this.docs.length?this.docs[0]:this.doc}
/**
    Apply a new step in this transform, saving the result. Throws an
    error when the step fails.
    */step(step){let result=this.maybeStep(step);if(result.failed)throw new TransformError$2(result.failed);return this}
/**
    Try to apply a step in this transformation, ignoring it if it
    fails. Returns the step result.
    */maybeStep(step){let result=step.apply(this.doc);return result.failed||this.addStep(step,result.doc),result}
/**
    True when the document has been changed (when there are any
    steps).
    */get docChanged(){return this.steps.length>0}
/**
    @internal
    */addStep(step,doc){this.docs.push(this.doc),this.steps.push(step),this.mapping.appendMap(step.getMap()),this.doc=doc}
/**
    Replace the part of the document between `from` and `to` with the
    given `slice`.
    */replace(from,to=from,slice=Slice$2.empty){let step=replaceStep$2(this.doc,from,to,slice);return step&&this.step(step),this}
/**
    Replace the given range with the given content, which may be a
    fragment, node, or array of nodes.
    */replaceWith(from,to,content){return this.replace(from,to,new Slice$2(Fragment$2.from(content),0,0))}
/**
    Delete the content between the given positions.
    */delete(from,to){return this.replace(from,to,Slice$2.empty)}
/**
    Insert the given content at the given position.
    */insert(pos,content){return this.replaceWith(pos,pos,content)}
/**
    Replace a range of the document with a given slice, using
    `from`, `to`, and the slice's
    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
    than fixed start and end points. This method may grow the
    replaced area or close open nodes in the slice in order to get a
    fit that is more in line with WYSIWYG expectations, by dropping
    fully covered parent nodes of the replaced region when they are
    marked [non-defining as
    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
    open parent node from the slice that _is_ marked as [defining
    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
    
    This is the method, for example, to handle paste. The similar
    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
    primitive tool which will _not_ move the start and end of its given
    range, and is useful in situations where you need more precise
    control over what happens.
    */replaceRange(from,to,slice){return replaceRange$2(this,from,to,slice),this}
/**
    Replace the given range with a node, but use `from` and `to` as
    hints, rather than precise positions. When from and to are the same
    and are at the start or end of a parent node in which the given
    node doesn't fit, this method may _move_ them out towards a parent
    that does allow the given node to be placed. When the given range
    completely covers a parent node, this method may completely replace
    that parent node.
    */replaceRangeWith(from,to,node){return replaceRangeWith$2(this,from,to,node),this}
/**
    Delete the given range, expanding it to cover fully covered
    parent nodes until a valid replace is found.
    */deleteRange(from,to){return deleteRange$1$2(this,from,to),this}
/**
    Split the content in the given range off from its parent, if there
    is sibling content before or after it, and move it up the tree to
    the depth specified by `target`. You'll probably want to use
    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
    sure the lift is valid.
    */lift(range,target){return lift$2$2(this,range,target),this}
/**
    Join the blocks around the given position. If depth is 2, their
    last and first siblings are also joined, and so on.
    */join(pos,depth=1){return join$2(this,pos,depth),this}
/**
    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
    The wrappers are assumed to be valid in this position, and should
    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
    */wrap(range,wrappers){return wrap$2(this,range,wrappers),this}
/**
    Set the type of all textblocks (partly) between `from` and `to` to
    the given node type with the given attributes.
    */setBlockType(from,to=from,type,attrs=null){return setBlockType$1$2(this,from,to,type,attrs),this}
/**
    Change the type, attributes, and/or marks of the node at `pos`.
    When `type` isn't given, the existing node type is preserved,
    */setNodeMarkup(pos,type,attrs=null,marks=[]){return setNodeMarkup$2(this,pos,type,attrs,marks),this}
/**
    Split the node at the given position, and optionally, if `depth` is
    greater than one, any number of nodes above that. By default, the
    parts split off will inherit the node type of the original node.
    This can be changed by passing an array of types and attributes to
    use after the split.
    */split(pos,depth=1,typesAfter){return split$2(this,pos,depth,typesAfter),this}
/**
    Add the given mark to the inline content between `from` and `to`.
    */addMark(from,to,mark){return addMark$2(this,from,to,mark),this}
/**
    Remove marks from inline nodes between `from` and `to`. When
    `mark` is a single mark, remove precisely that mark. When it is
    a mark type, remove all marks of that type. When it is null,
    remove all marks of any type.
    */removeMark(from,to,mark){return removeMark$2(this,from,to,mark),this}
/**
    Removes all marks and nodes from the content of the node at
    `pos` that don't match the given new parent node type. Accepts
    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
    third argument.
    */clearIncompatible(pos,parentType,match){return clearIncompatible$2(this,pos,parentType,match),this}}const classesById$2=Object.create(null);
/**
Superclass for editor selections. Every selection type should
extend this. Should not be instantiated directly.
*/class Selection$2{
/**
    Initialize a selection with the head and anchor and ranges. If no
    ranges are given, constructs a single range across `$anchor` and
    `$head`.
    */
constructor(
/**
    The resolved anchor of the selection (the side that stays in
    place when the selection is modified).
    */
$anchor,
/**
    The resolved head of the selection (the side that moves when
    the selection is modified).
    */
$head,ranges){this.$anchor=$anchor,this.$head=$head,this.ranges=ranges||[new SelectionRange$2($anchor.min($head),$anchor.max($head))]}
/**
    The selection's anchor, as an unresolved position.
    */get anchor(){return this.$anchor.pos}
/**
    The selection's head.
    */get head(){return this.$head.pos}
/**
    The lower bound of the selection's main range.
    */get from(){return this.$from.pos}
/**
    The upper bound of the selection's main range.
    */get to(){return this.$to.pos}
/**
    The resolved lower  bound of the selection's main range.
    */get $from(){return this.ranges[0].$from}
/**
    The resolved upper bound of the selection's main range.
    */get $to(){return this.ranges[0].$to}
/**
    Indicates whether the selection contains any content.
    */get empty(){let ranges=this.ranges;for(let i=0;i<ranges.length;i++)if(ranges[i].$from.pos!=ranges[i].$to.pos)return!1;return!0}
/**
    Get the content of this selection as a slice.
    */content(){return this.$from.doc.slice(this.from,this.to,!0)}
/**
    Replace the selection with a slice or, if no slice is given,
    delete the selection. Will append to the given transaction.
    */replace(tr,content=Slice$2.empty){
// Put the new selection at the position after the inserted
// content. When that ended in an inline node, search backwards,
// to get the position after that node. If not, search forward.
let lastNode=content.content.lastChild,lastParent=null;for(let i=0;i<content.openEnd;i++)lastParent=lastNode,lastNode=lastNode.lastChild;let mapFrom=tr.steps.length,ranges=this.ranges;for(let i=0;i<ranges.length;i++){let{$from:$from,$to:$to}=ranges[i],mapping=tr.mapping.slice(mapFrom);tr.replaceRange(mapping.map($from.pos),mapping.map($to.pos),i?Slice$2.empty:content),0==i&&selectionToInsertionEnd$1$2(tr,mapFrom,(lastNode?lastNode.isInline:lastParent&&lastParent.isTextblock)?-1:1)}}
/**
    Replace the selection with the given node, appending the changes
    to the given transaction.
    */replaceWith(tr,node){let mapFrom=tr.steps.length,ranges=this.ranges;for(let i=0;i<ranges.length;i++){let{$from:$from,$to:$to}=ranges[i],mapping=tr.mapping.slice(mapFrom),from=mapping.map($from.pos),to=mapping.map($to.pos);i?tr.deleteRange(from,to):(tr.replaceRangeWith(from,to,node),selectionToInsertionEnd$1$2(tr,mapFrom,node.isInline?-1:1))}}
/**
    Find a valid cursor or leaf node selection starting at the given
    position and searching back if `dir` is negative, and forward if
    positive. When `textOnly` is true, only consider cursor
    selections. Will return null when no valid selection position is
    found.
    */static findFrom($pos,dir,textOnly=!1){let inner=$pos.parent.inlineContent?new TextSelection$2($pos):findSelectionIn$2($pos.node(0),$pos.parent,$pos.pos,$pos.index(),dir,textOnly);if(inner)return inner;for(let depth=$pos.depth-1;depth>=0;depth--){let found=dir<0?findSelectionIn$2($pos.node(0),$pos.node(depth),$pos.before(depth+1),$pos.index(depth),dir,textOnly):findSelectionIn$2($pos.node(0),$pos.node(depth),$pos.after(depth+1),$pos.index(depth)+1,dir,textOnly);if(found)return found}return null}
/**
    Find a valid cursor or leaf node selection near the given
    position. Searches forward first by default, but if `bias` is
    negative, it will search backwards first.
    */static near($pos,bias=1){return this.findFrom($pos,bias)||this.findFrom($pos,-bias)||new AllSelection$2($pos.node(0))}
/**
    Find the cursor or leaf node selection closest to the start of
    the given document. Will return an
    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
    exists.
    */static atStart(doc){return findSelectionIn$2(doc,doc,0,0,1)||new AllSelection$2(doc)}
/**
    Find the cursor or leaf node selection closest to the end of the
    given document.
    */static atEnd(doc){return findSelectionIn$2(doc,doc,doc.content.size,doc.childCount,-1)||new AllSelection$2(doc)}
/**
    Deserialize the JSON representation of a selection. Must be
    implemented for custom classes (as a static class method).
    */static fromJSON(doc,json){if(!json||!json.type)throw new RangeError("Invalid input for Selection.fromJSON");let cls=classesById$2[json.type];if(!cls)throw new RangeError(`No selection type ${json.type} defined`);return cls.fromJSON(doc,json)}
/**
    To be able to deserialize selections from JSON, custom selection
    classes must register themselves with an ID string, so that they
    can be disambiguated. Try to pick something that's unlikely to
    clash with classes from other modules.
    */static jsonID(id,selectionClass){if(id in classesById$2)throw new RangeError("Duplicate use of selection JSON ID "+id);return classesById$2[id]=selectionClass,selectionClass.prototype.jsonID=id,selectionClass}
/**
    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
    which is a value that can be mapped without having access to a
    current document, and later resolved to a real selection for a
    given document again. (This is used mostly by the history to
    track and restore old selections.) The default implementation of
    this method just converts the selection to a text selection and
    returns the bookmark for that.
    */getBookmark(){return TextSelection$2.between(this.$anchor,this.$head).getBookmark()}}Selection$2.prototype.visible=!0;
/**
Represents a selected range in a document.
*/
class SelectionRange$2{
/**
    Create a range.
    */
constructor(
/**
    The lower bound of the range.
    */
$from,
/**
    The upper bound of the range.
    */
$to){this.$from=$from,this.$to=$to}}let warnedAboutTextSelection$2=!1;function checkTextSelection$2($pos){warnedAboutTextSelection$2||$pos.parent.inlineContent||(warnedAboutTextSelection$2=!0)}
/**
A text selection represents a classical editor selection, with a
head (the moving side) and anchor (immobile side), both of which
point into textblock nodes. It can be empty (a regular cursor
position).
*/class TextSelection$2 extends Selection$2{
/**
    Construct a text selection between the given points.
    */
constructor($anchor,$head=$anchor){checkTextSelection$2($anchor),checkTextSelection$2($head),super($anchor,$head)}
/**
    Returns a resolved position if this is a cursor selection (an
    empty text selection), and null otherwise.
    */get $cursor(){return this.$anchor.pos==this.$head.pos?this.$head:null}map(doc,mapping){let $head=doc.resolve(mapping.map(this.head));if(!$head.parent.inlineContent)return Selection$2.near($head);let $anchor=doc.resolve(mapping.map(this.anchor));return new TextSelection$2($anchor.parent.inlineContent?$anchor:$head,$head)}replace(tr,content=Slice$2.empty){if(super.replace(tr,content),content==Slice$2.empty){let marks=this.$from.marksAcross(this.$to);marks&&tr.ensureMarks(marks)}}eq(other){return other instanceof TextSelection$2&&other.anchor==this.anchor&&other.head==this.head}getBookmark(){return new TextBookmark$2(this.anchor,this.head)}toJSON(){return{type:"text",anchor:this.anchor,head:this.head}}
/**
    @internal
    */static fromJSON(doc,json){if("number"!=typeof json.anchor||"number"!=typeof json.head)throw new RangeError("Invalid input for TextSelection.fromJSON");return new TextSelection$2(doc.resolve(json.anchor),doc.resolve(json.head))}
/**
    Create a text selection from non-resolved positions.
    */static create(doc,anchor,head=anchor){let $anchor=doc.resolve(anchor);return new this($anchor,head==anchor?$anchor:doc.resolve(head))}
/**
    Return a text selection that spans the given positions or, if
    they aren't text positions, find a text selection near them.
    `bias` determines whether the method searches forward (default)
    or backwards (negative number) first. Will fall back to calling
    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
    doesn't contain a valid text position.
    */static between($anchor,$head,bias){let dPos=$anchor.pos-$head.pos;if(bias&&!dPos||(bias=dPos>=0?1:-1),!$head.parent.inlineContent){let found=Selection$2.findFrom($head,bias,!0)||Selection$2.findFrom($head,-bias,!0);if(!found)return Selection$2.near($head,bias);$head=found.$head}return $anchor.parent.inlineContent||(0==dPos?$anchor=$head:($anchor=(Selection$2.findFrom($anchor,-bias,!0)||Selection$2.findFrom($anchor,bias,!0)).$anchor,$anchor.pos<$head.pos!=dPos<0&&($anchor=$head))),new TextSelection$2($anchor,$head)}}Selection$2.jsonID("text",TextSelection$2);class TextBookmark$2{constructor(anchor,head){this.anchor=anchor,this.head=head}map(mapping){return new TextBookmark$2(mapping.map(this.anchor),mapping.map(this.head))}resolve(doc){return TextSelection$2.between(doc.resolve(this.anchor),doc.resolve(this.head))}}
/**
A node selection is a selection that points at a single node. All
nodes marked [selectable](https://prosemirror.net/docs/ref/#model.NodeSpec.selectable) can be the
target of a node selection. In such a selection, `from` and `to`
point directly before and after the selected node, `anchor` equals
`from`, and `head` equals `to`..
*/class NodeSelection$2 extends Selection$2{
/**
    Create a node selection. Does not verify the validity of its
    argument.
    */
constructor($pos){let node=$pos.nodeAfter,$end=$pos.node(0).resolve($pos.pos+node.nodeSize);super($pos,$end),this.node=node}map(doc,mapping){let{deleted:deleted,pos:pos}=mapping.mapResult(this.anchor),$pos=doc.resolve(pos);return deleted?Selection$2.near($pos):new NodeSelection$2($pos)}content(){return new Slice$2(Fragment$2.from(this.node),0,0)}eq(other){return other instanceof NodeSelection$2&&other.anchor==this.anchor}toJSON(){return{type:"node",anchor:this.anchor}}getBookmark(){return new NodeBookmark$2(this.anchor)}
/**
    @internal
    */static fromJSON(doc,json){if("number"!=typeof json.anchor)throw new RangeError("Invalid input for NodeSelection.fromJSON");return new NodeSelection$2(doc.resolve(json.anchor))}
/**
    Create a node selection from non-resolved positions.
    */static create(doc,from){return new NodeSelection$2(doc.resolve(from))}
/**
    Determines whether the given node may be selected as a node
    selection.
    */static isSelectable(node){return!node.isText&&!1!==node.type.spec.selectable}}NodeSelection$2.prototype.visible=!1,Selection$2.jsonID("node",NodeSelection$2);class NodeBookmark$2{constructor(anchor){this.anchor=anchor}map(mapping){let{deleted:deleted,pos:pos}=mapping.mapResult(this.anchor);return deleted?new TextBookmark$2(pos,pos):new NodeBookmark$2(pos)}resolve(doc){let $pos=doc.resolve(this.anchor),node=$pos.nodeAfter;return node&&NodeSelection$2.isSelectable(node)?new NodeSelection$2($pos):Selection$2.near($pos)}}
/**
A selection type that represents selecting the whole document
(which can not necessarily be expressed with a text selection, when
there are for example leaf block nodes at the start or end of the
document).
*/class AllSelection$2 extends Selection$2{
/**
    Create an all-selection over the given document.
    */
constructor(doc){super(doc.resolve(0),doc.resolve(doc.content.size))}replace(tr,content=Slice$2.empty){if(content==Slice$2.empty){tr.delete(0,tr.doc.content.size);let sel=Selection$2.atStart(tr.doc);sel.eq(tr.selection)||tr.setSelection(sel)}else super.replace(tr,content)}toJSON(){return{type:"all"}}
/**
    @internal
    */static fromJSON(doc){return new AllSelection$2(doc)}map(doc){return new AllSelection$2(doc)}eq(other){return other instanceof AllSelection$2}getBookmark(){return AllBookmark$2}}Selection$2.jsonID("all",AllSelection$2);const AllBookmark$2={map(){return this},resolve(doc){return new AllSelection$2(doc)}};
// FIXME we'll need some awareness of text direction when scanning for selections
// Try to find a selection inside the given node. `pos` points at the
// position where the search starts. When `text` is true, only return
// text selections.
function findSelectionIn$2(doc,node,pos,index,dir,text=!1){if(node.inlineContent)return TextSelection$2.create(doc,pos);for(let i=index-(dir>0?0:1);dir>0?i<node.childCount:i>=0;i+=dir){let child=node.child(i);if(child.isAtom){if(!text&&NodeSelection$2.isSelectable(child))return NodeSelection$2.create(doc,pos-(dir<0?child.nodeSize:0))}else{let inner=findSelectionIn$2(doc,child,pos+dir,dir<0?child.childCount:0,dir,text);if(inner)return inner}pos+=child.nodeSize*dir}return null}function selectionToInsertionEnd$1$2(tr,startLen,bias){let last=tr.steps.length-1;if(last<startLen)return;let step=tr.steps[last];if(!(step instanceof ReplaceStep$2||step instanceof ReplaceAroundStep$2))return;let end,map=tr.mapping.maps[last];map.forEach(((_from,_to,_newFrom,newTo)=>{null==end&&(end=newTo)})),tr.setSelection(Selection$2.near(tr.doc.resolve(end),bias))}function bind$1$2(f,self){return self&&f?f.bind(self):f}class FieldDesc$2{constructor(name,desc,self){this.name=name,this.init=bind$1$2(desc.init,self),this.apply=bind$1$2(desc.apply,self)}}function bindProps$2(obj,self,target){for(let prop in obj){let val=obj[prop];val instanceof Function?val=val.bind(self):"handleDOMEvents"==prop&&(val=bindProps$2(val,self,{})),target[prop]=val}return target}
/**
Plugins bundle functionality that can be added to an editor.
They are part of the [editor state](https://prosemirror.net/docs/ref/#state.EditorState) and
may influence that state and the view that contains it.
*/new FieldDesc$2("doc",{init(config){return config.doc||config.schema.topNodeType.createAndFill()},apply(tr){return tr.doc}}),new FieldDesc$2("selection",{init(config,instance){return config.selection||Selection$2.atStart(instance.doc)},apply(tr){return tr.selection}}),new FieldDesc$2("storedMarks",{init(config){return config.storedMarks||null},apply(tr,_marks,_old,state){return state.selection.$cursor?tr.storedMarks:null}}),new FieldDesc$2("scrollToSelection",{init(){return 0},apply(tr,prev){return tr.scrolledIntoView?prev+1:prev}});class Plugin$2{
/**
    Create a plugin.
    */
constructor(
/**
    The plugin's [spec object](https://prosemirror.net/docs/ref/#state.PluginSpec).
    */
spec){this.spec=spec,
/**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
this.props={},spec.props&&bindProps$2(spec.props,this,this.props),this.key=spec.key?spec.key.key:createKey$2("plugin")}
/**
    Extract the plugin's state field from an editor state.
    */getState(state){return state[this.key]}}const keys$1$2=Object.create(null);function createKey$2(name){return name in keys$1$2?name+"$"+ ++keys$1$2[name]:(keys$1$2[name]=0,name+"$")}
/**
A key is used to [tag](https://prosemirror.net/docs/ref/#state.PluginSpec.key) plugins in a way
that makes it possible to find them, given an editor state.
Assigning a key does mean only one plugin of that type can be
active in a state.
*/class PluginKey$2{
/**
    Create a plugin key.
    */
constructor(name="key"){this.key=createKey$2(name)}
/**
    Get the active plugin with this key, if any, from an editor
    state.
    */get(state){return state.config.pluginsByKey[this.key]}
/**
    Get the plugin's state from an editor state.
    */getState(state){return state[this.key]}}const nav$2="undefined"!=typeof navigator?navigator:null,doc$5="undefined"!=typeof document?document:null,agent$2=nav$2&&nav$2.userAgent||"",ie_edge$2=/Edge\/(\d+)/.exec(agent$2),ie_upto10$2=/MSIE \d/.exec(agent$2),ie_11up$2=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent$2),ie$1$2=!!(ie_upto10$2||ie_11up$2||ie_edge$2),ie_version$2=ie_upto10$2?document.documentMode:ie_11up$2?+ie_11up$2[1]:ie_edge$2?+ie_edge$2[1]:0,gecko$2=!ie$1$2&&/gecko\/(\d+)/i.test(agent$2);gecko$2&&(/Firefox\/(\d+)/.exec(agent$2)||[0,0])[1];const _chrome$2=!ie$1$2&&/Chrome\/(\d+)/.exec(agent$2),chrome$1$2=!!_chrome$2,chrome_version$2=_chrome$2?+_chrome$2[1]:0,safari$2=!ie$1$2&&!!nav$2&&/Apple Computer/.test(nav$2.vendor),ios$2=safari$2&&(/Mobile\/\w+/.test(agent$2)||!!nav$2&&nav$2.maxTouchPoints>2),mac$2$2=ios$2||!!nav$2&&/Mac/.test(nav$2.platform),android$2=/Android \d/.test(agent$2),webkit$2=!!doc$5&&"webkitFontSmoothing"in doc$5.documentElement.style,webkit_version$2=webkit$2?+(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent)||[0,0])[1]:0,domIndex$2=function(node){for(var index=0;;index++)if(node=node.previousSibling,!node)return index},isEquivalentPosition$2=function(node,off,targetNode,targetOff){return targetNode&&(scanFor$2(node,off,targetNode,targetOff,-1)||scanFor$2(node,off,targetNode,targetOff,1))},atomElements$2=/^(img|br|input|textarea|hr)$/i;function scanFor$2(node,off,targetNode,targetOff,dir){for(;;){if(node==targetNode&&off==targetOff)return!0;if(off==(dir<0?0:nodeSize$2(node))){let parent=node.parentNode;if(!parent||1!=parent.nodeType||hasBlockDesc$2(node)||atomElements$2.test(node.nodeName)||"false"==node.contentEditable)return!1;off=domIndex$2(node)+(dir<0?0:1),node=parent}else{if(1!=node.nodeType)return!1;if(node=node.childNodes[off+(dir<0?-1:0)],"false"==node.contentEditable)return!1;off=dir<0?nodeSize$2(node):0}}}function nodeSize$2(node){return 3==node.nodeType?node.nodeValue.length:node.childNodes.length}function isOnEdge$2(node,offset,parent){for(let atStart=0==offset,atEnd=offset==nodeSize$2(node);atStart||atEnd;){if(node==parent)return!0;let index=domIndex$2(node);if(node=node.parentNode,!node)return!1;atStart=atStart&&0==index,atEnd=atEnd&&index==nodeSize$2(node)}}function hasBlockDesc$2(dom){let desc;for(let cur=dom;cur;cur=cur.parentNode)if(desc=cur.pmViewDesc)break;return desc&&desc.node&&desc.node.isBlock&&(desc.dom==dom||desc.contentDOM==dom)}
// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523
// (isCollapsed inappropriately returns true in shadow dom)
const selectionCollapsed$2=function(domSel){let collapsed=domSel.isCollapsed;return collapsed&&chrome$1$2&&domSel.rangeCount&&!domSel.getRangeAt(0).collapsed&&(collapsed=!1),collapsed};function keyEvent$2(keyCode,key){let event=document.createEvent("Event");return event.initEvent("keydown",!0,!0),event.keyCode=keyCode,event.key=event.code=key,event}function selectionFromDOM$2(view,origin=null){let domSel=view.domSelection(),doc=view.state.doc;if(!domSel.focusNode)return null;let nearestDesc=view.docView.nearestDesc(domSel.focusNode),inWidget=nearestDesc&&0==nearestDesc.size,head=view.docView.posFromDOM(domSel.focusNode,domSel.focusOffset,1);if(head<0)return null;let $anchor,selection,$head=doc.resolve(head);if(selectionCollapsed$2(domSel)){$anchor=$head;while(nearestDesc&&!nearestDesc.node)nearestDesc=nearestDesc.parent;let nearestDescNode=nearestDesc.node;if(nearestDesc&&nearestDescNode.isAtom&&NodeSelection$2.isSelectable(nearestDescNode)&&nearestDesc.parent&&(!nearestDescNode.isInline||!isOnEdge$2(domSel.focusNode,domSel.focusOffset,nearestDesc.dom))){let pos=nearestDesc.posBefore;selection=new NodeSelection$2(head==pos?$head:doc.resolve(pos))}}else{let anchor=view.docView.posFromDOM(domSel.anchorNode,domSel.anchorOffset,1);if(anchor<0)return null;$anchor=doc.resolve(anchor)}if(!selection){let bias="pointer"==origin||view.state.selection.head<$head.pos&&!inWidget?1:-1;selection=selectionBetween$2(view,$anchor,$head,bias)}return selection}function editorOwnsSelection$2(view){return view.editable?view.hasFocus():hasSelection$2(view)&&document.activeElement&&document.activeElement.contains(view.dom)}function selectionToDOM$2(view,force=!1){let sel=view.state.selection;if(syncNodeSelection$2(view,sel),editorOwnsSelection$2(view)){
// The delayed drag selection causes issues with Cell Selections
// in Safari. And the drag selection delay is to workarond issues
// which only present in Chrome.
if(!force&&view.input.mouseDown&&view.input.mouseDown.allowDefault&&chrome$1$2){let domSel=view.domSelection(),curSel=view.domObserver.currentSelection;if(domSel.anchorNode&&curSel.anchorNode&&isEquivalentPosition$2(domSel.anchorNode,domSel.anchorOffset,curSel.anchorNode,curSel.anchorOffset))return view.input.mouseDown.delayedSelectionSync=!0,void view.domObserver.setCurSelection()}if(view.domObserver.disconnectSelection(),view.cursorWrapper)selectCursorWrapper$2(view);else{let resetEditableFrom,resetEditableTo,{anchor:anchor,head:head}=sel;!brokenSelectBetweenUneditable$2||sel instanceof TextSelection$2||(sel.$from.parent.inlineContent||(resetEditableFrom=temporarilyEditableNear$2(view,sel.from)),sel.empty||sel.$from.parent.inlineContent||(resetEditableTo=temporarilyEditableNear$2(view,sel.to))),view.docView.setSelection(anchor,head,view.root,force),brokenSelectBetweenUneditable$2&&(resetEditableFrom&&resetEditable$2(resetEditableFrom),resetEditableTo&&resetEditable$2(resetEditableTo)),sel.visible?view.dom.classList.remove("ProseMirror-hideselection"):(view.dom.classList.add("ProseMirror-hideselection"),"onselectionchange"in document&&removeClassOnSelectionChange$2(view))}view.domObserver.setCurSelection(),view.domObserver.connectSelection()}}
// Kludge to work around Webkit not allowing a selection to start/end
// between non-editable block nodes. We briefly make something
// editable, set the selection, then set it uneditable again.
const brokenSelectBetweenUneditable$2=safari$2||chrome$1$2&&chrome_version$2<63;function temporarilyEditableNear$2(view,pos){let{node:node,offset:offset}=view.docView.domFromPos(pos,0),after=offset<node.childNodes.length?node.childNodes[offset]:null,before=offset?node.childNodes[offset-1]:null;if(safari$2&&after&&"false"==after.contentEditable)return setEditable$2(after);if((!after||"false"==after.contentEditable)&&(!before||"false"==before.contentEditable)){if(after)return setEditable$2(after);if(before)return setEditable$2(before)}}function setEditable$2(element){return element.contentEditable="true",safari$2&&element.draggable&&(element.draggable=!1,element.wasDraggable=!0),element}function resetEditable$2(element){element.contentEditable="false",element.wasDraggable&&(element.draggable=!0,element.wasDraggable=null)}function removeClassOnSelectionChange$2(view){let doc=view.dom.ownerDocument;doc.removeEventListener("selectionchange",view.input.hideSelectionGuard);let domSel=view.domSelection(),node=domSel.anchorNode,offset=domSel.anchorOffset;doc.addEventListener("selectionchange",view.input.hideSelectionGuard=()=>{domSel.anchorNode==node&&domSel.anchorOffset==offset||(doc.removeEventListener("selectionchange",view.input.hideSelectionGuard),setTimeout((()=>{editorOwnsSelection$2(view)&&!view.state.selection.visible||view.dom.classList.remove("ProseMirror-hideselection")}),20))})}function selectCursorWrapper$2(view){let domSel=view.domSelection(),range=document.createRange(),node=view.cursorWrapper.dom,img="IMG"==node.nodeName;img?range.setEnd(node.parentNode,domIndex$2(node)+1):range.setEnd(node,0),range.collapse(!1),domSel.removeAllRanges(),domSel.addRange(range),
// Kludge to kill 'control selection' in IE11 when selecting an
// invisible cursor wrapper, since that would result in those weird
// resize handles and a selection that considers the absolutely
// positioned wrapper, rather than the root editable node, the
// focused element.
!img&&!view.state.selection.visible&&ie$1$2&&ie_version$2<=11&&(node.disabled=!0,node.disabled=!1)}function syncNodeSelection$2(view,sel){if(sel instanceof NodeSelection$2){let desc=view.docView.descAt(sel.from);desc!=view.lastSelectedViewDesc&&(clearNodeSelection$2(view),desc&&desc.selectNode(),view.lastSelectedViewDesc=desc)}else clearNodeSelection$2(view)}
// Clear all DOM statefulness of the last node selection.
function clearNodeSelection$2(view){view.lastSelectedViewDesc&&(view.lastSelectedViewDesc.parent&&view.lastSelectedViewDesc.deselectNode(),view.lastSelectedViewDesc=void 0)}function selectionBetween$2(view,$anchor,$head,bias){return view.someProp("createSelectionBetween",(f=>f(view,$anchor,$head)))||TextSelection$2.between($anchor,$head,bias)}function hasSelection$2(view){let sel=view.domSelection();if(!sel.anchorNode)return!1;try{
// Firefox will raise 'permission denied' errors when accessing
// properties of `sel.anchorNode` when it's in a generated CSS
// element.
return view.dom.contains(3==sel.anchorNode.nodeType?sel.anchorNode.parentNode:sel.anchorNode)&&(view.editable||view.dom.contains(3==sel.focusNode.nodeType?sel.focusNode.parentNode:sel.focusNode))}catch(_){return!1}}function moveSelectionBlock$2(state,dir){let{$anchor:$anchor,$head:$head}=state.selection,$side=dir>0?$anchor.max($head):$anchor.min($head),$start=$side.parent.inlineContent?$side.depth?state.doc.resolve(dir>0?$side.after():$side.before()):null:$side;return $start&&Selection$2.findFrom($start,dir)}function apply$3(view,sel){return view.dispatch(view.state.tr.setSelection(sel).scrollIntoView()),!0}function selectHorizontally$2(view,dir,mods){let sel=view.state.selection;if(!(sel instanceof TextSelection$2)){if(sel instanceof NodeSelection$2&&sel.node.isInline)return apply$3(view,new TextSelection$2(dir>0?sel.$to:sel.$from));{let next=moveSelectionBlock$2(view.state,dir);return!!next&&apply$3(view,next)}}if(!sel.empty||mods.indexOf("s")>-1)return!1;if(view.endOfTextblock(dir>0?"right":"left")){let next=moveSelectionBlock$2(view.state,dir);return!!(next&&next instanceof NodeSelection$2)&&apply$3(view,next)}if(!(mac$2$2&&mods.indexOf("m")>-1)){let desc,$head=sel.$head,node=$head.textOffset?null:dir<0?$head.nodeBefore:$head.nodeAfter;if(!node||node.isText)return!1;let nodePos=dir<0?$head.pos-node.nodeSize:$head.pos;return!!(node.isAtom||(desc=view.docView.descAt(nodePos))&&!desc.contentDOM)&&(NodeSelection$2.isSelectable(node)?apply$3(view,new NodeSelection$2(dir<0?view.state.doc.resolve($head.pos-node.nodeSize):$head)):!!webkit$2&&apply$3(view,new TextSelection$2(view.state.doc.resolve(dir<0?nodePos:nodePos+node.nodeSize))))}}function nodeLen$2(node){return 3==node.nodeType?node.nodeValue.length:node.childNodes.length}function isIgnorable$2(dom){let desc=dom.pmViewDesc;return desc&&0==desc.size&&(dom.nextSibling||"BR"!=dom.nodeName)}
// Make sure the cursor isn't directly after one or more ignored
// nodes, which will confuse the browser's cursor motion logic.
function skipIgnoredNodesLeft$2(view){let sel=view.domSelection(),node=sel.focusNode,offset=sel.focusOffset;if(!node)return;let moveNode,moveOffset,force=!1;
// Gecko will do odd things when the selection is directly in front
// of a non-editable node, so in that case, move it into the next
// node if possible. Issue prosemirror/prosemirror#832.
for(gecko$2&&1==node.nodeType&&offset<nodeLen$2(node)&&isIgnorable$2(node.childNodes[offset])&&(force=!0);;)if(offset>0){if(1!=node.nodeType)break;{let before=node.childNodes[offset-1];if(isIgnorable$2(before))moveNode=node,moveOffset=--offset;else{if(3!=before.nodeType)break;node=before,offset=node.nodeValue.length}}}else{if(isBlockNode$2(node))break;{let prev=node.previousSibling;while(prev&&isIgnorable$2(prev))moveNode=node.parentNode,moveOffset=domIndex$2(prev),prev=prev.previousSibling;if(prev)node=prev,offset=nodeLen$2(node);else{if(node=node.parentNode,node==view.dom)break;offset=0}}}force?setSelFocus$2(view,sel,node,offset):moveNode&&setSelFocus$2(view,sel,moveNode,moveOffset)}
// Make sure the cursor isn't directly before one or more ignored
// nodes.
function skipIgnoredNodesRight$2(view){let sel=view.domSelection(),node=sel.focusNode,offset=sel.focusOffset;if(!node)return;let moveNode,moveOffset,len=nodeLen$2(node);for(;;)if(offset<len){if(1!=node.nodeType)break;let after=node.childNodes[offset];if(!isIgnorable$2(after))break;moveNode=node,moveOffset=++offset}else{if(isBlockNode$2(node))break;{let next=node.nextSibling;while(next&&isIgnorable$2(next))moveNode=next.parentNode,moveOffset=domIndex$2(next)+1,next=next.nextSibling;if(next)node=next,offset=0,len=nodeLen$2(node);else{if(node=node.parentNode,node==view.dom)break;offset=len=0}}}moveNode&&setSelFocus$2(view,sel,moveNode,moveOffset)}function isBlockNode$2(dom){let desc=dom.pmViewDesc;return desc&&desc.node&&desc.node.isBlock}function setSelFocus$2(view,sel,node,offset){if(selectionCollapsed$2(sel)){let range=document.createRange();range.setEnd(node,offset),range.setStart(node,offset),sel.removeAllRanges(),sel.addRange(range)}else sel.extend&&sel.extend(node,offset);view.domObserver.setCurSelection();let{state:state}=view;
// If no state update ends up happening, reset the selection.
setTimeout((()=>{view.state==state&&selectionToDOM$2(view)}),50)}
// Check whether vertical selection motion would involve node
// selections. If so, apply it (if not, the result is left to the
// browser)
function selectVertically$2(view,dir,mods){let sel=view.state.selection;if(sel instanceof TextSelection$2&&!sel.empty||mods.indexOf("s")>-1)return!1;if(mac$2$2&&mods.indexOf("m")>-1)return!1;let{$from:$from,$to:$to}=sel;if(!$from.parent.inlineContent||view.endOfTextblock(dir<0?"up":"down")){let next=moveSelectionBlock$2(view.state,dir);if(next&&next instanceof NodeSelection$2)return apply$3(view,next)}if(!$from.parent.inlineContent){let side=dir<0?$from:$to,beyond=sel instanceof AllSelection$2?Selection$2.near(side,dir):Selection$2.findFrom(side,dir);return!!beyond&&apply$3(view,beyond)}return!1}function stopNativeHorizontalDelete$2(view,dir){if(!(view.state.selection instanceof TextSelection$2))return!0;let{$head:$head,$anchor:$anchor,empty:empty}=view.state.selection;if(!$head.sameParent($anchor))return!0;if(!empty)return!1;if(view.endOfTextblock(dir>0?"forward":"backward"))return!0;let nextNode=!$head.textOffset&&(dir<0?$head.nodeBefore:$head.nodeAfter);if(nextNode&&!nextNode.isText){let tr=view.state.tr;return dir<0?tr.delete($head.pos-nextNode.nodeSize,$head.pos):tr.delete($head.pos,$head.pos+nextNode.nodeSize),view.dispatch(tr),!0}return!1}function switchEditable$2(view,node,state){view.domObserver.stop(),node.contentEditable=state,view.domObserver.start()}
// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821
// In which Safari (and at some point in the past, Chrome) does really
// wrong things when the down arrow is pressed when the cursor is
// directly at the start of a textblock and has an uneditable node
// after it
function safariDownArrowBug$2(view){if(!safari$2||view.state.selection.$head.parentOffset>0)return!1;let{focusNode:focusNode,focusOffset:focusOffset}=view.domSelection();if(focusNode&&1==focusNode.nodeType&&0==focusOffset&&focusNode.firstChild&&"false"==focusNode.firstChild.contentEditable){let child=focusNode.firstChild;switchEditable$2(view,child,"true"),setTimeout((()=>switchEditable$2(view,child,"false")),20)}return!1}
// A backdrop key mapping used to make sure we always suppress keys
// that have a dangerous default effect, even if the commands they are
// bound to return false, and to make sure that cursor-motion keys
// find a cursor (as opposed to a node selection) when pressed. For
// cursor-motion keys, the code in the handlers also takes care of
// block selections.
function getMods$2(event){let result="";return event.ctrlKey&&(result+="c"),event.metaKey&&(result+="m"),event.altKey&&(result+="a"),event.shiftKey&&(result+="s"),result}function captureKeyDown$2(view,event){let code=event.keyCode,mods=getMods$2(event);return 8==code||mac$2$2&&72==code&&"c"==mods?stopNativeHorizontalDelete$2(view,-1)||skipIgnoredNodesLeft$2(view):46==code||mac$2$2&&68==code&&"c"==mods?stopNativeHorizontalDelete$2(view,1)||skipIgnoredNodesRight$2(view):13==code||27==code||(37==code||mac$2$2&&66==code&&"c"==mods?selectHorizontally$2(view,-1,mods)||skipIgnoredNodesLeft$2(view):39==code||mac$2$2&&70==code&&"c"==mods?selectHorizontally$2(view,1,mods)||skipIgnoredNodesRight$2(view):38==code||mac$2$2&&80==code&&"c"==mods?selectVertically$2(view,-1,mods)||skipIgnoredNodesLeft$2(view):40==code||mac$2$2&&78==code&&"c"==mods?safariDownArrowBug$2(view)||selectVertically$2(view,1,mods)||skipIgnoredNodesRight$2(view):mods==(mac$2$2?"m":"c")&&(66==code||73==code||89==code||90==code))}function serializeForClipboard$2(view,slice){let context=[],{content:content,openStart:openStart,openEnd:openEnd}=slice;while(openStart>1&&openEnd>1&&1==content.childCount&&1==content.firstChild.childCount){openStart--,openEnd--;let node=content.firstChild;context.push(node.type.name,node.attrs!=node.type.defaultAttrs?node.attrs:null),content=node.content}let serializer=view.someProp("clipboardSerializer")||DOMSerializer$2.fromSchema(view.state.schema),doc=detachedDoc$2(),wrap=doc.createElement("div");wrap.appendChild(serializer.serializeFragment(content,{document:doc}));let needsWrap,firstChild=wrap.firstChild,wrappers=0;while(firstChild&&1==firstChild.nodeType&&(needsWrap=wrapMap$2[firstChild.nodeName.toLowerCase()])){for(let i=needsWrap.length-1;i>=0;i--){let wrapper=doc.createElement(needsWrap[i]);while(wrap.firstChild)wrapper.appendChild(wrap.firstChild);wrap.appendChild(wrapper),wrappers++}firstChild=wrap.firstChild}firstChild&&1==firstChild.nodeType&&firstChild.setAttribute("data-pm-slice",`${openStart} ${openEnd}${wrappers?` -${wrappers}`:""} ${JSON.stringify(context)}`);let text=view.someProp("clipboardTextSerializer",(f=>f(slice)))||slice.content.textBetween(0,slice.content.size,"\n\n");return{dom:wrap,text:text}}
// Read a slice of content from the clipboard (or drop data).
function parseFromClipboard$2(view,text,html,plainText,$context){let dom,slice,inCode=$context.parent.type.spec.code;if(!html&&!text)return null;let asText=text&&(plainText||inCode||!html);if(asText){if(view.someProp("transformPastedText",(f=>{text=f(text,inCode||plainText)})),inCode)return text?new Slice$2(Fragment$2.from(view.state.schema.text(text.replace(/\r\n?/g,"\n"))),0,0):Slice$2.empty;let parsed=view.someProp("clipboardTextParser",(f=>f(text,$context,plainText)));if(parsed)slice=parsed;else{let marks=$context.marks(),{schema:schema}=view.state,serializer=DOMSerializer$2.fromSchema(schema);dom=document.createElement("div"),text.split(/(?:\r\n?|\n)+/).forEach((block=>{let p=dom.appendChild(document.createElement("p"));block&&p.appendChild(serializer.serializeNode(schema.text(block,marks)))}))}}else view.someProp("transformPastedHTML",(f=>{html=f(html)})),dom=readHTML$2(html),webkit$2&&restoreReplacedSpaces$2(dom);let contextNode=dom&&dom.querySelector("[data-pm-slice]"),sliceData=contextNode&&/^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice")||"");if(sliceData&&sliceData[3])for(let i=+sliceData[3];i>0&&dom.firstChild;i--)dom=dom.firstChild;if(!slice){let parser=view.someProp("clipboardParser")||view.someProp("domParser")||DOMParser$1$2.fromSchema(view.state.schema);slice=parser.parseSlice(dom,{preserveWhitespace:!(!asText&&!sliceData),context:$context,ruleFromNode(dom){return"BR"!=dom.nodeName||dom.nextSibling||!dom.parentNode||inlineParents$2.test(dom.parentNode.nodeName)?null:{ignore:!0}}})}if(sliceData)slice=addContext$2(closeSlice$2(slice,+sliceData[1],+sliceData[2]),sliceData[4]);else if(// HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent
slice=Slice$2.maxOpen(normalizeSiblings$2(slice.content,$context),!0),slice.openStart||slice.openEnd){let openStart=0,openEnd=0;for(let node=slice.content.firstChild;openStart<slice.openStart&&!node.type.spec.isolating;openStart++,node=node.firstChild);for(let node=slice.content.lastChild;openEnd<slice.openEnd&&!node.type.spec.isolating;openEnd++,node=node.lastChild);slice=closeSlice$2(slice,openStart,openEnd)}return view.someProp("transformPasted",(f=>{slice=f(slice)})),slice}const inlineParents$2=/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
// Takes a slice parsed with parseSlice, which means there hasn't been
// any content-expression checking done on the top nodes, tries to
// find a parent node in the current context that might fit the nodes,
// and if successful, rebuilds the slice so that it fits into that parent.

// This addresses the problem that Transform.replace expects a
// coherent slice, and will fail to place a set of siblings that don't
// fit anywhere in the schema.
function normalizeSiblings$2(fragment,$context){if(fragment.childCount<2)return fragment;for(let d=$context.depth;d>=0;d--){let lastWrap,parent=$context.node(d),match=parent.contentMatchAt($context.index(d)),result=[];if(fragment.forEach((node=>{if(!result)return;let inLast,wrap=match.findWrapping(node.type);if(!wrap)return result=null;if(inLast=result.length&&lastWrap.length&&addToSibling$2(wrap,lastWrap,node,result[result.length-1],0))result[result.length-1]=inLast;else{result.length&&(result[result.length-1]=closeRight$2(result[result.length-1],lastWrap.length));let wrapped=withWrappers$2(node,wrap);result.push(wrapped),match=match.matchType(wrapped.type),lastWrap=wrap}})),result)return Fragment$2.from(result)}return fragment}function withWrappers$2(node,wrap,from=0){for(let i=wrap.length-1;i>=from;i--)node=wrap[i].create(null,Fragment$2.from(node));return node}
// Used to group adjacent nodes wrapped in similar parents by
// normalizeSiblings into the same parent node
function addToSibling$2(wrap,lastWrap,node,sibling,depth){if(depth<wrap.length&&depth<lastWrap.length&&wrap[depth]==lastWrap[depth]){let inner=addToSibling$2(wrap,lastWrap,node,sibling.lastChild,depth+1);if(inner)return sibling.copy(sibling.content.replaceChild(sibling.childCount-1,inner));let match=sibling.contentMatchAt(sibling.childCount);if(match.matchType(depth==wrap.length-1?node.type:wrap[depth+1]))return sibling.copy(sibling.content.append(Fragment$2.from(withWrappers$2(node,wrap,depth+1))))}}function closeRight$2(node,depth){if(0==depth)return node;let fragment=node.content.replaceChild(node.childCount-1,closeRight$2(node.lastChild,depth-1)),fill=node.contentMatchAt(node.childCount).fillBefore(Fragment$2.empty,!0);return node.copy(fragment.append(fill))}function closeRange$2(fragment,side,from,to,depth,openEnd){let node=side<0?fragment.firstChild:fragment.lastChild,inner=node.content;return depth<to-1&&(inner=closeRange$2(inner,side,from,to,depth+1,openEnd)),depth>=from&&(inner=side<0?node.contentMatchAt(0).fillBefore(inner,fragment.childCount>1||openEnd<=depth).append(inner):inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment$2.empty,!0))),fragment.replaceChild(side<0?0:fragment.childCount-1,node.copy(inner))}function closeSlice$2(slice,openStart,openEnd){return openStart<slice.openStart&&(slice=new Slice$2(closeRange$2(slice.content,-1,openStart,slice.openStart,0,slice.openEnd),openStart,slice.openEnd)),openEnd<slice.openEnd&&(slice=new Slice$2(closeRange$2(slice.content,1,openEnd,slice.openEnd,0,0),slice.openStart,openEnd)),slice}
// Trick from jQuery -- some elements must be wrapped in other
// elements for innerHTML to work. I.e. if you do `div.innerHTML =
// "<td>..</td>"` the table cells are ignored.
const wrapMap$2={thead:["table"],tbody:["table"],tfoot:["table"],caption:["table"],colgroup:["table"],col:["table","colgroup"],tr:["table","tbody"],td:["table","tbody","tr"],th:["table","tbody","tr"]};let _detachedDoc$2=null;function detachedDoc$2(){return _detachedDoc$2||(_detachedDoc$2=document.implementation.createHTMLDocument("title"))}function readHTML$2(html){let metas=/^(\s*<meta [^>]*>)*/.exec(html);metas&&(html=html.slice(metas[0].length));let wrap,elt=detachedDoc$2().createElement("div"),firstTag=/<([a-z][^>\s]+)/i.exec(html);if((wrap=firstTag&&wrapMap$2[firstTag[1].toLowerCase()])&&(html=wrap.map((n=>"<"+n+">")).join("")+html+wrap.map((n=>"</"+n+">")).reverse().join("")),elt.innerHTML=html,wrap)for(let i=0;i<wrap.length;i++)elt=elt.querySelector(wrap[i])||elt;return elt}
// Webkit browsers do some hard-to-predict replacement of regular
// spaces with non-breaking spaces when putting content on the
// clipboard. This tries to convert such non-breaking spaces (which
// will be wrapped in a plain span on Chrome, a span with class
// Apple-converted-space on Safari) back to regular spaces.
function restoreReplacedSpaces$2(dom){let nodes=dom.querySelectorAll(chrome$1$2?"span:not([class]):not([style])":"span.Apple-converted-space");for(let i=0;i<nodes.length;i++){let node=nodes[i];1==node.childNodes.length&&" "==node.textContent&&node.parentNode&&node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "),node)}}function addContext$2(slice,context){if(!slice.size)return slice;let array,schema=slice.content.firstChild.type.schema;try{array=JSON.parse(context)}catch(e){return slice}let{content:content,openStart:openStart,openEnd:openEnd}=slice;for(let i=array.length-2;i>=0;i-=2){let type=schema.nodes[array[i]];if(!type||type.hasRequiredAttrs())break;content=Fragment$2.from(type.create(array[i+1],content)),openStart++,openEnd++}return new Slice$2(content,openStart,openEnd)}
// A collection of DOM events that occur within the editor, and callback functions
// to invoke when the event fires.
const handlers$2={};let editHandlers$2={};function setSelectionOrigin$2(view,origin){view.input.lastSelectionOrigin=origin,view.input.lastSelectionTime=Date.now()}function eventCoords$2(event){return{left:event.clientX,top:event.clientY}}function isNear$2(event,click){let dx=click.x-event.clientX,dy=click.y-event.clientY;return dx*dx+dy*dy<100}function runHandlerOnContext$2(view,propName,pos,inside,event){if(-1==inside)return!1;let $pos=view.state.doc.resolve(inside);for(let i=$pos.depth+1;i>0;i--)if(view.someProp(propName,(f=>i>$pos.depth?f(view,pos,$pos.nodeAfter,$pos.before(i),event,!0):f(view,pos,$pos.node(i),$pos.before(i),event,!1))))return!0;return!1}function updateSelection$2(view,selection,origin){view.focused||view.focus();let tr=view.state.tr.setSelection(selection);"pointer"==origin&&tr.setMeta("pointer",!0),view.dispatch(tr)}function selectClickedLeaf$2(view,inside){if(-1==inside)return!1;let $pos=view.state.doc.resolve(inside),node=$pos.nodeAfter;return!!(node&&node.isAtom&&NodeSelection$2.isSelectable(node))&&(updateSelection$2(view,new NodeSelection$2($pos),"pointer"),!0)}function selectClickedNode$2(view,inside){if(-1==inside)return!1;let selectedNode,selectAt,sel=view.state.selection;sel instanceof NodeSelection$2&&(selectedNode=sel.node);let $pos=view.state.doc.resolve(inside);for(let i=$pos.depth+1;i>0;i--){let node=i>$pos.depth?$pos.nodeAfter:$pos.node(i);if(NodeSelection$2.isSelectable(node)){selectAt=selectedNode&&sel.$from.depth>0&&i>=sel.$from.depth&&$pos.before(sel.$from.depth+1)==sel.$from.pos?$pos.before(sel.$from.depth):$pos.before(i);break}}return null!=selectAt&&(updateSelection$2(view,NodeSelection$2.create(view.state.doc,selectAt),"pointer"),!0)}function handleSingleClick$2(view,pos,inside,event,selectNode){return runHandlerOnContext$2(view,"handleClickOn",pos,inside,event)||view.someProp("handleClick",(f=>f(view,pos,event)))||(selectNode?selectClickedNode$2(view,inside):selectClickedLeaf$2(view,inside))}function handleDoubleClick$2(view,pos,inside,event){return runHandlerOnContext$2(view,"handleDoubleClickOn",pos,inside,event)||view.someProp("handleDoubleClick",(f=>f(view,pos,event)))}function handleTripleClick$1$2(view,pos,inside,event){return runHandlerOnContext$2(view,"handleTripleClickOn",pos,inside,event)||view.someProp("handleTripleClick",(f=>f(view,pos,event)))||defaultTripleClick$2(view,inside,event)}function defaultTripleClick$2(view,inside,event){if(0!=event.button)return!1;let doc=view.state.doc;if(-1==inside)return!!doc.inlineContent&&(updateSelection$2(view,TextSelection$2.create(doc,0,doc.content.size),"pointer"),!0);let $pos=doc.resolve(inside);for(let i=$pos.depth+1;i>0;i--){let node=i>$pos.depth?$pos.nodeAfter:$pos.node(i),nodePos=$pos.before(i);if(node.inlineContent)updateSelection$2(view,TextSelection$2.create(doc,nodePos+1,nodePos+1+node.content.size),"pointer");else{if(!NodeSelection$2.isSelectable(node))continue;updateSelection$2(view,NodeSelection$2.create(doc,nodePos),"pointer")}return!0}}function forceDOMFlush$2(view){return endComposition$2(view)}editHandlers$2.keydown=(view,_event)=>{let event=_event;if(view.input.shiftKey=16==event.keyCode||event.shiftKey,!inOrNearComposition$2(view,event)&&(view.input.lastKeyCode=event.keyCode,view.input.lastKeyCodeTime=Date.now(),!android$2||!chrome$1$2||13!=event.keyCode))
// On iOS, if we preventDefault enter key presses, the virtual
// keyboard gets confused. So the hack here is to set a flag that
// makes the DOM change code recognize that what just happens should
// be replaced by whatever the Enter key handlers do.
if(229!=event.keyCode&&view.domObserver.forceFlush(),!ios$2||13!=event.keyCode||event.ctrlKey||event.altKey||event.metaKey)view.someProp("handleKeyDown",(f=>f(view,event)))||captureKeyDown$2(view,event)?event.preventDefault():setSelectionOrigin$2(view,"key");else{let now=Date.now();view.input.lastIOSEnter=now,view.input.lastIOSEnterFallbackTimeout=setTimeout((()=>{view.input.lastIOSEnter==now&&(view.someProp("handleKeyDown",(f=>f(view,keyEvent$2(13,"Enter")))),view.input.lastIOSEnter=0)}),200)}},editHandlers$2.keyup=(view,event)=>{16==event.keyCode&&(view.input.shiftKey=!1)},editHandlers$2.keypress=(view,_event)=>{let event=_event;if(inOrNearComposition$2(view,event)||!event.charCode||event.ctrlKey&&!event.altKey||mac$2$2&&event.metaKey)return;if(view.someProp("handleKeyPress",(f=>f(view,event))))return void event.preventDefault();let sel=view.state.selection;if(!(sel instanceof TextSelection$2)||!sel.$from.sameParent(sel.$to)){let text=String.fromCharCode(event.charCode);view.someProp("handleTextInput",(f=>f(view,sel.$from.pos,sel.$to.pos,text)))||view.dispatch(view.state.tr.insertText(text).scrollIntoView()),event.preventDefault()}};const selectNodeModifier$2=mac$2$2?"metaKey":"ctrlKey";handlers$2.mousedown=(view,_event)=>{let event=_event;view.input.shiftKey=event.shiftKey;let flushed=forceDOMFlush$2(view),now=Date.now(),type="singleClick";now-view.input.lastClick.time<500&&isNear$2(event,view.input.lastClick)&&!event[selectNodeModifier$2]&&("singleClick"==view.input.lastClick.type?type="doubleClick":"doubleClick"==view.input.lastClick.type&&(type="tripleClick")),view.input.lastClick={time:now,x:event.clientX,y:event.clientY,type:type};let pos=view.posAtCoords(eventCoords$2(event));pos&&("singleClick"==type?(view.input.mouseDown&&view.input.mouseDown.done(),view.input.mouseDown=new MouseDown$2(view,pos,event,!!flushed)):("doubleClick"==type?handleDoubleClick$2:handleTripleClick$1$2)(view,pos.pos,pos.inside,event)?event.preventDefault():setSelectionOrigin$2(view,"pointer"))};class MouseDown$2{constructor(view,pos,event,flushed){let targetNode,targetPos;if(this.view=view,this.pos=pos,this.event=event,this.flushed=flushed,this.delayedSelectionSync=!1,this.mightDrag=null,this.startDoc=view.state.doc,this.selectNode=!!event[selectNodeModifier$2],this.allowDefault=event.shiftKey,pos.inside>-1)targetNode=view.state.doc.nodeAt(pos.inside),targetPos=pos.inside;else{let $pos=view.state.doc.resolve(pos.pos);targetNode=$pos.parent,targetPos=$pos.depth?$pos.before():0}const target=flushed?null:event.target,targetDesc=target?view.docView.nearestDesc(target,!0):null;this.target=targetDesc?targetDesc.dom:null;let{selection:selection}=view.state;(0==event.button&&targetNode.type.spec.draggable&&!1!==targetNode.type.spec.selectable||selection instanceof NodeSelection$2&&selection.from<=targetPos&&selection.to>targetPos)&&(this.mightDrag={node:targetNode,pos:targetPos,addAttr:!(!this.target||this.target.draggable),setUneditable:!(!this.target||!gecko$2||this.target.hasAttribute("contentEditable"))}),this.target&&this.mightDrag&&(this.mightDrag.addAttr||this.mightDrag.setUneditable)&&(this.view.domObserver.stop(),this.mightDrag.addAttr&&(this.target.draggable=!0),this.mightDrag.setUneditable&&setTimeout((()=>{this.view.input.mouseDown==this&&this.target.setAttribute("contentEditable","false")}),20),this.view.domObserver.start()),view.root.addEventListener("mouseup",this.up=this.up.bind(this)),view.root.addEventListener("mousemove",this.move=this.move.bind(this)),setSelectionOrigin$2(view,"pointer")}done(){this.view.root.removeEventListener("mouseup",this.up),this.view.root.removeEventListener("mousemove",this.move),this.mightDrag&&this.target&&(this.view.domObserver.stop(),this.mightDrag.addAttr&&this.target.removeAttribute("draggable"),this.mightDrag.setUneditable&&this.target.removeAttribute("contentEditable"),this.view.domObserver.start()),this.delayedSelectionSync&&setTimeout((()=>selectionToDOM$2(this.view))),this.view.input.mouseDown=null}up(event){if(this.done(),!this.view.dom.contains(event.target))return;let pos=this.pos;this.view.state.doc!=this.startDoc&&(pos=this.view.posAtCoords(eventCoords$2(event))),this.allowDefault||!pos?setSelectionOrigin$2(this.view,"pointer"):handleSingleClick$2(this.view,pos.pos,pos.inside,event,this.selectNode)?event.preventDefault():0==event.button&&(this.flushed||
// Safari ignores clicks on draggable elements
safari$2&&this.mightDrag&&!this.mightDrag.node.isAtom||
// Chrome will sometimes treat a node selection as a
// cursor, but still report that the node is selected
// when asked through getSelection. You'll then get a
// situation where clicking at the point where that
// (hidden) cursor is doesn't change the selection, and
// thus doesn't get a reaction from ProseMirror. This
// works around that.
chrome$1$2&&!(this.view.state.selection instanceof TextSelection$2)&&Math.min(Math.abs(pos.pos-this.view.state.selection.from),Math.abs(pos.pos-this.view.state.selection.to))<=2)?(updateSelection$2(this.view,Selection$2.near(this.view.state.doc.resolve(pos.pos)),"pointer"),event.preventDefault()):setSelectionOrigin$2(this.view,"pointer")}move(event){!this.allowDefault&&(Math.abs(this.event.x-event.clientX)>4||Math.abs(this.event.y-event.clientY)>4)&&(this.allowDefault=!0),setSelectionOrigin$2(this.view,"pointer"),0==event.buttons&&this.done()}}function inOrNearComposition$2(view,event){return!!view.composing||
// See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
// On Japanese input method editors (IMEs), the Enter key is used to confirm character
// selection. On Safari, when Enter is pressed, compositionend and keydown events are
// emitted. The keydown event triggers newline insertion, which we don't want.
// This method returns true if the keydown event should be ignored.
// We only ignore it once, as pressing Enter a second time *should* insert a newline.
// Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.
// This guards against the case where compositionend is triggered without the keyboard
// (e.g. character confirmation may be done with the mouse), and keydown is triggered
// afterwards- we wouldn't want to ignore the keydown event in this case.
!!(safari$2&&Math.abs(event.timeStamp-view.input.compositionEndedAt)<500)&&(view.input.compositionEndedAt=-2e8,!0)}
// Drop active composition after 5 seconds of inactivity on Android
handlers$2.touchdown=view=>{forceDOMFlush$2(view),setSelectionOrigin$2(view,"pointer")},handlers$2.contextmenu=view=>forceDOMFlush$2(view);const timeoutComposition$2=android$2?5e3:-1;function scheduleComposeEnd$2(view,delay){clearTimeout(view.input.composingTimeout),delay>-1&&(view.input.composingTimeout=setTimeout((()=>endComposition$2(view)),delay))}function clearComposition$2(view){view.composing&&(view.input.composing=!1,view.input.compositionEndedAt=timestampFromCustomEvent$2());while(view.input.compositionNodes.length>0)view.input.compositionNodes.pop().markParentsDirty()}function timestampFromCustomEvent$2(){let event=document.createEvent("Event");return event.initEvent("event",!0,!0),event.timeStamp}
/**
@internal
*/function endComposition$2(view,forceUpdate=!1){if(!(android$2&&view.domObserver.flushingSoon>=0)){if(view.domObserver.forceFlush(),clearComposition$2(view),forceUpdate||view.docView&&view.docView.dirty){let sel=selectionFromDOM$2(view);return sel&&!sel.eq(view.state.selection)?view.dispatch(view.state.tr.setSelection(sel)):view.updateState(view.state),!0}return!1}}function captureCopy$2(view,dom){
// The extra wrapper is somehow necessary on IE/Edge to prevent the
// content from being mangled when it is put onto the clipboard
if(!view.dom.parentNode)return;let wrap=view.dom.parentNode.appendChild(document.createElement("div"));wrap.appendChild(dom),wrap.style.cssText="position: fixed; left: -10000px; top: 10px";let sel=getSelection(),range=document.createRange();range.selectNodeContents(dom),
// Done because IE will fire a selectionchange moving the selection
// to its start when removeAllRanges is called and the editor still
// has focus (which will mess up the editor's selection state).
view.dom.blur(),sel.removeAllRanges(),sel.addRange(range),setTimeout((()=>{wrap.parentNode&&wrap.parentNode.removeChild(wrap),view.focus()}),50)}
// This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard API—all the objects and methods are
// there, they just don't work, and they are hard to test.
editHandlers$2.compositionstart=editHandlers$2.compositionupdate=view=>{if(!view.composing){view.domObserver.flush();let{state:state}=view,$pos=state.selection.$from;if(state.selection.empty&&(state.storedMarks||!$pos.textOffset&&$pos.parentOffset&&$pos.nodeBefore.marks.some((m=>!1===m.type.spec.inclusive))))
// Need to wrap the cursor in mark nodes different from the ones in the DOM context
view.markCursor=view.state.storedMarks||$pos.marks(),endComposition$2(view,!0),view.markCursor=null;else
// In firefox, if the cursor is after but outside a marked node,
// the inserted text won't inherit the marks. So this moves it
// inside if necessary.
if(endComposition$2(view),gecko$2&&state.selection.empty&&$pos.parentOffset&&!$pos.textOffset&&$pos.nodeBefore.marks.length){let sel=view.domSelection();for(let node=sel.focusNode,offset=sel.focusOffset;node&&1==node.nodeType&&0!=offset;){let before=offset<0?node.lastChild:node.childNodes[offset-1];if(!before)break;if(3==before.nodeType){sel.collapse(before,before.nodeValue.length);break}node=before,offset=-1}}view.input.composing=!0}scheduleComposeEnd$2(view,timeoutComposition$2)},editHandlers$2.compositionend=(view,event)=>{view.composing&&(view.input.composing=!1,view.input.compositionEndedAt=event.timeStamp,scheduleComposeEnd$2(view,20))};const brokenClipboardAPI$2=ie$1$2&&ie_version$2<15||ios$2&&webkit_version$2<604;function sliceSingleNode$2(slice){return 0==slice.openStart&&0==slice.openEnd&&1==slice.content.childCount?slice.content.firstChild:null}function capturePaste$2(view,event){if(!view.dom.parentNode)return;let plainText=view.input.shiftKey||view.state.selection.$from.parent.type.spec.code,target=view.dom.parentNode.appendChild(document.createElement(plainText?"textarea":"div"));plainText||(target.contentEditable="true"),target.style.cssText="position: fixed; left: -10000px; top: 10px",target.focus(),setTimeout((()=>{view.focus(),target.parentNode&&target.parentNode.removeChild(target),plainText?doPaste$2(view,target.value,null,event):doPaste$2(view,target.textContent,target.innerHTML,event)}),50)}function doPaste$2(view,text,html,event){let slice=parseFromClipboard$2(view,text,html,view.input.shiftKey,view.state.selection.$from);if(view.someProp("handlePaste",(f=>f(view,event,slice||Slice$2.empty))))return!0;if(!slice)return!1;let singleNode=sliceSingleNode$2(slice),tr=singleNode?view.state.tr.replaceSelectionWith(singleNode,view.input.shiftKey):view.state.tr.replaceSelection(slice);return view.dispatch(tr.scrollIntoView().setMeta("paste",!0).setMeta("uiEvent","paste")),!0}handlers$2.copy=editHandlers$2.cut=(view,_event)=>{let event=_event,sel=view.state.selection,cut="cut"==event.type;if(sel.empty)return;
// IE and Edge's clipboard interface is completely broken
let data=brokenClipboardAPI$2?null:event.clipboardData,slice=sel.content(),{dom:dom,text:text}=serializeForClipboard$2(view,slice);data?(event.preventDefault(),data.clearData(),data.setData("text/html",dom.innerHTML),data.setData("text/plain",text)):captureCopy$2(view,dom),cut&&view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent","cut"))},editHandlers$2.paste=(view,_event)=>{let event=_event;
// Handling paste from JavaScript during composition is very poorly
// handled by browsers, so as a dodgy but preferable kludge, we just
// let the browser do its native thing there, except on Android,
// where the editor is almost always composing.
if(view.composing&&!android$2)return;let data=brokenClipboardAPI$2?null:event.clipboardData;data&&doPaste$2(view,data.getData("text/plain"),data.getData("text/html"),event)?event.preventDefault():capturePaste$2(view,event)};class Dragging$2{constructor(slice,move){this.slice=slice,this.move=move}}const dragCopyModifier$2=mac$2$2?"altKey":"ctrlKey";handlers$2.dragstart=(view,_event)=>{let event=_event,mouseDown=view.input.mouseDown;if(mouseDown&&mouseDown.done(),!event.dataTransfer)return;let sel=view.state.selection,pos=sel.empty?null:view.posAtCoords(eventCoords$2(event));if(pos&&pos.pos>=sel.from&&pos.pos<=(sel instanceof NodeSelection$2?sel.to-1:sel.to));else if(mouseDown&&mouseDown.mightDrag)view.dispatch(view.state.tr.setSelection(NodeSelection$2.create(view.state.doc,mouseDown.mightDrag.pos)));else if(event.target&&1==event.target.nodeType){let desc=view.docView.nearestDesc(event.target,!0);desc&&desc.node.type.spec.draggable&&desc!=view.docView&&view.dispatch(view.state.tr.setSelection(NodeSelection$2.create(view.state.doc,desc.posBefore)))}let slice=view.state.selection.content(),{dom:dom,text:text}=serializeForClipboard$2(view,slice);event.dataTransfer.clearData(),event.dataTransfer.setData(brokenClipboardAPI$2?"Text":"text/html",dom.innerHTML),
// See https://github.com/ProseMirror/prosemirror/issues/1156
event.dataTransfer.effectAllowed="copyMove",brokenClipboardAPI$2||event.dataTransfer.setData("text/plain",text),view.dragging=new Dragging$2(slice,!event[dragCopyModifier$2])},handlers$2.dragend=view=>{let dragging=view.dragging;window.setTimeout((()=>{view.dragging==dragging&&(view.dragging=null)}),50)},editHandlers$2.dragover=editHandlers$2.dragenter=(_,e)=>e.preventDefault(),editHandlers$2.drop=(view,_event)=>{let event=_event,dragging=view.dragging;if(view.dragging=null,!event.dataTransfer)return;let eventPos=view.posAtCoords(eventCoords$2(event));if(!eventPos)return;let $mouse=view.state.doc.resolve(eventPos.pos);if(!$mouse)return;let slice=dragging&&dragging.slice;slice?view.someProp("transformPasted",(f=>{slice=f(slice)})):slice=parseFromClipboard$2(view,event.dataTransfer.getData(brokenClipboardAPI$2?"Text":"text/plain"),brokenClipboardAPI$2?null:event.dataTransfer.getData("text/html"),!1,$mouse);let move=!(!dragging||event[dragCopyModifier$2]);if(view.someProp("handleDrop",(f=>f(view,event,slice||Slice$2.empty,move))))return void event.preventDefault();if(!slice)return;event.preventDefault();let insertPos=slice?dropPoint$2(view.state.doc,$mouse.pos,slice):$mouse.pos;null==insertPos&&(insertPos=$mouse.pos);let tr=view.state.tr;move&&tr.deleteSelection();let pos=tr.mapping.map(insertPos),isNode=0==slice.openStart&&0==slice.openEnd&&1==slice.content.childCount,beforeInsert=tr.doc;if(isNode?tr.replaceRangeWith(pos,pos,slice.content.firstChild):tr.replaceRange(pos,pos,slice),tr.doc.eq(beforeInsert))return;let $pos=tr.doc.resolve(pos);if(isNode&&NodeSelection$2.isSelectable(slice.content.firstChild)&&$pos.nodeAfter&&$pos.nodeAfter.sameMarkup(slice.content.firstChild))tr.setSelection(new NodeSelection$2($pos));else{let end=tr.mapping.map(insertPos);tr.mapping.maps[tr.mapping.maps.length-1].forEach(((_from,_to,_newFrom,newTo)=>end=newTo)),tr.setSelection(selectionBetween$2(view,$pos,tr.doc.resolve(end)))}view.focus(),view.dispatch(tr.setMeta("uiEvent","drop"))},handlers$2.focus=view=>{view.focused||(view.domObserver.stop(),view.dom.classList.add("ProseMirror-focused"),view.domObserver.start(),view.focused=!0,setTimeout((()=>{view.docView&&view.hasFocus()&&!view.domObserver.currentSelection.eq(view.domSelection())&&selectionToDOM$2(view)}),20))},handlers$2.blur=(view,_event)=>{let event=_event;view.focused&&(view.domObserver.stop(),view.dom.classList.remove("ProseMirror-focused"),view.domObserver.start(),event.relatedTarget&&view.dom.contains(event.relatedTarget)&&view.domObserver.currentSelection.clear(),view.focused=!1)},handlers$2.beforeinput=(view,_event)=>{let event=_event;
// We should probably do more with beforeinput events, but support
// is so spotty that I'm still waiting to see where they are going.
// Very specific hack to deal with backspace sometimes failing on
// Chrome Android when after an uneditable node.
if(chrome$1$2&&android$2&&"deleteContentBackward"==event.inputType){view.domObserver.flushSoon();let{domChangeCount:domChangeCount}=view.input;setTimeout((()=>{if(view.input.domChangeCount!=domChangeCount)return;// Event already had some effect
// This bug tends to close the virtual keyboard, so we refocus
if(view.dom.blur(),view.focus(),view.someProp("handleKeyDown",(f=>f(view,keyEvent$2(8,"Backspace")))))return;let{$cursor:$cursor}=view.state.selection;
// Crude approximation of backspace behavior when no command handled it
$cursor&&$cursor.pos>0&&view.dispatch(view.state.tr.delete($cursor.pos-1,$cursor.pos).scrollIntoView())}),50)}};
// Make sure all handlers get registered
for(let prop in editHandlers$2)handlers$2[prop]=editHandlers$2[prop];function compareObjs$2(a,b){if(a==b)return!0;for(let p in a)if(a[p]!==b[p])return!1;for(let p in b)if(!(p in a))return!1;return!0}class WidgetType$2{constructor(toDOM,spec){this.toDOM=toDOM,this.spec=spec||noSpec$2,this.side=this.spec.side||0}map(mapping,span,offset,oldOffset){let{pos:pos,deleted:deleted}=mapping.mapResult(span.from+oldOffset,this.side<0?-1:1);return deleted?null:new Decoration$2(pos-offset,pos-offset,this)}valid(){return!0}eq(other){return this==other||other instanceof WidgetType$2&&(this.spec.key&&this.spec.key==other.spec.key||this.toDOM==other.toDOM&&compareObjs$2(this.spec,other.spec))}destroy(node){this.spec.destroy&&this.spec.destroy(node)}}class InlineType$2{constructor(attrs,spec){this.attrs=attrs,this.spec=spec||noSpec$2}map(mapping,span,offset,oldOffset){let from=mapping.map(span.from+oldOffset,this.spec.inclusiveStart?-1:1)-offset,to=mapping.map(span.to+oldOffset,this.spec.inclusiveEnd?1:-1)-offset;return from>=to?null:new Decoration$2(from,to,this)}valid(_,span){return span.from<span.to}eq(other){return this==other||other instanceof InlineType$2&&compareObjs$2(this.attrs,other.attrs)&&compareObjs$2(this.spec,other.spec)}static is(span){return span.type instanceof InlineType$2}destroy(){}}class NodeType$3{constructor(attrs,spec){this.attrs=attrs,this.spec=spec||noSpec$2}map(mapping,span,offset,oldOffset){let from=mapping.mapResult(span.from+oldOffset,1);if(from.deleted)return null;let to=mapping.mapResult(span.to+oldOffset,-1);return to.deleted||to.pos<=from.pos?null:new Decoration$2(from.pos-offset,to.pos-offset,this)}valid(node,span){let child,{index:index,offset:offset}=node.content.findIndex(span.from);return offset==span.from&&!(child=node.child(index)).isText&&offset+child.nodeSize==span.to}eq(other){return this==other||other instanceof NodeType$3&&compareObjs$2(this.attrs,other.attrs)&&compareObjs$2(this.spec,other.spec)}destroy(){}}
/**
Decoration objects can be provided to the view through the
[`decorations` prop](https://prosemirror.net/docs/ref/#view.EditorProps.decorations). They come in
several variants—see the static members of this class for details.
*/class Decoration$2{
/**
    @internal
    */
constructor(
/**
    The start position of the decoration.
    */
from,
/**
    The end position. Will be the same as `from` for [widget
    decorations](https://prosemirror.net/docs/ref/#view.Decoration^widget).
    */
to,
/**
    @internal
    */
type){this.from=from,this.to=to,this.type=type}
/**
    @internal
    */copy(from,to){return new Decoration$2(from,to,this.type)}
/**
    @internal
    */eq(other,offset=0){return this.type.eq(other.type)&&this.from+offset==other.from&&this.to+offset==other.to}
/**
    @internal
    */map(mapping,offset,oldOffset){return this.type.map(mapping,this,offset,oldOffset)}
/**
    Creates a widget decoration, which is a DOM node that's shown in
    the document at the given position. It is recommended that you
    delay rendering the widget by passing a function that will be
    called when the widget is actually drawn in a view, but you can
    also directly pass a DOM node. `getPos` can be used to find the
    widget's current document position.
    */static widget(pos,toDOM,spec){return new Decoration$2(pos,pos,new WidgetType$2(toDOM,spec))}
/**
    Creates an inline decoration, which adds the given attributes to
    each inline node between `from` and `to`.
    */static inline(from,to,attrs,spec){return new Decoration$2(from,to,new InlineType$2(attrs,spec))}
/**
    Creates a node decoration. `from` and `to` should point precisely
    before and after a node in the document. That node, and only that
    node, will receive the given attributes.
    */static node(from,to,attrs,spec){return new Decoration$2(from,to,new NodeType$3(attrs,spec))}
/**
    The spec provided when creating this decoration. Can be useful
    if you've stored extra information in that object.
    */get spec(){return this.type.spec}
/**
    @internal
    */get inline(){return this.type instanceof InlineType$2}}const none$2=[],noSpec$2={};
/**
A collection of [decorations](https://prosemirror.net/docs/ref/#view.Decoration), organized in such
a way that the drawing algorithm can efficiently use and compare
them. This is a persistent data structure—it is not modified,
updates create a new value.
*/class DecorationSet$2{
/**
    @internal
    */
constructor(local,children){this.local=local.length?local:none$2,this.children=children.length?children:none$2}
/**
    Create a set of decorations, using the structure of the given
    document.
    */static create(doc,decorations){return decorations.length?buildTree$2(decorations,doc,0,noSpec$2):empty$2}
/**
    Find all decorations in this set which touch the given range
    (including decorations that start or end directly at the
    boundaries) and match the given predicate on their spec. When
    `start` and `end` are omitted, all decorations in the set are
    considered. When `predicate` isn't given, all decorations are
    assumed to match.
    */find(start,end,predicate){let result=[];return this.findInner(null==start?0:start,null==end?1e9:end,result,0,predicate),result}findInner(start,end,result,offset,predicate){for(let i=0;i<this.local.length;i++){let span=this.local[i];span.from<=end&&span.to>=start&&(!predicate||predicate(span.spec))&&result.push(span.copy(span.from+offset,span.to+offset))}for(let i=0;i<this.children.length;i+=3)if(this.children[i]<end&&this.children[i+1]>start){let childOff=this.children[i]+1;this.children[i+2].findInner(start-childOff,end-childOff,result,offset+childOff,predicate)}}
/**
    Map the set of decorations in response to a change in the
    document.
    */map(mapping,doc,options){return this==empty$2||0==mapping.maps.length?this:this.mapInner(mapping,doc,0,0,options||noSpec$2)}
/**
    @internal
    */mapInner(mapping,node,offset,oldOffset,options){let newLocal;for(let i=0;i<this.local.length;i++){let mapped=this.local[i].map(mapping,offset,oldOffset);mapped&&mapped.type.valid(node,mapped)?(newLocal||(newLocal=[])).push(mapped):options.onRemove&&options.onRemove(this.local[i].spec)}return this.children.length?mapChildren$2(this.children,newLocal||[],mapping,node,offset,oldOffset,options):newLocal?new DecorationSet$2(newLocal.sort(byPos$2),none$2):empty$2}
/**
    Add the given array of decorations to the ones in the set,
    producing a new set. Needs access to the current document to
    create the appropriate tree structure.
    */add(doc,decorations){return decorations.length?this==empty$2?DecorationSet$2.create(doc,decorations):this.addInner(doc,decorations,0):this}addInner(doc,decorations,offset){let children,childIndex=0;doc.forEach(((childNode,childOffset)=>{let found,baseOffset=childOffset+offset;if(found=takeSpansForNode$2(decorations,childNode,baseOffset)){children||(children=this.children.slice());while(childIndex<children.length&&children[childIndex]<childOffset)childIndex+=3;children[childIndex]==childOffset?children[childIndex+2]=children[childIndex+2].addInner(childNode,found,baseOffset+1):children.splice(childIndex,0,childOffset,childOffset+childNode.nodeSize,buildTree$2(found,childNode,baseOffset+1,noSpec$2)),childIndex+=3}}));let local=moveSpans$2(childIndex?withoutNulls$2(decorations):decorations,-offset);for(let i=0;i<local.length;i++)local[i].type.valid(doc,local[i])||local.splice(i--,1);return new DecorationSet$2(local.length?this.local.concat(local).sort(byPos$2):this.local,children||this.children)}
/**
    Create a new set that contains the decorations in this set, minus
    the ones in the given array.
    */remove(decorations){return 0==decorations.length||this==empty$2?this:this.removeInner(decorations,0)}removeInner(decorations,offset){let children=this.children,local=this.local;for(let i=0;i<children.length;i+=3){let found,from=children[i]+offset,to=children[i+1]+offset;for(let span,j=0;j<decorations.length;j++)(span=decorations[j])&&span.from>from&&span.to<to&&(decorations[j]=null,(found||(found=[])).push(span));if(!found)continue;children==this.children&&(children=this.children.slice());let removed=children[i+2].removeInner(found,from+1);removed!=empty$2?children[i+2]=removed:(children.splice(i,3),i-=3)}if(local.length)for(let span,i=0;i<decorations.length;i++)if(span=decorations[i])for(let j=0;j<local.length;j++)local[j].eq(span,offset)&&(local==this.local&&(local=this.local.slice()),local.splice(j--,1));return children==this.children&&local==this.local?this:local.length||children.length?new DecorationSet$2(local,children):empty$2}
/**
    @internal
    */forChild(offset,node){if(this==empty$2)return this;if(node.isLeaf)return DecorationSet$2.empty;let child,local;for(let i=0;i<this.children.length;i+=3)if(this.children[i]>=offset){this.children[i]==offset&&(child=this.children[i+2]);break}let start=offset+1,end=start+node.content.size;for(let i=0;i<this.local.length;i++){let dec=this.local[i];if(dec.from<end&&dec.to>start&&dec.type instanceof InlineType$2){let from=Math.max(start,dec.from)-start,to=Math.min(end,dec.to)-start;from<to&&(local||(local=[])).push(dec.copy(from,to))}}if(local){let localSet=new DecorationSet$2(local.sort(byPos$2),none$2);return child?new DecorationGroup$2([localSet,child]):localSet}return child||empty$2}
/**
    @internal
    */eq(other){if(this==other)return!0;if(!(other instanceof DecorationSet$2)||this.local.length!=other.local.length||this.children.length!=other.children.length)return!1;for(let i=0;i<this.local.length;i++)if(!this.local[i].eq(other.local[i]))return!1;for(let i=0;i<this.children.length;i+=3)if(this.children[i]!=other.children[i]||this.children[i+1]!=other.children[i+1]||!this.children[i+2].eq(other.children[i+2]))return!1;return!0}
/**
    @internal
    */locals(node){return removeOverlap$2(this.localsInner(node))}
/**
    @internal
    */localsInner(node){if(this==empty$2)return none$2;if(node.inlineContent||!this.local.some(InlineType$2.is))return this.local;let result=[];for(let i=0;i<this.local.length;i++)this.local[i].type instanceof InlineType$2||result.push(this.local[i]);return result}}
/**
The empty set of decorations.
*/DecorationSet$2.empty=new DecorationSet$2([],[]),
/**
@internal
*/
DecorationSet$2.removeOverlap=removeOverlap$2;const empty$2=DecorationSet$2.empty;
// An abstraction that allows the code dealing with decorations to
// treat multiple DecorationSet objects as if it were a single object
// with (a subset of) the same interface.
class DecorationGroup$2{constructor(members){this.members=members}map(mapping,doc){const mappedDecos=this.members.map((member=>member.map(mapping,doc,noSpec$2)));return DecorationGroup$2.from(mappedDecos)}forChild(offset,child){if(child.isLeaf)return DecorationSet$2.empty;let found=[];for(let i=0;i<this.members.length;i++){let result=this.members[i].forChild(offset,child);result!=empty$2&&(result instanceof DecorationGroup$2?found=found.concat(result.members):found.push(result))}return DecorationGroup$2.from(found)}eq(other){if(!(other instanceof DecorationGroup$2)||other.members.length!=this.members.length)return!1;for(let i=0;i<this.members.length;i++)if(!this.members[i].eq(other.members[i]))return!1;return!0}locals(node){let result,sorted=!0;for(let i=0;i<this.members.length;i++){let locals=this.members[i].localsInner(node);if(locals.length)if(result){sorted&&(result=result.slice(),sorted=!1);for(let j=0;j<locals.length;j++)result.push(locals[j])}else result=locals}return result?removeOverlap$2(sorted?result:result.sort(byPos$2)):none$2}
// Create a group for the given array of decoration sets, or return
// a single set when possible.
static from(members){switch(members.length){case 0:return empty$2;case 1:return members[0];default:return new DecorationGroup$2(members)}}}function mapChildren$2(oldChildren,newLocal,mapping,node,offset,oldOffset,options){let children=oldChildren.slice(),shift=(oldStart,oldEnd,newStart,newEnd)=>{for(let i=0;i<children.length;i+=3){let dSize,end=children[i+1];if(end<0||oldStart>end+oldOffset)continue;let start=children[i]+oldOffset;oldEnd>=start?children[i+1]=oldStart<=start?-2:-1:newStart>=offset&&(dSize=newEnd-newStart-(oldEnd-oldStart))&&(children[i]+=dSize,children[i+1]+=dSize)}};
// Mark the children that are directly touched by changes, and
// move those that are after the changes.
for(let i=0;i<mapping.maps.length;i++)mapping.maps[i].forEach(shift);
// Find the child nodes that still correspond to a single node,
// recursively call mapInner on them and update their positions.
let mustRebuild=!1;for(let i=0;i<children.length;i+=3)if(children[i+1]<0){// Touched nodes
if(-2==children[i+1]){mustRebuild=!0,children[i+1]=-1;continue}let from=mapping.map(oldChildren[i]+oldOffset),fromLocal=from-offset;if(fromLocal<0||fromLocal>=node.content.size){mustRebuild=!0;continue}
// Must read oldChildren because children was tagged with -1
let to=mapping.map(oldChildren[i+1]+oldOffset,-1),toLocal=to-offset,{index:index,offset:childOffset}=node.content.findIndex(fromLocal),childNode=node.maybeChild(index);if(childNode&&childOffset==fromLocal&&childOffset+childNode.nodeSize==toLocal){let mapped=children[i+2].mapInner(mapping,childNode,from+1,oldChildren[i]+oldOffset+1,options);mapped!=empty$2?(children[i]=fromLocal,children[i+1]=toLocal,children[i+2]=mapped):(children[i+1]=-2,mustRebuild=!0)}else mustRebuild=!0}
// Remaining children must be collected and rebuilt into the appropriate structure
if(mustRebuild){let decorations=mapAndGatherRemainingDecorations$2(children,oldChildren,newLocal,mapping,offset,oldOffset,options),built=buildTree$2(decorations,node,0,options);newLocal=built.local;for(let i=0;i<children.length;i+=3)children[i+1]<0&&(children.splice(i,3),i-=3);for(let i=0,j=0;i<built.children.length;i+=3){let from=built.children[i];while(j<children.length&&children[j]<from)j+=3;children.splice(j,0,built.children[i],built.children[i+1],built.children[i+2])}}return new DecorationSet$2(newLocal.sort(byPos$2),children)}function moveSpans$2(spans,offset){if(!offset||!spans.length)return spans;let result=[];for(let i=0;i<spans.length;i++){let span=spans[i];result.push(new Decoration$2(span.from+offset,span.to+offset,span.type))}return result}function mapAndGatherRemainingDecorations$2(children,oldChildren,decorations,mapping,offset,oldOffset,options){
// Gather all decorations from the remaining marked children
function gather(set,oldOffset){for(let i=0;i<set.local.length;i++){let mapped=set.local[i].map(mapping,offset,oldOffset);mapped?decorations.push(mapped):options.onRemove&&options.onRemove(set.local[i].spec)}for(let i=0;i<set.children.length;i+=3)gather(set.children[i+2],set.children[i]+oldOffset+1)}for(let i=0;i<children.length;i+=3)-1==children[i+1]&&gather(children[i+2],oldChildren[i]+oldOffset+1);return decorations}function takeSpansForNode$2(spans,node,offset){if(node.isLeaf)return null;let end=offset+node.nodeSize,found=null;for(let span,i=0;i<spans.length;i++)(span=spans[i])&&span.from>offset&&span.to<end&&((found||(found=[])).push(span),spans[i]=null);return found}function withoutNulls$2(array){let result=[];for(let i=0;i<array.length;i++)null!=array[i]&&result.push(array[i]);return result}
// Build up a tree that corresponds to a set of decorations. `offset`
// is a base offset that should be subtracted from the `from` and `to`
// positions in the spans (so that we don't have to allocate new spans
// for recursive calls).
function buildTree$2(spans,node,offset,options){let children=[],hasNulls=!1;node.forEach(((childNode,localStart)=>{let found=takeSpansForNode$2(spans,childNode,localStart+offset);if(found){hasNulls=!0;let subtree=buildTree$2(found,childNode,offset+localStart+1,options);subtree!=empty$2&&children.push(localStart,localStart+childNode.nodeSize,subtree)}}));let locals=moveSpans$2(hasNulls?withoutNulls$2(spans):spans,-offset).sort(byPos$2);for(let i=0;i<locals.length;i++)locals[i].type.valid(node,locals[i])||(options.onRemove&&options.onRemove(locals[i].spec),locals.splice(i--,1));return locals.length||children.length?new DecorationSet$2(locals,children):empty$2}
// Used to sort decorations so that ones with a low start position
// come first, and within a set with the same start position, those
// with an smaller end position come first.
function byPos$2(a,b){return a.from-b.from||a.to-b.to}
// Scan a sorted array of decorations for partially overlapping spans,
// and split those so that only fully overlapping spans are left (to
// make subsequent rendering easier). Will return the input array if
// no partially overlapping spans are found (the common case).
function removeOverlap$2(spans){let working=spans;for(let i=0;i<working.length-1;i++){let span=working[i];if(span.from!=span.to)for(let j=i+1;j<working.length;j++){let next=working[j];if(next.from!=span.from){next.from<span.to&&(working==spans&&(working=spans.slice()),
// The end of this one overlaps with a subsequent span. Split
// this one.
working[i]=span.copy(span.from,next.from),insertAhead$2(working,j,span.copy(next.from,span.to)));break}next.to!=span.to&&(working==spans&&(working=spans.slice()),
// Followed by a partially overlapping larger span. Split that
// span.
working[j]=next.copy(next.from,span.to),insertAhead$2(working,j+1,next.copy(span.to,next.to)))}}return working}function insertAhead$2(array,i,deco){while(i<array.length&&byPos$2(deco,array[i])>0)i++;array.splice(i,0,deco)}var base$2={8:"Backspace",9:"Tab",10:"Enter",12:"NumLock",13:"Enter",16:"Shift",17:"Control",18:"Alt",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",44:"PrintScreen",45:"Insert",46:"Delete",59:";",61:"=",91:"Meta",92:"Meta",106:"*",107:"+",108:",",109:"-",110:".",111:"/",144:"NumLock",145:"ScrollLock",160:"Shift",161:"Shift",162:"Control",163:"Control",164:"Alt",165:"Alt",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},shift$2$2={48:")",49:"!",50:"@",51:"#",52:"$",53:"%",54:"^",55:"&",56:"*",57:"(",59:":",61:"+",173:"_",186:":",187:"+",188:"<",189:"_",190:">",191:"?",192:"~",219:"{",220:"|",221:"}",222:'"'},chrome$3="undefined"!=typeof navigator&&/Chrome\/(\d+)/.exec(navigator.userAgent);"undefined"!=typeof navigator&&/Gecko\/\d+/.test(navigator.userAgent);
// Fill in the digit keys
for(var mac$1$2="undefined"!=typeof navigator&&/Mac/.test(navigator.platform),ie$3="undefined"!=typeof navigator&&/MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent),brokenModifierNames$2=mac$1$2||chrome$3&&+chrome$3[1]<57,i$3=0;i$3<10;i$3++)base$2[48+i$3]=base$2[96+i$3]=String(i$3);
// The function keys
for(i$3=1;i$3<=24;i$3++)base$2[i$3+111]="F"+i$3;
// And the alphabetic keys
for(i$3=65;i$3<=90;i$3++)base$2[i$3]=String.fromCharCode(i$3+32),shift$2$2[i$3]=String.fromCharCode(i$3);
// For each code that doesn't have a shift-equivalent, copy the base name
for(var code$2 in base$2)shift$2$2.hasOwnProperty(code$2)||(shift$2$2[code$2]=base$2[code$2]);function keyName$2(event){var ignoreKey=brokenModifierNames$2&&(event.ctrlKey||event.altKey||event.metaKey)||ie$3&&event.shiftKey&&event.key&&1==event.key.length||"Unidentified"==event.key,name=!ignoreKey&&event.key||(event.shiftKey?shift$2$2:base$2)[event.keyCode]||event.key||"Unidentified";
// Edge sometimes produces wrong names (Issue #3)
return"Esc"==name&&(name="Escape"),"Del"==name&&(name="Delete"),
// https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
"Left"==name&&(name="ArrowLeft"),"Up"==name&&(name="ArrowUp"),"Right"==name&&(name="ArrowRight"),"Down"==name&&(name="ArrowDown"),name}const mac$4="undefined"!=typeof navigator&&/Mac|iP(hone|[oa]d)/.test(navigator.platform);function normalizeKeyName$1$2(name){let alt,ctrl,shift,meta,parts=name.split(/-(?!$)/),result=parts[parts.length-1];"Space"==result&&(result=" ");for(let i=0;i<parts.length-1;i++){let mod=parts[i];if(/^(cmd|meta|m)$/i.test(mod))meta=!0;else if(/^a(lt)?$/i.test(mod))alt=!0;else if(/^(c|ctrl|control)$/i.test(mod))ctrl=!0;else if(/^s(hift)?$/i.test(mod))shift=!0;else{if(!/^mod$/i.test(mod))throw new Error("Unrecognized modifier name: "+mod);mac$4?meta=!0:ctrl=!0}}return alt&&(result="Alt-"+result),ctrl&&(result="Ctrl-"+result),meta&&(result="Meta-"+result),shift&&(result="Shift-"+result),result}function normalize$2(map){let copy=Object.create(null);for(let prop in map)copy[normalizeKeyName$1$2(prop)]=map[prop];return copy}function modifiers$2$2(name,event,shift){return event.altKey&&(name="Alt-"+name),event.ctrlKey&&(name="Ctrl-"+name),event.metaKey&&(name="Meta-"+name),!1!==shift&&event.shiftKey&&(name="Shift-"+name),name}
/**
Given a set of bindings (using the same format as
[`keymap`](https://prosemirror.net/docs/ref/#keymap.keymap)), return a [keydown
handler](https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyDown) that handles them.
*/function keydownHandler$2(bindings){let map=normalize$2(bindings);return function(view,event){let baseName,name=keyName$2(event),isChar=1==name.length&&" "!=name,direct=map[modifiers$2$2(name,event,!isChar)];if(direct&&direct(view.state,view.dispatch,view))return!0;if(isChar&&(event.shiftKey||event.altKey||event.metaKey||name.charCodeAt(0)>127)&&(baseName=base$2[event.keyCode])&&baseName!=name){
// Try falling back to the keyCode when there's a modifier
// active or the character produced isn't ASCII, and our table
// produces a different name from the the keyCode. See #668,
// #1060
let fromCode=map[modifiers$2$2(baseName,event,!0)];if(fromCode&&fromCode(view.state,view.dispatch,view))return!0}else if(isChar&&event.shiftKey){
// Otherwise, if shift is active, also try the binding with the
// Shift- prefix enabled. See #997
let withShift=map[modifiers$2$2(name,event,!0)];if(withShift&&withShift(view.state,view.dispatch,view))return!0}return!1}}
/**
Delete the selection, if there is one.
*/const deleteSelection$1$2=(state,dispatch)=>!state.selection.empty&&(dispatch&&dispatch(state.tr.deleteSelection().scrollIntoView()),!0),joinBackward$1$2=(state,dispatch,view)=>{let{$cursor:$cursor}=state.selection;if(!$cursor||(view?!view.endOfTextblock("backward",state):$cursor.parentOffset>0))return!1;let $cut=findCutBefore$2($cursor);
// If there is no node before this, try to lift
if(!$cut){let range=$cursor.blockRange(),target=range&&liftTarget$2(range);return null!=target&&(dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0)}let before=$cut.nodeBefore;
// Apply the joining algorithm
if(!before.type.spec.isolating&&deleteBarrier$2(state,$cut,dispatch))return!0;
// If the node below has no content and the node above is
// selectable, delete the node below and select the one above.
if(0==$cursor.parent.content.size&&(textblockAt$2(before,"end")||NodeSelection$2.isSelectable(before))){let delStep=replaceStep$2(state.doc,$cursor.before(),$cursor.after(),Slice$2.empty);if(delStep&&delStep.slice.size<delStep.to-delStep.from){if(dispatch){let tr=state.tr.step(delStep);tr.setSelection(textblockAt$2(before,"end")?Selection$2.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos,-1)),-1):NodeSelection$2.create(tr.doc,$cut.pos-before.nodeSize)),dispatch(tr.scrollIntoView())}return!0}}
// If the node before is an atom, delete it
return!(!before.isAtom||$cut.depth!=$cursor.depth-1)&&(dispatch&&dispatch(state.tr.delete($cut.pos-before.nodeSize,$cut.pos).scrollIntoView()),!0)};
/**
If the selection is empty and at the start of a textblock, try to
reduce the distance between that block and the one before it—if
there's a block directly before it that can be joined, join them.
If not, try to move the selected block closer to the next one in
the document structure by lifting it out of its parent or moving it
into a parent of the previous block. Will use the view for accurate
(bidi-aware) start-of-textblock detection if given.
*/function textblockAt$2(node,side,only=!1){for(let scan=node;scan;scan="start"==side?scan.firstChild:scan.lastChild){if(scan.isTextblock)return!0;if(only&&1!=scan.childCount)return!1}return!1}
/**
When the selection is empty and at the start of a textblock, select
the node before that textblock, if possible. This is intended to be
bound to keys like backspace, after
[`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward) or other deleting
commands, as a fall-back behavior when the schema doesn't allow
deletion at the selected point.
*/const selectNodeBackward$1$2=(state,dispatch,view)=>{let{$head:$head,empty:empty}=state.selection,$cut=$head;if(!empty)return!1;if($head.parent.isTextblock){if(view?!view.endOfTextblock("backward",state):$head.parentOffset>0)return!1;$cut=findCutBefore$2($head)}let node=$cut&&$cut.nodeBefore;return!(!node||!NodeSelection$2.isSelectable(node))&&(dispatch&&dispatch(state.tr.setSelection(NodeSelection$2.create(state.doc,$cut.pos-node.nodeSize)).scrollIntoView()),!0)};function findCutBefore$2($pos){if(!$pos.parent.type.spec.isolating)for(let i=$pos.depth-1;i>=0;i--){if($pos.index(i)>0)return $pos.doc.resolve($pos.before(i+1));if($pos.node(i).type.spec.isolating)break}return null}
/**
If the selection is empty and the cursor is at the end of a
textblock, try to reduce or remove the boundary between that block
and the one after it, either by joining them or by moving the other
block closer to this one in the tree structure. Will use the view
for accurate start-of-textblock detection if given.
*/const joinForward$1$2=(state,dispatch,view)=>{let{$cursor:$cursor}=state.selection;if(!$cursor||(view?!view.endOfTextblock("forward",state):$cursor.parentOffset<$cursor.parent.content.size))return!1;let $cut=findCutAfter$2($cursor);
// If there is no node after this, there's nothing to do
if(!$cut)return!1;let after=$cut.nodeAfter;
// Try the joining algorithm
if(deleteBarrier$2(state,$cut,dispatch))return!0;
// If the node above has no content and the node below is
// selectable, delete the node above and select the one below.
if(0==$cursor.parent.content.size&&(textblockAt$2(after,"start")||NodeSelection$2.isSelectable(after))){let delStep=replaceStep$2(state.doc,$cursor.before(),$cursor.after(),Slice$2.empty);if(delStep&&delStep.slice.size<delStep.to-delStep.from){if(dispatch){let tr=state.tr.step(delStep);tr.setSelection(textblockAt$2(after,"start")?Selection$2.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)),1):NodeSelection$2.create(tr.doc,tr.mapping.map($cut.pos))),dispatch(tr.scrollIntoView())}return!0}}
// If the next node is an atom, delete it
return!(!after.isAtom||$cut.depth!=$cursor.depth-1)&&(dispatch&&dispatch(state.tr.delete($cut.pos,$cut.pos+after.nodeSize).scrollIntoView()),!0)},selectNodeForward$1$2=(state,dispatch,view)=>{let{$head:$head,empty:empty}=state.selection,$cut=$head;if(!empty)return!1;if($head.parent.isTextblock){if(view?!view.endOfTextblock("forward",state):$head.parentOffset<$head.parent.content.size)return!1;$cut=findCutAfter$2($head)}let node=$cut&&$cut.nodeAfter;return!(!node||!NodeSelection$2.isSelectable(node))&&(dispatch&&dispatch(state.tr.setSelection(NodeSelection$2.create(state.doc,$cut.pos)).scrollIntoView()),!0)};
/**
When the selection is empty and at the end of a textblock, select
the node coming after that textblock, if possible. This is intended
to be bound to keys like delete, after
[`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward) and similar deleting
commands, to provide a fall-back behavior when the schema doesn't
allow deletion at the selected point.
*/function findCutAfter$2($pos){if(!$pos.parent.type.spec.isolating)for(let i=$pos.depth-1;i>=0;i--){let parent=$pos.node(i);if($pos.index(i)+1<parent.childCount)return $pos.doc.resolve($pos.after(i+1));if(parent.type.spec.isolating)break}return null}
/**
Lift the selected block, or the closest ancestor block of the
selection that can be lifted, out of its parent node.
*/const lift$1$2=(state,dispatch)=>{let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to),target=range&&liftTarget$2(range);return null!=target&&(dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0)},newlineInCode$1$2=(state,dispatch)=>{let{$head:$head,$anchor:$anchor}=state.selection;return!(!$head.parent.type.spec.code||!$head.sameParent($anchor))&&(dispatch&&dispatch(state.tr.insertText("\n").scrollIntoView()),!0)};
/**
If the selection is in a node whose type has a truthy
[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, replace the
selection with a newline character.
*/function defaultBlockAt$1$2(match){for(let i=0;i<match.edgeCount;i++){let{type:type}=match.edge(i);if(type.isTextblock&&!type.hasRequiredAttrs())return type}return null}
/**
When the selection is in a node with a truthy
[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, create a
default block after the code block, and move the cursor there.
*/const exitCode$1$2=(state,dispatch)=>{let{$head:$head,$anchor:$anchor}=state.selection;if(!$head.parent.type.spec.code||!$head.sameParent($anchor))return!1;let above=$head.node(-1),after=$head.indexAfter(-1),type=defaultBlockAt$1$2(above.contentMatchAt(after));if(!type||!above.canReplaceWith(after,after,type))return!1;if(dispatch){let pos=$head.after(),tr=state.tr.replaceWith(pos,pos,type.createAndFill());tr.setSelection(Selection$2.near(tr.doc.resolve(pos),1)),dispatch(tr.scrollIntoView())}return!0},createParagraphNear$1$2=(state,dispatch)=>{let sel=state.selection,{$from:$from,$to:$to}=sel;if(sel instanceof AllSelection$2||$from.parent.inlineContent||$to.parent.inlineContent)return!1;let type=defaultBlockAt$1$2($to.parent.contentMatchAt($to.indexAfter()));if(!type||!type.isTextblock)return!1;if(dispatch){let side=(!$from.parentOffset&&$to.index()<$to.parent.childCount?$from:$to).pos,tr=state.tr.insert(side,type.createAndFill());tr.setSelection(TextSelection$2.create(tr.doc,side+1)),dispatch(tr.scrollIntoView())}return!0},liftEmptyBlock$1$2=(state,dispatch)=>{let{$cursor:$cursor}=state.selection;if(!$cursor||$cursor.parent.content.size)return!1;if($cursor.depth>1&&$cursor.after()!=$cursor.end(-1)){let before=$cursor.before();if(canSplit$2(state.doc,before))return dispatch&&dispatch(state.tr.split(before).scrollIntoView()),!0}let range=$cursor.blockRange(),target=range&&liftTarget$2(range);return null!=target&&(dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0)},selectParentNode$1$2=(state,dispatch)=>{let pos,{$from:$from,to:to}=state.selection,same=$from.sharedDepth(to);return 0!=same&&(pos=$from.before(same),dispatch&&dispatch(state.tr.setSelection(NodeSelection$2.create(state.doc,pos))),!0)};
/**
If a block node is selected, create an empty paragraph before (if
it is its parent's first child) or after it.
*/function joinMaybeClear$2(state,$pos,dispatch){let before=$pos.nodeBefore,after=$pos.nodeAfter,index=$pos.index();return!!(before&&after&&before.type.compatibleContent(after.type))&&(!before.content.size&&$pos.parent.canReplace(index-1,index)?(dispatch&&dispatch(state.tr.delete($pos.pos-before.nodeSize,$pos.pos).scrollIntoView()),!0):!(!$pos.parent.canReplace(index,index+1)||!after.isTextblock&&!canJoin$2(state.doc,$pos.pos))&&(dispatch&&dispatch(state.tr.clearIncompatible($pos.pos,before.type,before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView()),!0))}function deleteBarrier$2(state,$cut,dispatch){let conn,match,before=$cut.nodeBefore,after=$cut.nodeAfter;if(before.type.spec.isolating||after.type.spec.isolating)return!1;if(joinMaybeClear$2(state,$cut,dispatch))return!0;let canDelAfter=$cut.parent.canReplace($cut.index(),$cut.index()+1);if(canDelAfter&&(conn=(match=before.contentMatchAt(before.childCount)).findWrapping(after.type))&&match.matchType(conn[0]||after.type).validEnd){if(dispatch){let end=$cut.pos+after.nodeSize,wrap=Fragment$2.empty;for(let i=conn.length-1;i>=0;i--)wrap=Fragment$2.from(conn[i].create(null,wrap));wrap=Fragment$2.from(before.copy(wrap));let tr=state.tr.step(new ReplaceAroundStep$2($cut.pos-1,end,$cut.pos,end,new Slice$2(wrap,1,0),conn.length,!0)),joinAt=end+2*conn.length;canJoin$2(tr.doc,joinAt)&&tr.join(joinAt),dispatch(tr.scrollIntoView())}return!0}let selAfter=Selection$2.findFrom($cut,1),range=selAfter&&selAfter.$from.blockRange(selAfter.$to),target=range&&liftTarget$2(range);if(null!=target&&target>=$cut.depth)return dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0;if(canDelAfter&&textblockAt$2(after,"start",!0)&&textblockAt$2(before,"end")){let at=before,wrap=[];for(;;){if(wrap.push(at),at.isTextblock)break;at=at.lastChild}let afterText=after,afterDepth=1;for(;!afterText.isTextblock;afterText=afterText.firstChild)afterDepth++;if(at.canReplace(at.childCount,at.childCount,afterText.content)){if(dispatch){let end=Fragment$2.empty;for(let i=wrap.length-1;i>=0;i--)end=Fragment$2.from(wrap[i].copy(end));let tr=state.tr.step(new ReplaceAroundStep$2($cut.pos-wrap.length,$cut.pos+after.nodeSize,$cut.pos+afterDepth,$cut.pos+after.nodeSize-afterDepth,new Slice$2(end,wrap.length,0),0,!0));dispatch(tr.scrollIntoView())}return!0}}return!1}function selectTextblockSide$2(side){return function(state,dispatch){let sel=state.selection,$pos=side<0?sel.$from:sel.$to,depth=$pos.depth;while($pos.node(depth).isInline){if(!depth)return!1;depth--}return!!$pos.node(depth).isTextblock&&(dispatch&&dispatch(state.tr.setSelection(TextSelection$2.create(state.doc,side<0?$pos.start(depth):$pos.end(depth)))),!0)}}
/**
Moves the cursor to the start of current text block.
*/const selectTextblockStart$1$2=selectTextblockSide$2(-1),selectTextblockEnd$1$2=selectTextblockSide$2(1);
/**
Moves the cursor to the end of current text block.
*/
// Parameterized commands
/**
Wrap the selection in a node of the given type with the given
attributes.
*/
function wrapIn$1$2(nodeType,attrs=null){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to),wrapping=range&&findWrapping$2(range,nodeType,attrs);return!!wrapping&&(dispatch&&dispatch(state.tr.wrap(range,wrapping).scrollIntoView()),!0)}}
/**
Returns a command that tries to set the selected textblocks to the
given node type with the given attributes.
*/function setBlockType$3(nodeType,attrs=null){return function(state,dispatch){let{from:from,to:to}=state.selection,applicable=!1;return state.doc.nodesBetween(from,to,((node,pos)=>{if(applicable)return!1;if(node.isTextblock&&!node.hasMarkup(nodeType,attrs))if(node.type==nodeType)applicable=!0;else{let $pos=state.doc.resolve(pos),index=$pos.index();applicable=$pos.parent.canReplaceWith(index,index+1,nodeType)}})),!!applicable&&(dispatch&&dispatch(state.tr.setBlockType(from,to,nodeType,attrs).scrollIntoView()),!0)}}
/**
Returns a command function that wraps the selection in a list with
the given type an attributes. If `dispatch` is null, only return a
value to indicate whether this is possible, but don't actually
perform the change.
*/
function wrapInList$1$2(listType,attrs=null){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to),doJoin=!1,outerRange=range;if(!range)return!1;
// This is at the top of an existing list item
if(range.depth>=2&&$from.node(range.depth-1).type.compatibleContent(listType)&&0==range.startIndex){
// Don't do anything if this is the top of the list
if(0==$from.index(range.depth-1))return!1;let $insert=state.doc.resolve(range.start-2);outerRange=new NodeRange$2($insert,$insert,range.depth),range.endIndex<range.parent.childCount&&(range=new NodeRange$2($from,state.doc.resolve($to.end(range.depth)),range.depth)),doJoin=!0}let wrap=findWrapping$2(outerRange,listType,attrs,range);return!!wrap&&(dispatch&&dispatch(doWrapInList$2(state.tr,range,wrap,doJoin,listType).scrollIntoView()),!0)}}function doWrapInList$2(tr,range,wrappers,joinBefore,listType){let content=Fragment$2.empty;for(let i=wrappers.length-1;i>=0;i--)content=Fragment$2.from(wrappers[i].type.create(wrappers[i].attrs,content));tr.step(new ReplaceAroundStep$2(range.start-(joinBefore?2:0),range.end,range.start,range.end,new Slice$2(content,0,0),wrappers.length,!0));let found=0;for(let i=0;i<wrappers.length;i++)wrappers[i].type==listType&&(found=i+1);let splitDepth=wrappers.length-found,splitPos=range.start+wrappers.length-(joinBefore?2:0),parent=range.parent;for(let i=range.startIndex,e=range.endIndex,first=!0;i<e;i++,first=!1)!first&&canSplit$2(tr.doc,splitPos,splitDepth)&&(tr.split(splitPos,splitDepth),splitPos+=2*splitDepth),splitPos+=parent.child(i).nodeSize;return tr}
/**
Create a command to lift the list item around the selection up into
a wrapping list.
*/function liftListItem$1$2(itemType){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to,(node=>node.childCount>0&&node.firstChild.type==itemType));return!!range&&(!dispatch||($from.node(range.depth-1).type==itemType?liftToOuterList$2(state,dispatch,itemType,range):liftOutOfList$2(state,dispatch,range)))}}function liftToOuterList$2(state,dispatch,itemType,range){let tr=state.tr,end=range.end,endOfList=range.$to.end(range.depth);return end<endOfList&&(
// There are siblings after the lifted items, which must become
// children of the last item
tr.step(new ReplaceAroundStep$2(end-1,endOfList,end,endOfList,new Slice$2(Fragment$2.from(itemType.create(null,range.parent.copy())),1,0),1,!0)),range=new NodeRange$2(tr.doc.resolve(range.$from.pos),tr.doc.resolve(endOfList),range.depth)),dispatch(tr.lift(range,liftTarget$2(range)).scrollIntoView()),!0}function liftOutOfList$2(state,dispatch,range){let tr=state.tr,list=range.parent;
// Merge the list items into a single big item
for(let pos=range.end,i=range.endIndex-1,e=range.startIndex;i>e;i--)pos-=list.child(i).nodeSize,tr.delete(pos-1,pos+1);let $start=tr.doc.resolve(range.start),item=$start.nodeAfter;if(tr.mapping.map(range.end)!=range.start+$start.nodeAfter.nodeSize)return!1;let atStart=0==range.startIndex,atEnd=range.endIndex==list.childCount,parent=$start.node(-1),indexBefore=$start.index(-1);if(!parent.canReplace(indexBefore+(atStart?0:1),indexBefore+1,item.content.append(atEnd?Fragment$2.empty:Fragment$2.from(list))))return!1;let start=$start.pos,end=start+item.nodeSize;
// Strip off the surrounding list. At the sides where we're not at
// the end of the list, the existing list is closed. At sides where
// this is the end, it is overwritten to its end.
return tr.step(new ReplaceAroundStep$2(start-(atStart?1:0),end+(atEnd?1:0),start+1,end-1,new Slice$2((atStart?Fragment$2.empty:Fragment$2.from(list.copy(Fragment$2.empty))).append(atEnd?Fragment$2.empty:Fragment$2.from(list.copy(Fragment$2.empty))),atStart?0:1,atEnd?0:1),atStart?0:1)),dispatch(tr.scrollIntoView()),!0}
/**
Create a command to sink the list item around the selection down
into an inner list.
*/function sinkListItem$1$2(itemType){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to,(node=>node.childCount>0&&node.firstChild.type==itemType));if(!range)return!1;let startIndex=range.startIndex;if(0==startIndex)return!1;let parent=range.parent,nodeBefore=parent.child(startIndex-1);if(nodeBefore.type!=itemType)return!1;if(dispatch){let nestedBefore=nodeBefore.lastChild&&nodeBefore.lastChild.type==parent.type,inner=Fragment$2.from(nestedBefore?itemType.create():null),slice=new Slice$2(Fragment$2.from(itemType.create(null,Fragment$2.from(parent.type.create(null,inner)))),nestedBefore?3:1,0),before=range.start,after=range.end;dispatch(state.tr.step(new ReplaceAroundStep$2(before-(nestedBefore?3:1),after,before,after,slice,1,!0)).scrollIntoView())}return!0}}function createChainableState$2(config){const{state:state,transaction:transaction}=config;let{selection:selection}=transaction,{doc:doc}=transaction,{storedMarks:storedMarks}=transaction;return{...state,apply:state.apply.bind(state),applyTransaction:state.applyTransaction.bind(state),filterTransaction:state.filterTransaction,plugins:state.plugins,schema:state.schema,reconfigure:state.reconfigure.bind(state),toJSON:state.toJSON.bind(state),get storedMarks(){return storedMarks},get selection(){return selection},get doc(){return doc},get tr(){return selection=transaction.selection,doc=transaction.doc,storedMarks=transaction.storedMarks,transaction}}}"undefined"!=typeof navigator?/Mac|iP(hone|[oa]d)/.test(navigator.platform):"undefined"!=typeof os&&os.platform&&os.platform();class CommandManager$2{constructor(props){this.editor=props.editor,this.rawCommands=this.editor.extensionManager.commands,this.customState=props.state}get hasCustomState(){return!!this.customState}get state(){return this.customState||this.editor.state}get commands(){const{rawCommands:rawCommands,editor:editor,state:state}=this,{view:view}=editor,{tr:tr}=state,props=this.buildProps(tr);return Object.fromEntries(Object.entries(rawCommands).map((([name,command])=>{const method=(...args)=>{const callback=command(...args)(props);return tr.getMeta("preventDispatch")||this.hasCustomState||view.dispatch(tr),callback};return[name,method]})))}get chain(){return()=>this.createChain()}get can(){return()=>this.createCan()}createChain(startTr,shouldDispatch=!0){const{rawCommands:rawCommands,editor:editor,state:state}=this,{view:view}=editor,callbacks=[],hasStartTransaction=!!startTr,tr=startTr||state.tr,run=()=>(hasStartTransaction||!shouldDispatch||tr.getMeta("preventDispatch")||this.hasCustomState||view.dispatch(tr),callbacks.every((callback=>!0===callback))),chain={...Object.fromEntries(Object.entries(rawCommands).map((([name,command])=>{const chainedCommand=(...args)=>{const props=this.buildProps(tr,shouldDispatch),callback=command(...args)(props);return callbacks.push(callback),chain};return[name,chainedCommand]}))),run:run};return chain}createCan(startTr){const{rawCommands:rawCommands,state:state}=this,dispatch=!1,tr=startTr||state.tr,props=this.buildProps(tr,dispatch),formattedCommands=Object.fromEntries(Object.entries(rawCommands).map((([name,command])=>[name,(...args)=>command(...args)({...props,dispatch:void 0})])));return{...formattedCommands,chain:()=>this.createChain(tr,dispatch)}}buildProps(tr,shouldDispatch=!0){const{rawCommands:rawCommands,editor:editor,state:state}=this,{view:view}=editor;state.storedMarks&&tr.setStoredMarks(state.storedMarks);const props={tr:tr,editor:editor,view:view,state:createChainableState$2({state:state,transaction:tr}),dispatch:shouldDispatch?()=>{}:void 0,chain:()=>this.createChain(tr),can:()=>this.createCan(tr),get commands(){return Object.fromEntries(Object.entries(rawCommands).map((([name,command])=>[name,(...args)=>command(...args)(props)])))}};return props}}function getExtensionField$2(extension,field,context){if(void 0===extension.config[field]&&extension.parent)return getExtensionField$2(extension.parent,field,context);if("function"===typeof extension.config[field]){const value=extension.config[field].bind({...context,parent:extension.parent?getExtensionField$2(extension.parent,field,context):null});return value}return extension.config[field]}function splitExtensions$2(extensions){const baseExtensions=extensions.filter((extension=>"extension"===extension.type)),nodeExtensions=extensions.filter((extension=>"node"===extension.type)),markExtensions=extensions.filter((extension=>"mark"===extension.type));return{baseExtensions:baseExtensions,nodeExtensions:nodeExtensions,markExtensions:markExtensions}}function getNodeType$2(nameOrType,schema){if("string"===typeof nameOrType){if(!schema.nodes[nameOrType])throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);return schema.nodes[nameOrType]}return nameOrType}function mergeAttributes$2(...objects){return objects.filter((item=>!!item)).reduce(((items,item)=>{const mergedAttributes={...items};return Object.entries(item).forEach((([key,value])=>{const exists=mergedAttributes[key];mergedAttributes[key]=exists?"class"===key?[mergedAttributes[key],value].join(" "):"style"===key?[mergedAttributes[key],value].join("; "):value:value})),mergedAttributes}),{})}function isFunction$2$2(value){return"function"===typeof value}
/**
 * Optionally calls `value` as a function.
 * Otherwise it is returned directly.
 * @param value Function or any value.
 * @param context Optional context to bind to function.
 * @param props Optional props to pass to function.
 */function callOrReturn$2(value,context=void 0,...props){return isFunction$2$2(value)?context?value.bind(context)(...props):value(...props):value}function isRegExp$2(value){return"[object RegExp]"===Object.prototype.toString.call(value)}class InputRule$2{constructor(config){this.find=config.find,this.handler=config.handler}}class PasteRule$2{constructor(config){this.find=config.find,this.handler=config.handler}}
// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts
function getType$2(value){return Object.prototype.toString.call(value).slice(8,-1)}function isPlainObject$2(value){return"Object"===getType$2(value)&&(value.constructor===Object&&Object.getPrototypeOf(value)===Object.prototype)}function mergeDeep$2(target,source){const output={...target};return isPlainObject$2(target)&&isPlainObject$2(source)&&Object.keys(source).forEach((key=>{isPlainObject$2(source[key])?key in target?output[key]=mergeDeep$2(target[key],source[key]):Object.assign(output,{[key]:source[key]}):Object.assign(output,{[key]:source[key]})})),output}class Extension$2{constructor(config={}){this.type="extension",this.name="extension",this.parent=null,this.child=null,this.config={name:this.name,defaultOptions:{}},this.config={...this.config,...config},this.name=this.config.name,config.defaultOptions,
// TODO: remove `addOptions` fallback
this.options=this.config.defaultOptions,this.config.addOptions&&(this.options=callOrReturn$2(getExtensionField$2(this,"addOptions",{name:this.name}))),this.storage=callOrReturn$2(getExtensionField$2(this,"addStorage",{name:this.name,options:this.options}))||{}}static create(config={}){return new Extension$2(config)}configure(options={}){
// return a new instance so we can use the same extension
// with different calls of `configure`
const extension=this.extend();return extension.options=mergeDeep$2(this.options,options),extension.storage=callOrReturn$2(getExtensionField$2(extension,"addStorage",{name:extension.name,options:extension.options})),extension}extend(extendedConfig={}){const extension=new Extension$2(extendedConfig);return extension.parent=this,this.child=extension,extension.name=extendedConfig.name?extendedConfig.name:extension.parent.name,extendedConfig.defaultOptions,extension.options=callOrReturn$2(getExtensionField$2(extension,"addOptions",{name:extension.name})),extension.storage=callOrReturn$2(getExtensionField$2(extension,"addStorage",{name:extension.name,options:extension.options})),extension}}function getTextBetween$2(startNode,range,options){const{from:from,to:to}=range,{blockSeparator:blockSeparator="\n\n",textSerializers:textSerializers={}}=options||{};let text="",separated=!0;return startNode.nodesBetween(from,to,((node,pos,parent,index)=>{var _a;const textSerializer=null===textSerializers||void 0===textSerializers?void 0:textSerializers[node.type.name];textSerializer?(node.isBlock&&!separated&&(text+=blockSeparator,separated=!0),parent&&(text+=textSerializer({node:node,pos:pos,parent:parent,index:index,range:range}))):node.isText?(text+=null===(_a=null===node||void 0===node?void 0:node.text)||void 0===_a?void 0:_a.slice(Math.max(from,pos)-pos,to-pos),// eslint-disable-line
separated=!1):node.isBlock&&!separated&&(text+=blockSeparator,separated=!0)})),text}function getTextSerializersFromSchema$2(schema){return Object.fromEntries(Object.entries(schema.nodes).filter((([,node])=>node.spec.toText)).map((([name,node])=>[name,node.spec.toText])))}Extension$2.create({name:"clipboardTextSerializer",addProseMirrorPlugins(){return[new Plugin$2({key:new PluginKey$2("clipboardTextSerializer"),props:{clipboardTextSerializer:()=>{const{editor:editor}=this,{state:state,schema:schema}=editor,{doc:doc,selection:selection}=state,{ranges:ranges}=selection,from=Math.min(...ranges.map((range=>range.$from.pos))),to=Math.max(...ranges.map((range=>range.$to.pos))),textSerializers=getTextSerializersFromSchema$2(schema),range={from:from,to:to};return getTextBetween$2(doc,range,{textSerializers:textSerializers})}}})]}});const blur$2=()=>({editor:editor,view:view})=>(requestAnimationFrame((()=>{var _a;editor.isDestroyed||(view.dom.blur(),
// Browsers should remove the caret on blur but safari does not.
// See: https://github.com/ueberdosis/tiptap/issues/2405
null===(_a=null===window||void 0===window?void 0:window.getSelection())||void 0===_a||_a.removeAllRanges())})),!0),clearContent$2=(emitUpdate=!1)=>({commands:commands})=>commands.setContent("",emitUpdate),clearNodes$2=()=>({state:state,tr:tr,dispatch:dispatch})=>{const{selection:selection}=tr,{ranges:ranges}=selection;return!dispatch||(ranges.forEach((({$from:$from,$to:$to})=>{state.doc.nodesBetween($from.pos,$to.pos,((node,pos)=>{if(node.type.isText)return;const{doc:doc,mapping:mapping}=tr,$mappedFrom=doc.resolve(mapping.map(pos)),$mappedTo=doc.resolve(mapping.map(pos+node.nodeSize)),nodeRange=$mappedFrom.blockRange($mappedTo);if(!nodeRange)return;const targetLiftDepth=liftTarget$2(nodeRange);if(node.type.isTextblock){const{defaultType:defaultType}=$mappedFrom.parent.contentMatchAt($mappedFrom.index());tr.setNodeMarkup(nodeRange.start,defaultType)}(targetLiftDepth||0===targetLiftDepth)&&tr.lift(nodeRange,targetLiftDepth)}))})),!0)},command$2=fn=>props=>fn(props),createParagraphNear$3=()=>({state:state,dispatch:dispatch})=>createParagraphNear$1$2(state,dispatch),deleteNode$2=typeOrName=>({tr:tr,state:state,dispatch:dispatch})=>{const type=getNodeType$2(typeOrName,state.schema),$pos=tr.selection.$anchor;for(let depth=$pos.depth;depth>0;depth-=1){const node=$pos.node(depth);if(node.type===type){if(dispatch){const from=$pos.before(depth),to=$pos.after(depth);tr.delete(from,to).scrollIntoView()}return!0}}return!1},deleteRange$3=range=>({tr:tr,dispatch:dispatch})=>{const{from:from,to:to}=range;return dispatch&&tr.delete(from,to),!0},deleteSelection$3=()=>({state:state,dispatch:dispatch})=>deleteSelection$1$2(state,dispatch),enter$2=()=>({commands:commands})=>commands.keyboardShortcut("Enter"),exitCode$3=()=>({state:state,dispatch:dispatch})=>exitCode$1$2(state,dispatch)
/**
 * Check if object1 includes object2
 * @param object1 Object
 * @param object2 Object
 */;function objectIncludes$2(object1,object2,options={strict:!0}){const keys=Object.keys(object2);return!keys.length||keys.every((key=>options.strict?object2[key]===object1[key]:isRegExp$2(object2[key])?object2[key].test(object1[key]):object2[key]===object1[key]))}function findMarkInSet$2(marks,type,attributes={}){return marks.find((item=>item.type===type&&objectIncludes$2(item.attrs,attributes)))}function isMarkInSet$2(marks,type,attributes={}){return!!findMarkInSet$2(marks,type,attributes)}function getMarkRange$2($pos,type,attributes={}){if(!$pos||!type)return;let start=$pos.parent.childAfter($pos.parentOffset);if($pos.parentOffset===start.offset&&0!==start.offset&&(start=$pos.parent.childBefore($pos.parentOffset)),!start.node)return;const mark=findMarkInSet$2([...start.node.marks],type,attributes);if(!mark)return;let startIndex=start.index,startPos=$pos.start()+start.offset,endIndex=startIndex+1,endPos=startPos+start.node.nodeSize;findMarkInSet$2([...start.node.marks],type,attributes);while(startIndex>0&&mark.isInSet($pos.parent.child(startIndex-1).marks))startIndex-=1,startPos-=$pos.parent.child(startIndex).nodeSize;while(endIndex<$pos.parent.childCount&&isMarkInSet$2([...$pos.parent.child(endIndex).marks],type,attributes))endPos+=$pos.parent.child(endIndex).nodeSize,endIndex+=1;return{from:startPos,to:endPos}}function getMarkType$2(nameOrType,schema){if("string"===typeof nameOrType){if(!schema.marks[nameOrType])throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);return schema.marks[nameOrType]}return nameOrType}const extendMarkRange$2=(typeOrName,attributes={})=>({tr:tr,state:state,dispatch:dispatch})=>{const type=getMarkType$2(typeOrName,state.schema),{doc:doc,selection:selection}=tr,{$from:$from,from:from,to:to}=selection;if(dispatch){const range=getMarkRange$2($from,type,attributes);if(range&&range.from<=from&&range.to>=to){const newSelection=TextSelection$2.create(doc,range.from,range.to);tr.setSelection(newSelection)}}return!0},first$2=commands=>props=>{const items="function"===typeof commands?commands(props):commands;for(let i=0;i<items.length;i+=1)if(items[i](props))return!0;return!1};function isTextSelection$2(value){return value instanceof TextSelection$2}function minMax$2(value=0,min=0,max=0){return Math.min(Math.max(value,min),max)}function resolveFocusPosition$2(doc,position=null){if(!position)return null;const selectionAtStart=Selection$2.atStart(doc),selectionAtEnd=Selection$2.atEnd(doc);if("start"===position||!0===position)return selectionAtStart;if("end"===position)return selectionAtEnd;const minPos=selectionAtStart.from,maxPos=selectionAtEnd.to;return"all"===position?TextSelection$2.create(doc,minMax$2(0,minPos,maxPos),minMax$2(doc.content.size,minPos,maxPos)):TextSelection$2.create(doc,minMax$2(position,minPos,maxPos),minMax$2(position,minPos,maxPos))}function isiOS$2(){return["iPad Simulator","iPhone Simulator","iPod Simulator","iPad","iPhone","iPod"].includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document}const focus$2=(position=null,options={})=>({editor:editor,view:view,tr:tr,dispatch:dispatch})=>{options={scrollIntoView:!0,...options};const delayedFocus=()=>{
// focus within `requestAnimationFrame` breaks focus on iOS
// so we have to call this
isiOS$2()&&view.dom.focus(),
// For React we have to focus asynchronously. Otherwise wild things happen.
// see: https://github.com/ueberdosis/tiptap/issues/1520
requestAnimationFrame((()=>{editor.isDestroyed||(view.focus(),(null===options||void 0===options?void 0:options.scrollIntoView)&&editor.commands.scrollIntoView())}))};if(view.hasFocus()&&null===position||!1===position)return!0;
// we don’t try to resolve a NodeSelection or CellSelection
if(dispatch&&null===position&&!isTextSelection$2(editor.state.selection))return delayedFocus(),!0;
// pass through tr.doc instead of editor.state.doc
// since transactions could change the editors state before this command has been run
const selection=resolveFocusPosition$2(tr.doc,position)||editor.state.selection,isSameSelection=editor.state.selection.eq(selection);return dispatch&&(isSameSelection||tr.setSelection(selection),
// `tr.setSelection` resets the stored marks
// so we’ll restore them if the selection is the same as before
isSameSelection&&tr.storedMarks&&tr.setStoredMarks(tr.storedMarks),delayedFocus()),!0},forEach$2=(items,fn)=>props=>items.every(((item,index)=>fn(item,{...props,index:index}))),insertContent$2=(value,options)=>({tr:tr,commands:commands})=>commands.insertContentAt({from:tr.selection.from,to:tr.selection.to},value,options);function elementFromString$2(value){
// add a wrapper to preserve leading and trailing whitespace
const wrappedValue=`<body>${value}</body>`;return(new window.DOMParser).parseFromString(wrappedValue,"text/html").body}function createNodeFromContent$2(content,schema,options){if(options={slice:!0,parseOptions:{},...options},"object"===typeof content&&null!==content)try{return Array.isArray(content)?Fragment$2.fromArray(content.map((item=>schema.nodeFromJSON(item)))):schema.nodeFromJSON(content)}catch(error){return createNodeFromContent$2("",schema,options)}if("string"===typeof content){const parser=DOMParser$1$2.fromSchema(schema);return options.slice?parser.parseSlice(elementFromString$2(content),options.parseOptions).content:parser.parse(elementFromString$2(content),options.parseOptions)}return createNodeFromContent$2("",schema,options)}
// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466
function selectionToInsertionEnd$3(tr,startLen,bias){const last=tr.steps.length-1;if(last<startLen)return;const step=tr.steps[last];if(!(step instanceof ReplaceStep$2||step instanceof ReplaceAroundStep$2))return;const map=tr.mapping.maps[last];let end=0;map.forEach(((_from,_to,_newFrom,newTo)=>{0===end&&(end=newTo)})),tr.setSelection(Selection$2.near(tr.doc.resolve(end),bias))}const isFragment$2=nodeOrFragment=>nodeOrFragment.toString().startsWith("<"),insertContentAt$2=(position,value,options)=>({tr:tr,dispatch:dispatch,editor:editor})=>{if(dispatch){options={parseOptions:{},updateSelection:!0,...options};const content=createNodeFromContent$2(value,editor.schema,{parseOptions:{preserveWhitespace:"full",...options.parseOptions}});
// don’t dispatch an empty fragment because this can lead to strange errors
if("<>"===content.toString())return!0;let{from:from,to:to}="number"===typeof position?{from:position,to:position}:position,isOnlyTextContent=!0,isOnlyBlockContent=!0;const nodes=isFragment$2(content)?content:[content];
// check if we can replace the wrapping node by
// the newly inserted content
// example:
// replace an empty paragraph by an inserted image
// instead of inserting the image below the paragraph
if(nodes.forEach((node=>{
// check if added node is valid
node.check(),isOnlyTextContent=!!isOnlyTextContent&&(node.isText&&0===node.marks.length),isOnlyBlockContent=!!isOnlyBlockContent&&node.isBlock})),from===to&&isOnlyBlockContent){const{parent:parent}=tr.doc.resolve(from),isEmptyTextBlock=parent.isTextblock&&!parent.type.spec.code&&!parent.childCount;isEmptyTextBlock&&(from-=1,to+=1)}
// if there is only plain text we have to use `insertText`
// because this will keep the current marks
isOnlyTextContent?tr.insertText(value,from,to):tr.replaceWith(from,to,content),
// set cursor at end of inserted content
options.updateSelection&&selectionToInsertionEnd$3(tr,tr.steps.length-1,-1)}return!0},joinBackward$3=()=>({state:state,dispatch:dispatch})=>joinBackward$1$2(state,dispatch),joinForward$3=()=>({state:state,dispatch:dispatch})=>joinForward$1$2(state,dispatch);function isMacOS$2(){return"undefined"!==typeof navigator&&/Mac/.test(navigator.platform)}function normalizeKeyName$3(name){const parts=name.split(/-(?!$)/);let alt,ctrl,shift,meta,result=parts[parts.length-1];"Space"===result&&(result=" ");for(let i=0;i<parts.length-1;i+=1){const mod=parts[i];if(/^(cmd|meta|m)$/i.test(mod))meta=!0;else if(/^a(lt)?$/i.test(mod))alt=!0;else if(/^(c|ctrl|control)$/i.test(mod))ctrl=!0;else if(/^s(hift)?$/i.test(mod))shift=!0;else{if(!/^mod$/i.test(mod))throw new Error(`Unrecognized modifier name: ${mod}`);isiOS$2()||isMacOS$2()?meta=!0:ctrl=!0}}return alt&&(result=`Alt-${result}`),ctrl&&(result=`Ctrl-${result}`),meta&&(result=`Meta-${result}`),shift&&(result=`Shift-${result}`),result}const keyboardShortcut$2=name=>({editor:editor,view:view,tr:tr,dispatch:dispatch})=>{const keys=normalizeKeyName$3(name).split(/-(?!$)/),key=keys.find((item=>!["Alt","Ctrl","Meta","Shift"].includes(item))),event=new KeyboardEvent("keydown",{key:"Space"===key?" ":key,altKey:keys.includes("Alt"),ctrlKey:keys.includes("Ctrl"),metaKey:keys.includes("Meta"),shiftKey:keys.includes("Shift"),bubbles:!0,cancelable:!0}),capturedTransaction=editor.captureTransaction((()=>{view.someProp("handleKeyDown",(f=>f(view,event)))}));return null===capturedTransaction||void 0===capturedTransaction||capturedTransaction.steps.forEach((step=>{const newStep=step.map(tr.mapping);newStep&&dispatch&&tr.maybeStep(newStep)})),!0};function isNodeActive$2(state,typeOrName,attributes={}){const{from:from,to:to,empty:empty}=state.selection,type=typeOrName?getNodeType$2(typeOrName,state.schema):null,nodeRanges=[];state.doc.nodesBetween(from,to,((node,pos)=>{if(node.isText)return;const relativeFrom=Math.max(from,pos),relativeTo=Math.min(to,pos+node.nodeSize);nodeRanges.push({node:node,from:relativeFrom,to:relativeTo})}));const selectionRange=to-from,matchedNodeRanges=nodeRanges.filter((nodeRange=>!type||type.name===nodeRange.node.type.name)).filter((nodeRange=>objectIncludes$2(nodeRange.node.attrs,attributes,{strict:!1})));if(empty)return!!matchedNodeRanges.length;const range=matchedNodeRanges.reduce(((sum,nodeRange)=>sum+nodeRange.to-nodeRange.from),0);return range>=selectionRange}const lift$4=(typeOrName,attributes={})=>({state:state,dispatch:dispatch})=>{const type=getNodeType$2(typeOrName,state.schema),isActive=isNodeActive$2(state,type,attributes);return!!isActive&&lift$1$2(state,dispatch)},liftEmptyBlock$3=()=>({state:state,dispatch:dispatch})=>liftEmptyBlock$1$2(state,dispatch),liftListItem$3=typeOrName=>({state:state,dispatch:dispatch})=>{const type=getNodeType$2(typeOrName,state.schema);return liftListItem$1$2(type)(state,dispatch)},newlineInCode$3=()=>({state:state,dispatch:dispatch})=>newlineInCode$1$2(state,dispatch);function getSchemaTypeNameByName$2(name,schema){return schema.nodes[name]?"node":schema.marks[name]?"mark":null}
/**
 * Remove a property or an array of properties from an object
 * @param obj Object
 * @param key Key to remove
 */function deleteProps$2(obj,propOrProps){const props="string"===typeof propOrProps?[propOrProps]:propOrProps;return Object.keys(obj).reduce(((newObj,prop)=>(props.includes(prop)||(newObj[prop]=obj[prop]),newObj)),{})}const resetAttributes$2=(typeOrName,attributes)=>({tr:tr,state:state,dispatch:dispatch})=>{let nodeType=null,markType=null;const schemaType=getSchemaTypeNameByName$2("string"===typeof typeOrName?typeOrName:typeOrName.name,state.schema);return!!schemaType&&("node"===schemaType&&(nodeType=getNodeType$2(typeOrName,state.schema)),"mark"===schemaType&&(markType=getMarkType$2(typeOrName,state.schema)),dispatch&&tr.selection.ranges.forEach((range=>{state.doc.nodesBetween(range.$from.pos,range.$to.pos,((node,pos)=>{nodeType&&nodeType===node.type&&tr.setNodeMarkup(pos,void 0,deleteProps$2(node.attrs,attributes)),markType&&node.marks.length&&node.marks.forEach((mark=>{markType===mark.type&&tr.addMark(pos,pos+node.nodeSize,markType.create(deleteProps$2(mark.attrs,attributes)))}))}))})),!0)},scrollIntoView$2=()=>({tr:tr,dispatch:dispatch})=>(dispatch&&tr.scrollIntoView(),!0),selectAll$2=()=>({tr:tr,commands:commands})=>commands.setTextSelection({from:0,to:tr.doc.content.size}),selectNodeBackward$3=()=>({state:state,dispatch:dispatch})=>selectNodeBackward$1$2(state,dispatch),selectNodeForward$3=()=>({state:state,dispatch:dispatch})=>selectNodeForward$1$2(state,dispatch),selectParentNode$3=()=>({state:state,dispatch:dispatch})=>selectParentNode$1$2(state,dispatch)
// @ts-ignore
,selectTextblockEnd$3=()=>({state:state,dispatch:dispatch})=>selectTextblockEnd$1$2(state,dispatch)
// @ts-ignore
,selectTextblockStart$3=()=>({state:state,dispatch:dispatch})=>selectTextblockStart$1$2(state,dispatch);function createDocument$2(content,schema,parseOptions={}){return createNodeFromContent$2(content,schema,{slice:!1,parseOptions:parseOptions})}const setContent$1$2=(content,emitUpdate=!1,parseOptions={})=>({tr:tr,editor:editor,dispatch:dispatch})=>{const{doc:doc}=tr,document=createDocument$2(content,editor.schema,parseOptions);return dispatch&&tr.replaceWith(0,doc.content.size,document).setMeta("preventUpdate",!emitUpdate),!0};function getMarkAttributes$2(state,typeOrName){const type=getMarkType$2(typeOrName,state.schema),{from:from,to:to,empty:empty}=state.selection,marks=[];empty?(state.storedMarks&&marks.push(...state.storedMarks),marks.push(...state.selection.$head.marks())):state.doc.nodesBetween(from,to,(node=>{marks.push(...node.marks)}));const mark=marks.find((markItem=>markItem.type.name===type.name));return mark?{...mark.attrs}:{}}const setMark$2=(typeOrName,attributes={})=>({tr:tr,state:state,dispatch:dispatch})=>{const{selection:selection}=tr,{empty:empty,ranges:ranges}=selection,type=getMarkType$2(typeOrName,state.schema);if(dispatch)if(empty){const oldAttributes=getMarkAttributes$2(state,type);tr.addStoredMark(type.create({...oldAttributes,...attributes}))}else ranges.forEach((range=>{const from=range.$from.pos,to=range.$to.pos;state.doc.nodesBetween(from,to,((node,pos)=>{const trimmedFrom=Math.max(pos,from),trimmedTo=Math.min(pos+node.nodeSize,to),someHasMark=node.marks.find((mark=>mark.type===type));
// if there is already a mark of this type
// we know that we have to merge its attributes
// otherwise we add a fresh new mark
someHasMark?node.marks.forEach((mark=>{type===mark.type&&tr.addMark(trimmedFrom,trimmedTo,type.create({...mark.attrs,...attributes}))})):tr.addMark(trimmedFrom,trimmedTo,type.create(attributes))}))}));return!0},setMeta$2=(key,value)=>({tr:tr})=>(tr.setMeta(key,value),!0),setNode$2=(typeOrName,attributes={})=>({state:state,dispatch:dispatch,chain:chain})=>{const type=getNodeType$2(typeOrName,state.schema);
// TODO: use a fallback like insertContent?
return!!type.isTextblock&&chain().command((({commands:commands})=>{const canSetBlock=setBlockType$3(type,attributes)(state);return!!canSetBlock||commands.clearNodes()})).command((({state:updatedState})=>setBlockType$3(type,attributes)(updatedState,dispatch))).run()},setNodeSelection$2=position=>({tr:tr,dispatch:dispatch})=>{if(dispatch){const{doc:doc}=tr,from=minMax$2(position,0,doc.content.size),selection=NodeSelection$2.create(doc,from);tr.setSelection(selection)}return!0},setTextSelection$2=position=>({tr:tr,dispatch:dispatch})=>{if(dispatch){const{doc:doc}=tr,{from:from,to:to}="number"===typeof position?{from:position,to:position}:position,minPos=TextSelection$2.atStart(doc).from,maxPos=TextSelection$2.atEnd(doc).to,resolvedFrom=minMax$2(from,minPos,maxPos),resolvedEnd=minMax$2(to,minPos,maxPos),selection=TextSelection$2.create(doc,resolvedFrom,resolvedEnd);tr.setSelection(selection)}return!0},sinkListItem$3=typeOrName=>({state:state,dispatch:dispatch})=>{const type=getNodeType$2(typeOrName,state.schema);return sinkListItem$1$2(type)(state,dispatch)};function defaultBlockAt$3(match){for(let i=0;i<match.edgeCount;i+=1){const{type:type}=match.edge(i);if(type.isTextblock&&!type.hasRequiredAttrs())return type}return null}function getSplittedAttributes$2(extensionAttributes,typeName,attributes){return Object.fromEntries(Object.entries(attributes).filter((([name])=>{const extensionAttribute=extensionAttributes.find((item=>item.type===typeName&&item.name===name));return!!extensionAttribute&&extensionAttribute.attribute.keepOnSplit})))}function ensureMarks$2(state,splittableMarks){const marks=state.storedMarks||state.selection.$to.parentOffset&&state.selection.$from.marks();if(marks){const filteredMarks=marks.filter((mark=>null===splittableMarks||void 0===splittableMarks?void 0:splittableMarks.includes(mark.type.name)));state.tr.ensureMarks(filteredMarks)}}const splitBlock$2=({keepMarks:keepMarks=!0}={})=>({tr:tr,state:state,dispatch:dispatch,editor:editor})=>{const{selection:selection,doc:doc}=tr,{$from:$from,$to:$to}=selection,extensionAttributes=editor.extensionManager.attributes,newAttributes=getSplittedAttributes$2(extensionAttributes,$from.node().type.name,$from.node().attrs);if(selection instanceof NodeSelection$2&&selection.node.isBlock)return!(!$from.parentOffset||!canSplit$2(doc,$from.pos))&&(dispatch&&(keepMarks&&ensureMarks$2(state,editor.extensionManager.splittableMarks),tr.split($from.pos).scrollIntoView()),!0);if(!$from.parent.isBlock)return!1;if(dispatch){const atEnd=$to.parentOffset===$to.parent.content.size;selection instanceof TextSelection$2&&tr.deleteSelection();const deflt=0===$from.depth?void 0:defaultBlockAt$3($from.node(-1).contentMatchAt($from.indexAfter(-1)));let types=atEnd&&deflt?[{type:deflt,attrs:newAttributes}]:void 0,can=canSplit$2(tr.doc,tr.mapping.map($from.pos),1,types);if(types||can||!canSplit$2(tr.doc,tr.mapping.map($from.pos),1,deflt?[{type:deflt}]:void 0)||(can=!0,types=deflt?[{type:deflt,attrs:newAttributes}]:void 0),can&&(tr.split(tr.mapping.map($from.pos),1,types),deflt&&!atEnd&&!$from.parentOffset&&$from.parent.type!==deflt)){const first=tr.mapping.map($from.before()),$first=tr.doc.resolve(first);$from.node(-1).canReplaceWith($first.index(),$first.index()+1,deflt)&&tr.setNodeMarkup(tr.mapping.map($from.before()),deflt)}keepMarks&&ensureMarks$2(state,editor.extensionManager.splittableMarks),tr.scrollIntoView()}return!0},splitListItem$2=typeOrName=>({tr:tr,state:state,dispatch:dispatch,editor:editor})=>{var _a;const type=getNodeType$2(typeOrName,state.schema),{$from:$from,$to:$to}=state.selection,node=state.selection.node;if(node&&node.isBlock||$from.depth<2||!$from.sameParent($to))return!1;const grandParent=$from.node(-1);if(grandParent.type!==type)return!1;const extensionAttributes=editor.extensionManager.attributes;if(0===$from.parent.content.size&&$from.node(-1).childCount===$from.indexAfter(-1)){
// In an empty block. If this is a nested list, the wrapping
// list item should be split. Otherwise, bail out and let next
// command handle lifting.
if(2===$from.depth||$from.node(-3).type!==type||$from.index(-2)!==$from.node(-2).childCount-1)return!1;if(dispatch){let wrap=Fragment$2.empty;
// eslint-disable-next-line
const depthBefore=$from.index(-1)?1:$from.index(-2)?2:3;
// Build a fragment containing empty versions of the structure
// from the outer list item to the parent node of the cursor
for(let d=$from.depth-depthBefore;d>=$from.depth-3;d-=1)wrap=Fragment$2.from($from.node(d).copy(wrap));
// eslint-disable-next-line
const depthAfter=$from.indexAfter(-1)<$from.node(-2).childCount?1:$from.indexAfter(-2)<$from.node(-3).childCount?2:3,newNextTypeAttributes=getSplittedAttributes$2(extensionAttributes,$from.node().type.name,$from.node().attrs),nextType=(null===(_a=type.contentMatch.defaultType)||void 0===_a?void 0:_a.createAndFill(newNextTypeAttributes))||void 0;
// Add a second list item with an empty default start node
wrap=wrap.append(Fragment$2.from(type.createAndFill(null,nextType)||void 0));const start=$from.before($from.depth-(depthBefore-1));tr.replace(start,$from.after(-depthAfter),new Slice$2(wrap,4-depthBefore,0));let sel=-1;tr.doc.nodesBetween(start,tr.doc.content.size,((n,pos)=>{if(sel>-1)return!1;n.isTextblock&&0===n.content.size&&(sel=pos+1)})),sel>-1&&tr.setSelection(TextSelection$2.near(tr.doc.resolve(sel))),tr.scrollIntoView()}return!0}const nextType=$to.pos===$from.end()?grandParent.contentMatchAt(0).defaultType:null,newTypeAttributes=getSplittedAttributes$2(extensionAttributes,grandParent.type.name,grandParent.attrs),newNextTypeAttributes=getSplittedAttributes$2(extensionAttributes,$from.node().type.name,$from.node().attrs);tr.delete($from.pos,$to.pos);const types=nextType?[{type:type,attrs:newTypeAttributes},{type:nextType,attrs:newNextTypeAttributes}]:[{type:type,attrs:newTypeAttributes}];return!!canSplit$2(tr.doc,$from.pos,2)&&(dispatch&&tr.split($from.pos,2,types).scrollIntoView(),!0)};function findParentNodeClosestToPos$2($pos,predicate){for(let i=$pos.depth;i>0;i-=1){const node=$pos.node(i);if(predicate(node))return{pos:i>0?$pos.before(i):0,start:$pos.start(i),depth:i,node:node}}}function findParentNode$2(predicate){return selection=>findParentNodeClosestToPos$2(selection.$from,predicate)}function isList$2(name,extensions){const{nodeExtensions:nodeExtensions}=splitExtensions$2(extensions),extension=nodeExtensions.find((item=>item.name===name));if(!extension)return!1;const context={name:extension.name,options:extension.options,storage:extension.storage},group=callOrReturn$2(getExtensionField$2(extension,"group",context));return"string"===typeof group&&group.split(" ").includes("list")}const joinListBackwards$2=(tr,listType)=>{const list=findParentNode$2((node=>node.type===listType))(tr.selection);if(!list)return!0;const before=tr.doc.resolve(Math.max(0,list.pos-1)).before(list.depth);if(void 0===before)return!0;const nodeBefore=tr.doc.nodeAt(before),canJoinBackwards=list.node.type===(null===nodeBefore||void 0===nodeBefore?void 0:nodeBefore.type)&&canJoin$2(tr.doc,list.pos);return!canJoinBackwards||(tr.join(list.pos),!0)},joinListForwards$2=(tr,listType)=>{const list=findParentNode$2((node=>node.type===listType))(tr.selection);if(!list)return!0;const after=tr.doc.resolve(list.start).after(list.depth);if(void 0===after)return!0;const nodeAfter=tr.doc.nodeAt(after),canJoinForwards=list.node.type===(null===nodeAfter||void 0===nodeAfter?void 0:nodeAfter.type)&&canJoin$2(tr.doc,after);return!canJoinForwards||(tr.join(after),!0)},toggleList$2=(listTypeOrName,itemTypeOrName)=>({editor:editor,tr:tr,state:state,dispatch:dispatch,chain:chain,commands:commands,can:can})=>{const{extensions:extensions}=editor.extensionManager,listType=getNodeType$2(listTypeOrName,state.schema),itemType=getNodeType$2(itemTypeOrName,state.schema),{selection:selection}=state,{$from:$from,$to:$to}=selection,range=$from.blockRange($to);if(!range)return!1;const parentList=findParentNode$2((node=>isList$2(node.type.name,extensions)))(selection);if(range.depth>=1&&parentList&&range.depth-parentList.depth<=1){
// remove list
if(parentList.node.type===listType)return commands.liftListItem(itemType);
// change list type
if(isList$2(parentList.node.type.name,extensions)&&listType.validContent(parentList.node.content)&&dispatch)return chain().command((()=>(tr.setNodeMarkup(parentList.pos,listType),!0))).command((()=>joinListBackwards$2(tr,listType))).command((()=>joinListForwards$2(tr,listType))).run()}return chain().command((()=>{const canWrapInList=can().wrapInList(listType);return!!canWrapInList||commands.clearNodes()})).wrapInList(listType).command((()=>joinListBackwards$2(tr,listType))).command((()=>joinListForwards$2(tr,listType))).run()};function isMarkActive$2(state,typeOrName,attributes={}){const{empty:empty,ranges:ranges}=state.selection,type=typeOrName?getMarkType$2(typeOrName,state.schema):null;if(empty)return!!(state.storedMarks||state.selection.$from.marks()).filter((mark=>!type||type.name===mark.type.name)).find((mark=>objectIncludes$2(mark.attrs,attributes,{strict:!1})));let selectionRange=0;const markRanges=[];if(ranges.forEach((({$from:$from,$to:$to})=>{const from=$from.pos,to=$to.pos;state.doc.nodesBetween(from,to,((node,pos)=>{if(!node.isText&&!node.marks.length)return;const relativeFrom=Math.max(from,pos),relativeTo=Math.min(to,pos+node.nodeSize),range=relativeTo-relativeFrom;selectionRange+=range,markRanges.push(...node.marks.map((mark=>({mark:mark,from:relativeFrom,to:relativeTo}))))}))})),0===selectionRange)return!1;
// calculate range of matched mark
const matchedRange=markRanges.filter((markRange=>!type||type.name===markRange.mark.type.name)).filter((markRange=>objectIncludes$2(markRange.mark.attrs,attributes,{strict:!1}))).reduce(((sum,markRange)=>sum+markRange.to-markRange.from),0),excludedRange=markRanges.filter((markRange=>!type||markRange.mark.type!==type&&markRange.mark.type.excludes(type))).reduce(((sum,markRange)=>sum+markRange.to-markRange.from),0),range=matchedRange>0?matchedRange+excludedRange:matchedRange;
// calculate range of marks that excludes the searched mark
// for example `code` doesn’t allow any other marks
return range>=selectionRange}const toggleMark$2=(typeOrName,attributes={},options={})=>({state:state,commands:commands})=>{const{extendEmptyMarkRange:extendEmptyMarkRange=!1}=options,type=getMarkType$2(typeOrName,state.schema),isActive=isMarkActive$2(state,type,attributes);return isActive?commands.unsetMark(type,{extendEmptyMarkRange:extendEmptyMarkRange}):commands.setMark(type,attributes)},toggleNode$2=(typeOrName,toggleTypeOrName,attributes={})=>({state:state,commands:commands})=>{const type=getNodeType$2(typeOrName,state.schema),toggleType=getNodeType$2(toggleTypeOrName,state.schema),isActive=isNodeActive$2(state,type,attributes);return isActive?commands.setNode(toggleType):commands.setNode(type,attributes)},toggleWrap$2=(typeOrName,attributes={})=>({state:state,commands:commands})=>{const type=getNodeType$2(typeOrName,state.schema),isActive=isNodeActive$2(state,type,attributes);return isActive?commands.lift(type):commands.wrapIn(type,attributes)},undoInputRule$2=()=>({state:state,dispatch:dispatch})=>{const plugins=state.plugins;for(let i=0;i<plugins.length;i+=1){const plugin=plugins[i];let undoable;
// @ts-ignore
// eslint-disable-next-line
if(plugin.spec.isInputRules&&(undoable=plugin.getState(state))){if(dispatch){const tr=state.tr,toUndo=undoable.transform;for(let j=toUndo.steps.length-1;j>=0;j-=1)tr.step(toUndo.steps[j].invert(toUndo.docs[j]));if(undoable.text){const marks=tr.doc.resolve(undoable.from).marks();tr.replaceWith(undoable.from,undoable.to,state.schema.text(undoable.text,marks))}else tr.delete(undoable.from,undoable.to)}return!0}}return!1},unsetAllMarks$2=()=>({tr:tr,dispatch:dispatch})=>{const{selection:selection}=tr,{empty:empty,ranges:ranges}=selection;return empty||dispatch&&ranges.forEach((range=>{tr.removeMark(range.$from.pos,range.$to.pos)})),!0},unsetMark$2=(typeOrName,options={})=>({tr:tr,state:state,dispatch:dispatch})=>{var _a;const{extendEmptyMarkRange:extendEmptyMarkRange=!1}=options,{selection:selection}=tr,type=getMarkType$2(typeOrName,state.schema),{$from:$from,empty:empty,ranges:ranges}=selection;if(!dispatch)return!0;if(empty&&extendEmptyMarkRange){let{from:from,to:to}=selection;const attrs=null===(_a=$from.marks().find((mark=>mark.type===type)))||void 0===_a?void 0:_a.attrs,range=getMarkRange$2($from,type,attrs);range&&(from=range.from,to=range.to),tr.removeMark(from,to,type)}else ranges.forEach((range=>{tr.removeMark(range.$from.pos,range.$to.pos,type)}));return tr.removeStoredMark(type),!0},updateAttributes$2=(typeOrName,attributes={})=>({tr:tr,state:state,dispatch:dispatch})=>{let nodeType=null,markType=null;const schemaType=getSchemaTypeNameByName$2("string"===typeof typeOrName?typeOrName:typeOrName.name,state.schema);return!!schemaType&&("node"===schemaType&&(nodeType=getNodeType$2(typeOrName,state.schema)),"mark"===schemaType&&(markType=getMarkType$2(typeOrName,state.schema)),dispatch&&tr.selection.ranges.forEach((range=>{const from=range.$from.pos,to=range.$to.pos;state.doc.nodesBetween(from,to,((node,pos)=>{nodeType&&nodeType===node.type&&tr.setNodeMarkup(pos,void 0,{...node.attrs,...attributes}),markType&&node.marks.length&&node.marks.forEach((mark=>{if(markType===mark.type){const trimmedFrom=Math.max(pos,from),trimmedTo=Math.min(pos+node.nodeSize,to);tr.addMark(trimmedFrom,trimmedTo,markType.create({...mark.attrs,...attributes}))}}))}))})),!0)},wrapIn$3=(typeOrName,attributes={})=>({state:state,dispatch:dispatch})=>{const type=getNodeType$2(typeOrName,state.schema);return wrapIn$1$2(type,attributes)(state,dispatch)},wrapInList$3=(typeOrName,attributes={})=>({state:state,dispatch:dispatch})=>{const type=getNodeType$2(typeOrName,state.schema);return wrapInList$1$2(type,attributes)(state,dispatch)};var commands$2=Object.freeze({__proto__:null,blur:blur$2,clearContent:clearContent$2,clearNodes:clearNodes$2,command:command$2,createParagraphNear:createParagraphNear$3,deleteNode:deleteNode$2,deleteRange:deleteRange$3,deleteSelection:deleteSelection$3,enter:enter$2,exitCode:exitCode$3,extendMarkRange:extendMarkRange$2,first:first$2,focus:focus$2,forEach:forEach$2,insertContent:insertContent$2,insertContentAt:insertContentAt$2,joinBackward:joinBackward$3,joinForward:joinForward$3,keyboardShortcut:keyboardShortcut$2,lift:lift$4,liftEmptyBlock:liftEmptyBlock$3,liftListItem:liftListItem$3,newlineInCode:newlineInCode$3,resetAttributes:resetAttributes$2,scrollIntoView:scrollIntoView$2,selectAll:selectAll$2,selectNodeBackward:selectNodeBackward$3,selectNodeForward:selectNodeForward$3,selectParentNode:selectParentNode$3,selectTextblockEnd:selectTextblockEnd$3,selectTextblockStart:selectTextblockStart$3,setContent:setContent$1$2,setMark:setMark$2,setMeta:setMeta$2,setNode:setNode$2,setNodeSelection:setNodeSelection$2,setTextSelection:setTextSelection$2,sinkListItem:sinkListItem$3,splitBlock:splitBlock$2,splitListItem:splitListItem$2,toggleList:toggleList$2,toggleMark:toggleMark$2,toggleNode:toggleNode$2,toggleWrap:toggleWrap$2,undoInputRule:undoInputRule$2,unsetAllMarks:unsetAllMarks$2,unsetMark:unsetMark$2,updateAttributes:updateAttributes$2,wrapIn:wrapIn$3,wrapInList:wrapInList$3});function getNodeAttributes$2(state,typeOrName){const type=getNodeType$2(typeOrName,state.schema),{from:from,to:to}=state.selection,nodes=[];state.doc.nodesBetween(from,to,(node=>{nodes.push(node)}));const node=nodes.reverse().find((nodeItem=>nodeItem.type.name===type.name));return node?{...node.attrs}:{}}function getAttributes$2(state,typeOrName){const schemaType=getSchemaTypeNameByName$2("string"===typeof typeOrName?typeOrName:typeOrName.name,state.schema);return"node"===schemaType?getNodeAttributes$2(state,typeOrName):"mark"===schemaType?getMarkAttributes$2(state,typeOrName):{}}
/**
 * Returns a new `Transform` based on all steps of the passed transactions.
 */function combineTransactionSteps$2(oldDoc,transactions){const transform=new Transform$2(oldDoc);return transactions.forEach((transaction=>{transaction.steps.forEach((step=>{transform.step(step)}))})),transform}
/**
 * Same as `findChildren` but searches only within a `range`.
 */function findChildrenInRange$2(node,range,predicate){const nodesWithPos=[];
// if (range.from === range.to) {
//   const nodeAt = node.nodeAt(range.from)
//   if (nodeAt) {
//     nodesWithPos.push({
//       node: nodeAt,
//       pos: range.from,
//     })
//   }
// }
return node.nodesBetween(range.from,range.to,((child,pos)=>{predicate(child)&&nodesWithPos.push({node:child,pos:pos})})),nodesWithPos}
/**
 * Removes duplicated values within an array.
 * Supports numbers, strings and objects.
 */function removeDuplicates$2(array,by=JSON.stringify){const seen={};return array.filter((item=>{const key=by(item);return!Object.prototype.hasOwnProperty.call(seen,key)&&(seen[key]=!0)}))}
/**
 * Removes duplicated ranges and ranges that are
 * fully captured by other ranges.
 */function simplifyChangedRanges$2(changes){const uniqueChanges=removeDuplicates$2(changes);return 1===uniqueChanges.length?uniqueChanges:uniqueChanges.filter(((change,index)=>{const rest=uniqueChanges.filter(((_,i)=>i!==index));return!rest.some((otherChange=>change.oldRange.from>=otherChange.oldRange.from&&change.oldRange.to<=otherChange.oldRange.to&&change.newRange.from>=otherChange.newRange.from&&change.newRange.to<=otherChange.newRange.to))}))}
/**
 * Returns a list of changed ranges
 * based on the first and last state of all steps.
 */function getChangedRanges$2(transform){const{mapping:mapping,steps:steps}=transform,changes=[];return mapping.maps.forEach(((stepMap,index)=>{const ranges=[];
// This accounts for step changes where no range was actually altered
// e.g. when setting a mark, node attribute, etc.
// @ts-ignore
if(stepMap.ranges.length)stepMap.forEach(((from,to)=>{ranges.push({from:from,to:to})}));else{const{from:from,to:to}=steps[index];if(void 0===from||void 0===to)return;ranges.push({from:from,to:to})}ranges.forEach((({from:from,to:to})=>{const newStart=mapping.slice(index).map(from,-1),newEnd=mapping.slice(index).map(to),oldStart=mapping.invert().map(newStart,-1),oldEnd=mapping.invert().map(newEnd);changes.push({oldRange:{from:oldStart,to:oldEnd},newRange:{from:newStart,to:newEnd}})}))})),simplifyChangedRanges$2(changes)}function getMarksBetween$2(from,to,doc){const marks=[];
// get all inclusive marks on empty selection
return from===to?doc.resolve(from).marks().forEach((mark=>{const $pos=doc.resolve(from-1),range=getMarkRange$2($pos,mark.type);range&&marks.push({mark:mark,...range})})):doc.nodesBetween(from,to,((node,pos)=>{marks.push(...node.marks.map((mark=>({from:pos,to:pos+node.nodeSize,mark:mark}))))})),marks}
/**
 * Build an input rule that adds a mark when the
 * matched text is typed into it.
 */function markInputRule$2(config){return new InputRule$2({find:config.find,handler:({state:state,range:range,match:match})=>{const attributes=callOrReturn$2(config.getAttributes,void 0,match);if(!1===attributes||null===attributes)return null;const{tr:tr}=state,captureGroup=match[match.length-1],fullMatch=match[0];let markEnd=range.to;if(captureGroup){const startSpaces=fullMatch.search(/\S/),textStart=range.from+fullMatch.indexOf(captureGroup),textEnd=textStart+captureGroup.length,excludedMarks=getMarksBetween$2(range.from,range.to,state.doc).filter((item=>{
// @ts-ignore
const excluded=item.mark.type.excluded;return excluded.find((type=>type===config.type&&type!==item.mark.type))})).filter((item=>item.to>textStart));if(excludedMarks.length)return null;textEnd<range.to&&tr.delete(textEnd,range.to),textStart>range.from&&tr.delete(range.from+startSpaces,textStart),markEnd=range.from+startSpaces+captureGroup.length,tr.addMark(range.from+startSpaces,markEnd,config.type.create(attributes||{})),tr.removeStoredMark(config.type)}}})}
/**
 * Build an input rule that adds a node when the
 * matched text is typed into it.
 */function nodeInputRule$2(config){return new InputRule$2({find:config.find,handler:({state:state,range:range,match:match})=>{const attributes=callOrReturn$2(config.getAttributes,void 0,match)||{},{tr:tr}=state,start=range.from;let end=range.to;if(match[1]){const offset=match[0].lastIndexOf(match[1]);let matchStart=start+offset;matchStart>end?matchStart=end:end=matchStart+match[1].length;
// insert last typed character
const lastChar=match[0][match[0].length-1];tr.insertText(lastChar,start+match[0].length-1),
// insert node from input rule
tr.replaceWith(matchStart,end,config.type.create(attributes))}else match[0]&&tr.replaceWith(start,end,config.type.create(attributes))}})}
/**
 * Build an input rule that changes the type of a textblock when the
 * matched text is typed into it. When using a regular expresion you’ll
 * probably want the regexp to start with `^`, so that the pattern can
 * only occur at the start of a textblock.
 */function textblockTypeInputRule$2(config){return new InputRule$2({find:config.find,handler:({state:state,range:range,match:match})=>{const $start=state.doc.resolve(range.from),attributes=callOrReturn$2(config.getAttributes,void 0,match)||{};if(!$start.node(-1).canReplaceWith($start.index(-1),$start.indexAfter(-1),config.type))return null;state.tr.delete(range.from,range.to).setBlockType(range.from,range.from,config.type,attributes)}})}
/**
 * Build an input rule for automatically wrapping a textblock when a
 * given string is typed. When using a regular expresion you’ll
 * probably want the regexp to start with `^`, so that the pattern can
 * only occur at the start of a textblock.
 *
 * `type` is the type of node to wrap in.
 *
 * By default, if there’s a node with the same type above the newly
 * wrapped node, the rule will try to join those
 * two nodes. You can pass a join predicate, which takes a regular
 * expression match and the node before the wrapped node, and can
 * return a boolean to indicate whether a join should happen.
 */function wrappingInputRule$2(config){return new InputRule$2({find:config.find,handler:({state:state,range:range,match:match})=>{const attributes=callOrReturn$2(config.getAttributes,void 0,match)||{},tr=state.tr.delete(range.from,range.to),$start=tr.doc.resolve(range.from),blockRange=$start.blockRange(),wrapping=blockRange&&findWrapping$2(blockRange,config.type,attributes);if(!wrapping)return null;tr.wrap(blockRange,wrapping);const before=tr.doc.resolve(range.from-1).nodeBefore;before&&before.type===config.type&&canJoin$2(tr.doc,range.from-1)&&(!config.joinPredicate||config.joinPredicate(match,before))&&tr.join(range.from-1)}})}Extension$2.create({name:"commands",addCommands(){return{...commands$2}}}),Extension$2.create({name:"editable",addProseMirrorPlugins(){return[new Plugin$2({key:new PluginKey$2("editable"),props:{editable:()=>this.editor.options.editable}})]}}),Extension$2.create({name:"focusEvents",addProseMirrorPlugins(){const{editor:editor}=this;return[new Plugin$2({key:new PluginKey$2("focusEvents"),props:{handleDOMEvents:{focus:(view,event)=>{editor.isFocused=!0;const transaction=editor.state.tr.setMeta("focus",{event:event}).setMeta("addToHistory",!1);return view.dispatch(transaction),!1},blur:(view,event)=>{editor.isFocused=!1;const transaction=editor.state.tr.setMeta("blur",{event:event}).setMeta("addToHistory",!1);return view.dispatch(transaction),!1}}}})]}}),Extension$2.create({name:"keymap",addKeyboardShortcuts(){const handleBackspace=()=>this.editor.commands.first((({commands:commands})=>[()=>commands.undoInputRule()
// maybe convert first text block node to default node
,()=>commands.command((({tr:tr})=>{const{selection:selection,doc:doc}=tr,{empty:empty,$anchor:$anchor}=selection,{pos:pos,parent:parent}=$anchor,isAtStart=Selection$2.atStart(doc).from===pos;return!(!(empty&&isAtStart&&parent.type.isTextblock)||parent.textContent.length)&&commands.clearNodes()})),()=>commands.deleteSelection(),()=>commands.joinBackward(),()=>commands.selectNodeBackward()])),handleDelete=()=>this.editor.commands.first((({commands:commands})=>[()=>commands.deleteSelection(),()=>commands.joinForward(),()=>commands.selectNodeForward()])),handleEnter=()=>this.editor.commands.first((({commands:commands})=>[()=>commands.newlineInCode(),()=>commands.createParagraphNear(),()=>commands.liftEmptyBlock(),()=>commands.splitBlock()])),baseKeymap={Enter:handleEnter,"Mod-Enter":()=>this.editor.commands.exitCode(),Backspace:handleBackspace,"Mod-Backspace":handleBackspace,"Shift-Backspace":handleBackspace,Delete:handleDelete,"Mod-Delete":handleDelete,"Mod-a":()=>this.editor.commands.selectAll()},pcKeymap={...baseKeymap},macKeymap={...baseKeymap,"Ctrl-h":handleBackspace,"Alt-Backspace":handleBackspace,"Ctrl-d":handleDelete,"Ctrl-Alt-Backspace":handleDelete,"Alt-Delete":handleDelete,"Alt-d":handleDelete,"Ctrl-a":()=>this.editor.commands.selectTextblockStart(),"Ctrl-e":()=>this.editor.commands.selectTextblockEnd()};return isiOS$2()||isMacOS$2()?macKeymap:pcKeymap},addProseMirrorPlugins(){return[
// With this plugin we check if the whole document was selected and deleted.
// In this case we will additionally call `clearNodes()` to convert e.g. a heading
// to a paragraph if necessary.
// This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
// with many other commands.
new Plugin$2({key:new PluginKey$2("clearDocument"),appendTransaction:(transactions,oldState,newState)=>{const docChanges=transactions.some((transaction=>transaction.docChanged))&&!oldState.doc.eq(newState.doc);if(!docChanges)return;const{empty:empty,from:from,to:to}=oldState.selection,allFrom=Selection$2.atStart(oldState.doc).from,allEnd=Selection$2.atEnd(oldState.doc).to,allWasSelected=from===allFrom&&to===allEnd,isEmpty=0===newState.doc.textBetween(0,newState.doc.content.size," "," ").length;if(empty||!allWasSelected||!isEmpty)return;const tr=newState.tr,state=createChainableState$2({state:newState,transaction:tr}),{commands:commands}=new CommandManager$2({editor:this.editor,state:state});return commands.clearNodes(),tr.steps.length?tr:void 0}})]}}),Extension$2.create({name:"tabindex",addProseMirrorPlugins(){return[new Plugin$2({key:new PluginKey$2("tabindex"),props:{attributes:this.editor.isEditable?{tabindex:"0"}:{}}})]}});class Mark$3{constructor(config={}){this.type="mark",this.name="mark",this.parent=null,this.child=null,this.config={name:this.name,defaultOptions:{}},this.config={...this.config,...config},this.name=this.config.name,config.defaultOptions,
// TODO: remove `addOptions` fallback
this.options=this.config.defaultOptions,this.config.addOptions&&(this.options=callOrReturn$2(getExtensionField$2(this,"addOptions",{name:this.name}))),this.storage=callOrReturn$2(getExtensionField$2(this,"addStorage",{name:this.name,options:this.options}))||{}}static create(config={}){return new Mark$3(config)}configure(options={}){
// return a new instance so we can use the same extension
// with different calls of `configure`
const extension=this.extend();return extension.options=mergeDeep$2(this.options,options),extension.storage=callOrReturn$2(getExtensionField$2(extension,"addStorage",{name:extension.name,options:extension.options})),extension}extend(extendedConfig={}){const extension=new Mark$3(extendedConfig);return extension.parent=this,this.child=extension,extension.name=extendedConfig.name?extendedConfig.name:extension.parent.name,extendedConfig.defaultOptions,extension.options=callOrReturn$2(getExtensionField$2(extension,"addOptions",{name:extension.name})),extension.storage=callOrReturn$2(getExtensionField$2(extension,"addStorage",{name:extension.name,options:extension.options})),extension}static handleExit({editor:editor,mark:mark}){const{tr:tr}=editor.state,currentPos=editor.state.selection.$from,isAtEnd=currentPos.pos===currentPos.end();if(isAtEnd){const currentMarks=currentPos.marks(),isInMark=!!currentMarks.find((m=>(null===m||void 0===m?void 0:m.type.name)===mark.name));if(!isInMark)return!1;const removeMark=currentMarks.find((m=>(null===m||void 0===m?void 0:m.type.name)===mark.name));return removeMark&&tr.removeStoredMark(removeMark),tr.insertText(" ",currentPos.pos),editor.view.dispatch(tr),!0}return!1}}class Node$1$2{constructor(config={}){this.type="node",this.name="node",this.parent=null,this.child=null,this.config={name:this.name,defaultOptions:{}},this.config={...this.config,...config},this.name=this.config.name,config.defaultOptions,
// TODO: remove `addOptions` fallback
this.options=this.config.defaultOptions,this.config.addOptions&&(this.options=callOrReturn$2(getExtensionField$2(this,"addOptions",{name:this.name}))),this.storage=callOrReturn$2(getExtensionField$2(this,"addStorage",{name:this.name,options:this.options}))||{}}static create(config={}){return new Node$1$2(config)}configure(options={}){
// return a new instance so we can use the same extension
// with different calls of `configure`
const extension=this.extend();return extension.options=mergeDeep$2(this.options,options),extension.storage=callOrReturn$2(getExtensionField$2(extension,"addStorage",{name:extension.name,options:extension.options})),extension}extend(extendedConfig={}){const extension=new Node$1$2(extendedConfig);return extension.parent=this,this.child=extension,extension.name=extendedConfig.name?extendedConfig.name:extension.parent.name,extendedConfig.defaultOptions,extension.options=callOrReturn$2(getExtensionField$2(extension,"addOptions",{name:extension.name})),extension.storage=callOrReturn$2(getExtensionField$2(extension,"addStorage",{name:extension.name,options:extension.options})),extension}}
/**
 * Build an paste rule that adds a mark when the
 * matched text is pasted into it.
 */function markPasteRule$2(config){return new PasteRule$2({find:config.find,handler:({state:state,range:range,match:match})=>{const attributes=callOrReturn$2(config.getAttributes,void 0,match);if(!1===attributes||null===attributes)return null;const{tr:tr}=state,captureGroup=match[match.length-1],fullMatch=match[0];let markEnd=range.to;if(captureGroup){const startSpaces=fullMatch.search(/\S/),textStart=range.from+fullMatch.indexOf(captureGroup),textEnd=textStart+captureGroup.length,excludedMarks=getMarksBetween$2(range.from,range.to,state.doc).filter((item=>{
// @ts-ignore
const excluded=item.mark.type.excluded;return excluded.find((type=>type===config.type&&type!==item.mark.type))})).filter((item=>item.to>textStart));if(excludedMarks.length)return null;textEnd<range.to&&tr.delete(textEnd,range.to),textStart>range.from&&tr.delete(range.from+startSpaces,textStart),markEnd=range.from+startSpaces+captureGroup.length,tr.addMark(range.from+startSpaces,markEnd,config.type.create(attributes||{})),tr.removeStoredMark(config.type)}}})}Node$1$2.create({name:"doc",topNode:!0,content:"block+"});const Paragraph$2=Node$1$2.create({name:"paragraph",priority:1e3,addOptions(){return{HTMLAttributes:{}}},group:"block",content:"inline*",parseHTML(){return[{tag:"p"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["p",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setParagraph:()=>({commands:commands})=>commands.setNode(this.name)}},addKeyboardShortcuts(){return{"Mod-Alt-0":()=>this.editor.commands.setParagraph()}}});Node$1$2.create({name:"text",group:"inline"});const starInputRegex$1$2=/(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/,starPasteRegex$1$2=/(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g,underscoreInputRegex$1$2=/(?:^|\s)((?:__)((?:[^__]+))(?:__))$/,underscorePasteRegex$1$2=/(?:^|\s)((?:__)((?:[^__]+))(?:__))/g;Mark$3.create({name:"bold",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"strong"},{tag:"b",getAttrs:node=>"normal"!==node.style.fontWeight&&null},{style:"font-weight",getAttrs:value=>/^(bold(er)?|[5-9]\d{2,})$/.test(value)&&null}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["strong",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setBold:()=>({commands:commands})=>commands.setMark(this.name),toggleBold:()=>({commands:commands})=>commands.toggleMark(this.name),unsetBold:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-b":()=>this.editor.commands.toggleBold(),"Mod-B":()=>this.editor.commands.toggleBold()}},addInputRules(){return[markInputRule$2({find:starInputRegex$1$2,type:this.type}),markInputRule$2({find:underscoreInputRegex$1$2,type:this.type})]},addPasteRules(){return[markPasteRule$2({find:starPasteRegex$1$2,type:this.type}),markPasteRule$2({find:underscorePasteRegex$1$2,type:this.type})]}});const starInputRegex$3=/(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/,starPasteRegex$3=/(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g,underscoreInputRegex$3=/(?:^|\s)((?:_)((?:[^_]+))(?:_))$/,underscorePasteRegex$3=/(?:^|\s)((?:_)((?:[^_]+))(?:_))/g;Mark$3.create({name:"italic",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"em"},{tag:"i",getAttrs:node=>"normal"!==node.style.fontStyle&&null},{style:"font-style=italic"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["em",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setItalic:()=>({commands:commands})=>commands.setMark(this.name),toggleItalic:()=>({commands:commands})=>commands.toggleMark(this.name),unsetItalic:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-i":()=>this.editor.commands.toggleItalic(),"Mod-I":()=>this.editor.commands.toggleItalic()}},addInputRules(){return[markInputRule$2({find:starInputRegex$3,type:this.type}),markInputRule$2({find:underscoreInputRegex$3,type:this.type})]},addPasteRules(){return[markPasteRule$2({find:starPasteRegex$3,type:this.type}),markPasteRule$2({find:underscorePasteRegex$3,type:this.type})]}}),Mark$3.create({name:"underline",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"u"},{style:"text-decoration",consuming:!1,getAttrs:style=>!!style.includes("underline")&&{}}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["u",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setUnderline:()=>({commands:commands})=>commands.setMark(this.name),toggleUnderline:()=>({commands:commands})=>commands.toggleMark(this.name),unsetUnderline:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-u":()=>this.editor.commands.toggleUnderline(),"Mod-U":()=>this.editor.commands.toggleUnderline()}}});const inputRegex$5$2=/(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/,pasteRegex$1$2=/(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g;Mark$3.create({name:"strike",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"s"},{tag:"del"},{tag:"strike"},{style:"text-decoration",consuming:!1,getAttrs:style=>!!style.includes("line-through")&&{}}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["s",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setStrike:()=>({commands:commands})=>commands.setMark(this.name),toggleStrike:()=>({commands:commands})=>commands.toggleMark(this.name),unsetStrike:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-Shift-x":()=>this.editor.commands.toggleStrike()}},addInputRules(){return[markInputRule$2({find:inputRegex$5$2,type:this.type})]},addPasteRules(){return[markPasteRule$2({find:pasteRegex$1$2,type:this.type})]}}),Node$1$2.create({name:"listItem",addOptions(){return{HTMLAttributes:{}}},content:"paragraph block*",defining:!0,parseHTML(){return[{tag:"li"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["li",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes),0]},addKeyboardShortcuts(){return{Enter:()=>this.editor.commands.splitListItem(this.name),Tab:()=>this.editor.commands.sinkListItem(this.name),"Shift-Tab":()=>this.editor.commands.liftListItem(this.name)}}});const inputRegex$4$2=/^\s*([-+*])\s$/;Node$1$2.create({name:"bulletList",addOptions(){return{itemTypeName:"listItem",HTMLAttributes:{}}},group:"block list",content(){return`${this.options.itemTypeName}+`},parseHTML(){return[{tag:"ul"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["ul",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{toggleBulletList:()=>({commands:commands})=>commands.toggleList(this.name,this.options.itemTypeName)}},addKeyboardShortcuts(){return{"Mod-Shift-8":()=>this.editor.commands.toggleBulletList()}},addInputRules(){return[wrappingInputRule$2({find:inputRegex$4$2,type:this.type})]}}),Mark$3.create({name:"textStyle",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"span",getAttrs:element=>{const hasStyles=element.hasAttribute("style");return!!hasStyles&&{}}}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["span",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{removeEmptyTextStyle:()=>({state:state,commands:commands})=>{const attributes=getMarkAttributes$2(state,this.type),hasStyles=Object.entries(attributes).some((([,value])=>!!value));return!!hasStyles||commands.unsetMark(this.name)}}}}),Extension$2.create({name:"fontFamily",addOptions(){return{types:["textStyle"]}},addGlobalAttributes(){return[{types:this.options.types,attributes:{fontFamily:{default:null,parseHTML:element=>{var _a;return null===(_a=element.style.fontFamily)||void 0===_a?void 0:_a.replace(/['"]+/g,"")},renderHTML:attributes=>attributes.fontFamily?{style:`font-family: ${attributes.fontFamily}`}:{}}}}]},addCommands(){return{setFontFamily:fontFamily=>({chain:chain})=>chain().setMark("textStyle",{fontFamily:fontFamily}).run(),unsetFontFamily:()=>({chain:chain})=>chain().setMark("textStyle",{fontFamily:null}).removeEmptyTextStyle().run()}}});const inputRegex$3$2=/^(\d+)\.\s$/;Node$1$2.create({name:"orderedList",addOptions(){return{itemTypeName:"listItem",HTMLAttributes:{}}},group:"block list",content(){return`${this.options.itemTypeName}+`},addAttributes(){return{start:{default:1,parseHTML:element=>element.hasAttribute("start")?parseInt(element.getAttribute("start")||"",10):1}}},parseHTML(){return[{tag:"ol"}]},renderHTML({HTMLAttributes:HTMLAttributes}){const{start:start,...attributesWithoutStart}=HTMLAttributes;return 1===start?["ol",mergeAttributes$2(this.options.HTMLAttributes,attributesWithoutStart),0]:["ol",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{toggleOrderedList:()=>({commands:commands})=>commands.toggleList(this.name,this.options.itemTypeName)}},addKeyboardShortcuts(){return{"Mod-Shift-7":()=>this.editor.commands.toggleOrderedList()}},addInputRules(){return[wrappingInputRule$2({find:inputRegex$3$2,type:this.type,getAttributes:match=>({start:+match[1]}),joinPredicate:(match,node)=>node.childCount+node.attrs.start===+match[1]})]}}),Node$1$2.create({name:"heading",addOptions(){return{levels:[1,2,3,4,5,6],HTMLAttributes:{}}},content:"inline*",group:"block",defining:!0,addAttributes(){return{level:{default:1,rendered:!1}}},parseHTML(){return this.options.levels.map((level=>({tag:`h${level}`,attrs:{level:level}})))},renderHTML({node:node,HTMLAttributes:HTMLAttributes}){const hasLevel=this.options.levels.includes(node.attrs.level),level=hasLevel?node.attrs.level:this.options.levels[0];return[`h${level}`,mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setHeading:attributes=>({commands:commands})=>!!this.options.levels.includes(attributes.level)&&commands.setNode(this.name,attributes),toggleHeading:attributes=>({commands:commands})=>!!this.options.levels.includes(attributes.level)&&commands.toggleNode(this.name,"paragraph",attributes)}},addKeyboardShortcuts(){return this.options.levels.reduce(((items,level)=>({...items,[`Mod-Alt-${level}`]:()=>this.editor.commands.toggleHeading({level:level})})),{})},addInputRules(){return this.options.levels.map((level=>textblockTypeInputRule$2({find:new RegExp(`^(#{1,${level}})\\s$`),type:this.type,getAttributes:{level:level}})))}});var GOOD_LEAF_SIZE$2=200,RopeSequence$2=function(){};
// :: class<T> A rope sequence is a persistent sequence data structure
// that supports appending, prepending, and slicing without doing a
// full copy. It is represented as a mostly-balanced tree.
RopeSequence$2.prototype.append=function(other){return other.length?(other=RopeSequence$2.from(other),!this.length&&other||other.length<GOOD_LEAF_SIZE$2&&this.leafAppend(other)||this.length<GOOD_LEAF_SIZE$2&&other.leafPrepend(this)||this.appendInner(other)):this},
// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>
// Prepend an array or other rope to this one, returning a new rope.
RopeSequence$2.prototype.prepend=function(other){return other.length?RopeSequence$2.from(other).append(this):this},RopeSequence$2.prototype.appendInner=function(other){return new Append$2(this,other)},
// :: (?number, ?number) → RopeSequence<T>
// Create a rope repesenting a sub-sequence of this rope.
RopeSequence$2.prototype.slice=function(from,to){return void 0===from&&(from=0),void 0===to&&(to=this.length),from>=to?RopeSequence$2.empty:this.sliceInner(Math.max(0,from),Math.min(this.length,to))},
// :: (number) → T
// Retrieve the element at the given position from this rope.
RopeSequence$2.prototype.get=function(i){if(!(i<0||i>=this.length))return this.getInner(i)},
// :: ((element: T, index: number) → ?bool, ?number, ?number)
// Call the given function for each element between the given
// indices. This tends to be more efficient than looping over the
// indices and calling `get`, because it doesn't have to descend the
// tree for every element.
RopeSequence$2.prototype.forEach=function(f,from,to){void 0===from&&(from=0),void 0===to&&(to=this.length),from<=to?this.forEachInner(f,from,to,0):this.forEachInvertedInner(f,from,to,0)},
// :: ((element: T, index: number) → U, ?number, ?number) → [U]
// Map the given functions over the elements of the rope, producing
// a flat array.
RopeSequence$2.prototype.map=function(f,from,to){void 0===from&&(from=0),void 0===to&&(to=this.length);var result=[];return this.forEach((function(elt,i){return result.push(f(elt,i))}),from,to),result},
// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>
// Create a rope representing the given array, or return the rope
// itself if a rope was given.
RopeSequence$2.from=function(values){return values instanceof RopeSequence$2?values:values&&values.length?new Leaf$2(values):RopeSequence$2.empty};var Leaf$2=function(RopeSequence){function Leaf(values){RopeSequence.call(this),this.values=values}RopeSequence&&(Leaf.__proto__=RopeSequence),Leaf.prototype=Object.create(RopeSequence&&RopeSequence.prototype),Leaf.prototype.constructor=Leaf;var prototypeAccessors={length:{configurable:!0},depth:{configurable:!0}};return Leaf.prototype.flatten=function(){return this.values},Leaf.prototype.sliceInner=function(from,to){return 0==from&&to==this.length?this:new Leaf(this.values.slice(from,to))},Leaf.prototype.getInner=function(i){return this.values[i]},Leaf.prototype.forEachInner=function(f,from,to,start){for(var i=from;i<to;i++)if(!1===f(this.values[i],start+i))return!1},Leaf.prototype.forEachInvertedInner=function(f,from,to,start){for(var i=from-1;i>=to;i--)if(!1===f(this.values[i],start+i))return!1},Leaf.prototype.leafAppend=function(other){if(this.length+other.length<=GOOD_LEAF_SIZE$2)return new Leaf(this.values.concat(other.flatten()))},Leaf.prototype.leafPrepend=function(other){if(this.length+other.length<=GOOD_LEAF_SIZE$2)return new Leaf(other.flatten().concat(this.values))},prototypeAccessors.length.get=function(){return this.values.length},prototypeAccessors.depth.get=function(){return 0},Object.defineProperties(Leaf.prototype,prototypeAccessors),Leaf}(RopeSequence$2);
// :: RopeSequence
// The empty rope sequence.
RopeSequence$2.empty=new Leaf$2([]);var Append$2=function(RopeSequence){function Append(left,right){RopeSequence.call(this),this.left=left,this.right=right,this.length=left.length+right.length,this.depth=Math.max(left.depth,right.depth)+1}return RopeSequence&&(Append.__proto__=RopeSequence),Append.prototype=Object.create(RopeSequence&&RopeSequence.prototype),Append.prototype.constructor=Append,Append.prototype.flatten=function(){return this.left.flatten().concat(this.right.flatten())},Append.prototype.getInner=function(i){return i<this.left.length?this.left.get(i):this.right.get(i-this.left.length)},Append.prototype.forEachInner=function(f,from,to,start){var leftLen=this.left.length;return!(from<leftLen&&!1===this.left.forEachInner(f,from,Math.min(to,leftLen),start))&&(!(to>leftLen&&!1===this.right.forEachInner(f,Math.max(from-leftLen,0),Math.min(this.length,to)-leftLen,start+leftLen))&&void 0)},Append.prototype.forEachInvertedInner=function(f,from,to,start){var leftLen=this.left.length;return!(from>leftLen&&!1===this.right.forEachInvertedInner(f,from-leftLen,Math.max(to,leftLen)-leftLen,start+leftLen))&&(!(to<leftLen&&!1===this.left.forEachInvertedInner(f,Math.min(from,leftLen),to,start))&&void 0)},Append.prototype.sliceInner=function(from,to){if(0==from&&to==this.length)return this;var leftLen=this.left.length;return to<=leftLen?this.left.slice(from,to):from>=leftLen?this.right.slice(from-leftLen,to-leftLen):this.left.slice(from,leftLen).append(this.right.slice(0,to-leftLen))},Append.prototype.leafAppend=function(other){var inner=this.right.leafAppend(other);if(inner)return new Append(this.left,inner)},Append.prototype.leafPrepend=function(other){var inner=this.left.leafPrepend(other);if(inner)return new Append(inner,this.right)},Append.prototype.appendInner=function(other){return this.left.depth>=Math.max(this.right.depth,other.depth)+1?new Append(this.left,new Append(this.right,other)):new Append(this,other)},Append}(RopeSequence$2),ropeSequence$2=RopeSequence$2;
// ProseMirror's history isn't simply a way to roll back to a previous
// state, because ProseMirror supports applying changes without adding
// them to the history (for example during collaboration).
// To this end, each 'Branch' (one for the undo history and one for
// the redo history) keeps an array of 'Items', which can optionally
// hold a step (an actual undoable change), and always hold a position
// map (which is needed to move changes below them to apply to the
// current document).
// An item that has both a step and a selection bookmark is the start
// of an 'event' — a group of changes that will be undone or redone at
// once. (It stores only the bookmark, since that way we don't have to
// provide a document until the selection is actually applied, which
// is useful when compressing.)
// Used to schedule history compression
const max_empty_items$2=500;class Branch$2{constructor(items,eventCount){this.items=items,this.eventCount=eventCount}
// Pop the latest event off the branch's history and apply it
// to a document transform.
popEvent(state,preserveItems){if(0==this.eventCount)return null;let remap,mapFrom,end=this.items.length;for(;;end--){let next=this.items.get(end-1);if(next.selection){--end;break}}preserveItems&&(remap=this.remapping(end,this.items.length),mapFrom=remap.maps.length);let selection,remaining,transform=state.tr,addAfter=[],addBefore=[];return this.items.forEach(((item,i)=>{if(!item.step)return remap||(remap=this.remapping(end,i+1),mapFrom=remap.maps.length),mapFrom--,void addBefore.push(item);if(remap){addBefore.push(new Item$2(item.map));let map,step=item.step.map(remap.slice(mapFrom));step&&transform.maybeStep(step).doc&&(map=transform.mapping.maps[transform.mapping.maps.length-1],addAfter.push(new Item$2(map,void 0,void 0,addAfter.length+addBefore.length))),mapFrom--,map&&remap.appendMap(map,mapFrom)}else transform.maybeStep(item.step);return item.selection?(selection=remap?item.selection.map(remap.slice(mapFrom)):item.selection,remaining=new Branch$2(this.items.slice(0,end).append(addBefore.reverse().concat(addAfter)),this.eventCount-1),!1):void 0}),this.items.length,0),{remaining:remaining,transform:transform,selection:selection}}
// Create a new branch with the given transform added.
addTransform(transform,selection,histOptions,preserveItems){let newItems=[],eventCount=this.eventCount,oldItems=this.items,lastItem=!preserveItems&&oldItems.length?oldItems.get(oldItems.length-1):null;for(let i=0;i<transform.steps.length;i++){let merged,step=transform.steps[i].invert(transform.docs[i]),item=new Item$2(transform.mapping.maps[i],step,selection);(merged=lastItem&&lastItem.merge(item))&&(item=merged,i?newItems.pop():oldItems=oldItems.slice(0,oldItems.length-1)),newItems.push(item),selection&&(eventCount++,selection=void 0),preserveItems||(lastItem=item)}let overflow=eventCount-histOptions.depth;return overflow>DEPTH_OVERFLOW$2&&(oldItems=cutOffEvents$2(oldItems,overflow),eventCount-=overflow),new Branch$2(oldItems.append(newItems),eventCount)}remapping(from,to){let maps=new Mapping$2;return this.items.forEach(((item,i)=>{let mirrorPos=null!=item.mirrorOffset&&i-item.mirrorOffset>=from?maps.maps.length-item.mirrorOffset:void 0;maps.appendMap(item.map,mirrorPos)}),from,to),maps}addMaps(array){return 0==this.eventCount?this:new Branch$2(this.items.append(array.map((map=>new Item$2(map)))),this.eventCount)}
// When the collab module receives remote changes, the history has
// to know about those, so that it can adjust the steps that were
// rebased on top of the remote changes, and include the position
// maps for the remote changes in its array of items.
rebased(rebasedTransform,rebasedCount){if(!this.eventCount)return this;let rebasedItems=[],start=Math.max(0,this.items.length-rebasedCount),mapping=rebasedTransform.mapping,newUntil=rebasedTransform.steps.length,eventCount=this.eventCount;this.items.forEach((item=>{item.selection&&eventCount--}),start);let iRebased=rebasedCount;this.items.forEach((item=>{let pos=mapping.getMirror(--iRebased);if(null==pos)return;newUntil=Math.min(newUntil,pos);let map=mapping.maps[pos];if(item.step){let step=rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]),selection=item.selection&&item.selection.map(mapping.slice(iRebased+1,pos));selection&&eventCount++,rebasedItems.push(new Item$2(map,step,selection))}else rebasedItems.push(new Item$2(map))}),start);let newMaps=[];for(let i=rebasedCount;i<newUntil;i++)newMaps.push(new Item$2(mapping.maps[i]));let items=this.items.slice(0,start).append(newMaps).append(rebasedItems),branch=new Branch$2(items,eventCount);return branch.emptyItemCount()>max_empty_items$2&&(branch=branch.compress(this.items.length-rebasedItems.length)),branch}emptyItemCount(){let count=0;return this.items.forEach((item=>{item.step||count++})),count}
// Compressing a branch means rewriting it to push the air (map-only
// items) out. During collaboration, these naturally accumulate
// because each remote change adds one. The `upto` argument is used
// to ensure that only the items below a given level are compressed,
// because `rebased` relies on a clean, untouched set of items in
// order to associate old items with rebased steps.
compress(upto=this.items.length){let remap=this.remapping(0,upto),mapFrom=remap.maps.length,items=[],events=0;return this.items.forEach(((item,i)=>{if(i>=upto)items.push(item),item.selection&&events++;else if(item.step){let step=item.step.map(remap.slice(mapFrom)),map=step&&step.getMap();if(mapFrom--,map&&remap.appendMap(map,mapFrom),step){let selection=item.selection&&item.selection.map(remap.slice(mapFrom));selection&&events++;let merged,newItem=new Item$2(map.invert(),step,selection),last=items.length-1;(merged=items.length&&items[last].merge(newItem))?items[last]=merged:items.push(newItem)}}else item.map&&mapFrom--}),this.items.length,0),new Branch$2(ropeSequence$2.from(items.reverse()),events)}}function cutOffEvents$2(items,n){let cutPoint;return items.forEach(((item,i)=>{if(item.selection&&0==n--)return cutPoint=i,!1})),items.slice(cutPoint)}Branch$2.empty=new Branch$2(ropeSequence$2.empty,0);class Item$2{constructor(
// The (forward) step map for this item.
map,
// The inverted step
step,
// If this is non-null, this item is the start of a group, and
// this selection is the starting selection for the group (the one
// that was active before the first step was applied)
selection,
// If this item is the inverse of a previous mapping on the stack,
// this points at the inverse's offset
mirrorOffset){this.map=map,this.step=step,this.selection=selection,this.mirrorOffset=mirrorOffset}merge(other){if(this.step&&other.step&&!other.selection){let step=other.step.merge(this.step);if(step)return new Item$2(step.getMap().invert(),step,this.selection)}}}
// The value of the state field that tracks undo/redo history for that
// state. Will be stored in the plugin state when the history plugin
// is active.
class HistoryState$2{constructor(done,undone,prevRanges,prevTime){this.done=done,this.undone=undone,this.prevRanges=prevRanges,this.prevTime=prevTime}}const DEPTH_OVERFLOW$2=20;
// Record a transformation in undo history.
function applyTransaction$2(history,state,tr,options){let rebased,historyTr=tr.getMeta(historyKey$2);if(historyTr)return historyTr.historyState;tr.getMeta(closeHistoryKey$2)&&(history=new HistoryState$2(history.done,history.undone,null,0));let appended=tr.getMeta("appendedTransaction");if(0==tr.steps.length)return history;if(appended&&appended.getMeta(historyKey$2))return appended.getMeta(historyKey$2).redo?new HistoryState$2(history.done.addTransform(tr,void 0,options,mustPreserveItems$2(state)),history.undone,rangesFor$2(tr.mapping.maps[tr.steps.length-1]),history.prevTime):new HistoryState$2(history.done,history.undone.addTransform(tr,void 0,options,mustPreserveItems$2(state)),null,history.prevTime);if(!1===tr.getMeta("addToHistory")||appended&&!1===appended.getMeta("addToHistory"))return(rebased=tr.getMeta("rebased"))?new HistoryState$2(history.done.rebased(tr,rebased),history.undone.rebased(tr,rebased),mapRanges$2(history.prevRanges,tr.mapping),history.prevTime):new HistoryState$2(history.done.addMaps(tr.mapping.maps),history.undone.addMaps(tr.mapping.maps),mapRanges$2(history.prevRanges,tr.mapping),history.prevTime);{
// Group transforms that occur in quick succession into one event.
let newGroup=0==history.prevTime||!appended&&(history.prevTime<(tr.time||0)-options.newGroupDelay||!isAdjacentTo$2(tr,history.prevRanges)),prevRanges=appended?mapRanges$2(history.prevRanges,tr.mapping):rangesFor$2(tr.mapping.maps[tr.steps.length-1]);return new HistoryState$2(history.done.addTransform(tr,newGroup?state.selection.getBookmark():void 0,options,mustPreserveItems$2(state)),Branch$2.empty,prevRanges,tr.time)}}function isAdjacentTo$2(transform,prevRanges){if(!prevRanges)return!1;if(!transform.docChanged)return!0;let adjacent=!1;return transform.mapping.maps[0].forEach(((start,end)=>{for(let i=0;i<prevRanges.length;i+=2)start<=prevRanges[i+1]&&end>=prevRanges[i]&&(adjacent=!0)})),adjacent}function rangesFor$2(map){let result=[];return map.forEach(((_from,_to,from,to)=>result.push(from,to))),result}function mapRanges$2(ranges,mapping){if(!ranges)return null;let result=[];for(let i=0;i<ranges.length;i+=2){let from=mapping.map(ranges[i],1),to=mapping.map(ranges[i+1],-1);from<=to&&result.push(from,to)}return result}
// Apply the latest event from one branch to the document and shift the event
// onto the other branch.
function histTransaction$2(history,state,dispatch,redo){let preserveItems=mustPreserveItems$2(state),histOptions=historyKey$2.get(state).spec.config,pop=(redo?history.undone:history.done).popEvent(state,preserveItems);if(!pop)return;let selection=pop.selection.resolve(pop.transform.doc),added=(redo?history.done:history.undone).addTransform(pop.transform,state.selection.getBookmark(),histOptions,preserveItems),newHist=new HistoryState$2(redo?added:pop.remaining,redo?pop.remaining:added,null,0);dispatch(pop.transform.setSelection(selection).setMeta(historyKey$2,{redo:redo,historyState:newHist}).scrollIntoView())}let cachedPreserveItems$2=!1,cachedPreserveItemsPlugins$2=null;
// Check whether any plugin in the given state has a
// `historyPreserveItems` property in its spec, in which case we must
// preserve steps exactly as they came in, so that they can be
// rebased.
function mustPreserveItems$2(state){let plugins=state.plugins;if(cachedPreserveItemsPlugins$2!=plugins){cachedPreserveItems$2=!1,cachedPreserveItemsPlugins$2=plugins;for(let i=0;i<plugins.length;i++)if(plugins[i].spec.historyPreserveItems){cachedPreserveItems$2=!0;break}}return cachedPreserveItems$2}const historyKey$2=new PluginKey$2("history"),closeHistoryKey$2=new PluginKey$2("closeHistory");
/**
Returns a plugin that enables the undo history for an editor. The
plugin will track undo and redo stacks, which can be used with the
[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.

You can set an `"addToHistory"` [metadata
property](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction
to prevent it from being rolled back by undo.
*/
function history$2(config={}){return config={depth:config.depth||100,newGroupDelay:config.newGroupDelay||500},new Plugin$2({key:historyKey$2,state:{init(){return new HistoryState$2(Branch$2.empty,Branch$2.empty,null,0)},apply(tr,hist,state){return applyTransaction$2(hist,state,tr,config)}},config:config,props:{handleDOMEvents:{beforeinput(view,e){let inputType=e.inputType,command="historyUndo"==inputType?undo$2:"historyRedo"==inputType?redo$2:null;return!!command&&(e.preventDefault(),command(view.state,view.dispatch))}}}})}
/**
A command function that undoes the last change, if any.
*/const undo$2=(state,dispatch)=>{let hist=historyKey$2.getState(state);return!(!hist||0==hist.done.eventCount)&&(dispatch&&histTransaction$2(hist,state,dispatch,!1),!0)},redo$2=(state,dispatch)=>{let hist=historyKey$2.getState(state);return!(!hist||0==hist.undone.eventCount)&&(dispatch&&histTransaction$2(hist,state,dispatch,!0),!0)};
/**
A command function that redoes the last undone change, if any.
*/
// Because working with row and column-spanning cells is not quite
// trivial, this code builds up a descriptive structure for a given
// table node. The structures are cached with the (persistent) table
// nodes as key, so that they only have to be recomputed when the
// content of the table changes.
// This does mean that they have to store table-relative, not
// document-relative positions. So code that uses them will typically
// compute the start position of the table and offset positions passed
// to or gotten from this structure by that amount.
let readFromCache$2,addToCache$2;// Prefer using a weak map to cache table maps. Fall back on a
// fixed-size cache if that's not supported.
if(Extension$2.create({name:"history",addOptions(){return{depth:100,newGroupDelay:500}},addCommands(){return{undo:()=>({state:state,dispatch:dispatch})=>undo$2(state,dispatch),redo:()=>({state:state,dispatch:dispatch})=>redo$2(state,dispatch)}},addProseMirrorPlugins(){return[history$2(this.options)]},addKeyboardShortcuts(){return{"Mod-z":()=>this.editor.commands.undo(),"Mod-y":()=>this.editor.commands.redo(),"Shift-Mod-z":()=>this.editor.commands.redo()
// Russian keyboard layouts
,"Mod-я":()=>this.editor.commands.undo(),"Shift-Mod-я":()=>this.editor.commands.redo()}}}),Extension$2.create({name:"textAlign",addOptions(){return{types:[],alignments:["left","center","right","justify"],defaultAlignment:"left"}},addGlobalAttributes(){return[{types:this.options.types,attributes:{textAlign:{default:this.options.defaultAlignment,parseHTML:element=>element.style.textAlign||this.options.defaultAlignment,renderHTML:attributes=>attributes.textAlign===this.options.defaultAlignment?{}:{style:`text-align: ${attributes.textAlign}`}}}}]},addCommands(){return{setTextAlign:alignment=>({commands:commands})=>!!this.options.alignments.includes(alignment)&&this.options.types.every((type=>commands.updateAttributes(type,{textAlign:alignment}))),unsetTextAlign:()=>({commands:commands})=>this.options.types.every((type=>commands.resetAttributes(type,"textAlign")))}},addKeyboardShortcuts(){return{"Mod-Shift-l":()=>this.editor.commands.setTextAlign("left"),"Mod-Shift-e":()=>this.editor.commands.setTextAlign("center"),"Mod-Shift-r":()=>this.editor.commands.setTextAlign("right"),"Mod-Shift-j":()=>this.editor.commands.setTextAlign("justify")}}}),"undefined"!=typeof WeakMap){
// eslint-disable-next-line
let cache=new WeakMap;readFromCache$2=key=>cache.get(key),addToCache$2=(key,value)=>(cache.set(key,value),value)}else{let cache=[],cacheSize=10,cachePos=0;readFromCache$2=key=>{for(let i=0;i<cache.length;i+=2)if(cache[i]==key)return cache[i+1]},addToCache$2=(key,value)=>(cachePos==cacheSize&&(cachePos=0),cache[cachePos++]=key,cache[cachePos++]=value)}class Rect$2{constructor(left,top,right,bottom){this.left=left,this.top=top,this.right=right,this.bottom=bottom}}// ::- A table map describes the structore of a given table. To avoid
// recomputing them all the time, they are cached per table node. To
// be able to do that, positions saved in the map are relative to the
// start of the table, rather than the start of the document.
class TableMap$2{constructor(width,height,map,problems){
// :: number The width of the table
this.width=width,// :: number The table's height
this.height=height,// :: [number] A width * height array with the start position of
// the cell covering that part of the table in each slot
this.map=map,// An optional array of problems (cell overlap or non-rectangular
// shape) for the table, used by the table normalizer.
this.problems=problems}// :: (number) → Rect
// Find the dimensions of the cell at the given position.
findCell(pos){for(let i=0;i<this.map.length;i++){let curPos=this.map[i];if(curPos!=pos)continue;let left=i%this.width,top=i/this.width|0,right=left+1,bottom=top+1;for(let j=1;right<this.width&&this.map[i+j]==curPos;j++)right++;for(let j=1;bottom<this.height&&this.map[i+this.width*j]==curPos;j++)bottom++;return new Rect$2(left,top,right,bottom)}throw new RangeError("No cell with offset "+pos+" found")}// :: (number) → number
// Find the left side of the cell at the given position.
colCount(pos){for(let i=0;i<this.map.length;i++)if(this.map[i]==pos)return i%this.width;throw new RangeError("No cell with offset "+pos+" found")}// :: (number, string, number) → ?number
// Find the next cell in the given direction, starting from the cell
// at `pos`, if any.
nextCell(pos,axis,dir){let{left:left,right:right,top:top,bottom:bottom}=this.findCell(pos);return"horiz"==axis?(dir<0?0==left:right==this.width)?null:this.map[top*this.width+(dir<0?left-1:right)]:(dir<0?0==top:bottom==this.height)?null:this.map[left+this.width*(dir<0?top-1:bottom)]}// :: (number, number) → Rect
// Get the rectangle spanning the two given cells.
rectBetween(a,b){let{left:leftA,right:rightA,top:topA,bottom:bottomA}=this.findCell(a),{left:leftB,right:rightB,top:topB,bottom:bottomB}=this.findCell(b);return new Rect$2(Math.min(leftA,leftB),Math.min(topA,topB),Math.max(rightA,rightB),Math.max(bottomA,bottomB))}// :: (Rect) → [number]
// Return the position of all cells that have the top left corner in
// the given rectangle.
cellsInRect(rect){let result=[],seen={};for(let row=rect.top;row<rect.bottom;row++)for(let col=rect.left;col<rect.right;col++){let index=row*this.width+col,pos=this.map[index];seen[pos]||(seen[pos]=!0,col==rect.left&&col&&this.map[index-1]==pos||row==rect.top&&row&&this.map[index-this.width]==pos||result.push(pos))}return result}// :: (number, number, Node) → number
// Return the position at which the cell at the given row and column
// starts, or would start, if a cell started there.
positionAt(row,col,table){for(let i=0,rowStart=0;;i++){let rowEnd=rowStart+table.child(i).nodeSize;if(i==row){let index=col+row*this.width,rowEndIndex=(row+1)*this.width;// Skip past cells from previous rows (via rowspan)
while(index<rowEndIndex&&this.map[index]<rowStart)index++;return index==rowEndIndex?rowEnd-1:this.map[index]}rowStart=rowEnd}}// :: (Node) → TableMap
// Find the table map for the given table node.
static get(table){return readFromCache$2(table)||addToCache$2(table,computeMap$2(table))}}// Compute a table map.
function computeMap$2(table){if("table"!=table.type.spec.tableRole)throw new RangeError("Not a table node: "+table.type.name);let width=findWidth$2(table),height=table.childCount,map=[],mapPos=0,problems=null,colWidths=[];for(let i=0,e=width*height;i<e;i++)map[i]=0;for(let row=0,pos=0;row<height;row++){let rowNode=table.child(row);pos++;for(let i=0;;i++){while(mapPos<map.length&&0!=map[mapPos])mapPos++;if(i==rowNode.childCount)break;let cellNode=rowNode.child(i),{colspan:colspan,rowspan:rowspan,colwidth:colwidth}=cellNode.attrs;for(let h=0;h<rowspan;h++){if(h+row>=height){(problems||(problems=[])).push({type:"overlong_rowspan",pos:pos,n:rowspan-h});break}let start=mapPos+h*width;for(let w=0;w<colspan;w++){0==map[start+w]?map[start+w]=pos:(problems||(problems=[])).push({type:"collision",row:row,pos:pos,n:colspan-w});let colW=colwidth&&colwidth[w];if(colW){let widthIndex=(start+w)%width*2,prev=colWidths[widthIndex];null==prev||prev!=colW&&1==colWidths[widthIndex+1]?(colWidths[widthIndex]=colW,colWidths[widthIndex+1]=1):prev==colW&&colWidths[widthIndex+1]++}}}mapPos+=colspan,pos+=cellNode.nodeSize}let expectedPos=(row+1)*width,missing=0;while(mapPos<expectedPos)0==map[mapPos++]&&missing++;missing&&(problems||(problems=[])).push({type:"missing",row:row,n:missing}),pos++}let tableMap=new TableMap$2(width,height,map,problems),badWidths=!1;// For columns that have defined widths, but whose widths disagree
// between rows, fix up the cells whose width doesn't match the
// computed one.
for(let i=0;!badWidths&&i<colWidths.length;i+=2)null!=colWidths[i]&&colWidths[i+1]<height&&(badWidths=!0);return badWidths&&findBadColWidths$2(tableMap,colWidths,table),tableMap}function findWidth$2(table){let width=-1,hasRowSpan=!1;for(let row=0;row<table.childCount;row++){let rowNode=table.child(row),rowWidth=0;if(hasRowSpan)for(let j=0;j<row;j++){let prevRow=table.child(j);for(let i=0;i<prevRow.childCount;i++){let cell=prevRow.child(i);j+cell.attrs.rowspan>row&&(rowWidth+=cell.attrs.colspan)}}for(let i=0;i<rowNode.childCount;i++){let cell=rowNode.child(i);rowWidth+=cell.attrs.colspan,cell.attrs.rowspan>1&&(hasRowSpan=!0)}-1==width?width=rowWidth:width!=rowWidth&&(width=Math.max(width,rowWidth))}return width}function findBadColWidths$2(map,colWidths,table){map.problems||(map.problems=[]);for(let i=0,seen={};i<map.map.length;i++){let pos=map.map[i];if(seen[pos])continue;seen[pos]=!0;let node=table.nodeAt(pos),updated=null;for(let j=0;j<node.attrs.colspan;j++){let col=(i+j)%map.width,colWidth=colWidths[2*col];null==colWidth||node.attrs.colwidth&&node.attrs.colwidth[j]==colWidth||((updated||(updated=freshColWidth$2(node.attrs)))[j]=colWidth)}updated&&map.problems.unshift({type:"colwidth mismatch",pos:pos,colwidth:updated})}}function freshColWidth$2(attrs){if(attrs.colwidth)return attrs.colwidth.slice();let result=[];for(let i=0;i<attrs.colspan;i++)result.push(0);return result}function tableNodeTypes$2(schema){let result=schema.cached.tableNodeTypes;if(!result){result=schema.cached.tableNodeTypes={};for(let name in schema.nodes){let type=schema.nodes[name],role=type.spec.tableRole;role&&(result[role]=type)}}return result}
// Various helper function for working with tables
const key$1$2=new PluginKey$2("selectingCells");function cellAround$2($pos){for(let d=$pos.depth-1;d>0;d--)if("row"==$pos.node(d).type.spec.tableRole)return $pos.node(0).resolve($pos.before(d+1));return null}function cellWrapping$2($pos){for(let d=$pos.depth;d>0;d--){
// Sometimes the cell can be in the same depth.
const role=$pos.node(d).type.spec.tableRole;if("cell"===role||"header_cell"===role)return $pos.node(d)}return null}function isInTable$2(state){let $head=state.selection.$head;for(let d=$head.depth;d>0;d--)if("row"==$head.node(d).type.spec.tableRole)return!0;return!1}function selectionCell$2(state){let sel=state.selection;return sel.$anchorCell?sel.$anchorCell.pos>sel.$headCell.pos?sel.$anchorCell:sel.$headCell:sel.node&&"cell"==sel.node.type.spec.tableRole?sel.$anchor:cellAround$2(sel.$head)||cellNear$2(sel.$head)}function cellNear$2($pos){for(let after=$pos.nodeAfter,pos=$pos.pos;after;after=after.firstChild,pos++){let role=after.type.spec.tableRole;if("cell"==role||"header_cell"==role)return $pos.doc.resolve(pos)}for(let before=$pos.nodeBefore,pos=$pos.pos;before;before=before.lastChild,pos--){let role=before.type.spec.tableRole;if("cell"==role||"header_cell"==role)return $pos.doc.resolve(pos-before.nodeSize)}}function pointsAtCell$2($pos){return"row"==$pos.parent.type.spec.tableRole&&$pos.nodeAfter}function moveCellForward$2($pos){return $pos.node(0).resolve($pos.pos+$pos.nodeAfter.nodeSize)}function inSameTable$2($a,$b){return $a.depth==$b.depth&&$a.pos>=$b.start(-1)&&$a.pos<=$b.end(-1)}function nextCell$2($pos,axis,dir){let start=$pos.start(-1),map=TableMap$2.get($pos.node(-1)),moved=map.nextCell($pos.pos-start,axis,dir);return null==moved?null:$pos.node(0).resolve(start+moved)}function setAttr$2(attrs,name,value){let result={};for(let prop in attrs)result[prop]=attrs[prop];return result[name]=value,result}function removeColSpan$2(attrs,pos,n=1){let result=setAttr$2(attrs,"colspan",attrs.colspan-n);return result.colwidth&&(result.colwidth=result.colwidth.slice(),result.colwidth.splice(pos,n),result.colwidth.some((w=>w>0))||(result.colwidth=null)),result}function addColSpan$2(attrs,pos,n=1){let result=setAttr$2(attrs,"colspan",attrs.colspan+n);if(result.colwidth){result.colwidth=result.colwidth.slice();for(let i=0;i<n;i++)result.colwidth.splice(pos,0,0)}return result}function columnIsHeader$2(map,table,col){let headerCell=tableNodeTypes$2(table.type.schema).header_cell;for(let row=0;row<map.height;row++)if(table.nodeAt(map.map[col+row*map.width]).type!=headerCell)return!1;return!0}
// This file defines a ProseMirror selection subclass that models
// subclass that represents a cell selection spanning part of a table.
// With the plugin enabled, these will be created when the user
// selects across cells, and will be drawn by giving selected cells a
// `selectedCell` CSS class.
class CellSelection$2 extends Selection$2{
// :: (ResolvedPos, ?ResolvedPos)
// A table selection is identified by its anchor and head cells. The
// positions given to this constructor should point _before_ two
// cells in the same table. They may be the same, to select a single
// cell.
constructor($anchorCell,$headCell=$anchorCell){let table=$anchorCell.node(-1),map=TableMap$2.get(table),start=$anchorCell.start(-1),rect=map.rectBetween($anchorCell.pos-start,$headCell.pos-start),doc=$anchorCell.node(0),cells=map.cellsInRect(rect).filter((p=>p!=$headCell.pos-start));// Make the head cell the first range, so that it counts as the
// primary part of the selection
cells.unshift($headCell.pos-start);let ranges=cells.map((pos=>{let cell=table.nodeAt(pos),from=pos+start+1;return new SelectionRange$2(doc.resolve(from),doc.resolve(from+cell.content.size))}));super(ranges[0].$from,ranges[0].$to,ranges),// :: ResolvedPos
// A resolved position pointing _in front of_ the anchor cell (the one
// that doesn't move when extending the selection).
this.$anchorCell=$anchorCell,// :: ResolvedPos
// A resolved position pointing in front of the head cell (the one
// moves when extending the selection).
this.$headCell=$headCell}map(doc,mapping){let $anchorCell=doc.resolve(mapping.map(this.$anchorCell.pos)),$headCell=doc.resolve(mapping.map(this.$headCell.pos));if(pointsAtCell$2($anchorCell)&&pointsAtCell$2($headCell)&&inSameTable$2($anchorCell,$headCell)){let tableChanged=this.$anchorCell.node(-1)!=$anchorCell.node(-1);return tableChanged&&this.isRowSelection()?CellSelection$2.rowSelection($anchorCell,$headCell):tableChanged&&this.isColSelection()?CellSelection$2.colSelection($anchorCell,$headCell):new CellSelection$2($anchorCell,$headCell)}return TextSelection$2.between($anchorCell,$headCell)}// :: () → Slice
// Returns a rectangular slice of table rows containing the selected
// cells.
content(){let table=this.$anchorCell.node(-1),map=TableMap$2.get(table),start=this.$anchorCell.start(-1),rect=map.rectBetween(this.$anchorCell.pos-start,this.$headCell.pos-start),seen={},rows=[];for(let row=rect.top;row<rect.bottom;row++){let rowContent=[];for(let index=row*map.width+rect.left,col=rect.left;col<rect.right;col++,index++){let pos=map.map[index];if(!seen[pos]){seen[pos]=!0;let cellRect=map.findCell(pos),cell=table.nodeAt(pos),extraLeft=rect.left-cellRect.left,extraRight=cellRect.right-rect.right;if(extraLeft>0||extraRight>0){let attrs=cell.attrs;extraLeft>0&&(attrs=removeColSpan$2(attrs,0,extraLeft)),extraRight>0&&(attrs=removeColSpan$2(attrs,attrs.colspan-extraRight,extraRight)),cell=cellRect.left<rect.left?cell.type.createAndFill(attrs):cell.type.create(attrs,cell.content)}if(cellRect.top<rect.top||cellRect.bottom>rect.bottom){let attrs=setAttr$2(cell.attrs,"rowspan",Math.min(cellRect.bottom,rect.bottom)-Math.max(cellRect.top,rect.top));cell=cellRect.top<rect.top?cell.type.createAndFill(attrs):cell.type.create(attrs,cell.content)}rowContent.push(cell)}}rows.push(table.child(row).copy(Fragment$2.from(rowContent)))}const fragment=this.isColSelection()&&this.isRowSelection()?table:rows;return new Slice$2(Fragment$2.from(fragment),1,1)}replace(tr,content=Slice$2.empty){let mapFrom=tr.steps.length,ranges=this.ranges;for(let i=0;i<ranges.length;i++){let{$from:$from,$to:$to}=ranges[i],mapping=tr.mapping.slice(mapFrom);tr.replace(mapping.map($from.pos),mapping.map($to.pos),i?Slice$2.empty:content)}let sel=Selection$2.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),-1);sel&&tr.setSelection(sel)}replaceWith(tr,node){this.replace(tr,new Slice$2(Fragment$2.from(node),0,0))}forEachCell(f){let table=this.$anchorCell.node(-1),map=TableMap$2.get(table),start=this.$anchorCell.start(-1),cells=map.cellsInRect(map.rectBetween(this.$anchorCell.pos-start,this.$headCell.pos-start));for(let i=0;i<cells.length;i++)f(table.nodeAt(cells[i]),start+cells[i])}// :: () → bool
// True if this selection goes all the way from the top to the
// bottom of the table.
isColSelection(){let anchorTop=this.$anchorCell.index(-1),headTop=this.$headCell.index(-1);if(Math.min(anchorTop,headTop)>0)return!1;let anchorBot=anchorTop+this.$anchorCell.nodeAfter.attrs.rowspan,headBot=headTop+this.$headCell.nodeAfter.attrs.rowspan;return Math.max(anchorBot,headBot)==this.$headCell.node(-1).childCount}// :: (ResolvedPos, ?ResolvedPos) → CellSelection
// Returns the smallest column selection that covers the given anchor
// and head cell.
static colSelection($anchorCell,$headCell=$anchorCell){let map=TableMap$2.get($anchorCell.node(-1)),start=$anchorCell.start(-1),anchorRect=map.findCell($anchorCell.pos-start),headRect=map.findCell($headCell.pos-start),doc=$anchorCell.node(0);return anchorRect.top<=headRect.top?(anchorRect.top>0&&($anchorCell=doc.resolve(start+map.map[anchorRect.left])),headRect.bottom<map.height&&($headCell=doc.resolve(start+map.map[map.width*(map.height-1)+headRect.right-1]))):(headRect.top>0&&($headCell=doc.resolve(start+map.map[headRect.left])),anchorRect.bottom<map.height&&($anchorCell=doc.resolve(start+map.map[map.width*(map.height-1)+anchorRect.right-1]))),new CellSelection$2($anchorCell,$headCell)}// :: () → bool
// True if this selection goes all the way from the left to the
// right of the table.
isRowSelection(){let map=TableMap$2.get(this.$anchorCell.node(-1)),start=this.$anchorCell.start(-1),anchorLeft=map.colCount(this.$anchorCell.pos-start),headLeft=map.colCount(this.$headCell.pos-start);if(Math.min(anchorLeft,headLeft)>0)return!1;let anchorRight=anchorLeft+this.$anchorCell.nodeAfter.attrs.colspan,headRight=headLeft+this.$headCell.nodeAfter.attrs.colspan;return Math.max(anchorRight,headRight)==map.width}eq(other){return other instanceof CellSelection$2&&other.$anchorCell.pos==this.$anchorCell.pos&&other.$headCell.pos==this.$headCell.pos}// :: (ResolvedPos, ?ResolvedPos) → CellSelection
// Returns the smallest row selection that covers the given anchor
// and head cell.
static rowSelection($anchorCell,$headCell=$anchorCell){let map=TableMap$2.get($anchorCell.node(-1)),start=$anchorCell.start(-1),anchorRect=map.findCell($anchorCell.pos-start),headRect=map.findCell($headCell.pos-start),doc=$anchorCell.node(0);return anchorRect.left<=headRect.left?(anchorRect.left>0&&($anchorCell=doc.resolve(start+map.map[anchorRect.top*map.width])),headRect.right<map.width&&($headCell=doc.resolve(start+map.map[map.width*(headRect.top+1)-1]))):(headRect.left>0&&($headCell=doc.resolve(start+map.map[headRect.top*map.width])),anchorRect.right<map.width&&($anchorCell=doc.resolve(start+map.map[map.width*(anchorRect.top+1)-1]))),new CellSelection$2($anchorCell,$headCell)}toJSON(){return{type:"cell",anchor:this.$anchorCell.pos,head:this.$headCell.pos}}static fromJSON(doc,json){return new CellSelection$2(doc.resolve(json.anchor),doc.resolve(json.head))}// :: (Node, number, ?number) → CellSelection
static create(doc,anchorCell,headCell=anchorCell){return new CellSelection$2(doc.resolve(anchorCell),doc.resolve(headCell))}getBookmark(){return new CellBookmark$2(this.$anchorCell.pos,this.$headCell.pos)}}CellSelection$2.prototype.visible=!1,Selection$2.jsonID("cell",CellSelection$2);class CellBookmark$2{constructor(anchor,head){this.anchor=anchor,this.head=head}map(mapping){return new CellBookmark$2(mapping.map(this.anchor),mapping.map(this.head))}resolve(doc){let $anchorCell=doc.resolve(this.anchor),$headCell=doc.resolve(this.head);return"row"==$anchorCell.parent.type.spec.tableRole&&"row"==$headCell.parent.type.spec.tableRole&&$anchorCell.index()<$anchorCell.parent.childCount&&$headCell.index()<$headCell.parent.childCount&&inSameTable$2($anchorCell,$headCell)?new CellSelection$2($anchorCell,$headCell):Selection$2.near($headCell,1)}}function drawCellSelection$2(state){if(!(state.selection instanceof CellSelection$2))return null;let cells=[];return state.selection.forEachCell(((node,pos)=>{cells.push(Decoration$2.node(pos,pos+node.nodeSize,{class:"selectedCell"}))})),DecorationSet$2.create(state.doc,cells)}function isCellBoundarySelection$2({$from:$from,$to:$to}){if($from.pos==$to.pos||$from.pos<$from.pos-6)return!1;// Cheap elimination
let afterFrom=$from.pos,beforeTo=$to.pos,depth=$from.depth;for(;depth>=0;depth--,afterFrom++)if($from.after(depth+1)<$from.end(depth))break;for(let d=$to.depth;d>=0;d--,beforeTo--)if($to.before(d+1)>$to.start(d))break;return afterFrom==beforeTo&&/row|table/.test($from.node(depth).type.spec.tableRole)}function isTextSelectionAcrossCells$2({$from:$from,$to:$to}){let fromCellBoundaryNode,toCellBoundaryNode;for(let i=$from.depth;i>0;i--){let node=$from.node(i);if("cell"===node.type.spec.tableRole||"header_cell"===node.type.spec.tableRole){fromCellBoundaryNode=node;break}}for(let i=$to.depth;i>0;i--){let node=$to.node(i);if("cell"===node.type.spec.tableRole||"header_cell"===node.type.spec.tableRole){toCellBoundaryNode=node;break}}return fromCellBoundaryNode!==toCellBoundaryNode&&0===$to.parentOffset}function normalizeSelection$2(state,tr,allowTableNodeSelection){let normalize,role,sel=(tr||state).selection,doc=(tr||state).doc;if(sel instanceof NodeSelection$2&&(role=sel.node.type.spec.tableRole)){if("cell"==role||"header_cell"==role)normalize=CellSelection$2.create(doc,sel.from);else if("row"==role){let $cell=doc.resolve(sel.from+1);normalize=CellSelection$2.rowSelection($cell,$cell)}else if(!allowTableNodeSelection){let map=TableMap$2.get(sel.node),start=sel.from+1,lastCell=start+map.map[map.width*map.height-1];normalize=CellSelection$2.create(doc,start+1,lastCell)}}else sel instanceof TextSelection$2&&isCellBoundarySelection$2(sel)?normalize=TextSelection$2.create(doc,sel.from):sel instanceof TextSelection$2&&isTextSelectionAcrossCells$2(sel)&&(normalize=TextSelection$2.create(doc,sel.$from.start(),sel.$from.end()));return normalize&&(tr||(tr=state.tr)).setSelection(normalize),tr}
// Utilities used for copy/paste handling.
// : (Slice) → ?{width: number, height: number, rows: [Fragment]}
// Get a rectangular area of cells from a slice, or null if the outer
// nodes of the slice aren't table cells or rows.
function pastedCells$2(slice){if(!slice.size)return null;let{content:content,openStart:openStart,openEnd:openEnd}=slice;while(1==content.childCount&&(openStart>0&&openEnd>0||"table"==content.firstChild.type.spec.tableRole))openStart--,openEnd--,content=content.firstChild.content;let first=content.firstChild,role=first.type.spec.tableRole,schema=first.type.schema,rows=[];if("row"==role)for(let i=0;i<content.childCount;i++){let cells=content.child(i).content,left=i?0:Math.max(0,openStart-1),right=i<content.childCount-1?0:Math.max(0,openEnd-1);(left||right)&&(cells=fitSlice$2(tableNodeTypes$2(schema).row,new Slice$2(cells,left,right)).content),rows.push(cells)}else{if("cell"!=role&&"header_cell"!=role)return null;rows.push(openStart||openEnd?fitSlice$2(tableNodeTypes$2(schema).row,new Slice$2(content,openStart,openEnd)).content:content)}return ensureRectangular$2(schema,rows)}// : (Schema, [Fragment]) → {width: number, height: number, rows: [Fragment]}
// Compute the width and height of a set of cells, and make sure each
// row has the same number of cells.
function ensureRectangular$2(schema,rows){let widths=[];for(let i=0;i<rows.length;i++){let row=rows[i];for(let j=row.childCount-1;j>=0;j--){let{rowspan:rowspan,colspan:colspan}=row.child(j).attrs;for(let r=i;r<i+rowspan;r++)widths[r]=(widths[r]||0)+colspan}}let width=0;for(let r=0;r<widths.length;r++)width=Math.max(width,widths[r]);for(let r=0;r<widths.length;r++)if(r>=rows.length&&rows.push(Fragment$2.empty),widths[r]<width){let empty=tableNodeTypes$2(schema).cell.createAndFill(),cells=[];for(let i=widths[r];i<width;i++)cells.push(empty);rows[r]=rows[r].append(Fragment$2.from(cells))}return{height:rows.length,width:width,rows:rows}}function fitSlice$2(nodeType,slice){let node=nodeType.createAndFill(),tr=new Transform$2(node).replace(0,node.content.size,slice);return tr.doc}// : ({width: number, height: number, rows: [Fragment]}, number, number) → {width: number, height: number, rows: [Fragment]}
// Clip or extend (repeat) the given set of cells to cover the given
// width and height. Will clip rowspan/colspan cells at the edges when
// they stick out.
function clipCells$2({width:width,height:height,rows:rows},newWidth,newHeight){if(width!=newWidth){let added=[],newRows=[];for(let row=0;row<rows.length;row++){let frag=rows[row],cells=[];for(let col=added[row]||0,i=0;col<newWidth;i++){let cell=frag.child(i%frag.childCount);col+cell.attrs.colspan>newWidth&&(cell=cell.type.create(removeColSpan$2(cell.attrs,cell.attrs.colspan,col+cell.attrs.colspan-newWidth),cell.content)),cells.push(cell),col+=cell.attrs.colspan;for(let j=1;j<cell.attrs.rowspan;j++)added[row+j]=(added[row+j]||0)+cell.attrs.colspan}newRows.push(Fragment$2.from(cells))}rows=newRows,width=newWidth}if(height!=newHeight){let newRows=[];for(let row=0,i=0;row<newHeight;row++,i++){let cells=[],source=rows[i%height];for(let j=0;j<source.childCount;j++){let cell=source.child(j);row+cell.attrs.rowspan>newHeight&&(cell=cell.type.create(setAttr$2(cell.attrs,"rowspan",Math.max(1,newHeight-cell.attrs.rowspan)),cell.content)),cells.push(cell)}newRows.push(Fragment$2.from(cells))}rows=newRows,height=newHeight}return{width:width,height:height,rows:rows}}// Make sure a table has at least the given width and height. Return
// true if something was changed.
function growTable$2(tr,map,table,start,width,height,mapFrom){let empty,emptyHead,schema=tr.doc.type.schema,types=tableNodeTypes$2(schema);if(width>map.width)for(let row=0,rowEnd=0;row<map.height;row++){let rowNode=table.child(row);rowEnd+=rowNode.nodeSize;let add,cells=[];add=null==rowNode.lastChild||rowNode.lastChild.type==types.cell?empty||(empty=types.cell.createAndFill()):emptyHead||(emptyHead=types.header_cell.createAndFill());for(let i=map.width;i<width;i++)cells.push(add);tr.insert(tr.mapping.slice(mapFrom).map(rowEnd-1+start),cells)}if(height>map.height){let cells=[];for(let i=0,start=(map.height-1)*map.width;i<Math.max(map.width,width);i++){let header=!(i>=map.width)&&table.nodeAt(map.map[start+i]).type==types.header_cell;cells.push(header?emptyHead||(emptyHead=types.header_cell.createAndFill()):empty||(empty=types.cell.createAndFill()))}let emptyRow=types.row.create(null,Fragment$2.from(cells)),rows=[];for(let i=map.height;i<height;i++)rows.push(emptyRow);tr.insert(tr.mapping.slice(mapFrom).map(start+table.nodeSize-2),rows)}return!(!empty&&!emptyHead)}// Make sure the given line (left, top) to (right, top) doesn't cross
// any rowspan cells by splitting cells that cross it. Return true if
// something changed.
function isolateHorizontal$2(tr,map,table,start,left,right,top,mapFrom){if(0==top||top==map.height)return!1;let found=!1;for(let col=left;col<right;col++){let index=top*map.width+col,pos=map.map[index];if(map.map[index-map.width]==pos){found=!0;let cell=table.nodeAt(pos),{top:cellTop,left:cellLeft}=map.findCell(pos);tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos+start),null,setAttr$2(cell.attrs,"rowspan",top-cellTop)),tr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top,cellLeft,table)),cell.type.createAndFill(setAttr$2(cell.attrs,"rowspan",cellTop+cell.attrs.rowspan-top))),col+=cell.attrs.colspan-1}}return found}// Make sure the given line (left, top) to (left, bottom) doesn't
// cross any colspan cells by splitting cells that cross it. Return
// true if something changed.
function isolateVertical$2(tr,map,table,start,top,bottom,left,mapFrom){if(0==left||left==map.width)return!1;let found=!1;for(let row=top;row<bottom;row++){let index=row*map.width+left,pos=map.map[index];if(map.map[index-1]==pos){found=!0;let cell=table.nodeAt(pos),cellLeft=map.colCount(pos),updatePos=tr.mapping.slice(mapFrom).map(pos+start);tr.setNodeMarkup(updatePos,null,removeColSpan$2(cell.attrs,left-cellLeft,cell.attrs.colspan-(left-cellLeft))),tr.insert(updatePos+cell.nodeSize,cell.type.createAndFill(removeColSpan$2(cell.attrs,0,left-cellLeft))),row+=cell.attrs.rowspan-1}}return found}// Insert the given set of cells (as returned by `pastedCells`) into a
// table, at the position pointed at by rect.
function insertCells$2(state,dispatch,tableStart,rect,cells){let table=tableStart?state.doc.nodeAt(tableStart-1):state.doc,map=TableMap$2.get(table),{top:top,left:left}=rect,right=left+cells.width,bottom=top+cells.height,tr=state.tr,mapFrom=0;function recomp(){table=tableStart?tr.doc.nodeAt(tableStart-1):tr.doc,map=TableMap$2.get(table),mapFrom=tr.mapping.maps.length}// Prepare the table to be large enough and not have any cells
// crossing the boundaries of the rectangle that we want to
// insert into. If anything about it changes, recompute the table
// map so that subsequent operations can see the current shape.
growTable$2(tr,map,table,tableStart,right,bottom,mapFrom)&&recomp(),isolateHorizontal$2(tr,map,table,tableStart,left,right,top,mapFrom)&&recomp(),isolateHorizontal$2(tr,map,table,tableStart,left,right,bottom,mapFrom)&&recomp(),isolateVertical$2(tr,map,table,tableStart,top,bottom,left,mapFrom)&&recomp(),isolateVertical$2(tr,map,table,tableStart,top,bottom,right,mapFrom)&&recomp();for(let row=top;row<bottom;row++){let from=map.positionAt(row,left,table),to=map.positionAt(row,right,table);tr.replace(tr.mapping.slice(mapFrom).map(from+tableStart),tr.mapping.slice(mapFrom).map(to+tableStart),new Slice$2(cells.rows[row-top],0,0))}recomp(),tr.setSelection(new CellSelection$2(tr.doc.resolve(tableStart+map.positionAt(top,left,table)),tr.doc.resolve(tableStart+map.positionAt(bottom-1,right-1,table)))),dispatch(tr)}
// This file defines a number of helpers for wiring up user input to
const handleKeyDown$2=keydownHandler$2({ArrowLeft:arrow$2$2("horiz",-1),ArrowRight:arrow$2$2("horiz",1),ArrowUp:arrow$2$2("vert",-1),ArrowDown:arrow$2$2("vert",1),"Shift-ArrowLeft":shiftArrow$2("horiz",-1),"Shift-ArrowRight":shiftArrow$2("horiz",1),"Shift-ArrowUp":shiftArrow$2("vert",-1),"Shift-ArrowDown":shiftArrow$2("vert",1),Backspace:deleteCellSelection$2,"Mod-Backspace":deleteCellSelection$2,Delete:deleteCellSelection$2,"Mod-Delete":deleteCellSelection$2});function maybeSetSelection$2(state,dispatch,selection){return!selection.eq(state.selection)&&(dispatch&&dispatch(state.tr.setSelection(selection).scrollIntoView()),!0)}function arrow$2$2(axis,dir){return(state,dispatch,view)=>{let sel=state.selection;if(sel instanceof CellSelection$2)return maybeSetSelection$2(state,dispatch,Selection$2.near(sel.$headCell,dir));if("horiz"!=axis&&!sel.empty)return!1;let end=atEndOfCell$2(view,axis,dir);if(null==end)return!1;if("horiz"==axis)return maybeSetSelection$2(state,dispatch,Selection$2.near(state.doc.resolve(sel.head+dir),dir));{let newSel,$cell=state.doc.resolve(end),$next=nextCell$2($cell,axis,dir);return newSel=$next?Selection$2.near($next,1):dir<0?Selection$2.near(state.doc.resolve($cell.before(-1)),-1):Selection$2.near(state.doc.resolve($cell.after(-1)),1),maybeSetSelection$2(state,dispatch,newSel)}}}function shiftArrow$2(axis,dir){return(state,dispatch,view)=>{let sel=state.selection;if(!(sel instanceof CellSelection$2)){let end=atEndOfCell$2(view,axis,dir);if(null==end)return!1;sel=new CellSelection$2(state.doc.resolve(end))}let $head=nextCell$2(sel.$headCell,axis,dir);return!!$head&&maybeSetSelection$2(state,dispatch,new CellSelection$2(sel.$anchorCell,$head))}}function deleteCellSelection$2(state,dispatch){let sel=state.selection;if(!(sel instanceof CellSelection$2))return!1;if(dispatch){let tr=state.tr,baseContent=tableNodeTypes$2(state.schema).cell.createAndFill().content;sel.forEachCell(((cell,pos)=>{cell.content.eq(baseContent)||tr.replace(tr.mapping.map(pos+1),tr.mapping.map(pos+cell.nodeSize-1),new Slice$2(baseContent,0,0))})),tr.docChanged&&dispatch(tr)}return!0}function handleTripleClick$3(view,pos){let doc=view.state.doc,$cell=cellAround$2(doc.resolve(pos));return!!$cell&&(view.dispatch(view.state.tr.setSelection(new CellSelection$2($cell))),!0)}function handlePaste$2(view,_,slice){if(!isInTable$2(view.state))return!1;let cells=pastedCells$2(slice),sel=view.state.selection;if(sel instanceof CellSelection$2){cells||(cells={width:1,height:1,rows:[Fragment$2.from(fitSlice$2(tableNodeTypes$2(view.state.schema).cell,slice))]});let table=sel.$anchorCell.node(-1),start=sel.$anchorCell.start(-1),rect=TableMap$2.get(table).rectBetween(sel.$anchorCell.pos-start,sel.$headCell.pos-start);return cells=clipCells$2(cells,rect.right-rect.left,rect.bottom-rect.top),insertCells$2(view.state,view.dispatch,start,rect,cells),!0}if(cells){let $cell=selectionCell$2(view.state),start=$cell.start(-1);return insertCells$2(view.state,view.dispatch,start,TableMap$2.get($cell.node(-1)).findCell($cell.pos-start),cells),!0}return!1}function handleMouseDown$1$2(view,startEvent){if(startEvent.ctrlKey||startEvent.metaKey)return;let $anchor,startDOMCell=domInCell$2(view,startEvent.target);if(startEvent.shiftKey&&view.state.selection instanceof CellSelection$2)
// Adding to an existing cell selection
setCellSelection(view.state.selection.$anchorCell,startEvent),startEvent.preventDefault();else if(startEvent.shiftKey&&startDOMCell&&null!=($anchor=cellAround$2(view.state.selection.$anchor))&&cellUnderMouse$2(view,startEvent).pos!=$anchor.pos)
// Adding to a selection that starts in another cell (causing a
// cell selection to be created).
setCellSelection($anchor,startEvent),startEvent.preventDefault();else if(!startDOMCell)
// Not in a cell, let the default behavior happen.
return;// Create and dispatch a cell selection between the given anchor and
// the position under the mouse.
function setCellSelection($anchor,event){let $head=cellUnderMouse$2(view,event),starting=null==key$1$2.getState(view.state);if(!$head||!inSameTable$2($anchor,$head)){if(!starting)return;$head=$anchor}let selection=new CellSelection$2($anchor,$head);if(starting||!view.state.selection.eq(selection)){let tr=view.state.tr.setSelection(selection);starting&&tr.setMeta(key$1$2,$anchor.pos),view.dispatch(tr)}}// Stop listening to mouse motion events.
function stop(){view.root.removeEventListener("mouseup",stop),view.root.removeEventListener("dragstart",stop),view.root.removeEventListener("mousemove",move),null!=key$1$2.getState(view.state)&&view.dispatch(view.state.tr.setMeta(key$1$2,-1))}function move(event){let $anchor,anchor=key$1$2.getState(view.state);if(null!=anchor)
// Continuing an existing cross-cell selection
$anchor=view.state.doc.resolve(anchor);else if(domInCell$2(view,event.target)!=startDOMCell&&(
// Moving out of the initial cell -- start a new cell selection
$anchor=cellUnderMouse$2(view,startEvent),!$anchor))return stop();$anchor&&setCellSelection($anchor,event)}view.root.addEventListener("mouseup",stop),view.root.addEventListener("dragstart",stop),view.root.addEventListener("mousemove",move)}// Check whether the cursor is at the end of a cell (so that further
// motion would move out of the cell)
function atEndOfCell$2(view,axis,dir){if(!(view.state.selection instanceof TextSelection$2))return null;let{$head:$head}=view.state.selection;for(let d=$head.depth-1;d>=0;d--){let parent=$head.node(d),index=dir<0?$head.index(d):$head.indexAfter(d);if(index!=(dir<0?0:parent.childCount))return null;if("cell"==parent.type.spec.tableRole||"header_cell"==parent.type.spec.tableRole){let cellPos=$head.before(d),dirStr="vert"==axis?dir>0?"down":"up":dir>0?"right":"left";return view.endOfTextblock(dirStr)?cellPos:null}}return null}function domInCell$2(view,dom){for(;dom&&dom!=view.dom;dom=dom.parentNode)if("TD"==dom.nodeName||"TH"==dom.nodeName)return dom}function cellUnderMouse$2(view,event){let mousePos=view.posAtCoords({left:event.clientX,top:event.clientY});return mousePos&&mousePos?cellAround$2(view.state.doc.resolve(mousePos.pos)):null}
// This file defines helpers for normalizing tables, making sure no
const fixTablesKey$2=new PluginKey$2("fix-tables");// Helper for iterating through the nodes in a document that changed
// compared to the given previous document. Useful for avoiding
// duplicate work on each transaction.
function changedDescendants$2(old,cur,offset,f){let oldSize=old.childCount,curSize=cur.childCount;outer:for(let i=0,j=0;i<curSize;i++){let child=cur.child(i);for(let scan=j,e=Math.min(oldSize,i+3);scan<e;scan++)if(old.child(scan)==child){j=scan+1,offset+=child.nodeSize;continue outer}f(child,offset),j<oldSize&&old.child(j).sameMarkup(child)?changedDescendants$2(old.child(j),child,offset+1,f):child.nodesBetween(0,child.content.size,f,offset+1),offset+=child.nodeSize}}// :: (EditorState, ?EditorState) → ?Transaction
// Inspect all tables in the given state's document and return a
// transaction that fixes them, if necessary. If `oldState` was
// provided, that is assumed to hold a previous, known-good state,
// which will be used to avoid re-scanning unchanged parts of the
// document.
function fixTables$2(state,oldState){let tr,check=(node,pos)=>{"table"==node.type.spec.tableRole&&(tr=fixTable$2(state,node,pos,tr))};return oldState?oldState.doc!=state.doc&&changedDescendants$2(oldState.doc,state.doc,0,check):state.doc.descendants(check),tr}// : (EditorState, Node, number, ?Transaction) → ?Transaction
// Fix the given table, if necessary. Will append to the transaction
// it was given, if non-null, or create a new one if necessary.
function fixTable$2(state,table,tablePos,tr){let map=TableMap$2.get(table);if(!map.problems)return tr;tr||(tr=state.tr);// Track which rows we must add cells to, so that we can adjust that
// when fixing collisions.
let first,last,mustAdd=[];for(let i=0;i<map.height;i++)mustAdd.push(0);for(let i=0;i<map.problems.length;i++){let prob=map.problems[i];if("collision"==prob.type){let cell=table.nodeAt(prob.pos);for(let j=0;j<cell.attrs.rowspan;j++)mustAdd[prob.row+j]+=prob.n;tr.setNodeMarkup(tr.mapping.map(tablePos+1+prob.pos),null,removeColSpan$2(cell.attrs,cell.attrs.colspan-prob.n,prob.n))}else if("missing"==prob.type)mustAdd[prob.row]+=prob.n;else if("overlong_rowspan"==prob.type){let cell=table.nodeAt(prob.pos);tr.setNodeMarkup(tr.mapping.map(tablePos+1+prob.pos),null,setAttr$2(cell.attrs,"rowspan",cell.attrs.rowspan-prob.n))}else if("colwidth mismatch"==prob.type){let cell=table.nodeAt(prob.pos);tr.setNodeMarkup(tr.mapping.map(tablePos+1+prob.pos),null,setAttr$2(cell.attrs,"colwidth",prob.colwidth))}}for(let i=0;i<mustAdd.length;i++)mustAdd[i]&&(null==first&&(first=i),last=i);// Add the necessary cells, using a heuristic for whether to add the
// cells at the start or end of the rows (if it looks like a 'bite'
// was taken out of the table, add cells at the start of the row
// after the bite. Otherwise add them at the end).
for(let i=0,pos=tablePos+1;i<map.height;i++){let row=table.child(i),end=pos+row.nodeSize,add=mustAdd[i];if(add>0){let tableNodeType="cell";row.firstChild&&(tableNodeType=row.firstChild.type.spec.tableRole);let nodes=[];for(let j=0;j<add;j++)nodes.push(tableNodeTypes$2(state.schema)[tableNodeType].createAndFill());let side=0!=i&&first!=i-1||last!=i?end-1:pos+1;tr.insert(tr.mapping.map(side),nodes)}pos=end}return tr.setMeta(fixTablesKey$2,{fixTables:!0})}
// This file defines a number of table-related commands.
// map, table node, and table start offset to the object for
// convenience.
function selectedRect$2(state){let rect,sel=state.selection,$pos=selectionCell$2(state),table=$pos.node(-1),tableStart=$pos.start(-1),map=TableMap$2.get(table);return rect=sel instanceof CellSelection$2?map.rectBetween(sel.$anchorCell.pos-tableStart,sel.$headCell.pos-tableStart):map.findCell($pos.pos-tableStart),rect.tableStart=tableStart,rect.map=map,rect.table=table,rect}// Add a column at the given position in a table.
function addColumn$2(tr,{map:map,tableStart:tableStart,table:table},col){let refColumn=col>0?-1:0;columnIsHeader$2(map,table,col+refColumn)&&(refColumn=0==col||col==map.width?null:0);for(let row=0;row<map.height;row++){let index=row*map.width+col;// If this position falls inside a col-spanning cell
if(col>0&&col<map.width&&map.map[index-1]==map.map[index]){let pos=map.map[index],cell=table.nodeAt(pos);tr.setNodeMarkup(tr.mapping.map(tableStart+pos),null,addColSpan$2(cell.attrs,col-map.colCount(pos))),// Skip ahead if rowspan > 1
row+=cell.attrs.rowspan-1}else{let type=null==refColumn?tableNodeTypes$2(table.type.schema).cell:table.nodeAt(map.map[index+refColumn]).type,pos=map.positionAt(row,col,table);tr.insert(tr.mapping.map(tableStart+pos),type.createAndFill())}}return tr}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Command to add a column before the column with the selection.
function addColumnBefore$2(state,dispatch){if(!isInTable$2(state))return!1;if(dispatch){let rect=selectedRect$2(state);dispatch(addColumn$2(state.tr,rect,rect.left))}return!0}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Command to add a column after the column with the selection.
function addColumnAfter$2(state,dispatch){if(!isInTable$2(state))return!1;if(dispatch){let rect=selectedRect$2(state);dispatch(addColumn$2(state.tr,rect,rect.right))}return!0}function removeColumn$2(tr,{map:map,table:table,tableStart:tableStart},col){let mapStart=tr.mapping.maps.length;for(let row=0;row<map.height;){let index=row*map.width+col,pos=map.map[index],cell=table.nodeAt(pos);// If this is part of a col-spanning cell
if(col>0&&map.map[index-1]==pos||col<map.width-1&&map.map[index+1]==pos)tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart+pos),null,removeColSpan$2(cell.attrs,col-map.colCount(pos)));else{let start=tr.mapping.slice(mapStart).map(tableStart+pos);tr.delete(start,start+cell.nodeSize)}row+=cell.attrs.rowspan}}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Command function that removes the selected columns from a table.
function deleteColumn$2(state,dispatch){if(!isInTable$2(state))return!1;if(dispatch){let rect=selectedRect$2(state),tr=state.tr;if(0==rect.left&&rect.right==rect.map.width)return!1;for(let i=rect.right-1;;i--){if(removeColumn$2(tr,rect,i),i==rect.left)break;rect.table=rect.tableStart?tr.doc.nodeAt(rect.tableStart-1):tr.doc,rect.map=TableMap$2.get(rect.table)}dispatch(tr)}return!0}function rowIsHeader$2(map,table,row){let headerCell=tableNodeTypes$2(table.type.schema).header_cell;for(let col=0;col<map.width;col++)if(table.nodeAt(map.map[col+row*map.width]).type!=headerCell)return!1;return!0}function addRow$2(tr,{map:map,tableStart:tableStart,table:table},row){let rowPos=tableStart;for(let i=0;i<row;i++)rowPos+=table.child(i).nodeSize;let cells=[],refRow=row>0?-1:0;rowIsHeader$2(map,table,row+refRow)&&(refRow=0==row||row==map.height?null:0);for(let col=0,index=map.width*row;col<map.width;col++,index++)
// Covered by a rowspan cell
if(row>0&&row<map.height&&map.map[index]==map.map[index-map.width]){let pos=map.map[index],attrs=table.nodeAt(pos).attrs;tr.setNodeMarkup(tableStart+pos,null,setAttr$2(attrs,"rowspan",attrs.rowspan+1)),col+=attrs.colspan-1}else{let type=null==refRow?tableNodeTypes$2(table.type.schema).cell:table.nodeAt(map.map[index+refRow*map.width]).type;cells.push(type.createAndFill())}return tr.insert(rowPos,tableNodeTypes$2(table.type.schema).row.create(null,cells)),tr}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Add a table row before the selection.
function addRowBefore$2(state,dispatch){if(!isInTable$2(state))return!1;if(dispatch){let rect=selectedRect$2(state);dispatch(addRow$2(state.tr,rect,rect.top))}return!0}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Add a table row after the selection.
function addRowAfter$2(state,dispatch){if(!isInTable$2(state))return!1;if(dispatch){let rect=selectedRect$2(state);dispatch(addRow$2(state.tr,rect,rect.bottom))}return!0}function removeRow$2(tr,{map:map,table:table,tableStart:tableStart},row){let rowPos=0;for(let i=0;i<row;i++)rowPos+=table.child(i).nodeSize;let nextRow=rowPos+table.child(row).nodeSize,mapFrom=tr.mapping.maps.length;tr.delete(rowPos+tableStart,nextRow+tableStart);for(let col=0,index=row*map.width;col<map.width;col++,index++){let pos=map.map[index];if(row>0&&pos==map.map[index-map.width]){
// If this cell starts in the row above, simply reduce its rowspan
let attrs=table.nodeAt(pos).attrs;tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos+tableStart),null,setAttr$2(attrs,"rowspan",attrs.rowspan-1)),col+=attrs.colspan-1}else if(row<map.width&&pos==map.map[index+map.width]){
// Else, if it continues in the row below, it has to be moved down
let cell=table.nodeAt(pos),copy=cell.type.create(setAttr$2(cell.attrs,"rowspan",cell.attrs.rowspan-1),cell.content),newPos=map.positionAt(row+1,col,table);tr.insert(tr.mapping.slice(mapFrom).map(tableStart+newPos),copy),col+=cell.attrs.colspan-1}}}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Remove the selected rows from a table.
function deleteRow$2(state,dispatch){if(!isInTable$2(state))return!1;if(dispatch){let rect=selectedRect$2(state),tr=state.tr;if(0==rect.top&&rect.bottom==rect.map.height)return!1;for(let i=rect.bottom-1;;i--){if(removeRow$2(tr,rect,i),i==rect.top)break;rect.table=rect.tableStart?tr.doc.nodeAt(rect.tableStart-1):tr.doc,rect.map=TableMap$2.get(rect.table)}dispatch(tr)}return!0}function isEmpty$6(cell){let c=cell.content;return 1==c.childCount&&c.firstChild.isTextblock&&0==c.firstChild.childCount}function cellsOverlapRectangle$2({width:width,height:height,map:map},rect){let indexTop=rect.top*width+rect.left,indexLeft=indexTop,indexBottom=(rect.bottom-1)*width+rect.left,indexRight=indexTop+(rect.right-rect.left-1);for(let i=rect.top;i<rect.bottom;i++){if(rect.left>0&&map[indexLeft]==map[indexLeft-1]||rect.right<width&&map[indexRight]==map[indexRight+1])return!0;indexLeft+=width,indexRight+=width}for(let i=rect.left;i<rect.right;i++){if(rect.top>0&&map[indexTop]==map[indexTop-width]||rect.bottom<height&&map[indexBottom]==map[indexBottom+width])return!0;indexTop++,indexBottom++}return!1}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Merge the selected cells into a single cell. Only available when
// the selected cells' outline forms a rectangle.
function mergeCells$2(state,dispatch){let sel=state.selection;if(!(sel instanceof CellSelection$2)||sel.$anchorCell.pos==sel.$headCell.pos)return!1;let rect=selectedRect$2(state),{map:map}=rect;if(cellsOverlapRectangle$2(map,rect))return!1;if(dispatch){let mergedPos,mergedCell,tr=state.tr,seen={},content=Fragment$2.empty;for(let row=rect.top;row<rect.bottom;row++)for(let col=rect.left;col<rect.right;col++){let cellPos=map.map[row*map.width+col],cell=rect.table.nodeAt(cellPos);if(!seen[cellPos])if(seen[cellPos]=!0,null==mergedPos)mergedPos=cellPos,mergedCell=cell;else{isEmpty$6(cell)||(content=content.append(cell.content));let mapped=tr.mapping.map(cellPos+rect.tableStart);tr.delete(mapped,mapped+cell.nodeSize)}}if(tr.setNodeMarkup(mergedPos+rect.tableStart,null,setAttr$2(addColSpan$2(mergedCell.attrs,mergedCell.attrs.colspan,rect.right-rect.left-mergedCell.attrs.colspan),"rowspan",rect.bottom-rect.top)),content.size){let end=mergedPos+1+mergedCell.content.size,start=isEmpty$6(mergedCell)?mergedPos+1:end;tr.replaceWith(start+rect.tableStart,end+rect.tableStart,content)}tr.setSelection(new CellSelection$2(tr.doc.resolve(mergedPos+rect.tableStart))),dispatch(tr)}return!0}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Split a selected cell, whose rowpan or colspan is greater than one,
// into smaller cells. Use the first cell type for the new cells.
function splitCell$2(state,dispatch){const nodeTypes=tableNodeTypes$2(state.schema);return splitCellWithType$2((({node:node})=>nodeTypes[node.type.spec.tableRole]))(state,dispatch)}// :: (getCellType: ({ row: number, col: number, node: Node}) → NodeType) → (EditorState, dispatch: ?(tr: Transaction)) → bool
// Split a selected cell, whose rowpan or colspan is greater than one,
// into smaller cells with the cell type (th, td) returned by getType function.
function splitCellWithType$2(getCellType){return(state,dispatch)=>{let cellNode,cellPos,sel=state.selection;if(sel instanceof CellSelection$2){if(sel.$anchorCell.pos!=sel.$headCell.pos)return!1;cellNode=sel.$anchorCell.nodeAfter,cellPos=sel.$anchorCell.pos}else{if(cellNode=cellWrapping$2(sel.$from),!cellNode)return!1;cellPos=cellAround$2(sel.$from).pos}if(1==cellNode.attrs.colspan&&1==cellNode.attrs.rowspan)return!1;if(dispatch){let baseAttrs=cellNode.attrs,attrs=[],colwidth=baseAttrs.colwidth;baseAttrs.rowspan>1&&(baseAttrs=setAttr$2(baseAttrs,"rowspan",1)),baseAttrs.colspan>1&&(baseAttrs=setAttr$2(baseAttrs,"colspan",1));let lastCell,rect=selectedRect$2(state),tr=state.tr;for(let i=0;i<rect.right-rect.left;i++)attrs.push(colwidth?setAttr$2(baseAttrs,"colwidth",colwidth&&colwidth[i]?[colwidth[i]]:null):baseAttrs);for(let row=rect.top;row<rect.bottom;row++){let pos=rect.map.positionAt(row,rect.left,rect.table);row==rect.top&&(pos+=cellNode.nodeSize);for(let col=rect.left,i=0;col<rect.right;col++,i++)col==rect.left&&row==rect.top||tr.insert(lastCell=tr.mapping.map(pos+rect.tableStart,1),getCellType({node:cellNode,row:row,col:col}).createAndFill(attrs[i]))}tr.setNodeMarkup(cellPos,getCellType({node:cellNode,row:rect.top,col:rect.left}),attrs[0]),sel instanceof CellSelection$2&&tr.setSelection(new CellSelection$2(tr.doc.resolve(sel.$anchorCell.pos),lastCell&&tr.doc.resolve(lastCell))),dispatch(tr)}return!0}}// :: (string, any) → (EditorState, dispatch: ?(tr: Transaction)) → bool
// Returns a command that sets the given attribute to the given value,
// and is only available when the currently selected cell doesn't
// already have that attribute set to that value.
function setCellAttr$2(name,value){return function(state,dispatch){if(!isInTable$2(state))return!1;let $cell=selectionCell$2(state);if($cell.nodeAfter.attrs[name]===value)return!1;if(dispatch){let tr=state.tr;state.selection instanceof CellSelection$2?state.selection.forEachCell(((node,pos)=>{node.attrs[name]!==value&&tr.setNodeMarkup(pos,null,setAttr$2(node.attrs,name,value))})):tr.setNodeMarkup($cell.pos,null,setAttr$2($cell.nodeAfter.attrs,name,value)),dispatch(tr)}return!0}}function deprecated_toggleHeader$2(type){return function(state,dispatch){if(!isInTable$2(state))return!1;if(dispatch){let types=tableNodeTypes$2(state.schema),rect=selectedRect$2(state),tr=state.tr,cells=rect.map.cellsInRect("column"==type?new Rect$2(rect.left,0,rect.right,rect.map.height):"row"==type?new Rect$2(0,rect.top,rect.map.width,rect.bottom):rect),nodes=cells.map((pos=>rect.table.nodeAt(pos)));for(let i=0;i<cells.length;i++)nodes[i].type==types.header_cell&&tr.setNodeMarkup(rect.tableStart+cells[i],types.cell,nodes[i].attrs);if(0==tr.steps.length)for(let i=0;i<cells.length;i++)tr.setNodeMarkup(rect.tableStart+cells[i],types.header_cell,nodes[i].attrs);dispatch(tr)}return!0}}function isHeaderEnabledByType$2(type,rect,types){
// Get cell positions for first row or first column
const cellPositions=rect.map.cellsInRect({left:0,top:0,right:"row"==type?rect.map.width:1,bottom:"column"==type?rect.map.height:1});for(let i=0;i<cellPositions.length;i++){const cell=rect.table.nodeAt(cellPositions[i]);if(cell&&cell.type!==types.header_cell)return!1}return!0}// :: (string, ?{ useDeprecatedLogic: bool }) → (EditorState, dispatch: ?(tr: Transaction)) → bool
// Toggles between row/column header and normal cells (Only applies to first row/column).
// For deprecated behavior pass `useDeprecatedLogic` in options with true.
function toggleHeader$2(type,options){return options=options||{useDeprecatedLogic:!1},options.useDeprecatedLogic?deprecated_toggleHeader$2(type):function(state,dispatch){if(!isInTable$2(state))return!1;if(dispatch){let types=tableNodeTypes$2(state.schema),rect=selectedRect$2(state),tr=state.tr,isHeaderRowEnabled=isHeaderEnabledByType$2("row",rect,types),isHeaderColumnEnabled=isHeaderEnabledByType$2("column",rect,types),isHeaderEnabled="column"===type?isHeaderRowEnabled:"row"===type&&isHeaderColumnEnabled,selectionStartsAt=isHeaderEnabled?1:0,cellsRect="column"==type?new Rect$2(0,selectionStartsAt,1,rect.map.height):"row"==type?new Rect$2(selectionStartsAt,0,rect.map.width,1):rect,newType="column"==type?isHeaderColumnEnabled?types.cell:types.header_cell:"row"==type?isHeaderRowEnabled?types.cell:types.header_cell:types.cell;rect.map.cellsInRect(cellsRect).forEach((relativeCellPos=>{const cellPos=relativeCellPos+rect.tableStart,cell=tr.doc.nodeAt(cellPos);cell&&tr.setNodeMarkup(cellPos,newType,cell.attrs)})),dispatch(tr)}return!0}}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Toggles whether the selected row contains header cells.
toggleHeader$2("row",{useDeprecatedLogic:!0}),// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Toggles whether the selected column contains header cells.
toggleHeader$2("column",{useDeprecatedLogic:!0});// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Toggles whether the selected cells are header cells.
let toggleHeaderCell$2=toggleHeader$2("cell",{useDeprecatedLogic:!0});function findNextCell$2($cell,dir){if(dir<0){let before=$cell.nodeBefore;if(before)return $cell.pos-before.nodeSize;for(let row=$cell.index(-1)-1,rowEnd=$cell.before();row>=0;row--){let rowNode=$cell.node(-1).child(row);if(rowNode.childCount)return rowEnd-1-rowNode.lastChild.nodeSize;rowEnd-=rowNode.nodeSize}}else{if($cell.index()<$cell.parent.childCount-1)return $cell.pos+$cell.nodeAfter.nodeSize;let table=$cell.node(-1);for(let row=$cell.indexAfter(-1),rowStart=$cell.after();row<table.childCount;row++){let rowNode=table.child(row);if(rowNode.childCount)return rowStart+1;rowStart+=rowNode.nodeSize}}}// :: (number) → (EditorState, dispatch: ?(tr: Transaction)) → bool
// Returns a command for selecting the next (direction=1) or previous
// (direction=-1) cell in a table.
function goToNextCell$2(direction){return function(state,dispatch){if(!isInTable$2(state))return!1;let cell=findNextCell$2(selectionCell$2(state),direction);if(null!=cell){if(dispatch){let $cell=state.doc.resolve(cell);dispatch(state.tr.setSelection(TextSelection$2.between($cell,moveCellForward$2($cell))).scrollIntoView())}return!0}}}// :: (EditorState, ?(tr: Transaction)) → bool
// Deletes the table around the selection, if any.
function deleteTable$2(state,dispatch){let $pos=state.selection.$anchor;for(let d=$pos.depth;d>0;d--){let node=$pos.node(d);if("table"==node.type.spec.tableRole)return dispatch&&dispatch(state.tr.delete($pos.before(d),$pos.after(d)).scrollIntoView()),!0}return!1}class TableView$1$2{constructor(node,cellMinWidth){this.node=node,this.cellMinWidth=cellMinWidth,this.dom=document.createElement("div"),this.dom.className="tableWrapper",this.table=this.dom.appendChild(document.createElement("table")),this.colgroup=this.table.appendChild(document.createElement("colgroup")),updateColumns$1$2(node,this.colgroup,this.table,cellMinWidth),this.contentDOM=this.table.appendChild(document.createElement("tbody"))}update(node){return node.type==this.node.type&&(this.node=node,updateColumns$1$2(node,this.colgroup,this.table,this.cellMinWidth),!0)}ignoreMutation(record){return"attributes"==record.type&&(record.target==this.table||this.colgroup.contains(record.target))}}function updateColumns$1$2(node,colgroup,table,cellMinWidth,overrideCol,overrideValue){let totalWidth=0,fixedWidth=!0,nextDOM=colgroup.firstChild,row=node.firstChild;for(let i=0,col=0;i<row.childCount;i++){let{colspan:colspan,colwidth:colwidth}=row.child(i).attrs;for(let j=0;j<colspan;j++,col++){let hasWidth=overrideCol==col?overrideValue:colwidth&&colwidth[j],cssWidth=hasWidth?hasWidth+"px":"";totalWidth+=hasWidth||cellMinWidth,hasWidth||(fixedWidth=!1),nextDOM?(nextDOM.style.width!=cssWidth&&(nextDOM.style.width=cssWidth),nextDOM=nextDOM.nextSibling):colgroup.appendChild(document.createElement("col")).style.width=cssWidth}}while(nextDOM){let after=nextDOM.nextSibling;nextDOM.parentNode.removeChild(nextDOM),nextDOM=after}fixedWidth?(table.style.width=totalWidth+"px",table.style.minWidth=""):(table.style.width="",table.style.minWidth=totalWidth+"px")}const key$3=new PluginKey$2("tableColumnResizing");function columnResizing$2({handleWidth:handleWidth=5,cellMinWidth:cellMinWidth=25,View:View=TableView$1$2,lastColumnResizable:lastColumnResizable=!0}={}){let plugin=new Plugin$2({key:key$3,state:{init(_,state){return this.spec.props.nodeViews[tableNodeTypes$2(state.schema).table.name]=(node,view)=>new View(node,cellMinWidth,view),new ResizeState$2(-1,!1)},apply(tr,prev){return prev.apply(tr)}},props:{attributes(state){let pluginState=key$3.getState(state);return pluginState.activeHandle>-1?{class:"resize-cursor"}:null},handleDOMEvents:{mousemove(view,event){handleMouseMove$2(view,event,handleWidth,cellMinWidth,lastColumnResizable)},mouseleave(view){handleMouseLeave$2(view)},mousedown(view,event){handleMouseDown$3(view,event,cellMinWidth)}},decorations(state){let pluginState=key$3.getState(state);if(pluginState.activeHandle>-1)return handleDecorations$2(state,pluginState.activeHandle)},nodeViews:{}}});return plugin}class ResizeState$2{constructor(activeHandle,dragging){this.activeHandle=activeHandle,this.dragging=dragging}apply(tr){let state=this,action=tr.getMeta(key$3);if(action&&null!=action.setHandle)return new ResizeState$2(action.setHandle,null);if(action&&void 0!==action.setDragging)return new ResizeState$2(state.activeHandle,action.setDragging);if(state.activeHandle>-1&&tr.docChanged){let handle=tr.mapping.map(state.activeHandle,-1);pointsAtCell$2(tr.doc.resolve(handle))||(handle=null),state=new ResizeState$2(handle,state.dragging)}return state}}function handleMouseMove$2(view,event,handleWidth,cellMinWidth,lastColumnResizable){let pluginState=key$3.getState(view.state);if(!pluginState.dragging){let target=domCellAround$2(event.target),cell=-1;if(target){let{left:left,right:right}=target.getBoundingClientRect();event.clientX-left<=handleWidth?cell=edgeCell$2(view,event,"left"):right-event.clientX<=handleWidth&&(cell=edgeCell$2(view,event,"right"))}if(cell!=pluginState.activeHandle){if(!lastColumnResizable&&-1!==cell){let $cell=view.state.doc.resolve(cell),table=$cell.node(-1),map=TableMap$2.get(table),start=$cell.start(-1),col=map.colCount($cell.pos-start)+$cell.nodeAfter.attrs.colspan-1;if(col==map.width-1)return}updateHandle$2(view,cell)}}}function handleMouseLeave$2(view){let pluginState=key$3.getState(view.state);pluginState.activeHandle>-1&&!pluginState.dragging&&updateHandle$2(view,-1)}function handleMouseDown$3(view,event,cellMinWidth){let pluginState=key$3.getState(view.state);if(-1==pluginState.activeHandle||pluginState.dragging)return!1;let cell=view.state.doc.nodeAt(pluginState.activeHandle),width=currentColWidth$2(view,pluginState.activeHandle,cell.attrs);function finish(event){window.removeEventListener("mouseup",finish),window.removeEventListener("mousemove",move);let pluginState=key$3.getState(view.state);pluginState.dragging&&(updateColumnWidth$2(view,pluginState.activeHandle,draggedWidth$2(pluginState.dragging,event,cellMinWidth)),view.dispatch(view.state.tr.setMeta(key$3,{setDragging:null})))}function move(event){if(!event.which)return finish(event);let pluginState=key$3.getState(view.state),dragged=draggedWidth$2(pluginState.dragging,event,cellMinWidth);displayColumnWidth$2(view,pluginState.activeHandle,dragged,cellMinWidth)}return view.dispatch(view.state.tr.setMeta(key$3,{setDragging:{startX:event.clientX,startWidth:width}})),window.addEventListener("mouseup",finish),window.addEventListener("mousemove",move),event.preventDefault(),!0}function currentColWidth$2(view,cellPos,{colspan:colspan,colwidth:colwidth}){let width=colwidth&&colwidth[colwidth.length-1];if(width)return width;let dom=view.domAtPos(cellPos),node=dom.node.childNodes[dom.offset],domWidth=node.offsetWidth,parts=colspan;if(colwidth)for(let i=0;i<colspan;i++)colwidth[i]&&(domWidth-=colwidth[i],parts--);return domWidth/parts}function domCellAround$2(target){while(target&&"TD"!=target.nodeName&&"TH"!=target.nodeName)target=target.classList.contains("ProseMirror")?null:target.parentNode;return target}function edgeCell$2(view,event,side){let found=view.posAtCoords({left:event.clientX,top:event.clientY});if(!found)return-1;let{pos:pos}=found,$cell=cellAround$2(view.state.doc.resolve(pos));if(!$cell)return-1;if("right"==side)return $cell.pos;let map=TableMap$2.get($cell.node(-1)),start=$cell.start(-1),index=map.map.indexOf($cell.pos-start);return index%map.width==0?-1:start+map.map[index-1]}function draggedWidth$2(dragging,event,cellMinWidth){let offset=event.clientX-dragging.startX;return Math.max(cellMinWidth,dragging.startWidth+offset)}function updateHandle$2(view,value){view.dispatch(view.state.tr.setMeta(key$3,{setHandle:value}))}function updateColumnWidth$2(view,cell,width){let $cell=view.state.doc.resolve(cell),table=$cell.node(-1),map=TableMap$2.get(table),start=$cell.start(-1),col=map.colCount($cell.pos-start)+$cell.nodeAfter.attrs.colspan-1,tr=view.state.tr;for(let row=0;row<map.height;row++){let mapIndex=row*map.width+col;// Rowspanning cell that has already been handled
if(row&&map.map[mapIndex]==map.map[mapIndex-map.width])continue;let pos=map.map[mapIndex],{attrs:attrs}=table.nodeAt(pos),index=1==attrs.colspan?0:col-map.colCount(pos);if(attrs.colwidth&&attrs.colwidth[index]==width)continue;let colwidth=attrs.colwidth?attrs.colwidth.slice():zeroes$2(attrs.colspan);colwidth[index]=width,tr.setNodeMarkup(start+pos,null,setAttr$2(attrs,"colwidth",colwidth))}tr.docChanged&&view.dispatch(tr)}function displayColumnWidth$2(view,cell,width,cellMinWidth){let $cell=view.state.doc.resolve(cell),table=$cell.node(-1),start=$cell.start(-1),col=TableMap$2.get(table).colCount($cell.pos-start)+$cell.nodeAfter.attrs.colspan-1,dom=view.domAtPos($cell.start(-1)).node;while("TABLE"!=dom.nodeName)dom=dom.parentNode;updateColumns$1$2(table,dom.firstChild,dom,cellMinWidth,col,width)}function zeroes$2(n){let result=[];for(let i=0;i<n;i++)result.push(0);return result}function handleDecorations$2(state,cell){let decorations=[],$cell=state.doc.resolve(cell),table=$cell.node(-1),map=TableMap$2.get(table),start=$cell.start(-1),col=map.colCount($cell.pos-start)+$cell.nodeAfter.attrs.colspan;for(let row=0;row<map.height;row++){let index=col+row*map.width-1;// For positions that are have either a different cell or the end
// of the table to their right, and either the top of the table or
// a different cell above them, add a decoration
if((col==map.width||map.map[index]!=map.map[index+1])&&(0==row||map.map[index-1]!=map.map[index-1-map.width])){let cellPos=map.map[index],pos=start+cellPos+table.nodeAt(cellPos).nodeSize-1,dom=document.createElement("div");dom.className="column-resize-handle",decorations.push(Decoration$2.widget(pos,dom))}}return DecorationSet$2.create(state.doc,decorations)}
// This file defines a plugin that handles the drawing of cell

// Creates a [plugin](http://prosemirror.net/docs/ref/#state.Plugin)
// that, when added to an editor, enables cell-selection, handles
// cell-based copy/paste, and makes sure tables stay well-formed (each
// row has the same width, and cells don't overlap).

// You should probably put this plugin near the end of your array of
// plugins, since it handles mouse and arrow key events in tables
// rather broadly, and other plugins, like the gap cursor or the
// column-width dragging plugin, might want to get a turn first to
// perform more specific behavior.
function tableEditing$2({allowTableNodeSelection:allowTableNodeSelection=!1}={}){return new Plugin$2({key:key$1$2,
// This piece of state is used to remember when a mouse-drag
// cell-selection is happening, so that it can continue even as
// transactions (which might move its anchor cell) come in.
state:{init(){return null},apply(tr,cur){let set=tr.getMeta(key$1$2);if(null!=set)return-1==set?null:set;if(null==cur||!tr.docChanged)return cur;let{deleted:deleted,pos:pos}=tr.mapping.mapResult(cur);return deleted?null:pos}},props:{decorations:drawCellSelection$2,handleDOMEvents:{mousedown:handleMouseDown$1$2},createSelectionBetween(view){if(null!=key$1$2.getState(view.state))return view.state.selection},handleTripleClick:handleTripleClick$3,handleKeyDown:handleKeyDown$2,handlePaste:handlePaste$2},appendTransaction(_,oldState,state){return normalizeSelection$2(state,fixTables$2(state,oldState),allowTableNodeSelection)}})}function updateColumns$3(node,colgroup,table,cellMinWidth,overrideCol,overrideValue){let totalWidth=0,fixedWidth=!0,nextDOM=colgroup.firstChild;const row=node.firstChild;for(let i=0,col=0;i<row.childCount;i+=1){const{colspan:colspan,colwidth:colwidth}=row.child(i).attrs;for(let j=0;j<colspan;j+=1,col+=1){const hasWidth=overrideCol===col?overrideValue:colwidth&&colwidth[j],cssWidth=hasWidth?`${hasWidth}px`:"";totalWidth+=hasWidth||cellMinWidth,hasWidth||(fixedWidth=!1),nextDOM?(nextDOM.style.width!==cssWidth&&(nextDOM.style.width=cssWidth),nextDOM=nextDOM.nextSibling):colgroup.appendChild(document.createElement("col")).style.width=cssWidth}}while(nextDOM){const after=nextDOM.nextSibling;nextDOM.parentNode.removeChild(nextDOM),nextDOM=after}fixedWidth?(table.style.width=`${totalWidth}px`,table.style.minWidth=""):(table.style.width="",table.style.minWidth=`${totalWidth}px`)}class TableView$3{constructor(node,cellMinWidth){this.node=node,this.cellMinWidth=cellMinWidth,this.dom=document.createElement("div"),this.dom.className="tableWrapper",this.table=this.dom.appendChild(document.createElement("table")),this.colgroup=this.table.appendChild(document.createElement("colgroup")),updateColumns$3(node,this.colgroup,this.table,cellMinWidth),this.contentDOM=this.table.appendChild(document.createElement("tbody"))}update(node){return node.type===this.node.type&&(this.node=node,updateColumns$3(node,this.colgroup,this.table,this.cellMinWidth),!0)}ignoreMutation(mutation){return"attributes"===mutation.type&&(mutation.target===this.table||this.colgroup.contains(mutation.target))}}function createCell$2(cellType,cellContent){return cellContent?cellType.createChecked(null,cellContent):cellType.createAndFill()}function getTableNodeTypes$2(schema){if(schema.cached.tableNodeTypes)return schema.cached.tableNodeTypes;const roles={};return Object.keys(schema.nodes).forEach((type=>{const nodeType=schema.nodes[type];nodeType.spec.tableRole&&(roles[nodeType.spec.tableRole]=nodeType)})),schema.cached.tableNodeTypes=roles,roles}function createTable$2(schema,rowsCount,colsCount,withHeaderRow,cellContent){const types=getTableNodeTypes$2(schema),headerCells=[],cells=[];for(let index=0;index<colsCount;index+=1){const cell=createCell$2(types.cell,cellContent);if(cell&&cells.push(cell),withHeaderRow){const headerCell=createCell$2(types.header_cell,cellContent);headerCell&&headerCells.push(headerCell)}}const rows=[];for(let index=0;index<rowsCount;index+=1)rows.push(types.row.createChecked(null,withHeaderRow&&0===index?headerCells:cells));return types.table.createChecked(null,rows)}function isCellSelection$2(value){return value instanceof CellSelection$2}const deleteTableWhenAllCellsSelected$2=({editor:editor})=>{const{selection:selection}=editor.state;if(!isCellSelection$2(selection))return!1;let cellCount=0;const table=findParentNodeClosestToPos$2(selection.ranges[0].$from,(node=>"table"===node.type.name));null===table||void 0===table||table.node.descendants((node=>{if("table"===node.type.name)return!1;["tableCell","tableHeader"].includes(node.type.name)&&(cellCount+=1)}));const allCellsSelected=cellCount===selection.ranges.length;return!!allCellsSelected&&(editor.commands.deleteTable(),!0)};Node$1$2.create({name:"table",
// @ts-ignore
addOptions(){return{HTMLAttributes:{},resizable:!1,handleWidth:5,cellMinWidth:25,
// TODO: fix
View:TableView$3,lastColumnResizable:!0,allowTableNodeSelection:!1}},content:"tableRow+",tableRole:"table",isolating:!0,group:"block",parseHTML(){return[{tag:"table"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["table",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes),["tbody",0]]},addCommands(){return{insertTable:({rows:rows=3,cols:cols=3,withHeaderRow:withHeaderRow=!0}={})=>({tr:tr,dispatch:dispatch,editor:editor})=>{const node=createTable$2(editor.schema,rows,cols,withHeaderRow);if(dispatch){const offset=tr.selection.anchor+1;tr.replaceSelectionWith(node).scrollIntoView().setSelection(TextSelection$2.near(tr.doc.resolve(offset)))}return!0},addColumnBefore:()=>({state:state,dispatch:dispatch})=>addColumnBefore$2(state,dispatch),addColumnAfter:()=>({state:state,dispatch:dispatch})=>addColumnAfter$2(state,dispatch),deleteColumn:()=>({state:state,dispatch:dispatch})=>deleteColumn$2(state,dispatch),addRowBefore:()=>({state:state,dispatch:dispatch})=>addRowBefore$2(state,dispatch),addRowAfter:()=>({state:state,dispatch:dispatch})=>addRowAfter$2(state,dispatch),deleteRow:()=>({state:state,dispatch:dispatch})=>deleteRow$2(state,dispatch),deleteTable:()=>({state:state,dispatch:dispatch})=>deleteTable$2(state,dispatch),mergeCells:()=>({state:state,dispatch:dispatch})=>mergeCells$2(state,dispatch),splitCell:()=>({state:state,dispatch:dispatch})=>splitCell$2(state,dispatch),toggleHeaderColumn:()=>({state:state,dispatch:dispatch})=>toggleHeader$2("column")(state,dispatch),toggleHeaderRow:()=>({state:state,dispatch:dispatch})=>toggleHeader$2("row")(state,dispatch),toggleHeaderCell:()=>({state:state,dispatch:dispatch})=>toggleHeaderCell$2(state,dispatch),mergeOrSplit:()=>({state:state,dispatch:dispatch})=>!!mergeCells$2(state,dispatch)||splitCell$2(state,dispatch),setCellAttribute:(name,value)=>({state:state,dispatch:dispatch})=>setCellAttr$2(name,value)(state,dispatch),goToNextCell:()=>({state:state,dispatch:dispatch})=>goToNextCell$2(1)(state,dispatch),goToPreviousCell:()=>({state:state,dispatch:dispatch})=>goToNextCell$2(-1)(state,dispatch),fixTables:()=>({state:state,dispatch:dispatch})=>(dispatch&&fixTables$2(state),!0),setCellSelection:position=>({tr:tr,dispatch:dispatch})=>{if(dispatch){const selection=CellSelection$2.create(tr.doc,position.anchorCell,position.headCell);
// @ts-ignore
tr.setSelection(selection)}return!0}}},addKeyboardShortcuts(){return{Tab:()=>!!this.editor.commands.goToNextCell()||!!this.editor.can().addRowAfter()&&this.editor.chain().addRowAfter().goToNextCell().run(),"Shift-Tab":()=>this.editor.commands.goToPreviousCell(),Backspace:deleteTableWhenAllCellsSelected$2,"Mod-Backspace":deleteTableWhenAllCellsSelected$2,Delete:deleteTableWhenAllCellsSelected$2,"Mod-Delete":deleteTableWhenAllCellsSelected$2}},addProseMirrorPlugins(){const isResizable=this.options.resizable&&this.editor.isEditable;return[...isResizable?[columnResizing$2({handleWidth:this.options.handleWidth,cellMinWidth:this.options.cellMinWidth,View:this.options.View,
// TODO: PR for @types/prosemirror-tables
// @ts-ignore (incorrect type)
lastColumnResizable:this.options.lastColumnResizable})]:[],tableEditing$2({allowTableNodeSelection:this.options.allowTableNodeSelection})]},extendNodeSchema(extension){const context={name:extension.name,options:extension.options,storage:extension.storage};return{tableRole:callOrReturn$2(getExtensionField$2(extension,"tableRole",context))}}}),Node$1$2.create({name:"tableRow",addOptions(){return{HTMLAttributes:{}}},content:"(tableCell | tableHeader)*",tableRole:"row",parseHTML(){return[{tag:"tr"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["tr",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes),0]}});const TableCell$2=Node$1$2.create({name:"tableCell",addOptions(){return{HTMLAttributes:{}}},content:"block+",addAttributes(){return{colspan:{default:1},rowspan:{default:1},colwidth:{default:null,parseHTML:element=>{const colwidth=element.getAttribute("colwidth"),value=colwidth?[parseInt(colwidth,10)]:null;return value}}}},tableRole:"cell",isolating:!0,parseHTML(){return[{tag:"td"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["td",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes),0]}}),TableHeader$2=Node$1$2.create({name:"tableHeader",addOptions(){return{HTMLAttributes:{}}},content:"block+",addAttributes(){return{colspan:{default:1},rowspan:{default:1},colwidth:{default:null,parseHTML:element=>{const colwidth=element.getAttribute("colwidth"),value=colwidth?[parseInt(colwidth,10)]:null;return value}}}},tableRole:"header_cell",isolating:!0,parseHTML(){return[{tag:"th"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["th",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes),0]}});Extension$2.create({name:"placeholder",addOptions(){return{emptyEditorClass:"is-editor-empty",emptyNodeClass:"is-empty",placeholder:"Write something …",showOnlyWhenEditable:!0,showOnlyCurrent:!0,includeChildren:!1}},addProseMirrorPlugins(){return[new Plugin$2({props:{decorations:({doc:doc,selection:selection})=>{const active=this.editor.isEditable||!this.options.showOnlyWhenEditable,{anchor:anchor}=selection,decorations=[];return active?(doc.descendants(((node,pos)=>{const hasAnchor=anchor>=pos&&anchor<=pos+node.nodeSize,isEmpty=!node.isLeaf&&!node.childCount;if((hasAnchor||!this.options.showOnlyCurrent)&&isEmpty){const classes=[this.options.emptyNodeClass];this.editor.isEmpty&&classes.push(this.options.emptyEditorClass);const decoration=Decoration$2.node(pos,pos+node.nodeSize,{class:classes.join(" "),"data-placeholder":"function"===typeof this.options.placeholder?this.options.placeholder({editor:this.editor,node:node,pos:pos,hasAnchor:hasAnchor}):this.options.placeholder});decorations.push(decoration)}return this.options.includeChildren})),DecorationSet$2.create(doc,decorations)):null}}})]}});const inputRegex$2$2=/^\s*>\s$/;Node$1$2.create({name:"blockquote",addOptions(){return{HTMLAttributes:{}}},content:"block+",group:"block",defining:!0,parseHTML(){return[{tag:"blockquote"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["blockquote",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setBlockquote:()=>({commands:commands})=>commands.wrapIn(this.name),toggleBlockquote:()=>({commands:commands})=>commands.toggleWrap(this.name),unsetBlockquote:()=>({commands:commands})=>commands.lift(this.name)}},addKeyboardShortcuts(){return{"Mod-Shift-b":()=>this.editor.commands.toggleBlockquote()}},addInputRules(){return[wrappingInputRule$2({find:inputRegex$2$2,type:this.type})]}}),Extension$2.create({name:"color",addOptions(){return{types:["textStyle"]}},addGlobalAttributes(){return[{types:this.options.types,attributes:{color:{default:null,parseHTML:element=>{var _a;return null===(_a=element.style.color)||void 0===_a?void 0:_a.replace(/['"]+/g,"")},renderHTML:attributes=>attributes.color?{style:`color: ${attributes.color}`}:{}}}}]},addCommands(){return{setColor:color=>({chain:chain})=>chain().setMark("textStyle",{color:color}).run(),unsetColor:()=>({chain:chain})=>chain().setMark("textStyle",{color:null}).removeEmptyTextStyle().run()}}});const HardBreak$1$2=Node$1$2.create({name:"hardBreak",addOptions(){return{keepMarks:!0,HTMLAttributes:{}}},inline:!0,group:"inline",selectable:!1,parseHTML(){return[{tag:"br"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["br",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes)]},renderText(){return"\n"},addCommands(){return{setHardBreak:()=>({commands:commands,chain:chain,state:state,editor:editor})=>commands.first([()=>commands.exitCode(),()=>commands.command((()=>{const{selection:selection,storedMarks:storedMarks}=state;if(selection.$from.parent.type.spec.isolating)return!1;const{keepMarks:keepMarks}=this.options,{splittableMarks:splittableMarks}=editor.extensionManager,marks=storedMarks||selection.$to.parentOffset&&selection.$from.marks();return chain().insertContent({type:this.name}).command((({tr:tr,dispatch:dispatch})=>{if(dispatch&&marks&&keepMarks){const filteredMarks=marks.filter((mark=>splittableMarks.includes(mark.type.name)));tr.ensureMarks(filteredMarks)}return!0})).run()}))])}},addKeyboardShortcuts(){return{"Mod-Enter":()=>this.editor.commands.setHardBreak(),"Shift-Enter":()=>this.editor.commands.setHardBreak()}}});HardBreak$1$2.extend({addKeyboardShortcuts(){return{Enter:()=>this.editor.commands.setHardBreak()}}}),Node$1$2.create({name:"horizontalRule",addOptions(){return{HTMLAttributes:{}}},group:"block",parseHTML(){return[{tag:"hr"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["hr",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes)]},addCommands(){return{setHorizontalRule:()=>({chain:chain})=>chain().insertContent({type:this.name}).command((({tr:tr,dispatch:dispatch})=>{var _a;if(dispatch){const{$to:$to}=tr.selection,posAfter=$to.end();if($to.nodeAfter)tr.setSelection(TextSelection$2.create(tr.doc,$to.pos));else{
// add node after horizontal rule if it’s the end of the document
const node=null===(_a=$to.parent.type.contentMatch.defaultType)||void 0===_a?void 0:_a.create();node&&(tr.insert(posAfter,node),tr.setSelection(TextSelection$2.create(tr.doc,posAfter)))}tr.scrollIntoView()}return!0})).run()}},addInputRules(){return[nodeInputRule$2({find:/^(?:---|—-|___\s|\*\*\*\s)$/,type:this.type})]}});const inputRegex$1$2=/(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/,Image$1$2=Node$1$2.create({name:"image",addOptions(){return{inline:!1,allowBase64:!1,HTMLAttributes:{}}},inline(){return this.options.inline},group(){return this.options.inline?"inline":"block"},draggable:!0,addAttributes(){return{src:{default:null},alt:{default:null},title:{default:null}}},parseHTML(){return[{tag:this.options.allowBase64?"img[src]":'img[src]:not([src^="data:"])'}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["img",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes)]},addCommands(){return{setImage:options=>({commands:commands})=>commands.insertContent({type:this.name,attrs:options})}},addInputRules(){return[nodeInputRule$2({find:inputRegex$1$2,type:this.type,getAttributes:match=>{const[,,alt,src,title]=match;return{src:src,alt:alt,title:title}}})]}});Image$1$2.extend({addOptions(){return{inline:!1,allowBase64:!0,HTMLAttributes:{}}},addAttributes(){return{src:{default:null},alt:{default:null},title:{default:null},style:{default:null}}}}),Extension$2.create({name:"fontSize",addOptions(){return{types:["textStyle"]}},addGlobalAttributes(){return[{types:this.options.types,attributes:{fontSize:{default:null,parseHTML:element=>element.style.fontSize.replace(/['"]+/g,""),renderHTML:attributes=>attributes.fontSize?{style:`font-size: ${attributes.fontSize}`}:{}}}}]},addCommands(){return{setFontSize:fontSize=>({chain:chain})=>chain().setMark("textStyle",{fontSize:fontSize+"px"}).run(),unsetFontSize:()=>({chain:chain})=>chain().setMark("textStyle",{fontSize:null}).removeEmptyTextStyle().run()}}});const inputRegex$7=/(?:^|\s)((?:==)((?:[^~=]+))(?:==))$/,pasteRegex$3=/(?:^|\s)((?:==)((?:[^~=]+))(?:==))/g;
/**
 * Finite State Machine generation utilities
 */
/**
 * Define a basic state machine state. j is the list of character transitions,
 * jr is the list of regex-match transitions, jd is the default state to
 * transition to t is the accepting token type, if any. If this is the terminal
 * state, then it does not emit a token.
 * @param {string|class} token to emit
 */
function State$2(token){this.j={},// IMPLEMENTATION 1
// this.j = []; // IMPLEMENTATION 2
this.jr=[],this.jd=null,this.t=token}
/**
 * Take the transition from this state to the next one on the given input.
 * If this state does not exist deterministically, will create it.
 *
 * @param {string} input character or token to transition on
 * @param {string|class} [token] token or multi-token to emit when reaching
 * this state
 */Mark$3.create({name:"highlight",addOptions(){return{multicolor:!1,HTMLAttributes:{}}},addAttributes(){return this.options.multicolor?{color:{default:null,parseHTML:element=>element.getAttribute("data-color")||element.style.backgroundColor,renderHTML:attributes=>attributes.color?{"data-color":attributes.color,style:`background-color: ${attributes.color}`}:{}}}:{}},parseHTML(){return[{tag:"mark"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["mark",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setHighlight:attributes=>({commands:commands})=>commands.setMark(this.name,attributes),toggleHighlight:attributes=>({commands:commands})=>commands.toggleMark(this.name,attributes),unsetHighlight:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-Shift-h":()=>this.editor.commands.toggleHighlight()}},addInputRules(){return[markInputRule$2({find:inputRegex$7,type:this.type})]},addPasteRules(){return[markPasteRule$2({find:pasteRegex$3,type:this.type})]}}),TableHeader$2.extend({addAttributes(){return{colspan:{default:1},rowspan:{default:1},colwidth:{default:null,parseHTML:element=>{const colwidth=element.getAttribute("colwidth"),value=colwidth?[parseInt(colwidth,10)]:null;return value},renderHTML:()=>({style:"border: 1px solid #d0d9e2;color: #2f4058;font-weight: 400;background-color: #fafbff;"})}}},parseHTML(){return[{tag:"th"}]}}),TableCell$2.extend({addAttributes(){return{colspan:{default:1},rowspan:{default:1},colwidth:{default:null,parseHTML:element=>{const colwidth=element.getAttribute("colwidth"),value=colwidth?[parseInt(colwidth,10)]:null;return value},renderHTML:()=>({style:"border: 1px solid #d0d9e2;color: #2f4058;font-weight: 400;"})}}},parseHTML(){return[{tag:"td"}]}}),Paragraph$2.extend({renderHTML({HTMLAttributes:HTMLAttributes}){return["p",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes),0]}}),State$2.prototype={
/**
   * @param {State} state
   */
accepts:function(){return!!this.t},
/**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * @param {string} input character or token to transition on
   * @param {Token|State} tokenOrState transition to a matching state
   * @returns State taken after the given input
   */
tt:function(input,tokenOrState){if(tokenOrState&&tokenOrState.j)
// State, default a basic transition
return this.j[input]=tokenOrState,tokenOrState;// See if there's a direct state transition (not regex or default)
var token=tokenOrState,nextState=this.j[input];if(nextState)// overrwites previous token
return token&&(nextState.t=token),nextState;// Create a new state for this input
nextState=makeState$2();// Take the transition using the usual default mechanisms
var templateState=takeT$2(this,input);return templateState?(
// Some default state transition, make a prime state based on this one
Object.assign(nextState.j,templateState.j),nextState.jr.append(templateState.jr),nextState.jr=templateState.jd,nextState.t=token||templateState.t):nextState.t=token,this.j[input]=nextState,nextState}};
/**
 * Utility function to create state without using new keyword (reduced file size
 * when minified)
 */
var makeState$2=function(){return new State$2},makeAcceptingState$2=function(token){return new State$2(token)},makeT$2=function(startState,input,nextState){
// IMPLEMENTATION 1: Add to object (fast)
startState.j[input]||(startState.j[input]=nextState);// IMPLEMENTATION 2: Add to array (slower)
// startState.j.push([input, nextState]);
},makeRegexT$2=function(startState,regex,nextState){startState.jr.push([regex,nextState])},takeT$2=function(state,input){
// IMPLEMENTATION 1: Object key lookup (faster)
var nextState=state.j[input];if(nextState)return nextState;// IMPLEMENTATION 2: List lookup (slower)
// Loop through all the state transitions and see if there's a match
// for (let i = 0; i < state.j.length; i++) {
//	const val = state.j[i][0];
//	const nextState = state.j[i][1];
// 	if (input === val) { return nextState; }
// }
for(var i=0;i<state.jr.length;i++){var regex=state.jr[i][0],_nextState=state.jr[i][1];if(regex.test(input))return _nextState}// Nowhere left to jump! Return default, if any
return state.jd},makeMultiT$2=function(startState,chars,nextState){for(var i=0;i<chars.length;i++)makeT$2(startState,chars[i],nextState)},makeBatchT$2=function(startState,transitions){for(var i=0;i<transitions.length;i++){var input=transitions[i][0],nextState=transitions[i][1];makeT$2(startState,input,nextState)}},makeChainT$2=function(state,str,endState,defaultStateFactory){var nextState,i=0,len=str.length;// Find the next state without a jump to the next character
while(i<len&&(nextState=state.j[str[i]]))state=nextState,i++;if(i>=len)return[];// no new tokens were added
while(i<len-1)nextState=defaultStateFactory(),makeT$2(state,str[i],nextState),state=nextState,i++;makeT$2(state,str[len-1],endState)},DOMAIN$2="DOMAIN",LOCALHOST$2="LOCALHOST",TLD$2="TLD",NUM$2="NUM",PROTOCOL$2="PROTOCOL",MAILTO$2="MAILTO",WS$2="WS",NL$2="NL",OPENBRACE$2="OPENBRACE",OPENBRACKET$2="OPENBRACKET",OPENANGLEBRACKET$2="OPENANGLEBRACKET",OPENPAREN$2="OPENPAREN",CLOSEBRACE$2="CLOSEBRACE",CLOSEBRACKET$2="CLOSEBRACKET",CLOSEANGLEBRACKET$2="CLOSEANGLEBRACKET",CLOSEPAREN$2="CLOSEPAREN",AMPERSAND$2="AMPERSAND",APOSTROPHE$2="APOSTROPHE",ASTERISK$2="ASTERISK",AT$2="AT",BACKSLASH$2="BACKSLASH",BACKTICK$2="BACKTICK",CARET$2="CARET",COLON$2="COLON",COMMA$2="COMMA",DOLLAR$2="DOLLAR",DOT$2="DOT",EQUALS$2="EQUALS",EXCLAMATION$2="EXCLAMATION",HYPHEN$2="HYPHEN",PERCENT$2="PERCENT",PIPE$2="PIPE",PLUS$2="PLUS",POUND$2="POUND",QUERY$2="QUERY",QUOTE$2="QUOTE",SEMI$2="SEMI",SLASH$2="SLASH",TILDE$2="TILDE",UNDERSCORE$2="UNDERSCORE",SYM$2="SYM",text$3=Object.freeze({__proto__:null,DOMAIN:DOMAIN$2,LOCALHOST:LOCALHOST$2,TLD:TLD$2,NUM:NUM$2,PROTOCOL:PROTOCOL$2,MAILTO:MAILTO$2,WS:WS$2,NL:NL$2,OPENBRACE:OPENBRACE$2,OPENBRACKET:OPENBRACKET$2,OPENANGLEBRACKET:OPENANGLEBRACKET$2,OPENPAREN:OPENPAREN$2,CLOSEBRACE:CLOSEBRACE$2,CLOSEBRACKET:CLOSEBRACKET$2,CLOSEANGLEBRACKET:CLOSEANGLEBRACKET$2,CLOSEPAREN:CLOSEPAREN$2,AMPERSAND:AMPERSAND$2,APOSTROPHE:APOSTROPHE$2,ASTERISK:ASTERISK$2,AT:AT$2,BACKSLASH:BACKSLASH$2,BACKTICK:BACKTICK$2,CARET:CARET$2,COLON:COLON$2,COMMA:COMMA$2,DOLLAR:DOLLAR$2,DOT:DOT$2,EQUALS:EQUALS$2,EXCLAMATION:EXCLAMATION$2,HYPHEN:HYPHEN$2,PERCENT:PERCENT$2,PIPE:PIPE$2,PLUS:PLUS$2,POUND:POUND$2,QUERY:QUERY$2,QUOTE:QUOTE$2,SEMI:SEMI$2,SLASH:SLASH$2,TILDE:TILDE$2,UNDERSCORE:UNDERSCORE$2,SYM:SYM$2}),tlds$2="aaa aarp abarth abb abbott abbvie abc able abogado abudhabi ac academy accenture accountant accountants aco actor ad adac ads adult ae aeg aero aetna af afamilycompany afl africa ag agakhan agency ai aig airbus airforce airtel akdn al alfaromeo alibaba alipay allfinanz allstate ally alsace alstom am amazon americanexpress americanfamily amex amfam amica amsterdam analytics android anquan anz ao aol apartments app apple aq aquarelle ar arab aramco archi army arpa art arte as asda asia associates at athleta attorney au auction audi audible audio auspost author auto autos avianca aw aws ax axa az azure ba baby baidu banamex bananarepublic band bank bar barcelona barclaycard barclays barefoot bargains baseball basketball bauhaus bayern bb bbc bbt bbva bcg bcn bd be beats beauty beer bentley berlin best bestbuy bet bf bg bh bharti bi bible bid bike bing bingo bio biz bj black blackfriday blockbuster blog bloomberg blue bm bms bmw bn bnpparibas bo boats boehringer bofa bom bond boo book booking bosch bostik boston bot boutique box br bradesco bridgestone broadway broker brother brussels bs bt budapest bugatti build builders business buy buzz bv bw by bz bzh ca cab cafe cal call calvinklein cam camera camp cancerresearch canon capetown capital capitalone car caravan cards care career careers cars casa case cash casino cat catering catholic cba cbn cbre cbs cc cd center ceo cern cf cfa cfd cg ch chanel channel charity chase chat cheap chintai christmas chrome church ci cipriani circle cisco citadel citi citic city cityeats ck cl claims cleaning click clinic clinique clothing cloud club clubmed cm cn co coach codes coffee college cologne com comcast commbank community company compare computer comsec condos construction consulting contact contractors cooking cookingchannel cool coop corsica country coupon coupons courses cpa cr credit creditcard creditunion cricket crown crs cruise cruises csc cu cuisinella cv cw cx cy cymru cyou cz dabur dad dance data date dating datsun day dclk dds de deal dealer deals degree delivery dell deloitte delta democrat dental dentist desi design dev dhl diamonds diet digital direct directory discount discover dish diy dj dk dm dnp do docs doctor dog domains dot download drive dtv dubai duck dunlop dupont durban dvag dvr dz earth eat ec eco edeka edu education ee eg email emerck energy engineer engineering enterprises epson equipment er ericsson erni es esq estate et etisalat eu eurovision eus events exchange expert exposed express extraspace fage fail fairwinds faith family fan fans farm farmers fashion fast fedex feedback ferrari ferrero fi fiat fidelity fido film final finance financial fire firestone firmdale fish fishing fit fitness fj fk flickr flights flir florist flowers fly fm fo foo food foodnetwork football ford forex forsale forum foundation fox fr free fresenius frl frogans frontdoor frontier ftr fujitsu fujixerox fun fund furniture futbol fyi ga gal gallery gallo gallup game games gap garden gay gb gbiz gd gdn ge gea gent genting george gf gg ggee gh gi gift gifts gives giving gl glade glass gle global globo gm gmail gmbh gmo gmx gn godaddy gold goldpoint golf goo goodyear goog google gop got gov gp gq gr grainger graphics gratis green gripe grocery group gs gt gu guardian gucci guge guide guitars guru gw gy hair hamburg hangout haus hbo hdfc hdfcbank health healthcare help helsinki here hermes hgtv hiphop hisamitsu hitachi hiv hk hkt hm hn hockey holdings holiday homedepot homegoods homes homesense honda horse hospital host hosting hot hoteles hotels hotmail house how hr hsbc ht hu hughes hyatt hyundai ibm icbc ice icu id ie ieee ifm ikano il im imamat imdb immo immobilien in inc industries infiniti info ing ink institute insurance insure int international intuit investments io ipiranga iq ir irish is ismaili ist istanbul it itau itv iveco jaguar java jcb je jeep jetzt jewelry jio jll jm jmp jnj jo jobs joburg jot joy jp jpmorgan jprs juegos juniper kaufen kddi ke kerryhotels kerrylogistics kerryproperties kfh kg kh ki kia kim kinder kindle kitchen kiwi km kn koeln komatsu kosher kp kpmg kpn kr krd kred kuokgroup kw ky kyoto kz la lacaixa lamborghini lamer lancaster lancia land landrover lanxess lasalle lat latino latrobe law lawyer lb lc lds lease leclerc lefrak legal lego lexus lgbt li lidl life lifeinsurance lifestyle lighting like lilly limited limo lincoln linde link lipsy live living lixil lk llc llp loan loans locker locus loft lol london lotte lotto love lpl lplfinancial lr ls lt ltd ltda lu lundbeck luxe luxury lv ly ma macys madrid maif maison makeup man management mango map market marketing markets marriott marshalls maserati mattel mba mc mckinsey md me med media meet melbourne meme memorial men menu merckmsd mg mh miami microsoft mil mini mint mit mitsubishi mk ml mlb mls mm mma mn mo mobi mobile moda moe moi mom monash money monster mormon mortgage moscow moto motorcycles mov movie mp mq mr ms msd mt mtn mtr mu museum mutual mv mw mx my mz na nab nagoya name nationwide natura navy nba nc ne nec net netbank netflix network neustar new news next nextdirect nexus nf nfl ng ngo nhk ni nico nike nikon ninja nissan nissay nl no nokia northwesternmutual norton now nowruz nowtv np nr nra nrw ntt nu nyc nz obi observer off office okinawa olayan olayangroup oldnavy ollo om omega one ong onl online onyourside ooo open oracle orange org organic origins osaka otsuka ott ovh pa page panasonic paris pars partners parts party passagens pay pccw pe pet pf pfizer pg ph pharmacy phd philips phone photo photography photos physio pics pictet pictures pid pin ping pink pioneer pizza pk pl place play playstation plumbing plus pm pn pnc pohl poker politie porn post pr pramerica praxi press prime pro prod productions prof progressive promo properties property protection pru prudential ps pt pub pw pwc py qa qpon quebec quest qvc racing radio raid re read realestate realtor realty recipes red redstone redumbrella rehab reise reisen reit reliance ren rent rentals repair report republican rest restaurant review reviews rexroth rich richardli ricoh ril rio rip rmit ro rocher rocks rodeo rogers room rs rsvp ru rugby ruhr run rw rwe ryukyu sa saarland safe safety sakura sale salon samsclub samsung sandvik sandvikcoromant sanofi sap sarl sas save saxo sb sbi sbs sc sca scb schaeffler schmidt scholarships school schule schwarz science scjohnson scot sd se search seat secure security seek select sener services ses seven sew sex sexy sfr sg sh shangrila sharp shaw shell shia shiksha shoes shop shopping shouji show showtime si silk sina singles site sj sk ski skin sky skype sl sling sm smart smile sn sncf so soccer social softbank software sohu solar solutions song sony soy spa space sport spot spreadbetting sr srl ss st stada staples star statebank statefarm stc stcgroup stockholm storage store stream studio study style su sucks supplies supply support surf surgery suzuki sv swatch swiftcover swiss sx sy sydney systems sz tab taipei talk taobao target tatamotors tatar tattoo tax taxi tc tci td tdk team tech technology tel temasek tennis teva tf tg th thd theater theatre tiaa tickets tienda tiffany tips tires tirol tj tjmaxx tjx tk tkmaxx tl tm tmall tn to today tokyo tools top toray toshiba total tours town toyota toys tr trade trading training travel travelchannel travelers travelersinsurance trust trv tt tube tui tunes tushu tv tvs tw tz ua ubank ubs ug uk unicom university uno uol ups us uy uz va vacations vana vanguard vc ve vegas ventures verisign versicherung vet vg vi viajes video vig viking villas vin vip virgin visa vision viva vivo vlaanderen vn vodka volkswagen volvo vote voting voto voyage vu vuelos wales walmart walter wang wanggou watch watches weather weatherchannel webcam weber website wed wedding weibo weir wf whoswho wien wiki williamhill win windows wine winners wme wolterskluwer woodside work works world wow ws wtc wtf xbox xerox xfinity xihuan xin xxx xyz yachts yahoo yamaxun yandex ye yodobashi yoga yokohama you youtube yt yun za zappos zara zero zip zm zone zuerich zw vermögensberater-ctb vermögensberatung-pwb ελ ευ бг бел дети ею католик ком қаз мкд мон москва онлайн орг рус рф сайт срб укр გე հայ ישראל קום ابوظبي اتصالات ارامكو الاردن البحرين الجزائر السعودية العليان المغرب امارات ایران بارت بازار بھارت بيتك پاکستان ڀارت تونس سودان سورية شبكة عراق عرب عمان فلسطين قطر كاثوليك كوم مصر مليسيا موريتانيا موقع همراه कॉम नेट भारत भारतम् भारोत संगठन বাংলা ভারত ভাৰত ਭਾਰਤ ભારત ଭାରତ இந்தியா இலங்கை சிங்கப்பூர் భారత్ ಭಾರತ ഭാരതം ලංකා คอม ไทย ລາວ 닷넷 닷컴 삼성 한국 アマゾン グーグル クラウド コム ストア セール ファッション ポイント みんな 世界 中信 中国 中國 中文网 亚马逊 企业 佛山 信息 健康 八卦 公司 公益 台湾 台灣 商城 商店 商标 嘉里 嘉里大酒店 在线 大众汽车 大拿 天主教 娱乐 家電 广东 微博 慈善 我爱你 手机 招聘 政务 政府 新加坡 新闻 时尚 書籍 机构 淡马锡 游戏 澳門 点看 移动 组织机构 网址 网店 网站 网络 联通 诺基亚 谷歌 购物 通販 集团 電訊盈科 飞利浦 食品 餐厅 香格里拉 香港".split(" "),LETTER$2=/(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/,EMOJI$2=/(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDD-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6])/,EMOJI_VARIATION$2=/\uFE0F/,DIGIT$2=/\d/,SPACE$2=/\s/;
/**
 * Similar to previous except it is an accepting state that emits a token
 * @param {Token} token
 */
/**
 * Initialize the scanner character-based state machine for the given start state
 * @return {State} scanner starting state
 */
function init$2$2(){var customProtocols=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],S_START=makeState$2(),S_NUM=makeAcceptingState$2(NUM$2),S_DOMAIN=makeAcceptingState$2(DOMAIN$2),S_DOMAIN_HYPHEN=makeState$2(),S_WS=makeAcceptingState$2(WS$2),DOMAIN_REGEX_TRANSITIONS=[[DIGIT$2,S_DOMAIN],[LETTER$2,S_DOMAIN],[EMOJI$2,S_DOMAIN],[EMOJI_VARIATION$2,S_DOMAIN]],makeDomainState=function(){var state=makeAcceptingState$2(DOMAIN$2);return state.j={"-":S_DOMAIN_HYPHEN},state.jr=[].concat(DOMAIN_REGEX_TRANSITIONS),state},makeNearDomainState=function(token){var state=makeDomainState();return state.t=token,state};
// Frequently used states
// States for special URL symbols that accept immediately after start
makeBatchT$2(S_START,[["'",makeAcceptingState$2(APOSTROPHE$2)],["{",makeAcceptingState$2(OPENBRACE$2)],["[",makeAcceptingState$2(OPENBRACKET$2)],["<",makeAcceptingState$2(OPENANGLEBRACKET$2)],["(",makeAcceptingState$2(OPENPAREN$2)],["}",makeAcceptingState$2(CLOSEBRACE$2)],["]",makeAcceptingState$2(CLOSEBRACKET$2)],[">",makeAcceptingState$2(CLOSEANGLEBRACKET$2)],[")",makeAcceptingState$2(CLOSEPAREN$2)],["&",makeAcceptingState$2(AMPERSAND$2)],["*",makeAcceptingState$2(ASTERISK$2)],["@",makeAcceptingState$2(AT$2)],["`",makeAcceptingState$2(BACKTICK$2)],["^",makeAcceptingState$2(CARET$2)],[":",makeAcceptingState$2(COLON$2)],[",",makeAcceptingState$2(COMMA$2)],["$",makeAcceptingState$2(DOLLAR$2)],[".",makeAcceptingState$2(DOT$2)],["=",makeAcceptingState$2(EQUALS$2)],["!",makeAcceptingState$2(EXCLAMATION$2)],["-",makeAcceptingState$2(HYPHEN$2)],["%",makeAcceptingState$2(PERCENT$2)],["|",makeAcceptingState$2(PIPE$2)],["+",makeAcceptingState$2(PLUS$2)],["#",makeAcceptingState$2(POUND$2)],["?",makeAcceptingState$2(QUERY$2)],['"',makeAcceptingState$2(QUOTE$2)],["/",makeAcceptingState$2(SLASH$2)],[";",makeAcceptingState$2(SEMI$2)],["~",makeAcceptingState$2(TILDE$2)],["_",makeAcceptingState$2(UNDERSCORE$2)],["\\",makeAcceptingState$2(BACKSLASH$2)]]),// Whitespace jumps
// Tokens of only non-newline whitespace are arbitrarily long
makeT$2(S_START,"\n",makeAcceptingState$2(NL$2)),makeRegexT$2(S_START,SPACE$2,S_WS),// If any whitespace except newline, more whitespace!
makeT$2(S_WS,"\n",makeState$2()),// non-accepting state
makeRegexT$2(S_WS,SPACE$2,S_WS);// Generates states for top-level domains
// Note that this is most accurate when tlds are in alphabetical order
for(var i=0;i<tlds$2.length;i++)makeChainT$2(S_START,tlds$2[i],makeNearDomainState(TLD$2),makeDomainState);// Collect the states generated by different protocls
var S_PROTOCOL_FILE=makeDomainState(),S_PROTOCOL_FTP=makeDomainState(),S_PROTOCOL_HTTP=makeDomainState(),S_MAILTO=makeDomainState();makeChainT$2(S_START,"file",S_PROTOCOL_FILE,makeDomainState),makeChainT$2(S_START,"ftp",S_PROTOCOL_FTP,makeDomainState),makeChainT$2(S_START,"http",S_PROTOCOL_HTTP,makeDomainState),makeChainT$2(S_START,"mailto",S_MAILTO,makeDomainState);// Protocol states
var S_PROTOCOL_SECURE=makeDomainState(),S_FULL_PROTOCOL=makeAcceptingState$2(PROTOCOL$2),S_FULL_MAILTO=makeAcceptingState$2(MAILTO$2);// Mailto ends with COLON
// Secure protocols (end with 's')
makeT$2(S_PROTOCOL_FTP,"s",S_PROTOCOL_SECURE),makeT$2(S_PROTOCOL_FTP,":",S_FULL_PROTOCOL),makeT$2(S_PROTOCOL_HTTP,"s",S_PROTOCOL_SECURE),makeT$2(S_PROTOCOL_HTTP,":",S_FULL_PROTOCOL),// Become protocol tokens after a COLON
makeT$2(S_PROTOCOL_FILE,":",S_FULL_PROTOCOL),makeT$2(S_PROTOCOL_SECURE,":",S_FULL_PROTOCOL),makeT$2(S_MAILTO,":",S_FULL_MAILTO);for(// Register custom protocols
var S_CUSTOM_PROTOCOL=makeDomainState(),_i=0;_i<customProtocols.length;_i++)makeChainT$2(S_START,customProtocols[_i],S_CUSTOM_PROTOCOL,makeDomainState);return makeT$2(S_CUSTOM_PROTOCOL,":",S_FULL_PROTOCOL),// Localhost
makeChainT$2(S_START,"localhost",makeNearDomainState(LOCALHOST$2),makeDomainState),// Everything else
// DOMAINs make more DOMAINs
// Number and character transitions
makeRegexT$2(S_START,DIGIT$2,S_NUM),makeRegexT$2(S_START,LETTER$2,S_DOMAIN),makeRegexT$2(S_START,EMOJI$2,S_DOMAIN),makeRegexT$2(S_START,EMOJI_VARIATION$2,S_DOMAIN),makeRegexT$2(S_NUM,DIGIT$2,S_NUM),makeRegexT$2(S_NUM,LETTER$2,S_DOMAIN),// number becomes DOMAIN
makeRegexT$2(S_NUM,EMOJI$2,S_DOMAIN),// number becomes DOMAIN
makeRegexT$2(S_NUM,EMOJI_VARIATION$2,S_DOMAIN),// number becomes DOMAIN
makeT$2(S_NUM,"-",S_DOMAIN_HYPHEN),// Default domain transitions
makeT$2(S_DOMAIN,"-",S_DOMAIN_HYPHEN),makeT$2(S_DOMAIN_HYPHEN,"-",S_DOMAIN_HYPHEN),makeRegexT$2(S_DOMAIN,DIGIT$2,S_DOMAIN),makeRegexT$2(S_DOMAIN,LETTER$2,S_DOMAIN),makeRegexT$2(S_DOMAIN,EMOJI$2,S_DOMAIN),makeRegexT$2(S_DOMAIN,EMOJI_VARIATION$2,S_DOMAIN),makeRegexT$2(S_DOMAIN_HYPHEN,DIGIT$2,S_DOMAIN),makeRegexT$2(S_DOMAIN_HYPHEN,LETTER$2,S_DOMAIN),makeRegexT$2(S_DOMAIN_HYPHEN,EMOJI$2,S_DOMAIN),makeRegexT$2(S_DOMAIN_HYPHEN,EMOJI_VARIATION$2,S_DOMAIN),// Set default transition for start state (some symbol)
S_START.jd=makeAcceptingState$2(SYM$2),S_START}
/**
	Given a string, returns an array of TOKEN instances representing the
	composition of that string.

	@method run
	@param {State} start scanner starting state
	@param {string} str input string to scan
	@return {{t: string, v: string, s: number, l: number}[]} list of tokens, each with a type and value
*/function run$1$3(start,str){
// State machine is not case sensitive, so input is tokenized in lowercased
// form (still returns the regular case though) Uses selective `toLowerCase`
// is used because lowercasing the entire string causes the length and
// character position to vary in some non-English strings with V8-based
// runtimes.
var iterable=stringToArray$2(str.replace(/[A-Z]/g,(function(c){return c.toLowerCase()}))),charCount=iterable.length,tokens=[],cursor=0,charCursor=0;// Tokenize the string
while(charCursor<charCount){var state=start,nextState=null,tokenLength=0,latestAccepting=null,sinceAccepts=-1,charsSinceAccepts=-1;while(charCursor<charCount&&(nextState=takeT$2(state,iterable[charCursor])))state=nextState,// Keep track of the latest accepting state
state.accepts()?(sinceAccepts=0,charsSinceAccepts=0,latestAccepting=state):sinceAccepts>=0&&(sinceAccepts+=iterable[charCursor].length,charsSinceAccepts++),tokenLength+=iterable[charCursor].length,cursor+=iterable[charCursor].length,charCursor++;// Roll back to the latest accepting state
cursor-=sinceAccepts,charCursor-=charsSinceAccepts,tokenLength-=sinceAccepts,// No more jumps, just make a new token from the last accepting one
// TODO: If possible, don't output v, instead output range where values ocur
tokens.push({t:latestAccepting.t,
// token type/name
v:str.substr(cursor-tokenLength,tokenLength),
// string value
s:cursor-tokenLength,
// start index
e:cursor})}return tokens}
/**
 * Convert a String to an Array of characters, taking into account that some
 * characters like emojis take up two string indexes.
 *
 * Adapted from core-js (MIT license)
 * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js
 *
 * @function stringToArray
 * @param {string} str
 * @returns {string[]}
 */function stringToArray$2(str){var result=[],len=str.length,index=0;while(index<len){var first=str.charCodeAt(index),second=void 0,char=first<55296||first>56319||index+1===len||(second=str.charCodeAt(index+1))<56320||second>57343?str[index]:str.slice(index,index+2);// two-index characters
result.push(char),index+=char.length}return result}
/**
 * @property {string} defaultProtocol
 * @property {{[string]: (event) => void}]} [events]
 */var defaults$2={defaultProtocol:"http",events:null,format:noop$2,formatHref:noop$2,nl2br:!1,tagName:"a",target:null,rel:null,validate:!0,truncate:0,className:null,attributes:null,ignoreTags:[]};function noop$2(val){return val}
/******************************************************************************
	Multi-Tokens
	Tokens composed of arrays of TextTokens
******************************************************************************/function inherits$2(parent,child){var props=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},extended=Object.create(parent.prototype);for(var p in props)extended[p]=props[p];return extended.constructor=child,child.prototype=extended,child}
/**
	Abstract class used for manufacturing tokens of text tokens. That is rather
	than the value for a token being a small string of text, it's value an array
	of text tokens.

	Used for grouping together URLs, emails, hashtags, and other potential
	creations.

	@class MultiToken
	@param {string} value
	@param {{t: string, v: string, s: number, e: number}[]} tokens
	@abstract
*/function MultiToken$2(){}// Base token
/**
 * Create a new token that can be emitted by the parser state machine
 * @param {string} type readable type of the token
 * @param {object} props properties to assign or override, including isLink = true or false
 * @returns {(value: string, tokens: {t: string, v: string, s: number, e: number}) => MultiToken} new token class
 */
function createTokenClass$2(type,props){function Token(value,tokens){this.t=type,this.v=value,this.tk=tokens}return inherits$2(MultiToken$2,Token,props),Token}
/**
	Represents an arbitrarily mailto email address with the prefix included
	@class MailtoEmail
	@extends MultiToken
*/MultiToken$2.prototype={
/**
  	String representing the type for this token
  	@property t
  	@default 'token'
  */
t:"token",
/**
  	Is this multitoken a link?
  	@property isLink
  	@default false
  */
isLink:!1,
/**
  	Return the string this token represents.
  	@method toString
  	@return {string}
  */
toString:function(){return this.v},
/**
  	What should the value for this token be in the `href` HTML attribute?
  	Returns the `.toString` value by default.
  		@method toHref
  	@return {string}
  */
toHref:function(){return this.toString()},
/**
   * The start index of this token in the original input string
   * @returns {number}
   */
startIndex:function(){return this.tk[0].s},
/**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
endIndex:function(){return this.tk[this.tk.length-1].e},
/**
  	Returns a hash of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
toObject:function(){var protocol=arguments.length>0&&void 0!==arguments[0]?arguments[0]:defaults$2.defaultProtocol;return{type:this.t,value:this.v,isLink:this.isLink,href:this.toHref(protocol),start:this.startIndex(),end:this.endIndex()}}};var MailtoEmail$2=createTokenClass$2("email",{isLink:!0}),Email$2=createTokenClass$2("email",{isLink:!0,toHref:function(){return"mailto:"+this.toString()}}),Text$3=createTokenClass$2("text"),Nl$2=createTokenClass$2("nl"),Url$2=createTokenClass$2("url",{isLink:!0,
/**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@method href
  	@param {string} protocol
  	@return {string}
  */
toHref:function(){var protocol=arguments.length>0&&void 0!==arguments[0]?arguments[0]:defaults$2.defaultProtocol,tokens=this.tk,hasProtocol=!1,hasSlashSlash=!1,result=[],i=0;// Make the first part of the domain lowercase
// Lowercase protocol
while(tokens[i].t===PROTOCOL$2)hasProtocol=!0,result.push(tokens[i].v),i++;// Skip slash-slash
while(tokens[i].t===SLASH$2)hasSlashSlash=!0,result.push(tokens[i].v),i++;// Continue pushing characters
for(;i<tokens.length;i++)result.push(tokens[i].v);return result=result.join(""),hasProtocol||hasSlashSlash||(result="".concat(protocol,"://").concat(result)),result},hasProtocol:function(){return this.tk[0].t===PROTOCOL$2}}),multi$2=Object.freeze({__proto__:null,MultiToken:MultiToken$2,Base:MultiToken$2,createTokenClass:createTokenClass$2,MailtoEmail:MailtoEmail$2,Email:Email$2,Text:Text$3,Nl:Nl$2,Url:Url$2});
/**
	Represents a list of tokens making up a valid email address
	@class Email
	@extends MultiToken
*/
/**
	Not exactly parser, more like the second-stage scanner (although we can
	theoretically hotswap the code here with a real parser in the future... but
	for a little URL-finding utility abstract syntax trees may be a little
	overkill).

	URL format: http://en.wikipedia.org/wiki/URI_scheme
	Email format: http://en.wikipedia.org/wiki/Email_address (links to RFC in
	reference)

	@module linkify
	@submodule parser
	@main run
*/
/**
 * Generate the parser multi token-based state machine
 * @returns {State} the starting state
 */
function init$1$2(){
// The universal starting state.
var S_START=makeState$2(),S_PROTOCOL=makeState$2(),S_MAILTO=makeState$2(),S_PROTOCOL_SLASH=makeState$2(),S_PROTOCOL_SLASH_SLASH=makeState$2(),S_DOMAIN=makeState$2(),S_DOMAIN_DOT=makeState$2(),S_TLD=makeAcceptingState$2(Url$2),S_TLD_COLON=makeState$2(),S_TLD_PORT=makeAcceptingState$2(Url$2),S_URL=makeAcceptingState$2(Url$2),S_URL_NON_ACCEPTING=makeState$2(),S_URL_OPENBRACE=makeState$2(),S_URL_OPENBRACKET=makeState$2(),S_URL_OPENANGLEBRACKET=makeState$2(),S_URL_OPENPAREN=makeState$2(),S_URL_OPENBRACE_Q=makeAcceptingState$2(Url$2),S_URL_OPENBRACKET_Q=makeAcceptingState$2(Url$2),S_URL_OPENANGLEBRACKET_Q=makeAcceptingState$2(Url$2),S_URL_OPENPAREN_Q=makeAcceptingState$2(Url$2),S_URL_OPENBRACE_SYMS=makeState$2(),S_URL_OPENBRACKET_SYMS=makeState$2(),S_URL_OPENANGLEBRACKET_SYMS=makeState$2(),S_URL_OPENPAREN_SYMS=makeState$2(),S_EMAIL_DOMAIN=makeState$2(),S_EMAIL_DOMAIN_DOT=makeState$2(),S_EMAIL=makeAcceptingState$2(Email$2),S_EMAIL_COLON=makeState$2(),S_EMAIL_PORT=makeAcceptingState$2(Email$2),S_MAILTO_EMAIL=makeAcceptingState$2(MailtoEmail$2),S_MAILTO_EMAIL_NON_ACCEPTING=makeState$2(),S_LOCALPART=makeState$2(),S_LOCALPART_AT=makeState$2(),S_LOCALPART_DOT=makeState$2(),S_NL=makeAcceptingState$2(Nl$2);// Intermediate states for URLs. Note that domains that begin with a protocol
// are treated slighly differently from those that don't.
// single new line
// Make path from start to protocol (with '//')
makeT$2(S_START,NL$2,S_NL),makeT$2(S_START,PROTOCOL$2,S_PROTOCOL),makeT$2(S_START,MAILTO$2,S_MAILTO),makeT$2(S_PROTOCOL,SLASH$2,S_PROTOCOL_SLASH),makeT$2(S_PROTOCOL_SLASH,SLASH$2,S_PROTOCOL_SLASH_SLASH),// The very first potential domain name
makeT$2(S_START,TLD$2,S_DOMAIN),makeT$2(S_START,DOMAIN$2,S_DOMAIN),makeT$2(S_START,LOCALHOST$2,S_TLD),makeT$2(S_START,NUM$2,S_DOMAIN),// Force URL for protocol followed by anything sane
makeT$2(S_PROTOCOL_SLASH_SLASH,TLD$2,S_URL),makeT$2(S_PROTOCOL_SLASH_SLASH,DOMAIN$2,S_URL),makeT$2(S_PROTOCOL_SLASH_SLASH,NUM$2,S_URL),makeT$2(S_PROTOCOL_SLASH_SLASH,LOCALHOST$2,S_URL),// Account for dots and hyphens
// hyphens are usually parts of domain names
makeT$2(S_DOMAIN,DOT$2,S_DOMAIN_DOT),makeT$2(S_EMAIL_DOMAIN,DOT$2,S_EMAIL_DOMAIN_DOT),// Hyphen can jump back to a domain name
// After the first domain and a dot, we can find either a URL or another domain
makeT$2(S_DOMAIN_DOT,TLD$2,S_TLD),makeT$2(S_DOMAIN_DOT,DOMAIN$2,S_DOMAIN),makeT$2(S_DOMAIN_DOT,NUM$2,S_DOMAIN),makeT$2(S_DOMAIN_DOT,LOCALHOST$2,S_DOMAIN),makeT$2(S_EMAIL_DOMAIN_DOT,TLD$2,S_EMAIL),makeT$2(S_EMAIL_DOMAIN_DOT,DOMAIN$2,S_EMAIL_DOMAIN),makeT$2(S_EMAIL_DOMAIN_DOT,NUM$2,S_EMAIL_DOMAIN),makeT$2(S_EMAIL_DOMAIN_DOT,LOCALHOST$2,S_EMAIL_DOMAIN),// S_TLD accepts! But the URL could be longer, try to find a match greedily
// The `run` function should be able to "rollback" to the accepting state
makeT$2(S_TLD,DOT$2,S_DOMAIN_DOT),makeT$2(S_EMAIL,DOT$2,S_EMAIL_DOMAIN_DOT),// Become real URLs after `SLASH` or `COLON NUM SLASH`
// Here PSS and non-PSS converge
makeT$2(S_TLD,COLON$2,S_TLD_COLON),makeT$2(S_TLD,SLASH$2,S_URL),makeT$2(S_TLD_COLON,NUM$2,S_TLD_PORT),makeT$2(S_TLD_PORT,SLASH$2,S_URL),makeT$2(S_EMAIL,COLON$2,S_EMAIL_COLON),makeT$2(S_EMAIL_COLON,NUM$2,S_EMAIL_PORT);// Types of characters the URL can definitely end in
var qsAccepting=[AMPERSAND$2,ASTERISK$2,AT$2,BACKSLASH$2,BACKTICK$2,CARET$2,DOLLAR$2,DOMAIN$2,EQUALS$2,HYPHEN$2,LOCALHOST$2,NUM$2,PERCENT$2,PIPE$2,PLUS$2,POUND$2,PROTOCOL$2,SLASH$2,SYM$2,TILDE$2,TLD$2,UNDERSCORE$2],qsNonAccepting=[APOSTROPHE$2,CLOSEANGLEBRACKET$2,CLOSEBRACE$2,CLOSEBRACKET$2,CLOSEPAREN$2,COLON$2,COMMA$2,DOT$2,EXCLAMATION$2,OPENANGLEBRACKET$2,OPENBRACE$2,OPENBRACKET$2,OPENPAREN$2,QUERY$2,QUOTE$2,SEMI$2];// Types of tokens that can follow a URL and be part of the query string
// but cannot be the very last characters
// Characters that cannot appear in the URL at all should be excluded
// These states are responsible primarily for determining whether or not to
// include the final round bracket.
// URL, followed by an opening bracket
makeT$2(S_URL,OPENBRACE$2,S_URL_OPENBRACE),makeT$2(S_URL,OPENBRACKET$2,S_URL_OPENBRACKET),makeT$2(S_URL,OPENANGLEBRACKET$2,S_URL_OPENANGLEBRACKET),makeT$2(S_URL,OPENPAREN$2,S_URL_OPENPAREN),// URL with extra symbols at the end, followed by an opening bracket
makeT$2(S_URL_NON_ACCEPTING,OPENBRACE$2,S_URL_OPENBRACE),makeT$2(S_URL_NON_ACCEPTING,OPENBRACKET$2,S_URL_OPENBRACKET),makeT$2(S_URL_NON_ACCEPTING,OPENANGLEBRACKET$2,S_URL_OPENANGLEBRACKET),makeT$2(S_URL_NON_ACCEPTING,OPENPAREN$2,S_URL_OPENPAREN),// Closing bracket component. This character WILL be included in the URL
makeT$2(S_URL_OPENBRACE,CLOSEBRACE$2,S_URL),makeT$2(S_URL_OPENBRACKET,CLOSEBRACKET$2,S_URL),makeT$2(S_URL_OPENANGLEBRACKET,CLOSEANGLEBRACKET$2,S_URL),makeT$2(S_URL_OPENPAREN,CLOSEPAREN$2,S_URL),makeT$2(S_URL_OPENBRACE_Q,CLOSEBRACE$2,S_URL),makeT$2(S_URL_OPENBRACKET_Q,CLOSEBRACKET$2,S_URL),makeT$2(S_URL_OPENANGLEBRACKET_Q,CLOSEANGLEBRACKET$2,S_URL),makeT$2(S_URL_OPENPAREN_Q,CLOSEPAREN$2,S_URL),makeT$2(S_URL_OPENBRACE_SYMS,CLOSEBRACE$2,S_URL),makeT$2(S_URL_OPENBRACKET_SYMS,CLOSEBRACKET$2,S_URL),makeT$2(S_URL_OPENANGLEBRACKET_SYMS,CLOSEANGLEBRACKET$2,S_URL),makeT$2(S_URL_OPENPAREN_SYMS,CLOSEPAREN$2,S_URL),// URL that beings with an opening bracket, followed by a symbols.
// Note that the final state can still be `S_URL_OPENBRACE_Q` (if the URL only
// has a single opening bracket for some reason).
makeMultiT$2(S_URL_OPENBRACE,qsAccepting,S_URL_OPENBRACE_Q),makeMultiT$2(S_URL_OPENBRACKET,qsAccepting,S_URL_OPENBRACKET_Q),makeMultiT$2(S_URL_OPENANGLEBRACKET,qsAccepting,S_URL_OPENANGLEBRACKET_Q),makeMultiT$2(S_URL_OPENPAREN,qsAccepting,S_URL_OPENPAREN_Q),makeMultiT$2(S_URL_OPENBRACE,qsNonAccepting,S_URL_OPENBRACE_SYMS),makeMultiT$2(S_URL_OPENBRACKET,qsNonAccepting,S_URL_OPENBRACKET_SYMS),makeMultiT$2(S_URL_OPENANGLEBRACKET,qsNonAccepting,S_URL_OPENANGLEBRACKET_SYMS),makeMultiT$2(S_URL_OPENPAREN,qsNonAccepting,S_URL_OPENPAREN_SYMS),// URL that begins with an opening bracket, followed by some symbols
makeMultiT$2(S_URL_OPENBRACE_Q,qsAccepting,S_URL_OPENBRACE_Q),makeMultiT$2(S_URL_OPENBRACKET_Q,qsAccepting,S_URL_OPENBRACKET_Q),makeMultiT$2(S_URL_OPENANGLEBRACKET_Q,qsAccepting,S_URL_OPENANGLEBRACKET_Q),makeMultiT$2(S_URL_OPENPAREN_Q,qsAccepting,S_URL_OPENPAREN_Q),makeMultiT$2(S_URL_OPENBRACE_Q,qsNonAccepting,S_URL_OPENBRACE_Q),makeMultiT$2(S_URL_OPENBRACKET_Q,qsNonAccepting,S_URL_OPENBRACKET_Q),makeMultiT$2(S_URL_OPENANGLEBRACKET_Q,qsNonAccepting,S_URL_OPENANGLEBRACKET_Q),makeMultiT$2(S_URL_OPENPAREN_Q,qsNonAccepting,S_URL_OPENPAREN_Q),makeMultiT$2(S_URL_OPENBRACE_SYMS,qsAccepting,S_URL_OPENBRACE_Q),makeMultiT$2(S_URL_OPENBRACKET_SYMS,qsAccepting,S_URL_OPENBRACKET_Q),makeMultiT$2(S_URL_OPENANGLEBRACKET_SYMS,qsAccepting,S_URL_OPENANGLEBRACKET_Q),makeMultiT$2(S_URL_OPENPAREN_SYMS,qsAccepting,S_URL_OPENPAREN_Q),makeMultiT$2(S_URL_OPENBRACE_SYMS,qsNonAccepting,S_URL_OPENBRACE_SYMS),makeMultiT$2(S_URL_OPENBRACKET_SYMS,qsNonAccepting,S_URL_OPENBRACKET_SYMS),makeMultiT$2(S_URL_OPENANGLEBRACKET_SYMS,qsNonAccepting,S_URL_OPENANGLEBRACKET_SYMS),makeMultiT$2(S_URL_OPENPAREN_SYMS,qsNonAccepting,S_URL_OPENPAREN_SYMS),// Account for the query string
makeMultiT$2(S_URL,qsAccepting,S_URL),makeMultiT$2(S_URL_NON_ACCEPTING,qsAccepting,S_URL),makeMultiT$2(S_URL,qsNonAccepting,S_URL_NON_ACCEPTING),makeMultiT$2(S_URL_NON_ACCEPTING,qsNonAccepting,S_URL_NON_ACCEPTING),// Email address-specific state definitions
// Note: We are not allowing '/' in email addresses since this would interfere
// with real URLs
// For addresses with the mailto prefix
// 'mailto:' followed by anything sane is a valid email
makeT$2(S_MAILTO,TLD$2,S_MAILTO_EMAIL),makeT$2(S_MAILTO,DOMAIN$2,S_MAILTO_EMAIL),makeT$2(S_MAILTO,NUM$2,S_MAILTO_EMAIL),makeT$2(S_MAILTO,LOCALHOST$2,S_MAILTO_EMAIL),// Greedily get more potential valid email values
makeMultiT$2(S_MAILTO_EMAIL,qsAccepting,S_MAILTO_EMAIL),makeMultiT$2(S_MAILTO_EMAIL,qsNonAccepting,S_MAILTO_EMAIL_NON_ACCEPTING),makeMultiT$2(S_MAILTO_EMAIL_NON_ACCEPTING,qsAccepting,S_MAILTO_EMAIL),makeMultiT$2(S_MAILTO_EMAIL_NON_ACCEPTING,qsNonAccepting,S_MAILTO_EMAIL_NON_ACCEPTING);// For addresses without the mailto prefix
// Tokens allowed in the localpart of the email
var localpartAccepting=[AMPERSAND$2,APOSTROPHE$2,ASTERISK$2,BACKSLASH$2,BACKTICK$2,CARET$2,CLOSEBRACE$2,DOLLAR$2,DOMAIN$2,EQUALS$2,HYPHEN$2,NUM$2,OPENBRACE$2,PERCENT$2,PIPE$2,PLUS$2,POUND$2,QUERY$2,SLASH$2,SYM$2,TILDE$2,TLD$2,UNDERSCORE$2];// Some of the tokens in `localpartAccepting` are already accounted for here and
// will not be overwritten (don't worry)
// States following `@` defined above
return makeMultiT$2(S_DOMAIN,localpartAccepting,S_LOCALPART),makeT$2(S_DOMAIN,AT$2,S_LOCALPART_AT),makeMultiT$2(S_TLD,localpartAccepting,S_LOCALPART),makeT$2(S_TLD,AT$2,S_LOCALPART_AT),makeMultiT$2(S_DOMAIN_DOT,localpartAccepting,S_LOCALPART),// Now in localpart of address
// TODO: IP addresses and what if the email starts with numbers?
makeMultiT$2(S_LOCALPART,localpartAccepting,S_LOCALPART),makeT$2(S_LOCALPART,AT$2,S_LOCALPART_AT),// close to an email address now
makeT$2(S_LOCALPART,DOT$2,S_LOCALPART_DOT),makeMultiT$2(S_LOCALPART_DOT,localpartAccepting,S_LOCALPART),makeT$2(S_LOCALPART_AT,TLD$2,S_EMAIL_DOMAIN),makeT$2(S_LOCALPART_AT,DOMAIN$2,S_EMAIL_DOMAIN),makeT$2(S_LOCALPART_AT,NUM$2,S_EMAIL_DOMAIN),makeT$2(S_LOCALPART_AT,LOCALHOST$2,S_EMAIL),S_START}
/**
 * Run the parser state machine on a list of scanned string-based tokens to
 * create a list of multi tokens, each of which represents a URL, email address,
 * plain text, etc.
 *
 * @param {State} start parser start state
 * @param {string} input the original input used to generate the given tokens
 * @param {{t: string, v: string, s: number, e: number}[]} tokens list of scanned tokens
 * @returns {MultiToken[]}
 */function run$4(start,input,tokens){var len=tokens.length,cursor=0,multis=[],textTokens=[];while(cursor<len){var state=start,secondState=null,nextState=null,multiLength=0,latestAccepting=null,sinceAccepts=-1;while(cursor<len&&!(secondState=takeT$2(state,tokens[cursor].t)))
// Starting tokens with nowhere to jump to.
// Consider these to be just plain text
textTokens.push(tokens[cursor++]);while(cursor<len&&(nextState=secondState||takeT$2(state,tokens[cursor].t)))
// Get the next state
secondState=null,state=nextState,// Keep track of the latest accepting state
state.accepts()?(sinceAccepts=0,latestAccepting=state):sinceAccepts>=0&&sinceAccepts++,cursor++,multiLength++;if(sinceAccepts<0)
// No accepting state was found, part of a regular text token
// Add all the tokens we looked at to the text tokens array
for(var i=cursor-multiLength;i<cursor;i++)textTokens.push(tokens[i]);else{
// Accepting state!
// First close off the textTokens (if available)
textTokens.length>0&&(multis.push(parserCreateMultiToken$2(Text$3,input,textTokens)),textTokens=[]),// Roll back to the latest accepting state
cursor-=sinceAccepts,multiLength-=sinceAccepts;// Create a new multitoken
var Multi=latestAccepting.t,subtokens=tokens.slice(cursor-multiLength,cursor);multis.push(parserCreateMultiToken$2(Multi,input,subtokens))}}// Finally close off the textTokens (if available)
return textTokens.length>0&&multis.push(parserCreateMultiToken$2(Text$3,input,textTokens)),multis}
/**
 * Utility function for instantiating a new multitoken with all the relevant
 * fields during parsing.
 * @param {Class<MultiToken>} Multi class to instantiate
 * @param {string} input original input string
 * @param {{t: string, v: string, s: number, e: number}[]} tokens consecutive tokens scanned from input string
 * @returns {MultiToken}
 */function parserCreateMultiToken$2(Multi,input,tokens){var startIdx=tokens[0].s,endIdx=tokens[tokens.length-1].e,value=input.substr(startIdx,endIdx-startIdx);return new Multi(value,tokens)}var warn$2="undefined"!==typeof console&&console&&console.warn||function(){},INIT$2={scanner:null,parser:null,pluginQueue:[],customProtocols:[],initialized:!1};// Side-effect initialization state
/**
 * Detect URLs with the following additional protocol. Anything following
 * "protocol:" will be considered a link.
 * @param {string} protocol
 */
function registerCustomProtocol$2(protocol){if(INIT$2.initialized&&warn$2('linkifyjs: already initialized - will not register custom protocol "'.concat(protocol,'" until you manually call linkify.init(). To avoid this warning, please register all custom protocols before invoking linkify the first time.')),!/^[a-z-]+$/.test(protocol))throw Error("linkifyjs: protocols containing characters other than a-z or - (hyphen) are not supported");INIT$2.customProtocols.push(protocol)}
/**
 * Initialize the linkify state machine. Called automatically the first time
 * linkify is called on a string, but may be called manually as well.
 */function init$4(){
// Initialize state machines
INIT$2.scanner={start:init$2$2(INIT$2.customProtocols),tokens:text$3},INIT$2.parser={start:init$1$2(),tokens:multi$2};// Initialize plugins
for(var utils={createTokenClass:createTokenClass$2},i=0;i<INIT$2.pluginQueue.length;i++)INIT$2.pluginQueue[i][1]({scanner:INIT$2.scanner,parser:INIT$2.parser,utils:utils});INIT$2.initialized=!0}
/**
	Parse a string into tokens that represent linkable and non-linkable sub-components
	@param {string} str
	@return {MultiToken[]} tokens
*/function tokenize$2(str){return INIT$2.initialized||init$4(),run$4(INIT$2.parser.start,str,run$1$3(INIT$2.scanner.start,str))}
/**
	Find a list of linkable items in the given string.
	@param {string} str string to find links in
	@param {string} [type] (optional) only find links of a specific type, e.g.,
	'url' or 'email'
*/function find$2$2(str){for(var type=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,tokens=tokenize$2(str),filtered=[],i=0;i<tokens.length;i++){var token=tokens[i];!token.isLink||type&&token.t!==type||filtered.push(token.toObject())}return filtered}
/**
 * Is the given string valid linkable text of some sort. Note that this does not
 * trim the text for you.
 *
 * Optionally pass in a second `type` param, which is the type of link to test
 * for.
 *
 * For example,
 *
 *     linkify.test(str, 'email');
 *
 * Returns `true` if str is a valid email.
 * @param {string} str string to test for links
 * @param {string} [type] optional specific link type to look for
 * @returns boolean true/false
 */function test$2(str){var type=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,tokens=tokenize$2(str);return 1===tokens.length&&tokens[0].isLink&&(!type||tokens[0].t===type)}function autolink$2(options){return new Plugin$2({key:new PluginKey$2("autolink"),appendTransaction:(transactions,oldState,newState)=>{const docChanges=transactions.some((transaction=>transaction.docChanged))&&!oldState.doc.eq(newState.doc),preventAutolink=transactions.some((transaction=>transaction.getMeta("preventAutolink")));if(!docChanges||preventAutolink)return;const{tr:tr}=newState,transform=combineTransactionSteps$2(oldState.doc,[...transactions]),{mapping:mapping}=transform,changes=getChangedRanges$2(transform);return changes.forEach((({oldRange:oldRange,newRange:newRange})=>{
// at first we check if we have to remove links
getMarksBetween$2(oldRange.from,oldRange.to,oldState.doc).filter((item=>item.mark.type===options.type)).forEach((oldMark=>{const newFrom=mapping.map(oldMark.from),newTo=mapping.map(oldMark.to),newMarks=getMarksBetween$2(newFrom,newTo,newState.doc).filter((item=>item.mark.type===options.type));if(!newMarks.length)return;const newMark=newMarks[0],oldLinkText=oldState.doc.textBetween(oldMark.from,oldMark.to,void 0," "),newLinkText=newState.doc.textBetween(newMark.from,newMark.to,void 0," "),wasLink=test$2(oldLinkText),isLink=test$2(newLinkText);
// remove only the link, if it was a link before too
// because we don’t want to remove links that were set manually
wasLink&&!isLink&&tr.removeMark(newMark.from,newMark.to,options.type)})),
// now let’s see if we can add new links
findChildrenInRange$2(newState.doc,newRange,(node=>node.isTextblock)).forEach((textBlock=>{
// we need to define a placeholder for leaf nodes
// so that the link position can be calculated correctly
const text=newState.doc.textBetween(textBlock.pos,textBlock.pos+textBlock.node.nodeSize,void 0," ");find$2$2(text).filter((link=>link.isLink)).filter((link=>!options.validate||options.validate(link.value))).map((link=>({...link,from:textBlock.pos+link.start+1,to:textBlock.pos+link.end+1})
// check if link is within the changed range
)).filter((link=>{const fromIsInRange=newRange.from>=link.from&&newRange.from<=link.to,toIsInRange=newRange.to>=link.from&&newRange.to<=link.to;return fromIsInRange||toIsInRange})).forEach((link=>{tr.addMark(link.from,link.to,options.type.create({href:link.href}))}))}))})),tr.steps.length?tr:void 0}})}function clickHandler$2(options){return new Plugin$2({key:new PluginKey$2("handleClickLink"),props:{handleClick:(view,pos,event)=>{var _a;const attrs=getAttributes$2(view.state,options.type.name),link=null===(_a=event.target)||void 0===_a?void 0:_a.closest("a");return!(!link||!attrs.href)&&(window.open(attrs.href,attrs.target),!0)}}})}function pasteHandler$2(options){return new Plugin$2({key:new PluginKey$2("handlePasteLink"),props:{handlePaste:(view,event,slice)=>{const{state:state}=view,{selection:selection}=state,{empty:empty}=selection;if(empty)return!1;let textContent="";slice.content.forEach((node=>{textContent+=node.textContent}));const link=find$2$2(textContent).find((item=>item.isLink&&item.value===textContent));return!(!textContent||!link)&&(options.editor.commands.setMark(options.type,{href:link.href}),!0)}}})}const Link$1$2=Mark$3.create({name:"link",priority:1e3,keepOnSplit:!1,onCreate(){this.options.protocols.forEach(registerCustomProtocol$2)},inclusive(){return this.options.autolink},addOptions(){return{openOnClick:!0,linkOnPaste:!0,autolink:!0,protocols:[],HTMLAttributes:{target:"_blank",rel:"noopener noreferrer nofollow",class:null},validate:void 0}},addAttributes(){return{href:{default:null},target:{default:this.options.HTMLAttributes.target},class:{default:this.options.HTMLAttributes.class}}},parseHTML(){return[{tag:'a[href]:not([href *= "javascript:" i])'}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["a",mergeAttributes$2(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setLink:attributes=>({chain:chain})=>chain().setMark(this.name,attributes).setMeta("preventAutolink",!0).run(),toggleLink:attributes=>({chain:chain})=>chain().toggleMark(this.name,attributes,{extendEmptyMarkRange:!0}).setMeta("preventAutolink",!0).run(),unsetLink:()=>({chain:chain})=>chain().unsetMark(this.name,{extendEmptyMarkRange:!0}).setMeta("preventAutolink",!0).run()}},addPasteRules(){return[markPasteRule$2({find:text=>find$2$2(text).filter((link=>!this.options.validate||this.options.validate(link.value))).filter((link=>link.isLink)).map((link=>({text:link.value,index:link.start,data:link}))),type:this.type,getAttributes:match=>{var _a;return{href:null===(_a=match.data)||void 0===_a?void 0:_a.href}}})]},addProseMirrorPlugins(){const plugins=[];return this.options.autolink&&plugins.push(autolink$2({type:this.type,validate:this.options.validate})),this.options.openOnClick&&plugins.push(clickHandler$2({type:this.type})),this.options.linkOnPaste&&plugins.push(pasteHandler$2({editor:this.editor,type:this.type})),plugins}});function _typeof$6(obj){return _typeof$6="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof$6(obj)}function _defineProperty$1$2(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _classCallCheck$2(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _defineProperties$2(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass$2(Constructor,protoProps,staticProps){return protoProps&&_defineProperties$2(Constructor.prototype,protoProps),staticProps&&_defineProperties$2(Constructor,staticProps),Object.defineProperty(Constructor,"prototype",{writable:!1}),Constructor}
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */Link$1$2.extend({addAttributes(){return{href:{default:null},target:{default:this.options.HTMLAttributes.target},style:{default:null}}}});var isBrowser$2$2="undefined"!==typeof window&&"undefined"!==typeof document&&"undefined"!==typeof navigator,timeoutDuration$1$2=function(){for(var longerTimeoutBrowsers=["Edge","Trident","Firefox"],i=0;i<longerTimeoutBrowsers.length;i+=1)if(isBrowser$2$2&&navigator.userAgent.indexOf(longerTimeoutBrowsers[i])>=0)return 1;return 0}();function microtaskDebounce$1$2(fn){var called=!1;return function(){called||(called=!0,window.Promise.resolve().then((function(){called=!1,fn()})))}}function taskDebounce$1$2(fn){var scheduled=!1;return function(){scheduled||(scheduled=!0,setTimeout((function(){scheduled=!1,fn()}),timeoutDuration$1$2))}}var supportsMicroTasks$1$2=isBrowser$2$2&&window.Promise,debounce$2$2=supportsMicroTasks$1$2?microtaskDebounce$1$2:taskDebounce$1$2;
/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction$1$2(functionToCheck){var getType={};return functionToCheck&&"[object Function]"===getType.toString.call(functionToCheck)}
/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */function getStyleComputedProperty$1$2(element,property){if(1!==element.nodeType)return[];
// NOTE: 1 DOM access here
var window=element.ownerDocument.defaultView,css=window.getComputedStyle(element,null);return property?css[property]:css}
/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */function getParentNode$1$2(element){return"HTML"===element.nodeName?element:element.parentNode||element.host}
/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */function getScrollParent$1$2(element){
// Return body, `getScroll` will take care to get the correct `scrollTop` from it
if(!element)return document.body;switch(element.nodeName){case"HTML":case"BODY":return element.ownerDocument.body;case"#document":return element.body}
// Firefox want us to check `-x` and `-y` variations as well
var _getStyleComputedProp=getStyleComputedProperty$1$2(element),overflow=_getStyleComputedProp.overflow,overflowX=_getStyleComputedProp.overflowX,overflowY=_getStyleComputedProp.overflowY;return/(auto|scroll|overlay)/.test(overflow+overflowY+overflowX)?element:getScrollParent$1$2(getParentNode$1$2(element))}
/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */function getReferenceNode$1$2(reference){return reference&&reference.referenceNode?reference.referenceNode:reference}var isIE11$1$2=isBrowser$2$2&&!(!window.MSInputMethodContext||!document.documentMode),isIE10$1$2=isBrowser$2$2&&/MSIE 10/.test(navigator.userAgent);
/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE$3$2(version){return 11===version?isIE11$1$2:10===version?isIE10$1$2:isIE11$1$2||isIE10$1$2}
/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */function getOffsetParent$1$2(element){if(!element)return document.documentElement;var noOffsetParent=isIE$3$2(10)?document.body:null,offsetParent=element.offsetParent||null;
// NOTE: 1 DOM access here
// Skip hidden elements which don't have an offsetParent
while(offsetParent===noOffsetParent&&element.nextElementSibling)offsetParent=(element=element.nextElementSibling).offsetParent;var nodeName=offsetParent&&offsetParent.nodeName;return nodeName&&"BODY"!==nodeName&&"HTML"!==nodeName?
// .offsetParent will return the closest TH, TD or TABLE in case
// no offsetParent is present, I hate this job...
-1!==["TH","TD","TABLE"].indexOf(offsetParent.nodeName)&&"static"===getStyleComputedProperty$1$2(offsetParent,"position")?getOffsetParent$1$2(offsetParent):offsetParent:element?element.ownerDocument.documentElement:document.documentElement}function isOffsetContainer$1$2(element){var nodeName=element.nodeName;return"BODY"!==nodeName&&("HTML"===nodeName||getOffsetParent$1$2(element.firstElementChild)===element)}
/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */function getRoot$1$2(node){return null!==node.parentNode?getRoot$1$2(node.parentNode):node}
/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */function findCommonOffsetParent$1$2(element1,element2){
// This check is needed to avoid errors in case one of the elements isn't defined for any reason
if(!element1||!element1.nodeType||!element2||!element2.nodeType)return document.documentElement;
// Here we make sure to give as "start" the element that comes first in the DOM
var order=element1.compareDocumentPosition(element2)&Node.DOCUMENT_POSITION_FOLLOWING,start=order?element1:element2,end=order?element2:element1,range=document.createRange();range.setStart(start,0),range.setEnd(end,0);var commonAncestorContainer=range.commonAncestorContainer;
// Both nodes are inside #document
if(element1!==commonAncestorContainer&&element2!==commonAncestorContainer||start.contains(end))return isOffsetContainer$1$2(commonAncestorContainer)?commonAncestorContainer:getOffsetParent$1$2(commonAncestorContainer);
// one of the nodes is inside shadowDOM, find which one
var element1root=getRoot$1$2(element1);return element1root.host?findCommonOffsetParent$1$2(element1root.host,element2):findCommonOffsetParent$1$2(element1,getRoot$1$2(element2).host)}
/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */function getScroll$1$2(element){var side=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"top",upperSide="top"===side?"scrollTop":"scrollLeft",nodeName=element.nodeName;if("BODY"===nodeName||"HTML"===nodeName){var html=element.ownerDocument.documentElement,scrollingElement=element.ownerDocument.scrollingElement||html;return scrollingElement[upperSide]}return element[upperSide]}
/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */function includeScroll$1$2(rect,element){var subtract=arguments.length>2&&void 0!==arguments[2]&&arguments[2],scrollTop=getScroll$1$2(element,"top"),scrollLeft=getScroll$1$2(element,"left"),modifier=subtract?-1:1;return rect.top+=scrollTop*modifier,rect.bottom+=scrollTop*modifier,rect.left+=scrollLeft*modifier,rect.right+=scrollLeft*modifier,rect}
/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */function getBordersSize$1$2(styles,axis){var sideA="x"===axis?"Left":"Top",sideB="Left"===sideA?"Right":"Bottom";return parseFloat(styles["border"+sideA+"Width"])+parseFloat(styles["border"+sideB+"Width"])}function getSize$1$2(axis,body,html,computedStyle){return Math.max(body["offset"+axis],body["scroll"+axis],html["client"+axis],html["offset"+axis],html["scroll"+axis],isIE$3$2(10)?parseInt(html["offset"+axis])+parseInt(computedStyle["margin"+("Height"===axis?"Top":"Left")])+parseInt(computedStyle["margin"+("Height"===axis?"Bottom":"Right")]):0)}function getWindowSizes$1$2(document){var body=document.body,html=document.documentElement,computedStyle=isIE$3$2(10)&&getComputedStyle(html);return{height:getSize$1$2("Height",body,html,computedStyle),width:getSize$1$2("Width",body,html,computedStyle)}}var classCallCheck$1$2=function(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")},createClass$1$2=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),defineProperty$1$2=function(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj},_extends$2$2=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target};
/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect$1$2(offsets){return _extends$2$2({},offsets,{right:offsets.left+offsets.width,bottom:offsets.top+offsets.height})}
/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */function getBoundingClientRect$1$2(element){var rect={};
// IE10 10 FIX: Please, don't ask, the element isn't
// considered in DOM in some circumstances...
// This isn't reproducible in IE10 compatibility mode of IE11
try{if(isIE$3$2(10)){rect=element.getBoundingClientRect();var scrollTop=getScroll$1$2(element,"top"),scrollLeft=getScroll$1$2(element,"left");rect.top+=scrollTop,rect.left+=scrollLeft,rect.bottom+=scrollTop,rect.right+=scrollLeft}else rect=element.getBoundingClientRect()}catch(e){}var result={left:rect.left,top:rect.top,width:rect.right-rect.left,height:rect.bottom-rect.top},sizes="HTML"===element.nodeName?getWindowSizes$1$2(element.ownerDocument):{},width=sizes.width||element.clientWidth||result.width,height=sizes.height||element.clientHeight||result.height,horizScrollbar=element.offsetWidth-width,vertScrollbar=element.offsetHeight-height;
// subtract scrollbar size from sizes
// if an hypothetical scrollbar is detected, we must be sure it's not a `border`
// we make this check conditional for performance reasons
if(horizScrollbar||vertScrollbar){var styles=getStyleComputedProperty$1$2(element);horizScrollbar-=getBordersSize$1$2(styles,"x"),vertScrollbar-=getBordersSize$1$2(styles,"y"),result.width-=horizScrollbar,result.height-=vertScrollbar}return getClientRect$1$2(result)}function getOffsetRectRelativeToArbitraryNode$1$2(children,parent){var fixedPosition=arguments.length>2&&void 0!==arguments[2]&&arguments[2],isIE10=isIE$3$2(10),isHTML="HTML"===parent.nodeName,childrenRect=getBoundingClientRect$1$2(children),parentRect=getBoundingClientRect$1$2(parent),scrollParent=getScrollParent$1$2(children),styles=getStyleComputedProperty$1$2(parent),borderTopWidth=parseFloat(styles.borderTopWidth),borderLeftWidth=parseFloat(styles.borderLeftWidth);
// In cases where the parent is fixed, we must ignore negative scroll in offset calc
fixedPosition&&isHTML&&(parentRect.top=Math.max(parentRect.top,0),parentRect.left=Math.max(parentRect.left,0));var offsets=getClientRect$1$2({top:childrenRect.top-parentRect.top-borderTopWidth,left:childrenRect.left-parentRect.left-borderLeftWidth,width:childrenRect.width,height:childrenRect.height});
// Subtract margins of documentElement in case it's being used as parent
// we do this only on HTML because it's the only element that behaves
// differently when margins are applied to it. The margins are included in
// the box of the documentElement, in the other cases not.
if(offsets.marginTop=0,offsets.marginLeft=0,!isIE10&&isHTML){var marginTop=parseFloat(styles.marginTop),marginLeft=parseFloat(styles.marginLeft);offsets.top-=borderTopWidth-marginTop,offsets.bottom-=borderTopWidth-marginTop,offsets.left-=borderLeftWidth-marginLeft,offsets.right-=borderLeftWidth-marginLeft,
// Attach marginTop and marginLeft because in some circumstances we may need them
offsets.marginTop=marginTop,offsets.marginLeft=marginLeft}return(isIE10&&!fixedPosition?parent.contains(scrollParent):parent===scrollParent&&"BODY"!==scrollParent.nodeName)&&(offsets=includeScroll$1$2(offsets,parent)),offsets}function getViewportOffsetRectRelativeToArtbitraryNode$1$2(element){var excludeScroll=arguments.length>1&&void 0!==arguments[1]&&arguments[1],html=element.ownerDocument.documentElement,relativeOffset=getOffsetRectRelativeToArbitraryNode$1$2(element,html),width=Math.max(html.clientWidth,window.innerWidth||0),height=Math.max(html.clientHeight,window.innerHeight||0),scrollTop=excludeScroll?0:getScroll$1$2(html),scrollLeft=excludeScroll?0:getScroll$1$2(html,"left"),offset={top:scrollTop-relativeOffset.top+relativeOffset.marginTop,left:scrollLeft-relativeOffset.left+relativeOffset.marginLeft,width:width,height:height};return getClientRect$1$2(offset)}
/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */function isFixed$1$2(element){var nodeName=element.nodeName;if("BODY"===nodeName||"HTML"===nodeName)return!1;if("fixed"===getStyleComputedProperty$1$2(element,"position"))return!0;var parentNode=getParentNode$1$2(element);return!!parentNode&&isFixed$1$2(parentNode)}
/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */function getFixedPositionOffsetParent$1$2(element){
// This check is needed to avoid errors in case one of the elements isn't defined for any reason
if(!element||!element.parentElement||isIE$3$2())return document.documentElement;var el=element.parentElement;while(el&&"none"===getStyleComputedProperty$1$2(el,"transform"))el=el.parentElement;return el||document.documentElement}
/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */function getBoundaries$1$2(popper,reference,padding,boundariesElement){var fixedPosition=arguments.length>4&&void 0!==arguments[4]&&arguments[4],boundaries={top:0,left:0},offsetParent=fixedPosition?getFixedPositionOffsetParent$1$2(popper):findCommonOffsetParent$1$2(popper,getReferenceNode$1$2(reference));
// NOTE: 1 DOM access here
// Handle viewport case
if("viewport"===boundariesElement)boundaries=getViewportOffsetRectRelativeToArtbitraryNode$1$2(offsetParent,fixedPosition);else{
// Handle other cases based on DOM element used as boundaries
var boundariesNode=void 0;"scrollParent"===boundariesElement?(boundariesNode=getScrollParent$1$2(getParentNode$1$2(reference)),"BODY"===boundariesNode.nodeName&&(boundariesNode=popper.ownerDocument.documentElement)):boundariesNode="window"===boundariesElement?popper.ownerDocument.documentElement:boundariesElement;var offsets=getOffsetRectRelativeToArbitraryNode$1$2(boundariesNode,offsetParent,fixedPosition);
// In case of HTML, we need a different computation
if("HTML"!==boundariesNode.nodeName||isFixed$1$2(offsetParent))
// for all the other DOM elements, this one is good
boundaries=offsets;else{var _getWindowSizes=getWindowSizes$1$2(popper.ownerDocument),height=_getWindowSizes.height,width=_getWindowSizes.width;boundaries.top+=offsets.top-offsets.marginTop,boundaries.bottom=height+offsets.top,boundaries.left+=offsets.left-offsets.marginLeft,boundaries.right=width+offsets.left}}
// Add paddings
padding=padding||0;var isPaddingNumber="number"===typeof padding;return boundaries.left+=isPaddingNumber?padding:padding.left||0,boundaries.top+=isPaddingNumber?padding:padding.top||0,boundaries.right-=isPaddingNumber?padding:padding.right||0,boundaries.bottom-=isPaddingNumber?padding:padding.bottom||0,boundaries}function getArea$1$2(_ref){var width=_ref.width,height=_ref.height;return width*height}
/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function computeAutoPlacement$1$2(placement,refRect,popper,reference,boundariesElement){var padding=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(-1===placement.indexOf("auto"))return placement;var boundaries=getBoundaries$1$2(popper,reference,padding,boundariesElement),rects={top:{width:boundaries.width,height:refRect.top-boundaries.top},right:{width:boundaries.right-refRect.right,height:boundaries.height},bottom:{width:boundaries.width,height:boundaries.bottom-refRect.bottom},left:{width:refRect.left-boundaries.left,height:boundaries.height}},sortedAreas=Object.keys(rects).map((function(key){return _extends$2$2({key:key},rects[key],{area:getArea$1$2(rects[key])})})).sort((function(a,b){return b.area-a.area})),filteredAreas=sortedAreas.filter((function(_ref2){var width=_ref2.width,height=_ref2.height;return width>=popper.clientWidth&&height>=popper.clientHeight})),computedPlacement=filteredAreas.length>0?filteredAreas[0].key:sortedAreas[0].key,variation=placement.split("-")[1];return computedPlacement+(variation?"-"+variation:"")}
/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */function getReferenceOffsets$1$2(state,popper,reference){var fixedPosition=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,commonOffsetParent=fixedPosition?getFixedPositionOffsetParent$1$2(popper):findCommonOffsetParent$1$2(popper,getReferenceNode$1$2(reference));return getOffsetRectRelativeToArbitraryNode$1$2(reference,commonOffsetParent,fixedPosition)}
/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */function getOuterSizes$1$2(element){var window=element.ownerDocument.defaultView,styles=window.getComputedStyle(element),x=parseFloat(styles.marginTop||0)+parseFloat(styles.marginBottom||0),y=parseFloat(styles.marginLeft||0)+parseFloat(styles.marginRight||0),result={width:element.offsetWidth+y,height:element.offsetHeight+x};return result}
/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */function getOppositePlacement$1$2(placement){var hash={left:"right",right:"left",bottom:"top",top:"bottom"};return placement.replace(/left|right|bottom|top/g,(function(matched){return hash[matched]}))}
/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */function getPopperOffsets$1$2(popper,referenceOffsets,placement){placement=placement.split("-")[0];
// Get popper node sizes
var popperRect=getOuterSizes$1$2(popper),popperOffsets={width:popperRect.width,height:popperRect.height},isHoriz=-1!==["right","left"].indexOf(placement),mainSide=isHoriz?"top":"left",secondarySide=isHoriz?"left":"top",measurement=isHoriz?"height":"width",secondaryMeasurement=isHoriz?"width":"height";
// Add position, width and height to our offsets object
return popperOffsets[mainSide]=referenceOffsets[mainSide]+referenceOffsets[measurement]/2-popperRect[measurement]/2,popperOffsets[secondarySide]=placement===secondarySide?referenceOffsets[secondarySide]-popperRect[secondaryMeasurement]:referenceOffsets[getOppositePlacement$1$2(secondarySide)],popperOffsets}
/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */function find$1$2(arr,check){
// use native find if supported
return Array.prototype.find?arr.find(check):arr.filter(check)[0];
// use `filter` to obtain the same behavior of `find`
}
/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */function findIndex$1$2(arr,prop,value){
// use native findIndex if supported
if(Array.prototype.findIndex)return arr.findIndex((function(cur){return cur[prop]===value}));
// use `find` + `indexOf` if `findIndex` isn't supported
var match=find$1$2(arr,(function(obj){return obj[prop]===value}));return arr.indexOf(match)}
/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */function runModifiers$1$2(modifiers,data,ends){var modifiersToRun=void 0===ends?modifiers:modifiers.slice(0,findIndex$1$2(modifiers,"name",ends));return modifiersToRun.forEach((function(modifier){modifier["function"];var fn=modifier["function"]||modifier.fn;// eslint-disable-line dot-notation
modifier.enabled&&isFunction$1$2(fn)&&(
// Add properties to offsets to make them a complete clientRect object
// we do this before each modifier to make sure the previous one doesn't
// mess with these values
data.offsets.popper=getClientRect$1$2(data.offsets.popper),data.offsets.reference=getClientRect$1$2(data.offsets.reference),data=fn(data,modifier))})),data}
/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */function update$1$2(){
// if popper is destroyed, don't perform any further update
if(!this.state.isDestroyed){var data={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};
// compute reference element offsets
data.offsets.reference=getReferenceOffsets$1$2(this.state,this.popper,this.reference,this.options.positionFixed),
// compute auto placement, store placement inside the data object,
// modifiers will be able to edit `placement` if needed
// and refer to originalPlacement to know the original value
data.placement=computeAutoPlacement$1$2(this.options.placement,data.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),
// store the computed placement inside `originalPlacement`
data.originalPlacement=data.placement,data.positionFixed=this.options.positionFixed,
// compute the popper offsets
data.offsets.popper=getPopperOffsets$1$2(this.popper,data.offsets.reference,data.placement),data.offsets.popper.position=this.options.positionFixed?"fixed":"absolute",
// run the modifiers
data=runModifiers$1$2(this.modifiers,data),
// the first `update` will call `onCreate` callback
// the other ones will call `onUpdate` callback
this.state.isCreated?this.options.onUpdate(data):(this.state.isCreated=!0,this.options.onCreate(data))}}
/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */function isModifierEnabled$1$2(modifiers,modifierName){return modifiers.some((function(_ref){var name=_ref.name,enabled=_ref.enabled;return enabled&&name===modifierName}))}
/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */function getSupportedPropertyName$1$2(property){for(var prefixes=[!1,"ms","Webkit","Moz","O"],upperProp=property.charAt(0).toUpperCase()+property.slice(1),i=0;i<prefixes.length;i++){var prefix=prefixes[i],toCheck=prefix?""+prefix+upperProp:property;if("undefined"!==typeof document.body.style[toCheck])return toCheck}return null}
/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */function destroy$1$2(){return this.state.isDestroyed=!0,
// touch DOM only if `applyStyle` modifier is enabled
isModifierEnabled$1$2(this.modifiers,"applyStyle")&&(this.popper.removeAttribute("x-placement"),this.popper.style.position="",this.popper.style.top="",this.popper.style.left="",this.popper.style.right="",this.popper.style.bottom="",this.popper.style.willChange="",this.popper.style[getSupportedPropertyName$1$2("transform")]=""),this.disableEventListeners(),
// remove the popper if user explicitly asked for the deletion on destroy
// do not use `remove` because IE11 doesn't support it
this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}
/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */function getWindow$1$2(element){var ownerDocument=element.ownerDocument;return ownerDocument?ownerDocument.defaultView:window}function attachToScrollParents$1$2(scrollParent,event,callback,scrollParents){var isBody="BODY"===scrollParent.nodeName,target=isBody?scrollParent.ownerDocument.defaultView:scrollParent;target.addEventListener(event,callback,{passive:!0}),isBody||attachToScrollParents$1$2(getScrollParent$1$2(target.parentNode),event,callback,scrollParents),scrollParents.push(target)}
/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */function setupEventListeners$1$2(reference,options,state,updateBound){
// Resize event listener on window
state.updateBound=updateBound,getWindow$1$2(reference).addEventListener("resize",state.updateBound,{passive:!0});
// Scroll event listener on scroll parents
var scrollElement=getScrollParent$1$2(reference);return attachToScrollParents$1$2(scrollElement,"scroll",state.updateBound,state.scrollParents),state.scrollElement=scrollElement,state.eventsEnabled=!0,state}
/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */function enableEventListeners$1$2(){this.state.eventsEnabled||(this.state=setupEventListeners$1$2(this.reference,this.options,this.state,this.scheduleUpdate))}
/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */function removeEventListeners$1$2(reference,state){
// Remove resize event listener on window
return getWindow$1$2(reference).removeEventListener("resize",state.updateBound),
// Remove scroll event listener on scroll parents
state.scrollParents.forEach((function(target){target.removeEventListener("scroll",state.updateBound)})),
// Reset state
state.updateBound=null,state.scrollParents=[],state.scrollElement=null,state.eventsEnabled=!1,state}
/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */function disableEventListeners$1$2(){this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=removeEventListeners$1$2(this.reference,this.state))}
/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */function isNumeric$1$2(n){return""!==n&&!isNaN(parseFloat(n))&&isFinite(n)}
/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */function setStyles$1$2(element,styles){Object.keys(styles).forEach((function(prop){var unit="";
// add unit if the value is numeric and is one of the following
-1!==["width","height","top","right","bottom","left"].indexOf(prop)&&isNumeric$1$2(styles[prop])&&(unit="px"),element.style[prop]=styles[prop]+unit}))}
/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */function setAttributes$1$2(element,attributes){Object.keys(attributes).forEach((function(prop){var value=attributes[prop];!1!==value?element.setAttribute(prop,attributes[prop]):element.removeAttribute(prop)}))}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */function applyStyle$1$2(data){
// any property present in `data.styles` will be applied to the popper,
// in this way we can make the 3rd party modifiers add custom styles to it
// Be aware, modifiers could override the properties defined in the previous
// lines of this modifier!
return setStyles$1$2(data.instance.popper,data.styles),
// any property present in `data.attributes` will be applied to the popper,
// they will be set as HTML attributes of the element
setAttributes$1$2(data.instance.popper,data.attributes),
// if arrowElement is defined and arrowStyles has some properties
data.arrowElement&&Object.keys(data.arrowStyles).length&&setStyles$1$2(data.arrowElement,data.arrowStyles),data}
/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */function applyStyleOnLoad$1$2(reference,popper,options,modifierOptions,state){
// compute reference element offsets
var referenceOffsets=getReferenceOffsets$1$2(state,popper,reference,options.positionFixed),placement=computeAutoPlacement$1$2(options.placement,referenceOffsets,popper,reference,options.modifiers.flip.boundariesElement,options.modifiers.flip.padding);
// compute auto placement, store placement inside the data object,
// modifiers will be able to edit `placement` if needed
// and refer to originalPlacement to know the original value
return popper.setAttribute("x-placement",placement),
// Apply `position` to popper before anything else because
// without the position applied we can't guarantee correct computations
setStyles$1$2(popper,{position:options.positionFixed?"fixed":"absolute"}),options}
/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */function getRoundedOffsets$1$2(data,shouldRound){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,round=Math.round,floor=Math.floor,noRound=function(v){return v},referenceWidth=round(reference.width),popperWidth=round(popper.width),isVertical=-1!==["left","right"].indexOf(data.placement),isVariation=-1!==data.placement.indexOf("-"),sameWidthParity=referenceWidth%2===popperWidth%2,bothOddWidth=referenceWidth%2===1&&popperWidth%2===1,horizontalToInteger=shouldRound?isVertical||isVariation||sameWidthParity?round:floor:noRound,verticalToInteger=shouldRound?round:noRound;return{left:horizontalToInteger(bothOddWidth&&!isVariation&&shouldRound?popper.left-1:popper.left),top:verticalToInteger(popper.top),bottom:verticalToInteger(popper.bottom),right:horizontalToInteger(popper.right)}}var isFirefox$1$2=isBrowser$2$2&&/Firefox/i.test(navigator.userAgent);
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function computeStyle$1$2(data,options){var x=options.x,y=options.y,popper=data.offsets.popper,legacyGpuAccelerationOption=find$1$2(data.instance.modifiers,(function(modifier){return"applyStyle"===modifier.name})).gpuAcceleration,gpuAcceleration=void 0!==legacyGpuAccelerationOption?legacyGpuAccelerationOption:options.gpuAcceleration,offsetParent=getOffsetParent$1$2(data.instance.popper),offsetParentRect=getBoundingClientRect$1$2(offsetParent),styles={position:popper.position},offsets=getRoundedOffsets$1$2(data,window.devicePixelRatio<2||!isFirefox$1$2),sideA="bottom"===x?"top":"bottom",sideB="right"===y?"left":"right",prefixedProperty=getSupportedPropertyName$1$2("transform"),left=void 0,top=void 0;if(top="bottom"===sideA?
// when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
// and not the bottom of the html element
"HTML"===offsetParent.nodeName?-offsetParent.clientHeight+offsets.bottom:-offsetParentRect.height+offsets.bottom:offsets.top,left="right"===sideB?"HTML"===offsetParent.nodeName?-offsetParent.clientWidth+offsets.right:-offsetParentRect.width+offsets.right:offsets.left,gpuAcceleration&&prefixedProperty)styles[prefixedProperty]="translate3d("+left+"px, "+top+"px, 0)",styles[sideA]=0,styles[sideB]=0,styles.willChange="transform";else{
// othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
var invertTop="bottom"===sideA?-1:1,invertLeft="right"===sideB?-1:1;styles[sideA]=top*invertTop,styles[sideB]=left*invertLeft,styles.willChange=sideA+", "+sideB}
// Attributes
var attributes={"x-placement":data.placement};
// Update `data` attributes, styles and arrowStyles
return data.attributes=_extends$2$2({},attributes,data.attributes),data.styles=_extends$2$2({},styles,data.styles),data.arrowStyles=_extends$2$2({},data.offsets.arrow,data.arrowStyles),data}
/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */function isModifierRequired$1$2(modifiers,requestingName,requestedName){var requesting=find$1$2(modifiers,(function(_ref){var name=_ref.name;return name===requestingName})),isRequired=!!requesting&&modifiers.some((function(modifier){return modifier.name===requestedName&&modifier.enabled&&modifier.order<requesting.order}));if(!isRequired);return isRequired}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function arrow$1$2(data,options){var _data$offsets$arrow;
// arrow depends on keepTogether in order to work
if(!isModifierRequired$1$2(data.instance.modifiers,"arrow","keepTogether"))return data;var arrowElement=options.element;
// if arrowElement is a string, suppose it's a CSS selector
if("string"===typeof arrowElement){
// if arrowElement is not found, don't run the modifier
if(arrowElement=data.instance.popper.querySelector(arrowElement),!arrowElement)return data}else
// if the arrowElement isn't a query selector we must check that the
// provided DOM node is child of its popper node
if(!data.instance.popper.contains(arrowElement))return data;var placement=data.placement.split("-")[0],_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,isVertical=-1!==["left","right"].indexOf(placement),len=isVertical?"height":"width",sideCapitalized=isVertical?"Top":"Left",side=sideCapitalized.toLowerCase(),altSide=isVertical?"left":"top",opSide=isVertical?"bottom":"right",arrowElementSize=getOuterSizes$1$2(arrowElement)[len];
// extends keepTogether behavior making sure the popper and its
// reference have enough pixels in conjunction
// top/left side
reference[opSide]-arrowElementSize<popper[side]&&(data.offsets.popper[side]-=popper[side]-(reference[opSide]-arrowElementSize)),
// bottom/right side
reference[side]+arrowElementSize>popper[opSide]&&(data.offsets.popper[side]+=reference[side]+arrowElementSize-popper[opSide]),data.offsets.popper=getClientRect$1$2(data.offsets.popper);
// compute center of the popper
var center=reference[side]+reference[len]/2-arrowElementSize/2,css=getStyleComputedProperty$1$2(data.instance.popper),popperMarginSide=parseFloat(css["margin"+sideCapitalized]),popperBorderSide=parseFloat(css["border"+sideCapitalized+"Width"]),sideValue=center-data.offsets.popper[side]-popperMarginSide-popperBorderSide;
// Compute the sideValue using the updated popper offsets
// take popper margin in account because we don't have this info available
// prevent arrowElement from being placed not contiguously to its popper
return sideValue=Math.max(Math.min(popper[len]-arrowElementSize,sideValue),0),data.arrowElement=arrowElement,data.offsets.arrow=(_data$offsets$arrow={},defineProperty$1$2(_data$offsets$arrow,side,Math.round(sideValue)),defineProperty$1$2(_data$offsets$arrow,altSide,""),_data$offsets$arrow),data}
/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */function getOppositeVariation$1$2(variation){return"end"===variation?"start":"start"===variation?"end":variation}
/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */var placements$1$2=["auto-start","auto","auto-end","top-start","top","top-end","right-start","right","right-end","bottom-end","bottom","bottom-start","left-end","left","left-start"],validPlacements$1$2=placements$1$2.slice(3);
// Get rid of `auto` `auto-start` and `auto-end`
/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise$1$2(placement){var counter=arguments.length>1&&void 0!==arguments[1]&&arguments[1],index=validPlacements$1$2.indexOf(placement),arr=validPlacements$1$2.slice(index+1).concat(validPlacements$1$2.slice(0,index));return counter?arr.reverse():arr}var BEHAVIORS$1$2={FLIP:"flip",CLOCKWISE:"clockwise",COUNTERCLOCKWISE:"counterclockwise"};
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function flip$1$2(data,options){
// if `inner` modifier is enabled, we can't use the `flip` modifier
if(isModifierEnabled$1$2(data.instance.modifiers,"inner"))return data;if(data.flipped&&data.placement===data.originalPlacement)
// seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
return data;var boundaries=getBoundaries$1$2(data.instance.popper,data.instance.reference,options.padding,options.boundariesElement,data.positionFixed),placement=data.placement.split("-")[0],placementOpposite=getOppositePlacement$1$2(placement),variation=data.placement.split("-")[1]||"",flipOrder=[];switch(options.behavior){case BEHAVIORS$1$2.FLIP:flipOrder=[placement,placementOpposite];break;case BEHAVIORS$1$2.CLOCKWISE:flipOrder=clockwise$1$2(placement);break;case BEHAVIORS$1$2.COUNTERCLOCKWISE:flipOrder=clockwise$1$2(placement,!0);break;default:flipOrder=options.behavior}return flipOrder.forEach((function(step,index){if(placement!==step||flipOrder.length===index+1)return data;placement=data.placement.split("-")[0],placementOpposite=getOppositePlacement$1$2(placement);var popperOffsets=data.offsets.popper,refOffsets=data.offsets.reference,floor=Math.floor,overlapsRef="left"===placement&&floor(popperOffsets.right)>floor(refOffsets.left)||"right"===placement&&floor(popperOffsets.left)<floor(refOffsets.right)||"top"===placement&&floor(popperOffsets.bottom)>floor(refOffsets.top)||"bottom"===placement&&floor(popperOffsets.top)<floor(refOffsets.bottom),overflowsLeft=floor(popperOffsets.left)<floor(boundaries.left),overflowsRight=floor(popperOffsets.right)>floor(boundaries.right),overflowsTop=floor(popperOffsets.top)<floor(boundaries.top),overflowsBottom=floor(popperOffsets.bottom)>floor(boundaries.bottom),overflowsBoundaries="left"===placement&&overflowsLeft||"right"===placement&&overflowsRight||"top"===placement&&overflowsTop||"bottom"===placement&&overflowsBottom,isVertical=-1!==["top","bottom"].indexOf(placement),flippedVariationByRef=!!options.flipVariations&&(isVertical&&"start"===variation&&overflowsLeft||isVertical&&"end"===variation&&overflowsRight||!isVertical&&"start"===variation&&overflowsTop||!isVertical&&"end"===variation&&overflowsBottom),flippedVariationByContent=!!options.flipVariationsByContent&&(isVertical&&"start"===variation&&overflowsRight||isVertical&&"end"===variation&&overflowsLeft||!isVertical&&"start"===variation&&overflowsBottom||!isVertical&&"end"===variation&&overflowsTop),flippedVariation=flippedVariationByRef||flippedVariationByContent;(overlapsRef||overflowsBoundaries||flippedVariation)&&(
// this boolean to detect any flip loop
data.flipped=!0,(overlapsRef||overflowsBoundaries)&&(placement=flipOrder[index+1]),flippedVariation&&(variation=getOppositeVariation$1$2(variation)),data.placement=placement+(variation?"-"+variation:""),
// this object contains `position`, we want to preserve it along with
// any additional property we may add in the future
data.offsets.popper=_extends$2$2({},data.offsets.popper,getPopperOffsets$1$2(data.instance.popper,data.offsets.reference,data.placement)),data=runModifiers$1$2(data.instance.modifiers,data,"flip"))})),data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function keepTogether$1$2(data){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,placement=data.placement.split("-")[0],floor=Math.floor,isVertical=-1!==["top","bottom"].indexOf(placement),side=isVertical?"right":"bottom",opSide=isVertical?"left":"top",measurement=isVertical?"width":"height";return popper[side]<floor(reference[opSide])&&(data.offsets.popper[opSide]=floor(reference[opSide])-popper[measurement]),popper[opSide]>floor(reference[side])&&(data.offsets.popper[opSide]=floor(reference[side])),data}
/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */function toValue$1$2(str,measurement,popperOffsets,referenceOffsets){
// separate value from unit
var split=str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),value=+split[1],unit=split[2];
// If it's not a number it's an operator, I guess
if(!value)return str;if(0===unit.indexOf("%")){var element=void 0;switch(unit){case"%p":element=popperOffsets;break;case"%":case"%r":default:element=referenceOffsets}var rect=getClientRect$1$2(element);return rect[measurement]/100*value}if("vh"===unit||"vw"===unit){
// if is a vh or vw, we calculate the size based on the viewport
var size=void 0;return size="vh"===unit?Math.max(document.documentElement.clientHeight,window.innerHeight||0):Math.max(document.documentElement.clientWidth,window.innerWidth||0),size/100*value}
// if is an explicit pixel unit, we get rid of the unit and keep the value
// if is an implicit unit, it's px, and we return just the value
return value}
/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */function parseOffset$1$2(offset,popperOffsets,referenceOffsets,basePlacement){var offsets=[0,0],useHeight=-1!==["right","left"].indexOf(basePlacement),fragments=offset.split(/(\+|\-)/).map((function(frag){return frag.trim()})),divider=fragments.indexOf(find$1$2(fragments,(function(frag){return-1!==frag.search(/,|\s/)})));
// Use height if placement is left or right and index is 0 otherwise use width
// in this way the first offset will use an axis and the second one
// will use the other one
fragments[divider]&&fragments[divider].indexOf(",");
// If divider is found, we divide the list of values and operands to divide
// them by ofset X and Y.
var splitRegex=/\s*,\s*|\s+/,ops=-1!==divider?[fragments.slice(0,divider).concat([fragments[divider].split(splitRegex)[0]]),[fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider+1))]:[fragments];
// Convert the values with units to absolute pixels to allow our computations
return ops=ops.map((function(op,index){
// Most of the units rely on the orientation of the popper
var measurement=(1===index?!useHeight:useHeight)?"height":"width",mergeWithPrevious=!1;return op.reduce((function(a,b){return""===a[a.length-1]&&-1!==["+","-"].indexOf(b)?(a[a.length-1]=b,mergeWithPrevious=!0,a):mergeWithPrevious?(a[a.length-1]+=b,mergeWithPrevious=!1,a):a.concat(b)}),[]).map((function(str){return toValue$1$2(str,measurement,popperOffsets,referenceOffsets)}))})),
// Loop trough the offsets arrays and execute the operations
ops.forEach((function(op,index){op.forEach((function(frag,index2){isNumeric$1$2(frag)&&(offsets[index]+=frag*("-"===op[index2-1]?-1:1))}))})),offsets}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */function offset$1$2(data,_ref){var offset=_ref.offset,placement=data.placement,_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,basePlacement=placement.split("-")[0],offsets=void 0;return offsets=isNumeric$1$2(+offset)?[+offset,0]:parseOffset$1$2(offset,popper,reference,basePlacement),"left"===basePlacement?(popper.top+=offsets[0],popper.left-=offsets[1]):"right"===basePlacement?(popper.top+=offsets[0],popper.left+=offsets[1]):"top"===basePlacement?(popper.left+=offsets[0],popper.top-=offsets[1]):"bottom"===basePlacement&&(popper.left+=offsets[0],popper.top+=offsets[1]),data.popper=popper,data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function preventOverflow$1$2(data,options){var boundariesElement=options.boundariesElement||getOffsetParent$1$2(data.instance.popper);
// If offsetParent is the reference element, we really want to
// go one step up and use the next offsetParent as reference to
// avoid to make this modifier completely useless and look like broken
data.instance.reference===boundariesElement&&(boundariesElement=getOffsetParent$1$2(boundariesElement));
// NOTE: DOM access here
// resets the popper's position so that the document size can be calculated excluding
// the size of the popper element itself
var transformProp=getSupportedPropertyName$1$2("transform"),popperStyles=data.instance.popper.style,top=popperStyles.top,left=popperStyles.left,transform=popperStyles[transformProp];popperStyles.top="",popperStyles.left="",popperStyles[transformProp]="";var boundaries=getBoundaries$1$2(data.instance.popper,data.instance.reference,options.padding,boundariesElement,data.positionFixed);
// NOTE: DOM access here
// restores the original style properties after the offsets have been computed
popperStyles.top=top,popperStyles.left=left,popperStyles[transformProp]=transform,options.boundaries=boundaries;var order=options.priority,popper=data.offsets.popper,check={primary:function(placement){var value=popper[placement];return popper[placement]<boundaries[placement]&&!options.escapeWithReference&&(value=Math.max(popper[placement],boundaries[placement])),defineProperty$1$2({},placement,value)},secondary:function(placement){var mainSide="right"===placement?"left":"top",value=popper[mainSide];return popper[placement]>boundaries[placement]&&!options.escapeWithReference&&(value=Math.min(popper[mainSide],boundaries[placement]-("right"===placement?popper.width:popper.height))),defineProperty$1$2({},mainSide,value)}};return order.forEach((function(placement){var side=-1!==["left","top"].indexOf(placement)?"primary":"secondary";popper=_extends$2$2({},popper,check[side](placement))})),data.offsets.popper=popper,data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function shift$1$2(data){var placement=data.placement,basePlacement=placement.split("-")[0],shiftvariation=placement.split("-")[1];
// if shift shiftvariation is specified, run the modifier
if(shiftvariation){var _data$offsets=data.offsets,reference=_data$offsets.reference,popper=_data$offsets.popper,isVertical=-1!==["bottom","top"].indexOf(basePlacement),side=isVertical?"left":"top",measurement=isVertical?"width":"height",shiftOffsets={start:defineProperty$1$2({},side,reference[side]),end:defineProperty$1$2({},side,reference[side]+reference[measurement]-popper[measurement])};data.offsets.popper=_extends$2$2({},popper,shiftOffsets[shiftvariation])}return data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function hide$1$2(data){if(!isModifierRequired$1$2(data.instance.modifiers,"hide","preventOverflow"))return data;var refRect=data.offsets.reference,bound=find$1$2(data.instance.modifiers,(function(modifier){return"preventOverflow"===modifier.name})).boundaries;if(refRect.bottom<bound.top||refRect.left>bound.right||refRect.top>bound.bottom||refRect.right<bound.left){
// Avoid unnecessary DOM access if visibility hasn't changed
if(!0===data.hide)return data;data.hide=!0,data.attributes["x-out-of-boundaries"]=""}else{
// Avoid unnecessary DOM access if visibility hasn't changed
if(!1===data.hide)return data;data.hide=!1,data.attributes["x-out-of-boundaries"]=!1}return data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function inner$1$2(data){var placement=data.placement,basePlacement=placement.split("-")[0],_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,isHoriz=-1!==["left","right"].indexOf(basePlacement),subtractLength=-1===["top","left"].indexOf(basePlacement);return popper[isHoriz?"left":"top"]=reference[basePlacement]-(subtractLength?popper[isHoriz?"width":"height"]:0),data.placement=getOppositePlacement$1$2(placement),data.offsets.popper=getClientRect$1$2(popper),data}
/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */
/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */var modifiers$1$2={
/**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
shift:{
/** @prop {number} order=100 - Index used to define the order of execution */
order:100,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:shift$1$2},
/**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
offset:{
/** @prop {number} order=200 - Index used to define the order of execution */
order:200,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:offset$1$2,
/** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
offset:0},
/**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
preventOverflow:{
/** @prop {number} order=300 - Index used to define the order of execution */
order:300,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:preventOverflow$1$2,
/**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
priority:["left","right","top","bottom"],
/**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
padding:5,
/**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
boundariesElement:"scrollParent"},
/**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
keepTogether:{
/** @prop {number} order=400 - Index used to define the order of execution */
order:400,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:keepTogether$1$2},
/**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
arrow:{
/** @prop {number} order=500 - Index used to define the order of execution */
order:500,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:arrow$1$2,
/** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
element:"[x-arrow]"},
/**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
flip:{
/** @prop {number} order=600 - Index used to define the order of execution */
order:600,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:flip$1$2,
/**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
behavior:"flip",
/**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
padding:5,
/**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
boundariesElement:"viewport",
/**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
flipVariations:!1,
/**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
flipVariationsByContent:!1},
/**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
inner:{
/** @prop {number} order=700 - Index used to define the order of execution */
order:700,
/** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
enabled:!1,
/** @prop {ModifierFn} */
fn:inner$1$2},
/**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
hide:{
/** @prop {number} order=800 - Index used to define the order of execution */
order:800,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:hide$1$2},
/**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
computeStyle:{
/** @prop {number} order=850 - Index used to define the order of execution */
order:850,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:computeStyle$1$2,
/**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
gpuAcceleration:!0,
/**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
x:"bottom",
/**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
y:"right"},
/**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
applyStyle:{
/** @prop {number} order=900 - Index used to define the order of execution */
order:900,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:applyStyle$1$2,
/** @prop {Function} */
onLoad:applyStyleOnLoad$1$2,
/**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
gpuAcceleration:void 0}},Defaults$1$2={
/**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
placement:"bottom",
/**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
positionFixed:!1,
/**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
eventsEnabled:!0,
/**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
removeOnDestroy:!1,
/**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
onCreate:function(){},
/**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
onUpdate:function(){},
/**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
modifiers:modifiers$1$2},Popper$1$2=function(){
/**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
function Popper(reference,popper){var _this=this,options=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};classCallCheck$1$2(this,Popper),this.scheduleUpdate=function(){return requestAnimationFrame(_this.update)},
// make update() debounced, so that it only runs at most once-per-tick
this.update=debounce$2$2(this.update.bind(this)),
// with {} we create a new object with the options inside it
this.options=_extends$2$2({},Popper.Defaults,options),
// init state
this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},
// get reference and popper elements (allow jQuery wrappers)
this.reference=reference&&reference.jquery?reference[0]:reference,this.popper=popper&&popper.jquery?popper[0]:popper,
// Deep merge modifiers options
this.options.modifiers={},Object.keys(_extends$2$2({},Popper.Defaults.modifiers,options.modifiers)).forEach((function(name){_this.options.modifiers[name]=_extends$2$2({},Popper.Defaults.modifiers[name]||{},options.modifiers?options.modifiers[name]:{})})),
// Refactoring modifiers' list (Object => Array)
this.modifiers=Object.keys(this.options.modifiers).map((function(name){return _extends$2$2({name:name},_this.options.modifiers[name])})).sort((function(a,b){return a.order-b.order})),
// modifiers have the ability to execute arbitrary code when Popper.js get inited
// such code is executed in the same order of its modifier
// they could add new properties to their options configuration
// BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
this.modifiers.forEach((function(modifierOptions){modifierOptions.enabled&&isFunction$1$2(modifierOptions.onLoad)&&modifierOptions.onLoad(_this.reference,_this.popper,_this.options,modifierOptions,_this.state)})),
// fire the first update to position the popper in the right place
this.update();var eventsEnabled=this.options.eventsEnabled;eventsEnabled&&
// setup event listeners, they will take care of update the position in specific situations
this.enableEventListeners(),this.state.eventsEnabled=eventsEnabled}
// We can't use class properties because they don't get listed in the
// class prototype and break stuff like Sinon stubs
return createClass$1$2(Popper,[{key:"update",value:function(){return update$1$2.call(this)}},{key:"destroy",value:function(){return destroy$1$2.call(this)}},{key:"enableEventListeners",value:function(){return enableEventListeners$1$2.call(this)}},{key:"disableEventListeners",value:function(){return disableEventListeners$1$2.call(this)}
/**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */
/**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */}]),Popper}();
/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */
/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */
Popper$1$2.Utils=("undefined"!==typeof window?window:global).PopperUtils,Popper$1$2.placements=placements$1$2,Popper$1$2.Defaults=Defaults$1$2;var isIE$2$2,Popper$2$2=Popper$1$2;function getInternetExplorerVersion$2(){var ua=window.navigator.userAgent,msie=ua.indexOf("MSIE ");if(msie>0)
// IE 10 or older => return version number
return parseInt(ua.substring(msie+5,ua.indexOf(".",msie)),10);var trident=ua.indexOf("Trident/");if(trident>0){
// IE 11 => return version number
var rv=ua.indexOf("rv:");return parseInt(ua.substring(rv+3,ua.indexOf(".",rv)),10)}var edge=ua.indexOf("Edge/");return edge>0?parseInt(ua.substring(edge+5,ua.indexOf(".",edge)),10):-1;// other browser
}

function initCompat$2(){initCompat$2.init||(initCompat$2.init=!0,isIE$2$2=-1!==getInternetExplorerVersion$2())}var script$4$2={name:"ResizeObserver",props:{emitOnMount:{type:Boolean,default:!1},ignoreWidth:{type:Boolean,default:!1},ignoreHeight:{type:Boolean,default:!1}},mounted:function(){var _this=this;initCompat$2(),this.$nextTick((function(){_this._w=_this.$el.offsetWidth,_this._h=_this.$el.offsetHeight,_this.emitOnMount&&_this.emitSize()}));var object=document.createElement("object");this._resizeObject=object,object.setAttribute("aria-hidden","true"),object.setAttribute("tabindex",-1),object.onload=this.addResizeHandlers,object.type="text/html",isIE$2$2&&this.$el.appendChild(object),object.data="about:blank",isIE$2$2||this.$el.appendChild(object)},beforeDestroy:function(){this.removeResizeHandlers()},methods:{compareAndNotify:function(){(!this.ignoreWidth&&this._w!==this.$el.offsetWidth||!this.ignoreHeight&&this._h!==this.$el.offsetHeight)&&(this._w=this.$el.offsetWidth,this._h=this.$el.offsetHeight,this.emitSize())},emitSize:function(){this.$emit("notify",{width:this._w,height:this._h})},addResizeHandlers:function(){this._resizeObject.contentDocument.defaultView.addEventListener("resize",this.compareAndNotify),this.compareAndNotify()},removeResizeHandlers:function(){this._resizeObject&&this._resizeObject.onload&&(!isIE$2$2&&this._resizeObject.contentDocument&&this._resizeObject.contentDocument.defaultView.removeEventListener("resize",this.compareAndNotify),this.$el.removeChild(this._resizeObject),this._resizeObject.onload=null,this._resizeObject=null)}}};function normalizeComponent$2$2(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier
/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);// Vue.extend constructor export interop.
var hook,options="function"===typeof script?script.options:script;// render functions
if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,// functional template
isFunctionalTemplate&&(options.functional=!0)),// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),// inject component styles
style&&style.call(this,createInjectorSSR(context)),// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(context){style.call(this,createInjectorShadow(context,this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
var originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
var existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}
/* script */var __vue_script__$4$2=script$4$2,__vue_render__$4$2=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"resize-observer",attrs:{tabindex:"-1"}})},__vue_staticRenderFns__$4$2=[];
/* template */__vue_render__$4$2._withStripped=!0;
/* style */
var __vue_inject_styles__$4$2=void 0,__vue_scope_id__$4$2="data-v-8859cc6c",__vue_module_identifier__$4$2=void 0,__vue_is_functional_template__$4$2=!1,__vue_component__$3$2=normalizeComponent$2$2({render:__vue_render__$4$2,staticRenderFns:__vue_staticRenderFns__$4$2},__vue_inject_styles__$4$2,__vue_script__$4$2,__vue_scope_id__$4$2,__vue_is_functional_template__$4$2,__vue_module_identifier__$4$2,!1,void 0,void 0,void 0);
/* scoped */function install$1$2(Vue){
// eslint-disable-next-line vue/component-definition-name-casing
Vue.component("resize-observer",__vue_component__$3$2),Vue.component("ResizeObserver",__vue_component__$3$2)}var plugin$2$2={
// eslint-disable-next-line no-undef
version:"1.0.1",install:install$1$2},GlobalVue$1$2=null;"undefined"!==typeof window?GlobalVue$1$2=window.Vue:"undefined"!==typeof global&&(GlobalVue$1$2=global.Vue),GlobalVue$1$2&&GlobalVue$1$2.use(plugin$2$2);var SVGAnimatedString$2=function(){};function convertToArray$2(value){return"string"===typeof value&&(value=value.split(" ")),value}
/**
 * Add classes to an element.
 * This method checks to ensure that the classes don't already exist before adding them.
 * It uses el.className rather than classList in order to be IE friendly.
 * @param {object} el - The element to add the classes to.
 * @param {classes} string - List of space separated classes to be added to the element.
 */function addClasses$2(el,classes){var classList,newClasses=convertToArray$2(classes);classList=el.className instanceof SVGAnimatedString$2?convertToArray$2(el.className.baseVal):convertToArray$2(el.className),newClasses.forEach((function(newClass){-1===classList.indexOf(newClass)&&classList.push(newClass)})),el instanceof SVGElement?el.setAttribute("class",classList.join(" ")):el.className=classList.join(" ")}
/**
 * Remove classes from an element.
 * It uses el.className rather than classList in order to be IE friendly.
 * @export
 * @param {any} el The element to remove the classes from.
 * @param {any} classes List of space separated classes to be removed from the element.
 */function removeClasses$2(el,classes){var classList,newClasses=convertToArray$2(classes);classList=el.className instanceof SVGAnimatedString$2?convertToArray$2(el.className.baseVal):convertToArray$2(el.className),newClasses.forEach((function(newClass){var index=classList.indexOf(newClass);-1!==index&&classList.splice(index,1)})),el instanceof SVGElement?el.setAttribute("class",classList.join(" ")):el.className=classList.join(" ")}"undefined"!==typeof window&&(SVGAnimatedString$2=window.SVGAnimatedString);var supportsPassive$2=!1;if("undefined"!==typeof window){supportsPassive$2=!1;try{var opts$2=Object.defineProperty({},"passive",{get:function(){supportsPassive$2=!0}});window.addEventListener("test",null,opts$2)}catch(e){}}function ownKeys$2$2(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread$2$2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$2$2(Object(source),!0).forEach((function(key){_defineProperty$1$2(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$2$2(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}var DEFAULT_OPTIONS$2={container:!1,delay:0,html:!1,placement:"top",title:"",template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",offset:0},openTooltips$2=[],Tooltip$2=function(){
/**
   * Create a new Tooltip.js instance
   * @class Tooltip
   * @param {HTMLElement} reference - The DOM node used as reference of the tooltip (it can be a jQuery element).
   * @param {Object} options
   * @param {String} options.placement=bottom
   *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -end),
   *      left(-start, -end)`
   * @param {HTMLElement|String|false} options.container=false - Append the tooltip to a specific element.
   * @param {Number|Object} options.delay=0
   *      Delay showing and hiding the tooltip (ms) - does not apply to manual trigger type.
   *      If a number is supplied, delay is applied to both hide/show.
   *      Object structure is: `{ show: 500, hide: 100 }`
   * @param {Boolean} options.html=false - Insert HTML into the tooltip. If false, the content will inserted with `innerText`.
   * @param {String|PlacementFunction} options.placement='top' - One of the allowed placements, or a function returning one of them.
   * @param {String} [options.template='<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>']
   *      Base HTML to used when creating the tooltip.
   *      The tooltip's `title` will be injected into the `.tooltip-inner` or `.tooltip__inner`.
   *      `.tooltip-arrow` or `.tooltip__arrow` will become the tooltip's arrow.
   *      The outermost wrapper element should have the `.tooltip` class.
   * @param {String|HTMLElement|TitleFunction} options.title='' - Default title value if `title` attribute isn't present.
   * @param {String} [options.trigger='hover focus']
   *      How tooltip is triggered - click, hover, focus, manual.
   *      You may pass multiple triggers; separate them with a space. `manual` cannot be combined with any other trigger.
   * @param {HTMLElement} options.boundariesElement
   *      The element used as boundaries for the tooltip. For more information refer to Popper.js'
   *      [boundariesElement docs](https://popper.js.org/popper-documentation.html)
   * @param {Number|String} options.offset=0 - Offset of the tooltip relative to its reference. For more information refer to Popper.js'
   *      [offset docs](https://popper.js.org/popper-documentation.html)
   * @param {Object} options.popperOptions={} - Popper options, will be passed directly to popper instance. For more information refer to Popper.js'
   *      [options docs](https://popper.js.org/popper-documentation.html)
   * @param {string} [options.ariaId] Id used for accessibility
   * @return {Object} instance - The generated tooltip instance
   */
function Tooltip(_reference,_options){var _this=this;_classCallCheck$2(this,Tooltip),_defineProperty$1$2(this,"_events",[]),_defineProperty$1$2(this,"_setTooltipNodeEvent",(function(evt,reference,delay,options){var relatedreference=evt.relatedreference||evt.toElement||evt.relatedTarget,callback=function callback(evt2){var relatedreference2=evt2.relatedreference||evt2.toElement||evt2.relatedTarget;// Remove event listener after call
_this._tooltipNode.removeEventListener(evt.type,callback),// If the new reference is not the reference element
reference.contains(relatedreference2)||
// Schedule to hide tooltip
_this._scheduleHide(reference,options.delay,options,evt2)};return!!_this._tooltipNode.contains(relatedreference)&&(
// listen to mouseleave on the tooltip element to be able to hide the tooltip
_this._tooltipNode.addEventListener(evt.type,callback),!0)})),
// apply user options over default ones
_options=_objectSpread$2$2(_objectSpread$2$2({},DEFAULT_OPTIONS$2),_options),_reference.jquery&&(_reference=_reference[0]),this.show=this.show.bind(this),this.hide=this.hide.bind(this),// cache reference and options
this.reference=_reference,this.options=_options,// set initial state
this._isOpen=!1,this._init()}
// Public methods

/**
   * Reveals an element's tooltip. This is considered a "manual" triggering of the tooltip.
   * Tooltips with zero-length titles are never displayed.
   * @method Tooltip#show
   * @memberof Tooltip
   */return _createClass$2(Tooltip,[{key:"show",value:function(){this._show(this.reference,this.options)}
/**
     * Hides an element’s tooltip. This is considered a “manual” triggering of the tooltip.
     * @method Tooltip#hide
     * @memberof Tooltip
     */},{key:"hide",value:function(){this._hide()}
/**
     * Hides and destroys an element’s tooltip.
     * @method Tooltip#dispose
     * @memberof Tooltip
     */},{key:"dispose",value:function(){this._dispose()}
/**
     * Toggles an element’s tooltip. This is considered a “manual” triggering of the tooltip.
     * @method Tooltip#toggle
     * @memberof Tooltip
     */},{key:"toggle",value:function(){return this._isOpen?this.hide():this.show()}},{key:"setClasses",value:function(classes){this._classes=classes}},{key:"setContent",value:function(content){this.options.title=content,this._tooltipNode&&this._setContent(content,this.options)}},{key:"setOptions",value:function(options){var classesUpdated=!1,classes=options&&options.classes||directive$2.options.defaultClass;lodash_isEqual(this._classes,classes)||(this.setClasses(classes),classesUpdated=!0),options=getOptions$2(options);var needPopperUpdate=!1,needRestart=!1;for(var key in this.options.offset===options.offset&&this.options.placement===options.placement||(needPopperUpdate=!0),(this.options.template!==options.template||this.options.trigger!==options.trigger||this.options.container!==options.container||classesUpdated)&&(needRestart=!0),options)this.options[key]=options[key];if(this._tooltipNode)if(needRestart){var isOpen=this._isOpen;this.dispose(),this._init(),isOpen&&this.show()}else needPopperUpdate&&this.popperInstance.update()}
// Private methods

},{key:"_init",value:function(){
// get events list
var events="string"===typeof this.options.trigger?this.options.trigger.split(" "):[];this._isDisposed=!1,this._enableDocumentTouch=-1===events.indexOf("manual"),events=events.filter((function(trigger){return-1!==["click","hover","focus"].indexOf(trigger)})),// set event listeners
this._setEventListeners(this.reference,events,this.options),// title attribute
this.$_originalTitle=this.reference.getAttribute("title"),this.reference.removeAttribute("title"),this.reference.setAttribute("data-original-title",this.$_originalTitle)}
/**
     * Creates a new tooltip node
     * @memberof Tooltip
     * @private
     * @param {HTMLElement} reference
     * @param {String} template
     * @param {String|HTMLElement|TitleFunction} title
     * @param {Boolean} allowHtml
     * @return {HTMLelement} tooltipNode
     */},{key:"_create",value:function(reference,template){var _this2=this,tooltipGenerator=window.document.createElement("div");
// create tooltip element
tooltipGenerator.innerHTML=template.trim();var tooltipNode=tooltipGenerator.childNodes[0];// add unique ID to our tooltip (needed for accessibility reasons)
// return the generated tooltip node
return tooltipNode.id=this.options.ariaId||"tooltip_".concat(Math.random().toString(36).substr(2,10)),// Initially hide the tooltip
// The attribute will be switched in a next frame so
// CSS transitions can play
tooltipNode.setAttribute("aria-hidden","true"),this.options.autoHide&&-1!==this.options.trigger.indexOf("hover")&&(tooltipNode.addEventListener("mouseenter",(function(evt){return _this2._scheduleHide(reference,_this2.options.delay,_this2.options,evt)})),tooltipNode.addEventListener("click",(function(evt){return _this2._scheduleHide(reference,_this2.options.delay,_this2.options,evt)}))),tooltipNode}},{key:"_setContent",value:function(content,options){var _this3=this;this.asyncContent=!1,this._applyContent(content,options).then((function(){_this3.popperInstance&&_this3.popperInstance.update()}))}},{key:"_applyContent",value:function(title,options){var _this4=this;return new Promise((function(resolve,reject){var allowHtml=options.html,rootNode=_this4._tooltipNode;if(rootNode){var titleNode=rootNode.querySelector(_this4.options.innerSelector);if(1===title.nodeType){
// if title is a node, append it only if allowHtml is true
if(allowHtml){while(titleNode.firstChild)titleNode.removeChild(titleNode.firstChild);titleNode.appendChild(title)}}else{if("function"===typeof title){
// if title is a function, call it and set innerText or innerHtml depending by `allowHtml` value
var result=title();return void(result&&"function"===typeof result.then?(_this4.asyncContent=!0,options.loadingClass&&addClasses$2(rootNode,options.loadingClass),options.loadingContent&&_this4._applyContent(options.loadingContent,options),result.then((function(asyncResult){return options.loadingClass&&removeClasses$2(rootNode,options.loadingClass),_this4._applyContent(asyncResult,options)})).then(resolve).catch(reject)):_this4._applyContent(result,options).then(resolve).catch(reject))}
// if it's just a simple text, set innerText or innerHtml depending by `allowHtml` value
allowHtml?titleNode.innerHTML=title:titleNode.innerText=title}resolve()}}))}},{key:"_show",value:function(reference,options){if(options&&"string"===typeof options.container){var container=document.querySelector(options.container);if(!container)return}clearTimeout(this._disposeTimer),options=Object.assign({},options),delete options.offset;var updateClasses=!0;this._tooltipNode&&(addClasses$2(this._tooltipNode,this._classes),updateClasses=!1);var result=this._ensureShown(reference,options);return updateClasses&&this._tooltipNode&&addClasses$2(this._tooltipNode,this._classes),addClasses$2(reference,["v-tooltip-open"]),result}},{key:"_ensureShown",value:function(reference,options){var _this5=this;
// don't show if it's already visible
if(this._isOpen)return this;// if the tooltipNode already exists, just show it
if(this._isOpen=!0,openTooltips$2.push(this),this._tooltipNode)return this._tooltipNode.style.display="",this._tooltipNode.setAttribute("aria-hidden","false"),this.popperInstance.enableEventListeners(),this.popperInstance.update(),this.asyncContent&&this._setContent(options.title,options),this;// get title
var title=reference.getAttribute("title")||options.title;// don't show tooltip if no title is defined
if(!title)return this;// create tooltip node
var tooltipNode=this._create(reference,options.template);this._tooltipNode=tooltipNode,// Add `aria-describedby` to our reference element for accessibility reasons
reference.setAttribute("aria-describedby",tooltipNode.id);// append tooltip to container
var container=this._findContainer(options.container,reference);this._append(tooltipNode,container);var popperOptions=_objectSpread$2$2(_objectSpread$2$2({},options.popperOptions),{},{placement:options.placement});return popperOptions.modifiers=_objectSpread$2$2(_objectSpread$2$2({},popperOptions.modifiers),{},{arrow:{element:this.options.arrowSelector}}),options.boundariesElement&&(popperOptions.modifiers.preventOverflow={boundariesElement:options.boundariesElement}),this.popperInstance=new Popper$2$2(reference,tooltipNode,popperOptions),this._setContent(title,options),// Fix position
requestAnimationFrame((function(){!_this5._isDisposed&&_this5.popperInstance?(_this5.popperInstance.update(),// Show the tooltip
requestAnimationFrame((function(){_this5._isDisposed?_this5.dispose():_this5._isOpen&&tooltipNode.setAttribute("aria-hidden","false")}))):_this5.dispose()})),this}},{key:"_noLongerOpen",value:function(){var index=openTooltips$2.indexOf(this);-1!==index&&openTooltips$2.splice(index,1)}},{key:"_hide",value:function(){var _this6=this;
// don't hide if it's already hidden
if(!this._isOpen)return this;this._isOpen=!1,this._noLongerOpen(),// hide tooltipNode
this._tooltipNode.style.display="none",this._tooltipNode.setAttribute("aria-hidden","true"),this.popperInstance&&this.popperInstance.disableEventListeners(),clearTimeout(this._disposeTimer);var disposeTime=directive$2.options.disposeTimeout;return null!==disposeTime&&(this._disposeTimer=setTimeout((function(){_this6._tooltipNode&&(_this6._tooltipNode.removeEventListener("mouseenter",_this6.hide),_this6._tooltipNode.removeEventListener("click",_this6.hide),// Don't remove popper instance, just the HTML element
_this6._removeTooltipNode())}),disposeTime)),removeClasses$2(this.reference,["v-tooltip-open"]),this}},{key:"_removeTooltipNode",value:function(){if(this._tooltipNode){var parentNode=this._tooltipNode.parentNode;parentNode&&(parentNode.removeChild(this._tooltipNode),this.reference.removeAttribute("aria-describedby")),this._tooltipNode=null}}},{key:"_dispose",value:function(){var _this7=this;return this._isDisposed=!0,this.reference.removeAttribute("data-original-title"),this.$_originalTitle&&this.reference.setAttribute("title",this.$_originalTitle),// remove event listeners first to prevent any unexpected behaviour
this._events.forEach((function(_ref){var func=_ref.func,event=_ref.event;_this7.reference.removeEventListener(event,func)})),this._events=[],this._tooltipNode?(this._hide(),this._tooltipNode.removeEventListener("mouseenter",this.hide),this._tooltipNode.removeEventListener("click",this.hide),// destroy instance
this.popperInstance.destroy(),// destroy tooltipNode if removeOnDestroy is not set, as popperInstance.destroy() already removes the element
this.popperInstance.options.removeOnDestroy||this._removeTooltipNode()):this._noLongerOpen(),this}},{key:"_findContainer",value:function(container,reference){
// if container is a query, get the relative element
return"string"===typeof container?container=window.document.querySelector(container):!1===container&&(
// if container is `false`, set it to reference parent
container=reference.parentNode),container}
/**
     * Append tooltip to container
     * @memberof Tooltip
     * @private
     * @param {HTMLElement} tooltip
     * @param {HTMLElement|String|false} container
     */},{key:"_append",value:function(tooltipNode,container){container.appendChild(tooltipNode)}},{key:"_setEventListeners",value:function(reference,events,options){var _this8=this,directEvents=[],oppositeEvents=[];events.forEach((function(event){switch(event){case"hover":directEvents.push("mouseenter"),oppositeEvents.push("mouseleave"),_this8.options.hideOnTargetClick&&oppositeEvents.push("click");break;case"focus":directEvents.push("focus"),oppositeEvents.push("blur"),_this8.options.hideOnTargetClick&&oppositeEvents.push("click");break;case"click":directEvents.push("click"),oppositeEvents.push("click");break}})),// schedule show tooltip
directEvents.forEach((function(event){var func=function(evt){!0!==_this8._isOpen&&(evt.usedByTooltip=!0,_this8._scheduleShow(reference,options.delay,options,evt))};_this8._events.push({event:event,func:func}),reference.addEventListener(event,func)})),// schedule hide tooltip
oppositeEvents.forEach((function(event){var func=function(evt){!0!==evt.usedByTooltip&&_this8._scheduleHide(reference,options.delay,options,evt)};_this8._events.push({event:event,func:func}),reference.addEventListener(event,func)}))}},{key:"_onDocumentTouch",value:function(event){this._enableDocumentTouch&&this._scheduleHide(this.reference,this.options.delay,this.options,event)}},{key:"_scheduleShow",value:function(reference,delay,options
/*, evt */){var _this9=this,computedDelay=delay&&delay.show||delay||0;
// defaults to 0
clearTimeout(this._scheduleTimer),this._scheduleTimer=window.setTimeout((function(){return _this9._show(reference,options)}),computedDelay)}},{key:"_scheduleHide",value:function(reference,delay,options,evt){var _this10=this,computedDelay=delay&&delay.hide||delay||0;
// defaults to 0
clearTimeout(this._scheduleTimer),this._scheduleTimer=window.setTimeout((function(){if(!1!==_this10._isOpen&&_this10._tooltipNode.ownerDocument.body.contains(_this10._tooltipNode)){// if we are hiding because of a mouseleave, we must check that the new
// reference isn't the tooltip, because in this case we don't want to hide it
if("mouseleave"===evt.type){var isSet=_this10._setTooltipNodeEvent(evt,reference,delay,options);// if we set the new event, don't hide the tooltip yet
// the new event will take care to hide it if necessary
if(isSet)return}_this10._hide(reference,options)}}),computedDelay)}}]),Tooltip}();
/**
 * Placement function, its context is the Tooltip instance.
 * @memberof Tooltip
 * @callback PlacementFunction
 * @param {HTMLElement} tooltip - tooltip DOM node.
 * @param {HTMLElement} reference - reference DOM node.
 * @return {String} placement - One of the allowed placement options.
 */
/**
 * Title function, its context is the Tooltip instance.
 * @memberof Tooltip
 * @callback TitleFunction
 * @return {String} placement - The desired title.
 */
function ownKeys$1$2(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread$1$2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$1$2(Object(source),!0).forEach((function(key){_defineProperty$1$2(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$1$2(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}// Hide tooltips on touch devices
"undefined"!==typeof document&&document.addEventListener("touchstart",(function(event){for(var i=0;i<openTooltips$2.length;i++)openTooltips$2[i]._onDocumentTouch(event)}),!supportsPassive$2||{passive:!0,capture:!0});var state$2={enabled:!0},positions$2=["top","top-start","top-end","right","right-start","right-end","bottom","bottom-start","bottom-end","left","left-start","left-end"],defaultOptions$2={
// Default tooltip placement relative to target element
defaultPlacement:"top",
// Default CSS classes applied to the tooltip element
defaultClass:"vue-tooltip-theme",
// Default CSS classes applied to the target element of the tooltip
defaultTargetClass:"has-tooltip",
// Is the content HTML by default?
defaultHtml:!0,
// Default HTML template of the tooltip element
// It must include `tooltip-arrow` & `tooltip-inner` CSS classes (can be configured, see below)
// Change if the classes conflict with other libraries (for example bootstrap)
defaultTemplate:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
// Selector used to get the arrow element in the tooltip template
defaultArrowSelector:".tooltip-arrow, .tooltip__arrow",
// Selector used to get the inner content element in the tooltip template
defaultInnerSelector:".tooltip-inner, .tooltip__inner",
// Delay (ms)
defaultDelay:0,
// Default events that trigger the tooltip
defaultTrigger:"hover focus",
// Default position offset (px)
defaultOffset:0,
// Default container where the tooltip will be appended
defaultContainer:"body",defaultBoundariesElement:void 0,defaultPopperOptions:{},
// Class added when content is loading
defaultLoadingClass:"tooltip-loading",
// Displayed when tooltip content is loading
defaultLoadingContent:"...",
// Hide on mouseover tooltip
autoHide:!0,
// Close tooltip on click on tooltip target?
defaultHideOnTargetClick:!0,
// Auto destroy tooltip DOM nodes (ms)
disposeTimeout:5e3,
// Options for popover
popover:{defaultPlacement:"bottom",
// Use the `popoverClass` prop for theming
defaultClass:"vue-popover-theme",
// Base class (change if conflicts with other libraries)
defaultBaseClass:"tooltip popover",
// Wrapper class (contains arrow and inner)
defaultWrapperClass:"wrapper",
// Inner content class
defaultInnerClass:"tooltip-inner popover-inner",
// Arrow class
defaultArrowClass:"tooltip-arrow popover-arrow",
// Class added when popover is open
defaultOpenClass:"open",defaultDelay:0,defaultTrigger:"click",defaultOffset:0,defaultContainer:"body",defaultBoundariesElement:void 0,defaultPopperOptions:{},
// Hides if clicked outside of popover
defaultAutoHide:!0,
// Update popper on content resize
defaultHandleResize:!0}};function getOptions$2(options){var result={placement:"undefined"!==typeof options.placement?options.placement:directive$2.options.defaultPlacement,delay:"undefined"!==typeof options.delay?options.delay:directive$2.options.defaultDelay,html:"undefined"!==typeof options.html?options.html:directive$2.options.defaultHtml,template:"undefined"!==typeof options.template?options.template:directive$2.options.defaultTemplate,arrowSelector:"undefined"!==typeof options.arrowSelector?options.arrowSelector:directive$2.options.defaultArrowSelector,innerSelector:"undefined"!==typeof options.innerSelector?options.innerSelector:directive$2.options.defaultInnerSelector,trigger:"undefined"!==typeof options.trigger?options.trigger:directive$2.options.defaultTrigger,offset:"undefined"!==typeof options.offset?options.offset:directive$2.options.defaultOffset,container:"undefined"!==typeof options.container?options.container:directive$2.options.defaultContainer,boundariesElement:"undefined"!==typeof options.boundariesElement?options.boundariesElement:directive$2.options.defaultBoundariesElement,autoHide:"undefined"!==typeof options.autoHide?options.autoHide:directive$2.options.autoHide,hideOnTargetClick:"undefined"!==typeof options.hideOnTargetClick?options.hideOnTargetClick:directive$2.options.defaultHideOnTargetClick,loadingClass:"undefined"!==typeof options.loadingClass?options.loadingClass:directive$2.options.defaultLoadingClass,loadingContent:"undefined"!==typeof options.loadingContent?options.loadingContent:directive$2.options.defaultLoadingContent,popperOptions:_objectSpread$1$2({},"undefined"!==typeof options.popperOptions?options.popperOptions:directive$2.options.defaultPopperOptions)};if(result.offset){var typeofOffset=_typeof$6(result.offset),offset=result.offset;// One value -> switch
("number"===typeofOffset||"string"===typeofOffset&&-1===offset.indexOf(","))&&(offset="0, ".concat(offset)),result.popperOptions.modifiers||(result.popperOptions.modifiers={}),result.popperOptions.modifiers.offset={offset:offset}}return result.trigger&&-1!==result.trigger.indexOf("click")&&(result.hideOnTargetClick=!1),result}function getPlacement$2(value,modifiers){for(var placement=value.placement,i=0;i<positions$2.length;i++){var pos=positions$2[i];modifiers[pos]&&(placement=pos)}return placement}function getContent$2(value){var type=_typeof$6(value);return"string"===type?value:!(!value||"object"!==type)&&value.content}function createTooltip$2(el,value){var modifiers=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},content=getContent$2(value),classes="undefined"!==typeof value.classes?value.classes:directive$2.options.defaultClass,opts=_objectSpread$1$2({title:content},getOptions$2(_objectSpread$1$2(_objectSpread$1$2({},"object"===_typeof$6(value)?value:{}),{},{placement:getPlacement$2(value,modifiers)}))),tooltip=el._tooltip=new Tooltip$2(el,opts);tooltip.setClasses(classes),tooltip._vueEl=el;// Class on target
var targetClasses="undefined"!==typeof value.targetClasses?value.targetClasses:directive$2.options.defaultTargetClass;return el._tooltipTargetClasses=targetClasses,addClasses$2(el,targetClasses),tooltip}function destroyTooltip$2(el){el._tooltip&&(el._tooltip.dispose(),delete el._tooltip,delete el._tooltipOldShow),el._tooltipTargetClasses&&(removeClasses$2(el,el._tooltipTargetClasses),delete el._tooltipTargetClasses)}function bind$3(el,_ref){var value=_ref.value;_ref.oldValue;var tooltip,modifiers=_ref.modifiers,content=getContent$2(value);content&&state$2.enabled?(el._tooltip?(tooltip=el._tooltip,// Content
tooltip.setContent(content),// Options
tooltip.setOptions(_objectSpread$1$2(_objectSpread$1$2({},value),{},{placement:getPlacement$2(value,modifiers)}))):tooltip=createTooltip$2(el,value,modifiers),// Manual show
"undefined"!==typeof value.show&&value.show!==el._tooltipOldShow&&(el._tooltipOldShow=value.show,value.show?tooltip.show():tooltip.hide())):destroyTooltip$2(el)}var directive$2={options:defaultOptions$2,bind:bind$3,update:bind$3,unbind:function(el){destroyTooltip$2(el)}};function addListeners$2(el){el.addEventListener("click",onClick$2),el.addEventListener("touchstart",onTouchStart$2,!!supportsPassive$2&&{passive:!0})}function removeListeners$2(el){el.removeEventListener("click",onClick$2),el.removeEventListener("touchstart",onTouchStart$2),el.removeEventListener("touchend",onTouchEnd$2),el.removeEventListener("touchcancel",onTouchCancel$2)}function onClick$2(event){var el=event.currentTarget;event.closePopover=!el.$_vclosepopover_touch,event.closeAllPopover=el.$_closePopoverModifiers&&!!el.$_closePopoverModifiers.all}function onTouchStart$2(event){if(1===event.changedTouches.length){var el=event.currentTarget;el.$_vclosepopover_touch=!0;var touch=event.changedTouches[0];el.$_vclosepopover_touchPoint=touch,el.addEventListener("touchend",onTouchEnd$2),el.addEventListener("touchcancel",onTouchCancel$2)}}function onTouchEnd$2(event){var el=event.currentTarget;if(el.$_vclosepopover_touch=!1,1===event.changedTouches.length){var touch=event.changedTouches[0],firstTouch=el.$_vclosepopover_touchPoint;event.closePopover=Math.abs(touch.screenY-firstTouch.screenY)<20&&Math.abs(touch.screenX-firstTouch.screenX)<20,event.closeAllPopover=el.$_closePopoverModifiers&&!!el.$_closePopoverModifiers.all}}function onTouchCancel$2(event){var el=event.currentTarget;el.$_vclosepopover_touch=!1}var vclosepopover$2={bind:function(el,_ref){var value=_ref.value,modifiers=_ref.modifiers;el.$_closePopoverModifiers=modifiers,("undefined"===typeof value||value)&&addListeners$2(el)},update:function(el,_ref2){var value=_ref2.value,oldValue=_ref2.oldValue,modifiers=_ref2.modifiers;el.$_closePopoverModifiers=modifiers,value!==oldValue&&("undefined"===typeof value||value?addListeners$2(el):removeListeners$2(el))},unbind:function(el){removeListeners$2(el)}};function ownKeys$3$2(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread$4(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$3$2(Object(source),!0).forEach((function(key){_defineProperty$1$2(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$3$2(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}function getDefault$2(key){var value=directive$2.options.popover[key];return"undefined"===typeof value?directive$2.options[key]:value}var isIOS$1$2=!1;"undefined"!==typeof window&&"undefined"!==typeof navigator&&(isIOS$1$2=/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream);var openPopovers$2=[],Element$1$2=function(){};"undefined"!==typeof window&&(Element$1$2=window.Element);var script$3$2={name:"VPopover",components:{ResizeObserver:__vue_component__$3$2},props:{open:{type:Boolean,default:!1},disabled:{type:Boolean,default:!1},placement:{type:String,default:function(){return getDefault$2("defaultPlacement")}},delay:{type:[String,Number,Object],default:function(){return getDefault$2("defaultDelay")}},offset:{type:[String,Number],default:function(){return getDefault$2("defaultOffset")}},trigger:{type:String,default:function(){return getDefault$2("defaultTrigger")}},container:{type:[String,Object,Element$1$2,Boolean],default:function(){return getDefault$2("defaultContainer")}},boundariesElement:{type:[String,Element$1$2],default:function(){return getDefault$2("defaultBoundariesElement")}},popperOptions:{type:Object,default:function(){return getDefault$2("defaultPopperOptions")}},popoverClass:{type:[String,Array],default:function(){return getDefault$2("defaultClass")}},popoverBaseClass:{type:[String,Array],default:function(){return directive$2.options.popover.defaultBaseClass}},popoverInnerClass:{type:[String,Array],default:function(){return directive$2.options.popover.defaultInnerClass}},popoverWrapperClass:{type:[String,Array],default:function(){return directive$2.options.popover.defaultWrapperClass}},popoverArrowClass:{type:[String,Array],default:function(){return directive$2.options.popover.defaultArrowClass}},autoHide:{type:Boolean,default:function(){return directive$2.options.popover.defaultAutoHide}},handleResize:{type:Boolean,default:function(){return directive$2.options.popover.defaultHandleResize}},openGroup:{type:String,default:null},openClass:{type:[String,Array],default:function(){return directive$2.options.popover.defaultOpenClass}},ariaId:{default:null}},data:function(){return{isOpen:!1,id:Math.random().toString(36).substr(2,10)}},computed:{cssClass:function(){return _defineProperty$1$2({},this.openClass,this.isOpen)},popoverId:function(){return"popover_".concat(null!=this.ariaId?this.ariaId:this.id)}},watch:{open:function(val){val?this.show():this.hide()},disabled:function(val,oldVal){val!==oldVal&&(val?this.hide():this.open&&this.show())},container:function(val){if(this.isOpen&&this.popperInstance){var popoverNode=this.$refs.popover,reference=this.$refs.trigger,container=this.$_findContainer(this.container,reference);if(!container)return;container.appendChild(popoverNode),this.popperInstance.scheduleUpdate()}},trigger:function(val){this.$_removeEventListeners(),this.$_addEventListeners()},placement:function(val){var _this=this;this.$_updatePopper((function(){_this.popperInstance.options.placement=val}))},offset:"$_restartPopper",boundariesElement:"$_restartPopper",popperOptions:{handler:"$_restartPopper",deep:!0}},created:function(){this.$_isDisposed=!1,this.$_mounted=!1,this.$_events=[],this.$_preventOpen=!1},mounted:function(){var popoverNode=this.$refs.popover;popoverNode.parentNode&&popoverNode.parentNode.removeChild(popoverNode),this.$_init(),this.open&&this.show()},deactivated:function(){this.hide()},beforeDestroy:function(){this.dispose()},methods:{show:function(){var _this2=this,_ref2=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},event=_ref2.event;_ref2.skipDelay;var _ref2$force=_ref2.force,force=void 0!==_ref2$force&&_ref2$force;!force&&this.disabled||(this.$_scheduleShow(event),this.$emit("show")),this.$emit("update:open",!0),this.$_beingShowed=!0,requestAnimationFrame((function(){_this2.$_beingShowed=!1}))},hide:function(){var _ref3=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},event=_ref3.event;_ref3.skipDelay,this.$_scheduleHide(event),this.$emit("hide"),this.$emit("update:open",!1)},dispose:function(){if(this.$_isDisposed=!0,this.$_removeEventListeners(),this.hide({skipDelay:!0}),this.popperInstance&&(this.popperInstance.destroy(),!this.popperInstance.options.removeOnDestroy)){var popoverNode=this.$refs.popover;popoverNode.parentNode&&popoverNode.parentNode.removeChild(popoverNode)}this.$_mounted=!1,this.popperInstance=null,this.isOpen=!1,this.$emit("dispose")},$_init:function(){-1===this.trigger.indexOf("manual")&&this.$_addEventListeners()},$_show:function(){var _this3=this,reference=this.$refs.trigger,popoverNode=this.$refs.popover;// Already open
if(clearTimeout(this.$_disposeTimer),!this.isOpen){if(// Popper is already initialized
this.popperInstance&&(this.isOpen=!0,this.popperInstance.enableEventListeners(),this.popperInstance.scheduleUpdate()),!this.$_mounted){var container=this.$_findContainer(this.container,reference);if(!container)return;container.appendChild(popoverNode),this.$_mounted=!0,this.isOpen=!1,this.popperInstance&&requestAnimationFrame((function(){_this3.hidden||(_this3.isOpen=!0)}))}if(!this.popperInstance){var popperOptions=_objectSpread$4(_objectSpread$4({},this.popperOptions),{},{placement:this.placement});if(popperOptions.modifiers=_objectSpread$4(_objectSpread$4({},popperOptions.modifiers),{},{arrow:_objectSpread$4(_objectSpread$4({},popperOptions.modifiers&&popperOptions.modifiers.arrow),{},{element:this.$refs.arrow})}),this.offset){var offset=this.$_getOffset();popperOptions.modifiers.offset=_objectSpread$4(_objectSpread$4({},popperOptions.modifiers&&popperOptions.modifiers.offset),{},{offset:offset})}this.boundariesElement&&(popperOptions.modifiers.preventOverflow=_objectSpread$4(_objectSpread$4({},popperOptions.modifiers&&popperOptions.modifiers.preventOverflow),{},{boundariesElement:this.boundariesElement})),this.popperInstance=new Popper$2$2(reference,popoverNode,popperOptions),// Fix position
requestAnimationFrame((function(){if(_this3.hidden)return _this3.hidden=!1,void _this3.$_hide();!_this3.$_isDisposed&&_this3.popperInstance?(_this3.popperInstance.scheduleUpdate(),// Show the tooltip
requestAnimationFrame((function(){if(_this3.hidden)return _this3.hidden=!1,void _this3.$_hide();_this3.$_isDisposed?_this3.dispose():_this3.isOpen=!0}))):_this3.dispose()}))}var openGroup=this.openGroup;if(openGroup)for(var popover,i=0;i<openPopovers$2.length;i++)popover=openPopovers$2[i],popover.openGroup!==openGroup&&(popover.hide(),popover.$emit("close-group"));openPopovers$2.push(this),this.$emit("apply-show")}},$_hide:function(){var _this4=this;
// Already hidden
if(this.isOpen){var index=openPopovers$2.indexOf(this);-1!==index&&openPopovers$2.splice(index,1),this.isOpen=!1,this.popperInstance&&this.popperInstance.disableEventListeners(),clearTimeout(this.$_disposeTimer);var disposeTime=directive$2.options.popover.disposeTimeout||directive$2.options.disposeTimeout;null!==disposeTime&&(this.$_disposeTimer=setTimeout((function(){var popoverNode=_this4.$refs.popover;popoverNode&&(
// Don't remove popper instance, just the HTML element
popoverNode.parentNode&&popoverNode.parentNode.removeChild(popoverNode),_this4.$_mounted=!1)}),disposeTime)),this.$emit("apply-hide")}},$_findContainer:function(container,reference){
// if container is a query, get the relative element
return"string"===typeof container?container=window.document.querySelector(container):!1===container&&(
// if container is `false`, set it to reference parent
container=reference.parentNode),container},$_getOffset:function(){var typeofOffset=_typeof$6(this.offset),offset=this.offset;// One value -> switch
return("number"===typeofOffset||"string"===typeofOffset&&-1===offset.indexOf(","))&&(offset="0, ".concat(offset)),offset},$_addEventListeners:function(){var _this5=this,reference=this.$refs.trigger,directEvents=[],oppositeEvents=[],events="string"===typeof this.trigger?this.trigger.split(" ").filter((function(trigger){return-1!==["click","hover","focus"].indexOf(trigger)})):[];events.forEach((function(event){switch(event){case"hover":directEvents.push("mouseenter"),oppositeEvents.push("mouseleave");break;case"focus":directEvents.push("focus"),oppositeEvents.push("blur");break;case"click":directEvents.push("click"),oppositeEvents.push("click");break}})),// schedule show tooltip
directEvents.forEach((function(event){var func=function(event){_this5.isOpen||(event.usedByTooltip=!0,!_this5.$_preventOpen&&_this5.show({event:event}),_this5.hidden=!1)};_this5.$_events.push({event:event,func:func}),reference.addEventListener(event,func)})),// schedule hide tooltip
oppositeEvents.forEach((function(event){var func=function(event){event.usedByTooltip||(_this5.hide({event:event}),_this5.hidden=!0)};_this5.$_events.push({event:event,func:func}),reference.addEventListener(event,func)}))},$_scheduleShow:function(){var skipDelay=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(clearTimeout(this.$_scheduleTimer),skipDelay)this.$_show();else{
// defaults to 0
var computedDelay=parseInt(this.delay&&this.delay.show||this.delay||0);this.$_scheduleTimer=setTimeout(this.$_show.bind(this),computedDelay)}},$_scheduleHide:function(){var _this6=this,event=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,skipDelay=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(clearTimeout(this.$_scheduleTimer),skipDelay)this.$_hide();else{
// defaults to 0
var computedDelay=parseInt(this.delay&&this.delay.hide||this.delay||0);this.$_scheduleTimer=setTimeout((function(){if(_this6.isOpen){// if we are hiding because of a mouseleave, we must check that the new
// reference isn't the tooltip, because in this case we don't want to hide it
if(event&&"mouseleave"===event.type){var isSet=_this6.$_setTooltipNodeEvent(event);// if we set the new event, don't hide the tooltip yet
// the new event will take care to hide it if necessary
if(isSet)return}_this6.$_hide()}}),computedDelay)}},$_setTooltipNodeEvent:function(event){var _this7=this,reference=this.$refs.trigger,popoverNode=this.$refs.popover,relatedreference=event.relatedreference||event.toElement||event.relatedTarget,callback=function callback(event2){var relatedreference2=event2.relatedreference||event2.toElement||event2.relatedTarget;// Remove event listener after call
popoverNode.removeEventListener(event.type,callback),// If the new reference is not the reference element
reference.contains(relatedreference2)||
// Schedule to hide tooltip
_this7.hide({event:event2})};return!!popoverNode.contains(relatedreference)&&(
// listen to mouseleave on the tooltip element to be able to hide the tooltip
popoverNode.addEventListener(event.type,callback),!0)},$_removeEventListeners:function(){var reference=this.$refs.trigger;this.$_events.forEach((function(_ref4){var func=_ref4.func,event=_ref4.event;reference.removeEventListener(event,func)})),this.$_events=[]},$_updatePopper:function(cb){this.popperInstance&&(cb(),this.isOpen&&this.popperInstance.scheduleUpdate())},$_restartPopper:function(){if(this.popperInstance){var isOpen=this.isOpen;this.dispose(),this.$_isDisposed=!1,this.$_init(),isOpen&&this.show({skipDelay:!0,force:!0})}},$_handleGlobalClose:function(event){var _this8=this,touch=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.$_beingShowed||(this.hide({event:event}),event.closePopover?this.$emit("close-directive"):this.$emit("auto-hide"),touch&&(this.$_preventOpen=!0,setTimeout((function(){_this8.$_preventOpen=!1}),300)))},$_handleResize:function(){this.isOpen&&this.popperInstance&&(this.popperInstance.scheduleUpdate(),this.$emit("resize"))}}};function handleGlobalClick$2(event){handleGlobalClose$2(event)}function handleGlobalTouchend$2(event){handleGlobalClose$2(event,!0)}function handleGlobalClose$2(event){
// Delay so that close directive has time to set values
for(var touch=arguments.length>1&&void 0!==arguments[1]&&arguments[1],_loop=function(i){var popover=openPopovers$2[i];if(popover.$refs.popover){var contains=popover.$refs.popover.contains(event.target);requestAnimationFrame((function(){(event.closeAllPopover||event.closePopover&&contains||popover.autoHide&&!contains)&&popover.$_handleGlobalClose(event,touch)}))}},i=0;i<openPopovers$2.length;i++)_loop(i)}function normalizeComponent$1$2(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);
// Vue.extend constructor export interop.
const options="function"===typeof script?script.options:script;
// render functions
let hook;if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,
// functional template
isFunctionalTemplate&&(options.functional=!0)),
// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),
// inject component styles
style&&style.call(this,createInjectorSSR(context)),
// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},
// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(context){style.call(this,createInjectorShadow(context,this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
const originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
const existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}
/* script */"undefined"!==typeof document&&"undefined"!==typeof window&&(isIOS$1$2?document.addEventListener("touchend",handleGlobalTouchend$2,!supportsPassive$2||{passive:!0,capture:!0}):window.addEventListener("click",handleGlobalClick$2,!0));var __vue_script__$3$2=script$3$2,__vue_render__$3$2=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"v-popover",class:_vm.cssClass},[_c("div",{ref:"trigger",staticClass:"trigger",staticStyle:{display:"inline-block"},attrs:{"aria-describedby":_vm.isOpen?_vm.popoverId:void 0,tabindex:-1!==_vm.trigger.indexOf("focus")?0:void 0}},[_vm._t("default")],2),_vm._v(" "),_c("div",{ref:"popover",class:[_vm.popoverBaseClass,_vm.popoverClass,_vm.cssClass],style:{visibility:_vm.isOpen?"visible":"hidden"},attrs:{id:_vm.popoverId,"aria-hidden":_vm.isOpen?"false":"true",tabindex:_vm.autoHide?0:void 0},on:{keyup:function($event){if(!$event.type.indexOf("key")&&_vm._k($event.keyCode,"esc",27,$event.key,["Esc","Escape"]))return null;_vm.autoHide&&_vm.hide()}}},[_c("div",{class:_vm.popoverWrapperClass},[_c("div",{ref:"inner",class:_vm.popoverInnerClass,staticStyle:{position:"relative"}},[_c("div",[_vm._t("popover",null,{isOpen:_vm.isOpen})],2),_vm._v(" "),_vm.handleResize?_c("ResizeObserver",{on:{notify:_vm.$_handleResize}}):_vm._e()],1),_vm._v(" "),_c("div",{ref:"arrow",class:_vm.popoverArrowClass})])])])},__vue_staticRenderFns__$3$2=[];
/* template */__vue_render__$3$2._withStripped=!0;
/* style */
var __vue_inject_styles__$3$2=void 0,__vue_scope_id__$3$2=void 0,__vue_module_identifier__$3$2=void 0,__vue_is_functional_template__$3$2=!1,__vue_component__$2$3=normalizeComponent$1$2({render:__vue_render__$3$2,staticRenderFns:__vue_staticRenderFns__$3$2},__vue_inject_styles__$3$2,__vue_script__$3$2,__vue_scope_id__$3$2,__vue_is_functional_template__$3$2,__vue_module_identifier__$3$2,!1,void 0,void 0,void 0);
/* scoped */function styleInject$4(css,ref){void 0===ref&&(ref={});var insertAt=ref.insertAt;if(css&&"undefined"!==typeof document){var head=document.head||document.getElementsByTagName("head")[0],style=document.createElement("style");style.type="text/css","top"===insertAt&&head.firstChild?head.insertBefore(style,head.firstChild):head.appendChild(style),style.styleSheet?style.styleSheet.cssText=css:style.appendChild(document.createTextNode(css))}}var css_248z$6=".resize-observer[data-v-8859cc6c]{position:absolute;top:0;left:0;z-index:-1;width:100%;height:100%;border:none;background-color:transparent;pointer-events:none;display:block;overflow:hidden;opacity:0}.resize-observer[data-v-8859cc6c] object{display:block;position:absolute;top:0;left:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1}";function install$3(Vue){var options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!install$3.installed){install$3.installed=!0;var finalOptions={};merge(finalOptions,defaultOptions$2,options),plugin$1$2.options=finalOptions,directive$2.options=finalOptions,Vue.directive("tooltip",directive$2),Vue.directive("close-popover",vclosepopover$2),Vue.component("VPopover",__vue_component__$2$3)}}styleInject$4(css_248z$6);var plugin$1$2={install:install$3,get enabled(){return state$2.enabled},set enabled(value){state$2.enabled=value}},GlobalVue$3=null;// Auto-install
"undefined"!==typeof window?GlobalVue$3=window.Vue:"undefined"!==typeof global&&(GlobalVue$3=global.Vue),GlobalVue$3&&GlobalVue$3.use(plugin$1$2)
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */;var isBrowser$4="undefined"!==typeof window&&"undefined"!==typeof document&&"undefined"!==typeof navigator,timeoutDuration$3=function(){for(var longerTimeoutBrowsers=["Edge","Trident","Firefox"],i=0;i<longerTimeoutBrowsers.length;i+=1)if(isBrowser$4&&navigator.userAgent.indexOf(longerTimeoutBrowsers[i])>=0)return 1;return 0}();function microtaskDebounce$3(fn){var called=!1;return function(){called||(called=!0,window.Promise.resolve().then((function(){called=!1,fn()})))}}function taskDebounce$3(fn){var scheduled=!1;return function(){scheduled||(scheduled=!0,setTimeout((function(){scheduled=!1,fn()}),timeoutDuration$3))}}var supportsMicroTasks$3=isBrowser$4&&window.Promise,debounce$4=supportsMicroTasks$3?microtaskDebounce$3:taskDebounce$3;
/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction$5(functionToCheck){var getType={};return functionToCheck&&"[object Function]"===getType.toString.call(functionToCheck)}
/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */function getStyleComputedProperty$3(element,property){if(1!==element.nodeType)return[];
// NOTE: 1 DOM access here
var window=element.ownerDocument.defaultView,css=window.getComputedStyle(element,null);return property?css[property]:css}
/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */function getParentNode$3(element){return"HTML"===element.nodeName?element:element.parentNode||element.host}
/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */function getScrollParent$3(element){
// Return body, `getScroll` will take care to get the correct `scrollTop` from it
if(!element)return document.body;switch(element.nodeName){case"HTML":case"BODY":return element.ownerDocument.body;case"#document":return element.body}
// Firefox want us to check `-x` and `-y` variations as well
var _getStyleComputedProp=getStyleComputedProperty$3(element),overflow=_getStyleComputedProp.overflow,overflowX=_getStyleComputedProp.overflowX,overflowY=_getStyleComputedProp.overflowY;return/(auto|scroll|overlay)/.test(overflow+overflowY+overflowX)?element:getScrollParent$3(getParentNode$3(element))}
/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */function getReferenceNode$3(reference){return reference&&reference.referenceNode?reference.referenceNode:reference}var isIE11$3=isBrowser$4&&!(!window.MSInputMethodContext||!document.documentMode),isIE10$3=isBrowser$4&&/MSIE 10/.test(navigator.userAgent);
/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE$5(version){return 11===version?isIE11$3:10===version?isIE10$3:isIE11$3||isIE10$3}
/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */function getOffsetParent$3(element){if(!element)return document.documentElement;var noOffsetParent=isIE$5(10)?document.body:null,offsetParent=element.offsetParent||null;
// NOTE: 1 DOM access here
// Skip hidden elements which don't have an offsetParent
while(offsetParent===noOffsetParent&&element.nextElementSibling)offsetParent=(element=element.nextElementSibling).offsetParent;var nodeName=offsetParent&&offsetParent.nodeName;return nodeName&&"BODY"!==nodeName&&"HTML"!==nodeName?
// .offsetParent will return the closest TH, TD or TABLE in case
// no offsetParent is present, I hate this job...
-1!==["TH","TD","TABLE"].indexOf(offsetParent.nodeName)&&"static"===getStyleComputedProperty$3(offsetParent,"position")?getOffsetParent$3(offsetParent):offsetParent:element?element.ownerDocument.documentElement:document.documentElement}function isOffsetContainer$3(element){var nodeName=element.nodeName;return"BODY"!==nodeName&&("HTML"===nodeName||getOffsetParent$3(element.firstElementChild)===element)}
/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */function getRoot$3(node){return null!==node.parentNode?getRoot$3(node.parentNode):node}
/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */function findCommonOffsetParent$3(element1,element2){
// This check is needed to avoid errors in case one of the elements isn't defined for any reason
if(!element1||!element1.nodeType||!element2||!element2.nodeType)return document.documentElement;
// Here we make sure to give as "start" the element that comes first in the DOM
var order=element1.compareDocumentPosition(element2)&Node.DOCUMENT_POSITION_FOLLOWING,start=order?element1:element2,end=order?element2:element1,range=document.createRange();range.setStart(start,0),range.setEnd(end,0);var commonAncestorContainer=range.commonAncestorContainer;
// Both nodes are inside #document
if(element1!==commonAncestorContainer&&element2!==commonAncestorContainer||start.contains(end))return isOffsetContainer$3(commonAncestorContainer)?commonAncestorContainer:getOffsetParent$3(commonAncestorContainer);
// one of the nodes is inside shadowDOM, find which one
var element1root=getRoot$3(element1);return element1root.host?findCommonOffsetParent$3(element1root.host,element2):findCommonOffsetParent$3(element1,getRoot$3(element2).host)}
/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */function getScroll$3(element){var side=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"top",upperSide="top"===side?"scrollTop":"scrollLeft",nodeName=element.nodeName;if("BODY"===nodeName||"HTML"===nodeName){var html=element.ownerDocument.documentElement,scrollingElement=element.ownerDocument.scrollingElement||html;return scrollingElement[upperSide]}return element[upperSide]}
/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */function includeScroll$3(rect,element){var subtract=arguments.length>2&&void 0!==arguments[2]&&arguments[2],scrollTop=getScroll$3(element,"top"),scrollLeft=getScroll$3(element,"left"),modifier=subtract?-1:1;return rect.top+=scrollTop*modifier,rect.bottom+=scrollTop*modifier,rect.left+=scrollLeft*modifier,rect.right+=scrollLeft*modifier,rect}
/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */function getBordersSize$3(styles,axis){var sideA="x"===axis?"Left":"Top",sideB="Left"===sideA?"Right":"Bottom";return parseFloat(styles["border"+sideA+"Width"])+parseFloat(styles["border"+sideB+"Width"])}function getSize$3(axis,body,html,computedStyle){return Math.max(body["offset"+axis],body["scroll"+axis],html["client"+axis],html["offset"+axis],html["scroll"+axis],isIE$5(10)?parseInt(html["offset"+axis])+parseInt(computedStyle["margin"+("Height"===axis?"Top":"Left")])+parseInt(computedStyle["margin"+("Height"===axis?"Bottom":"Right")]):0)}function getWindowSizes$3(document){var body=document.body,html=document.documentElement,computedStyle=isIE$5(10)&&getComputedStyle(html);return{height:getSize$3("Height",body,html,computedStyle),width:getSize$3("Width",body,html,computedStyle)}}var classCallCheck$3=function(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")},createClass$3=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),defineProperty$3=function(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj},_extends$6=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target};
/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect$3(offsets){return _extends$6({},offsets,{right:offsets.left+offsets.width,bottom:offsets.top+offsets.height})}
/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */function getBoundingClientRect$3(element){var rect={};
// IE10 10 FIX: Please, don't ask, the element isn't
// considered in DOM in some circumstances...
// This isn't reproducible in IE10 compatibility mode of IE11
try{if(isIE$5(10)){rect=element.getBoundingClientRect();var scrollTop=getScroll$3(element,"top"),scrollLeft=getScroll$3(element,"left");rect.top+=scrollTop,rect.left+=scrollLeft,rect.bottom+=scrollTop,rect.right+=scrollLeft}else rect=element.getBoundingClientRect()}catch(e){}var result={left:rect.left,top:rect.top,width:rect.right-rect.left,height:rect.bottom-rect.top},sizes="HTML"===element.nodeName?getWindowSizes$3(element.ownerDocument):{},width=sizes.width||element.clientWidth||result.width,height=sizes.height||element.clientHeight||result.height,horizScrollbar=element.offsetWidth-width,vertScrollbar=element.offsetHeight-height;
// subtract scrollbar size from sizes
// if an hypothetical scrollbar is detected, we must be sure it's not a `border`
// we make this check conditional for performance reasons
if(horizScrollbar||vertScrollbar){var styles=getStyleComputedProperty$3(element);horizScrollbar-=getBordersSize$3(styles,"x"),vertScrollbar-=getBordersSize$3(styles,"y"),result.width-=horizScrollbar,result.height-=vertScrollbar}return getClientRect$3(result)}function getOffsetRectRelativeToArbitraryNode$3(children,parent){var fixedPosition=arguments.length>2&&void 0!==arguments[2]&&arguments[2],isIE10=isIE$5(10),isHTML="HTML"===parent.nodeName,childrenRect=getBoundingClientRect$3(children),parentRect=getBoundingClientRect$3(parent),scrollParent=getScrollParent$3(children),styles=getStyleComputedProperty$3(parent),borderTopWidth=parseFloat(styles.borderTopWidth),borderLeftWidth=parseFloat(styles.borderLeftWidth);
// In cases where the parent is fixed, we must ignore negative scroll in offset calc
fixedPosition&&isHTML&&(parentRect.top=Math.max(parentRect.top,0),parentRect.left=Math.max(parentRect.left,0));var offsets=getClientRect$3({top:childrenRect.top-parentRect.top-borderTopWidth,left:childrenRect.left-parentRect.left-borderLeftWidth,width:childrenRect.width,height:childrenRect.height});
// Subtract margins of documentElement in case it's being used as parent
// we do this only on HTML because it's the only element that behaves
// differently when margins are applied to it. The margins are included in
// the box of the documentElement, in the other cases not.
if(offsets.marginTop=0,offsets.marginLeft=0,!isIE10&&isHTML){var marginTop=parseFloat(styles.marginTop),marginLeft=parseFloat(styles.marginLeft);offsets.top-=borderTopWidth-marginTop,offsets.bottom-=borderTopWidth-marginTop,offsets.left-=borderLeftWidth-marginLeft,offsets.right-=borderLeftWidth-marginLeft,
// Attach marginTop and marginLeft because in some circumstances we may need them
offsets.marginTop=marginTop,offsets.marginLeft=marginLeft}return(isIE10&&!fixedPosition?parent.contains(scrollParent):parent===scrollParent&&"BODY"!==scrollParent.nodeName)&&(offsets=includeScroll$3(offsets,parent)),offsets}function getViewportOffsetRectRelativeToArtbitraryNode$3(element){var excludeScroll=arguments.length>1&&void 0!==arguments[1]&&arguments[1],html=element.ownerDocument.documentElement,relativeOffset=getOffsetRectRelativeToArbitraryNode$3(element,html),width=Math.max(html.clientWidth,window.innerWidth||0),height=Math.max(html.clientHeight,window.innerHeight||0),scrollTop=excludeScroll?0:getScroll$3(html),scrollLeft=excludeScroll?0:getScroll$3(html,"left"),offset={top:scrollTop-relativeOffset.top+relativeOffset.marginTop,left:scrollLeft-relativeOffset.left+relativeOffset.marginLeft,width:width,height:height};return getClientRect$3(offset)}
/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */function isFixed$3(element){var nodeName=element.nodeName;if("BODY"===nodeName||"HTML"===nodeName)return!1;if("fixed"===getStyleComputedProperty$3(element,"position"))return!0;var parentNode=getParentNode$3(element);return!!parentNode&&isFixed$3(parentNode)}
/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */function getFixedPositionOffsetParent$3(element){
// This check is needed to avoid errors in case one of the elements isn't defined for any reason
if(!element||!element.parentElement||isIE$5())return document.documentElement;var el=element.parentElement;while(el&&"none"===getStyleComputedProperty$3(el,"transform"))el=el.parentElement;return el||document.documentElement}
/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */function getBoundaries$3(popper,reference,padding,boundariesElement){var fixedPosition=arguments.length>4&&void 0!==arguments[4]&&arguments[4],boundaries={top:0,left:0},offsetParent=fixedPosition?getFixedPositionOffsetParent$3(popper):findCommonOffsetParent$3(popper,getReferenceNode$3(reference));
// NOTE: 1 DOM access here
// Handle viewport case
if("viewport"===boundariesElement)boundaries=getViewportOffsetRectRelativeToArtbitraryNode$3(offsetParent,fixedPosition);else{
// Handle other cases based on DOM element used as boundaries
var boundariesNode=void 0;"scrollParent"===boundariesElement?(boundariesNode=getScrollParent$3(getParentNode$3(reference)),"BODY"===boundariesNode.nodeName&&(boundariesNode=popper.ownerDocument.documentElement)):boundariesNode="window"===boundariesElement?popper.ownerDocument.documentElement:boundariesElement;var offsets=getOffsetRectRelativeToArbitraryNode$3(boundariesNode,offsetParent,fixedPosition);
// In case of HTML, we need a different computation
if("HTML"!==boundariesNode.nodeName||isFixed$3(offsetParent))
// for all the other DOM elements, this one is good
boundaries=offsets;else{var _getWindowSizes=getWindowSizes$3(popper.ownerDocument),height=_getWindowSizes.height,width=_getWindowSizes.width;boundaries.top+=offsets.top-offsets.marginTop,boundaries.bottom=height+offsets.top,boundaries.left+=offsets.left-offsets.marginLeft,boundaries.right=width+offsets.left}}
// Add paddings
padding=padding||0;var isPaddingNumber="number"===typeof padding;return boundaries.left+=isPaddingNumber?padding:padding.left||0,boundaries.top+=isPaddingNumber?padding:padding.top||0,boundaries.right-=isPaddingNumber?padding:padding.right||0,boundaries.bottom-=isPaddingNumber?padding:padding.bottom||0,boundaries}function getArea$3(_ref){var width=_ref.width,height=_ref.height;return width*height}
/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function computeAutoPlacement$3(placement,refRect,popper,reference,boundariesElement){var padding=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(-1===placement.indexOf("auto"))return placement;var boundaries=getBoundaries$3(popper,reference,padding,boundariesElement),rects={top:{width:boundaries.width,height:refRect.top-boundaries.top},right:{width:boundaries.right-refRect.right,height:boundaries.height},bottom:{width:boundaries.width,height:boundaries.bottom-refRect.bottom},left:{width:refRect.left-boundaries.left,height:boundaries.height}},sortedAreas=Object.keys(rects).map((function(key){return _extends$6({key:key},rects[key],{area:getArea$3(rects[key])})})).sort((function(a,b){return b.area-a.area})),filteredAreas=sortedAreas.filter((function(_ref2){var width=_ref2.width,height=_ref2.height;return width>=popper.clientWidth&&height>=popper.clientHeight})),computedPlacement=filteredAreas.length>0?filteredAreas[0].key:sortedAreas[0].key,variation=placement.split("-")[1];return computedPlacement+(variation?"-"+variation:"")}
/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */function getReferenceOffsets$3(state,popper,reference){var fixedPosition=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,commonOffsetParent=fixedPosition?getFixedPositionOffsetParent$3(popper):findCommonOffsetParent$3(popper,getReferenceNode$3(reference));return getOffsetRectRelativeToArbitraryNode$3(reference,commonOffsetParent,fixedPosition)}
/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */function getOuterSizes$3(element){var window=element.ownerDocument.defaultView,styles=window.getComputedStyle(element),x=parseFloat(styles.marginTop||0)+parseFloat(styles.marginBottom||0),y=parseFloat(styles.marginLeft||0)+parseFloat(styles.marginRight||0),result={width:element.offsetWidth+y,height:element.offsetHeight+x};return result}
/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */function getOppositePlacement$3(placement){var hash={left:"right",right:"left",bottom:"top",top:"bottom"};return placement.replace(/left|right|bottom|top/g,(function(matched){return hash[matched]}))}
/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */function getPopperOffsets$3(popper,referenceOffsets,placement){placement=placement.split("-")[0];
// Get popper node sizes
var popperRect=getOuterSizes$3(popper),popperOffsets={width:popperRect.width,height:popperRect.height},isHoriz=-1!==["right","left"].indexOf(placement),mainSide=isHoriz?"top":"left",secondarySide=isHoriz?"left":"top",measurement=isHoriz?"height":"width",secondaryMeasurement=isHoriz?"width":"height";
// Add position, width and height to our offsets object
return popperOffsets[mainSide]=referenceOffsets[mainSide]+referenceOffsets[measurement]/2-popperRect[measurement]/2,popperOffsets[secondarySide]=placement===secondarySide?referenceOffsets[secondarySide]-popperRect[secondaryMeasurement]:referenceOffsets[getOppositePlacement$3(secondarySide)],popperOffsets}
/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */function find$4(arr,check){
// use native find if supported
return Array.prototype.find?arr.find(check):arr.filter(check)[0];
// use `filter` to obtain the same behavior of `find`
}
/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */function findIndex$3(arr,prop,value){
// use native findIndex if supported
if(Array.prototype.findIndex)return arr.findIndex((function(cur){return cur[prop]===value}));
// use `find` + `indexOf` if `findIndex` isn't supported
var match=find$4(arr,(function(obj){return obj[prop]===value}));return arr.indexOf(match)}
/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */function runModifiers$3(modifiers,data,ends){var modifiersToRun=void 0===ends?modifiers:modifiers.slice(0,findIndex$3(modifiers,"name",ends));return modifiersToRun.forEach((function(modifier){modifier["function"];var fn=modifier["function"]||modifier.fn;// eslint-disable-line dot-notation
modifier.enabled&&isFunction$5(fn)&&(
// Add properties to offsets to make them a complete clientRect object
// we do this before each modifier to make sure the previous one doesn't
// mess with these values
data.offsets.popper=getClientRect$3(data.offsets.popper),data.offsets.reference=getClientRect$3(data.offsets.reference),data=fn(data,modifier))})),data}
/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */function update$3(){
// if popper is destroyed, don't perform any further update
if(!this.state.isDestroyed){var data={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};
// compute reference element offsets
data.offsets.reference=getReferenceOffsets$3(this.state,this.popper,this.reference,this.options.positionFixed),
// compute auto placement, store placement inside the data object,
// modifiers will be able to edit `placement` if needed
// and refer to originalPlacement to know the original value
data.placement=computeAutoPlacement$3(this.options.placement,data.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),
// store the computed placement inside `originalPlacement`
data.originalPlacement=data.placement,data.positionFixed=this.options.positionFixed,
// compute the popper offsets
data.offsets.popper=getPopperOffsets$3(this.popper,data.offsets.reference,data.placement),data.offsets.popper.position=this.options.positionFixed?"fixed":"absolute",
// run the modifiers
data=runModifiers$3(this.modifiers,data),
// the first `update` will call `onCreate` callback
// the other ones will call `onUpdate` callback
this.state.isCreated?this.options.onUpdate(data):(this.state.isCreated=!0,this.options.onCreate(data))}}
/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */function isModifierEnabled$3(modifiers,modifierName){return modifiers.some((function(_ref){var name=_ref.name,enabled=_ref.enabled;return enabled&&name===modifierName}))}
/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */function getSupportedPropertyName$3(property){for(var prefixes=[!1,"ms","Webkit","Moz","O"],upperProp=property.charAt(0).toUpperCase()+property.slice(1),i=0;i<prefixes.length;i++){var prefix=prefixes[i],toCheck=prefix?""+prefix+upperProp:property;if("undefined"!==typeof document.body.style[toCheck])return toCheck}return null}
/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */function destroy$3(){return this.state.isDestroyed=!0,
// touch DOM only if `applyStyle` modifier is enabled
isModifierEnabled$3(this.modifiers,"applyStyle")&&(this.popper.removeAttribute("x-placement"),this.popper.style.position="",this.popper.style.top="",this.popper.style.left="",this.popper.style.right="",this.popper.style.bottom="",this.popper.style.willChange="",this.popper.style[getSupportedPropertyName$3("transform")]=""),this.disableEventListeners(),
// remove the popper if user explicitly asked for the deletion on destroy
// do not use `remove` because IE11 doesn't support it
this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}
/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */function getWindow$3(element){var ownerDocument=element.ownerDocument;return ownerDocument?ownerDocument.defaultView:window}function attachToScrollParents$3(scrollParent,event,callback,scrollParents){var isBody="BODY"===scrollParent.nodeName,target=isBody?scrollParent.ownerDocument.defaultView:scrollParent;target.addEventListener(event,callback,{passive:!0}),isBody||attachToScrollParents$3(getScrollParent$3(target.parentNode),event,callback,scrollParents),scrollParents.push(target)}
/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */function setupEventListeners$3(reference,options,state,updateBound){
// Resize event listener on window
state.updateBound=updateBound,getWindow$3(reference).addEventListener("resize",state.updateBound,{passive:!0});
// Scroll event listener on scroll parents
var scrollElement=getScrollParent$3(reference);return attachToScrollParents$3(scrollElement,"scroll",state.updateBound,state.scrollParents),state.scrollElement=scrollElement,state.eventsEnabled=!0,state}
/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */function enableEventListeners$3(){this.state.eventsEnabled||(this.state=setupEventListeners$3(this.reference,this.options,this.state,this.scheduleUpdate))}
/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */function removeEventListeners$3(reference,state){
// Remove resize event listener on window
return getWindow$3(reference).removeEventListener("resize",state.updateBound),
// Remove scroll event listener on scroll parents
state.scrollParents.forEach((function(target){target.removeEventListener("scroll",state.updateBound)})),
// Reset state
state.updateBound=null,state.scrollParents=[],state.scrollElement=null,state.eventsEnabled=!1,state}
/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */function disableEventListeners$3(){this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=removeEventListeners$3(this.reference,this.state))}
/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */function isNumeric$3(n){return""!==n&&!isNaN(parseFloat(n))&&isFinite(n)}
/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */function setStyles$3(element,styles){Object.keys(styles).forEach((function(prop){var unit="";
// add unit if the value is numeric and is one of the following
-1!==["width","height","top","right","bottom","left"].indexOf(prop)&&isNumeric$3(styles[prop])&&(unit="px"),element.style[prop]=styles[prop]+unit}))}
/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */function setAttributes$3(element,attributes){Object.keys(attributes).forEach((function(prop){var value=attributes[prop];!1!==value?element.setAttribute(prop,attributes[prop]):element.removeAttribute(prop)}))}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */function applyStyle$3(data){
// any property present in `data.styles` will be applied to the popper,
// in this way we can make the 3rd party modifiers add custom styles to it
// Be aware, modifiers could override the properties defined in the previous
// lines of this modifier!
return setStyles$3(data.instance.popper,data.styles),
// any property present in `data.attributes` will be applied to the popper,
// they will be set as HTML attributes of the element
setAttributes$3(data.instance.popper,data.attributes),
// if arrowElement is defined and arrowStyles has some properties
data.arrowElement&&Object.keys(data.arrowStyles).length&&setStyles$3(data.arrowElement,data.arrowStyles),data}
/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */function applyStyleOnLoad$3(reference,popper,options,modifierOptions,state){
// compute reference element offsets
var referenceOffsets=getReferenceOffsets$3(state,popper,reference,options.positionFixed),placement=computeAutoPlacement$3(options.placement,referenceOffsets,popper,reference,options.modifiers.flip.boundariesElement,options.modifiers.flip.padding);
// compute auto placement, store placement inside the data object,
// modifiers will be able to edit `placement` if needed
// and refer to originalPlacement to know the original value
return popper.setAttribute("x-placement",placement),
// Apply `position` to popper before anything else because
// without the position applied we can't guarantee correct computations
setStyles$3(popper,{position:options.positionFixed?"fixed":"absolute"}),options}
/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */function getRoundedOffsets$3(data,shouldRound){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,round=Math.round,floor=Math.floor,noRound=function(v){return v},referenceWidth=round(reference.width),popperWidth=round(popper.width),isVertical=-1!==["left","right"].indexOf(data.placement),isVariation=-1!==data.placement.indexOf("-"),sameWidthParity=referenceWidth%2===popperWidth%2,bothOddWidth=referenceWidth%2===1&&popperWidth%2===1,horizontalToInteger=shouldRound?isVertical||isVariation||sameWidthParity?round:floor:noRound,verticalToInteger=shouldRound?round:noRound;return{left:horizontalToInteger(bothOddWidth&&!isVariation&&shouldRound?popper.left-1:popper.left),top:verticalToInteger(popper.top),bottom:verticalToInteger(popper.bottom),right:horizontalToInteger(popper.right)}}var isFirefox$3=isBrowser$4&&/Firefox/i.test(navigator.userAgent);
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function computeStyle$3(data,options){var x=options.x,y=options.y,popper=data.offsets.popper,legacyGpuAccelerationOption=find$4(data.instance.modifiers,(function(modifier){return"applyStyle"===modifier.name})).gpuAcceleration,gpuAcceleration=void 0!==legacyGpuAccelerationOption?legacyGpuAccelerationOption:options.gpuAcceleration,offsetParent=getOffsetParent$3(data.instance.popper),offsetParentRect=getBoundingClientRect$3(offsetParent),styles={position:popper.position},offsets=getRoundedOffsets$3(data,window.devicePixelRatio<2||!isFirefox$3),sideA="bottom"===x?"top":"bottom",sideB="right"===y?"left":"right",prefixedProperty=getSupportedPropertyName$3("transform"),left=void 0,top=void 0;if(top="bottom"===sideA?
// when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
// and not the bottom of the html element
"HTML"===offsetParent.nodeName?-offsetParent.clientHeight+offsets.bottom:-offsetParentRect.height+offsets.bottom:offsets.top,left="right"===sideB?"HTML"===offsetParent.nodeName?-offsetParent.clientWidth+offsets.right:-offsetParentRect.width+offsets.right:offsets.left,gpuAcceleration&&prefixedProperty)styles[prefixedProperty]="translate3d("+left+"px, "+top+"px, 0)",styles[sideA]=0,styles[sideB]=0,styles.willChange="transform";else{
// othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
var invertTop="bottom"===sideA?-1:1,invertLeft="right"===sideB?-1:1;styles[sideA]=top*invertTop,styles[sideB]=left*invertLeft,styles.willChange=sideA+", "+sideB}
// Attributes
var attributes={"x-placement":data.placement};
// Update `data` attributes, styles and arrowStyles
return data.attributes=_extends$6({},attributes,data.attributes),data.styles=_extends$6({},styles,data.styles),data.arrowStyles=_extends$6({},data.offsets.arrow,data.arrowStyles),data}
/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */function isModifierRequired$3(modifiers,requestingName,requestedName){var requesting=find$4(modifiers,(function(_ref){var name=_ref.name;return name===requestingName})),isRequired=!!requesting&&modifiers.some((function(modifier){return modifier.name===requestedName&&modifier.enabled&&modifier.order<requesting.order}));if(!isRequired);return isRequired}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function arrow$4(data,options){var _data$offsets$arrow;
// arrow depends on keepTogether in order to work
if(!isModifierRequired$3(data.instance.modifiers,"arrow","keepTogether"))return data;var arrowElement=options.element;
// if arrowElement is a string, suppose it's a CSS selector
if("string"===typeof arrowElement){
// if arrowElement is not found, don't run the modifier
if(arrowElement=data.instance.popper.querySelector(arrowElement),!arrowElement)return data}else
// if the arrowElement isn't a query selector we must check that the
// provided DOM node is child of its popper node
if(!data.instance.popper.contains(arrowElement))return data;var placement=data.placement.split("-")[0],_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,isVertical=-1!==["left","right"].indexOf(placement),len=isVertical?"height":"width",sideCapitalized=isVertical?"Top":"Left",side=sideCapitalized.toLowerCase(),altSide=isVertical?"left":"top",opSide=isVertical?"bottom":"right",arrowElementSize=getOuterSizes$3(arrowElement)[len];
// extends keepTogether behavior making sure the popper and its
// reference have enough pixels in conjunction
// top/left side
reference[opSide]-arrowElementSize<popper[side]&&(data.offsets.popper[side]-=popper[side]-(reference[opSide]-arrowElementSize)),
// bottom/right side
reference[side]+arrowElementSize>popper[opSide]&&(data.offsets.popper[side]+=reference[side]+arrowElementSize-popper[opSide]),data.offsets.popper=getClientRect$3(data.offsets.popper);
// compute center of the popper
var center=reference[side]+reference[len]/2-arrowElementSize/2,css=getStyleComputedProperty$3(data.instance.popper),popperMarginSide=parseFloat(css["margin"+sideCapitalized]),popperBorderSide=parseFloat(css["border"+sideCapitalized+"Width"]),sideValue=center-data.offsets.popper[side]-popperMarginSide-popperBorderSide;
// Compute the sideValue using the updated popper offsets
// take popper margin in account because we don't have this info available
// prevent arrowElement from being placed not contiguously to its popper
return sideValue=Math.max(Math.min(popper[len]-arrowElementSize,sideValue),0),data.arrowElement=arrowElement,data.offsets.arrow=(_data$offsets$arrow={},defineProperty$3(_data$offsets$arrow,side,Math.round(sideValue)),defineProperty$3(_data$offsets$arrow,altSide,""),_data$offsets$arrow),data}
/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */function getOppositeVariation$3(variation){return"end"===variation?"start":"start"===variation?"end":variation}
/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */var placements$3=["auto-start","auto","auto-end","top-start","top","top-end","right-start","right","right-end","bottom-end","bottom","bottom-start","left-end","left","left-start"],validPlacements$3=placements$3.slice(3);
// Get rid of `auto` `auto-start` and `auto-end`
/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise$3(placement){var counter=arguments.length>1&&void 0!==arguments[1]&&arguments[1],index=validPlacements$3.indexOf(placement),arr=validPlacements$3.slice(index+1).concat(validPlacements$3.slice(0,index));return counter?arr.reverse():arr}var BEHAVIORS$3={FLIP:"flip",CLOCKWISE:"clockwise",COUNTERCLOCKWISE:"counterclockwise"};
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function flip$3(data,options){
// if `inner` modifier is enabled, we can't use the `flip` modifier
if(isModifierEnabled$3(data.instance.modifiers,"inner"))return data;if(data.flipped&&data.placement===data.originalPlacement)
// seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
return data;var boundaries=getBoundaries$3(data.instance.popper,data.instance.reference,options.padding,options.boundariesElement,data.positionFixed),placement=data.placement.split("-")[0],placementOpposite=getOppositePlacement$3(placement),variation=data.placement.split("-")[1]||"",flipOrder=[];switch(options.behavior){case BEHAVIORS$3.FLIP:flipOrder=[placement,placementOpposite];break;case BEHAVIORS$3.CLOCKWISE:flipOrder=clockwise$3(placement);break;case BEHAVIORS$3.COUNTERCLOCKWISE:flipOrder=clockwise$3(placement,!0);break;default:flipOrder=options.behavior}return flipOrder.forEach((function(step,index){if(placement!==step||flipOrder.length===index+1)return data;placement=data.placement.split("-")[0],placementOpposite=getOppositePlacement$3(placement);var popperOffsets=data.offsets.popper,refOffsets=data.offsets.reference,floor=Math.floor,overlapsRef="left"===placement&&floor(popperOffsets.right)>floor(refOffsets.left)||"right"===placement&&floor(popperOffsets.left)<floor(refOffsets.right)||"top"===placement&&floor(popperOffsets.bottom)>floor(refOffsets.top)||"bottom"===placement&&floor(popperOffsets.top)<floor(refOffsets.bottom),overflowsLeft=floor(popperOffsets.left)<floor(boundaries.left),overflowsRight=floor(popperOffsets.right)>floor(boundaries.right),overflowsTop=floor(popperOffsets.top)<floor(boundaries.top),overflowsBottom=floor(popperOffsets.bottom)>floor(boundaries.bottom),overflowsBoundaries="left"===placement&&overflowsLeft||"right"===placement&&overflowsRight||"top"===placement&&overflowsTop||"bottom"===placement&&overflowsBottom,isVertical=-1!==["top","bottom"].indexOf(placement),flippedVariationByRef=!!options.flipVariations&&(isVertical&&"start"===variation&&overflowsLeft||isVertical&&"end"===variation&&overflowsRight||!isVertical&&"start"===variation&&overflowsTop||!isVertical&&"end"===variation&&overflowsBottom),flippedVariationByContent=!!options.flipVariationsByContent&&(isVertical&&"start"===variation&&overflowsRight||isVertical&&"end"===variation&&overflowsLeft||!isVertical&&"start"===variation&&overflowsBottom||!isVertical&&"end"===variation&&overflowsTop),flippedVariation=flippedVariationByRef||flippedVariationByContent;(overlapsRef||overflowsBoundaries||flippedVariation)&&(
// this boolean to detect any flip loop
data.flipped=!0,(overlapsRef||overflowsBoundaries)&&(placement=flipOrder[index+1]),flippedVariation&&(variation=getOppositeVariation$3(variation)),data.placement=placement+(variation?"-"+variation:""),
// this object contains `position`, we want to preserve it along with
// any additional property we may add in the future
data.offsets.popper=_extends$6({},data.offsets.popper,getPopperOffsets$3(data.instance.popper,data.offsets.reference,data.placement)),data=runModifiers$3(data.instance.modifiers,data,"flip"))})),data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function keepTogether$3(data){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,placement=data.placement.split("-")[0],floor=Math.floor,isVertical=-1!==["top","bottom"].indexOf(placement),side=isVertical?"right":"bottom",opSide=isVertical?"left":"top",measurement=isVertical?"width":"height";return popper[side]<floor(reference[opSide])&&(data.offsets.popper[opSide]=floor(reference[opSide])-popper[measurement]),popper[opSide]>floor(reference[side])&&(data.offsets.popper[opSide]=floor(reference[side])),data}
/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */function toValue$3(str,measurement,popperOffsets,referenceOffsets){
// separate value from unit
var split=str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),value=+split[1],unit=split[2];
// If it's not a number it's an operator, I guess
if(!value)return str;if(0===unit.indexOf("%")){var element=void 0;switch(unit){case"%p":element=popperOffsets;break;case"%":case"%r":default:element=referenceOffsets}var rect=getClientRect$3(element);return rect[measurement]/100*value}if("vh"===unit||"vw"===unit){
// if is a vh or vw, we calculate the size based on the viewport
var size=void 0;return size="vh"===unit?Math.max(document.documentElement.clientHeight,window.innerHeight||0):Math.max(document.documentElement.clientWidth,window.innerWidth||0),size/100*value}
// if is an explicit pixel unit, we get rid of the unit and keep the value
// if is an implicit unit, it's px, and we return just the value
return value}
/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */function parseOffset$3(offset,popperOffsets,referenceOffsets,basePlacement){var offsets=[0,0],useHeight=-1!==["right","left"].indexOf(basePlacement),fragments=offset.split(/(\+|\-)/).map((function(frag){return frag.trim()})),divider=fragments.indexOf(find$4(fragments,(function(frag){return-1!==frag.search(/,|\s/)})));
// Use height if placement is left or right and index is 0 otherwise use width
// in this way the first offset will use an axis and the second one
// will use the other one
fragments[divider]&&fragments[divider].indexOf(",");
// If divider is found, we divide the list of values and operands to divide
// them by ofset X and Y.
var splitRegex=/\s*,\s*|\s+/,ops=-1!==divider?[fragments.slice(0,divider).concat([fragments[divider].split(splitRegex)[0]]),[fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider+1))]:[fragments];
// Convert the values with units to absolute pixels to allow our computations
return ops=ops.map((function(op,index){
// Most of the units rely on the orientation of the popper
var measurement=(1===index?!useHeight:useHeight)?"height":"width",mergeWithPrevious=!1;return op.reduce((function(a,b){return""===a[a.length-1]&&-1!==["+","-"].indexOf(b)?(a[a.length-1]=b,mergeWithPrevious=!0,a):mergeWithPrevious?(a[a.length-1]+=b,mergeWithPrevious=!1,a):a.concat(b)}),[]).map((function(str){return toValue$3(str,measurement,popperOffsets,referenceOffsets)}))})),
// Loop trough the offsets arrays and execute the operations
ops.forEach((function(op,index){op.forEach((function(frag,index2){isNumeric$3(frag)&&(offsets[index]+=frag*("-"===op[index2-1]?-1:1))}))})),offsets}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */function offset$3(data,_ref){var offset=_ref.offset,placement=data.placement,_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,basePlacement=placement.split("-")[0],offsets=void 0;return offsets=isNumeric$3(+offset)?[+offset,0]:parseOffset$3(offset,popper,reference,basePlacement),"left"===basePlacement?(popper.top+=offsets[0],popper.left-=offsets[1]):"right"===basePlacement?(popper.top+=offsets[0],popper.left+=offsets[1]):"top"===basePlacement?(popper.left+=offsets[0],popper.top-=offsets[1]):"bottom"===basePlacement&&(popper.left+=offsets[0],popper.top+=offsets[1]),data.popper=popper,data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function preventOverflow$3(data,options){var boundariesElement=options.boundariesElement||getOffsetParent$3(data.instance.popper);
// If offsetParent is the reference element, we really want to
// go one step up and use the next offsetParent as reference to
// avoid to make this modifier completely useless and look like broken
data.instance.reference===boundariesElement&&(boundariesElement=getOffsetParent$3(boundariesElement));
// NOTE: DOM access here
// resets the popper's position so that the document size can be calculated excluding
// the size of the popper element itself
var transformProp=getSupportedPropertyName$3("transform"),popperStyles=data.instance.popper.style,top=popperStyles.top,left=popperStyles.left,transform=popperStyles[transformProp];popperStyles.top="",popperStyles.left="",popperStyles[transformProp]="";var boundaries=getBoundaries$3(data.instance.popper,data.instance.reference,options.padding,boundariesElement,data.positionFixed);
// NOTE: DOM access here
// restores the original style properties after the offsets have been computed
popperStyles.top=top,popperStyles.left=left,popperStyles[transformProp]=transform,options.boundaries=boundaries;var order=options.priority,popper=data.offsets.popper,check={primary:function(placement){var value=popper[placement];return popper[placement]<boundaries[placement]&&!options.escapeWithReference&&(value=Math.max(popper[placement],boundaries[placement])),defineProperty$3({},placement,value)},secondary:function(placement){var mainSide="right"===placement?"left":"top",value=popper[mainSide];return popper[placement]>boundaries[placement]&&!options.escapeWithReference&&(value=Math.min(popper[mainSide],boundaries[placement]-("right"===placement?popper.width:popper.height))),defineProperty$3({},mainSide,value)}};return order.forEach((function(placement){var side=-1!==["left","top"].indexOf(placement)?"primary":"secondary";popper=_extends$6({},popper,check[side](placement))})),data.offsets.popper=popper,data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function shift$4(data){var placement=data.placement,basePlacement=placement.split("-")[0],shiftvariation=placement.split("-")[1];
// if shift shiftvariation is specified, run the modifier
if(shiftvariation){var _data$offsets=data.offsets,reference=_data$offsets.reference,popper=_data$offsets.popper,isVertical=-1!==["bottom","top"].indexOf(basePlacement),side=isVertical?"left":"top",measurement=isVertical?"width":"height",shiftOffsets={start:defineProperty$3({},side,reference[side]),end:defineProperty$3({},side,reference[side]+reference[measurement]-popper[measurement])};data.offsets.popper=_extends$6({},popper,shiftOffsets[shiftvariation])}return data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function hide$3(data){if(!isModifierRequired$3(data.instance.modifiers,"hide","preventOverflow"))return data;var refRect=data.offsets.reference,bound=find$4(data.instance.modifiers,(function(modifier){return"preventOverflow"===modifier.name})).boundaries;if(refRect.bottom<bound.top||refRect.left>bound.right||refRect.top>bound.bottom||refRect.right<bound.left){
// Avoid unnecessary DOM access if visibility hasn't changed
if(!0===data.hide)return data;data.hide=!0,data.attributes["x-out-of-boundaries"]=""}else{
// Avoid unnecessary DOM access if visibility hasn't changed
if(!1===data.hide)return data;data.hide=!1,data.attributes["x-out-of-boundaries"]=!1}return data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function inner$3(data){var placement=data.placement,basePlacement=placement.split("-")[0],_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,isHoriz=-1!==["left","right"].indexOf(basePlacement),subtractLength=-1===["top","left"].indexOf(basePlacement);return popper[isHoriz?"left":"top"]=reference[basePlacement]-(subtractLength?popper[isHoriz?"width":"height"]:0),data.placement=getOppositePlacement$3(placement),data.offsets.popper=getClientRect$3(popper),data}
/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */
/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */var modifiers$4={
/**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
shift:{
/** @prop {number} order=100 - Index used to define the order of execution */
order:100,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:shift$4},
/**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
offset:{
/** @prop {number} order=200 - Index used to define the order of execution */
order:200,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:offset$3,
/** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
offset:0},
/**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
preventOverflow:{
/** @prop {number} order=300 - Index used to define the order of execution */
order:300,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:preventOverflow$3,
/**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
priority:["left","right","top","bottom"],
/**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
padding:5,
/**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
boundariesElement:"scrollParent"},
/**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
keepTogether:{
/** @prop {number} order=400 - Index used to define the order of execution */
order:400,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:keepTogether$3},
/**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
arrow:{
/** @prop {number} order=500 - Index used to define the order of execution */
order:500,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:arrow$4,
/** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
element:"[x-arrow]"},
/**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
flip:{
/** @prop {number} order=600 - Index used to define the order of execution */
order:600,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:flip$3,
/**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
behavior:"flip",
/**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
padding:5,
/**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
boundariesElement:"viewport",
/**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
flipVariations:!1,
/**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
flipVariationsByContent:!1},
/**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
inner:{
/** @prop {number} order=700 - Index used to define the order of execution */
order:700,
/** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
enabled:!1,
/** @prop {ModifierFn} */
fn:inner$3},
/**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
hide:{
/** @prop {number} order=800 - Index used to define the order of execution */
order:800,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:hide$3},
/**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
computeStyle:{
/** @prop {number} order=850 - Index used to define the order of execution */
order:850,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:computeStyle$3,
/**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
gpuAcceleration:!0,
/**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
x:"bottom",
/**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
y:"right"},
/**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
applyStyle:{
/** @prop {number} order=900 - Index used to define the order of execution */
order:900,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:applyStyle$3,
/** @prop {Function} */
onLoad:applyStyleOnLoad$3,
/**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
gpuAcceleration:void 0}},Defaults$3={
/**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
placement:"bottom",
/**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
positionFixed:!1,
/**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
eventsEnabled:!0,
/**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
removeOnDestroy:!1,
/**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
onCreate:function(){},
/**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
onUpdate:function(){},
/**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
modifiers:modifiers$4},Popper$4=function(){
/**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
function Popper(reference,popper){var _this=this,options=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};classCallCheck$3(this,Popper),this.scheduleUpdate=function(){return requestAnimationFrame(_this.update)},
// make update() debounced, so that it only runs at most once-per-tick
this.update=debounce$4(this.update.bind(this)),
// with {} we create a new object with the options inside it
this.options=_extends$6({},Popper.Defaults,options),
// init state
this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},
// get reference and popper elements (allow jQuery wrappers)
this.reference=reference&&reference.jquery?reference[0]:reference,this.popper=popper&&popper.jquery?popper[0]:popper,
// Deep merge modifiers options
this.options.modifiers={},Object.keys(_extends$6({},Popper.Defaults.modifiers,options.modifiers)).forEach((function(name){_this.options.modifiers[name]=_extends$6({},Popper.Defaults.modifiers[name]||{},options.modifiers?options.modifiers[name]:{})})),
// Refactoring modifiers' list (Object => Array)
this.modifiers=Object.keys(this.options.modifiers).map((function(name){return _extends$6({name:name},_this.options.modifiers[name])})).sort((function(a,b){return a.order-b.order})),
// modifiers have the ability to execute arbitrary code when Popper.js get inited
// such code is executed in the same order of its modifier
// they could add new properties to their options configuration
// BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
this.modifiers.forEach((function(modifierOptions){modifierOptions.enabled&&isFunction$5(modifierOptions.onLoad)&&modifierOptions.onLoad(_this.reference,_this.popper,_this.options,modifierOptions,_this.state)})),
// fire the first update to position the popper in the right place
this.update();var eventsEnabled=this.options.eventsEnabled;eventsEnabled&&
// setup event listeners, they will take care of update the position in specific situations
this.enableEventListeners(),this.state.eventsEnabled=eventsEnabled}
// We can't use class properties because they don't get listed in the
// class prototype and break stuff like Sinon stubs
return createClass$3(Popper,[{key:"update",value:function(){return update$3.call(this)}},{key:"destroy",value:function(){return destroy$3.call(this)}},{key:"enableEventListeners",value:function(){return enableEventListeners$3.call(this)}},{key:"disableEventListeners",value:function(){return disableEventListeners$3.call(this)}
/**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */
/**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */}]),Popper}();
/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */
/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */
Popper$4.Utils=("undefined"!==typeof window?window:global).PopperUtils,Popper$4.placements=placements$3,Popper$4.Defaults=Defaults$3;
/**!
* tippy.js v4.3.5
* (c) 2017-2019 atomiks
* MIT License
*/
var css$2='.tippy-iOS{cursor:pointer!important;-webkit-tap-highlight-color:transparent}.tippy-popper{transition-timing-function:cubic-bezier(.165,.84,.44,1);max-width:calc(100% - 8px);pointer-events:none;outline:0}.tippy-popper[x-placement^=top] .tippy-backdrop{border-radius:40% 40% 0 0}.tippy-popper[x-placement^=top] .tippy-roundarrow{bottom:-7px;bottom:-6.5px;-webkit-transform-origin:50% 0;transform-origin:50% 0;margin:0 3px}.tippy-popper[x-placement^=top] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(180deg);transform:rotate(180deg)}.tippy-popper[x-placement^=top] .tippy-arrow{border-top:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;bottom:-7px;margin:0 3px;-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=top] .tippy-backdrop{-webkit-transform-origin:0 25%;transform-origin:0 25%}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-55%);transform:scale(1) translate(-50%,-55%)}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%,-45%);transform:scale(.2) translate(-50%,-45%);opacity:0}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(-20px);transform:translateY(-20px)}.tippy-popper[x-placement^=top] [data-animation=perspective]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(-10px);transform:perspective(700px) translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateX(60deg);transform:perspective(700px) rotateX(60deg)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=top] [data-animation=scale]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px) scale(.5);transform:translateY(-10px) scale(.5)}.tippy-popper[x-placement^=bottom] .tippy-backdrop{border-radius:0 0 30% 30%}.tippy-popper[x-placement^=bottom] .tippy-roundarrow{top:-7px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%;margin:0 3px}.tippy-popper[x-placement^=bottom] .tippy-roundarrow svg{position:absolute;left:0}.tippy-popper[x-placement^=bottom] .tippy-arrow{border-bottom:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;top:-7px;margin:0 3px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%}.tippy-popper[x-placement^=bottom] .tippy-backdrop{-webkit-transform-origin:0 -50%;transform-origin:0 -50%}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-45%);transform:scale(1) translate(-50%,-45%)}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%);transform:scale(.2) translate(-50%);opacity:0}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(20px);transform:translateY(20px)}.tippy-popper[x-placement^=bottom] [data-animation=perspective]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(10px);transform:perspective(700px) translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateX(-60deg);transform:perspective(700px) rotateX(-60deg)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=bottom] [data-animation=scale]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px) scale(.5);transform:translateY(10px) scale(.5)}.tippy-popper[x-placement^=left] .tippy-backdrop{border-radius:50% 0 0 50%}.tippy-popper[x-placement^=left] .tippy-roundarrow{right:-12px;-webkit-transform-origin:33.33333333% 50%;transform-origin:33.33333333% 50%;margin:3px 0}.tippy-popper[x-placement^=left] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(90deg);transform:rotate(90deg)}.tippy-popper[x-placement^=left] .tippy-arrow{border-left:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;right:-7px;margin:3px 0;-webkit-transform-origin:0 50%;transform-origin:0 50%}.tippy-popper[x-placement^=left] .tippy-backdrop{-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-75%,-50%);transform:scale(.2) translate(-75%,-50%);opacity:0}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(-20px);transform:translateX(-20px)}.tippy-popper[x-placement^=left] [data-animation=perspective]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(-10px);transform:perspective(700px) translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateY(-60deg);transform:perspective(700px) rotateY(-60deg)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=left] [data-animation=scale]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px) scale(.5);transform:translateX(-10px) scale(.5)}.tippy-popper[x-placement^=right] .tippy-backdrop{border-radius:0 50% 50% 0}.tippy-popper[x-placement^=right] .tippy-roundarrow{left:-12px;-webkit-transform-origin:66.66666666% 50%;transform-origin:66.66666666% 50%;margin:3px 0}.tippy-popper[x-placement^=right] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.tippy-popper[x-placement^=right] .tippy-arrow{border-right:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;left:-7px;margin:3px 0;-webkit-transform-origin:100% 50%;transform-origin:100% 50%}.tippy-popper[x-placement^=right] .tippy-backdrop{-webkit-transform-origin:-50% 0;transform-origin:-50% 0}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-25%,-50%);transform:scale(.2) translate(-25%,-50%);opacity:0}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(20px);transform:translateX(20px)}.tippy-popper[x-placement^=right] [data-animation=perspective]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(10px);transform:perspective(700px) translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateY(60deg);transform:perspective(700px) rotateY(60deg)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=right] [data-animation=scale]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px) scale(.5);transform:translateX(10px) scale(.5)}.tippy-tooltip{position:relative;color:#fff;border-radius:.25rem;font-size:.875rem;padding:.3125rem .5625rem;line-height:1.4;text-align:center;background-color:#333}.tippy-tooltip[data-size=small]{padding:.1875rem .375rem;font-size:.75rem}.tippy-tooltip[data-size=large]{padding:.375rem .75rem;font-size:1rem}.tippy-tooltip[data-animatefill]{overflow:hidden;background-color:initial}.tippy-tooltip[data-interactive],.tippy-tooltip[data-interactive] .tippy-roundarrow path{pointer-events:auto}.tippy-tooltip[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-tooltip[data-inertia][data-state=hidden]{transition-timing-function:ease}.tippy-arrow,.tippy-roundarrow{position:absolute;width:0;height:0}.tippy-roundarrow{width:18px;height:7px;fill:#333;pointer-events:none}.tippy-backdrop{position:absolute;background-color:#333;border-radius:50%;width:calc(110% + 2rem);left:50%;top:50%;z-index:-1;transition:all cubic-bezier(.46,.1,.52,.98);-webkit-backface-visibility:hidden;backface-visibility:hidden}.tippy-backdrop:after{content:"";float:left;padding-top:100%}.tippy-backdrop+.tippy-content{transition-property:opacity;will-change:opacity}.tippy-backdrop+.tippy-content[data-state=hidden]{opacity:0}';function _extends$1$2(){return _extends$1$2=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},_extends$1$2.apply(this,arguments)}var version$2="4.3.5",isBrowser$1$2="undefined"!==typeof window&&"undefined"!==typeof document,ua$2=isBrowser$1$2?navigator.userAgent:"",isIE$1$2=/MSIE |Trident\//.test(ua$2),isUCBrowser$2=/UCBrowser\//.test(ua$2),isIOS$3=isBrowser$1$2&&/iPhone|iPad|iPod/.test(navigator.platform)&&!window.MSStream,defaultProps$3={a11y:!0,allowHTML:!0,animateFill:!0,animation:"shift-away",appendTo:function(){return document.body},aria:"describedby",arrow:!1,arrowType:"sharp",boundary:"scrollParent",content:"",delay:0,distance:10,duration:[325,275],flip:!0,flipBehavior:"flip",flipOnUpdate:!1,followCursor:!1,hideOnClick:!0,ignoreAttributes:!1,inertia:!1,interactive:!1,interactiveBorder:2,interactiveDebounce:0,lazy:!0,maxWidth:350,multiple:!1,offset:0,onHidden:function(){},onHide:function(){},onMount:function(){},onShow:function(){},onShown:function(){},onTrigger:function(){},placement:"top",popperOptions:{},role:"tooltip",showOnInit:!1,size:"regular",sticky:!1,target:"",theme:"dark",touch:!0,touchHold:!1,trigger:"mouseenter focus",triggerTarget:null,updateDuration:0,wait:null,zIndex:9999
/**
   * If the set() method encounters one of these, the popperInstance must be
   * recreated
   */},POPPER_INSTANCE_DEPENDENCIES$2=["arrow","arrowType","boundary","distance","flip","flipBehavior","flipOnUpdate","offset","placement","popperOptions"],elementProto$2=isBrowser$1$2?Element.prototype:{},matches$3=elementProto$2.matches||elementProto$2.matchesSelector||elementProto$2.webkitMatchesSelector||elementProto$2.mozMatchesSelector||elementProto$2.msMatchesSelector;
/**
 * Ponyfill for Array.from - converts iterable values to an array
 */
function arrayFrom$2(value){return[].slice.call(value)}
/**
 * Ponyfill for Element.prototype.closest
 */function closest$2(element,selector){return closestCallback$2(element,(function(el){return matches$3.call(el,selector)}))}
/**
 * Works like Element.prototype.closest, but uses a callback instead
 */function closestCallback$2(element,callback){while(element){if(callback(element))return element;element=element.parentElement}return null}
// Passive event listener config
var PASSIVE$2={passive:!0},PADDING$2=4,PLACEMENT_ATTRIBUTE$2="x-placement",OUT_OF_BOUNDARIES_ATTRIBUTE$2="x-out-of-boundaries",IOS_CLASS$2="tippy-iOS",ACTIVE_CLASS$2="tippy-active",POPPER_CLASS$2="tippy-popper",TOOLTIP_CLASS$2="tippy-tooltip",CONTENT_CLASS$2="tippy-content",BACKDROP_CLASS$2="tippy-backdrop",ARROW_CLASS$2="tippy-arrow",ROUND_ARROW_CLASS$2="tippy-roundarrow",POPPER_SELECTOR$2=".".concat(POPPER_CLASS$2),TOOLTIP_SELECTOR$2=".".concat(TOOLTIP_CLASS$2),CONTENT_SELECTOR$2=".".concat(CONTENT_CLASS$2),BACKDROP_SELECTOR$2=".".concat(BACKDROP_CLASS$2),ARROW_SELECTOR$2=".".concat(ARROW_CLASS$2),ROUND_ARROW_SELECTOR$2=".".concat(ROUND_ARROW_CLASS$2),isUsingTouch$2=!1;function onDocumentTouch$2(){isUsingTouch$2||(isUsingTouch$2=!0,isIOS$3&&document.body.classList.add(IOS_CLASS$2),window.performance&&document.addEventListener("mousemove",onDocumentMouseMove$2))}var lastMouseMoveTime$2=0;function onDocumentMouseMove$2(){var now=performance.now();// Chrome 60+ is 1 mousemove per animation frame, use 20ms time difference
now-lastMouseMoveTime$2<20&&(isUsingTouch$2=!1,document.removeEventListener("mousemove",onDocumentMouseMove$2),isIOS$3||document.body.classList.remove(IOS_CLASS$2)),lastMouseMoveTime$2=now}function onWindowBlur$2(){var _document=document,activeElement=_document.activeElement;activeElement&&activeElement.blur&&activeElement._tippy&&activeElement.blur()}
/**
 * Adds the needed global event listeners
 */function bindGlobalEventListeners$2(){document.addEventListener("touchstart",onDocumentTouch$2,PASSIVE$2),window.addEventListener("blur",onWindowBlur$2)}var keys$3=Object.keys(defaultProps$3);
/**
 * Returns an object of optional props from data-tippy-* attributes
 */function getDataAttributeOptions$2(reference){return keys$3.reduce((function(acc,key){var valueAsString=(reference.getAttribute("data-tippy-".concat(key))||"").trim();if(!valueAsString)return acc;if("content"===key)acc[key]=valueAsString;else try{acc[key]=JSON.parse(valueAsString)}catch(e){acc[key]=valueAsString}return acc}),{})}
/**
 * Polyfills the virtual reference (plain object) with Element.prototype props
 * Mutating because DOM elements are mutated, adds `_tippy` property
 */function polyfillElementPrototypeProperties$2(virtualReference){var polyfills={isVirtual:!0,attributes:virtualReference.attributes||{},contains:function(){},setAttribute:function(key,value){virtualReference.attributes[key]=value},getAttribute:function(key){return virtualReference.attributes[key]},removeAttribute:function(key){delete virtualReference.attributes[key]},hasAttribute:function(key){return key in virtualReference.attributes},addEventListener:function(){},removeEventListener:function(){},classList:{classNames:{},add:function(key){virtualReference.classList.classNames[key]=!0},remove:function(key){delete virtualReference.classList.classNames[key]},contains:function(key){return key in virtualReference.classList.classNames}}};for(var key in polyfills)virtualReference[key]=polyfills[key]}
/**
 * Determines if a value is a "bare" virtual element (before mutations done
 * by `polyfillElementPrototypeProperties()`). JSDOM elements show up as
 * [object Object], we can check if the value is "element-like" if it has
 * `addEventListener`
 */function isBareVirtualElement$2(value){return"[object Object]"==={}.toString.call(value)&&!value.addEventListener}
/**
 * Determines if the value is a reference element
 */function isReferenceElement$2(value){return!!value._tippy&&!matches$3.call(value,POPPER_SELECTOR$2)}
/**
 * Safe .hasOwnProperty check, for prototype-less objects
 */function hasOwnProperty$3(obj,key){return{}.hasOwnProperty.call(obj,key)}
/**
 * Returns an array of elements based on the value
 */function getArrayOfElements$2(value){if(isSingular$2(value))
// TODO: VirtualReference is not compatible to type Element
return[value];if(value instanceof NodeList)return arrayFrom$2(value);if(Array.isArray(value))return value;try{return arrayFrom$2(document.querySelectorAll(value))}catch(e){return[]}}
/**
 * Returns a value at a given index depending on if it's an array or number
 */function getValue$4(value,index,defaultValue){if(Array.isArray(value)){var v=value[index];return null==v?defaultValue:v}return value}
/**
 * Debounce utility. To avoid bloating bundle size, we're only passing 1
 * argument here, a more generic function would pass all arguments. Only
 * `onMouseMove` uses this which takes the event object for now.
 */function debounce$1$2(fn,ms){
// Avoid wrapping in `setTimeout` if ms is 0 anyway
return 0===ms?fn:function(arg){clearTimeout(timeout),timeout=setTimeout((function(){fn(arg)}),ms)};var timeout}
/**
 * Prevents errors from being thrown while accessing nested modifier objects
 * in `popperOptions`
 */function getModifier$2(obj,key){return obj&&obj.modifiers&&obj.modifiers[key]}
/**
 * Determines if an array or string includes a value
 */function includes$2(a,b){return a.indexOf(b)>-1}
/**
 * Determines if the value is a real element
 */function isRealElement$2(value){return value instanceof Element}
/**
 * Determines if the value is singular-like
 */function isSingular$2(value){return!(!value||!hasOwnProperty$3(value,"isVirtual"))||isRealElement$2(value)}
/**
 * Firefox extensions don't allow setting .innerHTML directly, this will trick it
 */function innerHTML$2(){return"innerHTML"}
/**
 * Evaluates a function if one, or returns the value
 */function invokeWithArgsOrReturn$2(value,args){return"function"===typeof value?value.apply(null,args):value}
/**
 * Sets a popperInstance `flip` modifier's enabled state
 */function setFlipModifierEnabled$2(modifiers,value){modifiers.filter((function(m){return"flip"===m.name}))[0].enabled=value}
/**
 * Determines if an element can receive focus
 * Always returns true for virtual objects
 */function canReceiveFocus$2(element){return!isRealElement$2(element)||matches$3.call(element,"a[href],area[href],button,details,input,textarea,select,iframe,[tabindex]")&&!element.hasAttribute("disabled")}
/**
 * Returns a new `div` element
 */function div$2(){return document.createElement("div")}
/**
 * Applies a transition duration to a list of elements
 */function setTransitionDuration$2(els,value){els.forEach((function(el){el&&(el.style.transitionDuration="".concat(value,"ms"))}))}
/**
 * Sets the visibility state to elements so they can begin to transition
 */function setVisibilityState$2(els,state){els.forEach((function(el){el&&el.setAttribute("data-state",state)}))}
/**
 * Evaluates the props object by merging data attributes and
 * disabling conflicting options where necessary
 */function evaluateProps$2(reference,props){var out=_extends$1$2({},props,{content:invokeWithArgsOrReturn$2(props.content,[reference])},props.ignoreAttributes?{}:getDataAttributeOptions$2(reference));return(out.arrow||isUCBrowser$2)&&(out.animateFill=!1),out}
/**
 * Validates an object of options with the valid default props object
 */function validateOptions$2(options,defaultProps){Object.keys(options).forEach((function(option){if(!hasOwnProperty$3(defaultProps,option))throw new Error("[tippy]: `".concat(option,"` is not a valid option"))}))}
/**
 * Sets the innerHTML of an element
 */function setInnerHTML$2(element,html){element[innerHTML$2()]=isRealElement$2(html)?html[innerHTML$2()]:html}
/**
 * Sets the content of a tooltip
 */function setContent$3(contentEl,props){if(isRealElement$2(props.content))setInnerHTML$2(contentEl,""),contentEl.appendChild(props.content);else if("function"!==typeof props.content){var key=props.allowHTML?"innerHTML":"textContent";contentEl[key]=props.content}}
/**
 * Returns the child elements of a popper element
 */function getChildren$2(popper){return{tooltip:popper.querySelector(TOOLTIP_SELECTOR$2),backdrop:popper.querySelector(BACKDROP_SELECTOR$2),content:popper.querySelector(CONTENT_SELECTOR$2),arrow:popper.querySelector(ARROW_SELECTOR$2)||popper.querySelector(ROUND_ARROW_SELECTOR$2)}}
/**
 * Adds `data-inertia` attribute
 */function addInertia$2(tooltip){tooltip.setAttribute("data-inertia","")}
/**
 * Removes `data-inertia` attribute
 */function removeInertia$2(tooltip){tooltip.removeAttribute("data-inertia")}
/**
 * Creates an arrow element and returns it
 */function createArrowElement$2(arrowType){var arrow=div$2();return"round"===arrowType?(arrow.className=ROUND_ARROW_CLASS$2,setInnerHTML$2(arrow,'<svg viewBox="0 0 18 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z"/></svg>')):arrow.className=ARROW_CLASS$2,arrow}
/**
 * Creates a backdrop element and returns it
 */function createBackdropElement$2(){var backdrop=div$2();return backdrop.className=BACKDROP_CLASS$2,backdrop.setAttribute("data-state","hidden"),backdrop}
/**
 * Adds interactive-related attributes
 */function addInteractive$2(popper,tooltip){popper.setAttribute("tabindex","-1"),tooltip.setAttribute("data-interactive","")}
/**
 * Removes interactive-related attributes
 */function removeInteractive$2(popper,tooltip){popper.removeAttribute("tabindex"),tooltip.removeAttribute("data-interactive")}
/**
 * Add/remove transitionend listener from tooltip
 */function updateTransitionEndListener$2(tooltip,action,listener){
// UC Browser hasn't adopted the `transitionend` event despite supporting
// unprefixed transitions...
var eventName=isUCBrowser$2&&void 0!==document.body.style.webkitTransition?"webkitTransitionEnd":"transitionend";tooltip[action+"EventListener"](eventName,listener)}
/**
 * Returns the popper's placement, ignoring shifting (top-start, etc)
 */function getBasicPlacement$2(popper){var fullPlacement=popper.getAttribute(PLACEMENT_ATTRIBUTE$2);return fullPlacement?fullPlacement.split("-")[0]:""}
/**
 * Triggers reflow
 */function reflow$2(popper){popper.offsetHeight}
/**
 * Adds/removes theme from tooltip's classList
 */function updateTheme$2(tooltip,action,theme){theme.split(" ").forEach((function(themeName){tooltip.classList[action](themeName+"-theme")}))}
/**
 * Constructs the popper element and returns it
 */function createPopperElement$2(id,props){var popper=div$2();popper.className=POPPER_CLASS$2,popper.id="tippy-".concat(id),popper.style.zIndex=""+props.zIndex,popper.style.position="absolute",popper.style.top="0",popper.style.left="0",props.role&&popper.setAttribute("role",props.role);var tooltip=div$2();tooltip.className=TOOLTIP_CLASS$2,tooltip.style.maxWidth=props.maxWidth+("number"===typeof props.maxWidth?"px":""),tooltip.setAttribute("data-size",props.size),tooltip.setAttribute("data-animation",props.animation),tooltip.setAttribute("data-state","hidden"),updateTheme$2(tooltip,"add",props.theme);var content=div$2();return content.className=CONTENT_CLASS$2,content.setAttribute("data-state","hidden"),props.interactive&&addInteractive$2(popper,tooltip),props.arrow&&tooltip.appendChild(createArrowElement$2(props.arrowType)),props.animateFill&&(tooltip.appendChild(createBackdropElement$2()),tooltip.setAttribute("data-animatefill","")),props.inertia&&addInertia$2(tooltip),setContent$3(content,props),tooltip.appendChild(content),popper.appendChild(tooltip),popper}
/**
 * Updates the popper element based on the new props
 */function updatePopperElement$2(popper,prevProps,nextProps){var _getChildren=getChildren$2(popper),tooltip=_getChildren.tooltip,content=_getChildren.content,backdrop=_getChildren.backdrop,arrow=_getChildren.arrow;popper.style.zIndex=""+nextProps.zIndex,tooltip.setAttribute("data-size",nextProps.size),tooltip.setAttribute("data-animation",nextProps.animation),tooltip.style.maxWidth=nextProps.maxWidth+("number"===typeof nextProps.maxWidth?"px":""),nextProps.role?popper.setAttribute("role",nextProps.role):popper.removeAttribute("role"),prevProps.content!==nextProps.content&&setContent$3(content,nextProps),// animateFill
!prevProps.animateFill&&nextProps.animateFill?(tooltip.appendChild(createBackdropElement$2()),tooltip.setAttribute("data-animatefill","")):prevProps.animateFill&&!nextProps.animateFill&&(tooltip.removeChild(backdrop),tooltip.removeAttribute("data-animatefill")),// arrow
!prevProps.arrow&&nextProps.arrow?tooltip.appendChild(createArrowElement$2(nextProps.arrowType)):prevProps.arrow&&!nextProps.arrow&&tooltip.removeChild(arrow),// arrowType
prevProps.arrow&&nextProps.arrow&&prevProps.arrowType!==nextProps.arrowType&&tooltip.replaceChild(createArrowElement$2(nextProps.arrowType),arrow),// interactive
!prevProps.interactive&&nextProps.interactive?addInteractive$2(popper,tooltip):prevProps.interactive&&!nextProps.interactive&&removeInteractive$2(popper,tooltip),// inertia
!prevProps.inertia&&nextProps.inertia?addInertia$2(tooltip):prevProps.inertia&&!nextProps.inertia&&removeInertia$2(tooltip),// theme
prevProps.theme!==nextProps.theme&&(updateTheme$2(tooltip,"remove",prevProps.theme),updateTheme$2(tooltip,"add",nextProps.theme))}
/**
 * Hides all visible poppers on the document
 */function hideAll$2(){var _ref=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},excludedReferenceOrInstance=_ref.exclude,duration=_ref.duration;arrayFrom$2(document.querySelectorAll(POPPER_SELECTOR$2)).forEach((function(popper){var instance=popper._tippy;if(instance){var isExcluded=!1;excludedReferenceOrInstance&&(isExcluded=isReferenceElement$2(excludedReferenceOrInstance)?instance.reference===excludedReferenceOrInstance:popper===excludedReferenceOrInstance.popper),isExcluded||instance.hide(duration)}}))}
/**
 * Determines if the mouse cursor is outside of the popper's interactive border
 * region
 */function isCursorOutsideInteractiveBorder$2(popperPlacement,popperRect,event,props){if(!popperPlacement)return!0;var x=event.clientX,y=event.clientY,interactiveBorder=props.interactiveBorder,distance=props.distance,exceedsTop=popperRect.top-y>("top"===popperPlacement?interactiveBorder+distance:interactiveBorder),exceedsBottom=y-popperRect.bottom>("bottom"===popperPlacement?interactiveBorder+distance:interactiveBorder),exceedsLeft=popperRect.left-x>("left"===popperPlacement?interactiveBorder+distance:interactiveBorder),exceedsRight=x-popperRect.right>("right"===popperPlacement?interactiveBorder+distance:interactiveBorder);return exceedsTop||exceedsBottom||exceedsLeft||exceedsRight}
/**
 * Returns the distance offset, taking into account the default offset due to
 * the transform: translate() rule (10px) in CSS
 */function getOffsetDistanceInPx$2(distance){return-(distance-10)+"px"}var idCounter$2=1,mouseMoveListeners$2=[];// Workaround for IE11's lack of new MouseEvent constructor
/**
 * Creates and returns a Tippy object. We're using a closure pattern instead of
 * a class so that the exposed object API is clean without private members
 * prefixed with `_`.
 */
function createTippy$2(reference,collectionProps){var lastTriggerEventType,lastMouseMoveEvent,showTimeoutId,hideTimeoutId,scheduleHideAnimationFrameId,props=evaluateProps$2(reference,collectionProps);// If the reference shouldn't have multiple tippys, return null early
if(!props.multiple&&reference._tippy)return null;
/* ======================= 🔒 Private members 🔒 ======================= */var previousPlacement,currentMountCallback,currentTransitionEndListener,currentComputedPadding,isScheduledToShow=!1,isBeingDestroyed=!1,wasVisibleDuringPreviousUpdate=!1,hasMountCallbackRun=!1,listeners=[],debouncedOnMouseMove=debounce$1$2(onMouseMove,props.interactiveDebounce),id=idCounter$2++,popper=createPopperElement$2(id,props),popperChildren=getChildren$2(popper),popperInstance=null,state={
// Is the instance currently enabled?
isEnabled:!0,
// Is the tippy currently showing and not transitioning out?
isVisible:!1,
// Has the instance been destroyed?
isDestroyed:!1,
// Is the tippy currently mounted to the DOM?
isMounted:!1,
// Has the tippy finished transitioning in?
isShown:!1},instance={
// properties
id:id,reference:reference,popper:popper,popperChildren:popperChildren,popperInstance:popperInstance,props:props,state:state,
// methods
clearDelayTimeouts:clearDelayTimeouts,set:set,setContent:setContent,show:show,hide:hide,enable:enable,disable:disable,destroy:destroy
/* ==================== Initial instance mutations =================== */};return reference._tippy=instance,popper._tippy=instance,addTriggersToReference(),props.lazy||createPopperInstance(),props.showOnInit&&scheduleShow(),// Ensure the event listeners target can receive focus
!props.a11y||props.target||canReceiveFocus$2(getEventListenersTarget())||getEventListenersTarget().setAttribute("tabindex","0"),// Prevent a tippy with a delay from hiding if the cursor left then returned
// before it started hiding
popper.addEventListener("mouseenter",(function(event){instance.props.interactive&&instance.state.isVisible&&"mouseenter"===lastTriggerEventType&&
// We don't want props.onTrigger() to be called here, since the `event`
// object is not related to the reference element
scheduleShow(event,!0)})),popper.addEventListener("mouseleave",(function(){instance.props.interactive&&"mouseenter"===lastTriggerEventType&&document.addEventListener("mousemove",debouncedOnMouseMove)})),instance;
/* ======================= 🔒 Private methods 🔒 ======================= */
/**
   * Removes the follow cursor listener
   */function removeFollowCursorListener(){document.removeEventListener("mousemove",positionVirtualReferenceNearCursor)}
/**
   * Cleans up interactive mouse listeners
   */function cleanupInteractiveMouseListeners(){document.body.removeEventListener("mouseleave",scheduleHide),document.removeEventListener("mousemove",debouncedOnMouseMove),mouseMoveListeners$2=mouseMoveListeners$2.filter((function(listener){return listener!==debouncedOnMouseMove}))}
/**
   * Returns correct target used for event listeners
   */function getEventListenersTarget(){return instance.props.triggerTarget||reference}
/**
   * Adds the document click event listener for the instance
   */function addDocumentClickListener(){document.addEventListener("click",onDocumentClick,!0)}
/**
   * Removes the document click event listener for the instance
   */function removeDocumentClickListener(){document.removeEventListener("click",onDocumentClick,!0)}
/**
   * Returns transitionable inner elements used in show/hide methods
   */function getTransitionableElements(){return[instance.popperChildren.tooltip,instance.popperChildren.backdrop,instance.popperChildren.content]}
/**
   * Determines if the instance is in `followCursor` mode.
   * NOTE: in v5, touch devices will use `initial` behavior no matter the value.
   */function getIsInLooseFollowCursorMode(){var followCursor=instance.props.followCursor;return followCursor&&"focus"!==lastTriggerEventType||isUsingTouch$2&&"initial"===followCursor}
/**
   * Updates the tooltip's position on each animation frame
   */function makeSticky(){setTransitionDuration$2([popper],isIE$1$2?0:instance.props.updateDuration);var prevRefRect=reference.getBoundingClientRect();function updatePosition(){var currentRefRect=reference.getBoundingClientRect();// Only schedule an update if the reference rect has changed
prevRefRect.top===currentRefRect.top&&prevRefRect.right===currentRefRect.right&&prevRefRect.bottom===currentRefRect.bottom&&prevRefRect.left===currentRefRect.left||instance.popperInstance.scheduleUpdate(),prevRefRect=currentRefRect,instance.state.isMounted&&requestAnimationFrame(updatePosition)}updatePosition()}
/**
   * Invokes a callback once the tooltip has fully transitioned out
   */function onTransitionedOut(duration,callback){onTransitionEnd(duration,(function(){!instance.state.isVisible&&popper.parentNode&&popper.parentNode.contains(popper)&&callback()}))}
/**
   * Invokes a callback once the tooltip has fully transitioned in
   */function onTransitionedIn(duration,callback){onTransitionEnd(duration,callback)}
/**
   * Invokes a callback once the tooltip's CSS transition ends
   */function onTransitionEnd(duration,callback){var tooltip=instance.popperChildren.tooltip;
/**
     * Listener added as the `transitionend` handler
     */function listener(event){event.target===tooltip&&(updateTransitionEndListener$2(tooltip,"remove",listener),callback())}// Make callback synchronous if duration is 0
// `transitionend` won't fire otherwise
if(0===duration)return callback();updateTransitionEndListener$2(tooltip,"remove",currentTransitionEndListener),updateTransitionEndListener$2(tooltip,"add",listener),currentTransitionEndListener=listener}
/**
   * Adds an event listener to the reference and stores it in `listeners`
   */function on(eventType,handler){var options=arguments.length>2&&void 0!==arguments[2]&&arguments[2];getEventListenersTarget().addEventListener(eventType,handler,options),listeners.push({eventType:eventType,handler:handler,options:options})}
/**
   * Adds event listeners to the reference based on the `trigger` prop
   */function addTriggersToReference(){instance.props.touchHold&&!instance.props.target&&(on("touchstart",onTrigger,PASSIVE$2),on("touchend",onMouseLeave,PASSIVE$2)),instance.props.trigger.trim().split(" ").forEach((function(eventType){if("manual"!==eventType)// Non-delegates
if(instance.props.target)
// Delegates
switch(eventType){case"mouseenter":on("mouseover",onDelegateShow),on("mouseout",onDelegateHide);break;case"focus":on("focusin",onDelegateShow),on("focusout",onDelegateHide);break;case"click":on(eventType,onDelegateShow);break}else switch(on(eventType,onTrigger),eventType){case"mouseenter":on("mouseleave",onMouseLeave);break;case"focus":on(isIE$1$2?"focusout":"blur",onBlur);break}}))}
/**
   * Removes event listeners from the reference
   */function removeTriggersFromReference(){listeners.forEach((function(_ref){var eventType=_ref.eventType,handler=_ref.handler,options=_ref.options;getEventListenersTarget().removeEventListener(eventType,handler,options)})),listeners=[]}
/**
   * Positions the virtual reference near the cursor
   */function positionVirtualReferenceNearCursor(event){var _lastMouseMoveEvent=lastMouseMoveEvent=event,x=_lastMouseMoveEvent.clientX,y=_lastMouseMoveEvent.clientY;// Gets set once popperInstance `onCreate` has been called
if(currentComputedPadding){// If the instance is interactive, avoid updating the position unless it's
// over the reference element
var isCursorOverReference=closestCallback$2(event.target,(function(el){return el===reference})),rect=reference.getBoundingClientRect(),followCursor=instance.props.followCursor,isHorizontal="horizontal"===followCursor,isVertical="vertical"===followCursor,isVerticalPlacement=includes$2(["top","bottom"],getBasicPlacement$2(popper)),fullPlacement=popper.getAttribute(PLACEMENT_ATTRIBUTE$2),isVariation=!!fullPlacement&&!!fullPlacement.split("-")[1],size=isVerticalPlacement?popper.offsetWidth:popper.offsetHeight,halfSize=size/2,verticalIncrease=isVerticalPlacement?0:isVariation?size:halfSize,horizontalIncrease=isVerticalPlacement?isVariation?size:halfSize:0;!isCursorOverReference&&instance.props.interactive||(instance.popperInstance.reference=_extends$1$2({},instance.popperInstance.reference,{
// This will exist in next Popper.js feature release to fix #532
// @ts-ignore
referenceNode:reference,
// These `client` values don't get used by Popper.js if they are 0
clientWidth:0,clientHeight:0,getBoundingClientRect:function(){return{width:isVerticalPlacement?size:0,height:isVerticalPlacement?0:size,top:(isHorizontal?rect.top:y)-verticalIncrease,bottom:(isHorizontal?rect.bottom:y)+verticalIncrease,left:(isVertical?rect.left:x)-horizontalIncrease,right:(isVertical?rect.right:x)+horizontalIncrease}}}),instance.popperInstance.update()),"initial"===followCursor&&instance.state.isVisible&&removeFollowCursorListener()}}
/**
   * Creates the tippy instance for a delegate when it's been triggered
   */function createDelegateChildTippy(event){if(event){var targetEl=closest$2(event.target,instance.props.target);targetEl&&!targetEl._tippy&&createTippy$2(targetEl,_extends$1$2({},instance.props,{content:invokeWithArgsOrReturn$2(collectionProps.content,[targetEl]),appendTo:collectionProps.appendTo,target:"",showOnInit:!0}))}}
/**
   * Event listener invoked upon trigger
   */function onTrigger(event){instance.state.isEnabled&&!isEventListenerStopped(event)&&(instance.state.isVisible||(lastTriggerEventType=event.type,event instanceof MouseEvent&&(lastMouseMoveEvent=event,// If scrolling, `mouseenter` events can be fired if the cursor lands
// over a new target, but `mousemove` events don't get fired. This
// causes interactive tooltips to get stuck open until the cursor is
// moved
mouseMoveListeners$2.forEach((function(listener){return listener(event)})))),// Toggle show/hide when clicking click-triggered tooltips
"click"===event.type&&!1!==instance.props.hideOnClick&&instance.state.isVisible?scheduleHide():scheduleShow(event))}
/**
   * Event listener used for interactive tooltips to detect when they should
   * hide
   */function onMouseMove(event){var isCursorOverPopper=closest$2(event.target,POPPER_SELECTOR$2)===popper,isCursorOverReference=closestCallback$2(event.target,(function(el){return el===reference}));isCursorOverPopper||isCursorOverReference||isCursorOutsideInteractiveBorder$2(getBasicPlacement$2(popper),popper.getBoundingClientRect(),event,instance.props)&&(cleanupInteractiveMouseListeners(),scheduleHide())}
/**
   * Event listener invoked upon mouseleave
   */function onMouseLeave(event){if(!isEventListenerStopped(event))return instance.props.interactive?(document.body.addEventListener("mouseleave",scheduleHide),document.addEventListener("mousemove",debouncedOnMouseMove),void mouseMoveListeners$2.push(debouncedOnMouseMove)):void scheduleHide()}
/**
   * Event listener invoked upon blur
   */function onBlur(event){event.target===getEventListenersTarget()&&(instance.props.interactive&&event.relatedTarget&&popper.contains(event.relatedTarget)||scheduleHide())}
/**
   * Event listener invoked when a child target is triggered
   */function onDelegateShow(event){closest$2(event.target,instance.props.target)&&scheduleShow(event)}
/**
   * Event listener invoked when a child target should hide
   */function onDelegateHide(event){closest$2(event.target,instance.props.target)&&scheduleHide()}
/**
   * Determines if an event listener should stop further execution due to the
   * `touchHold` option
   */function isEventListenerStopped(event){var supportsTouch="ontouchstart"in window,isTouchEvent=includes$2(event.type,"touch"),touchHold=instance.props.touchHold;return supportsTouch&&isUsingTouch$2&&touchHold&&!isTouchEvent||isUsingTouch$2&&!touchHold&&isTouchEvent}
/**
   * Runs the mount callback
   */function runMountCallback(){!hasMountCallbackRun&&currentMountCallback&&(hasMountCallbackRun=!0,reflow$2(popper),currentMountCallback())}
/**
   * Creates the popper instance for the instance
   */function createPopperInstance(){var popperOptions=instance.props.popperOptions,_instance$popperChild=instance.popperChildren,tooltip=_instance$popperChild.tooltip,arrow=_instance$popperChild.arrow,preventOverflowModifier=getModifier$2(popperOptions,"preventOverflow");function applyMutations(data){instance.props.flip&&!instance.props.flipOnUpdate&&(data.flipped&&(instance.popperInstance.options.placement=data.placement),setFlipModifierEnabled$2(instance.popperInstance.modifiers,!1)),// Apply all of the popper's attributes to the tootip node as well.
// Allows users to avoid using the .tippy-popper selector for themes.
tooltip.setAttribute(PLACEMENT_ATTRIBUTE$2,data.placement),!1!==data.attributes[OUT_OF_BOUNDARIES_ATTRIBUTE$2]?tooltip.setAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE$2,""):tooltip.removeAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE$2),// Prevents a transition when changing placements (while tippy is visible)
// for scroll/resize updates
previousPlacement&&previousPlacement!==data.placement&&wasVisibleDuringPreviousUpdate&&(tooltip.style.transition="none",requestAnimationFrame((function(){tooltip.style.transition=""}))),previousPlacement=data.placement,wasVisibleDuringPreviousUpdate=instance.state.isVisible;var basicPlacement=getBasicPlacement$2(popper),styles=tooltip.style;// Account for the `distance` offset
styles.top=styles.bottom=styles.left=styles.right="",styles[basicPlacement]=getOffsetDistanceInPx$2(instance.props.distance);var padding=preventOverflowModifier&&void 0!==preventOverflowModifier.padding?preventOverflowModifier.padding:PADDING$2,isPaddingNumber="number"===typeof padding,computedPadding=_extends$1$2({top:isPaddingNumber?padding:padding.top,bottom:isPaddingNumber?padding:padding.bottom,left:isPaddingNumber?padding:padding.left,right:isPaddingNumber?padding:padding.right},!isPaddingNumber&&padding);computedPadding[basicPlacement]=isPaddingNumber?padding+instance.props.distance:(padding[basicPlacement]||0)+instance.props.distance,instance.popperInstance.modifiers.filter((function(m){return"preventOverflow"===m.name}))[0].padding=computedPadding,currentComputedPadding=computedPadding}var config=_extends$1$2({eventsEnabled:!1,placement:instance.props.placement},popperOptions,{modifiers:_extends$1$2({},popperOptions?popperOptions.modifiers:{},{preventOverflow:_extends$1$2({boundariesElement:instance.props.boundary,padding:PADDING$2},preventOverflowModifier),arrow:_extends$1$2({element:arrow,enabled:!!arrow},getModifier$2(popperOptions,"arrow")),flip:_extends$1$2({enabled:instance.props.flip,
// The tooltip is offset by 10px from the popper in CSS,
// we need to account for its distance
padding:instance.props.distance+PADDING$2,behavior:instance.props.flipBehavior},getModifier$2(popperOptions,"flip")),offset:_extends$1$2({offset:instance.props.offset},getModifier$2(popperOptions,"offset"))}),onCreate:function(data){applyMutations(data),runMountCallback(),popperOptions&&popperOptions.onCreate&&popperOptions.onCreate(data)},onUpdate:function(data){applyMutations(data),runMountCallback(),popperOptions&&popperOptions.onUpdate&&popperOptions.onUpdate(data)}});instance.popperInstance=new Popper$4(reference,popper,config)}
/**
   * Mounts the tooltip to the DOM
   */function mount(){hasMountCallbackRun=!1;var isInLooseFollowCursorMode=getIsInLooseFollowCursorMode();instance.popperInstance?(setFlipModifierEnabled$2(instance.popperInstance.modifiers,instance.props.flip),isInLooseFollowCursorMode||(instance.popperInstance.reference=reference,instance.popperInstance.enableEventListeners()),instance.popperInstance.scheduleUpdate()):(createPopperInstance(),isInLooseFollowCursorMode||instance.popperInstance.enableEventListeners());var appendTo=instance.props.appendTo,parentNode="parent"===appendTo?reference.parentNode:invokeWithArgsOrReturn$2(appendTo,[reference]);parentNode.contains(popper)||(parentNode.appendChild(popper),instance.props.onMount(instance),instance.state.isMounted=!0)}
/**
   * Setup before show() is invoked (delays, etc.)
   */function scheduleShow(event,shouldAvoidCallingOnTrigger){if(clearDelayTimeouts(),!instance.state.isVisible){// Is a delegate, create an instance for the child target
if(instance.props.target)return createDelegateChildTippy(event);if(isScheduledToShow=!0,event&&!shouldAvoidCallingOnTrigger&&instance.props.onTrigger(instance,event),instance.props.wait)return instance.props.wait(instance,event);// If the tooltip has a delay, we need to be listening to the mousemove as
// soon as the trigger event is fired, so that it's in the correct position
// upon mount.
// Edge case: if the tooltip is still mounted, but then scheduleShow() is
// called, it causes a jump.
getIsInLooseFollowCursorMode()&&!instance.state.isMounted&&(instance.popperInstance||createPopperInstance(),document.addEventListener("mousemove",positionVirtualReferenceNearCursor)),addDocumentClickListener();var delay=getValue$4(instance.props.delay,0,defaultProps$3.delay);delay?showTimeoutId=setTimeout((function(){show()}),delay):show()}}
/**
   * Setup before hide() is invoked (delays, etc.)
   */function scheduleHide(){if(clearDelayTimeouts(),!instance.state.isVisible)return removeFollowCursorListener(),void removeDocumentClickListener();isScheduledToShow=!1;var delay=getValue$4(instance.props.delay,1,defaultProps$3.delay);delay?hideTimeoutId=setTimeout((function(){instance.state.isVisible&&hide()}),delay):
// Fixes a `transitionend` problem when it fires 1 frame too
// late sometimes, we don't want hide() to be called.
scheduleHideAnimationFrameId=requestAnimationFrame((function(){hide()}))}
/**
   * Listener to handle clicks on the document to determine if the
   * instance should hide
   */function onDocumentClick(event){
// Clicked on interactive popper
if(!instance.props.interactive||!popper.contains(event.target)){// Clicked on the event listeners target
if(getEventListenersTarget().contains(event.target)){if(isUsingTouch$2)return;if(instance.state.isVisible&&includes$2(instance.props.trigger,"click"))return}!0===instance.props.hideOnClick&&(clearDelayTimeouts(),hide())}}
/* ======================= 🔑 Public methods 🔑 ======================= */
/**
   * Enables the instance to allow it to show or hide
   */function enable(){instance.state.isEnabled=!0}
/**
   * Disables the instance to disallow it to show or hide
   */function disable(){instance.state.isEnabled=!1}
/**
   * Clears pending timeouts related to the `delay` prop if any
   */function clearDelayTimeouts(){clearTimeout(showTimeoutId),clearTimeout(hideTimeoutId),cancelAnimationFrame(scheduleHideAnimationFrameId)}
/**
   * Sets new props for the instance and redraws the tooltip
   */function set(options){
// Backwards-compatible after TypeScript change
options=options||{},validateOptions$2(options,defaultProps$3),removeTriggersFromReference();var prevProps=instance.props,nextProps=evaluateProps$2(reference,_extends$1$2({},instance.props,{},options,{ignoreAttributes:!0}));nextProps.ignoreAttributes=hasOwnProperty$3(options,"ignoreAttributes")?options.ignoreAttributes||!1:prevProps.ignoreAttributes,instance.props=nextProps,addTriggersToReference(),cleanupInteractiveMouseListeners(),debouncedOnMouseMove=debounce$1$2(onMouseMove,nextProps.interactiveDebounce),updatePopperElement$2(popper,prevProps,nextProps),instance.popperChildren=getChildren$2(popper),instance.popperInstance&&(POPPER_INSTANCE_DEPENDENCIES$2.some((function(prop){return hasOwnProperty$3(options,prop)&&options[prop]!==prevProps[prop]}))?(instance.popperInstance.destroy(),createPopperInstance(),instance.state.isVisible&&instance.popperInstance.enableEventListeners(),instance.props.followCursor&&lastMouseMoveEvent&&positionVirtualReferenceNearCursor(lastMouseMoveEvent)):instance.popperInstance.update())}
/**
   * Shortcut for .set({ content: newContent })
   */function setContent(content){set({content:content})}
/**
   * Shows the tooltip
   */function show(){var duration=arguments.length>0&&void 0!==arguments[0]?arguments[0]:getValue$4(instance.props.duration,0,defaultProps$3.duration[1]);if(!instance.state.isDestroyed&&instance.state.isEnabled&&(!isUsingTouch$2||instance.props.touch)&&!getEventListenersTarget().hasAttribute("disabled")&&!1!==instance.props.onShow(instance)){addDocumentClickListener(),popper.style.visibility="visible",instance.state.isVisible=!0,instance.props.interactive&&getEventListenersTarget().classList.add(ACTIVE_CLASS$2);// Prevent a transition if the popper is at the opposite placement
var transitionableElements=getTransitionableElements();setTransitionDuration$2(transitionableElements.concat(popper),0),currentMountCallback=function(){if(instance.state.isVisible){var isInLooseFollowCursorMode=getIsInLooseFollowCursorMode();isInLooseFollowCursorMode&&lastMouseMoveEvent?positionVirtualReferenceNearCursor(lastMouseMoveEvent):isInLooseFollowCursorMode||
// Double update will apply correct mutations
instance.popperInstance.update(),instance.popperChildren.backdrop&&(instance.popperChildren.content.style.transitionDelay=Math.round(duration/12)+"ms"),instance.props.sticky&&makeSticky(),setTransitionDuration$2([popper],instance.props.updateDuration),setTransitionDuration$2(transitionableElements,duration),setVisibilityState$2(transitionableElements,"visible"),onTransitionedIn(duration,(function(){instance.props.aria&&getEventListenersTarget().setAttribute("aria-".concat(instance.props.aria),popper.id),instance.props.onShown(instance),instance.state.isShown=!0}))}},mount()}// Standardize `disabled` behavior across browsers.
// Firefox allows events on disabled elements, but Chrome doesn't.
// Using a wrapper element (i.e. <span>) is recommended.
}
/**
   * Hides the tooltip
   */function hide(){var duration=arguments.length>0&&void 0!==arguments[0]?arguments[0]:getValue$4(instance.props.duration,1,defaultProps$3.duration[1]);if(!instance.state.isDestroyed&&(instance.state.isEnabled||isBeingDestroyed)&&(!1!==instance.props.onHide(instance)||isBeingDestroyed)){removeDocumentClickListener(),popper.style.visibility="hidden",instance.state.isVisible=!1,instance.state.isShown=!1,wasVisibleDuringPreviousUpdate=!1,instance.props.interactive&&getEventListenersTarget().classList.remove(ACTIVE_CLASS$2);var transitionableElements=getTransitionableElements();setTransitionDuration$2(transitionableElements,duration),setVisibilityState$2(transitionableElements,"hidden"),onTransitionedOut(duration,(function(){isScheduledToShow||removeFollowCursorListener(),instance.props.aria&&getEventListenersTarget().removeAttribute("aria-".concat(instance.props.aria)),instance.popperInstance.disableEventListeners(),instance.popperInstance.options.placement=instance.props.placement,popper.parentNode.removeChild(popper),instance.props.onHidden(instance),instance.state.isMounted=!1}))}}
/**
   * Destroys the tooltip
   */function destroy(destroyTargetInstances){if(!instance.state.isDestroyed){isBeingDestroyed=!0,// If the popper is currently mounted to the DOM, we want to ensure it gets
// hidden and unmounted instantly upon destruction
instance.state.isMounted&&hide(0),removeTriggersFromReference(),delete reference._tippy;var target=instance.props.target;target&&destroyTargetInstances&&isRealElement$2(reference)&&arrayFrom$2(reference.querySelectorAll(target)).forEach((function(child){child._tippy&&child._tippy.destroy()})),instance.popperInstance&&instance.popperInstance.destroy(),isBeingDestroyed=!1,instance.state.isDestroyed=!0}}}
/**
 * Groups an array of instances by taking control of their props during
 * certain lifecycles.
 */function group$2(instances){var _ref=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_ref$delay=_ref.delay,delay=void 0===_ref$delay?instances[0].props.delay:_ref$delay,_ref$duration=_ref.duration,duration=void 0===_ref$duration?0:_ref$duration,isAnyTippyOpen=!1;function setIsAnyTippyOpen(value){isAnyTippyOpen=value,updateInstances()}function onShow(instance){instance._originalProps.onShow(instance),instances.forEach((function(instance){instance.set({duration:duration}),instance.state.isVisible&&instance.hide()})),setIsAnyTippyOpen(!0)}function onHide(instance){instance._originalProps.onHide(instance),setIsAnyTippyOpen(!1)}function onShown(instance){instance._originalProps.onShown(instance),instance.set({duration:instance._originalProps.duration})}function updateInstances(){instances.forEach((function(instance){instance.set({onShow:onShow,onShown:onShown,onHide:onHide,delay:isAnyTippyOpen?[0,Array.isArray(delay)?delay[1]:delay]:delay,duration:isAnyTippyOpen?duration:instance._originalProps.duration})}))}instances.forEach((function(instance){instance._originalProps?instance.set(instance._originalProps):instance._originalProps=_extends$1$2({},instance.props)})),updateInstances()}var globalEventListenersBound$2=!1;
/**
 * Exported module
 */function tippy$2(targets,options){validateOptions$2(options||{},defaultProps$3),globalEventListenersBound$2||(bindGlobalEventListeners$2(),globalEventListenersBound$2=!0);var props=_extends$1$2({},defaultProps$3,{},options);// If they are specifying a virtual positioning reference, we need to polyfill
// some native DOM props
isBareVirtualElement$2(targets)&&polyfillElementPrototypeProperties$2(targets);var instances=getArrayOfElements$2(targets).reduce((function(acc,reference){var instance=reference&&createTippy$2(reference,props);return instance&&acc.push(instance),acc}),[]);return isSingular$2(targets)?instances[0]:instances}
/**
 * Static props
 */
/**
 * Auto-init tooltips for elements with a `data-tippy="..."` attribute
 */
function autoInit$2(){arrayFrom$2(document.querySelectorAll("[data-tippy]")).forEach((function(el){var content=el.getAttribute("data-tippy");content&&tippy$2(el,{content:content})}))}
/**
 * Injects a string of CSS styles to a style node in <head>
 */
function injectCSS$2(css){if(isBrowser$1$2){var style=document.createElement("style");style.type="text/css",style.textContent=css,style.setAttribute("data-tippy-stylesheet","");var head=document.head,firstStyleOrLinkTag=head.querySelector("style,link");firstStyleOrLinkTag?head.insertBefore(style,firstStyleOrLinkTag):head.appendChild(style)}}tippy$2.version=version$2,tippy$2.defaults=defaultProps$3,
/**
 * Static methods
 */
tippy$2.setDefaults=function(partialDefaults){Object.keys(partialDefaults).forEach((function(key){
// @ts-ignore
defaultProps$3[key]=partialDefaults[key]}))},tippy$2.hideAll=hideAll$2,tippy$2.group=group$2,isBrowser$1$2&&setTimeout(autoInit$2),injectCSS$2(css$2);var commonjsGlobal$2="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof window?window:"undefined"!==typeof global?global:"undefined"!==typeof self?self:{};function createCommonjsModule$3(fn,module){return module={exports:{}},fn(module,module.exports),module.exports}var humps$2=createCommonjsModule$3((function(module){(function(global){var _processKeys=function(convert,obj,options){if(!_isObject(obj)||_isDate(obj)||_isRegExp(obj)||_isBoolean(obj)||_isFunction(obj))return obj;var output,i=0,l=0;if(_isArray(obj))for(output=[],l=obj.length;i<l;i++)output.push(_processKeys(convert,obj[i],options));else for(var key in output={},obj)Object.prototype.hasOwnProperty.call(obj,key)&&(output[convert(key,options)]=_processKeys(convert,obj[key],options));return output},separateWords=function(string,options){options=options||{};var separator=options.separator||"_",split=options.split||/(?=[A-Z])/;return string.split(split).join(separator)},camelize=function(string){return _isNumerical(string)?string:(string=string.replace(/[\-_\s]+(.)?/g,(function(match,chr){return chr?chr.toUpperCase():""})),string.substr(0,1).toLowerCase()+string.substr(1))},pascalize=function(string){var camelized=camelize(string);
// Ensure 1st char is always uppercase
return camelized.substr(0,1).toUpperCase()+camelized.substr(1)},decamelize=function(string,options){return separateWords(string,options).toLowerCase()},toString=Object.prototype.toString,_isFunction=function(obj){return"function"===typeof obj},_isObject=function(obj){return obj===Object(obj)},_isArray=function(obj){return"[object Array]"==toString.call(obj)},_isDate=function(obj){return"[object Date]"==toString.call(obj)},_isRegExp=function(obj){return"[object RegExp]"==toString.call(obj)},_isBoolean=function(obj){return"[object Boolean]"==toString.call(obj)},_isNumerical=function(obj){return obj-=0,obj===obj},_processor=function(convert,options){var callback=options&&"process"in options?options.process:options;return"function"!==typeof callback?convert:function(string,options){return callback(string,convert,options)}},humps={camelize:camelize,decamelize:decamelize,pascalize:pascalize,depascalize:decamelize,camelizeKeys:function(object,options){return _processKeys(_processor(camelize,options),object)},decamelizeKeys:function(object,options){return _processKeys(_processor(decamelize,options),object,options)},pascalizeKeys:function(object,options){return _processKeys(_processor(pascalize,options),object)},depascalizeKeys:function(){return this.decamelizeKeys.apply(this,arguments)}};
// String conversion methods
module.exports?module.exports=humps:global.humps=humps})(commonjsGlobal$2)}));function _defineProperty$4(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function ownKeys$6(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread2$3(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$6(Object(source),!0).forEach((function(key){_defineProperty$4(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$6(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}var booleanProps$2={a11y:!0,allowHTML:!0,animateFill:!0,arrow:!1,flip:!0,flipOnUpdate:!1,followCursor:!1,hideOnClick:!0,ignoreAttributes:!1,inertia:!1,interactive:!1,lazy:!0,multiple:!1,showOnInit:!1,sticky:!1,touch:!0,touchHold:!1},defaultProps$1$2=_objectSpread2$3({animation:"shift-away",appendTo:function(){return document.body},aria:"describedby",arrowType:"sharp",boundary:"scrollParent",content:"",delay:0,distance:10,duration:[325,275],flipBehavior:"flip",interactiveBorder:2,interactiveDebounce:0,maxWidth:350,offset:0,onHidden:function(){},onHide:function(){},onMount:function(){},onShow:function(){},onShown:function(){},placement:"top",popperOptions:{},role:"tooltip",size:"regular",target:"",theme:"dark",trigger:"mouseenter focus",updateDuration:0,wait:null,zIndex:9999},booleanProps$2),script$2$3={props:{to:void 0,toSelector:void 0,toElement:void 0,content:void 0,enabled:void 0,visible:void 0,triggerTarget:void 0,tag:{type:String,default:"div"},triggerTag:String,contentTag:String},data:function(){return{tip:null,options:{}}},mounted:function(){this.init()},watch:{content:function(){this.tip&&this.tip.set(this.getOptions())},enabled:function(val){this.tip&&(val?this.tip.enable():(this.tip.hide(),this.tip.disable()))},visible:function(val){this.tip&&(val?this.tip.show():this.tip.hide())}},updated:function(){this.tip&&!this.content&&this.tip.set(this.getOptions())},beforeDestroy:function(){this.tip&&this.tip.destroy()},computed:{isManualTrigger:function(){return"manual"===this.options.trigger}},methods:{init:function(){if(this.tip){try{this.tip.destroy()}catch(error){}this.tip=null}var elm=this.toElement;if(null==elm&&(elm=this.to?document.querySelector("[name='".concat(this.to,"']")):this.toSelector?document.querySelector(this.toSelector):this.$refs.trigger&&this.$refs.trigger.childElementCount>0?this.$refs.trigger:this.$el.parentElement),elm){var tip=tippy$2(elm,this.getOptions());if(tip){if(Array.isArray(tip)){if(!(tip.length>0))return;this.tip=tip[0]}this.tip=tip,this.$emit("onCreate",this.tip),this.$emit("init",this.tip),!1===this.enabled&&this.tip.disable(),this.isManualTrigger&&!0===this.visible&&this.tip.show()}}},tippy:function(){return this.tip},filterOptions:function(){for(var getValue=function(key,value){if(booleanProps$2.hasOwnProperty(key)){if(""===value)return!0;if("false"===value)return!1;if("true"===value)return!0}return value},_i=0,_Object$keys=Object.keys(this.options);_i<_Object$keys.length;_i++){var key=_Object$keys[_i];defaultProps$1$2.hasOwnProperty(key)?this.options[key]=getValue(key,this.options[key]):
// We're replacing this.options anyway, we don't have to worry about modifying the object
delete this.options[key]}return this.options},getOptions:function(){var _this=this;return this.options.content=this.content?this.content:this.$refs.content,Object.assign(this.options,humps$2.camelizeKeys(this.$attrs)),this.filterOptions(),!this.options.onShow&&this.$listeners&&this.$listeners["show"]&&(this.options.onShow=function(){var _this$$listeners$show;return(_this$$listeners$show=_this.$listeners["show"]).fns.apply(_this$$listeners$show,arguments)}),!this.options.onShow&&this.$listeners&&this.$listeners["shown"]&&(this.options.onShown=function(){var _this$$listeners$show2;return(_this$$listeners$show2=_this.$listeners["shown"]).fns.apply(_this$$listeners$show2,arguments)}),!this.options.onHidden&&this.$listeners&&this.$listeners["hidden"]&&(this.options.onHidden=function(){var _this$$listeners$hidd;return(_this$$listeners$hidd=_this.$listeners["hidden"]).fns.apply(_this$$listeners$hidd,arguments)}),!this.options.onHide&&this.$listeners&&this.$listeners["hide"]&&(this.options.onHide=function(){var _this$$listeners$hide;return(_this$$listeners$hide=_this.$listeners["hide"]).fns.apply(_this$$listeners$hide,arguments)}),!this.options.onMount&&this.$listeners&&this.$listeners["mount"]&&(this.options.onMount=function(){var _this$$listeners$moun;return(_this$$listeners$moun=_this.$listeners["mount"]).fns.apply(_this$$listeners$moun,arguments)}),this.options.triggerTarget=this.triggerTarget,this.options}}};function normalizeComponent$6(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier
/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);// Vue.extend constructor export interop.
var hook,options="function"===typeof script?script.options:script;// render functions
if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,// functional template
isFunctionalTemplate&&(options.functional=!0)),// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),// inject component styles
style&&style.call(this,createInjectorSSR(context)),// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(){style.call(this,createInjectorShadow(this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
var originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
var existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}var normalizeComponent_1$2=normalizeComponent$6,__vue_script__$2$3=script$2$3,__vue_render__$2$3=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c(_vm.tag,{tag:"component",attrs:{"data-tippy-component":""}},[_c(_vm.triggerTag||_vm.tag,{ref:"trigger",tag:"component",attrs:{"data-tippy-component-trigger":""}},[_vm._t("trigger")],2),_vm._v(" "),_c(_vm.contentTag||_vm.tag,{ref:"content",tag:"component"},[_vm._t("default")],2)],1)},__vue_staticRenderFns__$2$3=[];
/* script */__vue_render__$2$3._withStripped=!0;
/* style */
var __vue_inject_styles__$2$3=void 0,__vue_scope_id__$2$3=void 0,__vue_module_identifier__$2$3=void 0,__vue_is_functional_template__$2$3=!1,TippyComponent$2=normalizeComponent_1$2({render:__vue_render__$2$3,staticRenderFns:__vue_staticRenderFns__$2$3},__vue_inject_styles__$2$3,__vue_script__$2$3,__vue_scope_id__$2$3,__vue_is_functional_template__$2$3,__vue_module_identifier__$2$3,void 0,void 0),tippyDirective$2="tippy",plugin$4={install:function(Vue){var options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};function createTippy(el,binding,vnode){var handlers=vnode.data&&vnode.data.on||vnode.componentOptions&&vnode.componentOptions.listeners;el.setAttribute("data-tippy-directive","");var opts=deriveOpts(binding),modifiers=Object.keys(binding.modifiers||{}),placement=modifiers.find((function(modifier){return"arrow"!==modifier})),withArrow=-1!==modifiers.findIndex((function(modifier){return"arrow"===modifier}));opts=Object.assign({},options,opts),placement&&(opts.placement=opts.placement||placement),withArrow&&(opts.arrow=void 0===opts.arrow||opts.arrow),handlers&&handlers["show"]&&(opts.onShow=function(){var _handlers$show;return(_handlers$show=handlers["show"]).fns.apply(_handlers$show,arguments)}),handlers&&handlers["shown"]&&(opts.onShown=function(){var _handlers$shown;(_handlers$shown=handlers["shown"]).fns.apply(_handlers$shown,arguments)}),handlers&&handlers["hidden"]&&(opts.onHidden=function(){var _handlers$hidden;(_handlers$hidden=handlers["hidden"]).fns.apply(_handlers$hidden,arguments)}),handlers&&handlers["hide"]&&(opts.onHide=function(){var _handlers$hide;return(_handlers$hide=handlers["hide"]).fns.apply(_handlers$hide,arguments)}),handlers&&handlers["mount"]&&(opts.onMount=function(){var _handlers$mount;(_handlers$mount=handlers["mount"]).fns.apply(_handlers$mount,arguments)}),el.getAttribute("title")&&!opts.content&&(opts.content=el.getAttribute("title"),el.removeAttribute("title")),el.getAttribute("content")&&!opts.content&&(opts.content=el.getAttribute("content")),tippy$2(el,opts),opts.showOnLoad&&el._tippy.show(),Vue.nextTick((function(){handlers&&handlers["init"]&&handlers["init"].fns(el._tippy,el)}))}function deriveOpts(binding){return"string"===typeof binding.value?{content:binding.value}:binding.value||{}}tippyDirective$2=options.directive||"tippy",tippy$2.setDefaults(options||{}),Vue.directive(tippyDirective$2,{inserted:function(el,binding,vnode){Vue.nextTick((function(){createTippy(el,binding,vnode)}))},unbind:function(el){el._tippy&&el._tippy.destroy()},componentUpdated:function(el,binding,vnode){if(el._tippy){var opts=deriveOpts(binding);el.getAttribute("title")&&!opts.content&&(opts.content=el.getAttribute("title"),el.removeAttribute("title")),el.getAttribute("content")&&!opts.content&&(opts.content=el.getAttribute("content")),el._tippy.set(opts)}}})}};
/* scoped */"undefined"!==typeof window&&window.Vue&&(window.Vue.use(plugin$4),window.Vue.component("tippy",TippyComponent$2))
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */;const byteToHex$3=[];for(let i=0;i<256;++i)byteToHex$3.push((i+256).toString(16).slice(1));function _arrayLikeToArray$1$2(arr,len){(null==len||len>arr.length)&&(len=arr.length);for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2}function _arrayWithoutHoles$1$2(arr){if(Array.isArray(arr))return _arrayLikeToArray$1$2(arr)}function _iterableToArray$1$2(iter){if("undefined"!==typeof Symbol&&null!=iter[Symbol.iterator]||null!=iter["@@iterator"])return Array.from(iter)}function _unsupportedIterableToArray$1$2(o,minLen){if(o){if("string"===typeof o)return _arrayLikeToArray$1$2(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);return"Object"===n&&o.constructor&&(n=o.constructor.name),"Map"===n||"Set"===n?Array.from(o):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?_arrayLikeToArray$1$2(o,minLen):void 0}}function _nonIterableSpread$1$2(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _toConsumableArray$1$2(arr){return _arrayWithoutHoles$1$2(arr)||_iterableToArray$1$2(arr)||_unsupportedIterableToArray$1$2(arr)||_nonIterableSpread$1$2()}function _defineProperty$2$2(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function ownKeys$4$2(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread2$1$2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$4$2(Object(source),!0).forEach((function(key){_defineProperty$2$2(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$4$2(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}function _typeof$4(obj){return _typeof$4="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof$4(obj)}function _regeneratorRuntime$2(){
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
_regeneratorRuntime$2=function(){return exports};var exports={},Op=Object.prototype,hasOwn=Op.hasOwnProperty,$Symbol="function"==typeof Symbol?Symbol:{},iteratorSymbol=$Symbol.iterator||"@@iterator",asyncIteratorSymbol=$Symbol.asyncIterator||"@@asyncIterator",toStringTagSymbol=$Symbol.toStringTag||"@@toStringTag";function define(obj,key,value){return Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}),obj[key]}try{define({},"")}catch(err){define=function(obj,key,value){return obj[key]=value}}function wrap(innerFn,outerFn,self,tryLocsList){var protoGenerator=outerFn&&outerFn.prototype instanceof Generator?outerFn:Generator,generator=Object.create(protoGenerator.prototype),context=new Context(tryLocsList||[]);return generator._invoke=function(innerFn,self,context){var state="suspendedStart";return function(method,arg){if("executing"===state)throw new Error("Generator is already running");if("completed"===state){if("throw"===method)throw arg;return doneResult()}for(context.method=method,context.arg=arg;;){var delegate=context.delegate;if(delegate){var delegateResult=maybeInvokeDelegate(delegate,context);if(delegateResult){if(delegateResult===ContinueSentinel)continue;return delegateResult}}if("next"===context.method)context.sent=context._sent=context.arg;else if("throw"===context.method){if("suspendedStart"===state)throw state="completed",context.arg;context.dispatchException(context.arg)}else"return"===context.method&&context.abrupt("return",context.arg);state="executing";var record=tryCatch(innerFn,self,context);if("normal"===record.type){if(state=context.done?"completed":"suspendedYield",record.arg===ContinueSentinel)continue;return{value:record.arg,done:context.done}}"throw"===record.type&&(state="completed",context.method="throw",context.arg=record.arg)}}}(innerFn,self,context),generator}function tryCatch(fn,obj,arg){try{return{type:"normal",arg:fn.call(obj,arg)}}catch(err){return{type:"throw",arg:err}}}exports.wrap=wrap;var ContinueSentinel={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var IteratorPrototype={};define(IteratorPrototype,iteratorSymbol,(function(){return this}));var getProto=Object.getPrototypeOf,NativeIteratorPrototype=getProto&&getProto(getProto(values([])));NativeIteratorPrototype&&NativeIteratorPrototype!==Op&&hasOwn.call(NativeIteratorPrototype,iteratorSymbol)&&(IteratorPrototype=NativeIteratorPrototype);var Gp=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(IteratorPrototype);function defineIteratorMethods(prototype){["next","throw","return"].forEach((function(method){define(prototype,method,(function(arg){return this._invoke(method,arg)}))}))}function AsyncIterator(generator,PromiseImpl){function invoke(method,arg,resolve,reject){var record=tryCatch(generator[method],generator,arg);if("throw"!==record.type){var result=record.arg,value=result.value;return value&&"object"==_typeof$4(value)&&hasOwn.call(value,"__await")?PromiseImpl.resolve(value.__await).then((function(value){invoke("next",value,resolve,reject)}),(function(err){invoke("throw",err,resolve,reject)})):PromiseImpl.resolve(value).then((function(unwrapped){result.value=unwrapped,resolve(result)}),(function(error){return invoke("throw",error,resolve,reject)}))}reject(record.arg)}var previousPromise;this._invoke=function(method,arg){function callInvokeWithMethodAndArg(){return new PromiseImpl((function(resolve,reject){invoke(method,arg,resolve,reject)}))}return previousPromise=previousPromise?previousPromise.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}}function maybeInvokeDelegate(delegate,context){var method=delegate.iterator[context.method];if(void 0===method){if(context.delegate=null,"throw"===context.method){if(delegate.iterator["return"]&&(context.method="return",context.arg=void 0,maybeInvokeDelegate(delegate,context),"throw"===context.method))return ContinueSentinel;context.method="throw",context.arg=new TypeError("The iterator does not provide a 'throw' method")}return ContinueSentinel}var record=tryCatch(method,delegate.iterator,context.arg);if("throw"===record.type)return context.method="throw",context.arg=record.arg,context.delegate=null,ContinueSentinel;var info=record.arg;return info?info.done?(context[delegate.resultName]=info.value,context.next=delegate.nextLoc,"return"!==context.method&&(context.method="next",context.arg=void 0),context.delegate=null,ContinueSentinel):info:(context.method="throw",context.arg=new TypeError("iterator result is not an object"),context.delegate=null,ContinueSentinel)}function pushTryEntry(locs){var entry={tryLoc:locs[0]};1 in locs&&(entry.catchLoc=locs[1]),2 in locs&&(entry.finallyLoc=locs[2],entry.afterLoc=locs[3]),this.tryEntries.push(entry)}function resetTryEntry(entry){var record=entry.completion||{};record.type="normal",delete record.arg,entry.completion=record}function Context(tryLocsList){this.tryEntries=[{tryLoc:"root"}],tryLocsList.forEach(pushTryEntry,this),this.reset(!0)}function values(iterable){if(iterable){var iteratorMethod=iterable[iteratorSymbol];if(iteratorMethod)return iteratorMethod.call(iterable);if("function"==typeof iterable.next)return iterable;if(!isNaN(iterable.length)){var i=-1,next=function next(){for(;++i<iterable.length;)if(hasOwn.call(iterable,i))return next.value=iterable[i],next.done=!1,next;return next.value=void 0,next.done=!0,next};return next.next=next}}return{next:doneResult}}function doneResult(){return{value:void 0,done:!0}}return GeneratorFunction.prototype=GeneratorFunctionPrototype,define(Gp,"constructor",GeneratorFunctionPrototype),define(GeneratorFunctionPrototype,"constructor",GeneratorFunction),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,toStringTagSymbol,"GeneratorFunction"),exports.isGeneratorFunction=function(genFun){var ctor="function"==typeof genFun&&genFun.constructor;return!!ctor&&(ctor===GeneratorFunction||"GeneratorFunction"===(ctor.displayName||ctor.name))},exports.mark=function(genFun){return Object.setPrototypeOf?Object.setPrototypeOf(genFun,GeneratorFunctionPrototype):(genFun.__proto__=GeneratorFunctionPrototype,define(genFun,toStringTagSymbol,"GeneratorFunction")),genFun.prototype=Object.create(Gp),genFun},exports.awrap=function(arg){return{__await:arg}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,asyncIteratorSymbol,(function(){return this})),exports.AsyncIterator=AsyncIterator,exports.async=function(innerFn,outerFn,self,tryLocsList,PromiseImpl){void 0===PromiseImpl&&(PromiseImpl=Promise);var iter=new AsyncIterator(wrap(innerFn,outerFn,self,tryLocsList),PromiseImpl);return exports.isGeneratorFunction(outerFn)?iter:iter.next().then((function(result){return result.done?result.value:iter.next()}))},defineIteratorMethods(Gp),define(Gp,toStringTagSymbol,"Generator"),define(Gp,iteratorSymbol,(function(){return this})),define(Gp,"toString",(function(){return"[object Generator]"})),exports.keys=function(object){var keys=[];for(var key in object)keys.push(key);return keys.reverse(),function next(){for(;keys.length;){var key=keys.pop();if(key in object)return next.value=key,next.done=!1,next}return next.done=!0,next}},exports.values=values,Context.prototype={constructor:Context,reset:function(skipTempReset){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(resetTryEntry),!skipTempReset)for(var name in this)"t"===name.charAt(0)&&hasOwn.call(this,name)&&!isNaN(+name.slice(1))&&(this[name]=void 0)},stop:function(){this.done=!0;var rootRecord=this.tryEntries[0].completion;if("throw"===rootRecord.type)throw rootRecord.arg;return this.rval},dispatchException:function(exception){if(this.done)throw exception;var context=this;function handle(loc,caught){return record.type="throw",record.arg=exception,context.next=loc,caught&&(context.method="next",context.arg=void 0),!!caught}for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i],record=entry.completion;if("root"===entry.tryLoc)return handle("end");if(entry.tryLoc<=this.prev){var hasCatch=hasOwn.call(entry,"catchLoc"),hasFinally=hasOwn.call(entry,"finallyLoc");if(hasCatch&&hasFinally){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0);if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc)}else if(hasCatch){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0)}else{if(!hasFinally)throw new Error("try statement without catch or finally");if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc)}}}},abrupt:function(type,arg){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc<=this.prev&&hasOwn.call(entry,"finallyLoc")&&this.prev<entry.finallyLoc){var finallyEntry=entry;break}}finallyEntry&&("break"===type||"continue"===type)&&finallyEntry.tryLoc<=arg&&arg<=finallyEntry.finallyLoc&&(finallyEntry=null);var record=finallyEntry?finallyEntry.completion:{};return record.type=type,record.arg=arg,finallyEntry?(this.method="next",this.next=finallyEntry.finallyLoc,ContinueSentinel):this.complete(record)},complete:function(record,afterLoc){if("throw"===record.type)throw record.arg;return"break"===record.type||"continue"===record.type?this.next=record.arg:"return"===record.type?(this.rval=this.arg=record.arg,this.method="return",this.next="end"):"normal"===record.type&&afterLoc&&(this.next=afterLoc),ContinueSentinel},finish:function(finallyLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.finallyLoc===finallyLoc)return this.complete(entry.completion,entry.afterLoc),resetTryEntry(entry),ContinueSentinel}},catch:function(tryLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc===tryLoc){var record=entry.completion;if("throw"===record.type){var thrown=record.arg;resetTryEntry(entry)}return thrown}}throw new Error("illegal catch attempt")},delegateYield:function(iterable,resultName,nextLoc){return this.delegate={iterator:values(iterable),resultName:resultName,nextLoc:nextLoc},"next"===this.method&&(this.arg=void 0),ContinueSentinel}},exports}function asyncGeneratorStep$2(gen,resolve,reject,_next,_throw,key,arg){try{var info=gen[key](arg),value=info.value}catch(error){return void reject(error)}info.done?resolve(value):Promise.resolve(value).then(_next,_throw)}function _asyncToGenerator$2(fn){return function(){var self=this,args=arguments;return new Promise((function(resolve,reject){var gen=fn.apply(self,args);function _next(value){asyncGeneratorStep$2(gen,resolve,reject,_next,_throw,"next",value)}function _throw(err){asyncGeneratorStep$2(gen,resolve,reject,_next,_throw,"throw",err)}_next(void 0)}))}}function _arrayWithHoles$2(arr){if(Array.isArray(arr))return arr}function _iterableToArrayLimit$2(arr,i){var _i=null==arr?null:"undefined"!==typeof Symbol&&arr[Symbol.iterator]||arr["@@iterator"];if(null!=_i){var _s,_e,_arr=[],_n=!0,_d=!1;try{for(_i=_i.call(arr);!(_n=(_s=_i.next()).done);_n=!0)if(_arr.push(_s.value),i&&_arr.length===i)break}catch(err){_d=!0,_e=err}finally{try{_n||null==_i["return"]||_i["return"]()}finally{if(_d)throw _e}}return _arr}}function _nonIterableRest$2(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _slicedToArray$2(arr,i){return _arrayWithHoles$2(arr)||_iterableToArrayLimit$2(arr,i)||_unsupportedIterableToArray$1$2(arr,i)||_nonIterableRest$2()}"undefined"!==typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto);var isLookupTypeField$2=function(field){var _ref=field||{},displayType=_ref.displayType;return["LOOKUP_SIMPLE","MULTI_LOOKUP_SIMPLE"].includes(displayType)},isLookupPopupField$2=function(field){var _ref2=field||{},displayType=_ref2.displayType;return["LOOKUP_POPUP"].includes(displayType)},isLookupField$2=function(field){var _ref5=field||{},displayType=_ref5.displayType;return["LOOKUP_SIMPLE"].includes(displayType)},isMultiLookupField$2=function(field){var _ref6=field||{},displayType=_ref6.displayType;return["MULTI_LOOKUP_SIMPLE"].includes(displayType)},isDateTypeField$2=function(field){var _ref7=field||{},displayType=_ref7.displayType;return["DATETIME","DATE"].includes(displayType)},FIELD_VALUE_HASH$2={lookup:function(_ref){var _this=this,field=_ref.field,h=this.$createElement;return h("div",{class:"w-full"},[h(__vue_component__$h,{class:"width-full",key:"".concat(field.name," Value"),attrs:{field:field,hideLookupIcon:this.canHidePopupIcon,hideDropDown:this.hideDropDown,disabled:this.disableValueContainer,customOptions:this.getCustomOption()},on:_objectSpread2$1$2(_objectSpread2$1$2({},{input:function(val){return _this.$set(_this,"fieldValue",isEmpty$8(val)?null:val)}}),{},{showLookupWizard:this.showLookupWizard}),model:{value:_this.fieldValue,callback:function($$v){_this.fieldValue=$$v}}}),this.canShowLookupWizard&&h(__vue_component__$6$2,{attrs:{canShowLookupWizard:this.canShowLookupWizard,field:field},on:_objectSpread2$1$2({},{"update:canShowLookupWizard":function(val){return _this.canShowLookupWizard=val},setLookupFieldValue:this.setLookupFieldValue})})])},select:function(_ref2){var _this2=this,field=_ref2.field,isMultiple=_ref2.isMultiple,h=this.$createElement;return h(__vue_component__$g,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:isMultiple,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:field.options},model:{value:_this2.fieldValue,callback:function($$v){_this2.fieldValue=$$v}}})},input:function(){var _this3=this,_ref3=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},_ref3$type=_ref3.type,type=void 0===_ref3$type?"":_ref3$type,h=this.$createElement;return h(__vue_component__$j,{class:"w-full",attrs:{placeholder:"Enter a value",type:type,disabled:this.disableValueContainer},model:{value:_this3.fieldValue,callback:function($$v){_this3.fieldValue=$$v}}})},date:function(_ref4){var _this4=this,type=_ref4.type,hasTime=_ref4.hasTime,h=this.$createElement;return h(__vue_component__$5$2,{class:"w-full",attrs:{type:type,disabled:this.disableValueContainer,placeholder:"Select a date ".concat(hasTime?"time":""),account:this.account},model:{value:_this4.fieldValue,callback:function($$v){_this4.fieldValue=$$v}}})}},FIELD_DISPLAY_TYPE_HASH$2={NUMBER:function(){return this["input"]({type:"number"})},DECIMAL:function(){return this["input"]({type:"number"})},SELECTBOX:function(field){return this["select"]({field:field,isMultiple:!0})},MULTI_SELECTBOX:function(field){return this["select"]({field:field,isMultiple:!0})},DECISION_BOX:function(field){return this["select"]({field:field,isMultiple:!1})},DATE:function(){return this["date"]({type:"date"})},DATETIME:function(){return this["date"]({type:"datetime",hasTime:!0})},DURATION:function(){return this["input"]({type:"number"})},LOOKUP_SIMPLE:function(field){return this["lookup"]({field:field})},MULTI_LOOKUP_SIMPLE:function(field){return this["lookup"]({field:field})},LOOKUP_POPUP:function(field){return this["lookup"]({field:field})},DEFAULT:function(){return this["input"]()}},WEEK_DAYS_OPTIONS$2=[{label:"Monday",value:1},{label:"Tuesday",value:2},{label:"Wednesday",value:3},{label:"Thursday",value:4},{label:"Friday",value:5},{label:"Saturday",value:6},{label:"Sunday",value:7}],MONTH_OPTIONS$2=[{label:"January",value:1},{label:"February",value:2},{label:"March",value:3},{label:"April",value:4},{label:"May",value:5},{label:"June",value:6},{label:"July",value:7},{label:"August",value:8},{label:"September",value:9},{label:"October",value:10},{label:"November",value:11},{label:"December",value:12}],dateTimeOperator$2={84:"Month",85:"Day of Week",101:"Day of Month",102:"Day of Year",103:"Hours of Day",106:"Before N Days",107:"After N Days",108:"Week of Year"},WEEK_DAYS$2={1:"Monday",2:"Tuesday",3:"Wednesday",4:"Thursday",5:"Friday",6:"Saturday",7:"Sunday"},MONTHS$2=[{label:"January",value:1},{label:"February",value:2},{label:"March",value:3},{label:"April",value:4},{label:"May",value:5},{label:"June",value:6},{label:"July",value:7},{label:"August",value:8},{label:"September",value:9},{label:"October",value:10},{label:"November",value:11},{label:"December",value:12}],ordinalSuffixOf$2=function(day){var j=day%10,k=day%100;return"".concat(day,1==j&&11!=k?"st":2==j&&12!=k?"nd":3==j&&13!=k?"rd":"th")},SPECIAL_VALUE_HASH$2={SPECIAL_20:function(field){var _this=this,h=this.$createElement,_ref=field||{},_ref$displayType=_ref.displayType,displayType=void 0===_ref$displayType?"":_ref$displayType,hasTime="DATETIME"===displayType,type=displayType.toLowerCase();return h(__vue_component__$5$2,{class:"w-full",attrs:{type:"".concat(type,"range"),disabled:this.disableValueContainer,placeholder:"Select a date ".concat(hasTime?"time":""),account:this.account},model:{value:_this.fieldValue,callback:function($$v){_this.fieldValue=$$v}}})},SPECIAL_81:function(){var h=this.$createElement;
// Number - between
return h("div",{class:"flex w-full"},[h(__vue_component__$j,{class:"flex flex-grow pr-1",attrs:{type:"number",placeholder:"Enter start value"}}),h(__vue_component__$j,{class:"flex flex-grow pl-1",attrs:{type:"number",placeholder:"Enter end value"}})])},SPECIAL_84:function(field){var _this2=this,h=this.$createElement;
// Month
return h(__vue_component__$g,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:MONTH_OPTIONS$2},model:{value:_this2.fieldValue,callback:function($$v){_this2.fieldValue=$$v}}})},SPECIAL_85:function(field){var _this3=this,h=this.$createElement;
// Date - day of week
return h(__vue_component__$g,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:WEEK_DAYS_OPTIONS$2},model:{value:_this3.fieldValue,callback:function($$v){_this3.fieldValue=$$v}}})},SPECIAL_101:function(field){var _this4=this,h=this.$createElement,options=Array(30).fill().map((function(_,index){return{label:"".concat(ordinalSuffixOf$2(index+1)," day"),value:index+1}}));return h(__vue_component__$g,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:options},model:{value:_this4.fieldValue,callback:function($$v){_this4.fieldValue=$$v}}})},SPECIAL_103:function(field){var _this5=this,h=this.$createElement,options=Array(24).fill().map((function(_,index){return{label:"".concat(index+1," hour").concat(index>0?"s":""),value:index+1}}));return h(__vue_component__$g,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:options},model:{value:_this5.fieldValue,callback:function($$v){_this5.fieldValue=$$v}}})},SPECIAL_106:function(){var _this6=this,h=this.$createElement;
// Date - n days
return h(__vue_component__$j,{class:"flex flex-grow pr-1 w-full",attrs:{type:"number",placeholder:"Enter number of days"},model:{value:_this6.fieldValue,callback:function($$v){_this6.fieldValue=$$v}}})},SPECIAL_108:function(field){var _this7=this,h=this.$createElement,options=Array(52).fill().map((function(_,index){return{label:"".concat(index+1," week").concat(index>0?"s":""),value:index+1}}));return h(__vue_component__$g,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:options},model:{value:_this7.fieldValue,callback:function($$v){_this7.fieldValue=$$v}}})}},SPECIAL_OPERATOR_HASH$2={DATETIME_20:function(field){return this["SPECIAL_20"](field)},DATETIME_84:function(field){return this["SPECIAL_84"](field)},DATETIME_85:function(field){return this["SPECIAL_85"](field)},DATETIME_101:function(field){return this["SPECIAL_101"](field)},DATETIME_103:function(field){return this["SPECIAL_103"](field)},DATETIME_106:function(field){return this["SPECIAL_106"](field)},DATETIME_107:function(field){return this["SPECIAL_106"](field)},DATETIME_108:function(field){return this["SPECIAL_108"](field)},DATE_20:function(field){return this["SPECIAL_20"](field)},DATE_84:function(field){return this["SPECIAL_84"](field)},DATE_85:function(field){return this["SPECIAL_85"](field)},DATE_101:function(field){return this["SPECIAL_101"](field)},DATE_103:function(field){return this["SPECIAL_103"](field)},DATE_106:function(field){return this["SPECIAL_106"](field)},DATE_107:function(field){return this["SPECIAL_106"](field)},DATE_108:function(field){return this["SPECIAL_108"](field)},NUMBER_81:function(){return this["SPECIAL_81"]()},NUMBER_82:function(){return this["SPECIAL_81"]()}},LOOKUP_FIELD_PLACEHOLDER_MAP$2={people:{value:"${LOGGED_PEOPLE}",label:"Current User"},users:{value:"${LOGGED_USER}",label:"Current User"},tenant:{value:"${LOGGED_TENANT}",label:"Current Tenant"},vendors:{value:"${LOGGED_VENDOR}",label:"Current vendor"}},script$a$2={name:"ConditionValue",props:["field","disableValueContainer","account","isSpecialOperator","operatorObj"],data:function(){return{canShowLookupWizard:!1}},computed:{fieldValue:{get:function(){var _ref=this||{},$attrs=_ref.$attrs,field=_ref.field,operatorObj=_ref.operatorObj,_ref2=$attrs||{},value=_ref2.value,_ref3=operatorObj||{},operatorId=_ref3.operatorId,_ref4=field||{},displayType=_ref4.displayType;return"DATETIME"!==displayType&&"DATE"!==displayType||20!==operatorId?value:this.serializeDateValues(value)},set:function(value){this.$emit("input",value)}},
// lookup properties
canHidePopupIcon:function(){var field=this.field,_ref5=field||{},lookupModule=_ref5.lookupModule,_ref6=lookupModule||{},_ref6$showPopup=_ref6.showPopup,showPopup=void 0===_ref6$showPopup||_ref6$showPopup;return!showPopup},hideDropDown:function(){
// Have to hide dropdown for resource type fields
var field=this.field,name=field.name;return"resource"===name}},methods:_objectSpread2$1$2(_objectSpread2$1$2(_objectSpread2$1$2(_objectSpread2$1$2({serializeDateValues:function(value){var dateArray=String(value).split(","),dates=dateArray.map((function(date){return parseInt(date)}));return dates},getFieldValueDisplay:function(){var field=this.field,isSpecialOperator=this.isSpecialOperator,operatorObj=this.operatorObj,fieldObj=field.field||field,_ref7=fieldObj||{},displayType=_ref7.displayType,_ref8=operatorObj||{},operatorId=_ref8.operatorId,specialHashKey="".concat(displayType,"_").concat(operatorId);return isSpecialOperator&&!isEmpty$8(SPECIAL_OPERATOR_HASH$2[specialHashKey])?this[specialHashKey](field):isEmpty$8(FIELD_DISPLAY_TYPE_HASH$2[displayType])?this["DEFAULT"](field):this[displayType](field)},getCustomOption:function(){var _ref9=this||{},field=_ref9.field,_ref10=field||{},lookupModule=_ref10.lookupModule;if(isEmpty$8(lookupModule))return[];var _ref11=lookupModule||{},name=_ref11.name;return isEmpty$8(LOOKUP_FIELD_PLACEHOLDER_MAP$2[name])?[]:[LOOKUP_FIELD_PLACEHOLDER_MAP$2[name]]},resetValue:function(){this.$set(this,"fieldValue",null)},
// lookup methods
showLookupWizard:function(){this.canShowLookupWizard=!0},setLookupFieldValue:function(props){var selectedLookupField=this.field,field=props.field;isEmpty$8(selectedLookupField)&&(this.selectedLookupField=field);var _ref12=field||{},selectedItems=_ref12.selectedItems,_ref12$options=_ref12.options,options=void 0===_ref12$options?[]:_ref12$options,multiple=_ref12.multiple,selectedItemIds=[];if(!isEmpty$8(selectedItems))if(selectedItemIds=selectedItems.map((function(item){return item.value})),isEmpty$8(options))options=_toConsumableArray$1$2(selectedItems);else{var _options,ids=options.map((function(item){return item.value})),newOptions=selectedItems.filter((function(item){return!ids.includes(item.value)}));(_options=options).unshift.apply(_options,_toConsumableArray$1$2(newOptions))}this.$set(this.field,"options",options),this.fieldValue=multiple?selectedItemIds:selectedItemIds[0]}},FIELD_VALUE_HASH$2),FIELD_DISPLAY_TYPE_HASH$2),SPECIAL_OPERATOR_HASH$2),SPECIAL_VALUE_HASH$2),render:function(){var h=arguments[0];return h("div",{class:"criteria-value-container ml-2 w-full flex items-center"},[this.getFieldValueDisplay()])}};function normalizeComponent$3$3(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);
// Vue.extend constructor export interop.
const options="function"===typeof script?script.options:script;
// render functions
let hook;if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,
// functional template
isFunctionalTemplate&&(options.functional=!0)),
// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),
// inject component styles
style&&style.call(this,createInjectorSSR(context)),
// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},
// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(context){style.call(this,createInjectorShadow(context,this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
const originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
const existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}
/* script */const __vue_script__$a$2=script$a$2,__vue_inject_styles__$a$2=void 0,__vue_scope_id__$a$2=void 0,__vue_module_identifier__$a$2=void 0,__vue_is_functional_template__$a$2=void 0,__vue_component__$a$2=normalizeComponent$3$3({},__vue_inject_styles__$a$2,__vue_script__$a$2,__vue_scope_id__$a$2,__vue_is_functional_template__$a$2,__vue_module_identifier__$a$2,!1,void 0,void 0,void 0),isOldIE$5="undefined"!==typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
/* template */
/* style */function createInjector$5(context){return(id,style)=>addStyle$8(id,style)}let HEAD$5;const styles$8={};function addStyle$8(id,css){const group=isOldIE$5?css.media||"default":id,style=styles$8[group]||(styles$8[group]={ids:new Set,styles:[]});if(!style.ids.has(id)){style.ids.add(id);let code=css.source;if(css.map&&(
// https://developer.chrome.com/devtools/docs/javascript-debugging
// this makes source maps inside style tags work properly in Chrome
code+="\n/*# sourceURL="+css.map.sources[0]+" */",
// http://stackoverflow.com/a/26603875
code+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(css.map))))+" */"),style.element||(style.element=document.createElement("style"),style.element.type="text/css",css.media&&style.element.setAttribute("media",css.media),void 0===HEAD$5&&(HEAD$5=document.head||document.getElementsByTagName("head")[0]),HEAD$5.appendChild(style.element)),"styleSheet"in style.element)style.styles.push(code),style.element.styleSheet.cssText=style.styles.filter(Boolean).join("\n");else{const index=style.ids.size-1,textNode=document.createTextNode(code),nodes=style.element.childNodes;nodes[index]&&style.element.removeChild(nodes[index]),nodes.length?style.element.insertBefore(textNode,nodes[index]):style.element.appendChild(textNode)}}}function styleInject$1$3(css,ref){void 0===ref&&(ref={});var insertAt=ref.insertAt;if(css&&"undefined"!==typeof document){var head=document.head||document.getElementsByTagName("head")[0],style=document.createElement("style");style.type="text/css","top"===insertAt&&head.firstChild?head.insertBefore(style,head.firstChild):head.appendChild(style),style.styleSheet?style.styleSheet.cssText=css:style.appendChild(document.createTextNode(css))}}var css_248z$1$3="*, ::before, ::after {\n  --tw-border-opacity: 1;\n  border-color: rgba(229, 231, 235, var(--tw-border-opacity))\n}\n\n.relative {\n  position: relative\n}\n\n.m-2 {\n  margin: 0.5rem\n}\n\n.mt-0 {\n  margin-top: 0px\n}\n\n.mt-5 {\n  margin-top: 1.25rem\n}\n\n.mt-0\\.5 {\n  margin-top: 0.125rem\n}\n\n.mr-2 {\n  margin-right: 0.5rem\n}\n\n.mb-2 {\n  margin-bottom: 0.5rem\n}\n\n.ml-1 {\n  margin-left: 0.25rem\n}\n\n.ml-2 {\n  margin-left: 0.5rem\n}\n\n.ml-3 {\n  margin-left: 0.75rem\n}\n\n.flex {\n  display: flex\n}\n\n.table {\n  display: table\n}\n\n.h-14 {\n  height: 3.5rem\n}\n\n.w-full {\n  width: 100%\n}\n\n.flex-grow {\n  flex-grow: 1\n}\n\n.transform {\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  transform: translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))\n}\n\n@-webkit-keyframes spin {\n  to {\n    transform: rotate(360deg)\n  }\n}\n\n@keyframes spin {\n  to {\n    transform: rotate(360deg)\n  }\n}\n\n@-webkit-keyframes ping {\n  75%, 100% {\n    transform: scale(2);\n    opacity: 0\n  }\n}\n\n@keyframes ping {\n  75%, 100% {\n    transform: scale(2);\n    opacity: 0\n  }\n}\n\n@-webkit-keyframes pulse {\n  50% {\n    opacity: .5\n  }\n}\n\n@keyframes pulse {\n  50% {\n    opacity: .5\n  }\n}\n\n@-webkit-keyframes bounce {\n  0%, 100% {\n    transform: translateY(-25%);\n    -webkit-animation-timing-function: cubic-bezier(0.8,0,1,1);\n            animation-timing-function: cubic-bezier(0.8,0,1,1)\n  }\n\n  50% {\n    transform: none;\n    -webkit-animation-timing-function: cubic-bezier(0,0,0.2,1);\n            animation-timing-function: cubic-bezier(0,0,0.2,1)\n  }\n}\n\n@keyframes bounce {\n  0%, 100% {\n    transform: translateY(-25%);\n    -webkit-animation-timing-function: cubic-bezier(0.8,0,1,1);\n            animation-timing-function: cubic-bezier(0.8,0,1,1)\n  }\n\n  50% {\n    transform: none;\n    -webkit-animation-timing-function: cubic-bezier(0,0,0.2,1);\n            animation-timing-function: cubic-bezier(0,0,0.2,1)\n  }\n}\n\n.cursor-pointer {\n  cursor: pointer\n}\n\n.cursor-not-allowed {\n  cursor: not-allowed\n}\n\n.flex-col {\n  flex-direction: column\n}\n\n.flex-wrap {\n  flex-wrap: wrap\n}\n\n.flex-nowrap {\n  flex-wrap: nowrap\n}\n\n.items-center {\n  align-items: center\n}\n\n.justify-center {\n  justify-content: center\n}\n\n.self-center {\n  align-self: center\n}\n\n.border {\n  border-width: 1px\n}\n\n.text-center {\n  text-align: center\n}\n\n.leading-5 {\n  line-height: 1.25rem\n}\n\n*, ::before, ::after {\n  --tw-shadow: 0 0 #0000\n}\n\n*, ::before, ::after {\n  --tw-ring-inset: var(--tw-empty,/*!*/ /*!*/);\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgba(59, 130, 246, 0.5);\n  --tw-ring-offset-shadow: 0 0 #0000;\n  --tw-ring-shadow: 0 0 #0000\n}\n\n.filter {\n  --tw-blur: var(--tw-empty,/*!*/ /*!*/);\n  --tw-brightness: var(--tw-empty,/*!*/ /*!*/);\n  --tw-contrast: var(--tw-empty,/*!*/ /*!*/);\n  --tw-grayscale: var(--tw-empty,/*!*/ /*!*/);\n  --tw-hue-rotate: var(--tw-empty,/*!*/ /*!*/);\n  --tw-invert: var(--tw-empty,/*!*/ /*!*/);\n  --tw-saturate: var(--tw-empty,/*!*/ /*!*/);\n  --tw-sepia: var(--tw-empty,/*!*/ /*!*/);\n  --tw-drop-shadow: var(--tw-empty,/*!*/ /*!*/);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)\n}\n\n.transition {\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms\n}\n\n.ease-in-out {\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1)\n}\n\n@media (min-width: 640px) {\n}\n\n@media (min-width: 768px) {\n}\n\n@media (min-width: 1024px) {\n}\n\n@media (min-width: 1280px) {\n}\n\n@media (min-width: 1536px) {\n}\n";styleInject$1$3(css_248z$1$3);var script$3$1$2={props:["field","operators","value","account"],components:{Select:__vue_component__$g,ConditionValue:__vue_component__$a$2},computed:{operatorId:{get:function(){var _this$value;return(null===(_this$value=this.value)||void 0===_this$value?void 0:_this$value.operatorId)||null},set:function(newVal){var value=this.value,updatedObj=_objectSpread2$1$2(_objectSpread2$1$2({},value),{},{operatorId:newVal});this.$emit("input",updatedObj),this.$emit("updateFilter",updatedObj)}},conditionValue:{get:function(){var _this$value2;return null===(_this$value2=this.value)||void 0===_this$value2?void 0:_this$value2.value},set:function(newVal){var inputValue=this.value,updatedObj=_objectSpread2$1$2(_objectSpread2$1$2({},inputValue),{},{value:newVal});this.$emit("input",updatedObj),this.$emit("updateFilter",updatedObj)}},errorText:function(){var field=this.field,_ref=field||{},displayName=_ref.displayName;return"Please input ".concat(displayName)},disableValueContainer:function(){var operatorId=this.operatorId,fieldOperators=this.fieldOperators,disabled=this.disabled,canDisable=!0,selectedOperator=fieldOperators.find((function(operator){return operator.id===operatorId}));return isEmpty$8(selectedOperator)||(canDisable=!(selectedOperator||{}).valueNeeded),canDisable||disabled},currentOperatorObj:function(){var _ref2=this||{},fieldOperators=_ref2.fieldOperators,operatorId=_ref2.operatorId,currentOperator=fieldOperators.find((function(operator){return operator.id===operatorId}));return currentOperator},isSpecialOperator:function(){var _ref3=this||{},currentOperatorObj=_ref3.currentOperatorObj,_ref4=currentOperatorObj||{},specialOperator=_ref4.specialOperator;return specialOperator},fieldOperators:function(){var operators=this.operators,filterOperators=this.filterOperators,field=this.field,_ref5=field||{},dataType=_ref5.dataType,fieldOperators=_ref5.operators;if(!isEmpty$8(operators)){var list=operators[dataType]||[];isEmpty$8(fieldOperators)||(list=list.concat(fieldOperators));var finalList=list.map((function(operator){var operatorId=operator.operatorId,defaultValue=operator.defaultValue,unqiueClientId=operatorId;return isEmpty$8(defaultValue)||(unqiueClientId="".concat(operatorId,"-").concat(defaultValue)),_objectSpread2$1$2(_objectSpread2$1$2({},operator),{},{id:unqiueClientId})}));// filter out special operator if special ui is not present
return finalList=finalList.filter((function(operator){var _ref6=operator||{},specialOperator=_ref6.specialOperator,operatorId=_ref6.id,_ref7=field||{},displayType=_ref7.displayType,specialHashPropName="".concat(displayType,"_").concat(operatorId);return!specialOperator||!isEmpty$8(SPECIAL_OPERATOR_HASH$2[specialHashPropName])})),!isEmpty$8(filterOperators)&&isFunction$6(filterOperators)&&(finalList=(finalList||[]).filter((function(operator){return filterOperators(operator,field)}))),finalList}return[]}},created:function(){this.init()},methods:{init:function(){var value=this.value,operatorId=value.operatorId,conditionValue=value.value;isEmpty$8(operatorId)||(this.operatorId=operatorId),isEmpty$8(conditionValue)||(this.conditionValue=conditionValue);var clonedCondition=cloneDeep(value);this.filterObj=clonedCondition},resetValue:function(){var ref=this.$refs.conditionValue;isEmpty$8(ref)||ref.resetValue()},validate:function(){var disableValueContainer=this.disableValueContainer,conditionValue=this.conditionValue,field=this.field,isValid=!0;return disableValueContainer||(isValid=!isEmpty$8(conditionValue)),this.$emit("isError",{field:field,isError:!isValid}),isValid}}};
/* script */const __vue_script__$3$1$2=script$3$1$2;
/* template */var __vue_render__$3$1$2=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"operator-value-container"},[_c("div",{staticClass:"criteria-operator-container"},[_c("Select",{staticClass:"width-full",attrs:{options:_vm.fieldOperators,labelName:"displayName",valueName:"id",filterable:!0,disabled:!1},on:{clear:_vm.resetValue},model:{value:_vm.operatorId,callback:function($$v){_vm.operatorId=$$v},expression:"operatorId"}})],1),_vm._v(" "),_c("div",{staticClass:"value-container",staticStyle:{display:"flex","flex-direction":"column"}},[_c("ConditionValue",{ref:"conditionValue",attrs:{account:_vm.account,field:_vm.field,operatorObj:_vm.currentOperatorObj,isSpecialOperator:_vm.isSpecialOperator,disableValueContainer:_vm.disableValueContainer},model:{value:_vm.conditionValue,callback:function($$v){_vm.conditionValue=$$v},expression:"conditionValue"}}),_vm._v(" "),_vm.field.isError?_c("div",{staticClass:"err-txt"},[_vm._v(_vm._s(_vm.errorText))]):_vm._e()],1)])},__vue_staticRenderFns__$3$1$2=[];
/* style */
const __vue_inject_styles__$3$1$2=function(inject){inject&&inject("data-v-77891a74_0",{source:".operator-value-container[data-v-77891a74]{display:flex;flex-wrap:nowrap}.operator-value-container .criteria-operator-container[data-v-77891a74]{flex:0 0 35%}.operator-value-container .value-container[data-v-77891a74]{flex-grow:1}.operator-value-container .value-container .err-txt[data-v-77891a74]{color:#f56c6c;font-size:12px;line-height:1;margin-top:4px;padding-left:8px}",map:void 0,media:void 0})},__vue_scope_id__$3$1$2="data-v-77891a74",__vue_module_identifier__$3$1$2=void 0,__vue_is_functional_template__$3$1$2=!1,__vue_component__$3$1$2=normalizeComponent$3$3({render:__vue_render__$3$1$2,staticRenderFns:__vue_staticRenderFns__$3$1$2},__vue_inject_styles__$3$1$2,__vue_script__$3$1$2,__vue_scope_id__$3$1$2,__vue_is_functional_template__$3$1$2,__vue_module_identifier__$3$1$2,!1,createInjector$5,void 0,void 0);
/* scoped */
var script$2$1$2={name:"spinner",props:["show","size","colour"],computed:{spinnerSize:function(){return this.size?this.size+"px":"50px"},strokeColor:function(){return this.colour?this.colour:"#fd4b92"}}};
/* script */const __vue_script__$2$1$2=script$2$1$2;
/* template */var __vue_render__$2$1$2=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("transition",[_c("svg",{directives:[{name:"show",rawName:"v-show",value:_vm.show,expression:"show"}],staticClass:"spinner",class:{show:_vm.show},attrs:{width:_vm.spinnerSize,height:_vm.spinnerSize,viewBox:"0 0 44 44"}},[_c("circle",{staticClass:"path",style:{stroke:_vm.strokeColor},attrs:{fill:"none","stroke-width":"4","stroke-linecap":"round",cx:"22",cy:"22",r:"20"}})])])},__vue_staticRenderFns__$2$1$2=[];
/* style */
const __vue_inject_styles__$2$1$2=function(inject){inject&&inject("data-v-688b5254_0",{source:".spinner[data-v-688b5254]{transition:opacity 50ms ease;animation:rotator-data-v-688b5254 1.4s linear infinite;animation-play-state:paused}.spinner.show[data-v-688b5254]{animation-play-state:running}.spinner.v-enter[data-v-688b5254],.spinner.v-leave-active[data-v-688b5254]{opacity:0}.spinner.v-enter-active[data-v-688b5254],.spinner.v-leave[data-v-688b5254]{opacity:1}.spinner .path[data-v-688b5254]{stroke-dasharray:126;stroke-dashoffset:0;transform-origin:center;animation:dash-data-v-688b5254 1.4s ease-in-out infinite}@-moz-keyframes rotator-data-v-688b5254{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-webkit-keyframes rotator-data-v-688b5254{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-o-keyframes rotator-data-v-688b5254{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@keyframes rotator-data-v-688b5254{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-moz-keyframes dash-data-v-688b5254{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@-webkit-keyframes dash-data-v-688b5254{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@-o-keyframes dash-data-v-688b5254{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@keyframes dash-data-v-688b5254{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}",map:void 0,media:void 0})},__vue_scope_id__$2$1$2="data-v-688b5254",__vue_module_identifier__$2$1$2=void 0,__vue_is_functional_template__$2$1$2=!1,__vue_component__$2$1$2=normalizeComponent$3$3({render:__vue_render__$2$1$2,staticRenderFns:__vue_staticRenderFns__$2$1$2},__vue_inject_styles__$2$1$2,__vue_script__$2$1$2,__vue_scope_id__$2$1$2,__vue_is_functional_template__$2$1$2,__vue_module_identifier__$2$1$2,!1,createInjector$5,void 0,void 0);
/* scoped */var script$1$1$2={components:{Checkbox:element_ui_common.Checkbox,OperatorValues:__vue_component__$3$1$2,Input:element_ui_common.Input,Button:element_ui_common.Button,Spinner:__vue_component__$2$1$2},props:["moduleName","searchParam","onSave","hideQuery","filterList","showAdvWizard"],data:function(){return{operators:[],fields:[],account:null,searchFilter:{},searchtext:"",filterObj:{},searchableFields:[],filtersFields:[],loading:!1}},created:function(){var _this=this;return _asyncToGenerator$2(_regeneratorRuntime$2().mark((function _callee(){return _regeneratorRuntime$2().wrap((function(_context){while(1)switch(_context.prev=_context.next){case 0:return _context.next=2,_this.init();case 2:case"end":return _context.stop()}}),_callee)})))()},computed:{filteredFields:function(){var searchtext=this.searchtext,searchableFields=this.searchableFields;return isEmpty$8(searchtext)?searchableFields:searchableFields.filter((function(field){var displayName=field.displayName,lowerCasedText=searchtext.toLowerCase(),canShow=displayName.toLowerCase().includes(lowerCasedText);return canShow}))},appliedFilters:function(){var searchParam=this.searchParam,hideQuery=this.hideQuery,filterList=this.filterList;return hideQuery?filterList:isEmpty$8(searchParam)?null:JSON.parse(searchParam)}},watch:{moduleName:function(){this.init()},filterList:function(){this.constructFilters()},showAdvWizard:function(){this.constructFilters()}},methods:{init:function(){var _this2=this;return _asyncToGenerator$2(_regeneratorRuntime$2().mark((function _callee2(){var _yield$Promise$all,_yield$Promise$all2,fields,account,operators;return _regeneratorRuntime$2().wrap((function(_context2){while(1)switch(_context2.prev=_context2.next){case 0:return _this2.loading=!0,_context2.next=3,Promise.all([_this2.loadFields(),_this2.fetchAccount(),_this2.loadOperators()]);case 3:_yield$Promise$all=_context2.sent,_yield$Promise$all2=_slicedToArray$2(_yield$Promise$all,3),fields=_yield$Promise$all2[0],account=_yield$Promise$all2[1],operators=_yield$Promise$all2[2],_this2.fields=fields,_this2.account=account,_this2.operators=operators,_this2.constructFilters(),_this2.loading=!1;case 13:case"end":return _context2.stop()}}),_callee2)})))()},fetchAccount:function(){var _this3=this;return _asyncToGenerator$2(_regeneratorRuntime$2().mark((function _callee3(){var _yield$API$get,data,error,_ref,account;return _regeneratorRuntime$2().wrap((function(_context3){while(1)switch(_context3.prev=_context3.next){case 0:return _context3.next=2,api/* API */.bl.get("/v2/fetchAccount");case 2:if(_yield$API$get=_context3.sent,data=_yield$API$get.data,error=_yield$API$get.error,!error){_context3.next=9;break}_this3.$message.error(error||"Error Occured"),_context3.next=11;break;case 9:return _ref=data||{},account=_ref.account,_context3.abrupt("return",account);case 11:case"end":return _context3.stop()}}),_callee3)})))()},loadOperators:function(){var _this4=this;return _asyncToGenerator$2(_regeneratorRuntime$2().mark((function _callee4(){var url,_yield$API$get2,data,error,_ref2,_ref2$message,message,_ref3,operators;return _regeneratorRuntime$2().wrap((function(_context4){while(1)switch(_context4.prev=_context4.next){case 0:return url="v2/filter/advanced/operators",_context4.next=3,api/* API */.bl.get(url);case 3:if(_yield$API$get2=_context4.sent,data=_yield$API$get2.data,error=_yield$API$get2.error,!error){_context4.next=11;break}_ref2=error||{},_ref2$message=_ref2.message,message=void 0===_ref2$message?"Error Occured":_ref2$message,_this4.$message.error(message),_context4.next=14;break;case 11:if(_ref3=data||{},operators=_ref3.operators,isEmpty$8(operators)){_context4.next=14;break}return _context4.abrupt("return",operators);case 14:case"end":return _context4.stop()}}),_callee4)})))()},loadFields:function(){var _this5=this;return _asyncToGenerator$2(_regeneratorRuntime$2().mark((function _callee5(){var moduleName,url,_yield$API$get3,data,error,_ref4,_ref4$message,message,_ref5,fields;return _regeneratorRuntime$2().wrap((function(_context5){while(1)switch(_context5.prev=_context5.next){case 0:return moduleName=_this5.moduleName,url="/v2/filter/advanced/fields/".concat(moduleName),_context5.next=4,api/* API */.bl.get(url);case 4:if(_yield$API$get3=_context5.sent,data=_yield$API$get3.data,error=_yield$API$get3.error,!error){_context5.next=12;break}_ref4=error||{},_ref4$message=_ref4.message,message=void 0===_ref4$message?"Error occured":_ref4$message,_this5.$message.error(message),_context5.next=14;break;case 12:return _ref5=data||{},fields=_ref5.fields,_context5.abrupt("return",fields.map((function(field){return isLookupPopupField$2(field)||isLookupTypeField$2(field)?_objectSpread2$1$2(_objectSpread2$1$2({},field),{},{multiple:!0,canShowCriteria:!1}):field})));case 14:case"end":return _context5.stop()}}),_callee5)})))()},setError:function(prop){var field=prop.field,isError=prop.isError;this.searchableFields=this.searchableFields.map((function(searchField){return searchField.name===field.name?_objectSpread2$1$2(_objectSpread2$1$2({},searchField),{},{isError:isError}):searchField}))},updateFilter:function(updatedField,filter){this.filtersFields=this.filtersFields.map((function(field){return field.name===updatedField.name?_objectSpread2$1$2(_objectSpread2$1$2({},field),{},{filterObj:filter}):field}))},removeAddFilter:function(checked,updatedField){checked||(this.filtersFields=this.filtersFields.map((function(field){return field.name===updatedField.name?_objectSpread2$1$2(_objectSpread2$1$2({},field),{},{filterObj:{}}):field})))},constructFilters:function(){var appliedFilters=this.appliedFilters,fields=this.fields,deserializedFields=fields.map((function(field){var clonedField=JSON.parse(JSON.stringify(field)),isMultiSupported=isLookupField$2(field)||isLookupPopupField$2(field)||isMultiLookupField$2(field);// Have to open multi support
if(isMultiSupported&&(
// To allow user to pick multiple values
clonedField.multiple=!0),isEmpty$8(appliedFilters))clonedField.canShowCriteria=!1,clonedField.filterObj={};else{var name=clonedField.name,filter=appliedFilters[name];if(clonedField.canShowCriteria=!1,!isEmpty$8(filter)){var _filter$value;if(clonedField.filterObj={},clonedField.filterObj=filter,!isMultiSupported)clonedField.filterObj=_objectSpread2$1$2(_objectSpread2$1$2({},filter),{},{value:null===filter||void 0===filter||null===(_filter$value=filter.value)||void 0===_filter$value?void 0:_filter$value.toString()});clonedField.canShowCriteria=!0}}return clonedField}));this.searchableFields=deserializedFields||[],this.filtersFields=JSON.parse(JSON.stringify(deserializedFields))},applyFilter:function(){var filtersFields=this.filtersFields,$refs=this.$refs,filters={},isNotValid=!1;filtersFields.forEach((function(field){var sanitizedObj,filterObj=field.filterObj,name=field.name,_ref6=$refs["".concat(name)]||[],_ref7=_slicedToArray$2(_ref6,1),criteriaComp=_ref7[0];if(isEmpty$8(criteriaComp)||(isNotValid=!criteriaComp.validate()||isNotValid),!isEmpty$8(filterObj)){var filterValue,_filterObj$value=filterObj.value,value=void 0===_filterObj$value?{}:_filterObj$value;if(isEmpty$8(value)?sanitizedObj=_objectSpread2$1$2({},filterObj):(filterValue=isArray$2(value)?value.map(String):[value],sanitizedObj=_objectSpread2$1$2(_objectSpread2$1$2({},filterObj),{},{value:filterValue})),!isEmpty$8(filterObj)){var _ref8=filterObj||{},operatorId=_ref8.operatorId;isEmpty$8(operatorId)||(filters=_objectSpread2$1$2(_objectSpread2$1$2({},filters),{},_defineProperty$2$2({},name,sanitizedObj)))}}})),isNotValid||this.$emit("applyFilters",filters)}}};
/* script */const __vue_script__$1$1$2=script$1$1$2;
/* template */var __vue_render__$1$1$2=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _vm.loading?_c("div",{staticClass:"loading-container"},[_c("Spinner",{attrs:{show:_vm.loading,size:60}})],1):_c("div",{staticClass:"f-advanced-search-container"},[_c("div",{staticClass:"f-dialog-search-container",staticStyle:{margin:"8px 0"}},[_c("Input",{staticClass:"f-search-box",attrs:{type:"search",autofocus:!1,placeholder:"Search Fields","prefix-icon":"el-icon-search"},model:{value:_vm.searchtext,callback:function($$v){_vm.searchtext=$$v},expression:"searchtext"}})],1),_vm._v(" "),_c("div",{staticClass:"f-field-container",staticStyle:{margin:"8px"}},_vm._l(_vm.filteredFields,(function(field,index){return _c("div",{key:index,staticClass:"field-item"},[_c("div",{staticClass:"field-label"},[_c("Checkbox",{on:{change:function(checked){return _vm.removeAddFilter(checked,field)}},model:{value:field.canShowCriteria,callback:function($$v){_vm.$set(field,"canShowCriteria",$$v)},expression:"field.canShowCriteria"}},[_c("div",{staticClass:"name"},[_vm._v(_vm._s(field.displayName))])]),_vm._v(" "),field.canShowCriteria?_c("div",{staticClass:"field-search-criteria"},[_c("OperatorValues",{ref:""+field.name,refInFor:!0,attrs:{field:field,operators:_vm.operators,account:_vm.account},on:{updateFilter:function(filter){return _vm.updateFilter(field,filter)},isError:_vm.setError},model:{value:field.filterObj,callback:function($$v){_vm.$set(field,"filterObj",$$v)},expression:"field.filterObj"}})],1):_vm._e()],1)])})),0),_vm._v(" "),_c("div",{staticClass:"btn-container"},[_c("Button",{staticClass:"form-btn f13 bold secondary text-center text-uppercase",on:{click:function($event){return _vm.$emit("closeDialog")}}},[_vm._v("Cancel")]),_vm._v(" "),_c("Button",{staticClass:"form-btn f13 bold primary m0 text-center text-uppercase",attrs:{type:"primary"},on:{click:function($event){return _vm.applyFilter()}}},[_vm._v("\n      Apply\n    ")])],1)])},__vue_staticRenderFns__$1$1$2=[];
/* style */
const __vue_inject_styles__$1$1$2=function(inject){inject&&inject("data-v-38859fba_0",{source:".loading-container{display:flex;justify-content:center;align-items:center;height:100px}.f-advanced-search-container{width:100%;height:100%;display:flex;flex-direction:column;flex-wrap:nowrap}.f-advanced-search-container .f-dialog-search-container .f-search-box .el-input__inner{height:40px;border-radius:0;padding:15px 40px!important;font-size:14px;letter-spacing:.4px;color:#324056;text-overflow:ellipsis;white-space:nowrap;background:#fff!important;width:100%!important;outline:0;border:1px solid #dcdfe6}.f-advanced-search-container .f-dialog-search-container .f-search-box .el-input__prefix{left:15px}.f-advanced-search-container .f-dialog-search-container .f-search-box .el-input__prefix .el-input__icon{line-height:28px!important}.f-advanced-search-container .f-field-container{overflow:scroll;height:90%!important;margin:8px 0;padding:0 8px}.f-advanced-search-container .f-field-container .field-search-criteria{margin:8px 0}.f-advanced-search-container .f-field-container .field-item{margin-bottom:25px}.f-advanced-search-container .f-field-container .field-item .field-label{display:flex;margin-bottom:10px;flex-direction:column;padding:0 4px}.f-advanced-search-container .f-field-container .field-item .field-label .el-checkbox{display:flex;cursor:pointer!important}.f-advanced-search-container .f-field-container .field-item .field-label .name{padding-left:15px;font-size:14px;letter-spacing:.5px;color:#324056}.f-advanced-search-container .btn-container{display:flex}.f-advanced-search-container .btn-container .form-btn{flex:1 1 100%;padding-top:20px;padding-bottom:20px;border:none;letter-spacing:1.1px;text-align:center;text-transform:uppercase}.f-advanced-search-container .btn-container .form-btn.primary{background-color:#39b2c2;color:#fff;border-radius:0}.f-advanced-search-container .btn-container .form-btn.secondary{background-color:#f4f4f4;color:#8f8f8f}",map:void 0,media:void 0})},__vue_scope_id__$1$1$2=void 0,__vue_module_identifier__$1$1$2=void 0,__vue_is_functional_template__$1$1$2=!1,__vue_component__$1$1$2=normalizeComponent$3$3({render:__vue_render__$1$1$2,staticRenderFns:__vue_staticRenderFns__$1$1$2},__vue_inject_styles__$1$1$2,__vue_script__$1$1$2,__vue_scope_id__$1$1$2,__vue_is_functional_template__$1$1$2,__vue_module_identifier__$1$1$2,!1,createInjector$5,void 0,void 0);
/* scoped */var CloseIcon$2={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{viewBox:"0 0 512 512",xmlns:"http://www.w3.org/2000/svg"}},[_c("path",{attrs:{d:"M309.582 257.554l185.1-188.733c14.782-15.057 14.782-39.478 0-54.534-14.767-15.072-38.702-15.072-53.484 0l-185.1 188.733L70.98 14.286c-14.75-15.073-38.718-15.073-53.484 0-14.767 15.057-14.767 39.478 0 54.534l185.116 188.734L17.088 446.721c-14.782 15.072-14.782 39.478 0 54.534 7.383 7.544 17.066 11.308 26.75 11.308 9.667 0 19.35-3.764 26.735-11.308L256.097 312.09l185.101 188.735c7.4 7.528 17.067 11.308 26.75 11.308 9.668 0 19.351-3.78 26.735-11.308 14.782-15.057 14.782-39.462 0-54.534l-185.1-188.736z"}})])}},script$8$3=_objectSpread2$1$2(_objectSpread2$1$2({components:{CloseIcon:CloseIcon$2,Tooltip:element_ui_common.Tooltip,Dropdown:element_ui_common.Dropdown,DropdownMenu:element_ui_common.DropdownMenu,DropdownItem:element_ui_common.DropdownItem},props:["moduleName","searchParam","filters","hideQuery","hideSaveAs"],computed:{checkDropDownExists:function(){var dropDownTags=this.dropDownTags;return!isEmpty$8(dropDownTags)},showTags:function(){var tagsArr=this.tagsArr;return!isEmpty$8(tagsArr)},firstThreeTags:function(){var tagsArr=this.tagsArr;return tagsArr.slice(0,3)},dropDownTags:function(){var tagsArr=this.tagsArr;return tagsArr.slice(3)},appliedFilters:function(){var searchParam=this.searchParam,hideQuery=this.hideQuery,filters=this.filters;return hideQuery?filters:isEmpty$8(searchParam)?null:JSON.parse(searchParam)}},watch:{appliedFilters:function(){this.constructTags()}},data:function(){return{tagsArr:[],fields:[],account:null,operatorsList:[]}},created:function(){var _this=this;return _asyncToGenerator$2(_regeneratorRuntime$2().mark((function _callee(){return _regeneratorRuntime$2().wrap((function(_context){while(1)switch(_context.prev=_context.next){case 0:_this.init();case 1:case"end":return _context.stop()}}),_callee)})))()},methods:{init:function(){var _this2=this;return _asyncToGenerator$2(_regeneratorRuntime$2().mark((function _callee2(){var _yield$Promise$all,_yield$Promise$all2,fields,account,operators;return _regeneratorRuntime$2().wrap((function(_context2){while(1)switch(_context2.prev=_context2.next){case 0:return _context2.next=2,Promise.all([_this2.loadFields(),_this2.fetchAccount(),_this2.loadOperators()]);case 2:_yield$Promise$all=_context2.sent,_yield$Promise$all2=_slicedToArray$2(_yield$Promise$all,3),fields=_yield$Promise$all2[0],account=_yield$Promise$all2[1],operators=_yield$Promise$all2[2],_this2.fields=fields,_this2.account=account,_this2.operatorsList=operators,_this2.constructTags();case 11:case"end":return _context2.stop()}}),_callee2)})))()},loadFields:function(){var _this3=this;return _asyncToGenerator$2(_regeneratorRuntime$2().mark((function _callee3(){var moduleName,url,_yield$API$get,data,error,_ref,_ref$message,message,_ref2,fields;return _regeneratorRuntime$2().wrap((function(_context3){while(1)switch(_context3.prev=_context3.next){case 0:return moduleName=_this3.moduleName,url="/v2/filter/advanced/fields/".concat(moduleName),_context3.next=4,api/* API */.bl.get(url);case 4:if(_yield$API$get=_context3.sent,data=_yield$API$get.data,error=_yield$API$get.error,!error){_context3.next=12;break}_ref=error||{},_ref$message=_ref.message,message=void 0===_ref$message?"Error occured":_ref$message,_this3.$message.error(message),_context3.next=14;break;case 12:return _ref2=data||{},fields=_ref2.fields,_context3.abrupt("return",fields);case 14:case"end":return _context3.stop()}}),_callee3)})))()},fetchAccount:function(){var _this4=this;return _asyncToGenerator$2(_regeneratorRuntime$2().mark((function _callee4(){var _yield$API$get2,data,error,_ref3,account;return _regeneratorRuntime$2().wrap((function(_context4){while(1)switch(_context4.prev=_context4.next){case 0:return _context4.next=2,api/* API */.bl.get("/v2/fetchAccount");case 2:if(_yield$API$get2=_context4.sent,data=_yield$API$get2.data,error=_yield$API$get2.error,!error){_context4.next=9;break}_this4.$message.error(error||"Error Occured"),_context4.next=11;break;case 9:return _ref3=data||{},account=_ref3.account,_context4.abrupt("return",account);case 11:case"end":return _context4.stop()}}),_callee4)})))()},loadOperators:function(){var _this5=this;return _asyncToGenerator$2(_regeneratorRuntime$2().mark((function _callee5(){var url,_yield$API$get3,data,error,_ref4,_ref4$message,message,_ref5,operators;return _regeneratorRuntime$2().wrap((function(_context5){while(1)switch(_context5.prev=_context5.next){case 0:return url="v2/filter/advanced/operators",_context5.next=3,api/* API */.bl.get(url);case 3:if(_yield$API$get3=_context5.sent,data=_yield$API$get3.data,error=_yield$API$get3.error,!error){_context5.next=11;break}_ref4=error||{},_ref4$message=_ref4.message,message=void 0===_ref4$message?"Error Occured":_ref4$message,_this5.$message.error(message),_context5.next=14;break;case 11:if(_ref5=data||{},operators=_ref5.operators,isEmpty$8(operators)){_context5.next=14;break}return _context5.abrupt("return",operators);case 14:case"end":return _context5.stop()}}),_callee5)})))()},checkSize:function(tag){var string="".concat(tag.fieldDisplayName," ").concat(tag.operatorDisplayName," ").concat(tag.valueStr),font="13px Arial",canvas=document.createElement("canvas"),context=canvas.getContext("2d");context.font=font;var width=context.measureText(string+", ").width,formattedWidth=Math.ceil(width);return!(formattedWidth>250)},isValueArray:function(tag){var _ref6=tag||{},valueStr=_ref6.valueStr;return isArray$2(valueStr)&&1!==valueStr.length},tagValue:function(tag){var _ref7=tag||{},valueStr=_ref7.valueStr;return isArray$2(valueStr)?valueStr[0]:valueStr},constructTags:function(){var _this6=this;return _asyncToGenerator$2(_regeneratorRuntime$2().mark((function _callee6(){var _this6$fields,fields,operatorsList,filters,labelMeta,lookupFieldsArr,tagsArr,isTagsConstructable;return _regeneratorRuntime$2().wrap((function(_context6){while(1)switch(_context6.prev=_context6.next){case 0:if(_this6$fields=_this6.fields,fields=void 0===_this6$fields?[]:_this6$fields,operatorsList=_this6.operatorsList,filters=_this6.appliedFilters,labelMeta={},lookupFieldsArr=[],tagsArr=[],isTagsConstructable=!isEmpty$8(filters)&&!isEmpty$8(operatorsList)&&!isEmpty$8(fields),isTagsConstructable&&Object.entries(filters).forEach((function(_ref8){var _ref9=_slicedToArray$2(_ref8,2),key=_ref9[0],value=_ref9[1],tagObj={};key=key.split("__")[0];var valueStr="",_ref10=value||{},valueArr=_ref10.value,operatorId=_ref10.operatorId,selectedField=_this6.getSelectedField({fields:fields,fieldName:key}),isLookupField$1=isLookupField$2(selectedField)||isLookupPopupField$2(selectedField)||isMultiLookupField$2(selectedField),selectedOperator=_this6.getSelectedOperator({selectedField:selectedField,operatorId:operatorId});isLookupField$1&&(labelMeta=_this6.constructLabelMeta({selectedField:selectedField,lookupFieldsArr:lookupFieldsArr,labelMeta:labelMeta,valueArr:valueArr,selectedOperator:selectedOperator}));var operatorDisplayName=_this6.getOperatorDisplayName({operator:selectedOperator}),isDefaultOperator=!isEmpty$8(selectedOperator.defaultValue),fieldDisplayName=selectedField.displayName;isDefaultOperator||(valueStr=_this6.getValueString({valueArr:valueArr,selectedField:selectedField,isLookupField:isLookupField$1,operator:selectedOperator})),tagObj={fieldName:key,fieldDisplayName:fieldDisplayName,operatorDisplayName:operatorDisplayName,valueStr:valueStr},"drillDownPattern"!=key&&tagsArr.push(tagObj)})),isEmpty$8(labelMeta)){_context6.next=10;break}return _context6.next=9,_this6.fetchLookupLabels({labelMeta:labelMeta,lookupFieldsArr:lookupFieldsArr,tagsArr:tagsArr});case 9:tagsArr=_context6.sent;case 10:_this6.tagsArr=tagsArr;case 11:case"end":return _context6.stop()}}),_callee6)})))()},getSelectedField:function(props){var fields=props.fields,fieldName=props.fieldName,selectedField=fields.find((function(field){return field.name===fieldName}));return selectedField||{}},getSelectedOperator:function(props){var operatorsList=this.operatorsList,operatorId=props.operatorId,selectedField=props.selectedField,_ref11=selectedField||{},dataType=_ref11.dataType,_ref11$operators=_ref11.operators,operators=void 0===_ref11$operators?[]:_ref11$operators,selectedOperator=operatorsList[dataType]||[];return isEmpty$8(operators)||(selectedOperator=selectedOperator.concat(operators)),selectedOperator.find((function(operator){return operator.operatorId===operatorId}))||{}},constructLabelMeta:function(props){var selectedField=props.selectedField,lookupFieldsArr=props.lookupFieldsArr,labelMeta=props.labelMeta,valueArr=props.valueArr,_props$selectedOperat=props.selectedOperator,selectedOperator=void 0===_props$selectedOperat?{}:_props$selectedOperat,name=this.getLookupModuleName({field:selectedField,operator:selectedOperator});// Have to construct the label meta keys from lookup module name
// either from the operator or from the field
lookupFieldsArr.push(selectedField);var selectedModule=labelMeta[name];if(isEmpty$8(selectedModule))labelMeta[name]=valueArr||[];else{var ids=labelMeta[name];labelMeta[name]=ids.concat(valueArr)}return labelMeta},getLookupModuleName:function(_ref12){var operator=_ref12.operator,field=_ref12.field,fieldLookupModule=dlv_umd(field,"lookupModule.name"),operatorLookupModule=dlv_umd(operator,"lookupModule.name");return isEmpty$8(operatorLookupModule)?fieldLookupModule:operatorLookupModule},getOperatorDisplayName:function(props){var operator=props.operator,_ref13=operator||{},tagDisplayName=_ref13.tagDisplayName,displayName=_ref13.displayName,operatorId=_ref13.operatorId;return[dateTimeOperator$2[operatorId]].includes(displayName)?"is":tagDisplayName||displayName},getValueString:function(props){var _this7=this,valueArr=props.valueArr,selectedField=props.selectedField,isLookupField=props.isLookupField,operator=props.operator,operatorId=operator.operatorId,operatorDisplayName=operator.displayName;if(!isEmpty$8(valueArr)){var valueStr="",isPicklistOrBoolean=this.isPicklistOrBoolean(selectedField),isDateTypeField$1=isDateTypeField$2(selectedField);if(isDateTypeField$1){if(valueStr=valueArr.reduce((function(acc,value,index){if([dateTimeOperator$2[operatorId]].includes(operatorDisplayName)){if([106,107,84,85].includes(operatorId))if(84===operatorId){var currentMonth=_this7.MONTHS.find((function(month){month.value==value&&currentMonth.push(month.label)}));acc+="".concat(currentMonth)}else acc+=85===operatorId?"".concat(_this7.WEEK_DAYS[value]):value;else acc+="".concat(value).concat(1==value?"st":2==value?"nd":3==value?"rd":"th");return acc+=index!==valueArr.length-1?", ":" ",acc}var dateStr=_this7.formatDate(Number(value),!0,!1);return isEmpty$8(acc)?"".concat(dateStr):"".concat(acc,", ").concat(dateStr)}),""),[dateTimeOperator$2[operatorId]].includes(operatorDisplayName))if([106,107].includes(operatorId)){var operatorIdKey={106:"Before",107:"After"};valueStr="".concat(operatorIdKey[operatorId]||""," ").concat(valueStr," days")}else[84,85].includes(operatorId)||(valueStr+="".concat(operatorDisplayName))}else if(isPicklistOrBoolean){var options=selectedField.options;isEmpty$8(options)||(valueStr=this.constructLabelString(valueArr,options))}else{if(isLookupField)return valueArr;valueStr=valueArr.reduce((function(acc,value){return isEmpty$8(acc)?"".concat(value):"".concat(acc,", ").concat(value)}),"")}return'"'.concat(valueStr,'"')}return""},isPicklistOrBoolean:function(field){var _ref14=field||{},displayType=_ref14.displayType;return["SELECTBOX","DECISION_BOX"].includes(displayType)},constructLabelString:function(){var valueArr=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],options=arguments.length>1?arguments[1]:void 0,valueStr="";return isArray$2(valueArr)&&(valueStr=valueArr.reduce((function(acc,value){var _ref15=options.find((function(option){return String(option.value)===value}))||{},_ref15$label=_ref15.label,label=void 0===_ref15$label?"Invalid":_ref15$label;return isEmpty$8(acc)?"".concat(label):"".concat(acc,", ").concat(label)}),"")),valueStr},fetchLookupLabels:function(props){var _this8=this;return _asyncToGenerator$2(_regeneratorRuntime$2().mark((function _callee7(){var labelMeta,lookupFieldsArr,tagsArr,_yield$API$post,data,error,_error$message,message,_ref16,label;return _regeneratorRuntime$2().wrap((function(_context7){while(1)switch(_context7.prev=_context7.next){case 0:return labelMeta=props.labelMeta,lookupFieldsArr=props.lookupFieldsArr,tagsArr=props.tagsArr,_context7.next=3,api/* API */.bl.post("/v2/picklist/label",{labelMeta:labelMeta});case 3:return _yield$API$post=_context7.sent,data=_yield$API$post.data,error=_yield$API$post.error,error?(_error$message=error.message,message=void 0===_error$message?"Error Occurred":_error$message,_this8.$message.error(message)):(_ref16=data||{},label=_ref16.label,tagsArr=tagsArr.map((function(tag){var fieldName=tag.fieldName,valueStr=tag.valueStr,lookupField=lookupFieldsArr.find((function(field){return field.name===fieldName}));if(lookupField){
// Have to get the value labels from lookup module name
// either from the operator or from the field
var fields=_this8.fields,filters=_this8.appliedFilters,field=_this8.getSelectedField({fields:fields,fieldName:fieldName}),currentFiter=filters[fieldName],operatorId=currentFiter.operatorId,operator=_this8.getSelectedOperator({selectedField:field,operatorId:operatorId}),name=_this8.getLookupModuleName({operator:operator,field:field}),moduleLabels=label[name]||[],labelArray=_this8.constructLabelString(valueStr,moduleLabels);tag.valueStr=labelArray}return tag}))),_context7.abrupt("return",tagsArr);case 8:case"end":return _context7.stop()}}),_callee7)})))()},formatDate:function(date,excludeTime,onlyTime){var dateformat=this.account.org.dateFormat,timeformat=this.account.org.timeFormat,timezone=this.account.org.timezone?this.account.org.timezone:"Etc/UTC";return onlyTime?moment_timezone(date).tz(timezone).format(timeformat):excludeTime?moment_timezone(date).tz(timezone).format(dateformat):moment_timezone(date).tz(timezone).format(dateformat+" "+timeformat)},clearFilter:function(tag){var appliedFilters=this.appliedFilters,hideQuery=this.hideQuery,filtersObj=this.filters,filters=deepClean$1(appliedFilters)||{},fieldName=tag.fieldName;isEmpty$8(fieldName)||delete filters[fieldName],hideQuery&&!isEmpty$8(filtersObj)?this.$emit("updateFilters",filters):isEmpty$8(filters)?this.$emit("resetFilters",filters):this.$emit("applyFilters",filters)}}},MONTHS$2),WEEK_DAYS$2);
/* script */
const __vue_script__$8$3=script$8$3;
/* template */var __vue_render__$8$3=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _vm.showTags?_c("div",{staticClass:"f-filter-tags-container"},[_vm._l(_vm.firstThreeTags,(function(tag,index){return _c("div",{key:index,ref:index,refInFor:!0},[_c("Tooltip",{attrs:{placement:"bottom-start",disabled:_vm.checkSize(tag)}},[_c("div",{staticClass:"f-tag-content",attrs:{slot:"content"},slot:"content"},[_vm._v("\n        "+_vm._s(tag.fieldDisplayName)+" "+_vm._s(tag.operatorDisplayName)+"\n        "+_vm._s(tag.valueStr)+"\n      ")]),_vm._v(" "),_c("div",{staticClass:"tag"},[_c("div",[_vm._v(_vm._s(tag.fieldDisplayName))]),_vm._v(" "),_c("div",{staticClass:"ftag-operator"},[_vm._v("\n          "+_vm._s(tag.operatorDisplayName)+"\n        ")]),_vm._v(" "),_c("div",{staticClass:"ftag-value-container"},[_vm._v("\n          "+_vm._s(tag.valueStr)+"\n        ")]),_vm._v(" "),_c("span",{on:{click:function($event){return _vm.clearFilter(tag)}}},[_c("CloseIcon",{staticClass:"ftag-close-icon"})],1)])])],1)})),_vm._v(" "),_vm.checkDropDownExists?_c("div",[_c("Dropdown",[_c("div",{staticClass:"tag"},[_vm._v("+"+_vm._s(_vm.dropDownTags.length))]),_vm._v(" "),_c("DropdownMenu",{staticClass:"f-tags-dropdown",attrs:{slot:"dropdown"},slot:"dropdown"},_vm._l(_vm.dropDownTags,(function(tag,index){return _c("DropdownItem",{key:index},[_c("Tooltip",{attrs:{placement:"right",disabled:_vm.checkSize(tag)}},[_c("div",{staticClass:"f-tag-content",attrs:{slot:"content"},slot:"content"},[_vm._v("\n              "+_vm._s(tag.fieldDisplayName)+" "+_vm._s(tag.operatorDisplayName)+"\n              "+_vm._s(tag.valueStr)+"\n            ")]),_vm._v(" "),_c("div",{staticClass:"dropdown-tag"},[_c("div",[_vm._v(_vm._s(tag.fieldDisplayName))]),_vm._v(" "),_c("div",{staticClass:"ftag-operator"},[_vm._v("\n                "+_vm._s(tag.operatorDisplayName)+"\n              ")]),_vm._v(" "),_c("div",{staticClass:"ftag-value-container"},[_vm._v("\n                "+_vm._s(tag.valueStr)+"\n              ")]),_vm._v(" "),_c("span",{on:{click:function($event){return _vm.clearFilter(tag)}}},[_c("CloseIcon",{staticClass:"ftag-close-icon"})],1)])])],1)})),1)],1)],1):_vm._e(),_vm._v(" "),_c("div",{staticClass:"btn-container"},[_c("Button",{staticClass:"tag-btn",on:{click:function($event){return _vm.$emit("clearFilters",!0)}}},[_vm._v("Clear all")]),_vm._v(" "),_c("Button",{directives:[{name:"show",rawName:"v-show",value:!_vm.hideSaveAs,expression:"!hideSaveAs"}],staticClass:"tag-btn"},[_vm._v("Save As")])],1)],2):_vm._e()},__vue_staticRenderFns__$8$3=[];
/* style */
const __vue_inject_styles__$8$3=function(inject){inject&&inject("data-v-52bb0d0a_0",{source:".ftag-value-container[data-v-52bb0d0a]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ftag-close-icon[data-v-52bb0d0a]{height:10px;width:10px;margin-left:8px;cursor:pointer}.f-tag-content[data-v-52bb0d0a]{max-width:250px;font-size:13px;background:#303133;color:#fff;padding:4px 8px;border-radius:4px}.ftag-operator[data-v-52bb0d0a]{margin:0 4px;color:#324056;font-size:13px;font-weight:400}.f-filter-tags-container[data-v-52bb0d0a]{background:#fff;margin:10px;padding:8px 4px;display:flex;flex-wrap:wrap;box-sizing:border-box;gap:12px}.f-filter-tags-container .tag[data-v-52bb0d0a]{cursor:pointer;display:flex;border-radius:14px;border:solid 1px rgba(58,178,193,.4705882353);background-color:#fff;color:#324056;font-size:13px;font-weight:500;height:24px;align-items:center;padding:6px 10px;box-sizing:border-box;margin-bottom:0!important;margin-right:0!important;max-width:330px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.f-filter-tags-container .tag[data-v-52bb0d0a]:hover{border-color:#3ab2c1}.f-filter-tags-container .tag-btn[data-v-52bb0d0a]{height:24px;margin:0 8px;padding:0 8px;border-radius:14px;border:solid 1px rgba(58,178,193,.4705882353);background-color:#f7feff;cursor:pointer}.f-filter-tags-container .tag-btn[data-v-52bb0d0a]:hover{border-color:#3ab2c1}.el-dropdown-link[data-v-52bb0d0a]{cursor:pointer}.el-dropdown-menu.el-popper.f-tags-dropdown[data-v-52bb0d0a]{list-style:none;width:250px;max-height:165px;overflow:scroll;box-shadow:0 1px 5px 0 rgba(0,0,0,.16);background-color:#fff;padding-inline-start:0}.el-dropdown-menu.el-popper.f-tags-dropdown li.el-dropdown-menu__item[data-v-52bb0d0a]{padding:0!important}.el-dropdown-menu.el-popper.f-tags-dropdown li .dropdown-tag[data-v-52bb0d0a]{background-color:#fff;color:#324056;font-size:13px;font-weight:500;cursor:pointer;box-sizing:border-box;width:100%;height:40px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:13px;background-color:#fff;display:flex;align-items:center;padding:4px}.el-dropdown-menu.el-popper.f-tags-dropdown li .dropdown-tag[data-v-52bb0d0a]:hover{background-color:#fafafa}.el-dropdown-menu.el-popper.f-tags-dropdown li .dropdown-tag span[data-v-52bb0d0a]{flex-grow:1;text-align:right}",map:void 0,media:void 0})},__vue_scope_id__$8$3="data-v-52bb0d0a",__vue_module_identifier__$8$3=void 0,__vue_is_functional_template__$8$3=!1,__vue_component__$7$3=normalizeComponent$3$3({render:__vue_render__$8$3,staticRenderFns:__vue_staticRenderFns__$8$3},__vue_inject_styles__$8$3,__vue_script__$8$3,__vue_scope_id__$8$3,__vue_is_functional_template__$8$3,__vue_module_identifier__$8$3,!1,createInjector$5,void 0,void 0);
/* scoped */var AdvancedSearch$2=__vue_component__$1$1$2,FTags$2=__vue_component__$7$3;const LOOKUP_FILTERS_MAP$2={1:"building",2:"asset",3:"tenantcontact",4:"clientcontact",5:"vendorcontact",6:"employee"},RESOURCE_MODULE_HASH$2={resource:[{label:"Asset",value:"asset"},{label:"Site",value:"site"},{label:"Building",value:"building"},{label:"Floor",value:"floor"},{label:"Space",value:"space"}],basespace:[{label:"Site",value:"site"},{label:"Building",value:"building"},{label:"Floor",value:"floor"},{label:"Space",value:"space"}]};
var script$7$3={props:["canShowLookupWizard","field","siteId"],components:{Dialog:element_ui_common.Dialog,CommonList:__vue_component__$l,Spinner:__vue_component__$i,Pagination:__vue_component__$k,Radio:element_ui_common.Radio,Tag:element_ui_common.Tag,Button:element_ui_common.Button,TextInput:__vue_component__$p,EmptyIcon:EmptyIcon$2,AdvancedFilterIcon:AdvancedFilterIcon$1,AdvancedSearch:AdvancedSearch$2,FTags:FTags$2,Select:element_ui_common.Select,Option:element_ui_common.Option},data:()=>({isLoading:!1,viewDetail:null,moduleList:[],perPage:10,page:1,totalCount:0,selectedItem:[],search:"",resourceModuleName:"basespace",criteria:{},showAdvWizard:!1,operators:[],filters:{},subModuleName:"",resourceSubModules:[]}),watch:{async page(){this.isLoading=!0,await this.fetchModuleList(),this.isLoading=!1},async filters(){this.loading=!0,await this.fetchModuleList(),this.loading=!1},moduleName:{handler(newVal,oldVal){isEmpty$8(RESOURCE_MODULE_HASH$2[newVal])&&this.loadData()},immediate:!0},isLoading(newVal){!newVal&&this.multiSelect&&this.toggleSelection()}},computed:{showFTags(){let{filters:filters}=this;return!isEmpty$8(filters)},actualMainfield(){let{viewDetail:viewDetail}=this,mainField=null;if(!isEmpty$8(viewDetail)){let{fields:fields}=viewDetail;mainField=(fields||[]).find((field=>{let{field:fieldObj}=field;return(fieldObj||{}).mainField}))}return mainField},isResourceModule(){let{field:field}=this,{config:config}=field,{isFiltersEnabled:isFiltersEnabled}=config||{};if(isFiltersEnabled)return!1;let displayName=dlv_umd(field,"field.lookupModule.name","");if(isEmpty$8(displayName)&&(displayName=dlv_umd(field,"lookupModule.name","")),!isEmpty$8(RESOURCE_MODULE_HASH$2[displayName])){let subModule=RESOURCE_MODULE_HASH$2[displayName][0];return this.subModuleName=subModule.value,this.resourceSubModules=RESOURCE_MODULE_HASH$2[displayName],!0}return!1},mainField(){let{viewDetail:viewDetail}=this,mainField=null;if(!isEmpty$8(viewDetail)){let{fields:fields}=viewDetail;mainField=(fields||[]).find((field=>{let{field:fieldObj}=field;return(fieldObj||{}).mainField}))}return isEmpty$8(mainField)&&(mainField={name:"name",displayName:"Name",field:{name:"name",dataTypeEnum:"STRING"}}),mainField},mainFieldName(){let{mainField:mainField}=this||{},{name:name}=mainField||{};return isEmpty$8(name)&&(name=dlv_umd(mainField,"field.name","")),name},canShowWizard:{get(){return this.canShowLookupWizard},set(value){this.$emit("update:canShowLookupWizard",value)}},moduleDisplayName(){let{field:field}=this,displayName=dlv_umd(field,"field.lookupModule.displayName","");return isEmpty$8(displayName)&&(displayName=dlv_umd(field,"lookupModule.displayName","")),displayName},moduleName(){let{field:field,subModuleName:subModuleName}=this,{config:config}=field,{isFiltersEnabled:isFiltersEnabled,filterValue:filterValue,lookupModuleName:configLookupModuleName}=config||{};if(isFiltersEnabled)return configLookupModuleName||LOOKUP_FILTERS_MAP$2[filterValue];let displayName=dlv_umd(field,"field.lookupModule.name","");return isEmpty$8(displayName)&&(displayName=dlv_umd(field,"lookupModule.name","")),isEmpty$8(subModuleName)||(displayName=subModuleName),displayName},title(){let{moduleDisplayName:moduleDisplayName}=this;return`Choose ${moduleDisplayName}`},multiSelect(){let{field:field}=this,{multiple:multiple}=field||{};return multiple},selectedLabel(){let{moduleDisplayName:moduleDisplayName}=this;return`Selected ${moduleDisplayName} `},selectedItemName(){let{selectedItem:selectedItem}=this||{},selectedItemNames=(selectedItem||[]).map((list=>list.label));return isEmpty$8(selectedItemNames)?null:selectedItemNames},selectedItemId:{get(){let{selectedItem:selectedItem,multiSelect:multiSelect}=this||{},selectedItemIds=(selectedItem||[]).map((list=>list.value));return multiSelect?selectedItemIds:selectedItemIds[0]},set(val){let{moduleList:moduleList,multiSelect:multiSelect}=this||{};multiSelect||Array.isArray(val)||(val=[val]);let selectedItem=moduleList.filter((item=>val.includes(item.id)));this.selectedItem=selectedItem.map((list=>{let{id:id}=list,{name:name}=this.mainField||{name:"name"},selectedItem={label:list[name],value:id};return selectedItem}))}},slotList(){let{actualMainfield:actualMainfield}=this,label=dlv_umd(this,"actualMainfield.field.displayName","Name"),slots=[{name:"select",isHardcodedColumn:!0,columnAttrs:{fixed:"left",width:"50"}}];if(isEmpty$8(actualMainfield))slots.push({name:"name",isHardcodedColumn:!0,columnAttrs:{fixed:"left",label:label,width:"200"}});else{let{field:field}=actualMainfield,{name:mainFieldName}=field;slots.push({criteria:JSON.stringify({name:mainFieldName})})}return slots}},created(){this.loadOperatorList()},methods:{async loadOperatorList(){let url="v2/filter/advanced/operators",{data:data,error:error}=await api/* API */.bl.get(url);if(error){let{message:message="Error Occured"}=error||{};this.$message.error(message)}else{let{operators:operators}=data||{};isEmpty$8(operators)||(this.operators=operators)}},isEmpty(val){return isEmpty$8(val)},applyFilters(filters){this.filters=filters,this.showAdvWizard=!1},getMainFieldValue(record={}){let{mainField:mainField}=this||{},{field:field}=mainField||{},{name:name}=field||{};if(isObject$4(record[name])){let{name:mainValue}=record[name];return mainValue}return record[name]||record.name},setResourceModule(val){this.subModuleName=val,this.filters=null},loadData(){let promise=[];this.moduleName&&(this.initSelectedItem(),promise.push(this.fetchViewDetail()),promise.push(this.fetchModuleList()),this.isLoading=!0,Promise.all(promise).finally((()=>{this.isLoading=!1})))},async fetchViewDetail(){let{moduleName:moduleName}=this,url="v2/views/hidden-all",{data:data,error:error}=await api/* API */.bl.get(url,{moduleName:moduleName});if(isEmpty$8(error)){let{viewDetail:viewDetail}=data||{},{fields:fields}=viewDetail||{};fields=fields.map((field=>{let{field:fieldObj,name:name=""}=field||{},{mainField:mainField}=fieldObj||{};return mainField?{...field,columnAttrs:{fixed:"left",width:"200"}}:field})),isEmpty$8(viewDetail)||this.$set(this,"viewDetail",{...viewDetail,fields:fields})}},async fetchModuleList(){this.isLoading=!0;let filterObj={},{moduleName:moduleName,page:page,perPage:perPage,siteId:siteId}=this||{},{filters:filters,field:field}=this||{},{config:config,filters:fieldFilters}=field||{},{skipSiteFilter:skipSiteFilter}=config||{};skipSiteFilter||isEmpty$8(siteId)||(filterObj={siteId:{operatorId:36,value:[`${siteId}`]}}),isEmpty$8(fieldFilters)||(filterObj={...filterObj,...fieldFilters}),isEmpty$8(filters)||(filterObj={...filterObj,...filters});let params={viewname:"hidden-all",includeParentFilter:!0,page:page,perPage:perPage,withCount:!0};isEmpty$8(filterObj)||(params["filters"]=JSON.stringify(filterObj));let{list:list,error:error,meta:meta}=await api/* API */.bl.fetchAll(moduleName,params);isEmpty$8(error)&&(this.moduleList=list,this.totalCount=dlv_umd(meta,"pagination.totalCount",0)),this.isLoading=!1},onSearchChange:debounce((async function(value){this.onSearch(value)}),700),async onSearch(value){if(this.isLoading=!0,isEmpty$8(value))await this.fetchModuleList();else{let{mainFieldName:mainFieldName}=this||{};("basespace"==this.moduleName||"asset"==this.moduleName)&&(mainFieldName="name");let filters={[mainFieldName]:{operatorId:5,value:[value]}};await this.fetchModuleList({filters:filters})}this.isLoading=!1},initSelectedItem(){let{field:field}=this,{selectedItems:selectedItems=[]}=field||{};isEmpty$8(selectedItems)||(this.selectedItem=[...selectedItems])},toggleSelection(){this.$nextTick((()=>{let{selectedItemId:selectedItemId}=this,currentSelectedList=this.moduleList.filter((list=>(selectedItemId||[]).includes((list||{}).id))),ref=this.$refs.lookupCommonList;isEmpty$8(ref)||(ref.clearSelection(),currentSelectedList.forEach((item=>{ref.toggleRowSelection(item,!0)})))}))},setSelectedItem(){let{selectedItem:selectedItem,mainField:mainField,selectedItemId:selectedItemId,multiSelect:multiSelect,field:field}=this;multiSelect||isEmpty$8(selectedItemId)||(selectedItem=[this.moduleList.find((list=>list.id===selectedItemId))],selectedItem=selectedItem.map((list=>{let{id:id}=list,{name:name}=this.mainField||{name:"name"},selectedItem={label:list[name],value:id};return selectedItem}))),isEmpty$8(mainField)&&(mainField={name:"name"}),field.selectedItems=selectedItem;let data={field:field};this.$emit("setLookupFieldValue",data),this.canShowWizard=!1},handleSelection(selectedList){let nonCurrentItems=this.getNonCurrentList(this.selectedItem),currentItems=(selectedList||[]).map((list=>{let{id:id}=list,{mainFieldName:mainFieldName}=this||{};return{label:list[mainFieldName],value:id}}));this.selectedItem=[...nonCurrentItems,...currentItems]},getNonCurrentList(selectedList){let{moduleList:moduleList}=this,currentModuleList=selectedList.filter((item=>-1===moduleList.findIndex((list=>list.id===item.value))));return currentModuleList},handleSelectedClose(item){let index=this.selectedItem.findIndex((list=>list.label===item));this.selectedItem.splice(index,1),this.toggleSelection()},closeWizard(){this.setSelectedItem()},closeAdvWizard(){this.showAdvWizard=!1},applyFilter(){let filters=this.$refs["advancedSearch"].save();this.filters=filters,this.closeAdvWizard()},updateFilters(filters){this.filters=filters}}};
/* script */const __vue_script__$7$3=script$7$3;
/* template */var __vue_render__$7$3=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("Dialog",{staticClass:"f-ui-forms f-ui-lookup-wizard",attrs:{visible:_vm.canShowWizard,width:"70%",top:"5vh","append-to-body":!0,"show-close":!1,"before-close":_vm.closeWizard},on:{"update:visible":function($event){_vm.canShowWizard=$event}}},[_c("template",{slot:"title"},[_vm.isResourceModule?_c("div",{staticClass:"resource-title-container"},[_c("div",{staticClass:"resource-header"},[_c("div",{staticClass:"resource-title"},[_vm._v("\n          "+_vm._s(_vm.title)+"\n        ")]),_vm._v(" "),_c("div",{staticClass:"el-dialog__close el-icon el-icon-close close-icon cursor-pointer",on:{click:_vm.closeWizard}})]),_vm._v(" "),_c("div",{staticClass:"title-seperator"})]):_vm._e(),_vm._v(" "),_c("div",{staticClass:"flex items-center"},[_vm.isResourceModule?_c("div",{staticClass:"lookup-wizard-title"},[_c("Select",{staticClass:"f-ui-select w-full f-ui-select-tag",attrs:{"default-first-option":"",filterable:""},on:{change:_vm.setResourceModule},model:{value:_vm.subModuleName,callback:function($$v){_vm.subModuleName=$$v},expression:"subModuleName"}},_vm._l(_vm.resourceSubModules,(function(module,index){return _c("Option",{key:index,staticClass:"f-ui-select-item width100",attrs:{label:module.label,value:module.value}})})),1)],1):_c("div",{staticClass:"lookup-wizard-title"},[_vm._v("\n        "+_vm._s(_vm.title)+"\n      ")]),_vm._v(" "),_c("div",{staticClass:"ml-auto flex items-center"},[[_c("div",{on:{click:function($event){_vm.showAdvWizard=!0}}},[_c("AdvancedFilterIcon",{staticClass:"advance-filter-icon"}),_vm._v(" "),_c("Dialog",{attrs:{visible:_vm.showAdvWizard,"append-to-body":!0,"show-close":!0,fullscreen:!0,"custom-class":"advance-search-dialog",title:"Filter "+_vm.moduleName+" by"},on:{"update:visible":function($event){_vm.showAdvWizard=$event}}},[_vm.showAdvWizard?[_c("AdvancedSearch",{ref:"advancedSearch",attrs:{moduleName:_vm.moduleName,hideQuery:!0,filterList:_vm.filters,showAdvWizard:_vm.showAdvWizard},on:{applyFilters:_vm.applyFilters,closeDialog:function($event){_vm.showAdvWizard=!1}}})]:_vm._e()],2)],1),_vm._v(" "),_c("span",{staticClass:"separator"},[_vm._v("|")])],_vm._v(" "),_c("Pagination",{staticClass:"self-center",attrs:{currentPage:_vm.page,total:_vm.totalCount,perPage:_vm.perPage},on:{"update:currentPage":function($event){_vm.page=$event},"update:current-page":function($event){_vm.page=$event}}}),_vm._v(" "),_vm.totalCount&&!_vm.isResourceModule?_c("span",{staticClass:"separator"},[_vm._v("|")]):_vm._e(),_vm._v(" "),_vm.isResourceModule?_vm._e():_c("div",{staticClass:"el-dialog__close el-icon el-icon-close close-icon cursor-pointer",on:{click:_vm.closeWizard}})],2)])]),_vm._v(" "),_vm.showFTags?_c("div",{staticClass:"wizard-f-tag-container"},[_c("FTags",{attrs:{moduleName:_vm.moduleName,filters:_vm.filters,hideQuery:!0,hideSaveAs:!0},on:{updateFilters:_vm.updateFilters,clearFilters:function($event){_vm.filters={}}}})],1):_vm._e(),_vm._v(" "),_vm.isEmpty(_vm.selectedItemName)?_vm._e():_c("div",{staticClass:"flex items-center ml-5 my-4"},[_c("div",{staticClass:"mr-3"},[_vm._v(_vm._s(_vm.selectedLabel)+":")]),_vm._v(" "),_c("div",{staticClass:"flex flex-wrap w-10/12"},_vm._l(_vm.selectedItemName,(function(name,index){return _c("Tag",{key:index,staticClass:"f-ui-tag flex items-center mr-2 my-1",on:{click:function(){return _vm.handleSelectedClose(name)}}},[_c("span",[_vm._v(_vm._s(name))]),_vm._v(" "),_vm.multiSelect?_c("i",{staticClass:"el-icon-close pointer"}):_vm._e()])})),1)]),_vm._v(" "),_vm.isLoading?_c("div",{staticClass:"flex justify-center"},[_c("Spinner",{attrs:{show:_vm.isLoading}})],1):_vm.isEmpty(_vm.moduleList)?_c("div",{staticClass:"f-ui-lookup-empty"},[_c("EmptyIcon",{staticClass:"w-40 h-40"}),_vm._v(" "),_c("div",{staticClass:"mT10 label-txt-black text-md"},[_vm._v("\n      No "+_vm._s(_vm.moduleDisplayName?_vm.moduleDisplayName:_vm.moduleName)+"s available\n    ")])],1):_c("div",{staticClass:"f-ui-lookup-table-container"},[_vm.isEmpty(_vm.moduleList)||_vm.isLoading?_vm._e():_c("CommonList",{ref:"lookupCommonList",attrs:{viewDetail:_vm.viewDetail,records:_vm.moduleList,moduleName:_vm.moduleName,slotList:_vm.slotList,hideListSelect:!_vm.multiSelect},on:{"selection-change":_vm.handleSelection},scopedSlots:_vm._u([{key:"select",fn:function(ref){var record=ref.record;return[_vm.multiSelect?_vm._e():_c("Radio",{attrs:{label:record.id},on:{change:_vm.setSelectedItem},model:{value:_vm.selectedItemId,callback:function($$v){_vm.selectedItemId=$$v},expression:"selectedItemId"}})]}},_vm.actualMainfield?{key:_vm.slotList[1].criteria,fn:function(ref){var record=ref.record;return[_vm._v("\n        "+_vm._s(_vm.getMainFieldValue(record)))]}}:{key:_vm.slotList[1].name,fn:function(ref){var record=ref.record;return[_vm._v("\n        "+_vm._s(_vm.getMainFieldValue(record)))]}}],null,!0)}),_vm._v(" "),_vm.multiSelect?_c("div",{staticClass:"flex mt-auto"},[_c("Button",{staticClass:"modal-btn-cancel modal-btn",on:{click:_vm.closeWizard}},[_vm._v("\n        Cancel\n      ")]),_vm._v(" "),_c("Button",{staticClass:"modal-btn-save modal-btn",attrs:{type:"primary"},on:{click:_vm.setSelectedItem}},[_vm._v("\n        Save\n      ")])],1):_vm._e()],1)],2)},__vue_staticRenderFns__$7$3=[];
/* style */
const __vue_inject_styles__$7$3=function(inject){inject&&inject("data-v-bd631ffe_0",{source:".advance-search-dialog.is-fullscreen{width:35%;overflow:hidden;height:100vh;display:flex;flex-direction:column;margin-right:0;margin-top:0}.advance-search-dialog .el-dialog__body{display:flex;flex-direction:column;overflow:scroll;height:100%;padding:0;margin-top:8px}.f-ui-lookup-wizard .wizard-f-tag-container{margin-left:6px}.f-ui-lookup-wizard .el-dialog{margin-top:2vh!important}.f-ui-lookup-wizard .advance-filter-icon{box-sizing:content-box;cursor:pointer;height:15px;width:15px;padding:4px;border-radius:4px;border:1px solid transparent}.f-ui-lookup-wizard .advance-filter-icon:hover{color:#615e88;background:#f5f6f8;border-color:#dae0e8}.f-ui-lookup-wizard .resource-title-container .resource-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:4px}.f-ui-lookup-wizard .resource-title-container .resource-title{height:28px;font-weight:500;font-size:16px}.f-ui-lookup-wizard .resource-title-container .title-seperator{height:1px;margin:0 0 15px;background-color:#ebeff3}.f-ui-lookup-wizard .f-ui-lookup-empty{height:600px;display:flex;flex-direction:column;justify-content:center;align-items:center}.f-ui-lookup-wizard .btn-active{font-size:14px;font-weight:700;letter-spacing:.5px;color:#324056}.f-ui-lookup-wizard .btn-not-active{color:#ccc;font-weight:50}.f-ui-lookup-wizard .el-radio__label{visibility:hidden}.f-ui-lookup-wizard .lookup-wizard-title{font-size:14px;font-weight:700;color:#324056;text-transform:uppercase;line-height:24px}.f-ui-lookup-wizard .lookup-wizard-title .uppercase{text-transform:uppercase}.f-ui-lookup-wizard .lookup-wizard-title .el-input__inner{height:28px!important;line-height:28px!important}.f-ui-lookup-wizard .lookup-wizard-title .el-input__suffix i{line-height:28px!important}.f-ui-lookup-wizard .el-table__cell{padding:12px 20px!important}.f-ui-lookup-wizard .el-table__cell:first-child{padding:0 10px 0 20px!important}.f-ui-lookup-wizard .separator{font-weight:300;color:#d8d8d8!important;padding-right:10px;padding-left:10px;padding-bottom:2px}.f-ui-lookup-wizard .close-icon{font-size:15px;padding:4px 3px;border-radius:4px;border:1px solid transparent}.f-ui-lookup-wizard .close-icon:hover{color:#615e88;background:#f5f6f8;border:1px solid #dae0e8}.f-ui-lookup-wizard .el-dialog__header{border-bottom:1px solid #eee;padding:20px 20px 10px!important}.f-ui-lookup-wizard .el-dialog__body{padding:0}.f-ui-lookup-wizard .el-dialog__body .f-ui-lookup-table-container{height:550px}.f-ui-lookup-wizard .el-dialog__body .f-ui-lookup-table-container .el-table th>.cell{font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:.5px;color:#333;white-space:nowrap}.f-ui-lookup-wizard .el-checkbox__input.is-checked .el-checkbox__inner,.f-ui-lookup-wizard .el-checkbox__input.is-indeterminate .el-checkbox__inner,.f-ui-lookup-wizard .el-radio__input.is-checked .el-radio__inner{background-color:#39b2c2;border-color:#39b2c2}.f-ui-lookup-wizard .el-checkbox__input.is-indeterminate .el-checkbox__inner{margin-left:5px}.f-ui-lookup-wizard .modal-btn-cancel{color:#8f8f8f;border-color:#8f8f8f;background-color:#f4f4f4}.f-ui-lookup-wizard .modal-btn-save{background-color:#39b2c2;color:#fff}.f-ui-lookup-wizard .modal-btn{width:50%;padding-top:18px;padding-bottom:18px;cursor:pointer;border:transparent;letter-spacing:1.1px;text-align:center;text-transform:uppercase;font-weight:500;border-radius:0;float:right;line-height:16px;cursor:pointer;margin:0}.f-ui-lookup-wizard .wizard-search-container{margin-right:5px}.f-ui-lookup-wizard .wizard-search-container .f-ui-forms .el-input__icon{display:flex;align-items:center;justify-content:center}.f-ui-lookup-wizard .wizard-search-container .f-ui-forms .f-ui-text-input .el-input__inner{height:30px;padding-left:30px}",map:void 0,media:void 0})},__vue_scope_id__$7$3=void 0,__vue_module_identifier__$7$3=void 0,__vue_is_functional_template__$7$3=!1,__vue_component__$6$3=normalizeComponent$7({render:__vue_render__$7$3,staticRenderFns:__vue_staticRenderFns__$7$3},__vue_inject_styles__$7$3,__vue_script__$7$3,__vue_scope_id__$7$3,__vue_is_functional_template__$7$3,__vue_module_identifier__$7$3,!1,createInjector$4,void 0,void 0);
/* scoped */var _default$2$3={el:{colorpicker:{confirm:"OK",clear:"Clear"},datepicker:{now:"Now",today:"Today",cancel:"Cancel",clear:"Clear",confirm:"OK",selectDate:"Select date",selectTime:"Select time",startDate:"Start Date",startTime:"Start Time",endDate:"End Date",endTime:"End Time",prevYear:"Previous Year",nextYear:"Next Year",prevMonth:"Previous Month",nextMonth:"Next Month",year:"",month1:"January",month2:"February",month3:"March",month4:"April",month5:"May",month6:"June",month7:"July",month8:"August",month9:"September",month10:"October",month11:"November",month12:"December",week:"week",weeks:{sun:"Sun",mon:"Mon",tue:"Tue",wed:"Wed",thu:"Thu",fri:"Fri",sat:"Sat"},months:{jan:"Jan",feb:"Feb",mar:"Mar",apr:"Apr",may:"May",jun:"Jun",jul:"Jul",aug:"Aug",sep:"Sep",oct:"Oct",nov:"Nov",dec:"Dec"}},select:{loading:"Loading",noMatch:"No matching data",noData:"No data",placeholder:"Select"},cascader:{noMatch:"No matching data",loading:"Loading",placeholder:"Select",noData:"No data"},pagination:{goto:"Go to",pagesize:"/page",total:"Total {total}",pageClassifier:""},messagebox:{title:"Message",confirm:"OK",cancel:"Cancel",error:"Illegal input"},upload:{deleteTip:"press delete to remove",delete:"Delete",preview:"Preview",continue:"Continue"},table:{emptyText:"No Data",confirmFilter:"Confirm",resetFilter:"Reset",clearFilter:"All",sumText:"Sum"},tree:{emptyText:"No Data"},transfer:{noMatch:"No matching data",noData:"No data",titles:["List 1","List 2"],// to be translated
filterPlaceholder:"Enter keyword",// to be translated
noCheckedFormat:"{total} items",// to be translated
hasCheckedFormat:"{checked}/{total} checked"},image:{error:"FAILED"},pageHeader:{title:"Back"},popconfirm:{confirmButtonText:"Yes",cancelButtonText:"No"},empty:{description:"No Data"}}};function getDefaultExportFromCjs$3(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,"default")?x["default"]:x}function getAugmentedNamespace$3(n){if(n.__esModule)return n;var a=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(n).forEach((function(k){var d=Object.getOwnPropertyDescriptor(n,k);Object.defineProperty(a,k,d.get?d:{enumerable:!0,get:function(){return n[k]}})})),a}function createCommonjsModule$1$3(fn){var module={exports:{}};return fn(module,module.exports),module.exports}var _default$1$3={el:{colorpicker:{confirm:"确定",clear:"清空"},datepicker:{now:"此刻",today:"今天",cancel:"取消",clear:"清空",confirm:"确定",selectDate:"选择日期",selectTime:"选择时间",startDate:"开始日期",startTime:"开始时间",endDate:"结束日期",endTime:"结束时间",prevYear:"前一年",nextYear:"后一年",prevMonth:"上个月",nextMonth:"下个月",year:"年",month1:"1 月",month2:"2 月",month3:"3 月",month4:"4 月",month5:"5 月",month6:"6 月",month7:"7 月",month8:"8 月",month9:"9 月",month10:"10 月",month11:"11 月",month12:"12 月",
// week: '周次',
weeks:{sun:"日",mon:"一",tue:"二",wed:"三",thu:"四",fri:"五",sat:"六"},months:{jan:"一月",feb:"二月",mar:"三月",apr:"四月",may:"五月",jun:"六月",jul:"七月",aug:"八月",sep:"九月",oct:"十月",nov:"十一月",dec:"十二月"}},select:{loading:"加载中",noMatch:"无匹配数据",noData:"无数据",placeholder:"请选择"},cascader:{noMatch:"无匹配数据",loading:"加载中",placeholder:"请选择",noData:"暂无数据"},pagination:{goto:"前往",pagesize:"条/页",total:"共 {total} 条",pageClassifier:"页"},messagebox:{title:"提示",confirm:"确定",cancel:"取消",error:"输入的数据不合法!"},upload:{deleteTip:"按 delete 键可删除",delete:"删除",preview:"查看图片",continue:"继续上传"},table:{emptyText:"暂无数据",confirmFilter:"筛选",resetFilter:"重置",clearFilter:"全部",sumText:"合计"},tree:{emptyText:"暂无数据"},transfer:{noMatch:"无匹配数据",noData:"无数据",titles:["列表 1","列表 2"],filterPlaceholder:"请输入搜索内容",noCheckedFormat:"共 {total} 项",hasCheckedFormat:"已选 {checked}/{total} 项"},image:{error:"加载失败"},pageHeader:{title:"返回"},popconfirm:{confirmButtonText:"确定",cancelButtonText:"取消"},empty:{description:"暂无数据"}}},zhCN$3=Object.defineProperty({default:_default$1$3},"__esModule",{value:!0}),isMergeableObject$3=function(value){return isNonNullObject$3(value)&&!isSpecial$3(value)};function isNonNullObject$3(value){return!!value&&"object"===typeof value}function isSpecial$3(value){var stringValue=Object.prototype.toString.call(value);return"[object RegExp]"===stringValue||"[object Date]"===stringValue||isReactElement$3(value)}
// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol$3="function"===typeof Symbol&&Symbol.for,REACT_ELEMENT_TYPE$3=canUseSymbol$3?Symbol.for("react.element"):60103;function isReactElement$3(value){return value.$$typeof===REACT_ELEMENT_TYPE$3}function emptyTarget$3(val){return Array.isArray(val)?[]:{}}function cloneIfNecessary$3(value,optionsArgument){var clone=optionsArgument&&!0===optionsArgument.clone;return clone&&isMergeableObject$3(value)?deepmerge$3(emptyTarget$3(value),value,optionsArgument):value}function defaultArrayMerge$3(target,source,optionsArgument){var destination=target.slice();return source.forEach((function(e,i){"undefined"===typeof destination[i]?destination[i]=cloneIfNecessary$3(e,optionsArgument):isMergeableObject$3(e)?destination[i]=deepmerge$3(target[i],e,optionsArgument):-1===target.indexOf(e)&&destination.push(cloneIfNecessary$3(e,optionsArgument))})),destination}function mergeObject$3(target,source,optionsArgument){var destination={};return isMergeableObject$3(target)&&Object.keys(target).forEach((function(key){destination[key]=cloneIfNecessary$3(target[key],optionsArgument)})),Object.keys(source).forEach((function(key){isMergeableObject$3(source[key])&&target[key]?destination[key]=deepmerge$3(target[key],source[key],optionsArgument):destination[key]=cloneIfNecessary$3(source[key],optionsArgument)})),destination}function deepmerge$3(target,source,optionsArgument){var sourceIsArray=Array.isArray(source),targetIsArray=Array.isArray(target),options=optionsArgument||{arrayMerge:defaultArrayMerge$3},sourceAndTargetTypesMatch=sourceIsArray===targetIsArray;if(sourceAndTargetTypesMatch){if(sourceIsArray){var arrayMerge=options.arrayMerge||defaultArrayMerge$3;return arrayMerge(target,source,optionsArgument)}return mergeObject$3(target,source,optionsArgument)}return cloneIfNecessary$3(source,optionsArgument)}deepmerge$3.all=function(array,optionsArgument){if(!Array.isArray(array)||array.length<2)throw new Error("first argument should be an array with at least two elements");
// we are sure there are at least 2 values, so it is safe to have no initial value
return array.reduce((function(prev,next){return deepmerge$3(prev,next,optionsArgument)}))};var deepmerge_1$3=deepmerge$3,es$3=Object.freeze({__proto__:null,default:deepmerge_1$3}),types$3=createCommonjsModule$1$3((function(module,exports){exports.__esModule=!0,exports.isDefined=exports.isUndefined=exports.isFunction=void 0;var _typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj};exports.isString=isString,exports.isObject=isObject,exports.isHtmlElement=isHtmlElement;var _vue2=_interopRequireDefault(vue_runtime_esm["default"]);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function isString(obj){return"[object String]"===Object.prototype.toString.call(obj)}function isObject(obj){return"[object Object]"===Object.prototype.toString.call(obj)}function isHtmlElement(node){return node&&node.nodeType===Node.ELEMENT_NODE}
/**
 *  - Inspired:
 *    https://github.com/jashkenas/underscore/blob/master/modules/isFunction.js
 */var isFunction=function(functionToCheck){var getType={};return functionToCheck&&"[object Function]"===getType.toString.call(functionToCheck)};"object"===("undefined"===typeof Int8Array?"undefined":_typeof(Int8Array))||!_vue2.default.prototype.$isServer&&"function"===typeof document.childNodes||(exports.isFunction=isFunction=function(obj){return"function"===typeof obj||!1}),exports.isFunction=isFunction,exports.isUndefined=function(val){return void 0===val},exports.isDefined=function(val){return void 0!==val&&null!==val}})),util$3=createCommonjsModule$1$3((function(module,exports){exports.__esModule=!0,exports.isEmpty=exports.isEqual=exports.arrayEquals=exports.looseEqual=exports.capitalize=exports.kebabCase=exports.autoprefixer=exports.isFirefox=exports.isEdge=exports.isIE=exports.coerceTruthyValueToArray=exports.arrayFind=exports.arrayFindIndex=exports.escapeRegexpString=exports.valueEquals=exports.generateId=exports.getValueByPath=void 0;var _typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj};exports.noop=noop,exports.hasOwn=hasOwn,exports.toObject=toObject,exports.getPropByPath=getPropByPath,exports.rafThrottle=rafThrottle,exports.objToArray=objToArray;var _vue2=_interopRequireDefault(vue_runtime_esm["default"]);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}var hasOwnProperty=Object.prototype.hasOwnProperty;function noop(){}function hasOwn(obj,key){return hasOwnProperty.call(obj,key)}function extend(to,_from){for(var key in _from)to[key]=_from[key];return to}function toObject(arr){for(var res={},i=0;i<arr.length;i++)arr[i]&&extend(res,arr[i]);return res}function getPropByPath(obj,path,strict){var tempObj=obj;path=path.replace(/\[(\w+)\]/g,".$1"),path=path.replace(/^\./,"");for(var keyArr=path.split("."),i=0,len=keyArr.length;i<len-1;++i){if(!tempObj&&!strict)break;var key=keyArr[i];if(!(key in tempObj)){if(strict)throw new Error("please transfer a valid prop path to form item!");break}tempObj=tempObj[key]}return{o:tempObj,k:keyArr[i],v:tempObj?tempObj[keyArr[i]]:null}}exports.getValueByPath=function(object,prop){prop=prop||"";for(var paths=prop.split("."),current=object,result=null,i=0,j=paths.length;i<j;i++){var path=paths[i];if(!current)break;if(i===j-1){result=current[path];break}current=current[path]}return result},exports.generateId=function(){return Math.floor(1e4*Math.random())},exports.valueEquals=function(a,b){
// see: https://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript
if(a===b)return!0;if(!(a instanceof Array))return!1;if(!(b instanceof Array))return!1;if(a.length!==b.length)return!1;for(var i=0;i!==a.length;++i)if(a[i]!==b[i])return!1;return!0},exports.escapeRegexpString=function(){var value=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return String(value).replace(/[|\\{}()[\]^$+*?.]/g,"\\$&")};
// TODO: use native Array.find, Array.findIndex when IE support is dropped
var arrayFindIndex=exports.arrayFindIndex=function(arr,pred){for(var i=0;i!==arr.length;++i)if(pred(arr[i]))return i;return-1};exports.arrayFind=function(arr,pred){var idx=arrayFindIndex(arr,pred);return-1!==idx?arr[idx]:void 0},
// coerce truthy value to array
exports.coerceTruthyValueToArray=function(val){return Array.isArray(val)?val:val?[val]:[]},exports.isIE=function(){return!_vue2.default.prototype.$isServer&&!isNaN(Number(document.documentMode))},exports.isEdge=function(){return!_vue2.default.prototype.$isServer&&navigator.userAgent.indexOf("Edge")>-1},exports.isFirefox=function(){return!_vue2.default.prototype.$isServer&&!!window.navigator.userAgent.match(/firefox/i)},exports.autoprefixer=function(style){if("object"!==("undefined"===typeof style?"undefined":_typeof(style)))return style;var rules=["transform","transition","animation"],prefixes=["ms-","webkit-"];return rules.forEach((function(rule){var value=style[rule];rule&&value&&prefixes.forEach((function(prefix){style[prefix+rule]=value}))})),style},exports.kebabCase=function(str){var hyphenateRE=/([^-])([A-Z])/g;return str.replace(hyphenateRE,"$1-$2").replace(hyphenateRE,"$1-$2").toLowerCase()},exports.capitalize=function(str){return(0,types$3.isString)(str)?str.charAt(0).toUpperCase()+str.slice(1):str};var looseEqual=exports.looseEqual=function(a,b){var isObjectA=(0,types$3.isObject)(a),isObjectB=(0,types$3.isObject)(b);return isObjectA&&isObjectB?JSON.stringify(a)===JSON.stringify(b):!isObjectA&&!isObjectB&&String(a)===String(b)},arrayEquals=exports.arrayEquals=function(arrayA,arrayB){if(arrayA=arrayA||[],arrayB=arrayB||[],arrayA.length!==arrayB.length)return!1;for(var i=0;i<arrayA.length;i++)if(!looseEqual(arrayA[i],arrayB[i]))return!1;return!0};exports.isEqual=function(value1,value2){return Array.isArray(value1)&&Array.isArray(value2)?arrayEquals(value1,value2):looseEqual(value1,value2)};var isEmpty=exports.isEmpty=function(val){
// null or undefined
if(null==val)return!0;if("boolean"===typeof val)return!1;if("number"===typeof val)return!val;if(val instanceof Error)return""===val.message;switch(Object.prototype.toString.call(val)){
// String or Array
case"[object String]":case"[object Array]":return!val.length;
// Map or Set or File
case"[object File]":case"[object Map]":case"[object Set]":return!val.size;
// Plain Object
case"[object Object]":return!Object.keys(val).length}return!1};function rafThrottle(fn){var locked=!1;return function(){for(var _this=this,_len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];locked||(locked=!0,window.requestAnimationFrame((function(_){fn.apply(_this,args),locked=!1})))}}function objToArray(obj){return Array.isArray(obj)?obj:isEmpty(obj)?[]:[obj]}})),_typeof$3$3="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_default$5=function(Vue){
/**
   * template
   *
   * @param {String} string
   * @param {Array} ...args
   * @return {String}
   */
function template(string){for(var _len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];return 1===args.length&&"object"===_typeof$3$3(args[0])&&(args=args[0]),args&&args.hasOwnProperty||(args={}),string.replace(RE_NARGS$3,(function(match,prefix,i,index){var result=void 0;return"{"===string[index-1]&&"}"===string[index+match.length]?i:(result=(0,util$3.hasOwn)(args,i)?args[i]:null,null===result||void 0===result?"":result)}))}return template},RE_NARGS$3=/(%|)\{([0-9a-zA-Z_]+)\}/g,format$3=Object.defineProperty({default:_default$5},"__esModule",{value:!0}),_deepmerge$3=getAugmentedNamespace$3(es$3),locale$4=createCommonjsModule$1$3((function(module,exports){exports.__esModule=!0,exports.i18n=exports.use=exports.t=void 0;var _zhCN2=_interopRequireDefault(zhCN$3),_vue2=_interopRequireDefault(vue_runtime_esm["default"]),_deepmerge2=_interopRequireDefault(_deepmerge$3),_format2=_interopRequireDefault(format$3);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}var format$1=(0,_format2.default)(_vue2.default),lang=_zhCN2.default,merged=!1,i18nHandler=function(){var vuei18n=Object.getPrototypeOf(this||_vue2.default).$t;if("function"===typeof vuei18n&&_vue2.default.locale)return merged||(merged=!0,_vue2.default.locale(_vue2.default.config.lang,(0,_deepmerge2.default)(lang,_vue2.default.locale(_vue2.default.config.lang)||{},{clone:!0}))),vuei18n.apply(this,arguments)},t=exports.t=function(path,options){var value=i18nHandler.apply(this,arguments);if(null!==value&&void 0!==value)return value;for(var array=path.split("."),current=lang,i=0,j=array.length;i<j;i++){var property=array[i];if(value=current[property],i===j-1)return format$1(value,options);if(!value)return"";current=value}return""},use=exports.use=function(l){lang=l||lang},i18n=exports.i18n=function(fn){i18nHandler=fn||i18nHandler};exports.default={use:use,t:t,i18n:i18n}})),locale$1$3=getDefaultExportFromCjs$3(locale$4);
locale$1$3.use(_default$2$3);var script$6$3={name:"Datepicker",props:["appendToBody","value","value-format","format","default-value","placeholder","disabled","editable","picker-options","type","prefix-icon","clear-icon","start-placeholder","end-placeholder","hideClear","account"],components:{DatePicker:element_ui_common.DatePicker},mounted(){this.init()},data(){return{timeinorg:[]}},computed:{isRangeType(){let{type:type}=this||{};return["daterange","datetimerange"].includes(type)},defaultFormats(){let{timeformat:timeformat,dateformat:dateformat}=this;return dateformat=dateformat.replaceAll("Y","y"),dateformat=dateformat.replaceAll("D","d"),{date:dateformat,month:"yyyy-MM",datetime:`${dateformat} ${timeformat}`,time:`${timeformat}`,week:"yyyywWW",timerange:`${timeformat}`,daterange:`${dateformat}`,monthrange:"yyyy-MM",datetimerange:`${dateformat} ${timeformat}`,year:"yyyy"}},pickerFormat(){let{defaultFormats:defaultFormats,type:type,format:format}=this||{};return isEmpty$8(format)&&!isEmpty$8(defaultFormats[type])?defaultFormats[type]:format},ttime:{get(){let{value:value,isRangeType:isRangeType}=this||{};return isEmpty$8(value)?isRangeType?[]:"":isRangeType?value.map((val=>this.getTimeInSystemZone(val))):this.getTimeInSystemZone(value)},set(value){let{isRangeType:isRangeType}=this,timeInOrg=[];if(isRangeType){if(isEmpty$8(value))timeInOrg=[];else for(let time in value)timeInOrg[time]=this.getDateInOrg(value[time]);this.$emit("input",timeInOrg),this.$emit("change",timeInOrg)}else{let modifiedTimeFormat=this.getDateInOrg(value);this.$emit("input",modifiedTimeFormat),this.$emit("change",modifiedTimeFormat)}}},dateformat(){let{account:account={}}=this||{},dateFormat=dlv_umd(account,"org.dateFormat","DD-MMM-YYYY");return dateFormat||"DD-MMM-YYYY"},timeformat(){let{account:account={}}=this||{},timeFormat=dlv_umd(account,"org.timeFormat");return 2===timeFormat?"hh:mm A":"HH:mm"},timezone(){let timezone,{account:account={}}=this||{};if((account||{}).timezone){let{timezone:accountTimeZone}=account||{};timezone=accountTimeZone||"Etc/UTC"}else{let orgTimeZone=dlv_umd(account,"org.timezone");timezone=orgTimeZone||"Etc/UTC"}return timezone}},methods:{init(){let{isRangeType:isRangeType,value:value}=this,timeInOrg=[];if(isRangeType){if(isEmpty$8(value))timeInOrg=[];else for(let time in value){let timeVal=parseInt(value[time]);timeInOrg[time]=this.getDateInOrg(timeVal)}this.$emit("input",timeInOrg)}else if(!isEmpty$8(value)){let isPlaceHoldersEnabled=Constants$2.FIELD_PLACEHOLDERS.includes(value)||!1;isPlaceHoldersEnabled||this.$emit("input",this.getDateInOrg(parseInt(value)))}this.$emit("initialized")},focus(){this.$refs["date-picker"].focus()},getTimeInSystemZone(value){let{timezone:timezone}=this||{};return new Date(moment_timezone.tz(value,timezone||"Etc/UTC").format("YYYY-MM-DD HH:mm:ss"))},getDateInOrg(date){let{timezone:timezone}=this||{};return moment_timezone.tz(moment_timezone(date).format("YYYY-MM-DD HH:mm:ss"),timezone).valueOf()}}};
/* script */const __vue_script__$6$3=script$6$3;
/* template */var __vue_render__$6$3=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"f-ui-forms"},[_c("DatePicker",{ref:"date-picker",staticClass:"f-ui-date-picker",attrs:{appendToBody:_vm.appendToBody,clearable:!_vm.hideClear,type:_vm.type,"value-format":_vm.valueFormat,format:_vm.pickerFormat,placeholder:_vm.placeholder,disabled:_vm.disabled,editable:_vm.editable,"default-value":_vm.defaultValue,"picker-options":_vm.pickerOptions,"prefix-icon":_vm.prefixIcon,"clear-icon":_vm.clearIcon,"start-placeholder":_vm.startPlaceholder,"end-placeholder":_vm.endPlaceholder,"popper-class":"f-date-picker-popper"},model:{value:_vm.ttime,callback:function($$v){_vm.ttime=$$v},expression:"ttime"}})],1)},__vue_staticRenderFns__$6$3=[];
/* style */
const __vue_inject_styles__$6$3=void 0,__vue_scope_id__$6$3=void 0,__vue_module_identifier__$6$3=void 0,__vue_is_functional_template__$6$3=!1,__vue_component__$5$3=normalizeComponent$7({render:__vue_render__$6$3,staticRenderFns:__vue_staticRenderFns__$6$3},__vue_inject_styles__$6$3,__vue_script__$6$3,__vue_scope_id__$6$3,__vue_is_functional_template__$6$3,__vue_module_identifier__$6$3,!1,void 0,void 0,void 0);
/* scoped */
/*! @license DOMPurify 2.3.10 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.10/LICENSE */
function _typeof$2$3(obj){return _typeof$2$3="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof$2$3(obj)}function _setPrototypeOf$3(o,p){return _setPrototypeOf$3=Object.setPrototypeOf||function(o,p){return o.__proto__=p,o},_setPrototypeOf$3(o,p)}function _isNativeReflectConstruct$3(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}function _construct$3(Parent,args,Class){return _construct$3=_isNativeReflectConstruct$3()?Reflect.construct:function(Parent,args,Class){var a=[null];a.push.apply(a,args);var Constructor=Function.bind.apply(Parent,a),instance=new Constructor;return Class&&_setPrototypeOf$3(instance,Class.prototype),instance},_construct$3.apply(null,arguments)}function _toConsumableArray$4(arr){return _arrayWithoutHoles$4(arr)||_iterableToArray$4(arr)||_unsupportedIterableToArray$4(arr)||_nonIterableSpread$4()}function _arrayWithoutHoles$4(arr){if(Array.isArray(arr))return _arrayLikeToArray$4(arr)}function _iterableToArray$4(iter){if("undefined"!==typeof Symbol&&null!=iter[Symbol.iterator]||null!=iter["@@iterator"])return Array.from(iter)}function _unsupportedIterableToArray$4(o,minLen){if(o){if("string"===typeof o)return _arrayLikeToArray$4(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);return"Object"===n&&o.constructor&&(n=o.constructor.name),"Map"===n||"Set"===n?Array.from(o):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?_arrayLikeToArray$4(o,minLen):void 0}}function _arrayLikeToArray$4(arr,len){(null==len||len>arr.length)&&(len=arr.length);for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2}function _nonIterableSpread$4(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var hasOwnProperty$1$3=Object.hasOwnProperty,setPrototypeOf$3=Object.setPrototypeOf,isFrozen$3=Object.isFrozen,getPrototypeOf$3=Object.getPrototypeOf,getOwnPropertyDescriptor$3=Object.getOwnPropertyDescriptor,freeze$3=Object.freeze,seal$3=Object.seal,create$3=Object.create,_ref$3="undefined"!==typeof Reflect&&Reflect,apply$1$3=_ref$3.apply,construct$3=_ref$3.construct;apply$1$3||(apply$1$3=function(fun,thisValue,args){return fun.apply(thisValue,args)}),freeze$3||(freeze$3=function(x){return x}),seal$3||(seal$3=function(x){return x}),construct$3||(construct$3=function(Func,args){return _construct$3(Func,_toConsumableArray$4(args))});var arrayForEach$3=unapply$3(Array.prototype.forEach),arrayPop$3=unapply$3(Array.prototype.pop),arrayPush$3=unapply$3(Array.prototype.push),stringToLowerCase$3=unapply$3(String.prototype.toLowerCase),stringMatch$3=unapply$3(String.prototype.match),stringReplace$3=unapply$3(String.prototype.replace),stringIndexOf$3=unapply$3(String.prototype.indexOf),stringTrim$3=unapply$3(String.prototype.trim),regExpTest$3=unapply$3(RegExp.prototype.test),typeErrorCreate$3=unconstruct$3(TypeError);function unapply$3(func){return function(thisArg){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];return apply$1$3(func,thisArg,args)}}function unconstruct$3(func){return function(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++)args[_key2]=arguments[_key2];return construct$3(func,args)}}
/* Add properties to a lookup table */function addToSet$3(set,array,transformCaseFunc){transformCaseFunc=transformCaseFunc||stringToLowerCase$3,setPrototypeOf$3&&
// Make 'in' and truthy checks like Boolean(set.constructor)
// independent of any properties defined on Object.prototype.
// Prevent prototype setters from intercepting set as a this value.
setPrototypeOf$3(set,null);var l=array.length;while(l--){var element=array[l];if("string"===typeof element){var lcElement=transformCaseFunc(element);lcElement!==element&&(
// Config presets (e.g. tags.js, attrs.js) are immutable.
isFrozen$3(array)||(array[l]=lcElement),element=lcElement)}set[element]=!0}return set}
/* Shallow clone an object */function clone$3(object){var property,newObject=create$3(null);for(property in object)apply$1$3(hasOwnProperty$1$3,object,[property])&&(newObject[property]=object[property]);return newObject}
/* IE10 doesn't support __lookupGetter__ so lets'
 * simulate it. It also automatically checks
 * if the prop is function or getter and behaves
 * accordingly. */function lookupGetter$3(object,prop){while(null!==object){var desc=getOwnPropertyDescriptor$3(object,prop);if(desc){if(desc.get)return unapply$3(desc.get);if("function"===typeof desc.value)return unapply$3(desc.value)}object=getPrototypeOf$3(object)}function fallbackValue(element){return null}return fallbackValue}var html$1$3=freeze$3(["a","abbr","acronym","address","area","article","aside","audio","b","bdi","bdo","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","content","data","datalist","dd","decorator","del","details","dfn","dialog","dir","div","dl","dt","element","em","fieldset","figcaption","figure","font","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","img","input","ins","kbd","label","legend","li","main","map","mark","marquee","menu","menuitem","meter","nav","nobr","ol","optgroup","option","output","p","picture","pre","progress","q","rp","rt","ruby","s","samp","section","select","shadow","small","source","spacer","span","strike","strong","style","sub","summary","sup","table","tbody","td","template","textarea","tfoot","th","thead","time","tr","track","tt","u","ul","var","video","wbr"]),svg$1$3=freeze$3(["svg","a","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","circle","clippath","defs","desc","ellipse","filter","font","g","glyph","glyphref","hkern","image","line","lineargradient","marker","mask","metadata","mpath","path","pattern","polygon","polyline","radialgradient","rect","stop","style","switch","symbol","text","textpath","title","tref","tspan","view","vkern"]),svgFilters$3=freeze$3(["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]),svgDisallowed$3=freeze$3(["animate","color-profile","cursor","discard","fedropshadow","font-face","font-face-format","font-face-name","font-face-src","font-face-uri","foreignobject","hatch","hatchpath","mesh","meshgradient","meshpatch","meshrow","missing-glyph","script","set","solidcolor","unknown","use"]),mathMl$1$3=freeze$3(["math","menclose","merror","mfenced","mfrac","mglyph","mi","mlabeledtr","mmultiscripts","mn","mo","mover","mpadded","mphantom","mroot","mrow","ms","mspace","msqrt","mstyle","msub","msup","msubsup","mtable","mtd","mtext","mtr","munder","munderover"]),mathMlDisallowed$3=freeze$3(["maction","maligngroup","malignmark","mlongdiv","mscarries","mscarry","msgroup","mstack","msline","msrow","semantics","annotation","annotation-xml","mprescripts","none"]),text$1=freeze$3(["#text"]),html$4=freeze$3(["accept","action","align","alt","autocapitalize","autocomplete","autopictureinpicture","autoplay","background","bgcolor","border","capture","cellpadding","cellspacing","checked","cite","class","clear","color","cols","colspan","controls","controlslist","coords","crossorigin","datetime","decoding","default","dir","disabled","disablepictureinpicture","disableremoteplayback","download","draggable","enctype","enterkeyhint","face","for","headers","height","hidden","high","href","hreflang","id","inputmode","integrity","ismap","kind","label","lang","list","loading","loop","low","max","maxlength","media","method","min","minlength","multiple","muted","name","nonce","noshade","novalidate","nowrap","open","optimum","pattern","placeholder","playsinline","poster","preload","pubdate","radiogroup","readonly","rel","required","rev","reversed","role","rows","rowspan","spellcheck","scope","selected","shape","size","sizes","span","srclang","start","src","srcset","step","style","summary","tabindex","title","translate","type","usemap","valign","value","width","xmlns","slot"]),svg$4=freeze$3(["accent-height","accumulate","additive","alignment-baseline","ascent","attributename","attributetype","azimuth","basefrequency","baseline-shift","begin","bias","by","class","clip","clippathunits","clip-path","clip-rule","color","color-interpolation","color-interpolation-filters","color-profile","color-rendering","cx","cy","d","dx","dy","diffuseconstant","direction","display","divisor","dur","edgemode","elevation","end","fill","fill-opacity","fill-rule","filter","filterunits","flood-color","flood-opacity","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","fx","fy","g1","g2","glyph-name","glyphref","gradientunits","gradienttransform","height","href","id","image-rendering","in","in2","k","k1","k2","k3","k4","kerning","keypoints","keysplines","keytimes","lang","lengthadjust","letter-spacing","kernelmatrix","kernelunitlength","lighting-color","local","marker-end","marker-mid","marker-start","markerheight","markerunits","markerwidth","maskcontentunits","maskunits","max","mask","media","method","mode","min","name","numoctaves","offset","operator","opacity","order","orient","orientation","origin","overflow","paint-order","path","pathlength","patterncontentunits","patterntransform","patternunits","points","preservealpha","preserveaspectratio","primitiveunits","r","rx","ry","radius","refx","refy","repeatcount","repeatdur","restart","result","rotate","scale","seed","shape-rendering","specularconstant","specularexponent","spreadmethod","startoffset","stddeviation","stitchtiles","stop-color","stop-opacity","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke","stroke-width","style","surfacescale","systemlanguage","tabindex","targetx","targety","transform","transform-origin","text-anchor","text-decoration","text-rendering","textlength","type","u1","u2","unicode","values","viewbox","visibility","version","vert-adv-y","vert-origin-x","vert-origin-y","width","word-spacing","wrap","writing-mode","xchannelselector","ychannelselector","x","x1","x2","xmlns","y","y1","y2","z","zoomandpan"]),mathMl$4=freeze$3(["accent","accentunder","align","bevelled","close","columnsalign","columnlines","columnspan","denomalign","depth","dir","display","displaystyle","encoding","fence","frame","height","href","id","largeop","length","linethickness","lspace","lquote","mathbackground","mathcolor","mathsize","mathvariant","maxsize","minsize","movablelimits","notation","numalign","open","rowalign","rowlines","rowspacing","rowspan","rspace","rquote","scriptlevel","scriptminsize","scriptsizemultiplier","selection","separator","separators","stretchy","subscriptshift","supscriptshift","symmetric","voffset","width","xmlns"]),xml$3=freeze$3(["xlink:href","xml:id","xlink:title","xml:space","xmlns:xlink"]),MUSTACHE_EXPR$3=seal$3(/\{\{[\w\W]*|[\w\W]*\}\}/gm),ERB_EXPR$3=seal$3(/<%[\w\W]*|[\w\W]*%>/gm),DATA_ATTR$3=seal$3(/^data-[\-\w.\u00B7-\uFFFF]/),ARIA_ATTR$3=seal$3(/^aria-[\-\w]+$/),IS_ALLOWED_URI$3=seal$3(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i),IS_SCRIPT_OR_DATA$3=seal$3(/^(?:\w+script|data):/i),ATTR_WHITESPACE$3=seal$3(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),DOCTYPE_NAME$3=seal$3(/^html$/i),getGlobal$3=function(){return"undefined"===typeof window?null:window},_createTrustedTypesPolicy$3=function(trustedTypes,document){if("object"!==_typeof$2$3(trustedTypes)||"function"!==typeof trustedTypes.createPolicy)return null;// Allow the callers to control the unique policy name
// by adding a data-tt-policy-suffix to the script element with the DOMPurify.
// Policy creation with duplicate names throws in Trusted Types.
var suffix=null,ATTR_NAME="data-tt-policy-suffix";document.currentScript&&document.currentScript.hasAttribute(ATTR_NAME)&&(suffix=document.currentScript.getAttribute(ATTR_NAME));var policyName="dompurify"+(suffix?"#"+suffix:"");try{return trustedTypes.createPolicy(policyName,{createHTML:function(html){return html},createScriptURL:function(scriptUrl){return scriptUrl}})}catch(_){return null}};// SVG
function createDOMPurify$3(){var window=arguments.length>0&&void 0!==arguments[0]?arguments[0]:getGlobal$3(),DOMPurify=function(root){return createDOMPurify$3(root)};if(
/**
   * Version label, exposed for easier checks
   * if DOMPurify is up to date or not
   */
DOMPurify.version="2.3.10",
/**
   * Array of elements that DOMPurify removed during sanitation.
   * Empty if nothing was removed.
   */
DOMPurify.removed=[],!window||!window.document||9!==window.document.nodeType)
// Not running in a browser, provide a factory function
// so that you can pass your own Window
return DOMPurify.isSupported=!1,DOMPurify;var originalDocument=window.document,document=window.document,DocumentFragment=window.DocumentFragment,HTMLTemplateElement=window.HTMLTemplateElement,Node=window.Node,Element=window.Element,NodeFilter=window.NodeFilter,_window$NamedNodeMap=window.NamedNodeMap,NamedNodeMap=void 0===_window$NamedNodeMap?window.NamedNodeMap||window.MozNamedAttrMap:_window$NamedNodeMap,HTMLFormElement=window.HTMLFormElement,DOMParser=window.DOMParser,trustedTypes=window.trustedTypes,ElementPrototype=Element.prototype,cloneNode=lookupGetter$3(ElementPrototype,"cloneNode"),getNextSibling=lookupGetter$3(ElementPrototype,"nextSibling"),getChildNodes=lookupGetter$3(ElementPrototype,"childNodes"),getParentNode=lookupGetter$3(ElementPrototype,"parentNode");// As per issue #47, the web-components registry is inherited by a
// new document created via createHTMLDocument. As per the spec
// (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
// a new empty registry is used when creating a template contents owner
// document, so we use that as our parent document to ensure nothing
// is inherited.
if("function"===typeof HTMLTemplateElement){var template=document.createElement("template");template.content&&template.content.ownerDocument&&(document=template.content.ownerDocument)}var trustedTypesPolicy=_createTrustedTypesPolicy$3(trustedTypes,originalDocument),emptyHTML=trustedTypesPolicy?trustedTypesPolicy.createHTML(""):"",_document=document,implementation=_document.implementation,createNodeIterator=_document.createNodeIterator,createDocumentFragment=_document.createDocumentFragment,getElementsByTagName=_document.getElementsByTagName,importNode=originalDocument.importNode,documentMode={};try{documentMode=clone$3(document).documentMode?document.documentMode:{}}catch(_){}var hooks={};
/**
   * Expose whether this browser supports running the full DOMPurify.
   */DOMPurify.isSupported="function"===typeof getParentNode&&implementation&&"undefined"!==typeof implementation.createHTMLDocument&&9!==documentMode;var PARSER_MEDIA_TYPE,transformCaseFunc,MUSTACHE_EXPR$1=MUSTACHE_EXPR$3,ERB_EXPR$1=ERB_EXPR$3,DATA_ATTR$1=DATA_ATTR$3,ARIA_ATTR$1=ARIA_ATTR$3,IS_SCRIPT_OR_DATA$1=IS_SCRIPT_OR_DATA$3,ATTR_WHITESPACE$1=ATTR_WHITESPACE$3,IS_ALLOWED_URI$1=IS_ALLOWED_URI$3,ALLOWED_TAGS=null,DEFAULT_ALLOWED_TAGS=addToSet$3({},[].concat(_toConsumableArray$4(html$1$3),_toConsumableArray$4(svg$1$3),_toConsumableArray$4(svgFilters$3),_toConsumableArray$4(mathMl$1$3),_toConsumableArray$4(text$1))),ALLOWED_ATTR=null,DEFAULT_ALLOWED_ATTR=addToSet$3({},[].concat(_toConsumableArray$4(html$4),_toConsumableArray$4(svg$4),_toConsumableArray$4(mathMl$4),_toConsumableArray$4(xml$3))),CUSTOM_ELEMENT_HANDLING=Object.seal(Object.create(null,{tagNameCheck:{writable:!0,configurable:!1,enumerable:!0,value:null},attributeNameCheck:{writable:!0,configurable:!1,enumerable:!0,value:null},allowCustomizedBuiltInElements:{writable:!0,configurable:!1,enumerable:!0,value:!1}})),FORBID_TAGS=null,FORBID_ATTR=null,ALLOW_ARIA_ATTR=!0,ALLOW_DATA_ATTR=!0,ALLOW_UNKNOWN_PROTOCOLS=!1,SAFE_FOR_TEMPLATES=!1,WHOLE_DOCUMENT=!1,SET_CONFIG=!1,FORCE_BODY=!1,RETURN_DOM=!1,RETURN_DOM_FRAGMENT=!1,RETURN_TRUSTED_TYPE=!1,SANITIZE_DOM=!0,KEEP_CONTENT=!0,IN_PLACE=!1,USE_PROFILES={},FORBID_CONTENTS=null,DEFAULT_FORBID_CONTENTS=addToSet$3({},["annotation-xml","audio","colgroup","desc","foreignobject","head","iframe","math","mi","mn","mo","ms","mtext","noembed","noframes","noscript","plaintext","script","style","svg","template","thead","title","video","xmp"]),DATA_URI_TAGS=null,DEFAULT_DATA_URI_TAGS=addToSet$3({},["audio","video","img","source","image","track"]),URI_SAFE_ATTRIBUTES=null,DEFAULT_URI_SAFE_ATTRIBUTES=addToSet$3({},["alt","class","for","id","label","name","pattern","placeholder","role","summary","title","value","style","xmlns"]),MATHML_NAMESPACE="http://www.w3.org/1998/Math/MathML",SVG_NAMESPACE="http://www.w3.org/2000/svg",HTML_NAMESPACE="http://www.w3.org/1999/xhtml",NAMESPACE=HTML_NAMESPACE,IS_EMPTY_INPUT=!1,SUPPORTED_PARSER_MEDIA_TYPES=["application/xhtml+xml","text/html"],DEFAULT_PARSER_MEDIA_TYPE="text/html",CONFIG=null,formElement=document.createElement("form"),isRegexOrFunction=function(testValue){return testValue instanceof RegExp||testValue instanceof Function},_parseConfig=function(cfg){CONFIG&&CONFIG===cfg||(
/* Shield configuration object from tampering */
cfg&&"object"===_typeof$2$3(cfg)||(cfg={})
/* Shield configuration object from prototype pollution */,cfg=clone$3(cfg),PARSER_MEDIA_TYPE=// eslint-disable-next-line unicorn/prefer-includes
PARSER_MEDIA_TYPE=-1===SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE)?DEFAULT_PARSER_MEDIA_TYPE:cfg.PARSER_MEDIA_TYPE,// HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
transformCaseFunc="application/xhtml+xml"===PARSER_MEDIA_TYPE?function(x){return x}:stringToLowerCase$3,
/* Set configuration parameters */
ALLOWED_TAGS="ALLOWED_TAGS"in cfg?addToSet$3({},cfg.ALLOWED_TAGS,transformCaseFunc):DEFAULT_ALLOWED_TAGS,ALLOWED_ATTR="ALLOWED_ATTR"in cfg?addToSet$3({},cfg.ALLOWED_ATTR,transformCaseFunc):DEFAULT_ALLOWED_ATTR,URI_SAFE_ATTRIBUTES="ADD_URI_SAFE_ATTR"in cfg?addToSet$3(clone$3(DEFAULT_URI_SAFE_ATTRIBUTES),// eslint-disable-line indent
cfg.ADD_URI_SAFE_ATTR,// eslint-disable-line indent
transformCaseFunc):DEFAULT_URI_SAFE_ATTRIBUTES,DATA_URI_TAGS="ADD_DATA_URI_TAGS"in cfg?addToSet$3(clone$3(DEFAULT_DATA_URI_TAGS),// eslint-disable-line indent
cfg.ADD_DATA_URI_TAGS,// eslint-disable-line indent
transformCaseFunc):DEFAULT_DATA_URI_TAGS,FORBID_CONTENTS="FORBID_CONTENTS"in cfg?addToSet$3({},cfg.FORBID_CONTENTS,transformCaseFunc):DEFAULT_FORBID_CONTENTS,FORBID_TAGS="FORBID_TAGS"in cfg?addToSet$3({},cfg.FORBID_TAGS,transformCaseFunc):{},FORBID_ATTR="FORBID_ATTR"in cfg?addToSet$3({},cfg.FORBID_ATTR,transformCaseFunc):{},USE_PROFILES="USE_PROFILES"in cfg&&cfg.USE_PROFILES,ALLOW_ARIA_ATTR=!1!==cfg.ALLOW_ARIA_ATTR,// Default true
ALLOW_DATA_ATTR=!1!==cfg.ALLOW_DATA_ATTR,// Default true
ALLOW_UNKNOWN_PROTOCOLS=cfg.ALLOW_UNKNOWN_PROTOCOLS||!1,// Default false
SAFE_FOR_TEMPLATES=cfg.SAFE_FOR_TEMPLATES||!1,// Default false
WHOLE_DOCUMENT=cfg.WHOLE_DOCUMENT||!1,// Default false
RETURN_DOM=cfg.RETURN_DOM||!1,// Default false
RETURN_DOM_FRAGMENT=cfg.RETURN_DOM_FRAGMENT||!1,// Default false
RETURN_TRUSTED_TYPE=cfg.RETURN_TRUSTED_TYPE||!1,// Default false
FORCE_BODY=cfg.FORCE_BODY||!1,// Default false
SANITIZE_DOM=!1!==cfg.SANITIZE_DOM,// Default true
KEEP_CONTENT=!1!==cfg.KEEP_CONTENT,// Default true
IN_PLACE=cfg.IN_PLACE||!1,// Default false
IS_ALLOWED_URI$1=cfg.ALLOWED_URI_REGEXP||IS_ALLOWED_URI$1,NAMESPACE=cfg.NAMESPACE||HTML_NAMESPACE,cfg.CUSTOM_ELEMENT_HANDLING&&isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)&&(CUSTOM_ELEMENT_HANDLING.tagNameCheck=cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck),cfg.CUSTOM_ELEMENT_HANDLING&&isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)&&(CUSTOM_ELEMENT_HANDLING.attributeNameCheck=cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck),cfg.CUSTOM_ELEMENT_HANDLING&&"boolean"===typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements&&(CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements=cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements),SAFE_FOR_TEMPLATES&&(ALLOW_DATA_ATTR=!1),RETURN_DOM_FRAGMENT&&(RETURN_DOM=!0)
/* Parse profile info */,USE_PROFILES&&(ALLOWED_TAGS=addToSet$3({},_toConsumableArray$4(text$1)),ALLOWED_ATTR=[],!0===USE_PROFILES.html&&(addToSet$3(ALLOWED_TAGS,html$1$3),addToSet$3(ALLOWED_ATTR,html$4)),!0===USE_PROFILES.svg&&(addToSet$3(ALLOWED_TAGS,svg$1$3),addToSet$3(ALLOWED_ATTR,svg$4),addToSet$3(ALLOWED_ATTR,xml$3)),!0===USE_PROFILES.svgFilters&&(addToSet$3(ALLOWED_TAGS,svgFilters$3),addToSet$3(ALLOWED_ATTR,svg$4),addToSet$3(ALLOWED_ATTR,xml$3)),!0===USE_PROFILES.mathMl&&(addToSet$3(ALLOWED_TAGS,mathMl$1$3),addToSet$3(ALLOWED_ATTR,mathMl$4),addToSet$3(ALLOWED_ATTR,xml$3)))
/* Merge configuration parameters */,cfg.ADD_TAGS&&(ALLOWED_TAGS===DEFAULT_ALLOWED_TAGS&&(ALLOWED_TAGS=clone$3(ALLOWED_TAGS)),addToSet$3(ALLOWED_TAGS,cfg.ADD_TAGS,transformCaseFunc)),cfg.ADD_ATTR&&(ALLOWED_ATTR===DEFAULT_ALLOWED_ATTR&&(ALLOWED_ATTR=clone$3(ALLOWED_ATTR)),addToSet$3(ALLOWED_ATTR,cfg.ADD_ATTR,transformCaseFunc)),cfg.ADD_URI_SAFE_ATTR&&addToSet$3(URI_SAFE_ATTRIBUTES,cfg.ADD_URI_SAFE_ATTR,transformCaseFunc),cfg.FORBID_CONTENTS&&(FORBID_CONTENTS===DEFAULT_FORBID_CONTENTS&&(FORBID_CONTENTS=clone$3(FORBID_CONTENTS)),addToSet$3(FORBID_CONTENTS,cfg.FORBID_CONTENTS,transformCaseFunc))
/* Add #text in case KEEP_CONTENT is set to true */,KEEP_CONTENT&&(ALLOWED_TAGS["#text"]=!0)
/* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */,WHOLE_DOCUMENT&&addToSet$3(ALLOWED_TAGS,["html","head","body"])
/* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */,ALLOWED_TAGS.table&&(addToSet$3(ALLOWED_TAGS,["tbody"]),delete FORBID_TAGS.tbody),// Prevent further manipulation of configuration.
// Not available in IE8, Safari 5, etc.
freeze$3&&freeze$3(cfg),CONFIG=cfg)},MATHML_TEXT_INTEGRATION_POINTS=addToSet$3({},["mi","mo","mn","ms","mtext"]),HTML_INTEGRATION_POINTS=addToSet$3({},["foreignobject","desc","title","annotation-xml"]),COMMON_SVG_AND_HTML_ELEMENTS=addToSet$3({},["title","style","font","a","script"]),ALL_SVG_TAGS=addToSet$3({},svg$1$3);addToSet$3(ALL_SVG_TAGS,svgFilters$3),addToSet$3(ALL_SVG_TAGS,svgDisallowed$3);var ALL_MATHML_TAGS=addToSet$3({},mathMl$1$3);addToSet$3(ALL_MATHML_TAGS,mathMlDisallowed$3);
/**
   *
   *
   * @param  {Element} element a DOM element whose namespace is being checked
   * @returns {boolean} Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */
var _checkValidNamespace=function(element){var parent=getParentNode(element);// In JSDOM, if we're inside shadow DOM, then parentNode
// can be null. We just simulate parent in this case.
parent&&parent.tagName||(parent={namespaceURI:HTML_NAMESPACE,tagName:"template"});var tagName=stringToLowerCase$3(element.tagName),parentTagName=stringToLowerCase$3(parent.tagName);return element.namespaceURI===SVG_NAMESPACE?
// The only way to switch from HTML namespace to SVG
// is via <svg>. If it happens via any other tag, then
// it should be killed.
parent.namespaceURI===HTML_NAMESPACE?"svg"===tagName:// The only way to switch from MathML to SVG is via
// svg if parent is either <annotation-xml> or MathML
// text integration points.
parent.namespaceURI===MATHML_NAMESPACE?"svg"===tagName&&("annotation-xml"===parentTagName||MATHML_TEXT_INTEGRATION_POINTS[parentTagName]):Boolean(ALL_SVG_TAGS[tagName]):element.namespaceURI===MATHML_NAMESPACE?
// The only way to switch from HTML namespace to MathML
// is via <math>. If it happens via any other tag, then
// it should be killed.
parent.namespaceURI===HTML_NAMESPACE?"math"===tagName:// The only way to switch from SVG to MathML is via
// <math> and HTML integration points
parent.namespaceURI===SVG_NAMESPACE?"math"===tagName&&HTML_INTEGRATION_POINTS[parentTagName]:Boolean(ALL_MATHML_TAGS[tagName]):element.namespaceURI===HTML_NAMESPACE&&(
// The only way to switch from SVG to HTML is via
// HTML integration points, and from MathML to HTML
// is via MathML text integration points
!(parent.namespaceURI===SVG_NAMESPACE&&!HTML_INTEGRATION_POINTS[parentTagName])&&(!(parent.namespaceURI===MATHML_NAMESPACE&&!MATHML_TEXT_INTEGRATION_POINTS[parentTagName])&&(!ALL_MATHML_TAGS[tagName]&&(COMMON_SVG_AND_HTML_ELEMENTS[tagName]||!ALL_SVG_TAGS[tagName]))))},_forceRemove=function(node){arrayPush$3(DOMPurify.removed,{element:node});try{
// eslint-disable-next-line unicorn/prefer-dom-node-remove
node.parentNode.removeChild(node)}catch(_){try{node.outerHTML=emptyHTML}catch(_){node.remove()}}},_removeAttribute=function(name,node){try{arrayPush$3(DOMPurify.removed,{attribute:node.getAttributeNode(name),from:node})}catch(_){arrayPush$3(DOMPurify.removed,{attribute:null,from:node})}// We void attribute values for unremovable "is"" attributes
if(node.removeAttribute(name),"is"===name&&!ALLOWED_ATTR[name])if(RETURN_DOM||RETURN_DOM_FRAGMENT)try{_forceRemove(node)}catch(_){}else try{node.setAttribute(name,"")}catch(_){}},_initDocument=function(dirty){
/* Create a HTML document */
var doc,leadingWhitespace;if(FORCE_BODY)dirty="<remove></remove>"+dirty;else{
/* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
var matches=stringMatch$3(dirty,/^[\r\n\t ]+/);leadingWhitespace=matches&&matches[0]}"application/xhtml+xml"===PARSER_MEDIA_TYPE&&(
// Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
dirty='<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>'+dirty+"</body></html>");var dirtyPayload=trustedTypesPolicy?trustedTypesPolicy.createHTML(dirty):dirty;
/*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */if(NAMESPACE===HTML_NAMESPACE)try{doc=(new DOMParser).parseFromString(dirtyPayload,PARSER_MEDIA_TYPE)}catch(_){}
/* Use createHTMLDocument in case DOMParser is not available */if(!doc||!doc.documentElement){doc=implementation.createDocument(NAMESPACE,"template",null);try{doc.documentElement.innerHTML=IS_EMPTY_INPUT?"":dirtyPayload}catch(_){// Syntax error if dirtyPayload is invalid xml
}}var body=doc.body||doc.documentElement;
/* Work on whole document or just its body */
return dirty&&leadingWhitespace&&body.insertBefore(document.createTextNode(leadingWhitespace),body.childNodes[0]||null),NAMESPACE===HTML_NAMESPACE?getElementsByTagName.call(doc,WHOLE_DOCUMENT?"html":"body")[0]:WHOLE_DOCUMENT?doc.documentElement:body},_createIterator=function(root){return createNodeIterator.call(root.ownerDocument||root,root,// eslint-disable-next-line no-bitwise
NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT|NodeFilter.SHOW_TEXT,null,!1)},_isClobbered=function(elm){return elm instanceof HTMLFormElement&&("string"!==typeof elm.nodeName||"string"!==typeof elm.textContent||"function"!==typeof elm.removeChild||!(elm.attributes instanceof NamedNodeMap)||"function"!==typeof elm.removeAttribute||"function"!==typeof elm.setAttribute||"string"!==typeof elm.namespaceURI||"function"!==typeof elm.insertBefore)},_isNode=function(object){return"object"===_typeof$2$3(Node)?object instanceof Node:object&&"object"===_typeof$2$3(object)&&"number"===typeof object.nodeType&&"string"===typeof object.nodeName},_executeHook=function(entryPoint,currentNode,data){hooks[entryPoint]&&arrayForEach$3(hooks[entryPoint],(function(hook){hook.call(DOMPurify,currentNode,data,CONFIG)}))},_sanitizeElements=function(currentNode){var content;
/* Execute a hook if present */
/* Check if element is clobbered or can clobber */
if(_executeHook("beforeSanitizeElements",currentNode,null),_isClobbered(currentNode))return _forceRemove(currentNode),!0;
/* Check if tagname contains Unicode */if(regExpTest$3(/[\u0080-\uFFFF]/,currentNode.nodeName))return _forceRemove(currentNode),!0;
/* Now let's check the element's type and name */var tagName=transformCaseFunc(currentNode.nodeName);
/* Execute a hook if present */
/* Detect mXSS attempts abusing namespace confusion */
if(_executeHook("uponSanitizeElement",currentNode,{tagName:tagName,allowedTags:ALLOWED_TAGS}),currentNode.hasChildNodes()&&!_isNode(currentNode.firstElementChild)&&(!_isNode(currentNode.content)||!_isNode(currentNode.content.firstElementChild))&&regExpTest$3(/<[/\w]/g,currentNode.innerHTML)&&regExpTest$3(/<[/\w]/g,currentNode.textContent))return _forceRemove(currentNode),!0;
/* Mitigate a problem with templates inside select */if("select"===tagName&&regExpTest$3(/<template/i,currentNode.innerHTML))return _forceRemove(currentNode),!0;
/* Remove element if anything forbids its presence */if(!ALLOWED_TAGS[tagName]||FORBID_TAGS[tagName]){
/* Check if we have a custom element to handle */
if(!FORBID_TAGS[tagName]&&_basicCustomElementTest(tagName)){if(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp&&regExpTest$3(CUSTOM_ELEMENT_HANDLING.tagNameCheck,tagName))return!1;if(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))return!1}
/* Keep content except for bad-listed elements */if(KEEP_CONTENT&&!FORBID_CONTENTS[tagName]){var parentNode=getParentNode(currentNode)||currentNode.parentNode,childNodes=getChildNodes(currentNode)||currentNode.childNodes;if(childNodes&&parentNode)for(var childCount=childNodes.length,i=childCount-1;i>=0;--i)parentNode.insertBefore(cloneNode(childNodes[i],!0),getNextSibling(currentNode))}return _forceRemove(currentNode),!0}
/* Check whether element has a valid namespace */return currentNode instanceof Element&&!_checkValidNamespace(currentNode)?(_forceRemove(currentNode),!0):"noscript"!==tagName&&"noembed"!==tagName||!regExpTest$3(/<\/no(script|embed)/i,currentNode.innerHTML)?(
/* Sanitize element content to be template-safe */
SAFE_FOR_TEMPLATES&&3===currentNode.nodeType&&(
/* Get the element's text content */
content=currentNode.textContent,content=stringReplace$3(content,MUSTACHE_EXPR$1," "),content=stringReplace$3(content,ERB_EXPR$1," "),currentNode.textContent!==content&&(arrayPush$3(DOMPurify.removed,{element:currentNode.cloneNode()}),currentNode.textContent=content))
/* Execute a hook if present */,_executeHook("afterSanitizeElements",currentNode,null),!1):(_forceRemove(currentNode),!0)},_isValidAttribute=function(lcTag,lcName,value){
/* Make sure attribute cannot clobber */
if(SANITIZE_DOM&&("id"===lcName||"name"===lcName)&&(value in document||value in formElement))return!1;
/* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */if(ALLOW_DATA_ATTR&&!FORBID_ATTR[lcName]&&regExpTest$3(DATA_ATTR$1,lcName));else if(ALLOW_ARIA_ATTR&&regExpTest$3(ARIA_ATTR$1,lcName));else if(!ALLOWED_ATTR[lcName]||FORBID_ATTR[lcName]){if(// First condition does a very basic check if a) it's basically a valid custom element tagname AND
// b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
// and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
!(_basicCustomElementTest(lcTag)&&(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp&&regExpTest$3(CUSTOM_ELEMENT_HANDLING.tagNameCheck,lcTag)||CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag))&&(CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp&&regExpTest$3(CUSTOM_ELEMENT_HANDLING.attributeNameCheck,lcName)||CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName))||// Alternative, second condition checks if it's an `is`-attribute, AND
// the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
"is"===lcName&&CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements&&(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp&&regExpTest$3(CUSTOM_ELEMENT_HANDLING.tagNameCheck,value)||CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))))return!1;
/* Check value is safe. First, is attr inert? If so, is safe */}else if(URI_SAFE_ATTRIBUTES[lcName]);else if(regExpTest$3(IS_ALLOWED_URI$1,stringReplace$3(value,ATTR_WHITESPACE$1,"")));else if("src"!==lcName&&"xlink:href"!==lcName&&"href"!==lcName||"script"===lcTag||0!==stringIndexOf$3(value,"data:")||!DATA_URI_TAGS[lcTag]){if(ALLOW_UNKNOWN_PROTOCOLS&&!regExpTest$3(IS_SCRIPT_OR_DATA$1,stringReplace$3(value,ATTR_WHITESPACE$1,"")));else if(value)return!1}else;return!0},_basicCustomElementTest=function(tagName){return tagName.indexOf("-")>0},_sanitizeAttributes=function(currentNode){var attr,value,lcName,l;
/* Execute a hook if present */
_executeHook("beforeSanitizeAttributes",currentNode,null);var attributes=currentNode.attributes;
/* Check if we have attributes; if not we might have a text node */if(attributes){var hookEvent={attrName:"",attrValue:"",keepAttr:!0,allowedAttributes:ALLOWED_ATTR};l=attributes.length;
/* Go backwards over all attributes; safely remove bad ones */
while(l--){attr=attributes[l];var _attr=attr,name=_attr.name,namespaceURI=_attr.namespaceURI;
/* Did the hooks approve of the attribute? */
if(value="value"===name?attr.value:stringTrim$3(attr.value),lcName=transformCaseFunc(name),
/* Execute a hook if present */
hookEvent.attrName=lcName,hookEvent.attrValue=value,hookEvent.keepAttr=!0,hookEvent.forceKeepAttr=void 0,// Allows developers to see this is a property they can set
_executeHook("uponSanitizeAttribute",currentNode,hookEvent),value=hookEvent.attrValue,!hookEvent.forceKeepAttr&&(
/* Remove attribute */
_removeAttribute(name,currentNode),hookEvent.keepAttr))
/* Work around a security issue in jQuery 3.0 */
if(regExpTest$3(/\/>/i,value))_removeAttribute(name,currentNode);else{
/* Sanitize attribute content to be template-safe */
SAFE_FOR_TEMPLATES&&(value=stringReplace$3(value,MUSTACHE_EXPR$1," "),value=stringReplace$3(value,ERB_EXPR$1," "))
/* Is `value` valid for this attribute? */;var lcTag=transformCaseFunc(currentNode.nodeName);if(_isValidAttribute(lcTag,lcName,value)){
/* Handle attributes that require Trusted Types */
if(trustedTypesPolicy&&"object"===_typeof$2$3(trustedTypes)&&"function"===typeof trustedTypes.getAttributeType)if(namespaceURI);else switch(trustedTypes.getAttributeType(lcTag,lcName)){case"TrustedHTML":value=trustedTypesPolicy.createHTML(value);break;case"TrustedScriptURL":value=trustedTypesPolicy.createScriptURL(value);break}
/* Handle invalid data-* attribute set by try-catching it */try{namespaceURI?currentNode.setAttributeNS(namespaceURI,name,value):
/* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
currentNode.setAttribute(name,value),arrayPop$3(DOMPurify.removed)}catch(_){}}}}
/* Execute a hook if present */_executeHook("afterSanitizeAttributes",currentNode,null)}},_sanitizeShadowDOM=function _sanitizeShadowDOM(fragment){var shadowNode,shadowIterator=_createIterator(fragment);
/* Execute a hook if present */
_executeHook("beforeSanitizeShadowDOM",fragment,null);while(shadowNode=shadowIterator.nextNode())
/* Execute a hook if present */
_executeHook("uponSanitizeShadowNode",shadowNode,null),
/* Sanitize tags and elements */
_sanitizeElements(shadowNode)||(
/* Deep shadow DOM detected */
shadowNode.content instanceof DocumentFragment&&_sanitizeShadowDOM(shadowNode.content)
/* Check attributes, sanitize if necessary */,_sanitizeAttributes(shadowNode));
/* Execute a hook if present */_executeHook("afterSanitizeShadowDOM",fragment,null)};
/**
   * _forceRemove
   *
   * @param  {Node} node a DOM node
   */
/**
   * Sanitize
   * Public method providing core sanitation functionality
   *
   * @param {String|Node} dirty string or DOM node
   * @param {Object} configuration object
   */
// eslint-disable-next-line complexity
return DOMPurify.sanitize=function(dirty,cfg){var body,importedNode,currentNode,oldNode,returnNode;
/* Stringify, in case dirty is an object */
if(
/* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
IS_EMPTY_INPUT=!dirty,IS_EMPTY_INPUT&&(dirty="\x3c!--\x3e"),"string"!==typeof dirty&&!_isNode(dirty)){
// eslint-disable-next-line no-negated-condition
if("function"!==typeof dirty.toString)throw typeErrorCreate$3("toString is not a function");if(dirty=dirty.toString(),"string"!==typeof dirty)throw typeErrorCreate$3("dirty is not a string, aborting")}
/* Check we can run. Otherwise fall back or ignore */if(!DOMPurify.isSupported){if("object"===_typeof$2$3(window.toStaticHTML)||"function"===typeof window.toStaticHTML){if("string"===typeof dirty)return window.toStaticHTML(dirty);if(_isNode(dirty))return window.toStaticHTML(dirty.outerHTML)}return dirty}
/* Assign config vars */if(SET_CONFIG||_parseConfig(cfg)
/* Clean up removed elements */,DOMPurify.removed=[],
/* Check if dirty is correctly typed for IN_PLACE */
"string"===typeof dirty&&(IN_PLACE=!1),IN_PLACE){
/* Do some early pre-sanitization to avoid unsafe root nodes */
if(dirty.nodeName){var tagName=transformCaseFunc(dirty.nodeName);if(!ALLOWED_TAGS[tagName]||FORBID_TAGS[tagName])throw typeErrorCreate$3("root node is forbidden and cannot be sanitized in-place")}}else if(dirty instanceof Node)
/* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
body=_initDocument("\x3c!----\x3e"),importedNode=body.ownerDocument.importNode(dirty,!0),1===importedNode.nodeType&&"BODY"===importedNode.nodeName||"HTML"===importedNode.nodeName?
/* Node is already a body, use as is */
body=importedNode:
// eslint-disable-next-line unicorn/prefer-dom-node-append
body.appendChild(importedNode);else{
/* Exit directly if we have nothing to do */
if(!RETURN_DOM&&!SAFE_FOR_TEMPLATES&&!WHOLE_DOCUMENT&&// eslint-disable-next-line unicorn/prefer-includes
-1===dirty.indexOf("<"))return trustedTypesPolicy&&RETURN_TRUSTED_TYPE?trustedTypesPolicy.createHTML(dirty):dirty;
/* Initialize the document to work on */
/* Check we have a DOM node from the data */
if(body=_initDocument(dirty),!body)return RETURN_DOM?null:RETURN_TRUSTED_TYPE?emptyHTML:""}
/* Remove first element node (ours) if FORCE_BODY is set */body&&FORCE_BODY&&_forceRemove(body.firstChild)
/* Get node iterator */;var nodeIterator=_createIterator(IN_PLACE?dirty:body);
/* Now start iterating over the created document */while(currentNode=nodeIterator.nextNode())
/* Fix IE's strange behavior with manipulated textNodes #89 */
3===currentNode.nodeType&&currentNode===oldNode||_sanitizeElements(currentNode)||(
/* Shadow DOM detected, sanitize it */
currentNode.content instanceof DocumentFragment&&_sanitizeShadowDOM(currentNode.content)
/* Check attributes, sanitize if necessary */,_sanitizeAttributes(currentNode),oldNode=currentNode)
/* Sanitize tags and elements */;
/* If we sanitized `dirty` in-place, return it. */
if(oldNode=null,IN_PLACE)return dirty;
/* Return sanitized string or DOM */if(RETURN_DOM){if(RETURN_DOM_FRAGMENT){returnNode=createDocumentFragment.call(body.ownerDocument);while(body.firstChild)
// eslint-disable-next-line unicorn/prefer-dom-node-append
returnNode.appendChild(body.firstChild)}else returnNode=body;return ALLOWED_ATTR.shadowroot&&(
/*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
returnNode=importNode.call(originalDocument,returnNode,!0)),returnNode}var serializedHTML=WHOLE_DOCUMENT?body.outerHTML:body.innerHTML;
/* Serialize doctype if allowed */return WHOLE_DOCUMENT&&ALLOWED_TAGS["!doctype"]&&body.ownerDocument&&body.ownerDocument.doctype&&body.ownerDocument.doctype.name&&regExpTest$3(DOCTYPE_NAME$3,body.ownerDocument.doctype.name)&&(serializedHTML="<!DOCTYPE "+body.ownerDocument.doctype.name+">\n"+serializedHTML)
/* Sanitize final string template-safe */,SAFE_FOR_TEMPLATES&&(serializedHTML=stringReplace$3(serializedHTML,MUSTACHE_EXPR$1," "),serializedHTML=stringReplace$3(serializedHTML,ERB_EXPR$1," ")),trustedTypesPolicy&&RETURN_TRUSTED_TYPE?trustedTypesPolicy.createHTML(serializedHTML):serializedHTML},
/**
   * Public method to set the configuration once
   * setConfig
   *
   * @param {Object} cfg configuration object
   */
DOMPurify.setConfig=function(cfg){_parseConfig(cfg),SET_CONFIG=!0},
/**
   * Public method to remove the configuration
   * clearConfig
   *
   */
DOMPurify.clearConfig=function(){CONFIG=null,SET_CONFIG=!1},
/**
   * Public method to check if an attribute value is valid.
   * Uses last set config, if any. Otherwise, uses config defaults.
   * isValidAttribute
   *
   * @param  {string} tag Tag name of containing element.
   * @param  {string} attr Attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
   */
DOMPurify.isValidAttribute=function(tag,attr,value){
/* Initialize shared config vars if necessary. */
CONFIG||_parseConfig({});var lcTag=transformCaseFunc(tag),lcName=transformCaseFunc(attr);return _isValidAttribute(lcTag,lcName,value)},
/**
   * AddHook
   * Public method to add DOMPurify hooks
   *
   * @param {String} entryPoint entry point for the hook to add
   * @param {Function} hookFunction function to execute
   */
DOMPurify.addHook=function(entryPoint,hookFunction){"function"===typeof hookFunction&&(hooks[entryPoint]=hooks[entryPoint]||[],arrayPush$3(hooks[entryPoint],hookFunction))},
/**
   * RemoveHook
   * Public method to remove a DOMPurify hook at a given entryPoint
   * (pops it from the stack of hooks if more are present)
   *
   * @param {String} entryPoint entry point for the hook to remove
   * @return {Function} removed(popped) hook
   */
DOMPurify.removeHook=function(entryPoint){if(hooks[entryPoint])return arrayPop$3(hooks[entryPoint])},
/**
   * RemoveHooks
   * Public method to remove all DOMPurify hooks at a given entryPoint
   *
   * @param  {String} entryPoint entry point for the hooks to remove
   */
DOMPurify.removeHooks=function(entryPoint){hooks[entryPoint]&&(hooks[entryPoint]=[])},
/**
   * RemoveAllHooks
   * Public method to remove all DOMPurify hooks
   *
   */
DOMPurify.removeAllHooks=function(){hooks={}},DOMPurify}
// ::- Persistent data structure representing an ordered mapping from
// strings to values, with some convenient update methods.
function OrderedMap$3(content){this.content=content}function findDiffStart$3(a,b,pos){for(let i=0;;i++){if(i==a.childCount||i==b.childCount)return a.childCount==b.childCount?null:pos;let childA=a.child(i),childB=b.child(i);if(childA!=childB){if(!childA.sameMarkup(childB))return pos;if(childA.isText&&childA.text!=childB.text){for(let j=0;childA.text[j]==childB.text[j];j++)pos++;return pos}if(childA.content.size||childB.content.size){let inner=findDiffStart$3(childA.content,childB.content,pos+1);if(null!=inner)return inner}pos+=childA.nodeSize}else pos+=childA.nodeSize}}function findDiffEnd$3(a,b,posA,posB){for(let iA=a.childCount,iB=b.childCount;;){if(0==iA||0==iB)return iA==iB?null:{a:posA,b:posB};let childA=a.child(--iA),childB=b.child(--iB),size=childA.nodeSize;if(childA!=childB){if(!childA.sameMarkup(childB))return{a:posA,b:posB};if(childA.isText&&childA.text!=childB.text){let same=0,minSize=Math.min(childA.text.length,childB.text.length);while(same<minSize&&childA.text[childA.text.length-same-1]==childB.text[childB.text.length-same-1])same++,posA--,posB--;return{a:posA,b:posB}}if(childA.content.size||childB.content.size){let inner=findDiffEnd$3(childA.content,childB.content,posA-1,posB-1);if(inner)return inner}posA-=size,posB-=size}else posA-=size,posB-=size}}
/**
A fragment represents a node's collection of child nodes.

Like nodes, fragments are persistent data structures, and you
should not mutate them or their content. Rather, you create new
instances whenever needed. The API tries to make this easy.
*/createDOMPurify$3(),OrderedMap$3.prototype={constructor:OrderedMap$3,find:function(key){for(var i=0;i<this.content.length;i+=2)if(this.content[i]===key)return i;return-1},
// :: (string) → ?any
// Retrieve the value stored under `key`, or return undefined when
// no such key exists.
get:function(key){var found=this.find(key);return-1==found?void 0:this.content[found+1]},
// :: (string, any, ?string) → OrderedMap
// Create a new map by replacing the value of `key` with a new
// value, or adding a binding to the end of the map. If `newKey` is
// given, the key of the binding will be replaced with that key.
update:function(key,value,newKey){var self=newKey&&newKey!=key?this.remove(newKey):this,found=self.find(key),content=self.content.slice();return-1==found?content.push(newKey||key,value):(content[found+1]=value,newKey&&(content[found]=newKey)),new OrderedMap$3(content)},
// :: (string) → OrderedMap
// Return a map with the given key removed, if it existed.
remove:function(key){var found=this.find(key);if(-1==found)return this;var content=this.content.slice();return content.splice(found,2),new OrderedMap$3(content)},
// :: (string, any) → OrderedMap
// Add a new key to the start of the map.
addToStart:function(key,value){return new OrderedMap$3([key,value].concat(this.remove(key).content))},
// :: (string, any) → OrderedMap
// Add a new key to the end of the map.
addToEnd:function(key,value){var content=this.remove(key).content.slice();return content.push(key,value),new OrderedMap$3(content)},
// :: (string, string, any) → OrderedMap
// Add a key after the given key. If `place` is not found, the new
// key is added to the end.
addBefore:function(place,key,value){var without=this.remove(key),content=without.content.slice(),found=without.find(place);return content.splice(-1==found?content.length:found,0,key,value),new OrderedMap$3(content)},
// :: ((key: string, value: any))
// Call the given function for each key/value pair in the map, in
// order.
forEach:function(f){for(var i=0;i<this.content.length;i+=2)f(this.content[i],this.content[i+1])},
// :: (union<Object, OrderedMap>) → OrderedMap
// Create a new map by prepending the keys in this map that don't
// appear in `map` before the keys in `map`.
prepend:function(map){return map=OrderedMap$3.from(map),map.size?new OrderedMap$3(map.content.concat(this.subtract(map).content)):this},
// :: (union<Object, OrderedMap>) → OrderedMap
// Create a new map by appending the keys in this map that don't
// appear in `map` after the keys in `map`.
append:function(map){return map=OrderedMap$3.from(map),map.size?new OrderedMap$3(this.subtract(map).content.concat(map.content)):this},
// :: (union<Object, OrderedMap>) → OrderedMap
// Create a map containing all the keys in this map that don't
// appear in `map`.
subtract:function(map){var result=this;map=OrderedMap$3.from(map);for(var i=0;i<map.content.length;i+=2)result=result.remove(map.content[i]);return result},
// :: number
// The amount of keys in this map.
get size(){return this.content.length>>1}},
// :: (?union<Object, OrderedMap>) → OrderedMap
// Return a map with the given content. If null, create an empty
// map. If given an ordered map, return that map itself. If given an
// object, create a map from the object's properties.
OrderedMap$3.from=function(value){if(value instanceof OrderedMap$3)return value;var content=[];if(value)for(var prop in value)content.push(prop,value[prop]);return new OrderedMap$3(content)};class Fragment$3{
/**
    @internal
    */
constructor(
/**
    @internal
    */
content,size){if(this.content=content,this.size=size||0,null==size)for(let i=0;i<content.length;i++)this.size+=content[i].nodeSize}
/**
    Invoke a callback for all descendant nodes between the given two
    positions (relative to start of this fragment). Doesn't descend
    into a node when the callback returns `false`.
    */nodesBetween(from,to,f,nodeStart=0,parent){for(let i=0,pos=0;pos<to;i++){let child=this.content[i],end=pos+child.nodeSize;if(end>from&&!1!==f(child,nodeStart+pos,parent||null,i)&&child.content.size){let start=pos+1;child.nodesBetween(Math.max(0,from-start),Math.min(child.content.size,to-start),f,nodeStart+start)}pos=end}}
/**
    Call the given callback for every descendant node. `pos` will be
    relative to the start of the fragment. The callback may return
    `false` to prevent traversal of a given node's children.
    */descendants(f){this.nodesBetween(0,this.size,f)}
/**
    Extract the text between `from` and `to`. See the same method on
    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
    */textBetween(from,to,blockSeparator,leafText){let text="",separated=!0;return this.nodesBetween(from,to,((node,pos)=>{node.isText?(text+=node.text.slice(Math.max(from,pos)-pos,to-pos),separated=!blockSeparator):node.isLeaf?(leafText?text+="function"===typeof leafText?leafText(node):leafText:node.type.spec.leafText&&(text+=node.type.spec.leafText(node)),separated=!blockSeparator):!separated&&node.isBlock&&(text+=blockSeparator,separated=!0)}),0),text}
/**
    Create a new fragment containing the combined content of this
    fragment and the other.
    */append(other){if(!other.size)return this;if(!this.size)return other;let last=this.lastChild,first=other.firstChild,content=this.content.slice(),i=0;for(last.isText&&last.sameMarkup(first)&&(content[content.length-1]=last.withText(last.text+first.text),i=1);i<other.content.length;i++)content.push(other.content[i]);return new Fragment$3(content,this.size+other.size)}
/**
    Cut out the sub-fragment between the two given positions.
    */cut(from,to=this.size){if(0==from&&to==this.size)return this;let result=[],size=0;if(to>from)for(let i=0,pos=0;pos<to;i++){let child=this.content[i],end=pos+child.nodeSize;end>from&&((pos<from||end>to)&&(child=child.isText?child.cut(Math.max(0,from-pos),Math.min(child.text.length,to-pos)):child.cut(Math.max(0,from-pos-1),Math.min(child.content.size,to-pos-1))),result.push(child),size+=child.nodeSize),pos=end}return new Fragment$3(result,size)}
/**
    @internal
    */cutByIndex(from,to){return from==to?Fragment$3.empty:0==from&&to==this.content.length?this:new Fragment$3(this.content.slice(from,to))}
/**
    Create a new fragment in which the node at the given index is
    replaced by the given node.
    */replaceChild(index,node){let current=this.content[index];if(current==node)return this;let copy=this.content.slice(),size=this.size+node.nodeSize-current.nodeSize;return copy[index]=node,new Fragment$3(copy,size)}
/**
    Create a new fragment by prepending the given node to this
    fragment.
    */addToStart(node){return new Fragment$3([node].concat(this.content),this.size+node.nodeSize)}
/**
    Create a new fragment by appending the given node to this
    fragment.
    */addToEnd(node){return new Fragment$3(this.content.concat(node),this.size+node.nodeSize)}
/**
    Compare this fragment to another one.
    */eq(other){if(this.content.length!=other.content.length)return!1;for(let i=0;i<this.content.length;i++)if(!this.content[i].eq(other.content[i]))return!1;return!0}
/**
    The first child of the fragment, or `null` if it is empty.
    */get firstChild(){return this.content.length?this.content[0]:null}
/**
    The last child of the fragment, or `null` if it is empty.
    */get lastChild(){return this.content.length?this.content[this.content.length-1]:null}
/**
    The number of child nodes in this fragment.
    */get childCount(){return this.content.length}
/**
    Get the child node at the given index. Raise an error when the
    index is out of range.
    */child(index){let found=this.content[index];if(!found)throw new RangeError("Index "+index+" out of range for "+this);return found}
/**
    Get the child node at the given index, if it exists.
    */maybeChild(index){return this.content[index]||null}
/**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */forEach(f){for(let i=0,p=0;i<this.content.length;i++){let child=this.content[i];f(child,p,i),p+=child.nodeSize}}
/**
    Find the first position at which this fragment and another
    fragment differ, or `null` if they are the same.
    */findDiffStart(other,pos=0){return findDiffStart$3(this,other,pos)}
/**
    Find the first position, searching from the end, at which this
    fragment and the given fragment differ, or `null` if they are
    the same. Since this position will not be the same in both
    nodes, an object with two separate positions is returned.
    */findDiffEnd(other,pos=this.size,otherPos=other.size){return findDiffEnd$3(this,other,pos,otherPos)}
/**
    Find the index and inner offset corresponding to a given relative
    position in this fragment. The result object will be reused
    (overwritten) the next time the function is called. (Not public.)
    */findIndex(pos,round=-1){if(0==pos)return retIndex$3(0,pos);if(pos==this.size)return retIndex$3(this.content.length,pos);if(pos>this.size||pos<0)throw new RangeError(`Position ${pos} outside of fragment (${this})`);for(let i=0,curPos=0;;i++){let cur=this.child(i),end=curPos+cur.nodeSize;if(end>=pos)return end==pos||round>0?retIndex$3(i+1,end):retIndex$3(i,curPos);curPos=end}}
/**
    Return a debugging string that describes this fragment.
    */toString(){return"<"+this.toStringInner()+">"}
/**
    @internal
    */toStringInner(){return this.content.join(", ")}
/**
    Create a JSON-serializeable representation of this fragment.
    */toJSON(){return this.content.length?this.content.map((n=>n.toJSON())):null}
/**
    Deserialize a fragment from its JSON representation.
    */static fromJSON(schema,value){if(!value)return Fragment$3.empty;if(!Array.isArray(value))throw new RangeError("Invalid input for Fragment.fromJSON");return new Fragment$3(value.map(schema.nodeFromJSON))}
/**
    Build a fragment from an array of nodes. Ensures that adjacent
    text nodes with the same marks are joined together.
    */static fromArray(array){if(!array.length)return Fragment$3.empty;let joined,size=0;for(let i=0;i<array.length;i++){let node=array[i];size+=node.nodeSize,i&&node.isText&&array[i-1].sameMarkup(node)?(joined||(joined=array.slice(0,i)),joined[joined.length-1]=node.withText(joined[joined.length-1].text+node.text)):joined&&joined.push(node)}return new Fragment$3(joined||array,size)}
/**
    Create a fragment from something that can be interpreted as a
    set of nodes. For `null`, it returns the empty fragment. For a
    fragment, the fragment itself. For a node or array of nodes, a
    fragment containing those nodes.
    */static from(nodes){if(!nodes)return Fragment$3.empty;if(nodes instanceof Fragment$3)return nodes;if(Array.isArray(nodes))return this.fromArray(nodes);if(nodes.attrs)return new Fragment$3([nodes],nodes.nodeSize);throw new RangeError("Can not convert "+nodes+" to a Fragment"+(nodes.nodesBetween?" (looks like multiple versions of prosemirror-model were loaded)":""))}}
/**
An empty fragment. Intended to be reused whenever a node doesn't
contain anything (rather than allocating a new empty fragment for
each leaf node).
*/Fragment$3.empty=new Fragment$3([],0);const found$3={index:0,offset:0};function retIndex$3(index,offset){return found$3.index=index,found$3.offset=offset,found$3}function compareDeep$3(a,b){if(a===b)return!0;if(!a||"object"!=typeof a||!b||"object"!=typeof b)return!1;let array=Array.isArray(a);if(Array.isArray(b)!=array)return!1;if(array){if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(!compareDeep$3(a[i],b[i]))return!1}else{for(let p in a)if(!(p in b)||!compareDeep$3(a[p],b[p]))return!1;for(let p in b)if(!(p in a))return!1}return!0}
/**
A mark is a piece of information that can be attached to a node,
such as it being emphasized, in code font, or a link. It has a
type and optionally a set of attributes that provide further
information (such as the target of the link). Marks are created
through a `Schema`, which controls which types exist and which
attributes they have.
*/class Mark$1$3{
/**
    @internal
    */
constructor(
/**
    The type of this mark.
    */
type,
/**
    The attributes associated with this mark.
    */
attrs){this.type=type,this.attrs=attrs}
/**
    Given a set of marks, create a new set which contains this one as
    well, in the right position. If this mark is already in the set,
    the set itself is returned. If any marks that are set to be
    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
    those are replaced by this one.
    */addToSet(set){let copy,placed=!1;for(let i=0;i<set.length;i++){let other=set[i];if(this.eq(other))return set;if(this.type.excludes(other.type))copy||(copy=set.slice(0,i));else{if(other.type.excludes(this.type))return set;!placed&&other.type.rank>this.type.rank&&(copy||(copy=set.slice(0,i)),copy.push(this),placed=!0),copy&&copy.push(other)}}return copy||(copy=set.slice()),placed||copy.push(this),copy}
/**
    Remove this mark from the given set, returning a new set. If this
    mark is not in the set, the set itself is returned.
    */removeFromSet(set){for(let i=0;i<set.length;i++)if(this.eq(set[i]))return set.slice(0,i).concat(set.slice(i+1));return set}
/**
    Test whether this mark is in the given set of marks.
    */isInSet(set){for(let i=0;i<set.length;i++)if(this.eq(set[i]))return!0;return!1}
/**
    Test whether this mark has the same type and attributes as
    another mark.
    */eq(other){return this==other||this.type==other.type&&compareDeep$3(this.attrs,other.attrs)}
/**
    Convert this mark to a JSON-serializeable representation.
    */toJSON(){let obj={type:this.type.name};for(let _ in this.attrs){obj.attrs=this.attrs;break}return obj}
/**
    Deserialize a mark from JSON.
    */static fromJSON(schema,json){if(!json)throw new RangeError("Invalid input for Mark.fromJSON");let type=schema.marks[json.type];if(!type)throw new RangeError(`There is no mark type ${json.type} in this schema`);return type.create(json.attrs)}
/**
    Test whether two sets of marks are identical.
    */static sameSet(a,b){if(a==b)return!0;if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(!a[i].eq(b[i]))return!1;return!0}
/**
    Create a properly sorted mark set from null, a single mark, or an
    unsorted array of marks.
    */static setFrom(marks){if(!marks||Array.isArray(marks)&&0==marks.length)return Mark$1$3.none;if(marks instanceof Mark$1$3)return[marks];let copy=marks.slice();return copy.sort(((a,b)=>a.type.rank-b.type.rank)),copy}}
/**
The empty set of marks.
*/Mark$1$3.none=[];
/**
Error type raised by [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) when
given an invalid replacement.
*/
class ReplaceError$3 extends Error{}
/*
ReplaceError = function(this: any, message: string) {
  let err = Error.call(this, message)
  ;(err as any).__proto__ = ReplaceError.prototype
  return err
} as any

ReplaceError.prototype = Object.create(Error.prototype)
ReplaceError.prototype.constructor = ReplaceError
ReplaceError.prototype.name = "ReplaceError"
*/
/**
A slice represents a piece cut out of a larger document. It
stores not only a fragment, but also the depth up to which nodes on
both side are ‘open’ (cut through).
*/class Slice$3{
/**
    Create a slice. When specifying a non-zero open depth, you must
    make sure that there are nodes of at least that depth at the
    appropriate side of the fragment—i.e. if the fragment is an
    empty paragraph node, `openStart` and `openEnd` can't be greater
    than 1.
    
    It is not necessary for the content of open nodes to conform to
    the schema's content constraints, though it should be a valid
    start/end/middle for such a node, depending on which sides are
    open.
    */
constructor(
/**
    The slice's content.
    */
content,
/**
    The open depth at the start of the fragment.
    */
openStart,
/**
    The open depth at the end.
    */
openEnd){this.content=content,this.openStart=openStart,this.openEnd=openEnd}
/**
    The size this slice would add when inserted into a document.
    */get size(){return this.content.size-this.openStart-this.openEnd}
/**
    @internal
    */insertAt(pos,fragment){let content=insertInto$3(this.content,pos+this.openStart,fragment);return content&&new Slice$3(content,this.openStart,this.openEnd)}
/**
    @internal
    */removeBetween(from,to){return new Slice$3(removeRange$3(this.content,from+this.openStart,to+this.openStart),this.openStart,this.openEnd)}
/**
    Tests whether this slice is equal to another slice.
    */eq(other){return this.content.eq(other.content)&&this.openStart==other.openStart&&this.openEnd==other.openEnd}
/**
    @internal
    */toString(){return this.content+"("+this.openStart+","+this.openEnd+")"}
/**
    Convert a slice to a JSON-serializable representation.
    */toJSON(){if(!this.content.size)return null;let json={content:this.content.toJSON()};return this.openStart>0&&(json.openStart=this.openStart),this.openEnd>0&&(json.openEnd=this.openEnd),json}
/**
    Deserialize a slice from its JSON representation.
    */static fromJSON(schema,json){if(!json)return Slice$3.empty;let openStart=json.openStart||0,openEnd=json.openEnd||0;if("number"!=typeof openStart||"number"!=typeof openEnd)throw new RangeError("Invalid input for Slice.fromJSON");return new Slice$3(Fragment$3.fromJSON(schema,json.content),openStart,openEnd)}
/**
    Create a slice from a fragment by taking the maximum possible
    open value on both side of the fragment.
    */static maxOpen(fragment,openIsolating=!0){let openStart=0,openEnd=0;for(let n=fragment.firstChild;n&&!n.isLeaf&&(openIsolating||!n.type.spec.isolating);n=n.firstChild)openStart++;for(let n=fragment.lastChild;n&&!n.isLeaf&&(openIsolating||!n.type.spec.isolating);n=n.lastChild)openEnd++;return new Slice$3(fragment,openStart,openEnd)}}
/**
The empty slice.
*/function removeRange$3(content,from,to){let{index:index,offset:offset}=content.findIndex(from),child=content.maybeChild(index),{index:indexTo,offset:offsetTo}=content.findIndex(to);if(offset==from||child.isText){if(offsetTo!=to&&!content.child(indexTo).isText)throw new RangeError("Removing non-flat range");return content.cut(0,from).append(content.cut(to))}if(index!=indexTo)throw new RangeError("Removing non-flat range");return content.replaceChild(index,child.copy(removeRange$3(child.content,from-offset-1,to-offset-1)))}function insertInto$3(content,dist,insert,parent){let{index:index,offset:offset}=content.findIndex(dist),child=content.maybeChild(index);if(offset==dist||child.isText)return parent&&!parent.canReplace(index,index,insert)?null:content.cut(0,dist).append(insert).append(content.cut(dist));let inner=insertInto$3(child.content,dist-offset-1,insert);return inner&&content.replaceChild(index,child.copy(inner))}
/**
Represents a flat range of content, i.e. one that starts and
ends in the same node.
*/Slice$3.empty=new Slice$3(Fragment$3.empty,0,0);class NodeRange$3{
/**
    Construct a node range. `$from` and `$to` should point into the
    same node until at least the given `depth`, since a node range
    denotes an adjacent set of nodes in a single parent node.
    */
constructor(
/**
    A resolved position along the start of the content. May have a
    `depth` greater than this object's `depth` property, since
    these are the positions that were used to compute the range,
    not re-resolved positions directly at its boundaries.
    */
$from,
/**
    A position along the end of the content. See
    caveat for [`$from`](https://prosemirror.net/docs/ref/#model.NodeRange.$from).
    */
$to,
/**
    The depth of the node that this range points into.
    */
depth){this.$from=$from,this.$to=$to,this.depth=depth}
/**
    The position at the start of the range.
    */get start(){return this.$from.before(this.depth+1)}
/**
    The position at the end of the range.
    */get end(){return this.$to.after(this.depth+1)}
/**
    The parent node that the range points into.
    */get parent(){return this.$from.node(this.depth)}
/**
    The start index of the range in the parent node.
    */get startIndex(){return this.$from.index(this.depth)}
/**
    The end index of the range in the parent node.
    */get endIndex(){return this.$to.indexAfter(this.depth)}}
// For node types where all attrs have a default value (or which don't
// have any attributes), build up a single reusable default attribute
// object, and use it for all nodes that don't specify specific
// attributes.
function defaultAttrs$3(attrs){let defaults=Object.create(null);for(let attrName in attrs){let attr=attrs[attrName];if(!attr.hasDefault)return null;defaults[attrName]=attr.default}return defaults}function computeAttrs$3(attrs,value){let built=Object.create(null);for(let name in attrs){let given=value&&value[name];if(void 0===given){let attr=attrs[name];if(!attr.hasDefault)throw new RangeError("No value supplied for attribute "+name);given=attr.default}built[name]=given}return built}function initAttrs$3(attrs){let result=Object.create(null);if(attrs)for(let name in attrs)result[name]=new Attribute$3(attrs[name]);return result}
// Attribute descriptors
class Attribute$3{constructor(options){this.hasDefault=Object.prototype.hasOwnProperty.call(options,"default"),this.default=options.default}get isRequired(){return!this.hasDefault}}
// Marks
/**
Like nodes, marks (which are associated with nodes to signify
things like emphasis or being part of a link) are
[tagged](https://prosemirror.net/docs/ref/#model.Mark.type) with type objects, which are
instantiated once per `Schema`.
*/class MarkType$3{
/**
    @internal
    */
constructor(
/**
    The name of the mark type.
    */
name,
/**
    @internal
    */
rank,
/**
    The schema that this mark type instance is part of.
    */
schema,
/**
    The spec on which the type is based.
    */
spec){this.name=name,this.rank=rank,this.schema=schema,this.spec=spec,this.attrs=initAttrs$3(spec.attrs),this.excluded=null;let defaults=defaultAttrs$3(this.attrs);this.instance=defaults?new Mark$1$3(this,defaults):null}
/**
    Create a mark of this type. `attrs` may be `null` or an object
    containing only some of the mark's attributes. The others, if
    they have defaults, will be added.
    */create(attrs=null){return!attrs&&this.instance?this.instance:new Mark$1$3(this,computeAttrs$3(this.attrs,attrs))}
/**
    @internal
    */static compile(marks,schema){let result=Object.create(null),rank=0;return marks.forEach(((name,spec)=>result[name]=new MarkType$3(name,rank++,schema,spec))),result}
/**
    When there is a mark of this type in the given set, a new set
    without it is returned. Otherwise, the input set is returned.
    */removeFromSet(set){for(var i=0;i<set.length;i++)set[i].type==this&&(set=set.slice(0,i).concat(set.slice(i+1)),i--);return set}
/**
    Tests whether there is a mark of this type in the given set.
    */isInSet(set){for(let i=0;i<set.length;i++)if(set[i].type==this)return set[i]}
/**
    Queries whether a given mark type is
    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
    */excludes(other){return this.excluded.indexOf(other)>-1}}
/**
A DOM parser represents a strategy for parsing DOM content into a
ProseMirror document conforming to a given schema. Its behavior is
defined by an array of [rules](https://prosemirror.net/docs/ref/#model.ParseRule).
*/class DOMParser$1$3{
/**
    Create a parser that targets the given schema, using the given
    parsing rules.
    */
constructor(
/**
    The schema into which the parser parses.
    */
schema,
/**
    The set of [parse rules](https://prosemirror.net/docs/ref/#model.ParseRule) that the parser
    uses, in order of precedence.
    */
rules){this.schema=schema,this.rules=rules,
/**
        @internal
        */
this.tags=[],
/**
        @internal
        */
this.styles=[],rules.forEach((rule=>{rule.tag?this.tags.push(rule):rule.style&&this.styles.push(rule)})),
// Only normalize list elements when lists in the schema can't directly contain themselves
this.normalizeLists=!this.tags.some((r=>{if(!/^(ul|ol)\b/.test(r.tag)||!r.node)return!1;let node=schema.nodes[r.node];return node.contentMatch.matchType(node)}))}
/**
    Parse a document from the content of a DOM node.
    */parse(dom,options={}){let context=new ParseContext$3(this,options,!1);return context.addAll(dom,options.from,options.to),context.finish()}
/**
    Parses the content of the given DOM node, like
    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
    options. But unlike that method, which produces a whole node,
    this one returns a slice that is open at the sides, meaning that
    the schema constraints aren't applied to the start of nodes to
    the left of the input and the end of nodes at the end.
    */parseSlice(dom,options={}){let context=new ParseContext$3(this,options,!0);return context.addAll(dom,options.from,options.to),Slice$3.maxOpen(context.finish())}
/**
    @internal
    */matchTag(dom,context,after){for(let i=after?this.tags.indexOf(after)+1:0;i<this.tags.length;i++){let rule=this.tags[i];if(matches$1$3(dom,rule.tag)&&(void 0===rule.namespace||dom.namespaceURI==rule.namespace)&&(!rule.context||context.matchesContext(rule.context))){if(rule.getAttrs){let result=rule.getAttrs(dom);if(!1===result)continue;rule.attrs=result||void 0}return rule}}}
/**
    @internal
    */matchStyle(prop,value,context,after){for(let i=after?this.styles.indexOf(after)+1:0;i<this.styles.length;i++){let rule=this.styles[i],style=rule.style;if(!(0!=style.indexOf(prop)||rule.context&&!context.matchesContext(rule.context)||
// Test that the style string either precisely matches the prop,
// or has an '=' sign after the prop, followed by the given
// value.
style.length>prop.length&&(61!=style.charCodeAt(prop.length)||style.slice(prop.length+1)!=value))){if(rule.getAttrs){let result=rule.getAttrs(value);if(!1===result)continue;rule.attrs=result||void 0}return rule}}}
/**
    @internal
    */static schemaRules(schema){let result=[];function insert(rule){let priority=null==rule.priority?50:rule.priority,i=0;for(;i<result.length;i++){let next=result[i],nextPriority=null==next.priority?50:next.priority;if(nextPriority<priority)break}result.splice(i,0,rule)}for(let name in schema.marks){let rules=schema.marks[name].spec.parseDOM;rules&&rules.forEach((rule=>{insert(rule=copy$3(rule)),rule.mark=name}))}for(let name in schema.nodes){let rules=schema.nodes[name].spec.parseDOM;rules&&rules.forEach((rule=>{insert(rule=copy$3(rule)),rule.node=name}))}return result}
/**
    Construct a DOM parser using the parsing rules listed in a
    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
    */static fromSchema(schema){return schema.cached.domParser||(schema.cached.domParser=new DOMParser$1$3(schema,DOMParser$1$3.schemaRules(schema)))}}const blockTags$3={address:!0,article:!0,aside:!0,blockquote:!0,canvas:!0,dd:!0,div:!0,dl:!0,fieldset:!0,figcaption:!0,figure:!0,footer:!0,form:!0,h1:!0,h2:!0,h3:!0,h4:!0,h5:!0,h6:!0,header:!0,hgroup:!0,hr:!0,li:!0,noscript:!0,ol:!0,output:!0,p:!0,pre:!0,section:!0,table:!0,tfoot:!0,ul:!0},ignoreTags$3={head:!0,noscript:!0,object:!0,script:!0,style:!0,title:!0},listTags$3={ol:!0,ul:!0},OPT_PRESERVE_WS$3=1,OPT_PRESERVE_WS_FULL$3=2,OPT_OPEN_LEFT$3=4;function wsOptionsFor$3(type,preserveWhitespace,base){return null!=preserveWhitespace?(preserveWhitespace?OPT_PRESERVE_WS$3:0)|("full"===preserveWhitespace?OPT_PRESERVE_WS_FULL$3:0):type&&"pre"==type.whitespace?OPT_PRESERVE_WS$3|OPT_PRESERVE_WS_FULL$3:base&~OPT_OPEN_LEFT$3}class NodeContext$3{constructor(type,attrs,
// Marks applied to this node itself
marks,
// Marks that can't apply here, but will be used in children if possible
pendingMarks,solid,match,options){this.type=type,this.attrs=attrs,this.marks=marks,this.pendingMarks=pendingMarks,this.solid=solid,this.options=options,this.content=[],
// Marks applied to the node's children
this.activeMarks=Mark$1$3.none,
// Nested Marks with same type
this.stashMarks=[],this.match=match||(options&OPT_OPEN_LEFT$3?null:type.contentMatch)}findWrapping(node){if(!this.match){if(!this.type)return[];let fill=this.type.contentMatch.fillBefore(Fragment$3.from(node));if(!fill){let wrap,start=this.type.contentMatch;return(wrap=start.findWrapping(node.type))?(this.match=start,wrap):null}this.match=this.type.contentMatch.matchFragment(fill)}return this.match.findWrapping(node.type)}finish(openEnd){if(!(this.options&OPT_PRESERVE_WS$3)){// Strip trailing whitespace
let m,last=this.content[this.content.length-1];if(last&&last.isText&&(m=/[ \t\r\n\u000c]+$/.exec(last.text))){let text=last;last.text.length==m[0].length?this.content.pop():this.content[this.content.length-1]=text.withText(text.text.slice(0,text.text.length-m[0].length))}}let content=Fragment$3.from(this.content);return!openEnd&&this.match&&(content=content.append(this.match.fillBefore(Fragment$3.empty,!0))),this.type?this.type.create(this.attrs,content,this.marks):content}popFromStashMark(mark){for(let i=this.stashMarks.length-1;i>=0;i--)if(mark.eq(this.stashMarks[i]))return this.stashMarks.splice(i,1)[0]}applyPending(nextType){for(let i=0,pending=this.pendingMarks;i<pending.length;i++){let mark=pending[i];(this.type?this.type.allowsMarkType(mark.type):markMayApply$3(mark.type,nextType))&&!mark.isInSet(this.activeMarks)&&(this.activeMarks=mark.addToSet(this.activeMarks),this.pendingMarks=mark.removeFromSet(this.pendingMarks))}}inlineContext(node){return this.type?this.type.inlineContent:this.content.length?this.content[0].isInline:node.parentNode&&!blockTags$3.hasOwnProperty(node.parentNode.nodeName.toLowerCase())}}class ParseContext$3{constructor(
// The parser we are using.
parser,
// The options passed to this parse.
options,isOpen){this.parser=parser,this.options=options,this.isOpen=isOpen,this.open=0;let topContext,topNode=options.topNode,topOptions=wsOptionsFor$3(null,options.preserveWhitespace,0)|(isOpen?OPT_OPEN_LEFT$3:0);topContext=topNode?new NodeContext$3(topNode.type,topNode.attrs,Mark$1$3.none,Mark$1$3.none,!0,options.topMatch||topNode.type.contentMatch,topOptions):new NodeContext$3(isOpen?null:parser.schema.topNodeType,null,Mark$1$3.none,Mark$1$3.none,!0,null,topOptions),this.nodes=[topContext],this.find=options.findPositions,this.needsBlock=!1}get top(){return this.nodes[this.open]}
// Add a DOM node to the content. Text is inserted as text node,
// otherwise, the node is passed to `addElement` or, if it has a
// `style` attribute, `addElementWithStyles`.
addDOM(dom){if(3==dom.nodeType)this.addTextNode(dom);else if(1==dom.nodeType){let style=dom.getAttribute("style"),marks=style?this.readStyles(parseStyles$3(style)):null,top=this.top;if(null!=marks)for(let i=0;i<marks.length;i++)this.addPendingMark(marks[i]);if(this.addElement(dom),null!=marks)for(let i=0;i<marks.length;i++)this.removePendingMark(marks[i],top)}}addTextNode(dom){let value=dom.nodeValue,top=this.top;if(top.options&OPT_PRESERVE_WS_FULL$3||top.inlineContext(dom)||/[^ \t\r\n\u000c]/.test(value)){if(top.options&OPT_PRESERVE_WS$3)value=top.options&OPT_PRESERVE_WS_FULL$3?value.replace(/\r\n?/g,"\n"):value.replace(/\r?\n|\r/g," ");else
// If this starts with whitespace, and there is no node before it, or
// a hard break, or a text node that ends with whitespace, strip the
// leading space.
if(value=value.replace(/[ \t\r\n\u000c]+/g," "),/^[ \t\r\n\u000c]/.test(value)&&this.open==this.nodes.length-1){let nodeBefore=top.content[top.content.length-1],domNodeBefore=dom.previousSibling;(!nodeBefore||domNodeBefore&&"BR"==domNodeBefore.nodeName||nodeBefore.isText&&/[ \t\r\n\u000c]$/.test(nodeBefore.text))&&(value=value.slice(1))}value&&this.insertNode(this.parser.schema.text(value)),this.findInText(dom)}else this.findInside(dom)}
// Try to find a handler for the given tag and use that to parse. If
// none is found, the element's content nodes are added directly.
addElement(dom,matchAfter){let ruleID,name=dom.nodeName.toLowerCase();listTags$3.hasOwnProperty(name)&&this.parser.normalizeLists&&normalizeList$3(dom);let rule=this.options.ruleFromNode&&this.options.ruleFromNode(dom)||(ruleID=this.parser.matchTag(dom,this,matchAfter));if(rule?rule.ignore:ignoreTags$3.hasOwnProperty(name))this.findInside(dom),this.ignoreFallback(dom);else if(!rule||rule.skip||rule.closeParent){rule&&rule.closeParent?this.open=Math.max(0,this.open-1):rule&&rule.skip.nodeType&&(dom=rule.skip);let sync,top=this.top,oldNeedsBlock=this.needsBlock;if(blockTags$3.hasOwnProperty(name))sync=!0,top.type||(this.needsBlock=!0);else if(!dom.firstChild)return void this.leafFallback(dom);this.addAll(dom),sync&&this.sync(top),this.needsBlock=oldNeedsBlock}else this.addElementByRule(dom,rule,!1===rule.consuming?ruleID:void 0)}
// Called for leaf DOM nodes that would otherwise be ignored
leafFallback(dom){"BR"==dom.nodeName&&this.top.type&&this.top.type.inlineContent&&this.addTextNode(dom.ownerDocument.createTextNode("\n"))}
// Called for ignored nodes
ignoreFallback(dom){
// Ignored BR nodes should at least create an inline context
"BR"!=dom.nodeName||this.top.type&&this.top.type.inlineContent||this.findPlace(this.parser.schema.text("-"))}
// Run any style parser associated with the node's styles. Either
// return an array of marks, or null to indicate some of the styles
// had a rule with `ignore` set.
readStyles(styles){let marks=Mark$1$3.none;style:for(let i=0;i<styles.length;i+=2)for(let after;;){let rule=this.parser.matchStyle(styles[i],styles[i+1],this,after);if(!rule)continue style;if(rule.ignore)return null;if(marks=this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks),!1!==rule.consuming)break;after=rule}return marks}
// Look up a handler for the given node. If none are found, return
// false. Otherwise, apply it, use its return value to drive the way
// the node's content is wrapped, and return true.
addElementByRule(dom,rule,continueAfter){let sync,nodeType,mark;if(rule.node)nodeType=this.parser.schema.nodes[rule.node],nodeType.isLeaf?this.insertNode(nodeType.create(rule.attrs))||this.leafFallback(dom):sync=this.enter(nodeType,rule.attrs||null,rule.preserveWhitespace);else{let markType=this.parser.schema.marks[rule.mark];mark=markType.create(rule.attrs),this.addPendingMark(mark)}let startIn=this.top;if(nodeType&&nodeType.isLeaf)this.findInside(dom);else if(continueAfter)this.addElement(dom,continueAfter);else if(rule.getContent)this.findInside(dom),rule.getContent(dom,this.parser.schema).forEach((node=>this.insertNode(node)));else{let contentDOM=dom;"string"==typeof rule.contentElement?contentDOM=dom.querySelector(rule.contentElement):"function"==typeof rule.contentElement?contentDOM=rule.contentElement(dom):rule.contentElement&&(contentDOM=rule.contentElement),this.findAround(dom,contentDOM,!0),this.addAll(contentDOM)}sync&&this.sync(startIn)&&this.open--,mark&&this.removePendingMark(mark,startIn)}
// Add all child nodes between `startIndex` and `endIndex` (or the
// whole node, if not given). If `sync` is passed, use it to
// synchronize after every block element.
addAll(parent,startIndex,endIndex){let index=startIndex||0;for(let dom=startIndex?parent.childNodes[startIndex]:parent.firstChild,end=null==endIndex?null:parent.childNodes[endIndex];dom!=end;dom=dom.nextSibling,++index)this.findAtPoint(parent,index),this.addDOM(dom);this.findAtPoint(parent,index)}
// Try to find a way to fit the given node type into the current
// context. May add intermediate wrappers and/or leave non-solid
// nodes that we're in.
findPlace(node){let route,sync;for(let depth=this.open;depth>=0;depth--){let cx=this.nodes[depth],found=cx.findWrapping(node);if(found&&(!route||route.length>found.length)&&(route=found,sync=cx,!found.length))break;if(cx.solid)break}if(!route)return!1;this.sync(sync);for(let i=0;i<route.length;i++)this.enterInner(route[i],null,!1);return!0}
// Try to insert the given node, adjusting the context when needed.
insertNode(node){if(node.isInline&&this.needsBlock&&!this.top.type){let block=this.textblockFromContext();block&&this.enterInner(block)}if(this.findPlace(node)){this.closeExtra();let top=this.top;top.applyPending(node.type),top.match&&(top.match=top.match.matchType(node.type));let marks=top.activeMarks;for(let i=0;i<node.marks.length;i++)top.type&&!top.type.allowsMarkType(node.marks[i].type)||(marks=node.marks[i].addToSet(marks));return top.content.push(node.mark(marks)),!0}return!1}
// Try to start a node of the given type, adjusting the context when
// necessary.
enter(type,attrs,preserveWS){let ok=this.findPlace(type.create(attrs));return ok&&this.enterInner(type,attrs,!0,preserveWS),ok}
// Open a node of the given type
enterInner(type,attrs=null,solid=!1,preserveWS){this.closeExtra();let top=this.top;top.applyPending(type),top.match=top.match&&top.match.matchType(type);let options=wsOptionsFor$3(type,preserveWS,top.options);top.options&OPT_OPEN_LEFT$3&&0==top.content.length&&(options|=OPT_OPEN_LEFT$3),this.nodes.push(new NodeContext$3(type,attrs,top.activeMarks,top.pendingMarks,solid,null,options)),this.open++}
// Make sure all nodes above this.open are finished and added to
// their parents
closeExtra(openEnd=!1){let i=this.nodes.length-1;if(i>this.open){for(;i>this.open;i--)this.nodes[i-1].content.push(this.nodes[i].finish(openEnd));this.nodes.length=this.open+1}}finish(){return this.open=0,this.closeExtra(this.isOpen),this.nodes[0].finish(this.isOpen||this.options.topOpen)}sync(to){for(let i=this.open;i>=0;i--)if(this.nodes[i]==to)return this.open=i,!0;return!1}get currentPos(){this.closeExtra();let pos=0;for(let i=this.open;i>=0;i--){let content=this.nodes[i].content;for(let j=content.length-1;j>=0;j--)pos+=content[j].nodeSize;i&&pos++}return pos}findAtPoint(parent,offset){if(this.find)for(let i=0;i<this.find.length;i++)this.find[i].node==parent&&this.find[i].offset==offset&&(this.find[i].pos=this.currentPos)}findInside(parent){if(this.find)for(let i=0;i<this.find.length;i++)null==this.find[i].pos&&1==parent.nodeType&&parent.contains(this.find[i].node)&&(this.find[i].pos=this.currentPos)}findAround(parent,content,before){if(parent!=content&&this.find)for(let i=0;i<this.find.length;i++)if(null==this.find[i].pos&&1==parent.nodeType&&parent.contains(this.find[i].node)){let pos=content.compareDocumentPosition(this.find[i].node);pos&(before?2:4)&&(this.find[i].pos=this.currentPos)}}findInText(textNode){if(this.find)for(let i=0;i<this.find.length;i++)this.find[i].node==textNode&&(this.find[i].pos=this.currentPos-(textNode.nodeValue.length-this.find[i].offset))}
// Determines whether the given context string matches this context.
matchesContext(context){if(context.indexOf("|")>-1)return context.split(/\s*\|\s*/).some(this.matchesContext,this);let parts=context.split("/"),option=this.options.context,useRoot=!this.isOpen&&(!option||option.parent.type==this.nodes[0].type),minDepth=-(option?option.depth+1:0)+(useRoot?0:1),match=(i,depth)=>{for(;i>=0;i--){let part=parts[i];if(""==part){if(i==parts.length-1||0==i)continue;for(;depth>=minDepth;depth--)if(match(i-1,depth))return!0;return!1}{let next=depth>0||0==depth&&useRoot?this.nodes[depth].type:option&&depth>=minDepth?option.node(depth-minDepth).type:null;if(!next||next.name!=part&&-1==next.groups.indexOf(part))return!1;depth--}}return!0};return match(parts.length-1,this.open)}textblockFromContext(){let $context=this.options.context;if($context)for(let d=$context.depth;d>=0;d--){let deflt=$context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;if(deflt&&deflt.isTextblock&&deflt.defaultAttrs)return deflt}for(let name in this.parser.schema.nodes){let type=this.parser.schema.nodes[name];if(type.isTextblock&&type.defaultAttrs)return type}}addPendingMark(mark){let found=findSameMarkInSet$3(mark,this.top.pendingMarks);found&&this.top.stashMarks.push(found),this.top.pendingMarks=mark.addToSet(this.top.pendingMarks)}removePendingMark(mark,upto){for(let depth=this.open;depth>=0;depth--){let level=this.nodes[depth],found=level.pendingMarks.lastIndexOf(mark);if(found>-1)level.pendingMarks=mark.removeFromSet(level.pendingMarks);else{level.activeMarks=mark.removeFromSet(level.activeMarks);let stashMark=level.popFromStashMark(mark);stashMark&&level.type&&level.type.allowsMarkType(stashMark.type)&&(level.activeMarks=stashMark.addToSet(level.activeMarks))}if(level==upto)break}}}
// Kludge to work around directly nested list nodes produced by some
// tools and allowed by browsers to mean that the nested list is
// actually part of the list item above it.
function normalizeList$3(dom){for(let child=dom.firstChild,prevItem=null;child;child=child.nextSibling){let name=1==child.nodeType?child.nodeName.toLowerCase():null;name&&listTags$3.hasOwnProperty(name)&&prevItem?(prevItem.appendChild(child),child=prevItem):"li"==name?prevItem=child:name&&(prevItem=null)}}
// Apply a CSS selector.
function matches$1$3(dom,selector){return(dom.matches||dom.msMatchesSelector||dom.webkitMatchesSelector||dom.mozMatchesSelector).call(dom,selector)}
// Tokenize a style attribute into property/value pairs.
function parseStyles$3(style){let m,re=/\s*([\w-]+)\s*:\s*([^;]+)/g,result=[];while(m=re.exec(style))result.push(m[1],m[2].trim());return result}function copy$3(obj){let copy={};for(let prop in obj)copy[prop]=obj[prop];return copy}
// Used when finding a mark at the top level of a fragment parse.
// Checks whether it would be reasonable to apply a given mark type to
// a given node, by looking at the way the mark occurs in the schema.
function markMayApply$3(markType,nodeType){let nodes=nodeType.schema.nodes;for(let name in nodes){let parent=nodes[name];if(!parent.allowsMarkType(markType))continue;let seen=[],scan=match=>{seen.push(match);for(let i=0;i<match.edgeCount;i++){let{type:type,next:next}=match.edge(i);if(type==nodeType)return!0;if(seen.indexOf(next)<0&&scan(next))return!0}};if(scan(parent.contentMatch))return!0}}function findSameMarkInSet$3(mark,set){for(let i=0;i<set.length;i++)if(mark.eq(set[i]))return set[i]}
/**
A DOM serializer knows how to convert ProseMirror nodes and
marks of various types to DOM nodes.
*/class DOMSerializer$3{
/**
    Create a serializer. `nodes` should map node names to functions
    that take a node and return a description of the corresponding
    DOM. `marks` does the same for mark names, but also gets an
    argument that tells it whether the mark's content is block or
    inline content (for typical use, it'll always be inline). A mark
    serializer may be `null` to indicate that marks of that type
    should not be serialized.
    */
constructor(
/**
    The node serialization functions.
    */
nodes,
/**
    The mark serialization functions.
    */
marks){this.nodes=nodes,this.marks=marks}
/**
    Serialize the content of this fragment to a DOM fragment. When
    not in the browser, the `document` option, containing a DOM
    document, should be passed so that the serializer can create
    nodes.
    */serializeFragment(fragment,options={},target){target||(target=doc$1$3(options).createDocumentFragment());let top=target,active=[];return fragment.forEach((node=>{if(active.length||node.marks.length){let keep=0,rendered=0;while(keep<active.length&&rendered<node.marks.length){let next=node.marks[rendered];if(this.marks[next.type.name]){if(!next.eq(active[keep][0])||!1===next.type.spec.spanning)break;keep++,rendered++}else rendered++}while(keep<active.length)top=active.pop()[1];while(rendered<node.marks.length){let add=node.marks[rendered++],markDOM=this.serializeMark(add,node.isInline,options);markDOM&&(active.push([add,top]),top.appendChild(markDOM.dom),top=markDOM.contentDOM||markDOM.dom)}}top.appendChild(this.serializeNodeInner(node,options))})),target}
/**
    @internal
    */serializeNodeInner(node,options){let{dom:dom,contentDOM:contentDOM}=DOMSerializer$3.renderSpec(doc$1$3(options),this.nodes[node.type.name](node));if(contentDOM){if(node.isLeaf)throw new RangeError("Content hole not allowed in a leaf node spec");this.serializeFragment(node.content,options,contentDOM)}return dom}
/**
    Serialize this node to a DOM node. This can be useful when you
    need to serialize a part of a document, as opposed to the whole
    document. To serialize a whole document, use
    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
    its [content](https://prosemirror.net/docs/ref/#model.Node.content).
    */serializeNode(node,options={}){let dom=this.serializeNodeInner(node,options);for(let i=node.marks.length-1;i>=0;i--){let wrap=this.serializeMark(node.marks[i],node.isInline,options);wrap&&((wrap.contentDOM||wrap.dom).appendChild(dom),dom=wrap.dom)}return dom}
/**
    @internal
    */serializeMark(mark,inline,options={}){let toDOM=this.marks[mark.type.name];return toDOM&&DOMSerializer$3.renderSpec(doc$1$3(options),toDOM(mark,inline))}
/**
    Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
    the spec has a hole (zero) in it, `contentDOM` will point at the
    node with the hole.
    */static renderSpec(doc,structure,xmlNS=null){if("string"==typeof structure)return{dom:doc.createTextNode(structure)};if(null!=structure.nodeType)return{dom:structure};if(structure.dom&&null!=structure.dom.nodeType)return structure;let contentDOM,tagName=structure[0],space=tagName.indexOf(" ");space>0&&(xmlNS=tagName.slice(0,space),tagName=tagName.slice(space+1));let dom=xmlNS?doc.createElementNS(xmlNS,tagName):doc.createElement(tagName),attrs=structure[1],start=1;if(attrs&&"object"==typeof attrs&&null==attrs.nodeType&&!Array.isArray(attrs)){start=2;for(let name in attrs)if(null!=attrs[name]){let space=name.indexOf(" ");space>0?dom.setAttributeNS(name.slice(0,space),name.slice(space+1),attrs[name]):dom.setAttribute(name,attrs[name])}}for(let i=start;i<structure.length;i++){let child=structure[i];if(0===child){if(i<structure.length-1||i>start)throw new RangeError("Content hole must be the only child of its parent node");return{dom:dom,contentDOM:dom}}{let{dom:inner,contentDOM:innerContent}=DOMSerializer$3.renderSpec(doc,child,xmlNS);if(dom.appendChild(inner),innerContent){if(contentDOM)throw new RangeError("Multiple content holes");contentDOM=innerContent}}}return{dom:dom,contentDOM:contentDOM}}
/**
    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
    properties in a schema's node and mark specs.
    */static fromSchema(schema){return schema.cached.domSerializer||(schema.cached.domSerializer=new DOMSerializer$3(this.nodesFromSchema(schema),this.marksFromSchema(schema)))}
/**
    Gather the serializers in a schema's node specs into an object.
    This can be useful as a base to build a custom serializer from.
    */static nodesFromSchema(schema){let result=gatherToDOM$3(schema.nodes);return result.text||(result.text=node=>node.text),result}
/**
    Gather the serializers in a schema's mark specs into an object.
    */static marksFromSchema(schema){return gatherToDOM$3(schema.marks)}}function gatherToDOM$3(obj){let result={};for(let name in obj){let toDOM=obj[name].spec.toDOM;toDOM&&(result[name]=toDOM)}return result}function doc$1$3(options){return options.document||window.document}
// Recovery values encode a range index and an offset. They are
// represented as numbers, because tons of them will be created when
// mapping, for example, a large number of decorations. The number's
// lower 16 bits provide the index, the remaining bits the offset.

// Note: We intentionally don't use bit shift operators to en- and
// decode these, since those clip to 32 bits, which we might in rare
// cases want to overflow. A 64-bit float can represent 48-bit
// integers precisely.
const lower16$3=65535,factor16$3=Math.pow(2,16);function makeRecover$3(index,offset){return index+offset*factor16$3}function recoverIndex$3(value){return value&lower16$3}function recoverOffset$3(value){return(value-(value&lower16$3))/factor16$3}const DEL_BEFORE$3=1,DEL_AFTER$3=2,DEL_ACROSS$3=4,DEL_SIDE$3=8;
/**
An object representing a mapped position with extra
information.
*/class MapResult$3{
/**
    @internal
    */
constructor(
/**
    The mapped version of the position.
    */
pos,
/**
    @internal
    */
delInfo,
/**
    @internal
    */
recover){this.pos=pos,this.delInfo=delInfo,this.recover=recover}
/**
    Tells you whether the position was deleted, that is, whether the
    step removed the token on the side queried (via the `assoc`)
    argument from the document.
    */get deleted(){return(this.delInfo&DEL_SIDE$3)>0}
/**
    Tells you whether the token before the mapped position was deleted.
    */get deletedBefore(){return(this.delInfo&(DEL_BEFORE$3|DEL_ACROSS$3))>0}
/**
    True when the token after the mapped position was deleted.
    */get deletedAfter(){return(this.delInfo&(DEL_AFTER$3|DEL_ACROSS$3))>0}
/**
    Tells whether any of the steps mapped through deletes across the
    position (including both the token before and after the
    position).
    */get deletedAcross(){return(this.delInfo&DEL_ACROSS$3)>0}}
/**
A map describing the deletions and insertions made by a step, which
can be used to find the correspondence between positions in the
pre-step version of a document and the same position in the
post-step version.
*/class StepMap$3{
/**
    Create a position map. The modifications to the document are
    represented as an array of numbers, in which each group of three
    represents a modified chunk as `[start, oldSize, newSize]`.
    */
constructor(
/**
    @internal
    */
ranges,
/**
    @internal
    */
inverted=!1){if(this.ranges=ranges,this.inverted=inverted,!ranges.length&&StepMap$3.empty)return StepMap$3.empty}
/**
    @internal
    */recover(value){let diff=0,index=recoverIndex$3(value);if(!this.inverted)for(let i=0;i<index;i++)diff+=this.ranges[3*i+2]-this.ranges[3*i+1];return this.ranges[3*index]+diff+recoverOffset$3(value)}mapResult(pos,assoc=1){return this._map(pos,assoc,!1)}map(pos,assoc=1){return this._map(pos,assoc,!0)}
/**
    @internal
    */_map(pos,assoc,simple){let diff=0,oldIndex=this.inverted?2:1,newIndex=this.inverted?1:2;for(let i=0;i<this.ranges.length;i+=3){let start=this.ranges[i]-(this.inverted?diff:0);if(start>pos)break;let oldSize=this.ranges[i+oldIndex],newSize=this.ranges[i+newIndex],end=start+oldSize;if(pos<=end){let side=oldSize?pos==start?-1:pos==end?1:assoc:assoc,result=start+diff+(side<0?0:newSize);if(simple)return result;let recover=pos==(assoc<0?start:end)?null:makeRecover$3(i/3,pos-start),del=pos==start?DEL_AFTER$3:pos==end?DEL_BEFORE$3:DEL_ACROSS$3;return(assoc<0?pos!=start:pos!=end)&&(del|=DEL_SIDE$3),new MapResult$3(result,del,recover)}diff+=newSize-oldSize}return simple?pos+diff:new MapResult$3(pos+diff,0,null)}
/**
    @internal
    */touches(pos,recover){let diff=0,index=recoverIndex$3(recover),oldIndex=this.inverted?2:1,newIndex=this.inverted?1:2;for(let i=0;i<this.ranges.length;i+=3){let start=this.ranges[i]-(this.inverted?diff:0);if(start>pos)break;let oldSize=this.ranges[i+oldIndex],end=start+oldSize;if(pos<=end&&i==3*index)return!0;diff+=this.ranges[i+newIndex]-oldSize}return!1}
/**
    Calls the given function on each of the changed ranges included in
    this map.
    */forEach(f){let oldIndex=this.inverted?2:1,newIndex=this.inverted?1:2;for(let i=0,diff=0;i<this.ranges.length;i+=3){let start=this.ranges[i],oldStart=start-(this.inverted?diff:0),newStart=start+(this.inverted?0:diff),oldSize=this.ranges[i+oldIndex],newSize=this.ranges[i+newIndex];f(oldStart,oldStart+oldSize,newStart,newStart+newSize),diff+=newSize-oldSize}}
/**
    Create an inverted version of this map. The result can be used to
    map positions in the post-step document to the pre-step document.
    */invert(){return new StepMap$3(this.ranges,!this.inverted)}
/**
    @internal
    */toString(){return(this.inverted?"-":"")+JSON.stringify(this.ranges)}
/**
    Create a map that moves all positions by offset `n` (which may be
    negative). This can be useful when applying steps meant for a
    sub-document to a larger document, or vice-versa.
    */static offset(n){return 0==n?StepMap$3.empty:new StepMap$3(n<0?[0,-n,0]:[0,0,n])}}
/**
A StepMap that contains no changed ranges.
*/StepMap$3.empty=new StepMap$3([]);
/**
A mapping represents a pipeline of zero or more [step
maps](https://prosemirror.net/docs/ref/#transform.StepMap). It has special provisions for losslessly
handling mapping positions through a series of steps in which some
steps are inverted versions of earlier steps. (This comes up when
‘[rebasing](/docs/guide/#transform.rebasing)’ steps for
collaboration or history management.)
*/
class Mapping$3{
/**
    Create a new mapping with the given position maps.
    */
constructor(
/**
    The step maps in this mapping.
    */
maps=[]
/**
    @internal
    */,mirror,
/**
    The starting position in the `maps` array, used when `map` or
    `mapResult` is called.
    */
from=0
/**
    The end position in the `maps` array.
    */,to=maps.length){this.maps=maps,this.mirror=mirror,this.from=from,this.to=to}
/**
    Create a mapping that maps only through a part of this one.
    */slice(from=0,to=this.maps.length){return new Mapping$3(this.maps,this.mirror,from,to)}
/**
    @internal
    */copy(){return new Mapping$3(this.maps.slice(),this.mirror&&this.mirror.slice(),this.from,this.to)}
/**
    Add a step map to the end of this mapping. If `mirrors` is
    given, it should be the index of the step map that is the mirror
    image of this one.
    */appendMap(map,mirrors){this.to=this.maps.push(map),null!=mirrors&&this.setMirror(this.maps.length-1,mirrors)}
/**
    Add all the step maps in a given mapping to this one (preserving
    mirroring information).
    */appendMapping(mapping){for(let i=0,startSize=this.maps.length;i<mapping.maps.length;i++){let mirr=mapping.getMirror(i);this.appendMap(mapping.maps[i],null!=mirr&&mirr<i?startSize+mirr:void 0)}}
/**
    Finds the offset of the step map that mirrors the map at the
    given offset, in this mapping (as per the second argument to
    `appendMap`).
    */getMirror(n){if(this.mirror)for(let i=0;i<this.mirror.length;i++)if(this.mirror[i]==n)return this.mirror[i+(i%2?-1:1)]}
/**
    @internal
    */setMirror(n,m){this.mirror||(this.mirror=[]),this.mirror.push(n,m)}
/**
    Append the inverse of the given mapping to this one.
    */appendMappingInverted(mapping){for(let i=mapping.maps.length-1,totalSize=this.maps.length+mapping.maps.length;i>=0;i--){let mirr=mapping.getMirror(i);this.appendMap(mapping.maps[i].invert(),null!=mirr&&mirr>i?totalSize-mirr-1:void 0)}}
/**
    Create an inverted version of this mapping.
    */invert(){let inverse=new Mapping$3;return inverse.appendMappingInverted(this),inverse}
/**
    Map a position through this mapping.
    */map(pos,assoc=1){if(this.mirror)return this._map(pos,assoc,!0);for(let i=this.from;i<this.to;i++)pos=this.maps[i].map(pos,assoc);return pos}
/**
    Map a position through this mapping, returning a mapping
    result.
    */mapResult(pos,assoc=1){return this._map(pos,assoc,!1)}
/**
    @internal
    */_map(pos,assoc,simple){let delInfo=0;for(let i=this.from;i<this.to;i++){let map=this.maps[i],result=map.mapResult(pos,assoc);if(null!=result.recover){let corr=this.getMirror(i);if(null!=corr&&corr>i&&corr<this.to){i=corr,pos=this.maps[corr].recover(result.recover);continue}}delInfo|=result.delInfo,pos=result.pos}return simple?pos:new MapResult$3(pos,delInfo,null)}}const stepsByID$3=Object.create(null);
/**
A step object represents an atomic change. It generally applies
only to the document it was created for, since the positions
stored in it will only make sense for that document.

New steps are defined by creating classes that extend `Step`,
overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`
methods, and registering your class with a unique
JSON-serialization identifier using
[`Step.jsonID`](https://prosemirror.net/docs/ref/#transform.Step^jsonID).
*/class Step$3{
/**
    Get the step map that represents the changes made by this step,
    and which can be used to transform between positions in the old
    and the new document.
    */
getMap(){return StepMap$3.empty}
/**
    Try to merge this step with another one, to be applied directly
    after it. Returns the merged step when possible, null if the
    steps can't be merged.
    */merge(other){return null}
/**
    Deserialize a step from its JSON representation. Will call
    through to the step class' own implementation of this method.
    */static fromJSON(schema,json){if(!json||!json.stepType)throw new RangeError("Invalid input for Step.fromJSON");let type=stepsByID$3[json.stepType];if(!type)throw new RangeError(`No step type ${json.stepType} defined`);return type.fromJSON(schema,json)}
/**
    To be able to serialize steps to JSON, each step needs a string
    ID to attach to its JSON representation. Use this method to
    register an ID for your step classes. Try to pick something
    that's unlikely to clash with steps from other modules.
    */static jsonID(id,stepClass){if(id in stepsByID$3)throw new RangeError("Duplicate use of step JSON ID "+id);return stepsByID$3[id]=stepClass,stepClass.prototype.jsonID=id,stepClass}}
/**
The result of [applying](https://prosemirror.net/docs/ref/#transform.Step.apply) a step. Contains either a
new document or a failure value.
*/class StepResult$3{
/**
    @internal
    */
constructor(
/**
    The transformed document, if successful.
    */
doc,
/**
    The failure message, if unsuccessful.
    */
failed){this.doc=doc,this.failed=failed}
/**
    Create a successful step result.
    */static ok(doc){return new StepResult$3(doc,null)}
/**
    Create a failed step result.
    */static fail(message){return new StepResult$3(null,message)}
/**
    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
    arguments. Create a successful result if it succeeds, and a
    failed one if it throws a `ReplaceError`.
    */static fromReplace(doc,from,to,slice){try{return StepResult$3.ok(doc.replace(from,to,slice))}catch(e){if(e instanceof ReplaceError$3)return StepResult$3.fail(e.message);throw e}}}function mapFragment$3(fragment,f,parent){let mapped=[];for(let i=0;i<fragment.childCount;i++){let child=fragment.child(i);child.content.size&&(child=child.copy(mapFragment$3(child.content,f,child))),child.isInline&&(child=f(child,parent,i)),mapped.push(child)}return Fragment$3.fromArray(mapped)}
/**
Add a mark to all inline content between two positions.
*/class AddMarkStep$3 extends Step$3{
/**
    Create a mark step.
    */
constructor(
/**
    The start of the marked range.
    */
from,
/**
    The end of the marked range.
    */
to,
/**
    The mark to add.
    */
mark){super(),this.from=from,this.to=to,this.mark=mark}apply(doc){let oldSlice=doc.slice(this.from,this.to),$from=doc.resolve(this.from),parent=$from.node($from.sharedDepth(this.to)),slice=new Slice$3(mapFragment$3(oldSlice.content,((node,parent)=>node.isAtom&&parent.type.allowsMarkType(this.mark.type)?node.mark(this.mark.addToSet(node.marks)):node),parent),oldSlice.openStart,oldSlice.openEnd);return StepResult$3.fromReplace(doc,this.from,this.to,slice)}invert(){return new RemoveMarkStep$3(this.from,this.to,this.mark)}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1);return from.deleted&&to.deleted||from.pos>=to.pos?null:new AddMarkStep$3(from.pos,to.pos,this.mark)}merge(other){return other instanceof AddMarkStep$3&&other.mark.eq(this.mark)&&this.from<=other.to&&this.to>=other.from?new AddMarkStep$3(Math.min(this.from,other.from),Math.max(this.to,other.to),this.mark):null}toJSON(){return{stepType:"addMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to)throw new RangeError("Invalid input for AddMarkStep.fromJSON");return new AddMarkStep$3(json.from,json.to,schema.markFromJSON(json.mark))}}Step$3.jsonID("addMark",AddMarkStep$3);
/**
Remove a mark from all inline content between two positions.
*/
class RemoveMarkStep$3 extends Step$3{
/**
    Create a mark-removing step.
    */
constructor(
/**
    The start of the unmarked range.
    */
from,
/**
    The end of the unmarked range.
    */
to,
/**
    The mark to remove.
    */
mark){super(),this.from=from,this.to=to,this.mark=mark}apply(doc){let oldSlice=doc.slice(this.from,this.to),slice=new Slice$3(mapFragment$3(oldSlice.content,(node=>node.mark(this.mark.removeFromSet(node.marks))),doc),oldSlice.openStart,oldSlice.openEnd);return StepResult$3.fromReplace(doc,this.from,this.to,slice)}invert(){return new AddMarkStep$3(this.from,this.to,this.mark)}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1);return from.deleted&&to.deleted||from.pos>=to.pos?null:new RemoveMarkStep$3(from.pos,to.pos,this.mark)}merge(other){return other instanceof RemoveMarkStep$3&&other.mark.eq(this.mark)&&this.from<=other.to&&this.to>=other.from?new RemoveMarkStep$3(Math.min(this.from,other.from),Math.max(this.to,other.to),this.mark):null}toJSON(){return{stepType:"removeMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to)throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");return new RemoveMarkStep$3(json.from,json.to,schema.markFromJSON(json.mark))}}Step$3.jsonID("removeMark",RemoveMarkStep$3);
/**
Replace a part of the document with a slice of new content.
*/
class ReplaceStep$3 extends Step$3{
/**
    The given `slice` should fit the 'gap' between `from` and
    `to`—the depths must line up, and the surrounding nodes must be
    able to be joined with the open sides of the slice. When
    `structure` is true, the step will fail if the content between
    from and to is not just a sequence of closing and then opening
    tokens (this is to guard against rebased replace steps
    overwriting something they weren't supposed to).
    */
constructor(
/**
    The start position of the replaced range.
    */
from,
/**
    The end position of the replaced range.
    */
to,
/**
    The slice to insert.
    */
slice,
/**
    @internal
    */
structure=!1){super(),this.from=from,this.to=to,this.slice=slice,this.structure=structure}apply(doc){return this.structure&&contentBetween$3(doc,this.from,this.to)?StepResult$3.fail("Structure replace would overwrite content"):StepResult$3.fromReplace(doc,this.from,this.to,this.slice)}getMap(){return new StepMap$3([this.from,this.to-this.from,this.slice.size])}invert(doc){return new ReplaceStep$3(this.from,this.from+this.slice.size,doc.slice(this.from,this.to))}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1);return from.deletedAcross&&to.deletedAcross?null:new ReplaceStep$3(from.pos,Math.max(from.pos,to.pos),this.slice)}merge(other){if(!(other instanceof ReplaceStep$3)||other.structure||this.structure)return null;if(this.from+this.slice.size!=other.from||this.slice.openEnd||other.slice.openStart){if(other.to!=this.from||this.slice.openStart||other.slice.openEnd)return null;{let slice=this.slice.size+other.slice.size==0?Slice$3.empty:new Slice$3(other.slice.content.append(this.slice.content),other.slice.openStart,this.slice.openEnd);return new ReplaceStep$3(other.from,this.to,slice,this.structure)}}{let slice=this.slice.size+other.slice.size==0?Slice$3.empty:new Slice$3(this.slice.content.append(other.slice.content),this.slice.openStart,other.slice.openEnd);return new ReplaceStep$3(this.from,this.to+(other.to-other.from),slice,this.structure)}}toJSON(){let json={stepType:"replace",from:this.from,to:this.to};return this.slice.size&&(json.slice=this.slice.toJSON()),this.structure&&(json.structure=!0),json}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to)throw new RangeError("Invalid input for ReplaceStep.fromJSON");return new ReplaceStep$3(json.from,json.to,Slice$3.fromJSON(schema,json.slice),!!json.structure)}}Step$3.jsonID("replace",ReplaceStep$3);
/**
Replace a part of the document with a slice of content, but
preserve a range of the replaced content by moving it into the
slice.
*/
class ReplaceAroundStep$3 extends Step$3{
/**
    Create a replace-around step with the given range and gap.
    `insert` should be the point in the slice into which the content
    of the gap should be moved. `structure` has the same meaning as
    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
    */
constructor(
/**
    The start position of the replaced range.
    */
from,
/**
    The end position of the replaced range.
    */
to,
/**
    The start of preserved range.
    */
gapFrom,
/**
    The end of preserved range.
    */
gapTo,
/**
    The slice to insert.
    */
slice,
/**
    The position in the slice where the preserved range should be
    inserted.
    */
insert,
/**
    @internal
    */
structure=!1){super(),this.from=from,this.to=to,this.gapFrom=gapFrom,this.gapTo=gapTo,this.slice=slice,this.insert=insert,this.structure=structure}apply(doc){if(this.structure&&(contentBetween$3(doc,this.from,this.gapFrom)||contentBetween$3(doc,this.gapTo,this.to)))return StepResult$3.fail("Structure gap-replace would overwrite content");let gap=doc.slice(this.gapFrom,this.gapTo);if(gap.openStart||gap.openEnd)return StepResult$3.fail("Gap is not a flat range");let inserted=this.slice.insertAt(this.insert,gap.content);return inserted?StepResult$3.fromReplace(doc,this.from,this.to,inserted):StepResult$3.fail("Content does not fit in gap")}getMap(){return new StepMap$3([this.from,this.gapFrom-this.from,this.insert,this.gapTo,this.to-this.gapTo,this.slice.size-this.insert])}invert(doc){let gap=this.gapTo-this.gapFrom;return new ReplaceAroundStep$3(this.from,this.from+this.slice.size+gap,this.from+this.insert,this.from+this.insert+gap,doc.slice(this.from,this.to).removeBetween(this.gapFrom-this.from,this.gapTo-this.from),this.gapFrom-this.from,this.structure)}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1),gapFrom=mapping.map(this.gapFrom,-1),gapTo=mapping.map(this.gapTo,1);return from.deletedAcross&&to.deletedAcross||gapFrom<from.pos||gapTo>to.pos?null:new ReplaceAroundStep$3(from.pos,to.pos,gapFrom,gapTo,this.slice,this.insert,this.structure)}toJSON(){let json={stepType:"replaceAround",from:this.from,to:this.to,gapFrom:this.gapFrom,gapTo:this.gapTo,insert:this.insert};return this.slice.size&&(json.slice=this.slice.toJSON()),this.structure&&(json.structure=!0),json}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to||"number"!=typeof json.gapFrom||"number"!=typeof json.gapTo||"number"!=typeof json.insert)throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");return new ReplaceAroundStep$3(json.from,json.to,json.gapFrom,json.gapTo,Slice$3.fromJSON(schema,json.slice),json.insert,!!json.structure)}}function contentBetween$3(doc,from,to){let $from=doc.resolve(from),dist=to-from,depth=$from.depth;while(dist>0&&depth>0&&$from.indexAfter(depth)==$from.node(depth).childCount)depth--,dist--;if(dist>0){let next=$from.node(depth).maybeChild($from.indexAfter(depth));while(dist>0){if(!next||next.isLeaf)return!0;next=next.firstChild,dist--}}return!1}function addMark$3(tr,from,to,mark){let removing,adding,removed=[],added=[];tr.doc.nodesBetween(from,to,((node,pos,parent)=>{if(!node.isInline)return;let marks=node.marks;if(!mark.isInSet(marks)&&parent.type.allowsMarkType(mark.type)){let start=Math.max(pos,from),end=Math.min(pos+node.nodeSize,to),newSet=mark.addToSet(marks);for(let i=0;i<marks.length;i++)marks[i].isInSet(newSet)||(removing&&removing.to==start&&removing.mark.eq(marks[i])?removing.to=end:removed.push(removing=new RemoveMarkStep$3(start,end,marks[i])));adding&&adding.to==start?adding.to=end:added.push(adding=new AddMarkStep$3(start,end,mark))}})),removed.forEach((s=>tr.step(s))),added.forEach((s=>tr.step(s)))}function removeMark$3(tr,from,to,mark){let matched=[],step=0;tr.doc.nodesBetween(from,to,((node,pos)=>{if(!node.isInline)return;step++;let toRemove=null;if(mark instanceof MarkType$3){let found,set=node.marks;while(found=mark.isInSet(set))(toRemove||(toRemove=[])).push(found),set=found.removeFromSet(set)}else mark?mark.isInSet(node.marks)&&(toRemove=[mark]):toRemove=node.marks;if(toRemove&&toRemove.length){let end=Math.min(pos+node.nodeSize,to);for(let i=0;i<toRemove.length;i++){let found,style=toRemove[i];for(let j=0;j<matched.length;j++){let m=matched[j];m.step==step-1&&style.eq(matched[j].style)&&(found=m)}found?(found.to=end,found.step=step):matched.push({style:style,from:Math.max(pos,from),to:end,step:step})}}})),matched.forEach((m=>tr.step(new RemoveMarkStep$3(m.from,m.to,m.style))))}function clearIncompatible$3(tr,pos,parentType,match=parentType.contentMatch){let node=tr.doc.nodeAt(pos),delSteps=[],cur=pos+1;for(let i=0;i<node.childCount;i++){let child=node.child(i),end=cur+child.nodeSize,allowed=match.matchType(child.type);if(allowed){match=allowed;for(let j=0;j<child.marks.length;j++)parentType.allowsMarkType(child.marks[j].type)||tr.step(new RemoveMarkStep$3(cur,end,child.marks[j]))}else delSteps.push(new ReplaceStep$3(cur,end,Slice$3.empty));cur=end}if(!match.validEnd){let fill=match.fillBefore(Fragment$3.empty,!0);tr.replace(cur,cur,new Slice$3(fill,0,0))}for(let i=delSteps.length-1;i>=0;i--)tr.step(delSteps[i])}function canCut$3(node,start,end){return(0==start||node.canReplace(start,node.childCount))&&(end==node.childCount||node.canReplace(0,end))}
/**
Try to find a target depth to which the content in the given range
can be lifted. Will not go across
[isolating](https://prosemirror.net/docs/ref/#model.NodeSpec.isolating) parent nodes.
*/function liftTarget$3(range){let parent=range.parent,content=parent.content.cutByIndex(range.startIndex,range.endIndex);for(let depth=range.depth;;--depth){let node=range.$from.node(depth),index=range.$from.index(depth),endIndex=range.$to.indexAfter(depth);if(depth<range.depth&&node.canReplace(index,endIndex,content))return depth;if(0==depth||node.type.spec.isolating||!canCut$3(node,index,endIndex))break}return null}function lift$2$3(tr,range,target){let{$from:$from,$to:$to,depth:depth}=range,gapStart=$from.before(depth+1),gapEnd=$to.after(depth+1),start=gapStart,end=gapEnd,before=Fragment$3.empty,openStart=0;for(let d=depth,splitting=!1;d>target;d--)splitting||$from.index(d)>0?(splitting=!0,before=Fragment$3.from($from.node(d).copy(before)),openStart++):start--;let after=Fragment$3.empty,openEnd=0;for(let d=depth,splitting=!1;d>target;d--)splitting||$to.after(d+1)<$to.end(d)?(splitting=!0,after=Fragment$3.from($to.node(d).copy(after)),openEnd++):end++;tr.step(new ReplaceAroundStep$3(start,end,gapStart,gapEnd,new Slice$3(before.append(after),openStart,openEnd),before.size-openStart,!0))}
/**
Try to find a valid way to wrap the content in the given range in a
node of the given type. May introduce extra nodes around and inside
the wrapper node, if necessary. Returns null if no valid wrapping
could be found. When `innerRange` is given, that range's content is
used as the content to fit into the wrapping, instead of the
content of `range`.
*/function findWrapping$3(range,nodeType,attrs=null,innerRange=range){let around=findWrappingOutside$3(range,nodeType),inner=around&&findWrappingInside$3(innerRange,nodeType);return inner?around.map(withAttrs$3).concat({type:nodeType,attrs:attrs}).concat(inner.map(withAttrs$3)):null}function withAttrs$3(type){return{type:type,attrs:null}}function findWrappingOutside$3(range,type){let{parent:parent,startIndex:startIndex,endIndex:endIndex}=range,around=parent.contentMatchAt(startIndex).findWrapping(type);if(!around)return null;let outer=around.length?around[0]:type;return parent.canReplaceWith(startIndex,endIndex,outer)?around:null}function findWrappingInside$3(range,type){let{parent:parent,startIndex:startIndex,endIndex:endIndex}=range,inner=parent.child(startIndex),inside=type.contentMatch.findWrapping(inner.type);if(!inside)return null;let lastType=inside.length?inside[inside.length-1]:type,innerMatch=lastType.contentMatch;for(let i=startIndex;innerMatch&&i<endIndex;i++)innerMatch=innerMatch.matchType(parent.child(i).type);return innerMatch&&innerMatch.validEnd?inside:null}function wrap$3(tr,range,wrappers){let content=Fragment$3.empty;for(let i=wrappers.length-1;i>=0;i--){if(content.size){let match=wrappers[i].type.contentMatch.matchFragment(content);if(!match||!match.validEnd)throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper")}content=Fragment$3.from(wrappers[i].type.create(wrappers[i].attrs,content))}let start=range.start,end=range.end;tr.step(new ReplaceAroundStep$3(start,end,start,end,new Slice$3(content,0,0),wrappers.length,!0))}function setBlockType$1$3(tr,from,to,type,attrs){if(!type.isTextblock)throw new RangeError("Type given to setBlockType should be a textblock");let mapFrom=tr.steps.length;tr.doc.nodesBetween(from,to,((node,pos)=>{if(node.isTextblock&&!node.hasMarkup(type,attrs)&&canChangeType$3(tr.doc,tr.mapping.slice(mapFrom).map(pos),type)){
// Ensure all markup that isn't allowed in the new node type is cleared
tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos,1),type);let mapping=tr.mapping.slice(mapFrom),startM=mapping.map(pos,1),endM=mapping.map(pos+node.nodeSize,1);return tr.step(new ReplaceAroundStep$3(startM,endM,startM+1,endM-1,new Slice$3(Fragment$3.from(type.create(attrs,null,node.marks)),0,0),1,!0)),!1}}))}function canChangeType$3(doc,pos,type){let $pos=doc.resolve(pos),index=$pos.index();return $pos.parent.canReplaceWith(index,index+1,type)}
/**
Change the type, attributes, and/or marks of the node at `pos`.
When `type` isn't given, the existing node type is preserved,
*/function setNodeMarkup$3(tr,pos,type,attrs,marks){let node=tr.doc.nodeAt(pos);if(!node)throw new RangeError("No node at given position");type||(type=node.type);let newNode=type.create(attrs,null,marks||node.marks);if(node.isLeaf)return tr.replaceWith(pos,pos+node.nodeSize,newNode);if(!type.validContent(node.content))throw new RangeError("Invalid content for node type "+type.name);tr.step(new ReplaceAroundStep$3(pos,pos+node.nodeSize,pos+1,pos+node.nodeSize-1,new Slice$3(Fragment$3.from(newNode),0,0),1,!0))}
/**
Check whether splitting at the given position is allowed.
*/function canSplit$3(doc,pos,depth=1,typesAfter){let $pos=doc.resolve(pos),base=$pos.depth-depth,innerType=typesAfter&&typesAfter[typesAfter.length-1]||$pos.parent;if(base<0||$pos.parent.type.spec.isolating||!$pos.parent.canReplace($pos.index(),$pos.parent.childCount)||!innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(),$pos.parent.childCount)))return!1;for(let d=$pos.depth-1,i=depth-2;d>base;d--,i--){let node=$pos.node(d),index=$pos.index(d);if(node.type.spec.isolating)return!1;let rest=node.content.cutByIndex(index,node.childCount),after=typesAfter&&typesAfter[i]||node;if(after!=node&&(rest=rest.replaceChild(0,after.type.create(after.attrs))),!node.canReplace(index+1,node.childCount)||!after.type.validContent(rest))return!1}let index=$pos.indexAfter(base),baseType=typesAfter&&typesAfter[0];return $pos.node(base).canReplaceWith(index,index,baseType?baseType.type:$pos.node(base+1).type)}function split$3(tr,pos,depth=1,typesAfter){let $pos=tr.doc.resolve(pos),before=Fragment$3.empty,after=Fragment$3.empty;for(let d=$pos.depth,e=$pos.depth-depth,i=depth-1;d>e;d--,i--){before=Fragment$3.from($pos.node(d).copy(before));let typeAfter=typesAfter&&typesAfter[i];after=Fragment$3.from(typeAfter?typeAfter.type.create(typeAfter.attrs,after):$pos.node(d).copy(after))}tr.step(new ReplaceStep$3(pos,pos,new Slice$3(before.append(after),depth,depth),!0))}
/**
Test whether the blocks before and after a given position can be
joined.
*/function canJoin$3(doc,pos){let $pos=doc.resolve(pos),index=$pos.index();return joinable$4($pos.nodeBefore,$pos.nodeAfter)&&$pos.parent.canReplace(index,index+1)}function joinable$4(a,b){return!(!a||!b||a.isLeaf||!a.canAppend(b))}function join$3(tr,pos,depth){let step=new ReplaceStep$3(pos-depth,pos+depth,Slice$3.empty,!0);tr.step(step)}
/**
Try to find a point where a node of the given type can be inserted
near `pos`, by searching up the node hierarchy when `pos` itself
isn't a valid place but is at the start or end of a node. Return
null if no position was found.
*/function insertPoint$3(doc,pos,nodeType){let $pos=doc.resolve(pos);if($pos.parent.canReplaceWith($pos.index(),$pos.index(),nodeType))return pos;if(0==$pos.parentOffset)for(let d=$pos.depth-1;d>=0;d--){let index=$pos.index(d);if($pos.node(d).canReplaceWith(index,index,nodeType))return $pos.before(d+1);if(index>0)return null}if($pos.parentOffset==$pos.parent.content.size)for(let d=$pos.depth-1;d>=0;d--){let index=$pos.indexAfter(d);if($pos.node(d).canReplaceWith(index,index,nodeType))return $pos.after(d+1);if(index<$pos.node(d).childCount)return null}return null}
/**
Finds a position at or around the given position where the given
slice can be inserted. Will look at parent nodes' nearest boundary
and try there, even if the original position wasn't directly at the
start or end of that node. Returns null when no position was found.
*/function dropPoint$3(doc,pos,slice){let $pos=doc.resolve(pos);if(!slice.content.size)return pos;let content=slice.content;for(let i=0;i<slice.openStart;i++)content=content.firstChild.content;for(let pass=1;pass<=(0==slice.openStart&&slice.size?2:1);pass++)for(let d=$pos.depth;d>=0;d--){let bias=d==$pos.depth?0:$pos.pos<=($pos.start(d+1)+$pos.end(d+1))/2?-1:1,insertPos=$pos.index(d)+(bias>0?1:0),parent=$pos.node(d),fits=!1;if(1==pass)fits=parent.canReplace(insertPos,insertPos,content);else{let wrapping=parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);fits=wrapping&&parent.canReplaceWith(insertPos,insertPos,wrapping[0])}if(fits)return 0==bias?$pos.pos:bias<0?$pos.before(d+1):$pos.after(d+1)}return null}
/**
‘Fit’ a slice into a given position in the document, producing a
[step](https://prosemirror.net/docs/ref/#transform.Step) that inserts it. Will return null if
there's no meaningful way to insert the slice here, or inserting it
would be a no-op (an empty slice over an empty range).
*/function replaceStep$3(doc,from,to=from,slice=Slice$3.empty){if(from==to&&!slice.size)return null;let $from=doc.resolve(from),$to=doc.resolve(to);
// Optimization -- avoid work if it's obvious that it's not needed.
return fitsTrivially$3($from,$to,slice)?new ReplaceStep$3(from,to,slice):new Fitter$3($from,$to,slice).fit()}function fitsTrivially$3($from,$to,slice){return!slice.openStart&&!slice.openEnd&&$from.start()==$to.start()&&$from.parent.canReplace($from.index(),$to.index(),slice.content)}
// Algorithm for 'placing' the elements of a slice into a gap:

// We consider the content of each node that is open to the left to be
// independently placeable. I.e. in <p("foo"), p("bar")>, when the
// paragraph on the left is open, "foo" can be placed (somewhere on
// the left side of the replacement gap) independently from p("bar").

// This class tracks the state of the placement progress in the
// following properties:

//  - `frontier` holds a stack of `{type, match}` objects that
//    represent the open side of the replacement. It starts at
//    `$from`, then moves forward as content is placed, and is finally
//    reconciled with `$to`.

//  - `unplaced` is a slice that represents the content that hasn't
//    been placed yet.

//  - `placed` is a fragment of placed content. Its open-start value
//    is implicit in `$from`, and its open-end value in `frontier`.
Step$3.jsonID("replaceAround",ReplaceAroundStep$3);class Fitter$3{constructor($from,$to,unplaced){this.$from=$from,this.$to=$to,this.unplaced=unplaced,this.frontier=[],this.placed=Fragment$3.empty;for(let i=0;i<=$from.depth;i++){let node=$from.node(i);this.frontier.push({type:node.type,match:node.contentMatchAt($from.indexAfter(i))})}for(let i=$from.depth;i>0;i--)this.placed=Fragment$3.from($from.node(i).copy(this.placed))}get depth(){return this.frontier.length-1}fit(){
// As long as there's unplaced content, try to place some of it.
// If that fails, either increase the open score of the unplaced
// slice, or drop nodes from it, and then try again.
while(this.unplaced.size){let fit=this.findFittable();fit?this.placeNodes(fit):this.openMore()||this.dropNode()}
// When there's inline content directly after the frontier _and_
// directly after `this.$to`, we must generate a `ReplaceAround`
// step that pulls that content into the node after the frontier.
// That means the fitting must be done to the end of the textblock
// node after `this.$to`, not `this.$to` itself.
let moveInline=this.mustMoveInline(),placedSize=this.placed.size-this.depth-this.$from.depth,$from=this.$from,$to=this.close(moveInline<0?this.$to:$from.doc.resolve(moveInline));if(!$to)return null;
// If closing to `$to` succeeded, create a step
let content=this.placed,openStart=$from.depth,openEnd=$to.depth;while(openStart&&openEnd&&1==content.childCount)// Normalize by dropping open parent nodes
content=content.firstChild.content,openStart--,openEnd--;let slice=new Slice$3(content,openStart,openEnd);return moveInline>-1?new ReplaceAroundStep$3($from.pos,moveInline,this.$to.pos,this.$to.end(),slice,placedSize):slice.size||$from.pos!=this.$to.pos?new ReplaceStep$3($from.pos,$to.pos,slice):null}
// Find a position on the start spine of `this.unplaced` that has
// content that can be moved somewhere on the frontier. Returns two
// depths, one for the slice and one for the frontier.
findFittable(){
// Only try wrapping nodes (pass 2) after finding a place without
// wrapping failed.
for(let pass=1;pass<=2;pass++)for(let sliceDepth=this.unplaced.openStart;sliceDepth>=0;sliceDepth--){let fragment,parent=null;sliceDepth?(parent=contentAt$3(this.unplaced.content,sliceDepth-1).firstChild,fragment=parent.content):fragment=this.unplaced.content;let first=fragment.firstChild;for(let frontierDepth=this.depth;frontierDepth>=0;frontierDepth--){let wrap,{type:type,match:match}=this.frontier[frontierDepth],inject=null;
// In pass 1, if the next node matches, or there is no next
// node but the parents look compatible, we've found a
// place.
if(1==pass&&(first?match.matchType(first.type)||(inject=match.fillBefore(Fragment$3.from(first),!1)):parent&&type.compatibleContent(parent.type)))return{sliceDepth:sliceDepth,frontierDepth:frontierDepth,parent:parent,inject:inject};
// In pass 2, look for a set of wrapping nodes that make
// `first` fit here.
// Don't continue looking further up if the parent node
// would fit here.
if(2==pass&&first&&(wrap=match.findWrapping(first.type)))return{sliceDepth:sliceDepth,frontierDepth:frontierDepth,parent:parent,wrap:wrap};if(parent&&match.matchType(parent.type))break}}}openMore(){let{content:content,openStart:openStart,openEnd:openEnd}=this.unplaced,inner=contentAt$3(content,openStart);return!(!inner.childCount||inner.firstChild.isLeaf)&&(this.unplaced=new Slice$3(content,openStart+1,Math.max(openEnd,inner.size+openStart>=content.size-openEnd?openStart+1:0)),!0)}dropNode(){let{content:content,openStart:openStart,openEnd:openEnd}=this.unplaced,inner=contentAt$3(content,openStart);if(inner.childCount<=1&&openStart>0){let openAtEnd=content.size-openStart<=openStart+inner.size;this.unplaced=new Slice$3(dropFromFragment$3(content,openStart-1,1),openStart-1,openAtEnd?openStart-1:openEnd)}else this.unplaced=new Slice$3(dropFromFragment$3(content,openStart,1),openStart,openEnd)}
// Move content from the unplaced slice at `sliceDepth` to the
// frontier node at `frontierDepth`. Close that frontier node when
// applicable.
placeNodes({sliceDepth:sliceDepth,frontierDepth:frontierDepth,parent:parent,inject:inject,wrap:wrap}){while(this.depth>frontierDepth)this.closeFrontierNode();if(wrap)for(let i=0;i<wrap.length;i++)this.openFrontierNode(wrap[i]);let slice=this.unplaced,fragment=parent?parent.content:slice.content,openStart=slice.openStart-sliceDepth,taken=0,add=[],{match:match,type:type}=this.frontier[frontierDepth];if(inject){for(let i=0;i<inject.childCount;i++)add.push(inject.child(i));match=match.matchFragment(inject)}
// Computes the amount of (end) open nodes at the end of the
// fragment. When 0, the parent is open, but no more. When
// negative, nothing is open.
let openEndCount=fragment.size+sliceDepth-(slice.content.size-slice.openEnd);
// Scan over the fragment, fitting as many child nodes as
// possible.
while(taken<fragment.childCount){let next=fragment.child(taken),matches=match.matchType(next.type);if(!matches)break;taken++,(taken>1||0==openStart||next.content.size)&&(// Drop empty open nodes
match=matches,add.push(closeNodeStart$3(next.mark(type.allowedMarks(next.marks)),1==taken?openStart:0,taken==fragment.childCount?openEndCount:-1)))}let toEnd=taken==fragment.childCount;toEnd||(openEndCount=-1),this.placed=addToFragment$3(this.placed,frontierDepth,Fragment$3.from(add)),this.frontier[frontierDepth].match=match,
// If the parent types match, and the entire node was moved, and
// it's not open, close this frontier node right away.
toEnd&&openEndCount<0&&parent&&parent.type==this.frontier[this.depth].type&&this.frontier.length>1&&this.closeFrontierNode();
// Add new frontier nodes for any open nodes at the end.
for(let i=0,cur=fragment;i<openEndCount;i++){let node=cur.lastChild;this.frontier.push({type:node.type,match:node.contentMatchAt(node.childCount)}),cur=node.content}
// Update `this.unplaced`. Drop the entire node from which we
// placed it we got to its end, otherwise just drop the placed
// nodes.
this.unplaced=toEnd?0==sliceDepth?Slice$3.empty:new Slice$3(dropFromFragment$3(slice.content,sliceDepth-1,1),sliceDepth-1,openEndCount<0?slice.openEnd:sliceDepth-1):new Slice$3(dropFromFragment$3(slice.content,sliceDepth,taken),slice.openStart,slice.openEnd)}mustMoveInline(){if(!this.$to.parent.isTextblock)return-1;let level,top=this.frontier[this.depth];if(!top.type.isTextblock||!contentAfterFits$3(this.$to,this.$to.depth,top.type,top.match,!1)||this.$to.depth==this.depth&&(level=this.findCloseLevel(this.$to))&&level.depth==this.depth)return-1;let{depth:depth}=this.$to,after=this.$to.after(depth);while(depth>1&&after==this.$to.end(--depth))++after;return after}findCloseLevel($to){scan:for(let i=Math.min(this.depth,$to.depth);i>=0;i--){let{match:match,type:type}=this.frontier[i],dropInner=i<$to.depth&&$to.end(i+1)==$to.pos+($to.depth-(i+1)),fit=contentAfterFits$3($to,i,type,match,dropInner);if(fit){for(let d=i-1;d>=0;d--){let{match:match,type:type}=this.frontier[d],matches=contentAfterFits$3($to,d,type,match,!0);if(!matches||matches.childCount)continue scan}return{depth:i,fit:fit,move:dropInner?$to.doc.resolve($to.after(i+1)):$to}}}}close($to){let close=this.findCloseLevel($to);if(!close)return null;while(this.depth>close.depth)this.closeFrontierNode();close.fit.childCount&&(this.placed=addToFragment$3(this.placed,close.depth,close.fit)),$to=close.move;for(let d=close.depth+1;d<=$to.depth;d++){let node=$to.node(d),add=node.type.contentMatch.fillBefore(node.content,!0,$to.index(d));this.openFrontierNode(node.type,node.attrs,add)}return $to}openFrontierNode(type,attrs=null,content){let top=this.frontier[this.depth];top.match=top.match.matchType(type),this.placed=addToFragment$3(this.placed,this.depth,Fragment$3.from(type.create(attrs,content))),this.frontier.push({type:type,match:type.contentMatch})}closeFrontierNode(){let open=this.frontier.pop(),add=open.match.fillBefore(Fragment$3.empty,!0);add.childCount&&(this.placed=addToFragment$3(this.placed,this.frontier.length,add))}}function dropFromFragment$3(fragment,depth,count){return 0==depth?fragment.cutByIndex(count,fragment.childCount):fragment.replaceChild(0,fragment.firstChild.copy(dropFromFragment$3(fragment.firstChild.content,depth-1,count)))}function addToFragment$3(fragment,depth,content){return 0==depth?fragment.append(content):fragment.replaceChild(fragment.childCount-1,fragment.lastChild.copy(addToFragment$3(fragment.lastChild.content,depth-1,content)))}function contentAt$3(fragment,depth){for(let i=0;i<depth;i++)fragment=fragment.firstChild.content;return fragment}function closeNodeStart$3(node,openStart,openEnd){if(openStart<=0)return node;let frag=node.content;return openStart>1&&(frag=frag.replaceChild(0,closeNodeStart$3(frag.firstChild,openStart-1,1==frag.childCount?openEnd-1:0))),openStart>0&&(frag=node.type.contentMatch.fillBefore(frag).append(frag),openEnd<=0&&(frag=frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment$3.empty,!0)))),node.copy(frag)}function contentAfterFits$3($to,depth,type,match,open){let node=$to.node(depth),index=open?$to.indexAfter(depth):$to.index(depth);if(index==node.childCount&&!type.compatibleContent(node.type))return null;let fit=match.fillBefore(node.content,!0,index);return fit&&!invalidMarks$3(type,node.content,index)?fit:null}function invalidMarks$3(type,fragment,start){for(let i=start;i<fragment.childCount;i++)if(!type.allowsMarks(fragment.child(i).marks))return!0;return!1}function definesContent$3(type){return type.spec.defining||type.spec.definingForContent}function replaceRange$3(tr,from,to,slice){if(!slice.size)return tr.deleteRange(from,to);let $from=tr.doc.resolve(from),$to=tr.doc.resolve(to);if(fitsTrivially$3($from,$to,slice))return tr.step(new ReplaceStep$3(from,to,slice));let targetDepths=coveredDepths$3($from,tr.doc.resolve(to));
// Can't replace the whole document, so remove 0 if it's present
0==targetDepths[targetDepths.length-1]&&targetDepths.pop();
// Negative numbers represent not expansion over the whole node at
// that depth, but replacing from $from.before(-D) to $to.pos.
let preferredTarget=-($from.depth+1);targetDepths.unshift(preferredTarget);
// This loop picks a preferred target depth, if one of the covering
// depths is not outside of a defining node, and adds negative
// depths for any depth that has $from at its start and does not
// cross a defining node.
for(let d=$from.depth,pos=$from.pos-1;d>0;d--,pos--){let spec=$from.node(d).type.spec;if(spec.defining||spec.definingAsContext||spec.isolating)break;targetDepths.indexOf(d)>-1?preferredTarget=d:$from.before(d)==pos&&targetDepths.splice(1,0,-d)}
// Try to fit each possible depth of the slice into each possible
// target depth, starting with the preferred depths.
let preferredTargetIndex=targetDepths.indexOf(preferredTarget),leftNodes=[],preferredDepth=slice.openStart;for(let content=slice.content,i=0;;i++){let node=content.firstChild;if(leftNodes.push(node),i==slice.openStart)break;content=node.content}
// Back up preferredDepth to cover defining textblocks directly
// above it, possibly skipping a non-defining textblock.
for(let d=preferredDepth-1;d>=0;d--){let type=leftNodes[d].type,def=definesContent$3(type);if(def&&$from.node(preferredTargetIndex).type!=type)preferredDepth=d;else if(def||!type.isTextblock)break}for(let j=slice.openStart;j>=0;j--){let openDepth=(j+preferredDepth+1)%(slice.openStart+1),insert=leftNodes[openDepth];if(insert)for(let i=0;i<targetDepths.length;i++){
// Loop over possible expansion levels, starting with the
// preferred one
let targetDepth=targetDepths[(i+preferredTargetIndex)%targetDepths.length],expand=!0;targetDepth<0&&(expand=!1,targetDepth=-targetDepth);let parent=$from.node(targetDepth-1),index=$from.index(targetDepth-1);if(parent.canReplaceWith(index,index,insert.type,insert.marks))return tr.replace($from.before(targetDepth),expand?$to.after(targetDepth):to,new Slice$3(closeFragment$3(slice.content,0,slice.openStart,openDepth),openDepth,slice.openEnd))}}let startSteps=tr.steps.length;for(let i=targetDepths.length-1;i>=0;i--){if(tr.replace(from,to,slice),tr.steps.length>startSteps)break;let depth=targetDepths[i];depth<0||(from=$from.before(depth),to=$to.after(depth))}}function closeFragment$3(fragment,depth,oldOpen,newOpen,parent){if(depth<oldOpen){let first=fragment.firstChild;fragment=fragment.replaceChild(0,first.copy(closeFragment$3(first.content,depth+1,oldOpen,newOpen,first)))}if(depth>newOpen){let match=parent.contentMatchAt(0),start=match.fillBefore(fragment).append(fragment);fragment=start.append(match.matchFragment(start).fillBefore(Fragment$3.empty,!0))}return fragment}function replaceRangeWith$3(tr,from,to,node){if(!node.isInline&&from==to&&tr.doc.resolve(from).parent.content.size){let point=insertPoint$3(tr.doc,from,node.type);null!=point&&(from=to=point)}tr.replaceRange(from,to,new Slice$3(Fragment$3.from(node),0,0))}function deleteRange$1$3(tr,from,to){let $from=tr.doc.resolve(from),$to=tr.doc.resolve(to),covered=coveredDepths$3($from,$to);for(let i=0;i<covered.length;i++){let depth=covered[i],last=i==covered.length-1;if(last&&0==depth||$from.node(depth).type.contentMatch.validEnd)return tr.delete($from.start(depth),$to.end(depth));if(depth>0&&(last||$from.node(depth-1).canReplace($from.index(depth-1),$to.indexAfter(depth-1))))return tr.delete($from.before(depth),$to.after(depth))}for(let d=1;d<=$from.depth&&d<=$to.depth;d++)if(from-$from.start(d)==$from.depth-d&&to>$from.end(d)&&$to.end(d)-to!=$to.depth-d)return tr.delete($from.before(d),to);tr.delete(from,to)}
// Returns an array of all depths for which $from - $to spans the
// whole content of the nodes at that depth.
function coveredDepths$3($from,$to){let result=[],minDepth=Math.min($from.depth,$to.depth);for(let d=minDepth;d>=0;d--){let start=$from.start(d);if(start<$from.pos-($from.depth-d)||$to.end(d)>$to.pos+($to.depth-d)||$from.node(d).type.spec.isolating||$to.node(d).type.spec.isolating)break;(start==$to.start(d)||d==$from.depth&&d==$to.depth&&$from.parent.inlineContent&&$to.parent.inlineContent&&d&&$to.start(d-1)==start-1)&&result.push(d)}return result}
/**
@internal
*/let TransformError$3=class extends Error{};TransformError$3=function TransformError(message){let err=Error.call(this,message);return err.__proto__=TransformError.prototype,err},TransformError$3.prototype=Object.create(Error.prototype),TransformError$3.prototype.constructor=TransformError$3,TransformError$3.prototype.name="TransformError";
/**
Abstraction to build up and track an array of
[steps](https://prosemirror.net/docs/ref/#transform.Step) representing a document transformation.

Most transforming methods return the `Transform` object itself, so
that they can be chained.
*/
class Transform$3{
/**
    Create a transform that starts with the given document.
    */
constructor(
/**
    The current document (the result of applying the steps in the
    transform).
    */
doc){this.doc=doc,
/**
        The steps in this transform.
        */
this.steps=[],
/**
        The documents before each of the steps.
        */
this.docs=[],
/**
        A mapping with the maps for each of the steps in this transform.
        */
this.mapping=new Mapping$3}
/**
    The starting document.
    */get before(){return this.docs.length?this.docs[0]:this.doc}
/**
    Apply a new step in this transform, saving the result. Throws an
    error when the step fails.
    */step(step){let result=this.maybeStep(step);if(result.failed)throw new TransformError$3(result.failed);return this}
/**
    Try to apply a step in this transformation, ignoring it if it
    fails. Returns the step result.
    */maybeStep(step){let result=step.apply(this.doc);return result.failed||this.addStep(step,result.doc),result}
/**
    True when the document has been changed (when there are any
    steps).
    */get docChanged(){return this.steps.length>0}
/**
    @internal
    */addStep(step,doc){this.docs.push(this.doc),this.steps.push(step),this.mapping.appendMap(step.getMap()),this.doc=doc}
/**
    Replace the part of the document between `from` and `to` with the
    given `slice`.
    */replace(from,to=from,slice=Slice$3.empty){let step=replaceStep$3(this.doc,from,to,slice);return step&&this.step(step),this}
/**
    Replace the given range with the given content, which may be a
    fragment, node, or array of nodes.
    */replaceWith(from,to,content){return this.replace(from,to,new Slice$3(Fragment$3.from(content),0,0))}
/**
    Delete the content between the given positions.
    */delete(from,to){return this.replace(from,to,Slice$3.empty)}
/**
    Insert the given content at the given position.
    */insert(pos,content){return this.replaceWith(pos,pos,content)}
/**
    Replace a range of the document with a given slice, using
    `from`, `to`, and the slice's
    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
    than fixed start and end points. This method may grow the
    replaced area or close open nodes in the slice in order to get a
    fit that is more in line with WYSIWYG expectations, by dropping
    fully covered parent nodes of the replaced region when they are
    marked [non-defining as
    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
    open parent node from the slice that _is_ marked as [defining
    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
    
    This is the method, for example, to handle paste. The similar
    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
    primitive tool which will _not_ move the start and end of its given
    range, and is useful in situations where you need more precise
    control over what happens.
    */replaceRange(from,to,slice){return replaceRange$3(this,from,to,slice),this}
/**
    Replace the given range with a node, but use `from` and `to` as
    hints, rather than precise positions. When from and to are the same
    and are at the start or end of a parent node in which the given
    node doesn't fit, this method may _move_ them out towards a parent
    that does allow the given node to be placed. When the given range
    completely covers a parent node, this method may completely replace
    that parent node.
    */replaceRangeWith(from,to,node){return replaceRangeWith$3(this,from,to,node),this}
/**
    Delete the given range, expanding it to cover fully covered
    parent nodes until a valid replace is found.
    */deleteRange(from,to){return deleteRange$1$3(this,from,to),this}
/**
    Split the content in the given range off from its parent, if there
    is sibling content before or after it, and move it up the tree to
    the depth specified by `target`. You'll probably want to use
    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
    sure the lift is valid.
    */lift(range,target){return lift$2$3(this,range,target),this}
/**
    Join the blocks around the given position. If depth is 2, their
    last and first siblings are also joined, and so on.
    */join(pos,depth=1){return join$3(this,pos,depth),this}
/**
    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
    The wrappers are assumed to be valid in this position, and should
    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
    */wrap(range,wrappers){return wrap$3(this,range,wrappers),this}
/**
    Set the type of all textblocks (partly) between `from` and `to` to
    the given node type with the given attributes.
    */setBlockType(from,to=from,type,attrs=null){return setBlockType$1$3(this,from,to,type,attrs),this}
/**
    Change the type, attributes, and/or marks of the node at `pos`.
    When `type` isn't given, the existing node type is preserved,
    */setNodeMarkup(pos,type,attrs=null,marks=[]){return setNodeMarkup$3(this,pos,type,attrs,marks),this}
/**
    Split the node at the given position, and optionally, if `depth` is
    greater than one, any number of nodes above that. By default, the
    parts split off will inherit the node type of the original node.
    This can be changed by passing an array of types and attributes to
    use after the split.
    */split(pos,depth=1,typesAfter){return split$3(this,pos,depth,typesAfter),this}
/**
    Add the given mark to the inline content between `from` and `to`.
    */addMark(from,to,mark){return addMark$3(this,from,to,mark),this}
/**
    Remove marks from inline nodes between `from` and `to`. When
    `mark` is a single mark, remove precisely that mark. When it is
    a mark type, remove all marks of that type. When it is null,
    remove all marks of any type.
    */removeMark(from,to,mark){return removeMark$3(this,from,to,mark),this}
/**
    Removes all marks and nodes from the content of the node at
    `pos` that don't match the given new parent node type. Accepts
    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
    third argument.
    */clearIncompatible(pos,parentType,match){return clearIncompatible$3(this,pos,parentType,match),this}}const classesById$3=Object.create(null);
/**
Superclass for editor selections. Every selection type should
extend this. Should not be instantiated directly.
*/class Selection$3{
/**
    Initialize a selection with the head and anchor and ranges. If no
    ranges are given, constructs a single range across `$anchor` and
    `$head`.
    */
constructor(
/**
    The resolved anchor of the selection (the side that stays in
    place when the selection is modified).
    */
$anchor,
/**
    The resolved head of the selection (the side that moves when
    the selection is modified).
    */
$head,ranges){this.$anchor=$anchor,this.$head=$head,this.ranges=ranges||[new SelectionRange$3($anchor.min($head),$anchor.max($head))]}
/**
    The selection's anchor, as an unresolved position.
    */get anchor(){return this.$anchor.pos}
/**
    The selection's head.
    */get head(){return this.$head.pos}
/**
    The lower bound of the selection's main range.
    */get from(){return this.$from.pos}
/**
    The upper bound of the selection's main range.
    */get to(){return this.$to.pos}
/**
    The resolved lower  bound of the selection's main range.
    */get $from(){return this.ranges[0].$from}
/**
    The resolved upper bound of the selection's main range.
    */get $to(){return this.ranges[0].$to}
/**
    Indicates whether the selection contains any content.
    */get empty(){let ranges=this.ranges;for(let i=0;i<ranges.length;i++)if(ranges[i].$from.pos!=ranges[i].$to.pos)return!1;return!0}
/**
    Get the content of this selection as a slice.
    */content(){return this.$from.doc.slice(this.from,this.to,!0)}
/**
    Replace the selection with a slice or, if no slice is given,
    delete the selection. Will append to the given transaction.
    */replace(tr,content=Slice$3.empty){
// Put the new selection at the position after the inserted
// content. When that ended in an inline node, search backwards,
// to get the position after that node. If not, search forward.
let lastNode=content.content.lastChild,lastParent=null;for(let i=0;i<content.openEnd;i++)lastParent=lastNode,lastNode=lastNode.lastChild;let mapFrom=tr.steps.length,ranges=this.ranges;for(let i=0;i<ranges.length;i++){let{$from:$from,$to:$to}=ranges[i],mapping=tr.mapping.slice(mapFrom);tr.replaceRange(mapping.map($from.pos),mapping.map($to.pos),i?Slice$3.empty:content),0==i&&selectionToInsertionEnd$1$3(tr,mapFrom,(lastNode?lastNode.isInline:lastParent&&lastParent.isTextblock)?-1:1)}}
/**
    Replace the selection with the given node, appending the changes
    to the given transaction.
    */replaceWith(tr,node){let mapFrom=tr.steps.length,ranges=this.ranges;for(let i=0;i<ranges.length;i++){let{$from:$from,$to:$to}=ranges[i],mapping=tr.mapping.slice(mapFrom),from=mapping.map($from.pos),to=mapping.map($to.pos);i?tr.deleteRange(from,to):(tr.replaceRangeWith(from,to,node),selectionToInsertionEnd$1$3(tr,mapFrom,node.isInline?-1:1))}}
/**
    Find a valid cursor or leaf node selection starting at the given
    position and searching back if `dir` is negative, and forward if
    positive. When `textOnly` is true, only consider cursor
    selections. Will return null when no valid selection position is
    found.
    */static findFrom($pos,dir,textOnly=!1){let inner=$pos.parent.inlineContent?new TextSelection$3($pos):findSelectionIn$3($pos.node(0),$pos.parent,$pos.pos,$pos.index(),dir,textOnly);if(inner)return inner;for(let depth=$pos.depth-1;depth>=0;depth--){let found=dir<0?findSelectionIn$3($pos.node(0),$pos.node(depth),$pos.before(depth+1),$pos.index(depth),dir,textOnly):findSelectionIn$3($pos.node(0),$pos.node(depth),$pos.after(depth+1),$pos.index(depth)+1,dir,textOnly);if(found)return found}return null}
/**
    Find a valid cursor or leaf node selection near the given
    position. Searches forward first by default, but if `bias` is
    negative, it will search backwards first.
    */static near($pos,bias=1){return this.findFrom($pos,bias)||this.findFrom($pos,-bias)||new AllSelection$3($pos.node(0))}
/**
    Find the cursor or leaf node selection closest to the start of
    the given document. Will return an
    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
    exists.
    */static atStart(doc){return findSelectionIn$3(doc,doc,0,0,1)||new AllSelection$3(doc)}
/**
    Find the cursor or leaf node selection closest to the end of the
    given document.
    */static atEnd(doc){return findSelectionIn$3(doc,doc,doc.content.size,doc.childCount,-1)||new AllSelection$3(doc)}
/**
    Deserialize the JSON representation of a selection. Must be
    implemented for custom classes (as a static class method).
    */static fromJSON(doc,json){if(!json||!json.type)throw new RangeError("Invalid input for Selection.fromJSON");let cls=classesById$3[json.type];if(!cls)throw new RangeError(`No selection type ${json.type} defined`);return cls.fromJSON(doc,json)}
/**
    To be able to deserialize selections from JSON, custom selection
    classes must register themselves with an ID string, so that they
    can be disambiguated. Try to pick something that's unlikely to
    clash with classes from other modules.
    */static jsonID(id,selectionClass){if(id in classesById$3)throw new RangeError("Duplicate use of selection JSON ID "+id);return classesById$3[id]=selectionClass,selectionClass.prototype.jsonID=id,selectionClass}
/**
    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
    which is a value that can be mapped without having access to a
    current document, and later resolved to a real selection for a
    given document again. (This is used mostly by the history to
    track and restore old selections.) The default implementation of
    this method just converts the selection to a text selection and
    returns the bookmark for that.
    */getBookmark(){return TextSelection$3.between(this.$anchor,this.$head).getBookmark()}}Selection$3.prototype.visible=!0;
/**
Represents a selected range in a document.
*/
class SelectionRange$3{
/**
    Create a range.
    */
constructor(
/**
    The lower bound of the range.
    */
$from,
/**
    The upper bound of the range.
    */
$to){this.$from=$from,this.$to=$to}}let warnedAboutTextSelection$3=!1;function checkTextSelection$3($pos){warnedAboutTextSelection$3||$pos.parent.inlineContent||(warnedAboutTextSelection$3=!0)}
/**
A text selection represents a classical editor selection, with a
head (the moving side) and anchor (immobile side), both of which
point into textblock nodes. It can be empty (a regular cursor
position).
*/class TextSelection$3 extends Selection$3{
/**
    Construct a text selection between the given points.
    */
constructor($anchor,$head=$anchor){checkTextSelection$3($anchor),checkTextSelection$3($head),super($anchor,$head)}
/**
    Returns a resolved position if this is a cursor selection (an
    empty text selection), and null otherwise.
    */get $cursor(){return this.$anchor.pos==this.$head.pos?this.$head:null}map(doc,mapping){let $head=doc.resolve(mapping.map(this.head));if(!$head.parent.inlineContent)return Selection$3.near($head);let $anchor=doc.resolve(mapping.map(this.anchor));return new TextSelection$3($anchor.parent.inlineContent?$anchor:$head,$head)}replace(tr,content=Slice$3.empty){if(super.replace(tr,content),content==Slice$3.empty){let marks=this.$from.marksAcross(this.$to);marks&&tr.ensureMarks(marks)}}eq(other){return other instanceof TextSelection$3&&other.anchor==this.anchor&&other.head==this.head}getBookmark(){return new TextBookmark$3(this.anchor,this.head)}toJSON(){return{type:"text",anchor:this.anchor,head:this.head}}
/**
    @internal
    */static fromJSON(doc,json){if("number"!=typeof json.anchor||"number"!=typeof json.head)throw new RangeError("Invalid input for TextSelection.fromJSON");return new TextSelection$3(doc.resolve(json.anchor),doc.resolve(json.head))}
/**
    Create a text selection from non-resolved positions.
    */static create(doc,anchor,head=anchor){let $anchor=doc.resolve(anchor);return new this($anchor,head==anchor?$anchor:doc.resolve(head))}
/**
    Return a text selection that spans the given positions or, if
    they aren't text positions, find a text selection near them.
    `bias` determines whether the method searches forward (default)
    or backwards (negative number) first. Will fall back to calling
    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
    doesn't contain a valid text position.
    */static between($anchor,$head,bias){let dPos=$anchor.pos-$head.pos;if(bias&&!dPos||(bias=dPos>=0?1:-1),!$head.parent.inlineContent){let found=Selection$3.findFrom($head,bias,!0)||Selection$3.findFrom($head,-bias,!0);if(!found)return Selection$3.near($head,bias);$head=found.$head}return $anchor.parent.inlineContent||(0==dPos?$anchor=$head:($anchor=(Selection$3.findFrom($anchor,-bias,!0)||Selection$3.findFrom($anchor,bias,!0)).$anchor,$anchor.pos<$head.pos!=dPos<0&&($anchor=$head))),new TextSelection$3($anchor,$head)}}Selection$3.jsonID("text",TextSelection$3);class TextBookmark$3{constructor(anchor,head){this.anchor=anchor,this.head=head}map(mapping){return new TextBookmark$3(mapping.map(this.anchor),mapping.map(this.head))}resolve(doc){return TextSelection$3.between(doc.resolve(this.anchor),doc.resolve(this.head))}}
/**
A node selection is a selection that points at a single node. All
nodes marked [selectable](https://prosemirror.net/docs/ref/#model.NodeSpec.selectable) can be the
target of a node selection. In such a selection, `from` and `to`
point directly before and after the selected node, `anchor` equals
`from`, and `head` equals `to`..
*/class NodeSelection$3 extends Selection$3{
/**
    Create a node selection. Does not verify the validity of its
    argument.
    */
constructor($pos){let node=$pos.nodeAfter,$end=$pos.node(0).resolve($pos.pos+node.nodeSize);super($pos,$end),this.node=node}map(doc,mapping){let{deleted:deleted,pos:pos}=mapping.mapResult(this.anchor),$pos=doc.resolve(pos);return deleted?Selection$3.near($pos):new NodeSelection$3($pos)}content(){return new Slice$3(Fragment$3.from(this.node),0,0)}eq(other){return other instanceof NodeSelection$3&&other.anchor==this.anchor}toJSON(){return{type:"node",anchor:this.anchor}}getBookmark(){return new NodeBookmark$3(this.anchor)}
/**
    @internal
    */static fromJSON(doc,json){if("number"!=typeof json.anchor)throw new RangeError("Invalid input for NodeSelection.fromJSON");return new NodeSelection$3(doc.resolve(json.anchor))}
/**
    Create a node selection from non-resolved positions.
    */static create(doc,from){return new NodeSelection$3(doc.resolve(from))}
/**
    Determines whether the given node may be selected as a node
    selection.
    */static isSelectable(node){return!node.isText&&!1!==node.type.spec.selectable}}NodeSelection$3.prototype.visible=!1,Selection$3.jsonID("node",NodeSelection$3);class NodeBookmark$3{constructor(anchor){this.anchor=anchor}map(mapping){let{deleted:deleted,pos:pos}=mapping.mapResult(this.anchor);return deleted?new TextBookmark$3(pos,pos):new NodeBookmark$3(pos)}resolve(doc){let $pos=doc.resolve(this.anchor),node=$pos.nodeAfter;return node&&NodeSelection$3.isSelectable(node)?new NodeSelection$3($pos):Selection$3.near($pos)}}
/**
A selection type that represents selecting the whole document
(which can not necessarily be expressed with a text selection, when
there are for example leaf block nodes at the start or end of the
document).
*/class AllSelection$3 extends Selection$3{
/**
    Create an all-selection over the given document.
    */
constructor(doc){super(doc.resolve(0),doc.resolve(doc.content.size))}replace(tr,content=Slice$3.empty){if(content==Slice$3.empty){tr.delete(0,tr.doc.content.size);let sel=Selection$3.atStart(tr.doc);sel.eq(tr.selection)||tr.setSelection(sel)}else super.replace(tr,content)}toJSON(){return{type:"all"}}
/**
    @internal
    */static fromJSON(doc){return new AllSelection$3(doc)}map(doc){return new AllSelection$3(doc)}eq(other){return other instanceof AllSelection$3}getBookmark(){return AllBookmark$3}}Selection$3.jsonID("all",AllSelection$3);const AllBookmark$3={map(){return this},resolve(doc){return new AllSelection$3(doc)}};
// FIXME we'll need some awareness of text direction when scanning for selections
// Try to find a selection inside the given node. `pos` points at the
// position where the search starts. When `text` is true, only return
// text selections.
function findSelectionIn$3(doc,node,pos,index,dir,text=!1){if(node.inlineContent)return TextSelection$3.create(doc,pos);for(let i=index-(dir>0?0:1);dir>0?i<node.childCount:i>=0;i+=dir){let child=node.child(i);if(child.isAtom){if(!text&&NodeSelection$3.isSelectable(child))return NodeSelection$3.create(doc,pos-(dir<0?child.nodeSize:0))}else{let inner=findSelectionIn$3(doc,child,pos+dir,dir<0?child.childCount:0,dir,text);if(inner)return inner}pos+=child.nodeSize*dir}return null}function selectionToInsertionEnd$1$3(tr,startLen,bias){let last=tr.steps.length-1;if(last<startLen)return;let step=tr.steps[last];if(!(step instanceof ReplaceStep$3||step instanceof ReplaceAroundStep$3))return;let end,map=tr.mapping.maps[last];map.forEach(((_from,_to,_newFrom,newTo)=>{null==end&&(end=newTo)})),tr.setSelection(Selection$3.near(tr.doc.resolve(end),bias))}function bind$1$3(f,self){return self&&f?f.bind(self):f}class FieldDesc$3{constructor(name,desc,self){this.name=name,this.init=bind$1$3(desc.init,self),this.apply=bind$1$3(desc.apply,self)}}function bindProps$3(obj,self,target){for(let prop in obj){let val=obj[prop];val instanceof Function?val=val.bind(self):"handleDOMEvents"==prop&&(val=bindProps$3(val,self,{})),target[prop]=val}return target}
/**
Plugins bundle functionality that can be added to an editor.
They are part of the [editor state](https://prosemirror.net/docs/ref/#state.EditorState) and
may influence that state and the view that contains it.
*/new FieldDesc$3("doc",{init(config){return config.doc||config.schema.topNodeType.createAndFill()},apply(tr){return tr.doc}}),new FieldDesc$3("selection",{init(config,instance){return config.selection||Selection$3.atStart(instance.doc)},apply(tr){return tr.selection}}),new FieldDesc$3("storedMarks",{init(config){return config.storedMarks||null},apply(tr,_marks,_old,state){return state.selection.$cursor?tr.storedMarks:null}}),new FieldDesc$3("scrollToSelection",{init(){return 0},apply(tr,prev){return tr.scrolledIntoView?prev+1:prev}});class Plugin$3{
/**
    Create a plugin.
    */
constructor(
/**
    The plugin's [spec object](https://prosemirror.net/docs/ref/#state.PluginSpec).
    */
spec){this.spec=spec,
/**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
this.props={},spec.props&&bindProps$3(spec.props,this,this.props),this.key=spec.key?spec.key.key:createKey$3("plugin")}
/**
    Extract the plugin's state field from an editor state.
    */getState(state){return state[this.key]}}const keys$1$3=Object.create(null);function createKey$3(name){return name in keys$1$3?name+"$"+ ++keys$1$3[name]:(keys$1$3[name]=0,name+"$")}
/**
A key is used to [tag](https://prosemirror.net/docs/ref/#state.PluginSpec.key) plugins in a way
that makes it possible to find them, given an editor state.
Assigning a key does mean only one plugin of that type can be
active in a state.
*/class PluginKey$3{
/**
    Create a plugin key.
    */
constructor(name="key"){this.key=createKey$3(name)}
/**
    Get the active plugin with this key, if any, from an editor
    state.
    */get(state){return state.config.pluginsByKey[this.key]}
/**
    Get the plugin's state from an editor state.
    */getState(state){return state[this.key]}}const nav$3="undefined"!=typeof navigator?navigator:null,doc$7="undefined"!=typeof document?document:null,agent$3=nav$3&&nav$3.userAgent||"",ie_edge$3=/Edge\/(\d+)/.exec(agent$3),ie_upto10$3=/MSIE \d/.exec(agent$3),ie_11up$3=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent$3),ie$1$3=!!(ie_upto10$3||ie_11up$3||ie_edge$3),ie_version$3=ie_upto10$3?document.documentMode:ie_11up$3?+ie_11up$3[1]:ie_edge$3?+ie_edge$3[1]:0,gecko$3=!ie$1$3&&/gecko\/(\d+)/i.test(agent$3);gecko$3&&(/Firefox\/(\d+)/.exec(agent$3)||[0,0])[1];const _chrome$3=!ie$1$3&&/Chrome\/(\d+)/.exec(agent$3),chrome$1$3=!!_chrome$3,chrome_version$3=_chrome$3?+_chrome$3[1]:0,safari$3=!ie$1$3&&!!nav$3&&/Apple Computer/.test(nav$3.vendor),ios$3=safari$3&&(/Mobile\/\w+/.test(agent$3)||!!nav$3&&nav$3.maxTouchPoints>2),mac$2$3=ios$3||!!nav$3&&/Mac/.test(nav$3.platform),android$3=/Android \d/.test(agent$3),webkit$3=!!doc$7&&"webkitFontSmoothing"in doc$7.documentElement.style,webkit_version$3=webkit$3?+(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent)||[0,0])[1]:0,domIndex$3=function(node){for(var index=0;;index++)if(node=node.previousSibling,!node)return index},isEquivalentPosition$3=function(node,off,targetNode,targetOff){return targetNode&&(scanFor$3(node,off,targetNode,targetOff,-1)||scanFor$3(node,off,targetNode,targetOff,1))},atomElements$3=/^(img|br|input|textarea|hr)$/i;function scanFor$3(node,off,targetNode,targetOff,dir){for(;;){if(node==targetNode&&off==targetOff)return!0;if(off==(dir<0?0:nodeSize$3(node))){let parent=node.parentNode;if(!parent||1!=parent.nodeType||hasBlockDesc$3(node)||atomElements$3.test(node.nodeName)||"false"==node.contentEditable)return!1;off=domIndex$3(node)+(dir<0?0:1),node=parent}else{if(1!=node.nodeType)return!1;if(node=node.childNodes[off+(dir<0?-1:0)],"false"==node.contentEditable)return!1;off=dir<0?nodeSize$3(node):0}}}function nodeSize$3(node){return 3==node.nodeType?node.nodeValue.length:node.childNodes.length}function isOnEdge$3(node,offset,parent){for(let atStart=0==offset,atEnd=offset==nodeSize$3(node);atStart||atEnd;){if(node==parent)return!0;let index=domIndex$3(node);if(node=node.parentNode,!node)return!1;atStart=atStart&&0==index,atEnd=atEnd&&index==nodeSize$3(node)}}function hasBlockDesc$3(dom){let desc;for(let cur=dom;cur;cur=cur.parentNode)if(desc=cur.pmViewDesc)break;return desc&&desc.node&&desc.node.isBlock&&(desc.dom==dom||desc.contentDOM==dom)}
// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523
// (isCollapsed inappropriately returns true in shadow dom)
const selectionCollapsed$3=function(domSel){let collapsed=domSel.isCollapsed;return collapsed&&chrome$1$3&&domSel.rangeCount&&!domSel.getRangeAt(0).collapsed&&(collapsed=!1),collapsed};function keyEvent$3(keyCode,key){let event=document.createEvent("Event");return event.initEvent("keydown",!0,!0),event.keyCode=keyCode,event.key=event.code=key,event}function selectionFromDOM$3(view,origin=null){let domSel=view.domSelection(),doc=view.state.doc;if(!domSel.focusNode)return null;let nearestDesc=view.docView.nearestDesc(domSel.focusNode),inWidget=nearestDesc&&0==nearestDesc.size,head=view.docView.posFromDOM(domSel.focusNode,domSel.focusOffset,1);if(head<0)return null;let $anchor,selection,$head=doc.resolve(head);if(selectionCollapsed$3(domSel)){$anchor=$head;while(nearestDesc&&!nearestDesc.node)nearestDesc=nearestDesc.parent;let nearestDescNode=nearestDesc.node;if(nearestDesc&&nearestDescNode.isAtom&&NodeSelection$3.isSelectable(nearestDescNode)&&nearestDesc.parent&&(!nearestDescNode.isInline||!isOnEdge$3(domSel.focusNode,domSel.focusOffset,nearestDesc.dom))){let pos=nearestDesc.posBefore;selection=new NodeSelection$3(head==pos?$head:doc.resolve(pos))}}else{let anchor=view.docView.posFromDOM(domSel.anchorNode,domSel.anchorOffset,1);if(anchor<0)return null;$anchor=doc.resolve(anchor)}if(!selection){let bias="pointer"==origin||view.state.selection.head<$head.pos&&!inWidget?1:-1;selection=selectionBetween$3(view,$anchor,$head,bias)}return selection}function editorOwnsSelection$3(view){return view.editable?view.hasFocus():hasSelection$3(view)&&document.activeElement&&document.activeElement.contains(view.dom)}function selectionToDOM$3(view,force=!1){let sel=view.state.selection;if(syncNodeSelection$3(view,sel),editorOwnsSelection$3(view)){
// The delayed drag selection causes issues with Cell Selections
// in Safari. And the drag selection delay is to workarond issues
// which only present in Chrome.
if(!force&&view.input.mouseDown&&view.input.mouseDown.allowDefault&&chrome$1$3){let domSel=view.domSelection(),curSel=view.domObserver.currentSelection;if(domSel.anchorNode&&curSel.anchorNode&&isEquivalentPosition$3(domSel.anchorNode,domSel.anchorOffset,curSel.anchorNode,curSel.anchorOffset))return view.input.mouseDown.delayedSelectionSync=!0,void view.domObserver.setCurSelection()}if(view.domObserver.disconnectSelection(),view.cursorWrapper)selectCursorWrapper$3(view);else{let resetEditableFrom,resetEditableTo,{anchor:anchor,head:head}=sel;!brokenSelectBetweenUneditable$3||sel instanceof TextSelection$3||(sel.$from.parent.inlineContent||(resetEditableFrom=temporarilyEditableNear$3(view,sel.from)),sel.empty||sel.$from.parent.inlineContent||(resetEditableTo=temporarilyEditableNear$3(view,sel.to))),view.docView.setSelection(anchor,head,view.root,force),brokenSelectBetweenUneditable$3&&(resetEditableFrom&&resetEditable$3(resetEditableFrom),resetEditableTo&&resetEditable$3(resetEditableTo)),sel.visible?view.dom.classList.remove("ProseMirror-hideselection"):(view.dom.classList.add("ProseMirror-hideselection"),"onselectionchange"in document&&removeClassOnSelectionChange$3(view))}view.domObserver.setCurSelection(),view.domObserver.connectSelection()}}
// Kludge to work around Webkit not allowing a selection to start/end
// between non-editable block nodes. We briefly make something
// editable, set the selection, then set it uneditable again.
const brokenSelectBetweenUneditable$3=safari$3||chrome$1$3&&chrome_version$3<63;function temporarilyEditableNear$3(view,pos){let{node:node,offset:offset}=view.docView.domFromPos(pos,0),after=offset<node.childNodes.length?node.childNodes[offset]:null,before=offset?node.childNodes[offset-1]:null;if(safari$3&&after&&"false"==after.contentEditable)return setEditable$3(after);if((!after||"false"==after.contentEditable)&&(!before||"false"==before.contentEditable)){if(after)return setEditable$3(after);if(before)return setEditable$3(before)}}function setEditable$3(element){return element.contentEditable="true",safari$3&&element.draggable&&(element.draggable=!1,element.wasDraggable=!0),element}function resetEditable$3(element){element.contentEditable="false",element.wasDraggable&&(element.draggable=!0,element.wasDraggable=null)}function removeClassOnSelectionChange$3(view){let doc=view.dom.ownerDocument;doc.removeEventListener("selectionchange",view.input.hideSelectionGuard);let domSel=view.domSelection(),node=domSel.anchorNode,offset=domSel.anchorOffset;doc.addEventListener("selectionchange",view.input.hideSelectionGuard=()=>{domSel.anchorNode==node&&domSel.anchorOffset==offset||(doc.removeEventListener("selectionchange",view.input.hideSelectionGuard),setTimeout((()=>{editorOwnsSelection$3(view)&&!view.state.selection.visible||view.dom.classList.remove("ProseMirror-hideselection")}),20))})}function selectCursorWrapper$3(view){let domSel=view.domSelection(),range=document.createRange(),node=view.cursorWrapper.dom,img="IMG"==node.nodeName;img?range.setEnd(node.parentNode,domIndex$3(node)+1):range.setEnd(node,0),range.collapse(!1),domSel.removeAllRanges(),domSel.addRange(range),
// Kludge to kill 'control selection' in IE11 when selecting an
// invisible cursor wrapper, since that would result in those weird
// resize handles and a selection that considers the absolutely
// positioned wrapper, rather than the root editable node, the
// focused element.
!img&&!view.state.selection.visible&&ie$1$3&&ie_version$3<=11&&(node.disabled=!0,node.disabled=!1)}function syncNodeSelection$3(view,sel){if(sel instanceof NodeSelection$3){let desc=view.docView.descAt(sel.from);desc!=view.lastSelectedViewDesc&&(clearNodeSelection$3(view),desc&&desc.selectNode(),view.lastSelectedViewDesc=desc)}else clearNodeSelection$3(view)}
// Clear all DOM statefulness of the last node selection.
function clearNodeSelection$3(view){view.lastSelectedViewDesc&&(view.lastSelectedViewDesc.parent&&view.lastSelectedViewDesc.deselectNode(),view.lastSelectedViewDesc=void 0)}function selectionBetween$3(view,$anchor,$head,bias){return view.someProp("createSelectionBetween",(f=>f(view,$anchor,$head)))||TextSelection$3.between($anchor,$head,bias)}function hasSelection$3(view){let sel=view.domSelection();if(!sel.anchorNode)return!1;try{
// Firefox will raise 'permission denied' errors when accessing
// properties of `sel.anchorNode` when it's in a generated CSS
// element.
return view.dom.contains(3==sel.anchorNode.nodeType?sel.anchorNode.parentNode:sel.anchorNode)&&(view.editable||view.dom.contains(3==sel.focusNode.nodeType?sel.focusNode.parentNode:sel.focusNode))}catch(_){return!1}}function moveSelectionBlock$3(state,dir){let{$anchor:$anchor,$head:$head}=state.selection,$side=dir>0?$anchor.max($head):$anchor.min($head),$start=$side.parent.inlineContent?$side.depth?state.doc.resolve(dir>0?$side.after():$side.before()):null:$side;return $start&&Selection$3.findFrom($start,dir)}function apply$4(view,sel){return view.dispatch(view.state.tr.setSelection(sel).scrollIntoView()),!0}function selectHorizontally$3(view,dir,mods){let sel=view.state.selection;if(!(sel instanceof TextSelection$3)){if(sel instanceof NodeSelection$3&&sel.node.isInline)return apply$4(view,new TextSelection$3(dir>0?sel.$to:sel.$from));{let next=moveSelectionBlock$3(view.state,dir);return!!next&&apply$4(view,next)}}if(!sel.empty||mods.indexOf("s")>-1)return!1;if(view.endOfTextblock(dir>0?"right":"left")){let next=moveSelectionBlock$3(view.state,dir);return!!(next&&next instanceof NodeSelection$3)&&apply$4(view,next)}if(!(mac$2$3&&mods.indexOf("m")>-1)){let desc,$head=sel.$head,node=$head.textOffset?null:dir<0?$head.nodeBefore:$head.nodeAfter;if(!node||node.isText)return!1;let nodePos=dir<0?$head.pos-node.nodeSize:$head.pos;return!!(node.isAtom||(desc=view.docView.descAt(nodePos))&&!desc.contentDOM)&&(NodeSelection$3.isSelectable(node)?apply$4(view,new NodeSelection$3(dir<0?view.state.doc.resolve($head.pos-node.nodeSize):$head)):!!webkit$3&&apply$4(view,new TextSelection$3(view.state.doc.resolve(dir<0?nodePos:nodePos+node.nodeSize))))}}function nodeLen$3(node){return 3==node.nodeType?node.nodeValue.length:node.childNodes.length}function isIgnorable$3(dom){let desc=dom.pmViewDesc;return desc&&0==desc.size&&(dom.nextSibling||"BR"!=dom.nodeName)}
// Make sure the cursor isn't directly after one or more ignored
// nodes, which will confuse the browser's cursor motion logic.
function skipIgnoredNodesLeft$3(view){let sel=view.domSelection(),node=sel.focusNode,offset=sel.focusOffset;if(!node)return;let moveNode,moveOffset,force=!1;
// Gecko will do odd things when the selection is directly in front
// of a non-editable node, so in that case, move it into the next
// node if possible. Issue prosemirror/prosemirror#832.
for(gecko$3&&1==node.nodeType&&offset<nodeLen$3(node)&&isIgnorable$3(node.childNodes[offset])&&(force=!0);;)if(offset>0){if(1!=node.nodeType)break;{let before=node.childNodes[offset-1];if(isIgnorable$3(before))moveNode=node,moveOffset=--offset;else{if(3!=before.nodeType)break;node=before,offset=node.nodeValue.length}}}else{if(isBlockNode$3(node))break;{let prev=node.previousSibling;while(prev&&isIgnorable$3(prev))moveNode=node.parentNode,moveOffset=domIndex$3(prev),prev=prev.previousSibling;if(prev)node=prev,offset=nodeLen$3(node);else{if(node=node.parentNode,node==view.dom)break;offset=0}}}force?setSelFocus$3(view,sel,node,offset):moveNode&&setSelFocus$3(view,sel,moveNode,moveOffset)}
// Make sure the cursor isn't directly before one or more ignored
// nodes.
function skipIgnoredNodesRight$3(view){let sel=view.domSelection(),node=sel.focusNode,offset=sel.focusOffset;if(!node)return;let moveNode,moveOffset,len=nodeLen$3(node);for(;;)if(offset<len){if(1!=node.nodeType)break;let after=node.childNodes[offset];if(!isIgnorable$3(after))break;moveNode=node,moveOffset=++offset}else{if(isBlockNode$3(node))break;{let next=node.nextSibling;while(next&&isIgnorable$3(next))moveNode=next.parentNode,moveOffset=domIndex$3(next)+1,next=next.nextSibling;if(next)node=next,offset=0,len=nodeLen$3(node);else{if(node=node.parentNode,node==view.dom)break;offset=len=0}}}moveNode&&setSelFocus$3(view,sel,moveNode,moveOffset)}function isBlockNode$3(dom){let desc=dom.pmViewDesc;return desc&&desc.node&&desc.node.isBlock}function setSelFocus$3(view,sel,node,offset){if(selectionCollapsed$3(sel)){let range=document.createRange();range.setEnd(node,offset),range.setStart(node,offset),sel.removeAllRanges(),sel.addRange(range)}else sel.extend&&sel.extend(node,offset);view.domObserver.setCurSelection();let{state:state}=view;
// If no state update ends up happening, reset the selection.
setTimeout((()=>{view.state==state&&selectionToDOM$3(view)}),50)}
// Check whether vertical selection motion would involve node
// selections. If so, apply it (if not, the result is left to the
// browser)
function selectVertically$3(view,dir,mods){let sel=view.state.selection;if(sel instanceof TextSelection$3&&!sel.empty||mods.indexOf("s")>-1)return!1;if(mac$2$3&&mods.indexOf("m")>-1)return!1;let{$from:$from,$to:$to}=sel;if(!$from.parent.inlineContent||view.endOfTextblock(dir<0?"up":"down")){let next=moveSelectionBlock$3(view.state,dir);if(next&&next instanceof NodeSelection$3)return apply$4(view,next)}if(!$from.parent.inlineContent){let side=dir<0?$from:$to,beyond=sel instanceof AllSelection$3?Selection$3.near(side,dir):Selection$3.findFrom(side,dir);return!!beyond&&apply$4(view,beyond)}return!1}function stopNativeHorizontalDelete$3(view,dir){if(!(view.state.selection instanceof TextSelection$3))return!0;let{$head:$head,$anchor:$anchor,empty:empty}=view.state.selection;if(!$head.sameParent($anchor))return!0;if(!empty)return!1;if(view.endOfTextblock(dir>0?"forward":"backward"))return!0;let nextNode=!$head.textOffset&&(dir<0?$head.nodeBefore:$head.nodeAfter);if(nextNode&&!nextNode.isText){let tr=view.state.tr;return dir<0?tr.delete($head.pos-nextNode.nodeSize,$head.pos):tr.delete($head.pos,$head.pos+nextNode.nodeSize),view.dispatch(tr),!0}return!1}function switchEditable$3(view,node,state){view.domObserver.stop(),node.contentEditable=state,view.domObserver.start()}
// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821
// In which Safari (and at some point in the past, Chrome) does really
// wrong things when the down arrow is pressed when the cursor is
// directly at the start of a textblock and has an uneditable node
// after it
function safariDownArrowBug$3(view){if(!safari$3||view.state.selection.$head.parentOffset>0)return!1;let{focusNode:focusNode,focusOffset:focusOffset}=view.domSelection();if(focusNode&&1==focusNode.nodeType&&0==focusOffset&&focusNode.firstChild&&"false"==focusNode.firstChild.contentEditable){let child=focusNode.firstChild;switchEditable$3(view,child,"true"),setTimeout((()=>switchEditable$3(view,child,"false")),20)}return!1}
// A backdrop key mapping used to make sure we always suppress keys
// that have a dangerous default effect, even if the commands they are
// bound to return false, and to make sure that cursor-motion keys
// find a cursor (as opposed to a node selection) when pressed. For
// cursor-motion keys, the code in the handlers also takes care of
// block selections.
function getMods$3(event){let result="";return event.ctrlKey&&(result+="c"),event.metaKey&&(result+="m"),event.altKey&&(result+="a"),event.shiftKey&&(result+="s"),result}function captureKeyDown$3(view,event){let code=event.keyCode,mods=getMods$3(event);return 8==code||mac$2$3&&72==code&&"c"==mods?stopNativeHorizontalDelete$3(view,-1)||skipIgnoredNodesLeft$3(view):46==code||mac$2$3&&68==code&&"c"==mods?stopNativeHorizontalDelete$3(view,1)||skipIgnoredNodesRight$3(view):13==code||27==code||(37==code||mac$2$3&&66==code&&"c"==mods?selectHorizontally$3(view,-1,mods)||skipIgnoredNodesLeft$3(view):39==code||mac$2$3&&70==code&&"c"==mods?selectHorizontally$3(view,1,mods)||skipIgnoredNodesRight$3(view):38==code||mac$2$3&&80==code&&"c"==mods?selectVertically$3(view,-1,mods)||skipIgnoredNodesLeft$3(view):40==code||mac$2$3&&78==code&&"c"==mods?safariDownArrowBug$3(view)||selectVertically$3(view,1,mods)||skipIgnoredNodesRight$3(view):mods==(mac$2$3?"m":"c")&&(66==code||73==code||89==code||90==code))}function serializeForClipboard$3(view,slice){let context=[],{content:content,openStart:openStart,openEnd:openEnd}=slice;while(openStart>1&&openEnd>1&&1==content.childCount&&1==content.firstChild.childCount){openStart--,openEnd--;let node=content.firstChild;context.push(node.type.name,node.attrs!=node.type.defaultAttrs?node.attrs:null),content=node.content}let serializer=view.someProp("clipboardSerializer")||DOMSerializer$3.fromSchema(view.state.schema),doc=detachedDoc$3(),wrap=doc.createElement("div");wrap.appendChild(serializer.serializeFragment(content,{document:doc}));let needsWrap,firstChild=wrap.firstChild,wrappers=0;while(firstChild&&1==firstChild.nodeType&&(needsWrap=wrapMap$3[firstChild.nodeName.toLowerCase()])){for(let i=needsWrap.length-1;i>=0;i--){let wrapper=doc.createElement(needsWrap[i]);while(wrap.firstChild)wrapper.appendChild(wrap.firstChild);wrap.appendChild(wrapper),wrappers++}firstChild=wrap.firstChild}firstChild&&1==firstChild.nodeType&&firstChild.setAttribute("data-pm-slice",`${openStart} ${openEnd}${wrappers?` -${wrappers}`:""} ${JSON.stringify(context)}`);let text=view.someProp("clipboardTextSerializer",(f=>f(slice)))||slice.content.textBetween(0,slice.content.size,"\n\n");return{dom:wrap,text:text}}
// Read a slice of content from the clipboard (or drop data).
function parseFromClipboard$3(view,text,html,plainText,$context){let dom,slice,inCode=$context.parent.type.spec.code;if(!html&&!text)return null;let asText=text&&(plainText||inCode||!html);if(asText){if(view.someProp("transformPastedText",(f=>{text=f(text,inCode||plainText)})),inCode)return text?new Slice$3(Fragment$3.from(view.state.schema.text(text.replace(/\r\n?/g,"\n"))),0,0):Slice$3.empty;let parsed=view.someProp("clipboardTextParser",(f=>f(text,$context,plainText)));if(parsed)slice=parsed;else{let marks=$context.marks(),{schema:schema}=view.state,serializer=DOMSerializer$3.fromSchema(schema);dom=document.createElement("div"),text.split(/(?:\r\n?|\n)+/).forEach((block=>{let p=dom.appendChild(document.createElement("p"));block&&p.appendChild(serializer.serializeNode(schema.text(block,marks)))}))}}else view.someProp("transformPastedHTML",(f=>{html=f(html)})),dom=readHTML$3(html),webkit$3&&restoreReplacedSpaces$3(dom);let contextNode=dom&&dom.querySelector("[data-pm-slice]"),sliceData=contextNode&&/^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice")||"");if(sliceData&&sliceData[3])for(let i=+sliceData[3];i>0&&dom.firstChild;i--)dom=dom.firstChild;if(!slice){let parser=view.someProp("clipboardParser")||view.someProp("domParser")||DOMParser$1$3.fromSchema(view.state.schema);slice=parser.parseSlice(dom,{preserveWhitespace:!(!asText&&!sliceData),context:$context,ruleFromNode(dom){return"BR"!=dom.nodeName||dom.nextSibling||!dom.parentNode||inlineParents$3.test(dom.parentNode.nodeName)?null:{ignore:!0}}})}if(sliceData)slice=addContext$3(closeSlice$3(slice,+sliceData[1],+sliceData[2]),sliceData[4]);else if(// HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent
slice=Slice$3.maxOpen(normalizeSiblings$3(slice.content,$context),!0),slice.openStart||slice.openEnd){let openStart=0,openEnd=0;for(let node=slice.content.firstChild;openStart<slice.openStart&&!node.type.spec.isolating;openStart++,node=node.firstChild);for(let node=slice.content.lastChild;openEnd<slice.openEnd&&!node.type.spec.isolating;openEnd++,node=node.lastChild);slice=closeSlice$3(slice,openStart,openEnd)}return view.someProp("transformPasted",(f=>{slice=f(slice)})),slice}const inlineParents$3=/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
// Takes a slice parsed with parseSlice, which means there hasn't been
// any content-expression checking done on the top nodes, tries to
// find a parent node in the current context that might fit the nodes,
// and if successful, rebuilds the slice so that it fits into that parent.

// This addresses the problem that Transform.replace expects a
// coherent slice, and will fail to place a set of siblings that don't
// fit anywhere in the schema.
function normalizeSiblings$3(fragment,$context){if(fragment.childCount<2)return fragment;for(let d=$context.depth;d>=0;d--){let lastWrap,parent=$context.node(d),match=parent.contentMatchAt($context.index(d)),result=[];if(fragment.forEach((node=>{if(!result)return;let inLast,wrap=match.findWrapping(node.type);if(!wrap)return result=null;if(inLast=result.length&&lastWrap.length&&addToSibling$3(wrap,lastWrap,node,result[result.length-1],0))result[result.length-1]=inLast;else{result.length&&(result[result.length-1]=closeRight$3(result[result.length-1],lastWrap.length));let wrapped=withWrappers$3(node,wrap);result.push(wrapped),match=match.matchType(wrapped.type),lastWrap=wrap}})),result)return Fragment$3.from(result)}return fragment}function withWrappers$3(node,wrap,from=0){for(let i=wrap.length-1;i>=from;i--)node=wrap[i].create(null,Fragment$3.from(node));return node}
// Used to group adjacent nodes wrapped in similar parents by
// normalizeSiblings into the same parent node
function addToSibling$3(wrap,lastWrap,node,sibling,depth){if(depth<wrap.length&&depth<lastWrap.length&&wrap[depth]==lastWrap[depth]){let inner=addToSibling$3(wrap,lastWrap,node,sibling.lastChild,depth+1);if(inner)return sibling.copy(sibling.content.replaceChild(sibling.childCount-1,inner));let match=sibling.contentMatchAt(sibling.childCount);if(match.matchType(depth==wrap.length-1?node.type:wrap[depth+1]))return sibling.copy(sibling.content.append(Fragment$3.from(withWrappers$3(node,wrap,depth+1))))}}function closeRight$3(node,depth){if(0==depth)return node;let fragment=node.content.replaceChild(node.childCount-1,closeRight$3(node.lastChild,depth-1)),fill=node.contentMatchAt(node.childCount).fillBefore(Fragment$3.empty,!0);return node.copy(fragment.append(fill))}function closeRange$3(fragment,side,from,to,depth,openEnd){let node=side<0?fragment.firstChild:fragment.lastChild,inner=node.content;return depth<to-1&&(inner=closeRange$3(inner,side,from,to,depth+1,openEnd)),depth>=from&&(inner=side<0?node.contentMatchAt(0).fillBefore(inner,fragment.childCount>1||openEnd<=depth).append(inner):inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment$3.empty,!0))),fragment.replaceChild(side<0?0:fragment.childCount-1,node.copy(inner))}function closeSlice$3(slice,openStart,openEnd){return openStart<slice.openStart&&(slice=new Slice$3(closeRange$3(slice.content,-1,openStart,slice.openStart,0,slice.openEnd),openStart,slice.openEnd)),openEnd<slice.openEnd&&(slice=new Slice$3(closeRange$3(slice.content,1,openEnd,slice.openEnd,0,0),slice.openStart,openEnd)),slice}
// Trick from jQuery -- some elements must be wrapped in other
// elements for innerHTML to work. I.e. if you do `div.innerHTML =
// "<td>..</td>"` the table cells are ignored.
const wrapMap$3={thead:["table"],tbody:["table"],tfoot:["table"],caption:["table"],colgroup:["table"],col:["table","colgroup"],tr:["table","tbody"],td:["table","tbody","tr"],th:["table","tbody","tr"]};let _detachedDoc$3=null;function detachedDoc$3(){return _detachedDoc$3||(_detachedDoc$3=document.implementation.createHTMLDocument("title"))}function readHTML$3(html){let metas=/^(\s*<meta [^>]*>)*/.exec(html);metas&&(html=html.slice(metas[0].length));let wrap,elt=detachedDoc$3().createElement("div"),firstTag=/<([a-z][^>\s]+)/i.exec(html);if((wrap=firstTag&&wrapMap$3[firstTag[1].toLowerCase()])&&(html=wrap.map((n=>"<"+n+">")).join("")+html+wrap.map((n=>"</"+n+">")).reverse().join("")),elt.innerHTML=html,wrap)for(let i=0;i<wrap.length;i++)elt=elt.querySelector(wrap[i])||elt;return elt}
// Webkit browsers do some hard-to-predict replacement of regular
// spaces with non-breaking spaces when putting content on the
// clipboard. This tries to convert such non-breaking spaces (which
// will be wrapped in a plain span on Chrome, a span with class
// Apple-converted-space on Safari) back to regular spaces.
function restoreReplacedSpaces$3(dom){let nodes=dom.querySelectorAll(chrome$1$3?"span:not([class]):not([style])":"span.Apple-converted-space");for(let i=0;i<nodes.length;i++){let node=nodes[i];1==node.childNodes.length&&" "==node.textContent&&node.parentNode&&node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "),node)}}function addContext$3(slice,context){if(!slice.size)return slice;let array,schema=slice.content.firstChild.type.schema;try{array=JSON.parse(context)}catch(e){return slice}let{content:content,openStart:openStart,openEnd:openEnd}=slice;for(let i=array.length-2;i>=0;i-=2){let type=schema.nodes[array[i]];if(!type||type.hasRequiredAttrs())break;content=Fragment$3.from(type.create(array[i+1],content)),openStart++,openEnd++}return new Slice$3(content,openStart,openEnd)}
// A collection of DOM events that occur within the editor, and callback functions
// to invoke when the event fires.
const handlers$3={};let editHandlers$3={};function setSelectionOrigin$3(view,origin){view.input.lastSelectionOrigin=origin,view.input.lastSelectionTime=Date.now()}function eventCoords$3(event){return{left:event.clientX,top:event.clientY}}function isNear$3(event,click){let dx=click.x-event.clientX,dy=click.y-event.clientY;return dx*dx+dy*dy<100}function runHandlerOnContext$3(view,propName,pos,inside,event){if(-1==inside)return!1;let $pos=view.state.doc.resolve(inside);for(let i=$pos.depth+1;i>0;i--)if(view.someProp(propName,(f=>i>$pos.depth?f(view,pos,$pos.nodeAfter,$pos.before(i),event,!0):f(view,pos,$pos.node(i),$pos.before(i),event,!1))))return!0;return!1}function updateSelection$3(view,selection,origin){view.focused||view.focus();let tr=view.state.tr.setSelection(selection);"pointer"==origin&&tr.setMeta("pointer",!0),view.dispatch(tr)}function selectClickedLeaf$3(view,inside){if(-1==inside)return!1;let $pos=view.state.doc.resolve(inside),node=$pos.nodeAfter;return!!(node&&node.isAtom&&NodeSelection$3.isSelectable(node))&&(updateSelection$3(view,new NodeSelection$3($pos),"pointer"),!0)}function selectClickedNode$3(view,inside){if(-1==inside)return!1;let selectedNode,selectAt,sel=view.state.selection;sel instanceof NodeSelection$3&&(selectedNode=sel.node);let $pos=view.state.doc.resolve(inside);for(let i=$pos.depth+1;i>0;i--){let node=i>$pos.depth?$pos.nodeAfter:$pos.node(i);if(NodeSelection$3.isSelectable(node)){selectAt=selectedNode&&sel.$from.depth>0&&i>=sel.$from.depth&&$pos.before(sel.$from.depth+1)==sel.$from.pos?$pos.before(sel.$from.depth):$pos.before(i);break}}return null!=selectAt&&(updateSelection$3(view,NodeSelection$3.create(view.state.doc,selectAt),"pointer"),!0)}function handleSingleClick$3(view,pos,inside,event,selectNode){return runHandlerOnContext$3(view,"handleClickOn",pos,inside,event)||view.someProp("handleClick",(f=>f(view,pos,event)))||(selectNode?selectClickedNode$3(view,inside):selectClickedLeaf$3(view,inside))}function handleDoubleClick$3(view,pos,inside,event){return runHandlerOnContext$3(view,"handleDoubleClickOn",pos,inside,event)||view.someProp("handleDoubleClick",(f=>f(view,pos,event)))}function handleTripleClick$1$3(view,pos,inside,event){return runHandlerOnContext$3(view,"handleTripleClickOn",pos,inside,event)||view.someProp("handleTripleClick",(f=>f(view,pos,event)))||defaultTripleClick$3(view,inside,event)}function defaultTripleClick$3(view,inside,event){if(0!=event.button)return!1;let doc=view.state.doc;if(-1==inside)return!!doc.inlineContent&&(updateSelection$3(view,TextSelection$3.create(doc,0,doc.content.size),"pointer"),!0);let $pos=doc.resolve(inside);for(let i=$pos.depth+1;i>0;i--){let node=i>$pos.depth?$pos.nodeAfter:$pos.node(i),nodePos=$pos.before(i);if(node.inlineContent)updateSelection$3(view,TextSelection$3.create(doc,nodePos+1,nodePos+1+node.content.size),"pointer");else{if(!NodeSelection$3.isSelectable(node))continue;updateSelection$3(view,NodeSelection$3.create(doc,nodePos),"pointer")}return!0}}function forceDOMFlush$3(view){return endComposition$3(view)}editHandlers$3.keydown=(view,_event)=>{let event=_event;if(view.input.shiftKey=16==event.keyCode||event.shiftKey,!inOrNearComposition$3(view,event)&&(view.input.lastKeyCode=event.keyCode,view.input.lastKeyCodeTime=Date.now(),!android$3||!chrome$1$3||13!=event.keyCode))
// On iOS, if we preventDefault enter key presses, the virtual
// keyboard gets confused. So the hack here is to set a flag that
// makes the DOM change code recognize that what just happens should
// be replaced by whatever the Enter key handlers do.
if(229!=event.keyCode&&view.domObserver.forceFlush(),!ios$3||13!=event.keyCode||event.ctrlKey||event.altKey||event.metaKey)view.someProp("handleKeyDown",(f=>f(view,event)))||captureKeyDown$3(view,event)?event.preventDefault():setSelectionOrigin$3(view,"key");else{let now=Date.now();view.input.lastIOSEnter=now,view.input.lastIOSEnterFallbackTimeout=setTimeout((()=>{view.input.lastIOSEnter==now&&(view.someProp("handleKeyDown",(f=>f(view,keyEvent$3(13,"Enter")))),view.input.lastIOSEnter=0)}),200)}},editHandlers$3.keyup=(view,event)=>{16==event.keyCode&&(view.input.shiftKey=!1)},editHandlers$3.keypress=(view,_event)=>{let event=_event;if(inOrNearComposition$3(view,event)||!event.charCode||event.ctrlKey&&!event.altKey||mac$2$3&&event.metaKey)return;if(view.someProp("handleKeyPress",(f=>f(view,event))))return void event.preventDefault();let sel=view.state.selection;if(!(sel instanceof TextSelection$3)||!sel.$from.sameParent(sel.$to)){let text=String.fromCharCode(event.charCode);view.someProp("handleTextInput",(f=>f(view,sel.$from.pos,sel.$to.pos,text)))||view.dispatch(view.state.tr.insertText(text).scrollIntoView()),event.preventDefault()}};const selectNodeModifier$3=mac$2$3?"metaKey":"ctrlKey";handlers$3.mousedown=(view,_event)=>{let event=_event;view.input.shiftKey=event.shiftKey;let flushed=forceDOMFlush$3(view),now=Date.now(),type="singleClick";now-view.input.lastClick.time<500&&isNear$3(event,view.input.lastClick)&&!event[selectNodeModifier$3]&&("singleClick"==view.input.lastClick.type?type="doubleClick":"doubleClick"==view.input.lastClick.type&&(type="tripleClick")),view.input.lastClick={time:now,x:event.clientX,y:event.clientY,type:type};let pos=view.posAtCoords(eventCoords$3(event));pos&&("singleClick"==type?(view.input.mouseDown&&view.input.mouseDown.done(),view.input.mouseDown=new MouseDown$3(view,pos,event,!!flushed)):("doubleClick"==type?handleDoubleClick$3:handleTripleClick$1$3)(view,pos.pos,pos.inside,event)?event.preventDefault():setSelectionOrigin$3(view,"pointer"))};class MouseDown$3{constructor(view,pos,event,flushed){let targetNode,targetPos;if(this.view=view,this.pos=pos,this.event=event,this.flushed=flushed,this.delayedSelectionSync=!1,this.mightDrag=null,this.startDoc=view.state.doc,this.selectNode=!!event[selectNodeModifier$3],this.allowDefault=event.shiftKey,pos.inside>-1)targetNode=view.state.doc.nodeAt(pos.inside),targetPos=pos.inside;else{let $pos=view.state.doc.resolve(pos.pos);targetNode=$pos.parent,targetPos=$pos.depth?$pos.before():0}const target=flushed?null:event.target,targetDesc=target?view.docView.nearestDesc(target,!0):null;this.target=targetDesc?targetDesc.dom:null;let{selection:selection}=view.state;(0==event.button&&targetNode.type.spec.draggable&&!1!==targetNode.type.spec.selectable||selection instanceof NodeSelection$3&&selection.from<=targetPos&&selection.to>targetPos)&&(this.mightDrag={node:targetNode,pos:targetPos,addAttr:!(!this.target||this.target.draggable),setUneditable:!(!this.target||!gecko$3||this.target.hasAttribute("contentEditable"))}),this.target&&this.mightDrag&&(this.mightDrag.addAttr||this.mightDrag.setUneditable)&&(this.view.domObserver.stop(),this.mightDrag.addAttr&&(this.target.draggable=!0),this.mightDrag.setUneditable&&setTimeout((()=>{this.view.input.mouseDown==this&&this.target.setAttribute("contentEditable","false")}),20),this.view.domObserver.start()),view.root.addEventListener("mouseup",this.up=this.up.bind(this)),view.root.addEventListener("mousemove",this.move=this.move.bind(this)),setSelectionOrigin$3(view,"pointer")}done(){this.view.root.removeEventListener("mouseup",this.up),this.view.root.removeEventListener("mousemove",this.move),this.mightDrag&&this.target&&(this.view.domObserver.stop(),this.mightDrag.addAttr&&this.target.removeAttribute("draggable"),this.mightDrag.setUneditable&&this.target.removeAttribute("contentEditable"),this.view.domObserver.start()),this.delayedSelectionSync&&setTimeout((()=>selectionToDOM$3(this.view))),this.view.input.mouseDown=null}up(event){if(this.done(),!this.view.dom.contains(event.target))return;let pos=this.pos;this.view.state.doc!=this.startDoc&&(pos=this.view.posAtCoords(eventCoords$3(event))),this.allowDefault||!pos?setSelectionOrigin$3(this.view,"pointer"):handleSingleClick$3(this.view,pos.pos,pos.inside,event,this.selectNode)?event.preventDefault():0==event.button&&(this.flushed||
// Safari ignores clicks on draggable elements
safari$3&&this.mightDrag&&!this.mightDrag.node.isAtom||
// Chrome will sometimes treat a node selection as a
// cursor, but still report that the node is selected
// when asked through getSelection. You'll then get a
// situation where clicking at the point where that
// (hidden) cursor is doesn't change the selection, and
// thus doesn't get a reaction from ProseMirror. This
// works around that.
chrome$1$3&&!(this.view.state.selection instanceof TextSelection$3)&&Math.min(Math.abs(pos.pos-this.view.state.selection.from),Math.abs(pos.pos-this.view.state.selection.to))<=2)?(updateSelection$3(this.view,Selection$3.near(this.view.state.doc.resolve(pos.pos)),"pointer"),event.preventDefault()):setSelectionOrigin$3(this.view,"pointer")}move(event){!this.allowDefault&&(Math.abs(this.event.x-event.clientX)>4||Math.abs(this.event.y-event.clientY)>4)&&(this.allowDefault=!0),setSelectionOrigin$3(this.view,"pointer"),0==event.buttons&&this.done()}}function inOrNearComposition$3(view,event){return!!view.composing||
// See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
// On Japanese input method editors (IMEs), the Enter key is used to confirm character
// selection. On Safari, when Enter is pressed, compositionend and keydown events are
// emitted. The keydown event triggers newline insertion, which we don't want.
// This method returns true if the keydown event should be ignored.
// We only ignore it once, as pressing Enter a second time *should* insert a newline.
// Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.
// This guards against the case where compositionend is triggered without the keyboard
// (e.g. character confirmation may be done with the mouse), and keydown is triggered
// afterwards- we wouldn't want to ignore the keydown event in this case.
!!(safari$3&&Math.abs(event.timeStamp-view.input.compositionEndedAt)<500)&&(view.input.compositionEndedAt=-2e8,!0)}
// Drop active composition after 5 seconds of inactivity on Android
handlers$3.touchdown=view=>{forceDOMFlush$3(view),setSelectionOrigin$3(view,"pointer")},handlers$3.contextmenu=view=>forceDOMFlush$3(view);const timeoutComposition$3=android$3?5e3:-1;function scheduleComposeEnd$3(view,delay){clearTimeout(view.input.composingTimeout),delay>-1&&(view.input.composingTimeout=setTimeout((()=>endComposition$3(view)),delay))}function clearComposition$3(view){view.composing&&(view.input.composing=!1,view.input.compositionEndedAt=timestampFromCustomEvent$3());while(view.input.compositionNodes.length>0)view.input.compositionNodes.pop().markParentsDirty()}function timestampFromCustomEvent$3(){let event=document.createEvent("Event");return event.initEvent("event",!0,!0),event.timeStamp}
/**
@internal
*/function endComposition$3(view,forceUpdate=!1){if(!(android$3&&view.domObserver.flushingSoon>=0)){if(view.domObserver.forceFlush(),clearComposition$3(view),forceUpdate||view.docView&&view.docView.dirty){let sel=selectionFromDOM$3(view);return sel&&!sel.eq(view.state.selection)?view.dispatch(view.state.tr.setSelection(sel)):view.updateState(view.state),!0}return!1}}function captureCopy$3(view,dom){
// The extra wrapper is somehow necessary on IE/Edge to prevent the
// content from being mangled when it is put onto the clipboard
if(!view.dom.parentNode)return;let wrap=view.dom.parentNode.appendChild(document.createElement("div"));wrap.appendChild(dom),wrap.style.cssText="position: fixed; left: -10000px; top: 10px";let sel=getSelection(),range=document.createRange();range.selectNodeContents(dom),
// Done because IE will fire a selectionchange moving the selection
// to its start when removeAllRanges is called and the editor still
// has focus (which will mess up the editor's selection state).
view.dom.blur(),sel.removeAllRanges(),sel.addRange(range),setTimeout((()=>{wrap.parentNode&&wrap.parentNode.removeChild(wrap),view.focus()}),50)}
// This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard API—all the objects and methods are
// there, they just don't work, and they are hard to test.
editHandlers$3.compositionstart=editHandlers$3.compositionupdate=view=>{if(!view.composing){view.domObserver.flush();let{state:state}=view,$pos=state.selection.$from;if(state.selection.empty&&(state.storedMarks||!$pos.textOffset&&$pos.parentOffset&&$pos.nodeBefore.marks.some((m=>!1===m.type.spec.inclusive))))
// Need to wrap the cursor in mark nodes different from the ones in the DOM context
view.markCursor=view.state.storedMarks||$pos.marks(),endComposition$3(view,!0),view.markCursor=null;else
// In firefox, if the cursor is after but outside a marked node,
// the inserted text won't inherit the marks. So this moves it
// inside if necessary.
if(endComposition$3(view),gecko$3&&state.selection.empty&&$pos.parentOffset&&!$pos.textOffset&&$pos.nodeBefore.marks.length){let sel=view.domSelection();for(let node=sel.focusNode,offset=sel.focusOffset;node&&1==node.nodeType&&0!=offset;){let before=offset<0?node.lastChild:node.childNodes[offset-1];if(!before)break;if(3==before.nodeType){sel.collapse(before,before.nodeValue.length);break}node=before,offset=-1}}view.input.composing=!0}scheduleComposeEnd$3(view,timeoutComposition$3)},editHandlers$3.compositionend=(view,event)=>{view.composing&&(view.input.composing=!1,view.input.compositionEndedAt=event.timeStamp,scheduleComposeEnd$3(view,20))};const brokenClipboardAPI$3=ie$1$3&&ie_version$3<15||ios$3&&webkit_version$3<604;function sliceSingleNode$3(slice){return 0==slice.openStart&&0==slice.openEnd&&1==slice.content.childCount?slice.content.firstChild:null}function capturePaste$3(view,event){if(!view.dom.parentNode)return;let plainText=view.input.shiftKey||view.state.selection.$from.parent.type.spec.code,target=view.dom.parentNode.appendChild(document.createElement(plainText?"textarea":"div"));plainText||(target.contentEditable="true"),target.style.cssText="position: fixed; left: -10000px; top: 10px",target.focus(),setTimeout((()=>{view.focus(),target.parentNode&&target.parentNode.removeChild(target),plainText?doPaste$3(view,target.value,null,event):doPaste$3(view,target.textContent,target.innerHTML,event)}),50)}function doPaste$3(view,text,html,event){let slice=parseFromClipboard$3(view,text,html,view.input.shiftKey,view.state.selection.$from);if(view.someProp("handlePaste",(f=>f(view,event,slice||Slice$3.empty))))return!0;if(!slice)return!1;let singleNode=sliceSingleNode$3(slice),tr=singleNode?view.state.tr.replaceSelectionWith(singleNode,view.input.shiftKey):view.state.tr.replaceSelection(slice);return view.dispatch(tr.scrollIntoView().setMeta("paste",!0).setMeta("uiEvent","paste")),!0}handlers$3.copy=editHandlers$3.cut=(view,_event)=>{let event=_event,sel=view.state.selection,cut="cut"==event.type;if(sel.empty)return;
// IE and Edge's clipboard interface is completely broken
let data=brokenClipboardAPI$3?null:event.clipboardData,slice=sel.content(),{dom:dom,text:text}=serializeForClipboard$3(view,slice);data?(event.preventDefault(),data.clearData(),data.setData("text/html",dom.innerHTML),data.setData("text/plain",text)):captureCopy$3(view,dom),cut&&view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent","cut"))},editHandlers$3.paste=(view,_event)=>{let event=_event;
// Handling paste from JavaScript during composition is very poorly
// handled by browsers, so as a dodgy but preferable kludge, we just
// let the browser do its native thing there, except on Android,
// where the editor is almost always composing.
if(view.composing&&!android$3)return;let data=brokenClipboardAPI$3?null:event.clipboardData;data&&doPaste$3(view,data.getData("text/plain"),data.getData("text/html"),event)?event.preventDefault():capturePaste$3(view,event)};class Dragging$3{constructor(slice,move){this.slice=slice,this.move=move}}const dragCopyModifier$3=mac$2$3?"altKey":"ctrlKey";handlers$3.dragstart=(view,_event)=>{let event=_event,mouseDown=view.input.mouseDown;if(mouseDown&&mouseDown.done(),!event.dataTransfer)return;let sel=view.state.selection,pos=sel.empty?null:view.posAtCoords(eventCoords$3(event));if(pos&&pos.pos>=sel.from&&pos.pos<=(sel instanceof NodeSelection$3?sel.to-1:sel.to));else if(mouseDown&&mouseDown.mightDrag)view.dispatch(view.state.tr.setSelection(NodeSelection$3.create(view.state.doc,mouseDown.mightDrag.pos)));else if(event.target&&1==event.target.nodeType){let desc=view.docView.nearestDesc(event.target,!0);desc&&desc.node.type.spec.draggable&&desc!=view.docView&&view.dispatch(view.state.tr.setSelection(NodeSelection$3.create(view.state.doc,desc.posBefore)))}let slice=view.state.selection.content(),{dom:dom,text:text}=serializeForClipboard$3(view,slice);event.dataTransfer.clearData(),event.dataTransfer.setData(brokenClipboardAPI$3?"Text":"text/html",dom.innerHTML),
// See https://github.com/ProseMirror/prosemirror/issues/1156
event.dataTransfer.effectAllowed="copyMove",brokenClipboardAPI$3||event.dataTransfer.setData("text/plain",text),view.dragging=new Dragging$3(slice,!event[dragCopyModifier$3])},handlers$3.dragend=view=>{let dragging=view.dragging;window.setTimeout((()=>{view.dragging==dragging&&(view.dragging=null)}),50)},editHandlers$3.dragover=editHandlers$3.dragenter=(_,e)=>e.preventDefault(),editHandlers$3.drop=(view,_event)=>{let event=_event,dragging=view.dragging;if(view.dragging=null,!event.dataTransfer)return;let eventPos=view.posAtCoords(eventCoords$3(event));if(!eventPos)return;let $mouse=view.state.doc.resolve(eventPos.pos);if(!$mouse)return;let slice=dragging&&dragging.slice;slice?view.someProp("transformPasted",(f=>{slice=f(slice)})):slice=parseFromClipboard$3(view,event.dataTransfer.getData(brokenClipboardAPI$3?"Text":"text/plain"),brokenClipboardAPI$3?null:event.dataTransfer.getData("text/html"),!1,$mouse);let move=!(!dragging||event[dragCopyModifier$3]);if(view.someProp("handleDrop",(f=>f(view,event,slice||Slice$3.empty,move))))return void event.preventDefault();if(!slice)return;event.preventDefault();let insertPos=slice?dropPoint$3(view.state.doc,$mouse.pos,slice):$mouse.pos;null==insertPos&&(insertPos=$mouse.pos);let tr=view.state.tr;move&&tr.deleteSelection();let pos=tr.mapping.map(insertPos),isNode=0==slice.openStart&&0==slice.openEnd&&1==slice.content.childCount,beforeInsert=tr.doc;if(isNode?tr.replaceRangeWith(pos,pos,slice.content.firstChild):tr.replaceRange(pos,pos,slice),tr.doc.eq(beforeInsert))return;let $pos=tr.doc.resolve(pos);if(isNode&&NodeSelection$3.isSelectable(slice.content.firstChild)&&$pos.nodeAfter&&$pos.nodeAfter.sameMarkup(slice.content.firstChild))tr.setSelection(new NodeSelection$3($pos));else{let end=tr.mapping.map(insertPos);tr.mapping.maps[tr.mapping.maps.length-1].forEach(((_from,_to,_newFrom,newTo)=>end=newTo)),tr.setSelection(selectionBetween$3(view,$pos,tr.doc.resolve(end)))}view.focus(),view.dispatch(tr.setMeta("uiEvent","drop"))},handlers$3.focus=view=>{view.focused||(view.domObserver.stop(),view.dom.classList.add("ProseMirror-focused"),view.domObserver.start(),view.focused=!0,setTimeout((()=>{view.docView&&view.hasFocus()&&!view.domObserver.currentSelection.eq(view.domSelection())&&selectionToDOM$3(view)}),20))},handlers$3.blur=(view,_event)=>{let event=_event;view.focused&&(view.domObserver.stop(),view.dom.classList.remove("ProseMirror-focused"),view.domObserver.start(),event.relatedTarget&&view.dom.contains(event.relatedTarget)&&view.domObserver.currentSelection.clear(),view.focused=!1)},handlers$3.beforeinput=(view,_event)=>{let event=_event;
// We should probably do more with beforeinput events, but support
// is so spotty that I'm still waiting to see where they are going.
// Very specific hack to deal with backspace sometimes failing on
// Chrome Android when after an uneditable node.
if(chrome$1$3&&android$3&&"deleteContentBackward"==event.inputType){view.domObserver.flushSoon();let{domChangeCount:domChangeCount}=view.input;setTimeout((()=>{if(view.input.domChangeCount!=domChangeCount)return;// Event already had some effect
// This bug tends to close the virtual keyboard, so we refocus
if(view.dom.blur(),view.focus(),view.someProp("handleKeyDown",(f=>f(view,keyEvent$3(8,"Backspace")))))return;let{$cursor:$cursor}=view.state.selection;
// Crude approximation of backspace behavior when no command handled it
$cursor&&$cursor.pos>0&&view.dispatch(view.state.tr.delete($cursor.pos-1,$cursor.pos).scrollIntoView())}),50)}};
// Make sure all handlers get registered
for(let prop in editHandlers$3)handlers$3[prop]=editHandlers$3[prop];function compareObjs$3(a,b){if(a==b)return!0;for(let p in a)if(a[p]!==b[p])return!1;for(let p in b)if(!(p in a))return!1;return!0}class WidgetType$3{constructor(toDOM,spec){this.toDOM=toDOM,this.spec=spec||noSpec$3,this.side=this.spec.side||0}map(mapping,span,offset,oldOffset){let{pos:pos,deleted:deleted}=mapping.mapResult(span.from+oldOffset,this.side<0?-1:1);return deleted?null:new Decoration$3(pos-offset,pos-offset,this)}valid(){return!0}eq(other){return this==other||other instanceof WidgetType$3&&(this.spec.key&&this.spec.key==other.spec.key||this.toDOM==other.toDOM&&compareObjs$3(this.spec,other.spec))}destroy(node){this.spec.destroy&&this.spec.destroy(node)}}class InlineType$3{constructor(attrs,spec){this.attrs=attrs,this.spec=spec||noSpec$3}map(mapping,span,offset,oldOffset){let from=mapping.map(span.from+oldOffset,this.spec.inclusiveStart?-1:1)-offset,to=mapping.map(span.to+oldOffset,this.spec.inclusiveEnd?1:-1)-offset;return from>=to?null:new Decoration$3(from,to,this)}valid(_,span){return span.from<span.to}eq(other){return this==other||other instanceof InlineType$3&&compareObjs$3(this.attrs,other.attrs)&&compareObjs$3(this.spec,other.spec)}static is(span){return span.type instanceof InlineType$3}destroy(){}}class NodeType$4{constructor(attrs,spec){this.attrs=attrs,this.spec=spec||noSpec$3}map(mapping,span,offset,oldOffset){let from=mapping.mapResult(span.from+oldOffset,1);if(from.deleted)return null;let to=mapping.mapResult(span.to+oldOffset,-1);return to.deleted||to.pos<=from.pos?null:new Decoration$3(from.pos-offset,to.pos-offset,this)}valid(node,span){let child,{index:index,offset:offset}=node.content.findIndex(span.from);return offset==span.from&&!(child=node.child(index)).isText&&offset+child.nodeSize==span.to}eq(other){return this==other||other instanceof NodeType$4&&compareObjs$3(this.attrs,other.attrs)&&compareObjs$3(this.spec,other.spec)}destroy(){}}
/**
Decoration objects can be provided to the view through the
[`decorations` prop](https://prosemirror.net/docs/ref/#view.EditorProps.decorations). They come in
several variants—see the static members of this class for details.
*/class Decoration$3{
/**
    @internal
    */
constructor(
/**
    The start position of the decoration.
    */
from,
/**
    The end position. Will be the same as `from` for [widget
    decorations](https://prosemirror.net/docs/ref/#view.Decoration^widget).
    */
to,
/**
    @internal
    */
type){this.from=from,this.to=to,this.type=type}
/**
    @internal
    */copy(from,to){return new Decoration$3(from,to,this.type)}
/**
    @internal
    */eq(other,offset=0){return this.type.eq(other.type)&&this.from+offset==other.from&&this.to+offset==other.to}
/**
    @internal
    */map(mapping,offset,oldOffset){return this.type.map(mapping,this,offset,oldOffset)}
/**
    Creates a widget decoration, which is a DOM node that's shown in
    the document at the given position. It is recommended that you
    delay rendering the widget by passing a function that will be
    called when the widget is actually drawn in a view, but you can
    also directly pass a DOM node. `getPos` can be used to find the
    widget's current document position.
    */static widget(pos,toDOM,spec){return new Decoration$3(pos,pos,new WidgetType$3(toDOM,spec))}
/**
    Creates an inline decoration, which adds the given attributes to
    each inline node between `from` and `to`.
    */static inline(from,to,attrs,spec){return new Decoration$3(from,to,new InlineType$3(attrs,spec))}
/**
    Creates a node decoration. `from` and `to` should point precisely
    before and after a node in the document. That node, and only that
    node, will receive the given attributes.
    */static node(from,to,attrs,spec){return new Decoration$3(from,to,new NodeType$4(attrs,spec))}
/**
    The spec provided when creating this decoration. Can be useful
    if you've stored extra information in that object.
    */get spec(){return this.type.spec}
/**
    @internal
    */get inline(){return this.type instanceof InlineType$3}}const none$3=[],noSpec$3={};
/**
A collection of [decorations](https://prosemirror.net/docs/ref/#view.Decoration), organized in such
a way that the drawing algorithm can efficiently use and compare
them. This is a persistent data structure—it is not modified,
updates create a new value.
*/class DecorationSet$3{
/**
    @internal
    */
constructor(local,children){this.local=local.length?local:none$3,this.children=children.length?children:none$3}
/**
    Create a set of decorations, using the structure of the given
    document.
    */static create(doc,decorations){return decorations.length?buildTree$3(decorations,doc,0,noSpec$3):empty$3}
/**
    Find all decorations in this set which touch the given range
    (including decorations that start or end directly at the
    boundaries) and match the given predicate on their spec. When
    `start` and `end` are omitted, all decorations in the set are
    considered. When `predicate` isn't given, all decorations are
    assumed to match.
    */find(start,end,predicate){let result=[];return this.findInner(null==start?0:start,null==end?1e9:end,result,0,predicate),result}findInner(start,end,result,offset,predicate){for(let i=0;i<this.local.length;i++){let span=this.local[i];span.from<=end&&span.to>=start&&(!predicate||predicate(span.spec))&&result.push(span.copy(span.from+offset,span.to+offset))}for(let i=0;i<this.children.length;i+=3)if(this.children[i]<end&&this.children[i+1]>start){let childOff=this.children[i]+1;this.children[i+2].findInner(start-childOff,end-childOff,result,offset+childOff,predicate)}}
/**
    Map the set of decorations in response to a change in the
    document.
    */map(mapping,doc,options){return this==empty$3||0==mapping.maps.length?this:this.mapInner(mapping,doc,0,0,options||noSpec$3)}
/**
    @internal
    */mapInner(mapping,node,offset,oldOffset,options){let newLocal;for(let i=0;i<this.local.length;i++){let mapped=this.local[i].map(mapping,offset,oldOffset);mapped&&mapped.type.valid(node,mapped)?(newLocal||(newLocal=[])).push(mapped):options.onRemove&&options.onRemove(this.local[i].spec)}return this.children.length?mapChildren$3(this.children,newLocal||[],mapping,node,offset,oldOffset,options):newLocal?new DecorationSet$3(newLocal.sort(byPos$3),none$3):empty$3}
/**
    Add the given array of decorations to the ones in the set,
    producing a new set. Needs access to the current document to
    create the appropriate tree structure.
    */add(doc,decorations){return decorations.length?this==empty$3?DecorationSet$3.create(doc,decorations):this.addInner(doc,decorations,0):this}addInner(doc,decorations,offset){let children,childIndex=0;doc.forEach(((childNode,childOffset)=>{let found,baseOffset=childOffset+offset;if(found=takeSpansForNode$3(decorations,childNode,baseOffset)){children||(children=this.children.slice());while(childIndex<children.length&&children[childIndex]<childOffset)childIndex+=3;children[childIndex]==childOffset?children[childIndex+2]=children[childIndex+2].addInner(childNode,found,baseOffset+1):children.splice(childIndex,0,childOffset,childOffset+childNode.nodeSize,buildTree$3(found,childNode,baseOffset+1,noSpec$3)),childIndex+=3}}));let local=moveSpans$3(childIndex?withoutNulls$3(decorations):decorations,-offset);for(let i=0;i<local.length;i++)local[i].type.valid(doc,local[i])||local.splice(i--,1);return new DecorationSet$3(local.length?this.local.concat(local).sort(byPos$3):this.local,children||this.children)}
/**
    Create a new set that contains the decorations in this set, minus
    the ones in the given array.
    */remove(decorations){return 0==decorations.length||this==empty$3?this:this.removeInner(decorations,0)}removeInner(decorations,offset){let children=this.children,local=this.local;for(let i=0;i<children.length;i+=3){let found,from=children[i]+offset,to=children[i+1]+offset;for(let span,j=0;j<decorations.length;j++)(span=decorations[j])&&span.from>from&&span.to<to&&(decorations[j]=null,(found||(found=[])).push(span));if(!found)continue;children==this.children&&(children=this.children.slice());let removed=children[i+2].removeInner(found,from+1);removed!=empty$3?children[i+2]=removed:(children.splice(i,3),i-=3)}if(local.length)for(let span,i=0;i<decorations.length;i++)if(span=decorations[i])for(let j=0;j<local.length;j++)local[j].eq(span,offset)&&(local==this.local&&(local=this.local.slice()),local.splice(j--,1));return children==this.children&&local==this.local?this:local.length||children.length?new DecorationSet$3(local,children):empty$3}
/**
    @internal
    */forChild(offset,node){if(this==empty$3)return this;if(node.isLeaf)return DecorationSet$3.empty;let child,local;for(let i=0;i<this.children.length;i+=3)if(this.children[i]>=offset){this.children[i]==offset&&(child=this.children[i+2]);break}let start=offset+1,end=start+node.content.size;for(let i=0;i<this.local.length;i++){let dec=this.local[i];if(dec.from<end&&dec.to>start&&dec.type instanceof InlineType$3){let from=Math.max(start,dec.from)-start,to=Math.min(end,dec.to)-start;from<to&&(local||(local=[])).push(dec.copy(from,to))}}if(local){let localSet=new DecorationSet$3(local.sort(byPos$3),none$3);return child?new DecorationGroup$3([localSet,child]):localSet}return child||empty$3}
/**
    @internal
    */eq(other){if(this==other)return!0;if(!(other instanceof DecorationSet$3)||this.local.length!=other.local.length||this.children.length!=other.children.length)return!1;for(let i=0;i<this.local.length;i++)if(!this.local[i].eq(other.local[i]))return!1;for(let i=0;i<this.children.length;i+=3)if(this.children[i]!=other.children[i]||this.children[i+1]!=other.children[i+1]||!this.children[i+2].eq(other.children[i+2]))return!1;return!0}
/**
    @internal
    */locals(node){return removeOverlap$3(this.localsInner(node))}
/**
    @internal
    */localsInner(node){if(this==empty$3)return none$3;if(node.inlineContent||!this.local.some(InlineType$3.is))return this.local;let result=[];for(let i=0;i<this.local.length;i++)this.local[i].type instanceof InlineType$3||result.push(this.local[i]);return result}}
/**
The empty set of decorations.
*/DecorationSet$3.empty=new DecorationSet$3([],[]),
/**
@internal
*/
DecorationSet$3.removeOverlap=removeOverlap$3;const empty$3=DecorationSet$3.empty;
// An abstraction that allows the code dealing with decorations to
// treat multiple DecorationSet objects as if it were a single object
// with (a subset of) the same interface.
class DecorationGroup$3{constructor(members){this.members=members}map(mapping,doc){const mappedDecos=this.members.map((member=>member.map(mapping,doc,noSpec$3)));return DecorationGroup$3.from(mappedDecos)}forChild(offset,child){if(child.isLeaf)return DecorationSet$3.empty;let found=[];for(let i=0;i<this.members.length;i++){let result=this.members[i].forChild(offset,child);result!=empty$3&&(result instanceof DecorationGroup$3?found=found.concat(result.members):found.push(result))}return DecorationGroup$3.from(found)}eq(other){if(!(other instanceof DecorationGroup$3)||other.members.length!=this.members.length)return!1;for(let i=0;i<this.members.length;i++)if(!this.members[i].eq(other.members[i]))return!1;return!0}locals(node){let result,sorted=!0;for(let i=0;i<this.members.length;i++){let locals=this.members[i].localsInner(node);if(locals.length)if(result){sorted&&(result=result.slice(),sorted=!1);for(let j=0;j<locals.length;j++)result.push(locals[j])}else result=locals}return result?removeOverlap$3(sorted?result:result.sort(byPos$3)):none$3}
// Create a group for the given array of decoration sets, or return
// a single set when possible.
static from(members){switch(members.length){case 0:return empty$3;case 1:return members[0];default:return new DecorationGroup$3(members)}}}function mapChildren$3(oldChildren,newLocal,mapping,node,offset,oldOffset,options){let children=oldChildren.slice(),shift=(oldStart,oldEnd,newStart,newEnd)=>{for(let i=0;i<children.length;i+=3){let dSize,end=children[i+1];if(end<0||oldStart>end+oldOffset)continue;let start=children[i]+oldOffset;oldEnd>=start?children[i+1]=oldStart<=start?-2:-1:newStart>=offset&&(dSize=newEnd-newStart-(oldEnd-oldStart))&&(children[i]+=dSize,children[i+1]+=dSize)}};
// Mark the children that are directly touched by changes, and
// move those that are after the changes.
for(let i=0;i<mapping.maps.length;i++)mapping.maps[i].forEach(shift);
// Find the child nodes that still correspond to a single node,
// recursively call mapInner on them and update their positions.
let mustRebuild=!1;for(let i=0;i<children.length;i+=3)if(children[i+1]<0){// Touched nodes
if(-2==children[i+1]){mustRebuild=!0,children[i+1]=-1;continue}let from=mapping.map(oldChildren[i]+oldOffset),fromLocal=from-offset;if(fromLocal<0||fromLocal>=node.content.size){mustRebuild=!0;continue}
// Must read oldChildren because children was tagged with -1
let to=mapping.map(oldChildren[i+1]+oldOffset,-1),toLocal=to-offset,{index:index,offset:childOffset}=node.content.findIndex(fromLocal),childNode=node.maybeChild(index);if(childNode&&childOffset==fromLocal&&childOffset+childNode.nodeSize==toLocal){let mapped=children[i+2].mapInner(mapping,childNode,from+1,oldChildren[i]+oldOffset+1,options);mapped!=empty$3?(children[i]=fromLocal,children[i+1]=toLocal,children[i+2]=mapped):(children[i+1]=-2,mustRebuild=!0)}else mustRebuild=!0}
// Remaining children must be collected and rebuilt into the appropriate structure
if(mustRebuild){let decorations=mapAndGatherRemainingDecorations$3(children,oldChildren,newLocal,mapping,offset,oldOffset,options),built=buildTree$3(decorations,node,0,options);newLocal=built.local;for(let i=0;i<children.length;i+=3)children[i+1]<0&&(children.splice(i,3),i-=3);for(let i=0,j=0;i<built.children.length;i+=3){let from=built.children[i];while(j<children.length&&children[j]<from)j+=3;children.splice(j,0,built.children[i],built.children[i+1],built.children[i+2])}}return new DecorationSet$3(newLocal.sort(byPos$3),children)}function moveSpans$3(spans,offset){if(!offset||!spans.length)return spans;let result=[];for(let i=0;i<spans.length;i++){let span=spans[i];result.push(new Decoration$3(span.from+offset,span.to+offset,span.type))}return result}function mapAndGatherRemainingDecorations$3(children,oldChildren,decorations,mapping,offset,oldOffset,options){
// Gather all decorations from the remaining marked children
function gather(set,oldOffset){for(let i=0;i<set.local.length;i++){let mapped=set.local[i].map(mapping,offset,oldOffset);mapped?decorations.push(mapped):options.onRemove&&options.onRemove(set.local[i].spec)}for(let i=0;i<set.children.length;i+=3)gather(set.children[i+2],set.children[i]+oldOffset+1)}for(let i=0;i<children.length;i+=3)-1==children[i+1]&&gather(children[i+2],oldChildren[i]+oldOffset+1);return decorations}function takeSpansForNode$3(spans,node,offset){if(node.isLeaf)return null;let end=offset+node.nodeSize,found=null;for(let span,i=0;i<spans.length;i++)(span=spans[i])&&span.from>offset&&span.to<end&&((found||(found=[])).push(span),spans[i]=null);return found}function withoutNulls$3(array){let result=[];for(let i=0;i<array.length;i++)null!=array[i]&&result.push(array[i]);return result}
// Build up a tree that corresponds to a set of decorations. `offset`
// is a base offset that should be subtracted from the `from` and `to`
// positions in the spans (so that we don't have to allocate new spans
// for recursive calls).
function buildTree$3(spans,node,offset,options){let children=[],hasNulls=!1;node.forEach(((childNode,localStart)=>{let found=takeSpansForNode$3(spans,childNode,localStart+offset);if(found){hasNulls=!0;let subtree=buildTree$3(found,childNode,offset+localStart+1,options);subtree!=empty$3&&children.push(localStart,localStart+childNode.nodeSize,subtree)}}));let locals=moveSpans$3(hasNulls?withoutNulls$3(spans):spans,-offset).sort(byPos$3);for(let i=0;i<locals.length;i++)locals[i].type.valid(node,locals[i])||(options.onRemove&&options.onRemove(locals[i].spec),locals.splice(i--,1));return locals.length||children.length?new DecorationSet$3(locals,children):empty$3}
// Used to sort decorations so that ones with a low start position
// come first, and within a set with the same start position, those
// with an smaller end position come first.
function byPos$3(a,b){return a.from-b.from||a.to-b.to}
// Scan a sorted array of decorations for partially overlapping spans,
// and split those so that only fully overlapping spans are left (to
// make subsequent rendering easier). Will return the input array if
// no partially overlapping spans are found (the common case).
function removeOverlap$3(spans){let working=spans;for(let i=0;i<working.length-1;i++){let span=working[i];if(span.from!=span.to)for(let j=i+1;j<working.length;j++){let next=working[j];if(next.from!=span.from){next.from<span.to&&(working==spans&&(working=spans.slice()),
// The end of this one overlaps with a subsequent span. Split
// this one.
working[i]=span.copy(span.from,next.from),insertAhead$3(working,j,span.copy(next.from,span.to)));break}next.to!=span.to&&(working==spans&&(working=spans.slice()),
// Followed by a partially overlapping larger span. Split that
// span.
working[j]=next.copy(next.from,span.to),insertAhead$3(working,j+1,next.copy(span.to,next.to)))}}return working}function insertAhead$3(array,i,deco){while(i<array.length&&byPos$3(deco,array[i])>0)i++;array.splice(i,0,deco)}var base$3={8:"Backspace",9:"Tab",10:"Enter",12:"NumLock",13:"Enter",16:"Shift",17:"Control",18:"Alt",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",44:"PrintScreen",45:"Insert",46:"Delete",59:";",61:"=",91:"Meta",92:"Meta",106:"*",107:"+",108:",",109:"-",110:".",111:"/",144:"NumLock",145:"ScrollLock",160:"Shift",161:"Shift",162:"Control",163:"Control",164:"Alt",165:"Alt",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},shift$2$3={48:")",49:"!",50:"@",51:"#",52:"$",53:"%",54:"^",55:"&",56:"*",57:"(",59:":",61:"+",173:"_",186:":",187:"+",188:"<",189:"_",190:">",191:"?",192:"~",219:"{",220:"|",221:"}",222:'"'},chrome$4="undefined"!=typeof navigator&&/Chrome\/(\d+)/.exec(navigator.userAgent);"undefined"!=typeof navigator&&/Gecko\/\d+/.test(navigator.userAgent);
// Fill in the digit keys
for(var mac$1$3="undefined"!=typeof navigator&&/Mac/.test(navigator.platform),ie$4="undefined"!=typeof navigator&&/MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent),brokenModifierNames$3=mac$1$3||chrome$4&&+chrome$4[1]<57,i$4=0;i$4<10;i$4++)base$3[48+i$4]=base$3[96+i$4]=String(i$4);
// The function keys
for(i$4=1;i$4<=24;i$4++)base$3[i$4+111]="F"+i$4;
// And the alphabetic keys
for(i$4=65;i$4<=90;i$4++)base$3[i$4]=String.fromCharCode(i$4+32),shift$2$3[i$4]=String.fromCharCode(i$4);
// For each code that doesn't have a shift-equivalent, copy the base name
for(var code$3 in base$3)shift$2$3.hasOwnProperty(code$3)||(shift$2$3[code$3]=base$3[code$3]);function keyName$3(event){var ignoreKey=brokenModifierNames$3&&(event.ctrlKey||event.altKey||event.metaKey)||ie$4&&event.shiftKey&&event.key&&1==event.key.length||"Unidentified"==event.key,name=!ignoreKey&&event.key||(event.shiftKey?shift$2$3:base$3)[event.keyCode]||event.key||"Unidentified";
// Edge sometimes produces wrong names (Issue #3)
return"Esc"==name&&(name="Escape"),"Del"==name&&(name="Delete"),
// https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
"Left"==name&&(name="ArrowLeft"),"Up"==name&&(name="ArrowUp"),"Right"==name&&(name="ArrowRight"),"Down"==name&&(name="ArrowDown"),name}const mac$5="undefined"!=typeof navigator&&/Mac|iP(hone|[oa]d)/.test(navigator.platform);function normalizeKeyName$1$3(name){let alt,ctrl,shift,meta,parts=name.split(/-(?!$)/),result=parts[parts.length-1];"Space"==result&&(result=" ");for(let i=0;i<parts.length-1;i++){let mod=parts[i];if(/^(cmd|meta|m)$/i.test(mod))meta=!0;else if(/^a(lt)?$/i.test(mod))alt=!0;else if(/^(c|ctrl|control)$/i.test(mod))ctrl=!0;else if(/^s(hift)?$/i.test(mod))shift=!0;else{if(!/^mod$/i.test(mod))throw new Error("Unrecognized modifier name: "+mod);mac$5?meta=!0:ctrl=!0}}return alt&&(result="Alt-"+result),ctrl&&(result="Ctrl-"+result),meta&&(result="Meta-"+result),shift&&(result="Shift-"+result),result}function normalize$3(map){let copy=Object.create(null);for(let prop in map)copy[normalizeKeyName$1$3(prop)]=map[prop];return copy}function modifiers$2$3(name,event,shift){return event.altKey&&(name="Alt-"+name),event.ctrlKey&&(name="Ctrl-"+name),event.metaKey&&(name="Meta-"+name),!1!==shift&&event.shiftKey&&(name="Shift-"+name),name}
/**
Given a set of bindings (using the same format as
[`keymap`](https://prosemirror.net/docs/ref/#keymap.keymap)), return a [keydown
handler](https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyDown) that handles them.
*/function keydownHandler$3(bindings){let map=normalize$3(bindings);return function(view,event){let baseName,name=keyName$3(event),isChar=1==name.length&&" "!=name,direct=map[modifiers$2$3(name,event,!isChar)];if(direct&&direct(view.state,view.dispatch,view))return!0;if(isChar&&(event.shiftKey||event.altKey||event.metaKey||name.charCodeAt(0)>127)&&(baseName=base$3[event.keyCode])&&baseName!=name){
// Try falling back to the keyCode when there's a modifier
// active or the character produced isn't ASCII, and our table
// produces a different name from the the keyCode. See #668,
// #1060
let fromCode=map[modifiers$2$3(baseName,event,!0)];if(fromCode&&fromCode(view.state,view.dispatch,view))return!0}else if(isChar&&event.shiftKey){
// Otherwise, if shift is active, also try the binding with the
// Shift- prefix enabled. See #997
let withShift=map[modifiers$2$3(name,event,!0)];if(withShift&&withShift(view.state,view.dispatch,view))return!0}return!1}}
/**
Delete the selection, if there is one.
*/const deleteSelection$1$3=(state,dispatch)=>!state.selection.empty&&(dispatch&&dispatch(state.tr.deleteSelection().scrollIntoView()),!0),joinBackward$1$3=(state,dispatch,view)=>{let{$cursor:$cursor}=state.selection;if(!$cursor||(view?!view.endOfTextblock("backward",state):$cursor.parentOffset>0))return!1;let $cut=findCutBefore$3($cursor);
// If there is no node before this, try to lift
if(!$cut){let range=$cursor.blockRange(),target=range&&liftTarget$3(range);return null!=target&&(dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0)}let before=$cut.nodeBefore;
// Apply the joining algorithm
if(!before.type.spec.isolating&&deleteBarrier$3(state,$cut,dispatch))return!0;
// If the node below has no content and the node above is
// selectable, delete the node below and select the one above.
if(0==$cursor.parent.content.size&&(textblockAt$3(before,"end")||NodeSelection$3.isSelectable(before))){let delStep=replaceStep$3(state.doc,$cursor.before(),$cursor.after(),Slice$3.empty);if(delStep&&delStep.slice.size<delStep.to-delStep.from){if(dispatch){let tr=state.tr.step(delStep);tr.setSelection(textblockAt$3(before,"end")?Selection$3.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos,-1)),-1):NodeSelection$3.create(tr.doc,$cut.pos-before.nodeSize)),dispatch(tr.scrollIntoView())}return!0}}
// If the node before is an atom, delete it
return!(!before.isAtom||$cut.depth!=$cursor.depth-1)&&(dispatch&&dispatch(state.tr.delete($cut.pos-before.nodeSize,$cut.pos).scrollIntoView()),!0)};
/**
If the selection is empty and at the start of a textblock, try to
reduce the distance between that block and the one before it—if
there's a block directly before it that can be joined, join them.
If not, try to move the selected block closer to the next one in
the document structure by lifting it out of its parent or moving it
into a parent of the previous block. Will use the view for accurate
(bidi-aware) start-of-textblock detection if given.
*/function textblockAt$3(node,side,only=!1){for(let scan=node;scan;scan="start"==side?scan.firstChild:scan.lastChild){if(scan.isTextblock)return!0;if(only&&1!=scan.childCount)return!1}return!1}
/**
When the selection is empty and at the start of a textblock, select
the node before that textblock, if possible. This is intended to be
bound to keys like backspace, after
[`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward) or other deleting
commands, as a fall-back behavior when the schema doesn't allow
deletion at the selected point.
*/const selectNodeBackward$1$3=(state,dispatch,view)=>{let{$head:$head,empty:empty}=state.selection,$cut=$head;if(!empty)return!1;if($head.parent.isTextblock){if(view?!view.endOfTextblock("backward",state):$head.parentOffset>0)return!1;$cut=findCutBefore$3($head)}let node=$cut&&$cut.nodeBefore;return!(!node||!NodeSelection$3.isSelectable(node))&&(dispatch&&dispatch(state.tr.setSelection(NodeSelection$3.create(state.doc,$cut.pos-node.nodeSize)).scrollIntoView()),!0)};function findCutBefore$3($pos){if(!$pos.parent.type.spec.isolating)for(let i=$pos.depth-1;i>=0;i--){if($pos.index(i)>0)return $pos.doc.resolve($pos.before(i+1));if($pos.node(i).type.spec.isolating)break}return null}
/**
If the selection is empty and the cursor is at the end of a
textblock, try to reduce or remove the boundary between that block
and the one after it, either by joining them or by moving the other
block closer to this one in the tree structure. Will use the view
for accurate start-of-textblock detection if given.
*/const joinForward$1$3=(state,dispatch,view)=>{let{$cursor:$cursor}=state.selection;if(!$cursor||(view?!view.endOfTextblock("forward",state):$cursor.parentOffset<$cursor.parent.content.size))return!1;let $cut=findCutAfter$3($cursor);
// If there is no node after this, there's nothing to do
if(!$cut)return!1;let after=$cut.nodeAfter;
// Try the joining algorithm
if(deleteBarrier$3(state,$cut,dispatch))return!0;
// If the node above has no content and the node below is
// selectable, delete the node above and select the one below.
if(0==$cursor.parent.content.size&&(textblockAt$3(after,"start")||NodeSelection$3.isSelectable(after))){let delStep=replaceStep$3(state.doc,$cursor.before(),$cursor.after(),Slice$3.empty);if(delStep&&delStep.slice.size<delStep.to-delStep.from){if(dispatch){let tr=state.tr.step(delStep);tr.setSelection(textblockAt$3(after,"start")?Selection$3.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)),1):NodeSelection$3.create(tr.doc,tr.mapping.map($cut.pos))),dispatch(tr.scrollIntoView())}return!0}}
// If the next node is an atom, delete it
return!(!after.isAtom||$cut.depth!=$cursor.depth-1)&&(dispatch&&dispatch(state.tr.delete($cut.pos,$cut.pos+after.nodeSize).scrollIntoView()),!0)},selectNodeForward$1$3=(state,dispatch,view)=>{let{$head:$head,empty:empty}=state.selection,$cut=$head;if(!empty)return!1;if($head.parent.isTextblock){if(view?!view.endOfTextblock("forward",state):$head.parentOffset<$head.parent.content.size)return!1;$cut=findCutAfter$3($head)}let node=$cut&&$cut.nodeAfter;return!(!node||!NodeSelection$3.isSelectable(node))&&(dispatch&&dispatch(state.tr.setSelection(NodeSelection$3.create(state.doc,$cut.pos)).scrollIntoView()),!0)};
/**
When the selection is empty and at the end of a textblock, select
the node coming after that textblock, if possible. This is intended
to be bound to keys like delete, after
[`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward) and similar deleting
commands, to provide a fall-back behavior when the schema doesn't
allow deletion at the selected point.
*/function findCutAfter$3($pos){if(!$pos.parent.type.spec.isolating)for(let i=$pos.depth-1;i>=0;i--){let parent=$pos.node(i);if($pos.index(i)+1<parent.childCount)return $pos.doc.resolve($pos.after(i+1));if(parent.type.spec.isolating)break}return null}
/**
Lift the selected block, or the closest ancestor block of the
selection that can be lifted, out of its parent node.
*/const lift$1$3=(state,dispatch)=>{let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to),target=range&&liftTarget$3(range);return null!=target&&(dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0)},newlineInCode$1$3=(state,dispatch)=>{let{$head:$head,$anchor:$anchor}=state.selection;return!(!$head.parent.type.spec.code||!$head.sameParent($anchor))&&(dispatch&&dispatch(state.tr.insertText("\n").scrollIntoView()),!0)};
/**
If the selection is in a node whose type has a truthy
[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, replace the
selection with a newline character.
*/function defaultBlockAt$1$3(match){for(let i=0;i<match.edgeCount;i++){let{type:type}=match.edge(i);if(type.isTextblock&&!type.hasRequiredAttrs())return type}return null}
/**
When the selection is in a node with a truthy
[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, create a
default block after the code block, and move the cursor there.
*/const exitCode$1$3=(state,dispatch)=>{let{$head:$head,$anchor:$anchor}=state.selection;if(!$head.parent.type.spec.code||!$head.sameParent($anchor))return!1;let above=$head.node(-1),after=$head.indexAfter(-1),type=defaultBlockAt$1$3(above.contentMatchAt(after));if(!type||!above.canReplaceWith(after,after,type))return!1;if(dispatch){let pos=$head.after(),tr=state.tr.replaceWith(pos,pos,type.createAndFill());tr.setSelection(Selection$3.near(tr.doc.resolve(pos),1)),dispatch(tr.scrollIntoView())}return!0},createParagraphNear$1$3=(state,dispatch)=>{let sel=state.selection,{$from:$from,$to:$to}=sel;if(sel instanceof AllSelection$3||$from.parent.inlineContent||$to.parent.inlineContent)return!1;let type=defaultBlockAt$1$3($to.parent.contentMatchAt($to.indexAfter()));if(!type||!type.isTextblock)return!1;if(dispatch){let side=(!$from.parentOffset&&$to.index()<$to.parent.childCount?$from:$to).pos,tr=state.tr.insert(side,type.createAndFill());tr.setSelection(TextSelection$3.create(tr.doc,side+1)),dispatch(tr.scrollIntoView())}return!0},liftEmptyBlock$1$3=(state,dispatch)=>{let{$cursor:$cursor}=state.selection;if(!$cursor||$cursor.parent.content.size)return!1;if($cursor.depth>1&&$cursor.after()!=$cursor.end(-1)){let before=$cursor.before();if(canSplit$3(state.doc,before))return dispatch&&dispatch(state.tr.split(before).scrollIntoView()),!0}let range=$cursor.blockRange(),target=range&&liftTarget$3(range);return null!=target&&(dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0)},selectParentNode$1$3=(state,dispatch)=>{let pos,{$from:$from,to:to}=state.selection,same=$from.sharedDepth(to);return 0!=same&&(pos=$from.before(same),dispatch&&dispatch(state.tr.setSelection(NodeSelection$3.create(state.doc,pos))),!0)};
/**
If a block node is selected, create an empty paragraph before (if
it is its parent's first child) or after it.
*/function joinMaybeClear$3(state,$pos,dispatch){let before=$pos.nodeBefore,after=$pos.nodeAfter,index=$pos.index();return!!(before&&after&&before.type.compatibleContent(after.type))&&(!before.content.size&&$pos.parent.canReplace(index-1,index)?(dispatch&&dispatch(state.tr.delete($pos.pos-before.nodeSize,$pos.pos).scrollIntoView()),!0):!(!$pos.parent.canReplace(index,index+1)||!after.isTextblock&&!canJoin$3(state.doc,$pos.pos))&&(dispatch&&dispatch(state.tr.clearIncompatible($pos.pos,before.type,before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView()),!0))}function deleteBarrier$3(state,$cut,dispatch){let conn,match,before=$cut.nodeBefore,after=$cut.nodeAfter;if(before.type.spec.isolating||after.type.spec.isolating)return!1;if(joinMaybeClear$3(state,$cut,dispatch))return!0;let canDelAfter=$cut.parent.canReplace($cut.index(),$cut.index()+1);if(canDelAfter&&(conn=(match=before.contentMatchAt(before.childCount)).findWrapping(after.type))&&match.matchType(conn[0]||after.type).validEnd){if(dispatch){let end=$cut.pos+after.nodeSize,wrap=Fragment$3.empty;for(let i=conn.length-1;i>=0;i--)wrap=Fragment$3.from(conn[i].create(null,wrap));wrap=Fragment$3.from(before.copy(wrap));let tr=state.tr.step(new ReplaceAroundStep$3($cut.pos-1,end,$cut.pos,end,new Slice$3(wrap,1,0),conn.length,!0)),joinAt=end+2*conn.length;canJoin$3(tr.doc,joinAt)&&tr.join(joinAt),dispatch(tr.scrollIntoView())}return!0}let selAfter=Selection$3.findFrom($cut,1),range=selAfter&&selAfter.$from.blockRange(selAfter.$to),target=range&&liftTarget$3(range);if(null!=target&&target>=$cut.depth)return dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0;if(canDelAfter&&textblockAt$3(after,"start",!0)&&textblockAt$3(before,"end")){let at=before,wrap=[];for(;;){if(wrap.push(at),at.isTextblock)break;at=at.lastChild}let afterText=after,afterDepth=1;for(;!afterText.isTextblock;afterText=afterText.firstChild)afterDepth++;if(at.canReplace(at.childCount,at.childCount,afterText.content)){if(dispatch){let end=Fragment$3.empty;for(let i=wrap.length-1;i>=0;i--)end=Fragment$3.from(wrap[i].copy(end));let tr=state.tr.step(new ReplaceAroundStep$3($cut.pos-wrap.length,$cut.pos+after.nodeSize,$cut.pos+afterDepth,$cut.pos+after.nodeSize-afterDepth,new Slice$3(end,wrap.length,0),0,!0));dispatch(tr.scrollIntoView())}return!0}}return!1}function selectTextblockSide$3(side){return function(state,dispatch){let sel=state.selection,$pos=side<0?sel.$from:sel.$to,depth=$pos.depth;while($pos.node(depth).isInline){if(!depth)return!1;depth--}return!!$pos.node(depth).isTextblock&&(dispatch&&dispatch(state.tr.setSelection(TextSelection$3.create(state.doc,side<0?$pos.start(depth):$pos.end(depth)))),!0)}}
/**
Moves the cursor to the start of current text block.
*/const selectTextblockStart$1$3=selectTextblockSide$3(-1),selectTextblockEnd$1$3=selectTextblockSide$3(1);
/**
Moves the cursor to the end of current text block.
*/
// Parameterized commands
/**
Wrap the selection in a node of the given type with the given
attributes.
*/
function wrapIn$1$3(nodeType,attrs=null){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to),wrapping=range&&findWrapping$3(range,nodeType,attrs);return!!wrapping&&(dispatch&&dispatch(state.tr.wrap(range,wrapping).scrollIntoView()),!0)}}
/**
Returns a command that tries to set the selected textblocks to the
given node type with the given attributes.
*/function setBlockType$4(nodeType,attrs=null){return function(state,dispatch){let{from:from,to:to}=state.selection,applicable=!1;return state.doc.nodesBetween(from,to,((node,pos)=>{if(applicable)return!1;if(node.isTextblock&&!node.hasMarkup(nodeType,attrs))if(node.type==nodeType)applicable=!0;else{let $pos=state.doc.resolve(pos),index=$pos.index();applicable=$pos.parent.canReplaceWith(index,index+1,nodeType)}})),!!applicable&&(dispatch&&dispatch(state.tr.setBlockType(from,to,nodeType,attrs).scrollIntoView()),!0)}}
/**
Returns a command function that wraps the selection in a list with
the given type an attributes. If `dispatch` is null, only return a
value to indicate whether this is possible, but don't actually
perform the change.
*/
function wrapInList$1$3(listType,attrs=null){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to),doJoin=!1,outerRange=range;if(!range)return!1;
// This is at the top of an existing list item
if(range.depth>=2&&$from.node(range.depth-1).type.compatibleContent(listType)&&0==range.startIndex){
// Don't do anything if this is the top of the list
if(0==$from.index(range.depth-1))return!1;let $insert=state.doc.resolve(range.start-2);outerRange=new NodeRange$3($insert,$insert,range.depth),range.endIndex<range.parent.childCount&&(range=new NodeRange$3($from,state.doc.resolve($to.end(range.depth)),range.depth)),doJoin=!0}let wrap=findWrapping$3(outerRange,listType,attrs,range);return!!wrap&&(dispatch&&dispatch(doWrapInList$3(state.tr,range,wrap,doJoin,listType).scrollIntoView()),!0)}}function doWrapInList$3(tr,range,wrappers,joinBefore,listType){let content=Fragment$3.empty;for(let i=wrappers.length-1;i>=0;i--)content=Fragment$3.from(wrappers[i].type.create(wrappers[i].attrs,content));tr.step(new ReplaceAroundStep$3(range.start-(joinBefore?2:0),range.end,range.start,range.end,new Slice$3(content,0,0),wrappers.length,!0));let found=0;for(let i=0;i<wrappers.length;i++)wrappers[i].type==listType&&(found=i+1);let splitDepth=wrappers.length-found,splitPos=range.start+wrappers.length-(joinBefore?2:0),parent=range.parent;for(let i=range.startIndex,e=range.endIndex,first=!0;i<e;i++,first=!1)!first&&canSplit$3(tr.doc,splitPos,splitDepth)&&(tr.split(splitPos,splitDepth),splitPos+=2*splitDepth),splitPos+=parent.child(i).nodeSize;return tr}
/**
Create a command to lift the list item around the selection up into
a wrapping list.
*/function liftListItem$1$3(itemType){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to,(node=>node.childCount>0&&node.firstChild.type==itemType));return!!range&&(!dispatch||($from.node(range.depth-1).type==itemType?liftToOuterList$3(state,dispatch,itemType,range):liftOutOfList$3(state,dispatch,range)))}}function liftToOuterList$3(state,dispatch,itemType,range){let tr=state.tr,end=range.end,endOfList=range.$to.end(range.depth);return end<endOfList&&(
// There are siblings after the lifted items, which must become
// children of the last item
tr.step(new ReplaceAroundStep$3(end-1,endOfList,end,endOfList,new Slice$3(Fragment$3.from(itemType.create(null,range.parent.copy())),1,0),1,!0)),range=new NodeRange$3(tr.doc.resolve(range.$from.pos),tr.doc.resolve(endOfList),range.depth)),dispatch(tr.lift(range,liftTarget$3(range)).scrollIntoView()),!0}function liftOutOfList$3(state,dispatch,range){let tr=state.tr,list=range.parent;
// Merge the list items into a single big item
for(let pos=range.end,i=range.endIndex-1,e=range.startIndex;i>e;i--)pos-=list.child(i).nodeSize,tr.delete(pos-1,pos+1);let $start=tr.doc.resolve(range.start),item=$start.nodeAfter;if(tr.mapping.map(range.end)!=range.start+$start.nodeAfter.nodeSize)return!1;let atStart=0==range.startIndex,atEnd=range.endIndex==list.childCount,parent=$start.node(-1),indexBefore=$start.index(-1);if(!parent.canReplace(indexBefore+(atStart?0:1),indexBefore+1,item.content.append(atEnd?Fragment$3.empty:Fragment$3.from(list))))return!1;let start=$start.pos,end=start+item.nodeSize;
// Strip off the surrounding list. At the sides where we're not at
// the end of the list, the existing list is closed. At sides where
// this is the end, it is overwritten to its end.
return tr.step(new ReplaceAroundStep$3(start-(atStart?1:0),end+(atEnd?1:0),start+1,end-1,new Slice$3((atStart?Fragment$3.empty:Fragment$3.from(list.copy(Fragment$3.empty))).append(atEnd?Fragment$3.empty:Fragment$3.from(list.copy(Fragment$3.empty))),atStart?0:1,atEnd?0:1),atStart?0:1)),dispatch(tr.scrollIntoView()),!0}
/**
Create a command to sink the list item around the selection down
into an inner list.
*/function sinkListItem$1$3(itemType){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to,(node=>node.childCount>0&&node.firstChild.type==itemType));if(!range)return!1;let startIndex=range.startIndex;if(0==startIndex)return!1;let parent=range.parent,nodeBefore=parent.child(startIndex-1);if(nodeBefore.type!=itemType)return!1;if(dispatch){let nestedBefore=nodeBefore.lastChild&&nodeBefore.lastChild.type==parent.type,inner=Fragment$3.from(nestedBefore?itemType.create():null),slice=new Slice$3(Fragment$3.from(itemType.create(null,Fragment$3.from(parent.type.create(null,inner)))),nestedBefore?3:1,0),before=range.start,after=range.end;dispatch(state.tr.step(new ReplaceAroundStep$3(before-(nestedBefore?3:1),after,before,after,slice,1,!0)).scrollIntoView())}return!0}}function createChainableState$3(config){const{state:state,transaction:transaction}=config;let{selection:selection}=transaction,{doc:doc}=transaction,{storedMarks:storedMarks}=transaction;return{...state,apply:state.apply.bind(state),applyTransaction:state.applyTransaction.bind(state),filterTransaction:state.filterTransaction,plugins:state.plugins,schema:state.schema,reconfigure:state.reconfigure.bind(state),toJSON:state.toJSON.bind(state),get storedMarks(){return storedMarks},get selection(){return selection},get doc(){return doc},get tr(){return selection=transaction.selection,doc=transaction.doc,storedMarks=transaction.storedMarks,transaction}}}"undefined"!=typeof navigator?/Mac|iP(hone|[oa]d)/.test(navigator.platform):"undefined"!=typeof os&&os.platform&&os.platform();class CommandManager$3{constructor(props){this.editor=props.editor,this.rawCommands=this.editor.extensionManager.commands,this.customState=props.state}get hasCustomState(){return!!this.customState}get state(){return this.customState||this.editor.state}get commands(){const{rawCommands:rawCommands,editor:editor,state:state}=this,{view:view}=editor,{tr:tr}=state,props=this.buildProps(tr);return Object.fromEntries(Object.entries(rawCommands).map((([name,command])=>{const method=(...args)=>{const callback=command(...args)(props);return tr.getMeta("preventDispatch")||this.hasCustomState||view.dispatch(tr),callback};return[name,method]})))}get chain(){return()=>this.createChain()}get can(){return()=>this.createCan()}createChain(startTr,shouldDispatch=!0){const{rawCommands:rawCommands,editor:editor,state:state}=this,{view:view}=editor,callbacks=[],hasStartTransaction=!!startTr,tr=startTr||state.tr,run=()=>(hasStartTransaction||!shouldDispatch||tr.getMeta("preventDispatch")||this.hasCustomState||view.dispatch(tr),callbacks.every((callback=>!0===callback))),chain={...Object.fromEntries(Object.entries(rawCommands).map((([name,command])=>{const chainedCommand=(...args)=>{const props=this.buildProps(tr,shouldDispatch),callback=command(...args)(props);return callbacks.push(callback),chain};return[name,chainedCommand]}))),run:run};return chain}createCan(startTr){const{rawCommands:rawCommands,state:state}=this,dispatch=!1,tr=startTr||state.tr,props=this.buildProps(tr,dispatch),formattedCommands=Object.fromEntries(Object.entries(rawCommands).map((([name,command])=>[name,(...args)=>command(...args)({...props,dispatch:void 0})])));return{...formattedCommands,chain:()=>this.createChain(tr,dispatch)}}buildProps(tr,shouldDispatch=!0){const{rawCommands:rawCommands,editor:editor,state:state}=this,{view:view}=editor;state.storedMarks&&tr.setStoredMarks(state.storedMarks);const props={tr:tr,editor:editor,view:view,state:createChainableState$3({state:state,transaction:tr}),dispatch:shouldDispatch?()=>{}:void 0,chain:()=>this.createChain(tr),can:()=>this.createCan(tr),get commands(){return Object.fromEntries(Object.entries(rawCommands).map((([name,command])=>[name,(...args)=>command(...args)(props)])))}};return props}}function getExtensionField$3(extension,field,context){if(void 0===extension.config[field]&&extension.parent)return getExtensionField$3(extension.parent,field,context);if("function"===typeof extension.config[field]){const value=extension.config[field].bind({...context,parent:extension.parent?getExtensionField$3(extension.parent,field,context):null});return value}return extension.config[field]}function splitExtensions$3(extensions){const baseExtensions=extensions.filter((extension=>"extension"===extension.type)),nodeExtensions=extensions.filter((extension=>"node"===extension.type)),markExtensions=extensions.filter((extension=>"mark"===extension.type));return{baseExtensions:baseExtensions,nodeExtensions:nodeExtensions,markExtensions:markExtensions}}function getNodeType$3(nameOrType,schema){if("string"===typeof nameOrType){if(!schema.nodes[nameOrType])throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);return schema.nodes[nameOrType]}return nameOrType}function mergeAttributes$3(...objects){return objects.filter((item=>!!item)).reduce(((items,item)=>{const mergedAttributes={...items};return Object.entries(item).forEach((([key,value])=>{const exists=mergedAttributes[key];mergedAttributes[key]=exists?"class"===key?[mergedAttributes[key],value].join(" "):"style"===key?[mergedAttributes[key],value].join("; "):value:value})),mergedAttributes}),{})}function isFunction$2$3(value){return"function"===typeof value}
/**
 * Optionally calls `value` as a function.
 * Otherwise it is returned directly.
 * @param value Function or any value.
 * @param context Optional context to bind to function.
 * @param props Optional props to pass to function.
 */function callOrReturn$3(value,context=void 0,...props){return isFunction$2$3(value)?context?value.bind(context)(...props):value(...props):value}function isRegExp$3(value){return"[object RegExp]"===Object.prototype.toString.call(value)}class InputRule$3{constructor(config){this.find=config.find,this.handler=config.handler}}class PasteRule$3{constructor(config){this.find=config.find,this.handler=config.handler}}
// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts
function getType$3(value){return Object.prototype.toString.call(value).slice(8,-1)}function isPlainObject$3(value){return"Object"===getType$3(value)&&(value.constructor===Object&&Object.getPrototypeOf(value)===Object.prototype)}function mergeDeep$3(target,source){const output={...target};return isPlainObject$3(target)&&isPlainObject$3(source)&&Object.keys(source).forEach((key=>{isPlainObject$3(source[key])?key in target?output[key]=mergeDeep$3(target[key],source[key]):Object.assign(output,{[key]:source[key]}):Object.assign(output,{[key]:source[key]})})),output}class Extension$3{constructor(config={}){this.type="extension",this.name="extension",this.parent=null,this.child=null,this.config={name:this.name,defaultOptions:{}},this.config={...this.config,...config},this.name=this.config.name,config.defaultOptions,
// TODO: remove `addOptions` fallback
this.options=this.config.defaultOptions,this.config.addOptions&&(this.options=callOrReturn$3(getExtensionField$3(this,"addOptions",{name:this.name}))),this.storage=callOrReturn$3(getExtensionField$3(this,"addStorage",{name:this.name,options:this.options}))||{}}static create(config={}){return new Extension$3(config)}configure(options={}){
// return a new instance so we can use the same extension
// with different calls of `configure`
const extension=this.extend();return extension.options=mergeDeep$3(this.options,options),extension.storage=callOrReturn$3(getExtensionField$3(extension,"addStorage",{name:extension.name,options:extension.options})),extension}extend(extendedConfig={}){const extension=new Extension$3(extendedConfig);return extension.parent=this,this.child=extension,extension.name=extendedConfig.name?extendedConfig.name:extension.parent.name,extendedConfig.defaultOptions,extension.options=callOrReturn$3(getExtensionField$3(extension,"addOptions",{name:extension.name})),extension.storage=callOrReturn$3(getExtensionField$3(extension,"addStorage",{name:extension.name,options:extension.options})),extension}}function getTextBetween$3(startNode,range,options){const{from:from,to:to}=range,{blockSeparator:blockSeparator="\n\n",textSerializers:textSerializers={}}=options||{};let text="",separated=!0;return startNode.nodesBetween(from,to,((node,pos,parent,index)=>{var _a;const textSerializer=null===textSerializers||void 0===textSerializers?void 0:textSerializers[node.type.name];textSerializer?(node.isBlock&&!separated&&(text+=blockSeparator,separated=!0),parent&&(text+=textSerializer({node:node,pos:pos,parent:parent,index:index,range:range}))):node.isText?(text+=null===(_a=null===node||void 0===node?void 0:node.text)||void 0===_a?void 0:_a.slice(Math.max(from,pos)-pos,to-pos),// eslint-disable-line
separated=!1):node.isBlock&&!separated&&(text+=blockSeparator,separated=!0)})),text}function getTextSerializersFromSchema$3(schema){return Object.fromEntries(Object.entries(schema.nodes).filter((([,node])=>node.spec.toText)).map((([name,node])=>[name,node.spec.toText])))}Extension$3.create({name:"clipboardTextSerializer",addProseMirrorPlugins(){return[new Plugin$3({key:new PluginKey$3("clipboardTextSerializer"),props:{clipboardTextSerializer:()=>{const{editor:editor}=this,{state:state,schema:schema}=editor,{doc:doc,selection:selection}=state,{ranges:ranges}=selection,from=Math.min(...ranges.map((range=>range.$from.pos))),to=Math.max(...ranges.map((range=>range.$to.pos))),textSerializers=getTextSerializersFromSchema$3(schema),range={from:from,to:to};return getTextBetween$3(doc,range,{textSerializers:textSerializers})}}})]}});const blur$3=()=>({editor:editor,view:view})=>(requestAnimationFrame((()=>{var _a;editor.isDestroyed||(view.dom.blur(),
// Browsers should remove the caret on blur but safari does not.
// See: https://github.com/ueberdosis/tiptap/issues/2405
null===(_a=null===window||void 0===window?void 0:window.getSelection())||void 0===_a||_a.removeAllRanges())})),!0),clearContent$3=(emitUpdate=!1)=>({commands:commands})=>commands.setContent("",emitUpdate),clearNodes$3=()=>({state:state,tr:tr,dispatch:dispatch})=>{const{selection:selection}=tr,{ranges:ranges}=selection;return!dispatch||(ranges.forEach((({$from:$from,$to:$to})=>{state.doc.nodesBetween($from.pos,$to.pos,((node,pos)=>{if(node.type.isText)return;const{doc:doc,mapping:mapping}=tr,$mappedFrom=doc.resolve(mapping.map(pos)),$mappedTo=doc.resolve(mapping.map(pos+node.nodeSize)),nodeRange=$mappedFrom.blockRange($mappedTo);if(!nodeRange)return;const targetLiftDepth=liftTarget$3(nodeRange);if(node.type.isTextblock){const{defaultType:defaultType}=$mappedFrom.parent.contentMatchAt($mappedFrom.index());tr.setNodeMarkup(nodeRange.start,defaultType)}(targetLiftDepth||0===targetLiftDepth)&&tr.lift(nodeRange,targetLiftDepth)}))})),!0)},command$3=fn=>props=>fn(props),createParagraphNear$4=()=>({state:state,dispatch:dispatch})=>createParagraphNear$1$3(state,dispatch),deleteNode$3=typeOrName=>({tr:tr,state:state,dispatch:dispatch})=>{const type=getNodeType$3(typeOrName,state.schema),$pos=tr.selection.$anchor;for(let depth=$pos.depth;depth>0;depth-=1){const node=$pos.node(depth);if(node.type===type){if(dispatch){const from=$pos.before(depth),to=$pos.after(depth);tr.delete(from,to).scrollIntoView()}return!0}}return!1},deleteRange$4=range=>({tr:tr,dispatch:dispatch})=>{const{from:from,to:to}=range;return dispatch&&tr.delete(from,to),!0},deleteSelection$4=()=>({state:state,dispatch:dispatch})=>deleteSelection$1$3(state,dispatch),enter$3=()=>({commands:commands})=>commands.keyboardShortcut("Enter"),exitCode$4=()=>({state:state,dispatch:dispatch})=>exitCode$1$3(state,dispatch)
/**
 * Check if object1 includes object2
 * @param object1 Object
 * @param object2 Object
 */;function objectIncludes$3(object1,object2,options={strict:!0}){const keys=Object.keys(object2);return!keys.length||keys.every((key=>options.strict?object2[key]===object1[key]:isRegExp$3(object2[key])?object2[key].test(object1[key]):object2[key]===object1[key]))}function findMarkInSet$3(marks,type,attributes={}){return marks.find((item=>item.type===type&&objectIncludes$3(item.attrs,attributes)))}function isMarkInSet$3(marks,type,attributes={}){return!!findMarkInSet$3(marks,type,attributes)}function getMarkRange$3($pos,type,attributes={}){if(!$pos||!type)return;let start=$pos.parent.childAfter($pos.parentOffset);if($pos.parentOffset===start.offset&&0!==start.offset&&(start=$pos.parent.childBefore($pos.parentOffset)),!start.node)return;const mark=findMarkInSet$3([...start.node.marks],type,attributes);if(!mark)return;let startIndex=start.index,startPos=$pos.start()+start.offset,endIndex=startIndex+1,endPos=startPos+start.node.nodeSize;findMarkInSet$3([...start.node.marks],type,attributes);while(startIndex>0&&mark.isInSet($pos.parent.child(startIndex-1).marks))startIndex-=1,startPos-=$pos.parent.child(startIndex).nodeSize;while(endIndex<$pos.parent.childCount&&isMarkInSet$3([...$pos.parent.child(endIndex).marks],type,attributes))endPos+=$pos.parent.child(endIndex).nodeSize,endIndex+=1;return{from:startPos,to:endPos}}function getMarkType$3(nameOrType,schema){if("string"===typeof nameOrType){if(!schema.marks[nameOrType])throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);return schema.marks[nameOrType]}return nameOrType}const extendMarkRange$3=(typeOrName,attributes={})=>({tr:tr,state:state,dispatch:dispatch})=>{const type=getMarkType$3(typeOrName,state.schema),{doc:doc,selection:selection}=tr,{$from:$from,from:from,to:to}=selection;if(dispatch){const range=getMarkRange$3($from,type,attributes);if(range&&range.from<=from&&range.to>=to){const newSelection=TextSelection$3.create(doc,range.from,range.to);tr.setSelection(newSelection)}}return!0},first$3=commands=>props=>{const items="function"===typeof commands?commands(props):commands;for(let i=0;i<items.length;i+=1)if(items[i](props))return!0;return!1};function isTextSelection$3(value){return value instanceof TextSelection$3}function minMax$3(value=0,min=0,max=0){return Math.min(Math.max(value,min),max)}function resolveFocusPosition$3(doc,position=null){if(!position)return null;const selectionAtStart=Selection$3.atStart(doc),selectionAtEnd=Selection$3.atEnd(doc);if("start"===position||!0===position)return selectionAtStart;if("end"===position)return selectionAtEnd;const minPos=selectionAtStart.from,maxPos=selectionAtEnd.to;return"all"===position?TextSelection$3.create(doc,minMax$3(0,minPos,maxPos),minMax$3(doc.content.size,minPos,maxPos)):TextSelection$3.create(doc,minMax$3(position,minPos,maxPos),minMax$3(position,minPos,maxPos))}function isiOS$3(){return["iPad Simulator","iPhone Simulator","iPod Simulator","iPad","iPhone","iPod"].includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document}const focus$3=(position=null,options={})=>({editor:editor,view:view,tr:tr,dispatch:dispatch})=>{options={scrollIntoView:!0,...options};const delayedFocus=()=>{
// focus within `requestAnimationFrame` breaks focus on iOS
// so we have to call this
isiOS$3()&&view.dom.focus(),
// For React we have to focus asynchronously. Otherwise wild things happen.
// see: https://github.com/ueberdosis/tiptap/issues/1520
requestAnimationFrame((()=>{editor.isDestroyed||(view.focus(),(null===options||void 0===options?void 0:options.scrollIntoView)&&editor.commands.scrollIntoView())}))};if(view.hasFocus()&&null===position||!1===position)return!0;
// we don’t try to resolve a NodeSelection or CellSelection
if(dispatch&&null===position&&!isTextSelection$3(editor.state.selection))return delayedFocus(),!0;
// pass through tr.doc instead of editor.state.doc
// since transactions could change the editors state before this command has been run
const selection=resolveFocusPosition$3(tr.doc,position)||editor.state.selection,isSameSelection=editor.state.selection.eq(selection);return dispatch&&(isSameSelection||tr.setSelection(selection),
// `tr.setSelection` resets the stored marks
// so we’ll restore them if the selection is the same as before
isSameSelection&&tr.storedMarks&&tr.setStoredMarks(tr.storedMarks),delayedFocus()),!0},forEach$3=(items,fn)=>props=>items.every(((item,index)=>fn(item,{...props,index:index}))),insertContent$3=(value,options)=>({tr:tr,commands:commands})=>commands.insertContentAt({from:tr.selection.from,to:tr.selection.to},value,options);function elementFromString$3(value){
// add a wrapper to preserve leading and trailing whitespace
const wrappedValue=`<body>${value}</body>`;return(new window.DOMParser).parseFromString(wrappedValue,"text/html").body}function createNodeFromContent$3(content,schema,options){if(options={slice:!0,parseOptions:{},...options},"object"===typeof content&&null!==content)try{return Array.isArray(content)?Fragment$3.fromArray(content.map((item=>schema.nodeFromJSON(item)))):schema.nodeFromJSON(content)}catch(error){return createNodeFromContent$3("",schema,options)}if("string"===typeof content){const parser=DOMParser$1$3.fromSchema(schema);return options.slice?parser.parseSlice(elementFromString$3(content),options.parseOptions).content:parser.parse(elementFromString$3(content),options.parseOptions)}return createNodeFromContent$3("",schema,options)}
// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466
function selectionToInsertionEnd$4(tr,startLen,bias){const last=tr.steps.length-1;if(last<startLen)return;const step=tr.steps[last];if(!(step instanceof ReplaceStep$3||step instanceof ReplaceAroundStep$3))return;const map=tr.mapping.maps[last];let end=0;map.forEach(((_from,_to,_newFrom,newTo)=>{0===end&&(end=newTo)})),tr.setSelection(Selection$3.near(tr.doc.resolve(end),bias))}const isFragment$3=nodeOrFragment=>nodeOrFragment.toString().startsWith("<"),insertContentAt$3=(position,value,options)=>({tr:tr,dispatch:dispatch,editor:editor})=>{if(dispatch){options={parseOptions:{},updateSelection:!0,...options};const content=createNodeFromContent$3(value,editor.schema,{parseOptions:{preserveWhitespace:"full",...options.parseOptions}});
// don’t dispatch an empty fragment because this can lead to strange errors
if("<>"===content.toString())return!0;let{from:from,to:to}="number"===typeof position?{from:position,to:position}:position,isOnlyTextContent=!0,isOnlyBlockContent=!0;const nodes=isFragment$3(content)?content:[content];
// check if we can replace the wrapping node by
// the newly inserted content
// example:
// replace an empty paragraph by an inserted image
// instead of inserting the image below the paragraph
if(nodes.forEach((node=>{
// check if added node is valid
node.check(),isOnlyTextContent=!!isOnlyTextContent&&(node.isText&&0===node.marks.length),isOnlyBlockContent=!!isOnlyBlockContent&&node.isBlock})),from===to&&isOnlyBlockContent){const{parent:parent}=tr.doc.resolve(from),isEmptyTextBlock=parent.isTextblock&&!parent.type.spec.code&&!parent.childCount;isEmptyTextBlock&&(from-=1,to+=1)}
// if there is only plain text we have to use `insertText`
// because this will keep the current marks
isOnlyTextContent?tr.insertText(value,from,to):tr.replaceWith(from,to,content),
// set cursor at end of inserted content
options.updateSelection&&selectionToInsertionEnd$4(tr,tr.steps.length-1,-1)}return!0},joinBackward$4=()=>({state:state,dispatch:dispatch})=>joinBackward$1$3(state,dispatch),joinForward$4=()=>({state:state,dispatch:dispatch})=>joinForward$1$3(state,dispatch);function isMacOS$3(){return"undefined"!==typeof navigator&&/Mac/.test(navigator.platform)}function normalizeKeyName$4(name){const parts=name.split(/-(?!$)/);let alt,ctrl,shift,meta,result=parts[parts.length-1];"Space"===result&&(result=" ");for(let i=0;i<parts.length-1;i+=1){const mod=parts[i];if(/^(cmd|meta|m)$/i.test(mod))meta=!0;else if(/^a(lt)?$/i.test(mod))alt=!0;else if(/^(c|ctrl|control)$/i.test(mod))ctrl=!0;else if(/^s(hift)?$/i.test(mod))shift=!0;else{if(!/^mod$/i.test(mod))throw new Error(`Unrecognized modifier name: ${mod}`);isiOS$3()||isMacOS$3()?meta=!0:ctrl=!0}}return alt&&(result=`Alt-${result}`),ctrl&&(result=`Ctrl-${result}`),meta&&(result=`Meta-${result}`),shift&&(result=`Shift-${result}`),result}const keyboardShortcut$3=name=>({editor:editor,view:view,tr:tr,dispatch:dispatch})=>{const keys=normalizeKeyName$4(name).split(/-(?!$)/),key=keys.find((item=>!["Alt","Ctrl","Meta","Shift"].includes(item))),event=new KeyboardEvent("keydown",{key:"Space"===key?" ":key,altKey:keys.includes("Alt"),ctrlKey:keys.includes("Ctrl"),metaKey:keys.includes("Meta"),shiftKey:keys.includes("Shift"),bubbles:!0,cancelable:!0}),capturedTransaction=editor.captureTransaction((()=>{view.someProp("handleKeyDown",(f=>f(view,event)))}));return null===capturedTransaction||void 0===capturedTransaction||capturedTransaction.steps.forEach((step=>{const newStep=step.map(tr.mapping);newStep&&dispatch&&tr.maybeStep(newStep)})),!0};function isNodeActive$3(state,typeOrName,attributes={}){const{from:from,to:to,empty:empty}=state.selection,type=typeOrName?getNodeType$3(typeOrName,state.schema):null,nodeRanges=[];state.doc.nodesBetween(from,to,((node,pos)=>{if(node.isText)return;const relativeFrom=Math.max(from,pos),relativeTo=Math.min(to,pos+node.nodeSize);nodeRanges.push({node:node,from:relativeFrom,to:relativeTo})}));const selectionRange=to-from,matchedNodeRanges=nodeRanges.filter((nodeRange=>!type||type.name===nodeRange.node.type.name)).filter((nodeRange=>objectIncludes$3(nodeRange.node.attrs,attributes,{strict:!1})));if(empty)return!!matchedNodeRanges.length;const range=matchedNodeRanges.reduce(((sum,nodeRange)=>sum+nodeRange.to-nodeRange.from),0);return range>=selectionRange}const lift$5=(typeOrName,attributes={})=>({state:state,dispatch:dispatch})=>{const type=getNodeType$3(typeOrName,state.schema),isActive=isNodeActive$3(state,type,attributes);return!!isActive&&lift$1$3(state,dispatch)},liftEmptyBlock$4=()=>({state:state,dispatch:dispatch})=>liftEmptyBlock$1$3(state,dispatch),liftListItem$4=typeOrName=>({state:state,dispatch:dispatch})=>{const type=getNodeType$3(typeOrName,state.schema);return liftListItem$1$3(type)(state,dispatch)},newlineInCode$4=()=>({state:state,dispatch:dispatch})=>newlineInCode$1$3(state,dispatch);function getSchemaTypeNameByName$3(name,schema){return schema.nodes[name]?"node":schema.marks[name]?"mark":null}
/**
 * Remove a property or an array of properties from an object
 * @param obj Object
 * @param key Key to remove
 */function deleteProps$3(obj,propOrProps){const props="string"===typeof propOrProps?[propOrProps]:propOrProps;return Object.keys(obj).reduce(((newObj,prop)=>(props.includes(prop)||(newObj[prop]=obj[prop]),newObj)),{})}const resetAttributes$3=(typeOrName,attributes)=>({tr:tr,state:state,dispatch:dispatch})=>{let nodeType=null,markType=null;const schemaType=getSchemaTypeNameByName$3("string"===typeof typeOrName?typeOrName:typeOrName.name,state.schema);return!!schemaType&&("node"===schemaType&&(nodeType=getNodeType$3(typeOrName,state.schema)),"mark"===schemaType&&(markType=getMarkType$3(typeOrName,state.schema)),dispatch&&tr.selection.ranges.forEach((range=>{state.doc.nodesBetween(range.$from.pos,range.$to.pos,((node,pos)=>{nodeType&&nodeType===node.type&&tr.setNodeMarkup(pos,void 0,deleteProps$3(node.attrs,attributes)),markType&&node.marks.length&&node.marks.forEach((mark=>{markType===mark.type&&tr.addMark(pos,pos+node.nodeSize,markType.create(deleteProps$3(mark.attrs,attributes)))}))}))})),!0)},scrollIntoView$3=()=>({tr:tr,dispatch:dispatch})=>(dispatch&&tr.scrollIntoView(),!0),selectAll$3=()=>({tr:tr,commands:commands})=>commands.setTextSelection({from:0,to:tr.doc.content.size}),selectNodeBackward$4=()=>({state:state,dispatch:dispatch})=>selectNodeBackward$1$3(state,dispatch),selectNodeForward$4=()=>({state:state,dispatch:dispatch})=>selectNodeForward$1$3(state,dispatch),selectParentNode$4=()=>({state:state,dispatch:dispatch})=>selectParentNode$1$3(state,dispatch)
// @ts-ignore
,selectTextblockEnd$4=()=>({state:state,dispatch:dispatch})=>selectTextblockEnd$1$3(state,dispatch)
// @ts-ignore
,selectTextblockStart$4=()=>({state:state,dispatch:dispatch})=>selectTextblockStart$1$3(state,dispatch);function createDocument$3(content,schema,parseOptions={}){return createNodeFromContent$3(content,schema,{slice:!1,parseOptions:parseOptions})}const setContent$1$3=(content,emitUpdate=!1,parseOptions={})=>({tr:tr,editor:editor,dispatch:dispatch})=>{const{doc:doc}=tr,document=createDocument$3(content,editor.schema,parseOptions);return dispatch&&tr.replaceWith(0,doc.content.size,document).setMeta("preventUpdate",!emitUpdate),!0};function getMarkAttributes$3(state,typeOrName){const type=getMarkType$3(typeOrName,state.schema),{from:from,to:to,empty:empty}=state.selection,marks=[];empty?(state.storedMarks&&marks.push(...state.storedMarks),marks.push(...state.selection.$head.marks())):state.doc.nodesBetween(from,to,(node=>{marks.push(...node.marks)}));const mark=marks.find((markItem=>markItem.type.name===type.name));return mark?{...mark.attrs}:{}}const setMark$3=(typeOrName,attributes={})=>({tr:tr,state:state,dispatch:dispatch})=>{const{selection:selection}=tr,{empty:empty,ranges:ranges}=selection,type=getMarkType$3(typeOrName,state.schema);if(dispatch)if(empty){const oldAttributes=getMarkAttributes$3(state,type);tr.addStoredMark(type.create({...oldAttributes,...attributes}))}else ranges.forEach((range=>{const from=range.$from.pos,to=range.$to.pos;state.doc.nodesBetween(from,to,((node,pos)=>{const trimmedFrom=Math.max(pos,from),trimmedTo=Math.min(pos+node.nodeSize,to),someHasMark=node.marks.find((mark=>mark.type===type));
// if there is already a mark of this type
// we know that we have to merge its attributes
// otherwise we add a fresh new mark
someHasMark?node.marks.forEach((mark=>{type===mark.type&&tr.addMark(trimmedFrom,trimmedTo,type.create({...mark.attrs,...attributes}))})):tr.addMark(trimmedFrom,trimmedTo,type.create(attributes))}))}));return!0},setMeta$3=(key,value)=>({tr:tr})=>(tr.setMeta(key,value),!0),setNode$3=(typeOrName,attributes={})=>({state:state,dispatch:dispatch,chain:chain})=>{const type=getNodeType$3(typeOrName,state.schema);
// TODO: use a fallback like insertContent?
return!!type.isTextblock&&chain().command((({commands:commands})=>{const canSetBlock=setBlockType$4(type,attributes)(state);return!!canSetBlock||commands.clearNodes()})).command((({state:updatedState})=>setBlockType$4(type,attributes)(updatedState,dispatch))).run()},setNodeSelection$3=position=>({tr:tr,dispatch:dispatch})=>{if(dispatch){const{doc:doc}=tr,from=minMax$3(position,0,doc.content.size),selection=NodeSelection$3.create(doc,from);tr.setSelection(selection)}return!0},setTextSelection$3=position=>({tr:tr,dispatch:dispatch})=>{if(dispatch){const{doc:doc}=tr,{from:from,to:to}="number"===typeof position?{from:position,to:position}:position,minPos=TextSelection$3.atStart(doc).from,maxPos=TextSelection$3.atEnd(doc).to,resolvedFrom=minMax$3(from,minPos,maxPos),resolvedEnd=minMax$3(to,minPos,maxPos),selection=TextSelection$3.create(doc,resolvedFrom,resolvedEnd);tr.setSelection(selection)}return!0},sinkListItem$4=typeOrName=>({state:state,dispatch:dispatch})=>{const type=getNodeType$3(typeOrName,state.schema);return sinkListItem$1$3(type)(state,dispatch)};function defaultBlockAt$4(match){for(let i=0;i<match.edgeCount;i+=1){const{type:type}=match.edge(i);if(type.isTextblock&&!type.hasRequiredAttrs())return type}return null}function getSplittedAttributes$3(extensionAttributes,typeName,attributes){return Object.fromEntries(Object.entries(attributes).filter((([name])=>{const extensionAttribute=extensionAttributes.find((item=>item.type===typeName&&item.name===name));return!!extensionAttribute&&extensionAttribute.attribute.keepOnSplit})))}function ensureMarks$3(state,splittableMarks){const marks=state.storedMarks||state.selection.$to.parentOffset&&state.selection.$from.marks();if(marks){const filteredMarks=marks.filter((mark=>null===splittableMarks||void 0===splittableMarks?void 0:splittableMarks.includes(mark.type.name)));state.tr.ensureMarks(filteredMarks)}}const splitBlock$3=({keepMarks:keepMarks=!0}={})=>({tr:tr,state:state,dispatch:dispatch,editor:editor})=>{const{selection:selection,doc:doc}=tr,{$from:$from,$to:$to}=selection,extensionAttributes=editor.extensionManager.attributes,newAttributes=getSplittedAttributes$3(extensionAttributes,$from.node().type.name,$from.node().attrs);if(selection instanceof NodeSelection$3&&selection.node.isBlock)return!(!$from.parentOffset||!canSplit$3(doc,$from.pos))&&(dispatch&&(keepMarks&&ensureMarks$3(state,editor.extensionManager.splittableMarks),tr.split($from.pos).scrollIntoView()),!0);if(!$from.parent.isBlock)return!1;if(dispatch){const atEnd=$to.parentOffset===$to.parent.content.size;selection instanceof TextSelection$3&&tr.deleteSelection();const deflt=0===$from.depth?void 0:defaultBlockAt$4($from.node(-1).contentMatchAt($from.indexAfter(-1)));let types=atEnd&&deflt?[{type:deflt,attrs:newAttributes}]:void 0,can=canSplit$3(tr.doc,tr.mapping.map($from.pos),1,types);if(types||can||!canSplit$3(tr.doc,tr.mapping.map($from.pos),1,deflt?[{type:deflt}]:void 0)||(can=!0,types=deflt?[{type:deflt,attrs:newAttributes}]:void 0),can&&(tr.split(tr.mapping.map($from.pos),1,types),deflt&&!atEnd&&!$from.parentOffset&&$from.parent.type!==deflt)){const first=tr.mapping.map($from.before()),$first=tr.doc.resolve(first);$from.node(-1).canReplaceWith($first.index(),$first.index()+1,deflt)&&tr.setNodeMarkup(tr.mapping.map($from.before()),deflt)}keepMarks&&ensureMarks$3(state,editor.extensionManager.splittableMarks),tr.scrollIntoView()}return!0},splitListItem$3=typeOrName=>({tr:tr,state:state,dispatch:dispatch,editor:editor})=>{var _a;const type=getNodeType$3(typeOrName,state.schema),{$from:$from,$to:$to}=state.selection,node=state.selection.node;if(node&&node.isBlock||$from.depth<2||!$from.sameParent($to))return!1;const grandParent=$from.node(-1);if(grandParent.type!==type)return!1;const extensionAttributes=editor.extensionManager.attributes;if(0===$from.parent.content.size&&$from.node(-1).childCount===$from.indexAfter(-1)){
// In an empty block. If this is a nested list, the wrapping
// list item should be split. Otherwise, bail out and let next
// command handle lifting.
if(2===$from.depth||$from.node(-3).type!==type||$from.index(-2)!==$from.node(-2).childCount-1)return!1;if(dispatch){let wrap=Fragment$3.empty;
// eslint-disable-next-line
const depthBefore=$from.index(-1)?1:$from.index(-2)?2:3;
// Build a fragment containing empty versions of the structure
// from the outer list item to the parent node of the cursor
for(let d=$from.depth-depthBefore;d>=$from.depth-3;d-=1)wrap=Fragment$3.from($from.node(d).copy(wrap));
// eslint-disable-next-line
const depthAfter=$from.indexAfter(-1)<$from.node(-2).childCount?1:$from.indexAfter(-2)<$from.node(-3).childCount?2:3,newNextTypeAttributes=getSplittedAttributes$3(extensionAttributes,$from.node().type.name,$from.node().attrs),nextType=(null===(_a=type.contentMatch.defaultType)||void 0===_a?void 0:_a.createAndFill(newNextTypeAttributes))||void 0;
// Add a second list item with an empty default start node
wrap=wrap.append(Fragment$3.from(type.createAndFill(null,nextType)||void 0));const start=$from.before($from.depth-(depthBefore-1));tr.replace(start,$from.after(-depthAfter),new Slice$3(wrap,4-depthBefore,0));let sel=-1;tr.doc.nodesBetween(start,tr.doc.content.size,((n,pos)=>{if(sel>-1)return!1;n.isTextblock&&0===n.content.size&&(sel=pos+1)})),sel>-1&&tr.setSelection(TextSelection$3.near(tr.doc.resolve(sel))),tr.scrollIntoView()}return!0}const nextType=$to.pos===$from.end()?grandParent.contentMatchAt(0).defaultType:null,newTypeAttributes=getSplittedAttributes$3(extensionAttributes,grandParent.type.name,grandParent.attrs),newNextTypeAttributes=getSplittedAttributes$3(extensionAttributes,$from.node().type.name,$from.node().attrs);tr.delete($from.pos,$to.pos);const types=nextType?[{type:type,attrs:newTypeAttributes},{type:nextType,attrs:newNextTypeAttributes}]:[{type:type,attrs:newTypeAttributes}];return!!canSplit$3(tr.doc,$from.pos,2)&&(dispatch&&tr.split($from.pos,2,types).scrollIntoView(),!0)};function findParentNodeClosestToPos$3($pos,predicate){for(let i=$pos.depth;i>0;i-=1){const node=$pos.node(i);if(predicate(node))return{pos:i>0?$pos.before(i):0,start:$pos.start(i),depth:i,node:node}}}function findParentNode$3(predicate){return selection=>findParentNodeClosestToPos$3(selection.$from,predicate)}function isList$3(name,extensions){const{nodeExtensions:nodeExtensions}=splitExtensions$3(extensions),extension=nodeExtensions.find((item=>item.name===name));if(!extension)return!1;const context={name:extension.name,options:extension.options,storage:extension.storage},group=callOrReturn$3(getExtensionField$3(extension,"group",context));return"string"===typeof group&&group.split(" ").includes("list")}const joinListBackwards$3=(tr,listType)=>{const list=findParentNode$3((node=>node.type===listType))(tr.selection);if(!list)return!0;const before=tr.doc.resolve(Math.max(0,list.pos-1)).before(list.depth);if(void 0===before)return!0;const nodeBefore=tr.doc.nodeAt(before),canJoinBackwards=list.node.type===(null===nodeBefore||void 0===nodeBefore?void 0:nodeBefore.type)&&canJoin$3(tr.doc,list.pos);return!canJoinBackwards||(tr.join(list.pos),!0)},joinListForwards$3=(tr,listType)=>{const list=findParentNode$3((node=>node.type===listType))(tr.selection);if(!list)return!0;const after=tr.doc.resolve(list.start).after(list.depth);if(void 0===after)return!0;const nodeAfter=tr.doc.nodeAt(after),canJoinForwards=list.node.type===(null===nodeAfter||void 0===nodeAfter?void 0:nodeAfter.type)&&canJoin$3(tr.doc,after);return!canJoinForwards||(tr.join(after),!0)},toggleList$3=(listTypeOrName,itemTypeOrName)=>({editor:editor,tr:tr,state:state,dispatch:dispatch,chain:chain,commands:commands,can:can})=>{const{extensions:extensions}=editor.extensionManager,listType=getNodeType$3(listTypeOrName,state.schema),itemType=getNodeType$3(itemTypeOrName,state.schema),{selection:selection}=state,{$from:$from,$to:$to}=selection,range=$from.blockRange($to);if(!range)return!1;const parentList=findParentNode$3((node=>isList$3(node.type.name,extensions)))(selection);if(range.depth>=1&&parentList&&range.depth-parentList.depth<=1){
// remove list
if(parentList.node.type===listType)return commands.liftListItem(itemType);
// change list type
if(isList$3(parentList.node.type.name,extensions)&&listType.validContent(parentList.node.content)&&dispatch)return chain().command((()=>(tr.setNodeMarkup(parentList.pos,listType),!0))).command((()=>joinListBackwards$3(tr,listType))).command((()=>joinListForwards$3(tr,listType))).run()}return chain().command((()=>{const canWrapInList=can().wrapInList(listType);return!!canWrapInList||commands.clearNodes()})).wrapInList(listType).command((()=>joinListBackwards$3(tr,listType))).command((()=>joinListForwards$3(tr,listType))).run()};function isMarkActive$3(state,typeOrName,attributes={}){const{empty:empty,ranges:ranges}=state.selection,type=typeOrName?getMarkType$3(typeOrName,state.schema):null;if(empty)return!!(state.storedMarks||state.selection.$from.marks()).filter((mark=>!type||type.name===mark.type.name)).find((mark=>objectIncludes$3(mark.attrs,attributes,{strict:!1})));let selectionRange=0;const markRanges=[];if(ranges.forEach((({$from:$from,$to:$to})=>{const from=$from.pos,to=$to.pos;state.doc.nodesBetween(from,to,((node,pos)=>{if(!node.isText&&!node.marks.length)return;const relativeFrom=Math.max(from,pos),relativeTo=Math.min(to,pos+node.nodeSize),range=relativeTo-relativeFrom;selectionRange+=range,markRanges.push(...node.marks.map((mark=>({mark:mark,from:relativeFrom,to:relativeTo}))))}))})),0===selectionRange)return!1;
// calculate range of matched mark
const matchedRange=markRanges.filter((markRange=>!type||type.name===markRange.mark.type.name)).filter((markRange=>objectIncludes$3(markRange.mark.attrs,attributes,{strict:!1}))).reduce(((sum,markRange)=>sum+markRange.to-markRange.from),0),excludedRange=markRanges.filter((markRange=>!type||markRange.mark.type!==type&&markRange.mark.type.excludes(type))).reduce(((sum,markRange)=>sum+markRange.to-markRange.from),0),range=matchedRange>0?matchedRange+excludedRange:matchedRange;
// calculate range of marks that excludes the searched mark
// for example `code` doesn’t allow any other marks
return range>=selectionRange}const toggleMark$3=(typeOrName,attributes={},options={})=>({state:state,commands:commands})=>{const{extendEmptyMarkRange:extendEmptyMarkRange=!1}=options,type=getMarkType$3(typeOrName,state.schema),isActive=isMarkActive$3(state,type,attributes);return isActive?commands.unsetMark(type,{extendEmptyMarkRange:extendEmptyMarkRange}):commands.setMark(type,attributes)},toggleNode$3=(typeOrName,toggleTypeOrName,attributes={})=>({state:state,commands:commands})=>{const type=getNodeType$3(typeOrName,state.schema),toggleType=getNodeType$3(toggleTypeOrName,state.schema),isActive=isNodeActive$3(state,type,attributes);return isActive?commands.setNode(toggleType):commands.setNode(type,attributes)},toggleWrap$3=(typeOrName,attributes={})=>({state:state,commands:commands})=>{const type=getNodeType$3(typeOrName,state.schema),isActive=isNodeActive$3(state,type,attributes);return isActive?commands.lift(type):commands.wrapIn(type,attributes)},undoInputRule$3=()=>({state:state,dispatch:dispatch})=>{const plugins=state.plugins;for(let i=0;i<plugins.length;i+=1){const plugin=plugins[i];let undoable;
// @ts-ignore
// eslint-disable-next-line
if(plugin.spec.isInputRules&&(undoable=plugin.getState(state))){if(dispatch){const tr=state.tr,toUndo=undoable.transform;for(let j=toUndo.steps.length-1;j>=0;j-=1)tr.step(toUndo.steps[j].invert(toUndo.docs[j]));if(undoable.text){const marks=tr.doc.resolve(undoable.from).marks();tr.replaceWith(undoable.from,undoable.to,state.schema.text(undoable.text,marks))}else tr.delete(undoable.from,undoable.to)}return!0}}return!1},unsetAllMarks$3=()=>({tr:tr,dispatch:dispatch})=>{const{selection:selection}=tr,{empty:empty,ranges:ranges}=selection;return empty||dispatch&&ranges.forEach((range=>{tr.removeMark(range.$from.pos,range.$to.pos)})),!0},unsetMark$3=(typeOrName,options={})=>({tr:tr,state:state,dispatch:dispatch})=>{var _a;const{extendEmptyMarkRange:extendEmptyMarkRange=!1}=options,{selection:selection}=tr,type=getMarkType$3(typeOrName,state.schema),{$from:$from,empty:empty,ranges:ranges}=selection;if(!dispatch)return!0;if(empty&&extendEmptyMarkRange){let{from:from,to:to}=selection;const attrs=null===(_a=$from.marks().find((mark=>mark.type===type)))||void 0===_a?void 0:_a.attrs,range=getMarkRange$3($from,type,attrs);range&&(from=range.from,to=range.to),tr.removeMark(from,to,type)}else ranges.forEach((range=>{tr.removeMark(range.$from.pos,range.$to.pos,type)}));return tr.removeStoredMark(type),!0},updateAttributes$3=(typeOrName,attributes={})=>({tr:tr,state:state,dispatch:dispatch})=>{let nodeType=null,markType=null;const schemaType=getSchemaTypeNameByName$3("string"===typeof typeOrName?typeOrName:typeOrName.name,state.schema);return!!schemaType&&("node"===schemaType&&(nodeType=getNodeType$3(typeOrName,state.schema)),"mark"===schemaType&&(markType=getMarkType$3(typeOrName,state.schema)),dispatch&&tr.selection.ranges.forEach((range=>{const from=range.$from.pos,to=range.$to.pos;state.doc.nodesBetween(from,to,((node,pos)=>{nodeType&&nodeType===node.type&&tr.setNodeMarkup(pos,void 0,{...node.attrs,...attributes}),markType&&node.marks.length&&node.marks.forEach((mark=>{if(markType===mark.type){const trimmedFrom=Math.max(pos,from),trimmedTo=Math.min(pos+node.nodeSize,to);tr.addMark(trimmedFrom,trimmedTo,markType.create({...mark.attrs,...attributes}))}}))}))})),!0)},wrapIn$4=(typeOrName,attributes={})=>({state:state,dispatch:dispatch})=>{const type=getNodeType$3(typeOrName,state.schema);return wrapIn$1$3(type,attributes)(state,dispatch)},wrapInList$4=(typeOrName,attributes={})=>({state:state,dispatch:dispatch})=>{const type=getNodeType$3(typeOrName,state.schema);return wrapInList$1$3(type,attributes)(state,dispatch)};var commands$3=Object.freeze({__proto__:null,blur:blur$3,clearContent:clearContent$3,clearNodes:clearNodes$3,command:command$3,createParagraphNear:createParagraphNear$4,deleteNode:deleteNode$3,deleteRange:deleteRange$4,deleteSelection:deleteSelection$4,enter:enter$3,exitCode:exitCode$4,extendMarkRange:extendMarkRange$3,first:first$3,focus:focus$3,forEach:forEach$3,insertContent:insertContent$3,insertContentAt:insertContentAt$3,joinBackward:joinBackward$4,joinForward:joinForward$4,keyboardShortcut:keyboardShortcut$3,lift:lift$5,liftEmptyBlock:liftEmptyBlock$4,liftListItem:liftListItem$4,newlineInCode:newlineInCode$4,resetAttributes:resetAttributes$3,scrollIntoView:scrollIntoView$3,selectAll:selectAll$3,selectNodeBackward:selectNodeBackward$4,selectNodeForward:selectNodeForward$4,selectParentNode:selectParentNode$4,selectTextblockEnd:selectTextblockEnd$4,selectTextblockStart:selectTextblockStart$4,setContent:setContent$1$3,setMark:setMark$3,setMeta:setMeta$3,setNode:setNode$3,setNodeSelection:setNodeSelection$3,setTextSelection:setTextSelection$3,sinkListItem:sinkListItem$4,splitBlock:splitBlock$3,splitListItem:splitListItem$3,toggleList:toggleList$3,toggleMark:toggleMark$3,toggleNode:toggleNode$3,toggleWrap:toggleWrap$3,undoInputRule:undoInputRule$3,unsetAllMarks:unsetAllMarks$3,unsetMark:unsetMark$3,updateAttributes:updateAttributes$3,wrapIn:wrapIn$4,wrapInList:wrapInList$4});function getNodeAttributes$3(state,typeOrName){const type=getNodeType$3(typeOrName,state.schema),{from:from,to:to}=state.selection,nodes=[];state.doc.nodesBetween(from,to,(node=>{nodes.push(node)}));const node=nodes.reverse().find((nodeItem=>nodeItem.type.name===type.name));return node?{...node.attrs}:{}}function getAttributes$3(state,typeOrName){const schemaType=getSchemaTypeNameByName$3("string"===typeof typeOrName?typeOrName:typeOrName.name,state.schema);return"node"===schemaType?getNodeAttributes$3(state,typeOrName):"mark"===schemaType?getMarkAttributes$3(state,typeOrName):{}}
/**
 * Returns a new `Transform` based on all steps of the passed transactions.
 */function combineTransactionSteps$3(oldDoc,transactions){const transform=new Transform$3(oldDoc);return transactions.forEach((transaction=>{transaction.steps.forEach((step=>{transform.step(step)}))})),transform}
/**
 * Same as `findChildren` but searches only within a `range`.
 */function findChildrenInRange$3(node,range,predicate){const nodesWithPos=[];
// if (range.from === range.to) {
//   const nodeAt = node.nodeAt(range.from)
//   if (nodeAt) {
//     nodesWithPos.push({
//       node: nodeAt,
//       pos: range.from,
//     })
//   }
// }
return node.nodesBetween(range.from,range.to,((child,pos)=>{predicate(child)&&nodesWithPos.push({node:child,pos:pos})})),nodesWithPos}
/**
 * Removes duplicated values within an array.
 * Supports numbers, strings and objects.
 */function removeDuplicates$3(array,by=JSON.stringify){const seen={};return array.filter((item=>{const key=by(item);return!Object.prototype.hasOwnProperty.call(seen,key)&&(seen[key]=!0)}))}
/**
 * Removes duplicated ranges and ranges that are
 * fully captured by other ranges.
 */function simplifyChangedRanges$3(changes){const uniqueChanges=removeDuplicates$3(changes);return 1===uniqueChanges.length?uniqueChanges:uniqueChanges.filter(((change,index)=>{const rest=uniqueChanges.filter(((_,i)=>i!==index));return!rest.some((otherChange=>change.oldRange.from>=otherChange.oldRange.from&&change.oldRange.to<=otherChange.oldRange.to&&change.newRange.from>=otherChange.newRange.from&&change.newRange.to<=otherChange.newRange.to))}))}
/**
 * Returns a list of changed ranges
 * based on the first and last state of all steps.
 */function getChangedRanges$3(transform){const{mapping:mapping,steps:steps}=transform,changes=[];return mapping.maps.forEach(((stepMap,index)=>{const ranges=[];
// This accounts for step changes where no range was actually altered
// e.g. when setting a mark, node attribute, etc.
// @ts-ignore
if(stepMap.ranges.length)stepMap.forEach(((from,to)=>{ranges.push({from:from,to:to})}));else{const{from:from,to:to}=steps[index];if(void 0===from||void 0===to)return;ranges.push({from:from,to:to})}ranges.forEach((({from:from,to:to})=>{const newStart=mapping.slice(index).map(from,-1),newEnd=mapping.slice(index).map(to),oldStart=mapping.invert().map(newStart,-1),oldEnd=mapping.invert().map(newEnd);changes.push({oldRange:{from:oldStart,to:oldEnd},newRange:{from:newStart,to:newEnd}})}))})),simplifyChangedRanges$3(changes)}function getMarksBetween$3(from,to,doc){const marks=[];
// get all inclusive marks on empty selection
return from===to?doc.resolve(from).marks().forEach((mark=>{const $pos=doc.resolve(from-1),range=getMarkRange$3($pos,mark.type);range&&marks.push({mark:mark,...range})})):doc.nodesBetween(from,to,((node,pos)=>{marks.push(...node.marks.map((mark=>({from:pos,to:pos+node.nodeSize,mark:mark}))))})),marks}
/**
 * Build an input rule that adds a mark when the
 * matched text is typed into it.
 */function markInputRule$3(config){return new InputRule$3({find:config.find,handler:({state:state,range:range,match:match})=>{const attributes=callOrReturn$3(config.getAttributes,void 0,match);if(!1===attributes||null===attributes)return null;const{tr:tr}=state,captureGroup=match[match.length-1],fullMatch=match[0];let markEnd=range.to;if(captureGroup){const startSpaces=fullMatch.search(/\S/),textStart=range.from+fullMatch.indexOf(captureGroup),textEnd=textStart+captureGroup.length,excludedMarks=getMarksBetween$3(range.from,range.to,state.doc).filter((item=>{
// @ts-ignore
const excluded=item.mark.type.excluded;return excluded.find((type=>type===config.type&&type!==item.mark.type))})).filter((item=>item.to>textStart));if(excludedMarks.length)return null;textEnd<range.to&&tr.delete(textEnd,range.to),textStart>range.from&&tr.delete(range.from+startSpaces,textStart),markEnd=range.from+startSpaces+captureGroup.length,tr.addMark(range.from+startSpaces,markEnd,config.type.create(attributes||{})),tr.removeStoredMark(config.type)}}})}
/**
 * Build an input rule that adds a node when the
 * matched text is typed into it.
 */function nodeInputRule$3(config){return new InputRule$3({find:config.find,handler:({state:state,range:range,match:match})=>{const attributes=callOrReturn$3(config.getAttributes,void 0,match)||{},{tr:tr}=state,start=range.from;let end=range.to;if(match[1]){const offset=match[0].lastIndexOf(match[1]);let matchStart=start+offset;matchStart>end?matchStart=end:end=matchStart+match[1].length;
// insert last typed character
const lastChar=match[0][match[0].length-1];tr.insertText(lastChar,start+match[0].length-1),
// insert node from input rule
tr.replaceWith(matchStart,end,config.type.create(attributes))}else match[0]&&tr.replaceWith(start,end,config.type.create(attributes))}})}
/**
 * Build an input rule that changes the type of a textblock when the
 * matched text is typed into it. When using a regular expresion you’ll
 * probably want the regexp to start with `^`, so that the pattern can
 * only occur at the start of a textblock.
 */function textblockTypeInputRule$3(config){return new InputRule$3({find:config.find,handler:({state:state,range:range,match:match})=>{const $start=state.doc.resolve(range.from),attributes=callOrReturn$3(config.getAttributes,void 0,match)||{};if(!$start.node(-1).canReplaceWith($start.index(-1),$start.indexAfter(-1),config.type))return null;state.tr.delete(range.from,range.to).setBlockType(range.from,range.from,config.type,attributes)}})}
/**
 * Build an input rule for automatically wrapping a textblock when a
 * given string is typed. When using a regular expresion you’ll
 * probably want the regexp to start with `^`, so that the pattern can
 * only occur at the start of a textblock.
 *
 * `type` is the type of node to wrap in.
 *
 * By default, if there’s a node with the same type above the newly
 * wrapped node, the rule will try to join those
 * two nodes. You can pass a join predicate, which takes a regular
 * expression match and the node before the wrapped node, and can
 * return a boolean to indicate whether a join should happen.
 */function wrappingInputRule$3(config){return new InputRule$3({find:config.find,handler:({state:state,range:range,match:match})=>{const attributes=callOrReturn$3(config.getAttributes,void 0,match)||{},tr=state.tr.delete(range.from,range.to),$start=tr.doc.resolve(range.from),blockRange=$start.blockRange(),wrapping=blockRange&&findWrapping$3(blockRange,config.type,attributes);if(!wrapping)return null;tr.wrap(blockRange,wrapping);const before=tr.doc.resolve(range.from-1).nodeBefore;before&&before.type===config.type&&canJoin$3(tr.doc,range.from-1)&&(!config.joinPredicate||config.joinPredicate(match,before))&&tr.join(range.from-1)}})}Extension$3.create({name:"commands",addCommands(){return{...commands$3}}}),Extension$3.create({name:"editable",addProseMirrorPlugins(){return[new Plugin$3({key:new PluginKey$3("editable"),props:{editable:()=>this.editor.options.editable}})]}}),Extension$3.create({name:"focusEvents",addProseMirrorPlugins(){const{editor:editor}=this;return[new Plugin$3({key:new PluginKey$3("focusEvents"),props:{handleDOMEvents:{focus:(view,event)=>{editor.isFocused=!0;const transaction=editor.state.tr.setMeta("focus",{event:event}).setMeta("addToHistory",!1);return view.dispatch(transaction),!1},blur:(view,event)=>{editor.isFocused=!1;const transaction=editor.state.tr.setMeta("blur",{event:event}).setMeta("addToHistory",!1);return view.dispatch(transaction),!1}}}})]}}),Extension$3.create({name:"keymap",addKeyboardShortcuts(){const handleBackspace=()=>this.editor.commands.first((({commands:commands})=>[()=>commands.undoInputRule()
// maybe convert first text block node to default node
,()=>commands.command((({tr:tr})=>{const{selection:selection,doc:doc}=tr,{empty:empty,$anchor:$anchor}=selection,{pos:pos,parent:parent}=$anchor,isAtStart=Selection$3.atStart(doc).from===pos;return!(!(empty&&isAtStart&&parent.type.isTextblock)||parent.textContent.length)&&commands.clearNodes()})),()=>commands.deleteSelection(),()=>commands.joinBackward(),()=>commands.selectNodeBackward()])),handleDelete=()=>this.editor.commands.first((({commands:commands})=>[()=>commands.deleteSelection(),()=>commands.joinForward(),()=>commands.selectNodeForward()])),handleEnter=()=>this.editor.commands.first((({commands:commands})=>[()=>commands.newlineInCode(),()=>commands.createParagraphNear(),()=>commands.liftEmptyBlock(),()=>commands.splitBlock()])),baseKeymap={Enter:handleEnter,"Mod-Enter":()=>this.editor.commands.exitCode(),Backspace:handleBackspace,"Mod-Backspace":handleBackspace,"Shift-Backspace":handleBackspace,Delete:handleDelete,"Mod-Delete":handleDelete,"Mod-a":()=>this.editor.commands.selectAll()},pcKeymap={...baseKeymap},macKeymap={...baseKeymap,"Ctrl-h":handleBackspace,"Alt-Backspace":handleBackspace,"Ctrl-d":handleDelete,"Ctrl-Alt-Backspace":handleDelete,"Alt-Delete":handleDelete,"Alt-d":handleDelete,"Ctrl-a":()=>this.editor.commands.selectTextblockStart(),"Ctrl-e":()=>this.editor.commands.selectTextblockEnd()};return isiOS$3()||isMacOS$3()?macKeymap:pcKeymap},addProseMirrorPlugins(){return[
// With this plugin we check if the whole document was selected and deleted.
// In this case we will additionally call `clearNodes()` to convert e.g. a heading
// to a paragraph if necessary.
// This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
// with many other commands.
new Plugin$3({key:new PluginKey$3("clearDocument"),appendTransaction:(transactions,oldState,newState)=>{const docChanges=transactions.some((transaction=>transaction.docChanged))&&!oldState.doc.eq(newState.doc);if(!docChanges)return;const{empty:empty,from:from,to:to}=oldState.selection,allFrom=Selection$3.atStart(oldState.doc).from,allEnd=Selection$3.atEnd(oldState.doc).to,allWasSelected=from===allFrom&&to===allEnd,isEmpty=0===newState.doc.textBetween(0,newState.doc.content.size," "," ").length;if(empty||!allWasSelected||!isEmpty)return;const tr=newState.tr,state=createChainableState$3({state:newState,transaction:tr}),{commands:commands}=new CommandManager$3({editor:this.editor,state:state});return commands.clearNodes(),tr.steps.length?tr:void 0}})]}}),Extension$3.create({name:"tabindex",addProseMirrorPlugins(){return[new Plugin$3({key:new PluginKey$3("tabindex"),props:{attributes:this.editor.isEditable?{tabindex:"0"}:{}}})]}});class Mark$4{constructor(config={}){this.type="mark",this.name="mark",this.parent=null,this.child=null,this.config={name:this.name,defaultOptions:{}},this.config={...this.config,...config},this.name=this.config.name,config.defaultOptions,
// TODO: remove `addOptions` fallback
this.options=this.config.defaultOptions,this.config.addOptions&&(this.options=callOrReturn$3(getExtensionField$3(this,"addOptions",{name:this.name}))),this.storage=callOrReturn$3(getExtensionField$3(this,"addStorage",{name:this.name,options:this.options}))||{}}static create(config={}){return new Mark$4(config)}configure(options={}){
// return a new instance so we can use the same extension
// with different calls of `configure`
const extension=this.extend();return extension.options=mergeDeep$3(this.options,options),extension.storage=callOrReturn$3(getExtensionField$3(extension,"addStorage",{name:extension.name,options:extension.options})),extension}extend(extendedConfig={}){const extension=new Mark$4(extendedConfig);return extension.parent=this,this.child=extension,extension.name=extendedConfig.name?extendedConfig.name:extension.parent.name,extendedConfig.defaultOptions,extension.options=callOrReturn$3(getExtensionField$3(extension,"addOptions",{name:extension.name})),extension.storage=callOrReturn$3(getExtensionField$3(extension,"addStorage",{name:extension.name,options:extension.options})),extension}static handleExit({editor:editor,mark:mark}){const{tr:tr}=editor.state,currentPos=editor.state.selection.$from,isAtEnd=currentPos.pos===currentPos.end();if(isAtEnd){const currentMarks=currentPos.marks(),isInMark=!!currentMarks.find((m=>(null===m||void 0===m?void 0:m.type.name)===mark.name));if(!isInMark)return!1;const removeMark=currentMarks.find((m=>(null===m||void 0===m?void 0:m.type.name)===mark.name));return removeMark&&tr.removeStoredMark(removeMark),tr.insertText(" ",currentPos.pos),editor.view.dispatch(tr),!0}return!1}}class Node$1$3{constructor(config={}){this.type="node",this.name="node",this.parent=null,this.child=null,this.config={name:this.name,defaultOptions:{}},this.config={...this.config,...config},this.name=this.config.name,config.defaultOptions,
// TODO: remove `addOptions` fallback
this.options=this.config.defaultOptions,this.config.addOptions&&(this.options=callOrReturn$3(getExtensionField$3(this,"addOptions",{name:this.name}))),this.storage=callOrReturn$3(getExtensionField$3(this,"addStorage",{name:this.name,options:this.options}))||{}}static create(config={}){return new Node$1$3(config)}configure(options={}){
// return a new instance so we can use the same extension
// with different calls of `configure`
const extension=this.extend();return extension.options=mergeDeep$3(this.options,options),extension.storage=callOrReturn$3(getExtensionField$3(extension,"addStorage",{name:extension.name,options:extension.options})),extension}extend(extendedConfig={}){const extension=new Node$1$3(extendedConfig);return extension.parent=this,this.child=extension,extension.name=extendedConfig.name?extendedConfig.name:extension.parent.name,extendedConfig.defaultOptions,extension.options=callOrReturn$3(getExtensionField$3(extension,"addOptions",{name:extension.name})),extension.storage=callOrReturn$3(getExtensionField$3(extension,"addStorage",{name:extension.name,options:extension.options})),extension}}
/**
 * Build an paste rule that adds a mark when the
 * matched text is pasted into it.
 */function markPasteRule$3(config){return new PasteRule$3({find:config.find,handler:({state:state,range:range,match:match})=>{const attributes=callOrReturn$3(config.getAttributes,void 0,match);if(!1===attributes||null===attributes)return null;const{tr:tr}=state,captureGroup=match[match.length-1],fullMatch=match[0];let markEnd=range.to;if(captureGroup){const startSpaces=fullMatch.search(/\S/),textStart=range.from+fullMatch.indexOf(captureGroup),textEnd=textStart+captureGroup.length,excludedMarks=getMarksBetween$3(range.from,range.to,state.doc).filter((item=>{
// @ts-ignore
const excluded=item.mark.type.excluded;return excluded.find((type=>type===config.type&&type!==item.mark.type))})).filter((item=>item.to>textStart));if(excludedMarks.length)return null;textEnd<range.to&&tr.delete(textEnd,range.to),textStart>range.from&&tr.delete(range.from+startSpaces,textStart),markEnd=range.from+startSpaces+captureGroup.length,tr.addMark(range.from+startSpaces,markEnd,config.type.create(attributes||{})),tr.removeStoredMark(config.type)}}})}Node$1$3.create({name:"doc",topNode:!0,content:"block+"});const Paragraph$3=Node$1$3.create({name:"paragraph",priority:1e3,addOptions(){return{HTMLAttributes:{}}},group:"block",content:"inline*",parseHTML(){return[{tag:"p"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["p",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setParagraph:()=>({commands:commands})=>commands.setNode(this.name)}},addKeyboardShortcuts(){return{"Mod-Alt-0":()=>this.editor.commands.setParagraph()}}});Node$1$3.create({name:"text",group:"inline"});const starInputRegex$1$3=/(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/,starPasteRegex$1$3=/(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g,underscoreInputRegex$1$3=/(?:^|\s)((?:__)((?:[^__]+))(?:__))$/,underscorePasteRegex$1$3=/(?:^|\s)((?:__)((?:[^__]+))(?:__))/g;Mark$4.create({name:"bold",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"strong"},{tag:"b",getAttrs:node=>"normal"!==node.style.fontWeight&&null},{style:"font-weight",getAttrs:value=>/^(bold(er)?|[5-9]\d{2,})$/.test(value)&&null}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["strong",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setBold:()=>({commands:commands})=>commands.setMark(this.name),toggleBold:()=>({commands:commands})=>commands.toggleMark(this.name),unsetBold:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-b":()=>this.editor.commands.toggleBold(),"Mod-B":()=>this.editor.commands.toggleBold()}},addInputRules(){return[markInputRule$3({find:starInputRegex$1$3,type:this.type}),markInputRule$3({find:underscoreInputRegex$1$3,type:this.type})]},addPasteRules(){return[markPasteRule$3({find:starPasteRegex$1$3,type:this.type}),markPasteRule$3({find:underscorePasteRegex$1$3,type:this.type})]}});const starInputRegex$4=/(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/,starPasteRegex$4=/(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g,underscoreInputRegex$4=/(?:^|\s)((?:_)((?:[^_]+))(?:_))$/,underscorePasteRegex$4=/(?:^|\s)((?:_)((?:[^_]+))(?:_))/g;Mark$4.create({name:"italic",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"em"},{tag:"i",getAttrs:node=>"normal"!==node.style.fontStyle&&null},{style:"font-style=italic"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["em",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setItalic:()=>({commands:commands})=>commands.setMark(this.name),toggleItalic:()=>({commands:commands})=>commands.toggleMark(this.name),unsetItalic:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-i":()=>this.editor.commands.toggleItalic(),"Mod-I":()=>this.editor.commands.toggleItalic()}},addInputRules(){return[markInputRule$3({find:starInputRegex$4,type:this.type}),markInputRule$3({find:underscoreInputRegex$4,type:this.type})]},addPasteRules(){return[markPasteRule$3({find:starPasteRegex$4,type:this.type}),markPasteRule$3({find:underscorePasteRegex$4,type:this.type})]}}),Mark$4.create({name:"underline",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"u"},{style:"text-decoration",consuming:!1,getAttrs:style=>!!style.includes("underline")&&{}}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["u",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setUnderline:()=>({commands:commands})=>commands.setMark(this.name),toggleUnderline:()=>({commands:commands})=>commands.toggleMark(this.name),unsetUnderline:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-u":()=>this.editor.commands.toggleUnderline(),"Mod-U":()=>this.editor.commands.toggleUnderline()}}});const inputRegex$5$3=/(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/,pasteRegex$1$3=/(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g;Mark$4.create({name:"strike",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"s"},{tag:"del"},{tag:"strike"},{style:"text-decoration",consuming:!1,getAttrs:style=>!!style.includes("line-through")&&{}}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["s",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setStrike:()=>({commands:commands})=>commands.setMark(this.name),toggleStrike:()=>({commands:commands})=>commands.toggleMark(this.name),unsetStrike:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-Shift-x":()=>this.editor.commands.toggleStrike()}},addInputRules(){return[markInputRule$3({find:inputRegex$5$3,type:this.type})]},addPasteRules(){return[markPasteRule$3({find:pasteRegex$1$3,type:this.type})]}}),Node$1$3.create({name:"listItem",addOptions(){return{HTMLAttributes:{}}},content:"paragraph block*",defining:!0,parseHTML(){return[{tag:"li"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["li",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes),0]},addKeyboardShortcuts(){return{Enter:()=>this.editor.commands.splitListItem(this.name),Tab:()=>this.editor.commands.sinkListItem(this.name),"Shift-Tab":()=>this.editor.commands.liftListItem(this.name)}}});const inputRegex$4$3=/^\s*([-+*])\s$/;Node$1$3.create({name:"bulletList",addOptions(){return{itemTypeName:"listItem",HTMLAttributes:{}}},group:"block list",content(){return`${this.options.itemTypeName}+`},parseHTML(){return[{tag:"ul"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["ul",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{toggleBulletList:()=>({commands:commands})=>commands.toggleList(this.name,this.options.itemTypeName)}},addKeyboardShortcuts(){return{"Mod-Shift-8":()=>this.editor.commands.toggleBulletList()}},addInputRules(){return[wrappingInputRule$3({find:inputRegex$4$3,type:this.type})]}}),Mark$4.create({name:"textStyle",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"span",getAttrs:element=>{const hasStyles=element.hasAttribute("style");return!!hasStyles&&{}}}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["span",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{removeEmptyTextStyle:()=>({state:state,commands:commands})=>{const attributes=getMarkAttributes$3(state,this.type),hasStyles=Object.entries(attributes).some((([,value])=>!!value));return!!hasStyles||commands.unsetMark(this.name)}}}}),Extension$3.create({name:"fontFamily",addOptions(){return{types:["textStyle"]}},addGlobalAttributes(){return[{types:this.options.types,attributes:{fontFamily:{default:null,parseHTML:element=>{var _a;return null===(_a=element.style.fontFamily)||void 0===_a?void 0:_a.replace(/['"]+/g,"")},renderHTML:attributes=>attributes.fontFamily?{style:`font-family: ${attributes.fontFamily}`}:{}}}}]},addCommands(){return{setFontFamily:fontFamily=>({chain:chain})=>chain().setMark("textStyle",{fontFamily:fontFamily}).run(),unsetFontFamily:()=>({chain:chain})=>chain().setMark("textStyle",{fontFamily:null}).removeEmptyTextStyle().run()}}});const inputRegex$3$3=/^(\d+)\.\s$/;Node$1$3.create({name:"orderedList",addOptions(){return{itemTypeName:"listItem",HTMLAttributes:{}}},group:"block list",content(){return`${this.options.itemTypeName}+`},addAttributes(){return{start:{default:1,parseHTML:element=>element.hasAttribute("start")?parseInt(element.getAttribute("start")||"",10):1}}},parseHTML(){return[{tag:"ol"}]},renderHTML({HTMLAttributes:HTMLAttributes}){const{start:start,...attributesWithoutStart}=HTMLAttributes;return 1===start?["ol",mergeAttributes$3(this.options.HTMLAttributes,attributesWithoutStart),0]:["ol",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{toggleOrderedList:()=>({commands:commands})=>commands.toggleList(this.name,this.options.itemTypeName)}},addKeyboardShortcuts(){return{"Mod-Shift-7":()=>this.editor.commands.toggleOrderedList()}},addInputRules(){return[wrappingInputRule$3({find:inputRegex$3$3,type:this.type,getAttributes:match=>({start:+match[1]}),joinPredicate:(match,node)=>node.childCount+node.attrs.start===+match[1]})]}}),Node$1$3.create({name:"heading",addOptions(){return{levels:[1,2,3,4,5,6],HTMLAttributes:{}}},content:"inline*",group:"block",defining:!0,addAttributes(){return{level:{default:1,rendered:!1}}},parseHTML(){return this.options.levels.map((level=>({tag:`h${level}`,attrs:{level:level}})))},renderHTML({node:node,HTMLAttributes:HTMLAttributes}){const hasLevel=this.options.levels.includes(node.attrs.level),level=hasLevel?node.attrs.level:this.options.levels[0];return[`h${level}`,mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setHeading:attributes=>({commands:commands})=>!!this.options.levels.includes(attributes.level)&&commands.setNode(this.name,attributes),toggleHeading:attributes=>({commands:commands})=>!!this.options.levels.includes(attributes.level)&&commands.toggleNode(this.name,"paragraph",attributes)}},addKeyboardShortcuts(){return this.options.levels.reduce(((items,level)=>({...items,[`Mod-Alt-${level}`]:()=>this.editor.commands.toggleHeading({level:level})})),{})},addInputRules(){return this.options.levels.map((level=>textblockTypeInputRule$3({find:new RegExp(`^(#{1,${level}})\\s$`),type:this.type,getAttributes:{level:level}})))}});var GOOD_LEAF_SIZE$3=200,RopeSequence$3=function(){};
// :: class<T> A rope sequence is a persistent sequence data structure
// that supports appending, prepending, and slicing without doing a
// full copy. It is represented as a mostly-balanced tree.
RopeSequence$3.prototype.append=function(other){return other.length?(other=RopeSequence$3.from(other),!this.length&&other||other.length<GOOD_LEAF_SIZE$3&&this.leafAppend(other)||this.length<GOOD_LEAF_SIZE$3&&other.leafPrepend(this)||this.appendInner(other)):this},
// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>
// Prepend an array or other rope to this one, returning a new rope.
RopeSequence$3.prototype.prepend=function(other){return other.length?RopeSequence$3.from(other).append(this):this},RopeSequence$3.prototype.appendInner=function(other){return new Append$3(this,other)},
// :: (?number, ?number) → RopeSequence<T>
// Create a rope repesenting a sub-sequence of this rope.
RopeSequence$3.prototype.slice=function(from,to){return void 0===from&&(from=0),void 0===to&&(to=this.length),from>=to?RopeSequence$3.empty:this.sliceInner(Math.max(0,from),Math.min(this.length,to))},
// :: (number) → T
// Retrieve the element at the given position from this rope.
RopeSequence$3.prototype.get=function(i){if(!(i<0||i>=this.length))return this.getInner(i)},
// :: ((element: T, index: number) → ?bool, ?number, ?number)
// Call the given function for each element between the given
// indices. This tends to be more efficient than looping over the
// indices and calling `get`, because it doesn't have to descend the
// tree for every element.
RopeSequence$3.prototype.forEach=function(f,from,to){void 0===from&&(from=0),void 0===to&&(to=this.length),from<=to?this.forEachInner(f,from,to,0):this.forEachInvertedInner(f,from,to,0)},
// :: ((element: T, index: number) → U, ?number, ?number) → [U]
// Map the given functions over the elements of the rope, producing
// a flat array.
RopeSequence$3.prototype.map=function(f,from,to){void 0===from&&(from=0),void 0===to&&(to=this.length);var result=[];return this.forEach((function(elt,i){return result.push(f(elt,i))}),from,to),result},
// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>
// Create a rope representing the given array, or return the rope
// itself if a rope was given.
RopeSequence$3.from=function(values){return values instanceof RopeSequence$3?values:values&&values.length?new Leaf$3(values):RopeSequence$3.empty};var Leaf$3=function(RopeSequence){function Leaf(values){RopeSequence.call(this),this.values=values}RopeSequence&&(Leaf.__proto__=RopeSequence),Leaf.prototype=Object.create(RopeSequence&&RopeSequence.prototype),Leaf.prototype.constructor=Leaf;var prototypeAccessors={length:{configurable:!0},depth:{configurable:!0}};return Leaf.prototype.flatten=function(){return this.values},Leaf.prototype.sliceInner=function(from,to){return 0==from&&to==this.length?this:new Leaf(this.values.slice(from,to))},Leaf.prototype.getInner=function(i){return this.values[i]},Leaf.prototype.forEachInner=function(f,from,to,start){for(var i=from;i<to;i++)if(!1===f(this.values[i],start+i))return!1},Leaf.prototype.forEachInvertedInner=function(f,from,to,start){for(var i=from-1;i>=to;i--)if(!1===f(this.values[i],start+i))return!1},Leaf.prototype.leafAppend=function(other){if(this.length+other.length<=GOOD_LEAF_SIZE$3)return new Leaf(this.values.concat(other.flatten()))},Leaf.prototype.leafPrepend=function(other){if(this.length+other.length<=GOOD_LEAF_SIZE$3)return new Leaf(other.flatten().concat(this.values))},prototypeAccessors.length.get=function(){return this.values.length},prototypeAccessors.depth.get=function(){return 0},Object.defineProperties(Leaf.prototype,prototypeAccessors),Leaf}(RopeSequence$3);
// :: RopeSequence
// The empty rope sequence.
RopeSequence$3.empty=new Leaf$3([]);var Append$3=function(RopeSequence){function Append(left,right){RopeSequence.call(this),this.left=left,this.right=right,this.length=left.length+right.length,this.depth=Math.max(left.depth,right.depth)+1}return RopeSequence&&(Append.__proto__=RopeSequence),Append.prototype=Object.create(RopeSequence&&RopeSequence.prototype),Append.prototype.constructor=Append,Append.prototype.flatten=function(){return this.left.flatten().concat(this.right.flatten())},Append.prototype.getInner=function(i){return i<this.left.length?this.left.get(i):this.right.get(i-this.left.length)},Append.prototype.forEachInner=function(f,from,to,start){var leftLen=this.left.length;return!(from<leftLen&&!1===this.left.forEachInner(f,from,Math.min(to,leftLen),start))&&(!(to>leftLen&&!1===this.right.forEachInner(f,Math.max(from-leftLen,0),Math.min(this.length,to)-leftLen,start+leftLen))&&void 0)},Append.prototype.forEachInvertedInner=function(f,from,to,start){var leftLen=this.left.length;return!(from>leftLen&&!1===this.right.forEachInvertedInner(f,from-leftLen,Math.max(to,leftLen)-leftLen,start+leftLen))&&(!(to<leftLen&&!1===this.left.forEachInvertedInner(f,Math.min(from,leftLen),to,start))&&void 0)},Append.prototype.sliceInner=function(from,to){if(0==from&&to==this.length)return this;var leftLen=this.left.length;return to<=leftLen?this.left.slice(from,to):from>=leftLen?this.right.slice(from-leftLen,to-leftLen):this.left.slice(from,leftLen).append(this.right.slice(0,to-leftLen))},Append.prototype.leafAppend=function(other){var inner=this.right.leafAppend(other);if(inner)return new Append(this.left,inner)},Append.prototype.leafPrepend=function(other){var inner=this.left.leafPrepend(other);if(inner)return new Append(inner,this.right)},Append.prototype.appendInner=function(other){return this.left.depth>=Math.max(this.right.depth,other.depth)+1?new Append(this.left,new Append(this.right,other)):new Append(this,other)},Append}(RopeSequence$3),ropeSequence$3=RopeSequence$3;
// ProseMirror's history isn't simply a way to roll back to a previous
// state, because ProseMirror supports applying changes without adding
// them to the history (for example during collaboration).
// To this end, each 'Branch' (one for the undo history and one for
// the redo history) keeps an array of 'Items', which can optionally
// hold a step (an actual undoable change), and always hold a position
// map (which is needed to move changes below them to apply to the
// current document).
// An item that has both a step and a selection bookmark is the start
// of an 'event' — a group of changes that will be undone or redone at
// once. (It stores only the bookmark, since that way we don't have to
// provide a document until the selection is actually applied, which
// is useful when compressing.)
// Used to schedule history compression
const max_empty_items$3=500;class Branch$3{constructor(items,eventCount){this.items=items,this.eventCount=eventCount}
// Pop the latest event off the branch's history and apply it
// to a document transform.
popEvent(state,preserveItems){if(0==this.eventCount)return null;let remap,mapFrom,end=this.items.length;for(;;end--){let next=this.items.get(end-1);if(next.selection){--end;break}}preserveItems&&(remap=this.remapping(end,this.items.length),mapFrom=remap.maps.length);let selection,remaining,transform=state.tr,addAfter=[],addBefore=[];return this.items.forEach(((item,i)=>{if(!item.step)return remap||(remap=this.remapping(end,i+1),mapFrom=remap.maps.length),mapFrom--,void addBefore.push(item);if(remap){addBefore.push(new Item$3(item.map));let map,step=item.step.map(remap.slice(mapFrom));step&&transform.maybeStep(step).doc&&(map=transform.mapping.maps[transform.mapping.maps.length-1],addAfter.push(new Item$3(map,void 0,void 0,addAfter.length+addBefore.length))),mapFrom--,map&&remap.appendMap(map,mapFrom)}else transform.maybeStep(item.step);return item.selection?(selection=remap?item.selection.map(remap.slice(mapFrom)):item.selection,remaining=new Branch$3(this.items.slice(0,end).append(addBefore.reverse().concat(addAfter)),this.eventCount-1),!1):void 0}),this.items.length,0),{remaining:remaining,transform:transform,selection:selection}}
// Create a new branch with the given transform added.
addTransform(transform,selection,histOptions,preserveItems){let newItems=[],eventCount=this.eventCount,oldItems=this.items,lastItem=!preserveItems&&oldItems.length?oldItems.get(oldItems.length-1):null;for(let i=0;i<transform.steps.length;i++){let merged,step=transform.steps[i].invert(transform.docs[i]),item=new Item$3(transform.mapping.maps[i],step,selection);(merged=lastItem&&lastItem.merge(item))&&(item=merged,i?newItems.pop():oldItems=oldItems.slice(0,oldItems.length-1)),newItems.push(item),selection&&(eventCount++,selection=void 0),preserveItems||(lastItem=item)}let overflow=eventCount-histOptions.depth;return overflow>DEPTH_OVERFLOW$3&&(oldItems=cutOffEvents$3(oldItems,overflow),eventCount-=overflow),new Branch$3(oldItems.append(newItems),eventCount)}remapping(from,to){let maps=new Mapping$3;return this.items.forEach(((item,i)=>{let mirrorPos=null!=item.mirrorOffset&&i-item.mirrorOffset>=from?maps.maps.length-item.mirrorOffset:void 0;maps.appendMap(item.map,mirrorPos)}),from,to),maps}addMaps(array){return 0==this.eventCount?this:new Branch$3(this.items.append(array.map((map=>new Item$3(map)))),this.eventCount)}
// When the collab module receives remote changes, the history has
// to know about those, so that it can adjust the steps that were
// rebased on top of the remote changes, and include the position
// maps for the remote changes in its array of items.
rebased(rebasedTransform,rebasedCount){if(!this.eventCount)return this;let rebasedItems=[],start=Math.max(0,this.items.length-rebasedCount),mapping=rebasedTransform.mapping,newUntil=rebasedTransform.steps.length,eventCount=this.eventCount;this.items.forEach((item=>{item.selection&&eventCount--}),start);let iRebased=rebasedCount;this.items.forEach((item=>{let pos=mapping.getMirror(--iRebased);if(null==pos)return;newUntil=Math.min(newUntil,pos);let map=mapping.maps[pos];if(item.step){let step=rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]),selection=item.selection&&item.selection.map(mapping.slice(iRebased+1,pos));selection&&eventCount++,rebasedItems.push(new Item$3(map,step,selection))}else rebasedItems.push(new Item$3(map))}),start);let newMaps=[];for(let i=rebasedCount;i<newUntil;i++)newMaps.push(new Item$3(mapping.maps[i]));let items=this.items.slice(0,start).append(newMaps).append(rebasedItems),branch=new Branch$3(items,eventCount);return branch.emptyItemCount()>max_empty_items$3&&(branch=branch.compress(this.items.length-rebasedItems.length)),branch}emptyItemCount(){let count=0;return this.items.forEach((item=>{item.step||count++})),count}
// Compressing a branch means rewriting it to push the air (map-only
// items) out. During collaboration, these naturally accumulate
// because each remote change adds one. The `upto` argument is used
// to ensure that only the items below a given level are compressed,
// because `rebased` relies on a clean, untouched set of items in
// order to associate old items with rebased steps.
compress(upto=this.items.length){let remap=this.remapping(0,upto),mapFrom=remap.maps.length,items=[],events=0;return this.items.forEach(((item,i)=>{if(i>=upto)items.push(item),item.selection&&events++;else if(item.step){let step=item.step.map(remap.slice(mapFrom)),map=step&&step.getMap();if(mapFrom--,map&&remap.appendMap(map,mapFrom),step){let selection=item.selection&&item.selection.map(remap.slice(mapFrom));selection&&events++;let merged,newItem=new Item$3(map.invert(),step,selection),last=items.length-1;(merged=items.length&&items[last].merge(newItem))?items[last]=merged:items.push(newItem)}}else item.map&&mapFrom--}),this.items.length,0),new Branch$3(ropeSequence$3.from(items.reverse()),events)}}function cutOffEvents$3(items,n){let cutPoint;return items.forEach(((item,i)=>{if(item.selection&&0==n--)return cutPoint=i,!1})),items.slice(cutPoint)}Branch$3.empty=new Branch$3(ropeSequence$3.empty,0);class Item$3{constructor(
// The (forward) step map for this item.
map,
// The inverted step
step,
// If this is non-null, this item is the start of a group, and
// this selection is the starting selection for the group (the one
// that was active before the first step was applied)
selection,
// If this item is the inverse of a previous mapping on the stack,
// this points at the inverse's offset
mirrorOffset){this.map=map,this.step=step,this.selection=selection,this.mirrorOffset=mirrorOffset}merge(other){if(this.step&&other.step&&!other.selection){let step=other.step.merge(this.step);if(step)return new Item$3(step.getMap().invert(),step,this.selection)}}}
// The value of the state field that tracks undo/redo history for that
// state. Will be stored in the plugin state when the history plugin
// is active.
class HistoryState$3{constructor(done,undone,prevRanges,prevTime){this.done=done,this.undone=undone,this.prevRanges=prevRanges,this.prevTime=prevTime}}const DEPTH_OVERFLOW$3=20;
// Record a transformation in undo history.
function applyTransaction$3(history,state,tr,options){let rebased,historyTr=tr.getMeta(historyKey$3);if(historyTr)return historyTr.historyState;tr.getMeta(closeHistoryKey$3)&&(history=new HistoryState$3(history.done,history.undone,null,0));let appended=tr.getMeta("appendedTransaction");if(0==tr.steps.length)return history;if(appended&&appended.getMeta(historyKey$3))return appended.getMeta(historyKey$3).redo?new HistoryState$3(history.done.addTransform(tr,void 0,options,mustPreserveItems$3(state)),history.undone,rangesFor$3(tr.mapping.maps[tr.steps.length-1]),history.prevTime):new HistoryState$3(history.done,history.undone.addTransform(tr,void 0,options,mustPreserveItems$3(state)),null,history.prevTime);if(!1===tr.getMeta("addToHistory")||appended&&!1===appended.getMeta("addToHistory"))return(rebased=tr.getMeta("rebased"))?new HistoryState$3(history.done.rebased(tr,rebased),history.undone.rebased(tr,rebased),mapRanges$3(history.prevRanges,tr.mapping),history.prevTime):new HistoryState$3(history.done.addMaps(tr.mapping.maps),history.undone.addMaps(tr.mapping.maps),mapRanges$3(history.prevRanges,tr.mapping),history.prevTime);{
// Group transforms that occur in quick succession into one event.
let newGroup=0==history.prevTime||!appended&&(history.prevTime<(tr.time||0)-options.newGroupDelay||!isAdjacentTo$3(tr,history.prevRanges)),prevRanges=appended?mapRanges$3(history.prevRanges,tr.mapping):rangesFor$3(tr.mapping.maps[tr.steps.length-1]);return new HistoryState$3(history.done.addTransform(tr,newGroup?state.selection.getBookmark():void 0,options,mustPreserveItems$3(state)),Branch$3.empty,prevRanges,tr.time)}}function isAdjacentTo$3(transform,prevRanges){if(!prevRanges)return!1;if(!transform.docChanged)return!0;let adjacent=!1;return transform.mapping.maps[0].forEach(((start,end)=>{for(let i=0;i<prevRanges.length;i+=2)start<=prevRanges[i+1]&&end>=prevRanges[i]&&(adjacent=!0)})),adjacent}function rangesFor$3(map){let result=[];return map.forEach(((_from,_to,from,to)=>result.push(from,to))),result}function mapRanges$3(ranges,mapping){if(!ranges)return null;let result=[];for(let i=0;i<ranges.length;i+=2){let from=mapping.map(ranges[i],1),to=mapping.map(ranges[i+1],-1);from<=to&&result.push(from,to)}return result}
// Apply the latest event from one branch to the document and shift the event
// onto the other branch.
function histTransaction$3(history,state,dispatch,redo){let preserveItems=mustPreserveItems$3(state),histOptions=historyKey$3.get(state).spec.config,pop=(redo?history.undone:history.done).popEvent(state,preserveItems);if(!pop)return;let selection=pop.selection.resolve(pop.transform.doc),added=(redo?history.done:history.undone).addTransform(pop.transform,state.selection.getBookmark(),histOptions,preserveItems),newHist=new HistoryState$3(redo?added:pop.remaining,redo?pop.remaining:added,null,0);dispatch(pop.transform.setSelection(selection).setMeta(historyKey$3,{redo:redo,historyState:newHist}).scrollIntoView())}let cachedPreserveItems$3=!1,cachedPreserveItemsPlugins$3=null;
// Check whether any plugin in the given state has a
// `historyPreserveItems` property in its spec, in which case we must
// preserve steps exactly as they came in, so that they can be
// rebased.
function mustPreserveItems$3(state){let plugins=state.plugins;if(cachedPreserveItemsPlugins$3!=plugins){cachedPreserveItems$3=!1,cachedPreserveItemsPlugins$3=plugins;for(let i=0;i<plugins.length;i++)if(plugins[i].spec.historyPreserveItems){cachedPreserveItems$3=!0;break}}return cachedPreserveItems$3}const historyKey$3=new PluginKey$3("history"),closeHistoryKey$3=new PluginKey$3("closeHistory");
/**
Returns a plugin that enables the undo history for an editor. The
plugin will track undo and redo stacks, which can be used with the
[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.

You can set an `"addToHistory"` [metadata
property](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction
to prevent it from being rolled back by undo.
*/
function history$3(config={}){return config={depth:config.depth||100,newGroupDelay:config.newGroupDelay||500},new Plugin$3({key:historyKey$3,state:{init(){return new HistoryState$3(Branch$3.empty,Branch$3.empty,null,0)},apply(tr,hist,state){return applyTransaction$3(hist,state,tr,config)}},config:config,props:{handleDOMEvents:{beforeinput(view,e){let inputType=e.inputType,command="historyUndo"==inputType?undo$3:"historyRedo"==inputType?redo$3:null;return!!command&&(e.preventDefault(),command(view.state,view.dispatch))}}}})}
/**
A command function that undoes the last change, if any.
*/const undo$3=(state,dispatch)=>{let hist=historyKey$3.getState(state);return!(!hist||0==hist.done.eventCount)&&(dispatch&&histTransaction$3(hist,state,dispatch,!1),!0)},redo$3=(state,dispatch)=>{let hist=historyKey$3.getState(state);return!(!hist||0==hist.undone.eventCount)&&(dispatch&&histTransaction$3(hist,state,dispatch,!0),!0)};
/**
A command function that redoes the last undone change, if any.
*/
// Because working with row and column-spanning cells is not quite
// trivial, this code builds up a descriptive structure for a given
// table node. The structures are cached with the (persistent) table
// nodes as key, so that they only have to be recomputed when the
// content of the table changes.
// This does mean that they have to store table-relative, not
// document-relative positions. So code that uses them will typically
// compute the start position of the table and offset positions passed
// to or gotten from this structure by that amount.
let readFromCache$3,addToCache$3;// Prefer using a weak map to cache table maps. Fall back on a
// fixed-size cache if that's not supported.
if(Extension$3.create({name:"history",addOptions(){return{depth:100,newGroupDelay:500}},addCommands(){return{undo:()=>({state:state,dispatch:dispatch})=>undo$3(state,dispatch),redo:()=>({state:state,dispatch:dispatch})=>redo$3(state,dispatch)}},addProseMirrorPlugins(){return[history$3(this.options)]},addKeyboardShortcuts(){return{"Mod-z":()=>this.editor.commands.undo(),"Mod-y":()=>this.editor.commands.redo(),"Shift-Mod-z":()=>this.editor.commands.redo()
// Russian keyboard layouts
,"Mod-я":()=>this.editor.commands.undo(),"Shift-Mod-я":()=>this.editor.commands.redo()}}}),Extension$3.create({name:"textAlign",addOptions(){return{types:[],alignments:["left","center","right","justify"],defaultAlignment:"left"}},addGlobalAttributes(){return[{types:this.options.types,attributes:{textAlign:{default:this.options.defaultAlignment,parseHTML:element=>element.style.textAlign||this.options.defaultAlignment,renderHTML:attributes=>attributes.textAlign===this.options.defaultAlignment?{}:{style:`text-align: ${attributes.textAlign}`}}}}]},addCommands(){return{setTextAlign:alignment=>({commands:commands})=>!!this.options.alignments.includes(alignment)&&this.options.types.every((type=>commands.updateAttributes(type,{textAlign:alignment}))),unsetTextAlign:()=>({commands:commands})=>this.options.types.every((type=>commands.resetAttributes(type,"textAlign")))}},addKeyboardShortcuts(){return{"Mod-Shift-l":()=>this.editor.commands.setTextAlign("left"),"Mod-Shift-e":()=>this.editor.commands.setTextAlign("center"),"Mod-Shift-r":()=>this.editor.commands.setTextAlign("right"),"Mod-Shift-j":()=>this.editor.commands.setTextAlign("justify")}}}),"undefined"!=typeof WeakMap){
// eslint-disable-next-line
let cache=new WeakMap;readFromCache$3=key=>cache.get(key),addToCache$3=(key,value)=>(cache.set(key,value),value)}else{let cache=[],cacheSize=10,cachePos=0;readFromCache$3=key=>{for(let i=0;i<cache.length;i+=2)if(cache[i]==key)return cache[i+1]},addToCache$3=(key,value)=>(cachePos==cacheSize&&(cachePos=0),cache[cachePos++]=key,cache[cachePos++]=value)}class Rect{constructor(left,top,right,bottom){this.left=left,this.top=top,this.right=right,this.bottom=bottom}}// ::- A table map describes the structore of a given table. To avoid
// recomputing them all the time, they are cached per table node. To
// be able to do that, positions saved in the map are relative to the
// start of the table, rather than the start of the document.
class TableMap$3{constructor(width,height,map,problems){
// :: number The width of the table
this.width=width,// :: number The table's height
this.height=height,// :: [number] A width * height array with the start position of
// the cell covering that part of the table in each slot
this.map=map,// An optional array of problems (cell overlap or non-rectangular
// shape) for the table, used by the table normalizer.
this.problems=problems}// :: (number) → Rect
// Find the dimensions of the cell at the given position.
findCell(pos){for(let i=0;i<this.map.length;i++){let curPos=this.map[i];if(curPos!=pos)continue;let left=i%this.width,top=i/this.width|0,right=left+1,bottom=top+1;for(let j=1;right<this.width&&this.map[i+j]==curPos;j++)right++;for(let j=1;bottom<this.height&&this.map[i+this.width*j]==curPos;j++)bottom++;return new Rect(left,top,right,bottom)}throw new RangeError("No cell with offset "+pos+" found")}// :: (number) → number
// Find the left side of the cell at the given position.
colCount(pos){for(let i=0;i<this.map.length;i++)if(this.map[i]==pos)return i%this.width;throw new RangeError("No cell with offset "+pos+" found")}// :: (number, string, number) → ?number
// Find the next cell in the given direction, starting from the cell
// at `pos`, if any.
nextCell(pos,axis,dir){let{left:left,right:right,top:top,bottom:bottom}=this.findCell(pos);return"horiz"==axis?(dir<0?0==left:right==this.width)?null:this.map[top*this.width+(dir<0?left-1:right)]:(dir<0?0==top:bottom==this.height)?null:this.map[left+this.width*(dir<0?top-1:bottom)]}// :: (number, number) → Rect
// Get the rectangle spanning the two given cells.
rectBetween(a,b){let{left:leftA,right:rightA,top:topA,bottom:bottomA}=this.findCell(a),{left:leftB,right:rightB,top:topB,bottom:bottomB}=this.findCell(b);return new Rect(Math.min(leftA,leftB),Math.min(topA,topB),Math.max(rightA,rightB),Math.max(bottomA,bottomB))}// :: (Rect) → [number]
// Return the position of all cells that have the top left corner in
// the given rectangle.
cellsInRect(rect){let result=[],seen={};for(let row=rect.top;row<rect.bottom;row++)for(let col=rect.left;col<rect.right;col++){let index=row*this.width+col,pos=this.map[index];seen[pos]||(seen[pos]=!0,col==rect.left&&col&&this.map[index-1]==pos||row==rect.top&&row&&this.map[index-this.width]==pos||result.push(pos))}return result}// :: (number, number, Node) → number
// Return the position at which the cell at the given row and column
// starts, or would start, if a cell started there.
positionAt(row,col,table){for(let i=0,rowStart=0;;i++){let rowEnd=rowStart+table.child(i).nodeSize;if(i==row){let index=col+row*this.width,rowEndIndex=(row+1)*this.width;// Skip past cells from previous rows (via rowspan)
while(index<rowEndIndex&&this.map[index]<rowStart)index++;return index==rowEndIndex?rowEnd-1:this.map[index]}rowStart=rowEnd}}// :: (Node) → TableMap
// Find the table map for the given table node.
static get(table){return readFromCache$3(table)||addToCache$3(table,computeMap$3(table))}}// Compute a table map.
function computeMap$3(table){if("table"!=table.type.spec.tableRole)throw new RangeError("Not a table node: "+table.type.name);let width=findWidth$3(table),height=table.childCount,map=[],mapPos=0,problems=null,colWidths=[];for(let i=0,e=width*height;i<e;i++)map[i]=0;for(let row=0,pos=0;row<height;row++){let rowNode=table.child(row);pos++;for(let i=0;;i++){while(mapPos<map.length&&0!=map[mapPos])mapPos++;if(i==rowNode.childCount)break;let cellNode=rowNode.child(i),{colspan:colspan,rowspan:rowspan,colwidth:colwidth}=cellNode.attrs;for(let h=0;h<rowspan;h++){if(h+row>=height){(problems||(problems=[])).push({type:"overlong_rowspan",pos:pos,n:rowspan-h});break}let start=mapPos+h*width;for(let w=0;w<colspan;w++){0==map[start+w]?map[start+w]=pos:(problems||(problems=[])).push({type:"collision",row:row,pos:pos,n:colspan-w});let colW=colwidth&&colwidth[w];if(colW){let widthIndex=(start+w)%width*2,prev=colWidths[widthIndex];null==prev||prev!=colW&&1==colWidths[widthIndex+1]?(colWidths[widthIndex]=colW,colWidths[widthIndex+1]=1):prev==colW&&colWidths[widthIndex+1]++}}}mapPos+=colspan,pos+=cellNode.nodeSize}let expectedPos=(row+1)*width,missing=0;while(mapPos<expectedPos)0==map[mapPos++]&&missing++;missing&&(problems||(problems=[])).push({type:"missing",row:row,n:missing}),pos++}let tableMap=new TableMap$3(width,height,map,problems),badWidths=!1;// For columns that have defined widths, but whose widths disagree
// between rows, fix up the cells whose width doesn't match the
// computed one.
for(let i=0;!badWidths&&i<colWidths.length;i+=2)null!=colWidths[i]&&colWidths[i+1]<height&&(badWidths=!0);return badWidths&&findBadColWidths$3(tableMap,colWidths,table),tableMap}function findWidth$3(table){let width=-1,hasRowSpan=!1;for(let row=0;row<table.childCount;row++){let rowNode=table.child(row),rowWidth=0;if(hasRowSpan)for(let j=0;j<row;j++){let prevRow=table.child(j);for(let i=0;i<prevRow.childCount;i++){let cell=prevRow.child(i);j+cell.attrs.rowspan>row&&(rowWidth+=cell.attrs.colspan)}}for(let i=0;i<rowNode.childCount;i++){let cell=rowNode.child(i);rowWidth+=cell.attrs.colspan,cell.attrs.rowspan>1&&(hasRowSpan=!0)}-1==width?width=rowWidth:width!=rowWidth&&(width=Math.max(width,rowWidth))}return width}function findBadColWidths$3(map,colWidths,table){map.problems||(map.problems=[]);for(let i=0,seen={};i<map.map.length;i++){let pos=map.map[i];if(seen[pos])continue;seen[pos]=!0;let node=table.nodeAt(pos),updated=null;for(let j=0;j<node.attrs.colspan;j++){let col=(i+j)%map.width,colWidth=colWidths[2*col];null==colWidth||node.attrs.colwidth&&node.attrs.colwidth[j]==colWidth||((updated||(updated=freshColWidth$3(node.attrs)))[j]=colWidth)}updated&&map.problems.unshift({type:"colwidth mismatch",pos:pos,colwidth:updated})}}function freshColWidth$3(attrs){if(attrs.colwidth)return attrs.colwidth.slice();let result=[];for(let i=0;i<attrs.colspan;i++)result.push(0);return result}function tableNodeTypes$3(schema){let result=schema.cached.tableNodeTypes;if(!result){result=schema.cached.tableNodeTypes={};for(let name in schema.nodes){let type=schema.nodes[name],role=type.spec.tableRole;role&&(result[role]=type)}}return result}
// Various helper function for working with tables
const key$1=new PluginKey$3("selectingCells");function cellAround$3($pos){for(let d=$pos.depth-1;d>0;d--)if("row"==$pos.node(d).type.spec.tableRole)return $pos.node(0).resolve($pos.before(d+1));return null}function cellWrapping$3($pos){for(let d=$pos.depth;d>0;d--){
// Sometimes the cell can be in the same depth.
const role=$pos.node(d).type.spec.tableRole;if("cell"===role||"header_cell"===role)return $pos.node(d)}return null}function isInTable$3(state){let $head=state.selection.$head;for(let d=$head.depth;d>0;d--)if("row"==$head.node(d).type.spec.tableRole)return!0;return!1}function selectionCell$3(state){let sel=state.selection;return sel.$anchorCell?sel.$anchorCell.pos>sel.$headCell.pos?sel.$anchorCell:sel.$headCell:sel.node&&"cell"==sel.node.type.spec.tableRole?sel.$anchor:cellAround$3(sel.$head)||cellNear$3(sel.$head)}function cellNear$3($pos){for(let after=$pos.nodeAfter,pos=$pos.pos;after;after=after.firstChild,pos++){let role=after.type.spec.tableRole;if("cell"==role||"header_cell"==role)return $pos.doc.resolve(pos)}for(let before=$pos.nodeBefore,pos=$pos.pos;before;before=before.lastChild,pos--){let role=before.type.spec.tableRole;if("cell"==role||"header_cell"==role)return $pos.doc.resolve(pos-before.nodeSize)}}function pointsAtCell$3($pos){return"row"==$pos.parent.type.spec.tableRole&&$pos.nodeAfter}function moveCellForward$3($pos){return $pos.node(0).resolve($pos.pos+$pos.nodeAfter.nodeSize)}function inSameTable$3($a,$b){return $a.depth==$b.depth&&$a.pos>=$b.start(-1)&&$a.pos<=$b.end(-1)}function nextCell$3($pos,axis,dir){let start=$pos.start(-1),map=TableMap$3.get($pos.node(-1)),moved=map.nextCell($pos.pos-start,axis,dir);return null==moved?null:$pos.node(0).resolve(start+moved)}function setAttr(attrs,name,value){let result={};for(let prop in attrs)result[prop]=attrs[prop];return result[name]=value,result}function removeColSpan$3(attrs,pos,n=1){let result=setAttr(attrs,"colspan",attrs.colspan-n);return result.colwidth&&(result.colwidth=result.colwidth.slice(),result.colwidth.splice(pos,n),result.colwidth.some((w=>w>0))||(result.colwidth=null)),result}function addColSpan$3(attrs,pos,n=1){let result=setAttr(attrs,"colspan",attrs.colspan+n);if(result.colwidth){result.colwidth=result.colwidth.slice();for(let i=0;i<n;i++)result.colwidth.splice(pos,0,0)}return result}function columnIsHeader$3(map,table,col){let headerCell=tableNodeTypes$3(table.type.schema).header_cell;for(let row=0;row<map.height;row++)if(table.nodeAt(map.map[col+row*map.width]).type!=headerCell)return!1;return!0}
// This file defines a ProseMirror selection subclass that models
// subclass that represents a cell selection spanning part of a table.
// With the plugin enabled, these will be created when the user
// selects across cells, and will be drawn by giving selected cells a
// `selectedCell` CSS class.
class CellSelection$3 extends Selection$3{
// :: (ResolvedPos, ?ResolvedPos)
// A table selection is identified by its anchor and head cells. The
// positions given to this constructor should point _before_ two
// cells in the same table. They may be the same, to select a single
// cell.
constructor($anchorCell,$headCell=$anchorCell){let table=$anchorCell.node(-1),map=TableMap$3.get(table),start=$anchorCell.start(-1),rect=map.rectBetween($anchorCell.pos-start,$headCell.pos-start),doc=$anchorCell.node(0),cells=map.cellsInRect(rect).filter((p=>p!=$headCell.pos-start));// Make the head cell the first range, so that it counts as the
// primary part of the selection
cells.unshift($headCell.pos-start);let ranges=cells.map((pos=>{let cell=table.nodeAt(pos),from=pos+start+1;return new SelectionRange$3(doc.resolve(from),doc.resolve(from+cell.content.size))}));super(ranges[0].$from,ranges[0].$to,ranges),// :: ResolvedPos
// A resolved position pointing _in front of_ the anchor cell (the one
// that doesn't move when extending the selection).
this.$anchorCell=$anchorCell,// :: ResolvedPos
// A resolved position pointing in front of the head cell (the one
// moves when extending the selection).
this.$headCell=$headCell}map(doc,mapping){let $anchorCell=doc.resolve(mapping.map(this.$anchorCell.pos)),$headCell=doc.resolve(mapping.map(this.$headCell.pos));if(pointsAtCell$3($anchorCell)&&pointsAtCell$3($headCell)&&inSameTable$3($anchorCell,$headCell)){let tableChanged=this.$anchorCell.node(-1)!=$anchorCell.node(-1);return tableChanged&&this.isRowSelection()?CellSelection$3.rowSelection($anchorCell,$headCell):tableChanged&&this.isColSelection()?CellSelection$3.colSelection($anchorCell,$headCell):new CellSelection$3($anchorCell,$headCell)}return TextSelection$3.between($anchorCell,$headCell)}// :: () → Slice
// Returns a rectangular slice of table rows containing the selected
// cells.
content(){let table=this.$anchorCell.node(-1),map=TableMap$3.get(table),start=this.$anchorCell.start(-1),rect=map.rectBetween(this.$anchorCell.pos-start,this.$headCell.pos-start),seen={},rows=[];for(let row=rect.top;row<rect.bottom;row++){let rowContent=[];for(let index=row*map.width+rect.left,col=rect.left;col<rect.right;col++,index++){let pos=map.map[index];if(!seen[pos]){seen[pos]=!0;let cellRect=map.findCell(pos),cell=table.nodeAt(pos),extraLeft=rect.left-cellRect.left,extraRight=cellRect.right-rect.right;if(extraLeft>0||extraRight>0){let attrs=cell.attrs;extraLeft>0&&(attrs=removeColSpan$3(attrs,0,extraLeft)),extraRight>0&&(attrs=removeColSpan$3(attrs,attrs.colspan-extraRight,extraRight)),cell=cellRect.left<rect.left?cell.type.createAndFill(attrs):cell.type.create(attrs,cell.content)}if(cellRect.top<rect.top||cellRect.bottom>rect.bottom){let attrs=setAttr(cell.attrs,"rowspan",Math.min(cellRect.bottom,rect.bottom)-Math.max(cellRect.top,rect.top));cell=cellRect.top<rect.top?cell.type.createAndFill(attrs):cell.type.create(attrs,cell.content)}rowContent.push(cell)}}rows.push(table.child(row).copy(Fragment$3.from(rowContent)))}const fragment=this.isColSelection()&&this.isRowSelection()?table:rows;return new Slice$3(Fragment$3.from(fragment),1,1)}replace(tr,content=Slice$3.empty){let mapFrom=tr.steps.length,ranges=this.ranges;for(let i=0;i<ranges.length;i++){let{$from:$from,$to:$to}=ranges[i],mapping=tr.mapping.slice(mapFrom);tr.replace(mapping.map($from.pos),mapping.map($to.pos),i?Slice$3.empty:content)}let sel=Selection$3.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),-1);sel&&tr.setSelection(sel)}replaceWith(tr,node){this.replace(tr,new Slice$3(Fragment$3.from(node),0,0))}forEachCell(f){let table=this.$anchorCell.node(-1),map=TableMap$3.get(table),start=this.$anchorCell.start(-1),cells=map.cellsInRect(map.rectBetween(this.$anchorCell.pos-start,this.$headCell.pos-start));for(let i=0;i<cells.length;i++)f(table.nodeAt(cells[i]),start+cells[i])}// :: () → bool
// True if this selection goes all the way from the top to the
// bottom of the table.
isColSelection(){let anchorTop=this.$anchorCell.index(-1),headTop=this.$headCell.index(-1);if(Math.min(anchorTop,headTop)>0)return!1;let anchorBot=anchorTop+this.$anchorCell.nodeAfter.attrs.rowspan,headBot=headTop+this.$headCell.nodeAfter.attrs.rowspan;return Math.max(anchorBot,headBot)==this.$headCell.node(-1).childCount}// :: (ResolvedPos, ?ResolvedPos) → CellSelection
// Returns the smallest column selection that covers the given anchor
// and head cell.
static colSelection($anchorCell,$headCell=$anchorCell){let map=TableMap$3.get($anchorCell.node(-1)),start=$anchorCell.start(-1),anchorRect=map.findCell($anchorCell.pos-start),headRect=map.findCell($headCell.pos-start),doc=$anchorCell.node(0);return anchorRect.top<=headRect.top?(anchorRect.top>0&&($anchorCell=doc.resolve(start+map.map[anchorRect.left])),headRect.bottom<map.height&&($headCell=doc.resolve(start+map.map[map.width*(map.height-1)+headRect.right-1]))):(headRect.top>0&&($headCell=doc.resolve(start+map.map[headRect.left])),anchorRect.bottom<map.height&&($anchorCell=doc.resolve(start+map.map[map.width*(map.height-1)+anchorRect.right-1]))),new CellSelection$3($anchorCell,$headCell)}// :: () → bool
// True if this selection goes all the way from the left to the
// right of the table.
isRowSelection(){let map=TableMap$3.get(this.$anchorCell.node(-1)),start=this.$anchorCell.start(-1),anchorLeft=map.colCount(this.$anchorCell.pos-start),headLeft=map.colCount(this.$headCell.pos-start);if(Math.min(anchorLeft,headLeft)>0)return!1;let anchorRight=anchorLeft+this.$anchorCell.nodeAfter.attrs.colspan,headRight=headLeft+this.$headCell.nodeAfter.attrs.colspan;return Math.max(anchorRight,headRight)==map.width}eq(other){return other instanceof CellSelection$3&&other.$anchorCell.pos==this.$anchorCell.pos&&other.$headCell.pos==this.$headCell.pos}// :: (ResolvedPos, ?ResolvedPos) → CellSelection
// Returns the smallest row selection that covers the given anchor
// and head cell.
static rowSelection($anchorCell,$headCell=$anchorCell){let map=TableMap$3.get($anchorCell.node(-1)),start=$anchorCell.start(-1),anchorRect=map.findCell($anchorCell.pos-start),headRect=map.findCell($headCell.pos-start),doc=$anchorCell.node(0);return anchorRect.left<=headRect.left?(anchorRect.left>0&&($anchorCell=doc.resolve(start+map.map[anchorRect.top*map.width])),headRect.right<map.width&&($headCell=doc.resolve(start+map.map[map.width*(headRect.top+1)-1]))):(headRect.left>0&&($headCell=doc.resolve(start+map.map[headRect.top*map.width])),anchorRect.right<map.width&&($anchorCell=doc.resolve(start+map.map[map.width*(anchorRect.top+1)-1]))),new CellSelection$3($anchorCell,$headCell)}toJSON(){return{type:"cell",anchor:this.$anchorCell.pos,head:this.$headCell.pos}}static fromJSON(doc,json){return new CellSelection$3(doc.resolve(json.anchor),doc.resolve(json.head))}// :: (Node, number, ?number) → CellSelection
static create(doc,anchorCell,headCell=anchorCell){return new CellSelection$3(doc.resolve(anchorCell),doc.resolve(headCell))}getBookmark(){return new CellBookmark$3(this.$anchorCell.pos,this.$headCell.pos)}}CellSelection$3.prototype.visible=!1,Selection$3.jsonID("cell",CellSelection$3);class CellBookmark$3{constructor(anchor,head){this.anchor=anchor,this.head=head}map(mapping){return new CellBookmark$3(mapping.map(this.anchor),mapping.map(this.head))}resolve(doc){let $anchorCell=doc.resolve(this.anchor),$headCell=doc.resolve(this.head);return"row"==$anchorCell.parent.type.spec.tableRole&&"row"==$headCell.parent.type.spec.tableRole&&$anchorCell.index()<$anchorCell.parent.childCount&&$headCell.index()<$headCell.parent.childCount&&inSameTable$3($anchorCell,$headCell)?new CellSelection$3($anchorCell,$headCell):Selection$3.near($headCell,1)}}function drawCellSelection$3(state){if(!(state.selection instanceof CellSelection$3))return null;let cells=[];return state.selection.forEachCell(((node,pos)=>{cells.push(Decoration$3.node(pos,pos+node.nodeSize,{class:"selectedCell"}))})),DecorationSet$3.create(state.doc,cells)}function isCellBoundarySelection$3({$from:$from,$to:$to}){if($from.pos==$to.pos||$from.pos<$from.pos-6)return!1;// Cheap elimination
let afterFrom=$from.pos,beforeTo=$to.pos,depth=$from.depth;for(;depth>=0;depth--,afterFrom++)if($from.after(depth+1)<$from.end(depth))break;for(let d=$to.depth;d>=0;d--,beforeTo--)if($to.before(d+1)>$to.start(d))break;return afterFrom==beforeTo&&/row|table/.test($from.node(depth).type.spec.tableRole)}function isTextSelectionAcrossCells$3({$from:$from,$to:$to}){let fromCellBoundaryNode,toCellBoundaryNode;for(let i=$from.depth;i>0;i--){let node=$from.node(i);if("cell"===node.type.spec.tableRole||"header_cell"===node.type.spec.tableRole){fromCellBoundaryNode=node;break}}for(let i=$to.depth;i>0;i--){let node=$to.node(i);if("cell"===node.type.spec.tableRole||"header_cell"===node.type.spec.tableRole){toCellBoundaryNode=node;break}}return fromCellBoundaryNode!==toCellBoundaryNode&&0===$to.parentOffset}function normalizeSelection$3(state,tr,allowTableNodeSelection){let normalize,role,sel=(tr||state).selection,doc=(tr||state).doc;if(sel instanceof NodeSelection$3&&(role=sel.node.type.spec.tableRole)){if("cell"==role||"header_cell"==role)normalize=CellSelection$3.create(doc,sel.from);else if("row"==role){let $cell=doc.resolve(sel.from+1);normalize=CellSelection$3.rowSelection($cell,$cell)}else if(!allowTableNodeSelection){let map=TableMap$3.get(sel.node),start=sel.from+1,lastCell=start+map.map[map.width*map.height-1];normalize=CellSelection$3.create(doc,start+1,lastCell)}}else sel instanceof TextSelection$3&&isCellBoundarySelection$3(sel)?normalize=TextSelection$3.create(doc,sel.from):sel instanceof TextSelection$3&&isTextSelectionAcrossCells$3(sel)&&(normalize=TextSelection$3.create(doc,sel.$from.start(),sel.$from.end()));return normalize&&(tr||(tr=state.tr)).setSelection(normalize),tr}
// Utilities used for copy/paste handling.
// : (Slice) → ?{width: number, height: number, rows: [Fragment]}
// Get a rectangular area of cells from a slice, or null if the outer
// nodes of the slice aren't table cells or rows.
function pastedCells$3(slice){if(!slice.size)return null;let{content:content,openStart:openStart,openEnd:openEnd}=slice;while(1==content.childCount&&(openStart>0&&openEnd>0||"table"==content.firstChild.type.spec.tableRole))openStart--,openEnd--,content=content.firstChild.content;let first=content.firstChild,role=first.type.spec.tableRole,schema=first.type.schema,rows=[];if("row"==role)for(let i=0;i<content.childCount;i++){let cells=content.child(i).content,left=i?0:Math.max(0,openStart-1),right=i<content.childCount-1?0:Math.max(0,openEnd-1);(left||right)&&(cells=fitSlice$3(tableNodeTypes$3(schema).row,new Slice$3(cells,left,right)).content),rows.push(cells)}else{if("cell"!=role&&"header_cell"!=role)return null;rows.push(openStart||openEnd?fitSlice$3(tableNodeTypes$3(schema).row,new Slice$3(content,openStart,openEnd)).content:content)}return ensureRectangular$3(schema,rows)}// : (Schema, [Fragment]) → {width: number, height: number, rows: [Fragment]}
// Compute the width and height of a set of cells, and make sure each
// row has the same number of cells.
function ensureRectangular$3(schema,rows){let widths=[];for(let i=0;i<rows.length;i++){let row=rows[i];for(let j=row.childCount-1;j>=0;j--){let{rowspan:rowspan,colspan:colspan}=row.child(j).attrs;for(let r=i;r<i+rowspan;r++)widths[r]=(widths[r]||0)+colspan}}let width=0;for(let r=0;r<widths.length;r++)width=Math.max(width,widths[r]);for(let r=0;r<widths.length;r++)if(r>=rows.length&&rows.push(Fragment$3.empty),widths[r]<width){let empty=tableNodeTypes$3(schema).cell.createAndFill(),cells=[];for(let i=widths[r];i<width;i++)cells.push(empty);rows[r]=rows[r].append(Fragment$3.from(cells))}return{height:rows.length,width:width,rows:rows}}function fitSlice$3(nodeType,slice){let node=nodeType.createAndFill(),tr=new Transform$3(node).replace(0,node.content.size,slice);return tr.doc}// : ({width: number, height: number, rows: [Fragment]}, number, number) → {width: number, height: number, rows: [Fragment]}
// Clip or extend (repeat) the given set of cells to cover the given
// width and height. Will clip rowspan/colspan cells at the edges when
// they stick out.
function clipCells$3({width:width,height:height,rows:rows},newWidth,newHeight){if(width!=newWidth){let added=[],newRows=[];for(let row=0;row<rows.length;row++){let frag=rows[row],cells=[];for(let col=added[row]||0,i=0;col<newWidth;i++){let cell=frag.child(i%frag.childCount);col+cell.attrs.colspan>newWidth&&(cell=cell.type.create(removeColSpan$3(cell.attrs,cell.attrs.colspan,col+cell.attrs.colspan-newWidth),cell.content)),cells.push(cell),col+=cell.attrs.colspan;for(let j=1;j<cell.attrs.rowspan;j++)added[row+j]=(added[row+j]||0)+cell.attrs.colspan}newRows.push(Fragment$3.from(cells))}rows=newRows,width=newWidth}if(height!=newHeight){let newRows=[];for(let row=0,i=0;row<newHeight;row++,i++){let cells=[],source=rows[i%height];for(let j=0;j<source.childCount;j++){let cell=source.child(j);row+cell.attrs.rowspan>newHeight&&(cell=cell.type.create(setAttr(cell.attrs,"rowspan",Math.max(1,newHeight-cell.attrs.rowspan)),cell.content)),cells.push(cell)}newRows.push(Fragment$3.from(cells))}rows=newRows,height=newHeight}return{width:width,height:height,rows:rows}}// Make sure a table has at least the given width and height. Return
// true if something was changed.
function growTable$3(tr,map,table,start,width,height,mapFrom){let empty,emptyHead,schema=tr.doc.type.schema,types=tableNodeTypes$3(schema);if(width>map.width)for(let row=0,rowEnd=0;row<map.height;row++){let rowNode=table.child(row);rowEnd+=rowNode.nodeSize;let add,cells=[];add=null==rowNode.lastChild||rowNode.lastChild.type==types.cell?empty||(empty=types.cell.createAndFill()):emptyHead||(emptyHead=types.header_cell.createAndFill());for(let i=map.width;i<width;i++)cells.push(add);tr.insert(tr.mapping.slice(mapFrom).map(rowEnd-1+start),cells)}if(height>map.height){let cells=[];for(let i=0,start=(map.height-1)*map.width;i<Math.max(map.width,width);i++){let header=!(i>=map.width)&&table.nodeAt(map.map[start+i]).type==types.header_cell;cells.push(header?emptyHead||(emptyHead=types.header_cell.createAndFill()):empty||(empty=types.cell.createAndFill()))}let emptyRow=types.row.create(null,Fragment$3.from(cells)),rows=[];for(let i=map.height;i<height;i++)rows.push(emptyRow);tr.insert(tr.mapping.slice(mapFrom).map(start+table.nodeSize-2),rows)}return!(!empty&&!emptyHead)}// Make sure the given line (left, top) to (right, top) doesn't cross
// any rowspan cells by splitting cells that cross it. Return true if
// something changed.
function isolateHorizontal$3(tr,map,table,start,left,right,top,mapFrom){if(0==top||top==map.height)return!1;let found=!1;for(let col=left;col<right;col++){let index=top*map.width+col,pos=map.map[index];if(map.map[index-map.width]==pos){found=!0;let cell=table.nodeAt(pos),{top:cellTop,left:cellLeft}=map.findCell(pos);tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos+start),null,setAttr(cell.attrs,"rowspan",top-cellTop)),tr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top,cellLeft,table)),cell.type.createAndFill(setAttr(cell.attrs,"rowspan",cellTop+cell.attrs.rowspan-top))),col+=cell.attrs.colspan-1}}return found}// Make sure the given line (left, top) to (left, bottom) doesn't
// cross any colspan cells by splitting cells that cross it. Return
// true if something changed.
function isolateVertical$3(tr,map,table,start,top,bottom,left,mapFrom){if(0==left||left==map.width)return!1;let found=!1;for(let row=top;row<bottom;row++){let index=row*map.width+left,pos=map.map[index];if(map.map[index-1]==pos){found=!0;let cell=table.nodeAt(pos),cellLeft=map.colCount(pos),updatePos=tr.mapping.slice(mapFrom).map(pos+start);tr.setNodeMarkup(updatePos,null,removeColSpan$3(cell.attrs,left-cellLeft,cell.attrs.colspan-(left-cellLeft))),tr.insert(updatePos+cell.nodeSize,cell.type.createAndFill(removeColSpan$3(cell.attrs,0,left-cellLeft))),row+=cell.attrs.rowspan-1}}return found}// Insert the given set of cells (as returned by `pastedCells`) into a
// table, at the position pointed at by rect.
function insertCells$3(state,dispatch,tableStart,rect,cells){let table=tableStart?state.doc.nodeAt(tableStart-1):state.doc,map=TableMap$3.get(table),{top:top,left:left}=rect,right=left+cells.width,bottom=top+cells.height,tr=state.tr,mapFrom=0;function recomp(){table=tableStart?tr.doc.nodeAt(tableStart-1):tr.doc,map=TableMap$3.get(table),mapFrom=tr.mapping.maps.length}// Prepare the table to be large enough and not have any cells
// crossing the boundaries of the rectangle that we want to
// insert into. If anything about it changes, recompute the table
// map so that subsequent operations can see the current shape.
growTable$3(tr,map,table,tableStart,right,bottom,mapFrom)&&recomp(),isolateHorizontal$3(tr,map,table,tableStart,left,right,top,mapFrom)&&recomp(),isolateHorizontal$3(tr,map,table,tableStart,left,right,bottom,mapFrom)&&recomp(),isolateVertical$3(tr,map,table,tableStart,top,bottom,left,mapFrom)&&recomp(),isolateVertical$3(tr,map,table,tableStart,top,bottom,right,mapFrom)&&recomp();for(let row=top;row<bottom;row++){let from=map.positionAt(row,left,table),to=map.positionAt(row,right,table);tr.replace(tr.mapping.slice(mapFrom).map(from+tableStart),tr.mapping.slice(mapFrom).map(to+tableStart),new Slice$3(cells.rows[row-top],0,0))}recomp(),tr.setSelection(new CellSelection$3(tr.doc.resolve(tableStart+map.positionAt(top,left,table)),tr.doc.resolve(tableStart+map.positionAt(bottom-1,right-1,table)))),dispatch(tr)}
// This file defines a number of helpers for wiring up user input to
const handleKeyDown$3=keydownHandler$3({ArrowLeft:arrow$2$3("horiz",-1),ArrowRight:arrow$2$3("horiz",1),ArrowUp:arrow$2$3("vert",-1),ArrowDown:arrow$2$3("vert",1),"Shift-ArrowLeft":shiftArrow$3("horiz",-1),"Shift-ArrowRight":shiftArrow$3("horiz",1),"Shift-ArrowUp":shiftArrow$3("vert",-1),"Shift-ArrowDown":shiftArrow$3("vert",1),Backspace:deleteCellSelection$3,"Mod-Backspace":deleteCellSelection$3,Delete:deleteCellSelection$3,"Mod-Delete":deleteCellSelection$3});function maybeSetSelection$3(state,dispatch,selection){return!selection.eq(state.selection)&&(dispatch&&dispatch(state.tr.setSelection(selection).scrollIntoView()),!0)}function arrow$2$3(axis,dir){return(state,dispatch,view)=>{let sel=state.selection;if(sel instanceof CellSelection$3)return maybeSetSelection$3(state,dispatch,Selection$3.near(sel.$headCell,dir));if("horiz"!=axis&&!sel.empty)return!1;let end=atEndOfCell$3(view,axis,dir);if(null==end)return!1;if("horiz"==axis)return maybeSetSelection$3(state,dispatch,Selection$3.near(state.doc.resolve(sel.head+dir),dir));{let newSel,$cell=state.doc.resolve(end),$next=nextCell$3($cell,axis,dir);return newSel=$next?Selection$3.near($next,1):dir<0?Selection$3.near(state.doc.resolve($cell.before(-1)),-1):Selection$3.near(state.doc.resolve($cell.after(-1)),1),maybeSetSelection$3(state,dispatch,newSel)}}}function shiftArrow$3(axis,dir){return(state,dispatch,view)=>{let sel=state.selection;if(!(sel instanceof CellSelection$3)){let end=atEndOfCell$3(view,axis,dir);if(null==end)return!1;sel=new CellSelection$3(state.doc.resolve(end))}let $head=nextCell$3(sel.$headCell,axis,dir);return!!$head&&maybeSetSelection$3(state,dispatch,new CellSelection$3(sel.$anchorCell,$head))}}function deleteCellSelection$3(state,dispatch){let sel=state.selection;if(!(sel instanceof CellSelection$3))return!1;if(dispatch){let tr=state.tr,baseContent=tableNodeTypes$3(state.schema).cell.createAndFill().content;sel.forEachCell(((cell,pos)=>{cell.content.eq(baseContent)||tr.replace(tr.mapping.map(pos+1),tr.mapping.map(pos+cell.nodeSize-1),new Slice$3(baseContent,0,0))})),tr.docChanged&&dispatch(tr)}return!0}function handleTripleClick$4(view,pos){let doc=view.state.doc,$cell=cellAround$3(doc.resolve(pos));return!!$cell&&(view.dispatch(view.state.tr.setSelection(new CellSelection$3($cell))),!0)}function handlePaste$3(view,_,slice){if(!isInTable$3(view.state))return!1;let cells=pastedCells$3(slice),sel=view.state.selection;if(sel instanceof CellSelection$3){cells||(cells={width:1,height:1,rows:[Fragment$3.from(fitSlice$3(tableNodeTypes$3(view.state.schema).cell,slice))]});let table=sel.$anchorCell.node(-1),start=sel.$anchorCell.start(-1),rect=TableMap$3.get(table).rectBetween(sel.$anchorCell.pos-start,sel.$headCell.pos-start);return cells=clipCells$3(cells,rect.right-rect.left,rect.bottom-rect.top),insertCells$3(view.state,view.dispatch,start,rect,cells),!0}if(cells){let $cell=selectionCell$3(view.state),start=$cell.start(-1);return insertCells$3(view.state,view.dispatch,start,TableMap$3.get($cell.node(-1)).findCell($cell.pos-start),cells),!0}return!1}function handleMouseDown$1(view,startEvent){if(startEvent.ctrlKey||startEvent.metaKey)return;let $anchor,startDOMCell=domInCell$3(view,startEvent.target);if(startEvent.shiftKey&&view.state.selection instanceof CellSelection$3)
// Adding to an existing cell selection
setCellSelection(view.state.selection.$anchorCell,startEvent),startEvent.preventDefault();else if(startEvent.shiftKey&&startDOMCell&&null!=($anchor=cellAround$3(view.state.selection.$anchor))&&cellUnderMouse$3(view,startEvent).pos!=$anchor.pos)
// Adding to a selection that starts in another cell (causing a
// cell selection to be created).
setCellSelection($anchor,startEvent),startEvent.preventDefault();else if(!startDOMCell)
// Not in a cell, let the default behavior happen.
return;// Create and dispatch a cell selection between the given anchor and
// the position under the mouse.
function setCellSelection($anchor,event){let $head=cellUnderMouse$3(view,event),starting=null==key$1.getState(view.state);if(!$head||!inSameTable$3($anchor,$head)){if(!starting)return;$head=$anchor}let selection=new CellSelection$3($anchor,$head);if(starting||!view.state.selection.eq(selection)){let tr=view.state.tr.setSelection(selection);starting&&tr.setMeta(key$1,$anchor.pos),view.dispatch(tr)}}// Stop listening to mouse motion events.
function stop(){view.root.removeEventListener("mouseup",stop),view.root.removeEventListener("dragstart",stop),view.root.removeEventListener("mousemove",move),null!=key$1.getState(view.state)&&view.dispatch(view.state.tr.setMeta(key$1,-1))}function move(event){let $anchor,anchor=key$1.getState(view.state);if(null!=anchor)
// Continuing an existing cross-cell selection
$anchor=view.state.doc.resolve(anchor);else if(domInCell$3(view,event.target)!=startDOMCell&&(
// Moving out of the initial cell -- start a new cell selection
$anchor=cellUnderMouse$3(view,startEvent),!$anchor))return stop();$anchor&&setCellSelection($anchor,event)}view.root.addEventListener("mouseup",stop),view.root.addEventListener("dragstart",stop),view.root.addEventListener("mousemove",move)}// Check whether the cursor is at the end of a cell (so that further
// motion would move out of the cell)
function atEndOfCell$3(view,axis,dir){if(!(view.state.selection instanceof TextSelection$3))return null;let{$head:$head}=view.state.selection;for(let d=$head.depth-1;d>=0;d--){let parent=$head.node(d),index=dir<0?$head.index(d):$head.indexAfter(d);if(index!=(dir<0?0:parent.childCount))return null;if("cell"==parent.type.spec.tableRole||"header_cell"==parent.type.spec.tableRole){let cellPos=$head.before(d),dirStr="vert"==axis?dir>0?"down":"up":dir>0?"right":"left";return view.endOfTextblock(dirStr)?cellPos:null}}return null}function domInCell$3(view,dom){for(;dom&&dom!=view.dom;dom=dom.parentNode)if("TD"==dom.nodeName||"TH"==dom.nodeName)return dom}function cellUnderMouse$3(view,event){let mousePos=view.posAtCoords({left:event.clientX,top:event.clientY});return mousePos&&mousePos?cellAround$3(view.state.doc.resolve(mousePos.pos)):null}
// This file defines helpers for normalizing tables, making sure no
const fixTablesKey$3=new PluginKey$3("fix-tables");// Helper for iterating through the nodes in a document that changed
// compared to the given previous document. Useful for avoiding
// duplicate work on each transaction.
function changedDescendants$3(old,cur,offset,f){let oldSize=old.childCount,curSize=cur.childCount;outer:for(let i=0,j=0;i<curSize;i++){let child=cur.child(i);for(let scan=j,e=Math.min(oldSize,i+3);scan<e;scan++)if(old.child(scan)==child){j=scan+1,offset+=child.nodeSize;continue outer}f(child,offset),j<oldSize&&old.child(j).sameMarkup(child)?changedDescendants$3(old.child(j),child,offset+1,f):child.nodesBetween(0,child.content.size,f,offset+1),offset+=child.nodeSize}}// :: (EditorState, ?EditorState) → ?Transaction
// Inspect all tables in the given state's document and return a
// transaction that fixes them, if necessary. If `oldState` was
// provided, that is assumed to hold a previous, known-good state,
// which will be used to avoid re-scanning unchanged parts of the
// document.
function fixTables$3(state,oldState){let tr,check=(node,pos)=>{"table"==node.type.spec.tableRole&&(tr=fixTable$3(state,node,pos,tr))};return oldState?oldState.doc!=state.doc&&changedDescendants$3(oldState.doc,state.doc,0,check):state.doc.descendants(check),tr}// : (EditorState, Node, number, ?Transaction) → ?Transaction
// Fix the given table, if necessary. Will append to the transaction
// it was given, if non-null, or create a new one if necessary.
function fixTable$3(state,table,tablePos,tr){let map=TableMap$3.get(table);if(!map.problems)return tr;tr||(tr=state.tr);// Track which rows we must add cells to, so that we can adjust that
// when fixing collisions.
let first,last,mustAdd=[];for(let i=0;i<map.height;i++)mustAdd.push(0);for(let i=0;i<map.problems.length;i++){let prob=map.problems[i];if("collision"==prob.type){let cell=table.nodeAt(prob.pos);for(let j=0;j<cell.attrs.rowspan;j++)mustAdd[prob.row+j]+=prob.n;tr.setNodeMarkup(tr.mapping.map(tablePos+1+prob.pos),null,removeColSpan$3(cell.attrs,cell.attrs.colspan-prob.n,prob.n))}else if("missing"==prob.type)mustAdd[prob.row]+=prob.n;else if("overlong_rowspan"==prob.type){let cell=table.nodeAt(prob.pos);tr.setNodeMarkup(tr.mapping.map(tablePos+1+prob.pos),null,setAttr(cell.attrs,"rowspan",cell.attrs.rowspan-prob.n))}else if("colwidth mismatch"==prob.type){let cell=table.nodeAt(prob.pos);tr.setNodeMarkup(tr.mapping.map(tablePos+1+prob.pos),null,setAttr(cell.attrs,"colwidth",prob.colwidth))}}for(let i=0;i<mustAdd.length;i++)mustAdd[i]&&(null==first&&(first=i),last=i);// Add the necessary cells, using a heuristic for whether to add the
// cells at the start or end of the rows (if it looks like a 'bite'
// was taken out of the table, add cells at the start of the row
// after the bite. Otherwise add them at the end).
for(let i=0,pos=tablePos+1;i<map.height;i++){let row=table.child(i),end=pos+row.nodeSize,add=mustAdd[i];if(add>0){let tableNodeType="cell";row.firstChild&&(tableNodeType=row.firstChild.type.spec.tableRole);let nodes=[];for(let j=0;j<add;j++)nodes.push(tableNodeTypes$3(state.schema)[tableNodeType].createAndFill());let side=0!=i&&first!=i-1||last!=i?end-1:pos+1;tr.insert(tr.mapping.map(side),nodes)}pos=end}return tr.setMeta(fixTablesKey$3,{fixTables:!0})}
// This file defines a number of table-related commands.
// map, table node, and table start offset to the object for
// convenience.
function selectedRect$3(state){let rect,sel=state.selection,$pos=selectionCell$3(state),table=$pos.node(-1),tableStart=$pos.start(-1),map=TableMap$3.get(table);return rect=sel instanceof CellSelection$3?map.rectBetween(sel.$anchorCell.pos-tableStart,sel.$headCell.pos-tableStart):map.findCell($pos.pos-tableStart),rect.tableStart=tableStart,rect.map=map,rect.table=table,rect}// Add a column at the given position in a table.
function addColumn$3(tr,{map:map,tableStart:tableStart,table:table},col){let refColumn=col>0?-1:0;columnIsHeader$3(map,table,col+refColumn)&&(refColumn=0==col||col==map.width?null:0);for(let row=0;row<map.height;row++){let index=row*map.width+col;// If this position falls inside a col-spanning cell
if(col>0&&col<map.width&&map.map[index-1]==map.map[index]){let pos=map.map[index],cell=table.nodeAt(pos);tr.setNodeMarkup(tr.mapping.map(tableStart+pos),null,addColSpan$3(cell.attrs,col-map.colCount(pos))),// Skip ahead if rowspan > 1
row+=cell.attrs.rowspan-1}else{let type=null==refColumn?tableNodeTypes$3(table.type.schema).cell:table.nodeAt(map.map[index+refColumn]).type,pos=map.positionAt(row,col,table);tr.insert(tr.mapping.map(tableStart+pos),type.createAndFill())}}return tr}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Command to add a column before the column with the selection.
function addColumnBefore$3(state,dispatch){if(!isInTable$3(state))return!1;if(dispatch){let rect=selectedRect$3(state);dispatch(addColumn$3(state.tr,rect,rect.left))}return!0}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Command to add a column after the column with the selection.
function addColumnAfter$3(state,dispatch){if(!isInTable$3(state))return!1;if(dispatch){let rect=selectedRect$3(state);dispatch(addColumn$3(state.tr,rect,rect.right))}return!0}function removeColumn$3(tr,{map:map,table:table,tableStart:tableStart},col){let mapStart=tr.mapping.maps.length;for(let row=0;row<map.height;){let index=row*map.width+col,pos=map.map[index],cell=table.nodeAt(pos);// If this is part of a col-spanning cell
if(col>0&&map.map[index-1]==pos||col<map.width-1&&map.map[index+1]==pos)tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart+pos),null,removeColSpan$3(cell.attrs,col-map.colCount(pos)));else{let start=tr.mapping.slice(mapStart).map(tableStart+pos);tr.delete(start,start+cell.nodeSize)}row+=cell.attrs.rowspan}}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Command function that removes the selected columns from a table.
function deleteColumn$3(state,dispatch){if(!isInTable$3(state))return!1;if(dispatch){let rect=selectedRect$3(state),tr=state.tr;if(0==rect.left&&rect.right==rect.map.width)return!1;for(let i=rect.right-1;;i--){if(removeColumn$3(tr,rect,i),i==rect.left)break;rect.table=rect.tableStart?tr.doc.nodeAt(rect.tableStart-1):tr.doc,rect.map=TableMap$3.get(rect.table)}dispatch(tr)}return!0}function rowIsHeader$3(map,table,row){let headerCell=tableNodeTypes$3(table.type.schema).header_cell;for(let col=0;col<map.width;col++)if(table.nodeAt(map.map[col+row*map.width]).type!=headerCell)return!1;return!0}function addRow$3(tr,{map:map,tableStart:tableStart,table:table},row){let rowPos=tableStart;for(let i=0;i<row;i++)rowPos+=table.child(i).nodeSize;let cells=[],refRow=row>0?-1:0;rowIsHeader$3(map,table,row+refRow)&&(refRow=0==row||row==map.height?null:0);for(let col=0,index=map.width*row;col<map.width;col++,index++)
// Covered by a rowspan cell
if(row>0&&row<map.height&&map.map[index]==map.map[index-map.width]){let pos=map.map[index],attrs=table.nodeAt(pos).attrs;tr.setNodeMarkup(tableStart+pos,null,setAttr(attrs,"rowspan",attrs.rowspan+1)),col+=attrs.colspan-1}else{let type=null==refRow?tableNodeTypes$3(table.type.schema).cell:table.nodeAt(map.map[index+refRow*map.width]).type;cells.push(type.createAndFill())}return tr.insert(rowPos,tableNodeTypes$3(table.type.schema).row.create(null,cells)),tr}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Add a table row before the selection.
function addRowBefore$3(state,dispatch){if(!isInTable$3(state))return!1;if(dispatch){let rect=selectedRect$3(state);dispatch(addRow$3(state.tr,rect,rect.top))}return!0}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Add a table row after the selection.
function addRowAfter$3(state,dispatch){if(!isInTable$3(state))return!1;if(dispatch){let rect=selectedRect$3(state);dispatch(addRow$3(state.tr,rect,rect.bottom))}return!0}function removeRow$3(tr,{map:map,table:table,tableStart:tableStart},row){let rowPos=0;for(let i=0;i<row;i++)rowPos+=table.child(i).nodeSize;let nextRow=rowPos+table.child(row).nodeSize,mapFrom=tr.mapping.maps.length;tr.delete(rowPos+tableStart,nextRow+tableStart);for(let col=0,index=row*map.width;col<map.width;col++,index++){let pos=map.map[index];if(row>0&&pos==map.map[index-map.width]){
// If this cell starts in the row above, simply reduce its rowspan
let attrs=table.nodeAt(pos).attrs;tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos+tableStart),null,setAttr(attrs,"rowspan",attrs.rowspan-1)),col+=attrs.colspan-1}else if(row<map.width&&pos==map.map[index+map.width]){
// Else, if it continues in the row below, it has to be moved down
let cell=table.nodeAt(pos),copy=cell.type.create(setAttr(cell.attrs,"rowspan",cell.attrs.rowspan-1),cell.content),newPos=map.positionAt(row+1,col,table);tr.insert(tr.mapping.slice(mapFrom).map(tableStart+newPos),copy),col+=cell.attrs.colspan-1}}}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Remove the selected rows from a table.
function deleteRow$3(state,dispatch){if(!isInTable$3(state))return!1;if(dispatch){let rect=selectedRect$3(state),tr=state.tr;if(0==rect.top&&rect.bottom==rect.map.height)return!1;for(let i=rect.bottom-1;;i--){if(removeRow$3(tr,rect,i),i==rect.top)break;rect.table=rect.tableStart?tr.doc.nodeAt(rect.tableStart-1):tr.doc,rect.map=TableMap$3.get(rect.table)}dispatch(tr)}return!0}function isEmpty$9(cell){let c=cell.content;return 1==c.childCount&&c.firstChild.isTextblock&&0==c.firstChild.childCount}function cellsOverlapRectangle$3({width:width,height:height,map:map},rect){let indexTop=rect.top*width+rect.left,indexLeft=indexTop,indexBottom=(rect.bottom-1)*width+rect.left,indexRight=indexTop+(rect.right-rect.left-1);for(let i=rect.top;i<rect.bottom;i++){if(rect.left>0&&map[indexLeft]==map[indexLeft-1]||rect.right<width&&map[indexRight]==map[indexRight+1])return!0;indexLeft+=width,indexRight+=width}for(let i=rect.left;i<rect.right;i++){if(rect.top>0&&map[indexTop]==map[indexTop-width]||rect.bottom<height&&map[indexBottom]==map[indexBottom+width])return!0;indexTop++,indexBottom++}return!1}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Merge the selected cells into a single cell. Only available when
// the selected cells' outline forms a rectangle.
function mergeCells$3(state,dispatch){let sel=state.selection;if(!(sel instanceof CellSelection$3)||sel.$anchorCell.pos==sel.$headCell.pos)return!1;let rect=selectedRect$3(state),{map:map}=rect;if(cellsOverlapRectangle$3(map,rect))return!1;if(dispatch){let mergedPos,mergedCell,tr=state.tr,seen={},content=Fragment$3.empty;for(let row=rect.top;row<rect.bottom;row++)for(let col=rect.left;col<rect.right;col++){let cellPos=map.map[row*map.width+col],cell=rect.table.nodeAt(cellPos);if(!seen[cellPos])if(seen[cellPos]=!0,null==mergedPos)mergedPos=cellPos,mergedCell=cell;else{isEmpty$9(cell)||(content=content.append(cell.content));let mapped=tr.mapping.map(cellPos+rect.tableStart);tr.delete(mapped,mapped+cell.nodeSize)}}if(tr.setNodeMarkup(mergedPos+rect.tableStart,null,setAttr(addColSpan$3(mergedCell.attrs,mergedCell.attrs.colspan,rect.right-rect.left-mergedCell.attrs.colspan),"rowspan",rect.bottom-rect.top)),content.size){let end=mergedPos+1+mergedCell.content.size,start=isEmpty$9(mergedCell)?mergedPos+1:end;tr.replaceWith(start+rect.tableStart,end+rect.tableStart,content)}tr.setSelection(new CellSelection$3(tr.doc.resolve(mergedPos+rect.tableStart))),dispatch(tr)}return!0}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Split a selected cell, whose rowpan or colspan is greater than one,
// into smaller cells. Use the first cell type for the new cells.
function splitCell$3(state,dispatch){const nodeTypes=tableNodeTypes$3(state.schema);return splitCellWithType$3((({node:node})=>nodeTypes[node.type.spec.tableRole]))(state,dispatch)}// :: (getCellType: ({ row: number, col: number, node: Node}) → NodeType) → (EditorState, dispatch: ?(tr: Transaction)) → bool
// Split a selected cell, whose rowpan or colspan is greater than one,
// into smaller cells with the cell type (th, td) returned by getType function.
function splitCellWithType$3(getCellType){return(state,dispatch)=>{let cellNode,cellPos,sel=state.selection;if(sel instanceof CellSelection$3){if(sel.$anchorCell.pos!=sel.$headCell.pos)return!1;cellNode=sel.$anchorCell.nodeAfter,cellPos=sel.$anchorCell.pos}else{if(cellNode=cellWrapping$3(sel.$from),!cellNode)return!1;cellPos=cellAround$3(sel.$from).pos}if(1==cellNode.attrs.colspan&&1==cellNode.attrs.rowspan)return!1;if(dispatch){let baseAttrs=cellNode.attrs,attrs=[],colwidth=baseAttrs.colwidth;baseAttrs.rowspan>1&&(baseAttrs=setAttr(baseAttrs,"rowspan",1)),baseAttrs.colspan>1&&(baseAttrs=setAttr(baseAttrs,"colspan",1));let lastCell,rect=selectedRect$3(state),tr=state.tr;for(let i=0;i<rect.right-rect.left;i++)attrs.push(colwidth?setAttr(baseAttrs,"colwidth",colwidth&&colwidth[i]?[colwidth[i]]:null):baseAttrs);for(let row=rect.top;row<rect.bottom;row++){let pos=rect.map.positionAt(row,rect.left,rect.table);row==rect.top&&(pos+=cellNode.nodeSize);for(let col=rect.left,i=0;col<rect.right;col++,i++)col==rect.left&&row==rect.top||tr.insert(lastCell=tr.mapping.map(pos+rect.tableStart,1),getCellType({node:cellNode,row:row,col:col}).createAndFill(attrs[i]))}tr.setNodeMarkup(cellPos,getCellType({node:cellNode,row:rect.top,col:rect.left}),attrs[0]),sel instanceof CellSelection$3&&tr.setSelection(new CellSelection$3(tr.doc.resolve(sel.$anchorCell.pos),lastCell&&tr.doc.resolve(lastCell))),dispatch(tr)}return!0}}// :: (string, any) → (EditorState, dispatch: ?(tr: Transaction)) → bool
// Returns a command that sets the given attribute to the given value,
// and is only available when the currently selected cell doesn't
// already have that attribute set to that value.
function setCellAttr$3(name,value){return function(state,dispatch){if(!isInTable$3(state))return!1;let $cell=selectionCell$3(state);if($cell.nodeAfter.attrs[name]===value)return!1;if(dispatch){let tr=state.tr;state.selection instanceof CellSelection$3?state.selection.forEachCell(((node,pos)=>{node.attrs[name]!==value&&tr.setNodeMarkup(pos,null,setAttr(node.attrs,name,value))})):tr.setNodeMarkup($cell.pos,null,setAttr($cell.nodeAfter.attrs,name,value)),dispatch(tr)}return!0}}function deprecated_toggleHeader$3(type){return function(state,dispatch){if(!isInTable$3(state))return!1;if(dispatch){let types=tableNodeTypes$3(state.schema),rect=selectedRect$3(state),tr=state.tr,cells=rect.map.cellsInRect("column"==type?new Rect(rect.left,0,rect.right,rect.map.height):"row"==type?new Rect(0,rect.top,rect.map.width,rect.bottom):rect),nodes=cells.map((pos=>rect.table.nodeAt(pos)));for(let i=0;i<cells.length;i++)nodes[i].type==types.header_cell&&tr.setNodeMarkup(rect.tableStart+cells[i],types.cell,nodes[i].attrs);if(0==tr.steps.length)for(let i=0;i<cells.length;i++)tr.setNodeMarkup(rect.tableStart+cells[i],types.header_cell,nodes[i].attrs);dispatch(tr)}return!0}}function isHeaderEnabledByType$3(type,rect,types){
// Get cell positions for first row or first column
const cellPositions=rect.map.cellsInRect({left:0,top:0,right:"row"==type?rect.map.width:1,bottom:"column"==type?rect.map.height:1});for(let i=0;i<cellPositions.length;i++){const cell=rect.table.nodeAt(cellPositions[i]);if(cell&&cell.type!==types.header_cell)return!1}return!0}// :: (string, ?{ useDeprecatedLogic: bool }) → (EditorState, dispatch: ?(tr: Transaction)) → bool
// Toggles between row/column header and normal cells (Only applies to first row/column).
// For deprecated behavior pass `useDeprecatedLogic` in options with true.
function toggleHeader$3(type,options){return options=options||{useDeprecatedLogic:!1},options.useDeprecatedLogic?deprecated_toggleHeader$3(type):function(state,dispatch){if(!isInTable$3(state))return!1;if(dispatch){let types=tableNodeTypes$3(state.schema),rect=selectedRect$3(state),tr=state.tr,isHeaderRowEnabled=isHeaderEnabledByType$3("row",rect,types),isHeaderColumnEnabled=isHeaderEnabledByType$3("column",rect,types),isHeaderEnabled="column"===type?isHeaderRowEnabled:"row"===type&&isHeaderColumnEnabled,selectionStartsAt=isHeaderEnabled?1:0,cellsRect="column"==type?new Rect(0,selectionStartsAt,1,rect.map.height):"row"==type?new Rect(selectionStartsAt,0,rect.map.width,1):rect,newType="column"==type?isHeaderColumnEnabled?types.cell:types.header_cell:"row"==type?isHeaderRowEnabled?types.cell:types.header_cell:types.cell;rect.map.cellsInRect(cellsRect).forEach((relativeCellPos=>{const cellPos=relativeCellPos+rect.tableStart,cell=tr.doc.nodeAt(cellPos);cell&&tr.setNodeMarkup(cellPos,newType,cell.attrs)})),dispatch(tr)}return!0}}// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Toggles whether the selected row contains header cells.
toggleHeader$3("row",{useDeprecatedLogic:!0}),// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Toggles whether the selected column contains header cells.
toggleHeader$3("column",{useDeprecatedLogic:!0});// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Toggles whether the selected cells are header cells.
let toggleHeaderCell$3=toggleHeader$3("cell",{useDeprecatedLogic:!0});function findNextCell$3($cell,dir){if(dir<0){let before=$cell.nodeBefore;if(before)return $cell.pos-before.nodeSize;for(let row=$cell.index(-1)-1,rowEnd=$cell.before();row>=0;row--){let rowNode=$cell.node(-1).child(row);if(rowNode.childCount)return rowEnd-1-rowNode.lastChild.nodeSize;rowEnd-=rowNode.nodeSize}}else{if($cell.index()<$cell.parent.childCount-1)return $cell.pos+$cell.nodeAfter.nodeSize;let table=$cell.node(-1);for(let row=$cell.indexAfter(-1),rowStart=$cell.after();row<table.childCount;row++){let rowNode=table.child(row);if(rowNode.childCount)return rowStart+1;rowStart+=rowNode.nodeSize}}}// :: (number) → (EditorState, dispatch: ?(tr: Transaction)) → bool
// Returns a command for selecting the next (direction=1) or previous
// (direction=-1) cell in a table.
function goToNextCell$3(direction){return function(state,dispatch){if(!isInTable$3(state))return!1;let cell=findNextCell$3(selectionCell$3(state),direction);if(null!=cell){if(dispatch){let $cell=state.doc.resolve(cell);dispatch(state.tr.setSelection(TextSelection$3.between($cell,moveCellForward$3($cell))).scrollIntoView())}return!0}}}// :: (EditorState, ?(tr: Transaction)) → bool
// Deletes the table around the selection, if any.
function deleteTable$3(state,dispatch){let $pos=state.selection.$anchor;for(let d=$pos.depth;d>0;d--){let node=$pos.node(d);if("table"==node.type.spec.tableRole)return dispatch&&dispatch(state.tr.delete($pos.before(d),$pos.after(d)).scrollIntoView()),!0}return!1}class TableView$1$3{constructor(node,cellMinWidth){this.node=node,this.cellMinWidth=cellMinWidth,this.dom=document.createElement("div"),this.dom.className="tableWrapper",this.table=this.dom.appendChild(document.createElement("table")),this.colgroup=this.table.appendChild(document.createElement("colgroup")),updateColumns$1(node,this.colgroup,this.table,cellMinWidth),this.contentDOM=this.table.appendChild(document.createElement("tbody"))}update(node){return node.type==this.node.type&&(this.node=node,updateColumns$1(node,this.colgroup,this.table,this.cellMinWidth),!0)}ignoreMutation(record){return"attributes"==record.type&&(record.target==this.table||this.colgroup.contains(record.target))}}function updateColumns$1(node,colgroup,table,cellMinWidth,overrideCol,overrideValue){let totalWidth=0,fixedWidth=!0,nextDOM=colgroup.firstChild,row=node.firstChild;for(let i=0,col=0;i<row.childCount;i++){let{colspan:colspan,colwidth:colwidth}=row.child(i).attrs;for(let j=0;j<colspan;j++,col++){let hasWidth=overrideCol==col?overrideValue:colwidth&&colwidth[j],cssWidth=hasWidth?hasWidth+"px":"";totalWidth+=hasWidth||cellMinWidth,hasWidth||(fixedWidth=!1),nextDOM?(nextDOM.style.width!=cssWidth&&(nextDOM.style.width=cssWidth),nextDOM=nextDOM.nextSibling):colgroup.appendChild(document.createElement("col")).style.width=cssWidth}}while(nextDOM){let after=nextDOM.nextSibling;nextDOM.parentNode.removeChild(nextDOM),nextDOM=after}fixedWidth?(table.style.width=totalWidth+"px",table.style.minWidth=""):(table.style.width="",table.style.minWidth=totalWidth+"px")}const key=new PluginKey$3("tableColumnResizing");function columnResizing$3({handleWidth:handleWidth=5,cellMinWidth:cellMinWidth=25,View:View=TableView$1$3,lastColumnResizable:lastColumnResizable=!0}={}){let plugin=new Plugin$3({key:key,state:{init(_,state){return this.spec.props.nodeViews[tableNodeTypes$3(state.schema).table.name]=(node,view)=>new View(node,cellMinWidth,view),new ResizeState$3(-1,!1)},apply(tr,prev){return prev.apply(tr)}},props:{attributes(state){let pluginState=key.getState(state);return pluginState.activeHandle>-1?{class:"resize-cursor"}:null},handleDOMEvents:{mousemove(view,event){handleMouseMove$3(view,event,handleWidth,cellMinWidth,lastColumnResizable)},mouseleave(view){handleMouseLeave$3(view)},mousedown(view,event){handleMouseDown$4(view,event,cellMinWidth)}},decorations(state){let pluginState=key.getState(state);if(pluginState.activeHandle>-1)return handleDecorations$3(state,pluginState.activeHandle)},nodeViews:{}}});return plugin}class ResizeState$3{constructor(activeHandle,dragging){this.activeHandle=activeHandle,this.dragging=dragging}apply(tr){let state=this,action=tr.getMeta(key);if(action&&null!=action.setHandle)return new ResizeState$3(action.setHandle,null);if(action&&void 0!==action.setDragging)return new ResizeState$3(state.activeHandle,action.setDragging);if(state.activeHandle>-1&&tr.docChanged){let handle=tr.mapping.map(state.activeHandle,-1);pointsAtCell$3(tr.doc.resolve(handle))||(handle=null),state=new ResizeState$3(handle,state.dragging)}return state}}function handleMouseMove$3(view,event,handleWidth,cellMinWidth,lastColumnResizable){let pluginState=key.getState(view.state);if(!pluginState.dragging){let target=domCellAround$3(event.target),cell=-1;if(target){let{left:left,right:right}=target.getBoundingClientRect();event.clientX-left<=handleWidth?cell=edgeCell$3(view,event,"left"):right-event.clientX<=handleWidth&&(cell=edgeCell$3(view,event,"right"))}if(cell!=pluginState.activeHandle){if(!lastColumnResizable&&-1!==cell){let $cell=view.state.doc.resolve(cell),table=$cell.node(-1),map=TableMap$3.get(table),start=$cell.start(-1),col=map.colCount($cell.pos-start)+$cell.nodeAfter.attrs.colspan-1;if(col==map.width-1)return}updateHandle$3(view,cell)}}}function handleMouseLeave$3(view){let pluginState=key.getState(view.state);pluginState.activeHandle>-1&&!pluginState.dragging&&updateHandle$3(view,-1)}function handleMouseDown$4(view,event,cellMinWidth){let pluginState=key.getState(view.state);if(-1==pluginState.activeHandle||pluginState.dragging)return!1;let cell=view.state.doc.nodeAt(pluginState.activeHandle),width=currentColWidth$3(view,pluginState.activeHandle,cell.attrs);function finish(event){window.removeEventListener("mouseup",finish),window.removeEventListener("mousemove",move);let pluginState=key.getState(view.state);pluginState.dragging&&(updateColumnWidth$3(view,pluginState.activeHandle,draggedWidth$3(pluginState.dragging,event,cellMinWidth)),view.dispatch(view.state.tr.setMeta(key,{setDragging:null})))}function move(event){if(!event.which)return finish(event);let pluginState=key.getState(view.state),dragged=draggedWidth$3(pluginState.dragging,event,cellMinWidth);displayColumnWidth$3(view,pluginState.activeHandle,dragged,cellMinWidth)}return view.dispatch(view.state.tr.setMeta(key,{setDragging:{startX:event.clientX,startWidth:width}})),window.addEventListener("mouseup",finish),window.addEventListener("mousemove",move),event.preventDefault(),!0}function currentColWidth$3(view,cellPos,{colspan:colspan,colwidth:colwidth}){let width=colwidth&&colwidth[colwidth.length-1];if(width)return width;let dom=view.domAtPos(cellPos),node=dom.node.childNodes[dom.offset],domWidth=node.offsetWidth,parts=colspan;if(colwidth)for(let i=0;i<colspan;i++)colwidth[i]&&(domWidth-=colwidth[i],parts--);return domWidth/parts}function domCellAround$3(target){while(target&&"TD"!=target.nodeName&&"TH"!=target.nodeName)target=target.classList.contains("ProseMirror")?null:target.parentNode;return target}function edgeCell$3(view,event,side){let found=view.posAtCoords({left:event.clientX,top:event.clientY});if(!found)return-1;let{pos:pos}=found,$cell=cellAround$3(view.state.doc.resolve(pos));if(!$cell)return-1;if("right"==side)return $cell.pos;let map=TableMap$3.get($cell.node(-1)),start=$cell.start(-1),index=map.map.indexOf($cell.pos-start);return index%map.width==0?-1:start+map.map[index-1]}function draggedWidth$3(dragging,event,cellMinWidth){let offset=event.clientX-dragging.startX;return Math.max(cellMinWidth,dragging.startWidth+offset)}function updateHandle$3(view,value){view.dispatch(view.state.tr.setMeta(key,{setHandle:value}))}function updateColumnWidth$3(view,cell,width){let $cell=view.state.doc.resolve(cell),table=$cell.node(-1),map=TableMap$3.get(table),start=$cell.start(-1),col=map.colCount($cell.pos-start)+$cell.nodeAfter.attrs.colspan-1,tr=view.state.tr;for(let row=0;row<map.height;row++){let mapIndex=row*map.width+col;// Rowspanning cell that has already been handled
if(row&&map.map[mapIndex]==map.map[mapIndex-map.width])continue;let pos=map.map[mapIndex],{attrs:attrs}=table.nodeAt(pos),index=1==attrs.colspan?0:col-map.colCount(pos);if(attrs.colwidth&&attrs.colwidth[index]==width)continue;let colwidth=attrs.colwidth?attrs.colwidth.slice():zeroes$3(attrs.colspan);colwidth[index]=width,tr.setNodeMarkup(start+pos,null,setAttr(attrs,"colwidth",colwidth))}tr.docChanged&&view.dispatch(tr)}function displayColumnWidth$3(view,cell,width,cellMinWidth){let $cell=view.state.doc.resolve(cell),table=$cell.node(-1),start=$cell.start(-1),col=TableMap$3.get(table).colCount($cell.pos-start)+$cell.nodeAfter.attrs.colspan-1,dom=view.domAtPos($cell.start(-1)).node;while("TABLE"!=dom.nodeName)dom=dom.parentNode;updateColumns$1(table,dom.firstChild,dom,cellMinWidth,col,width)}function zeroes$3(n){let result=[];for(let i=0;i<n;i++)result.push(0);return result}function handleDecorations$3(state,cell){let decorations=[],$cell=state.doc.resolve(cell),table=$cell.node(-1),map=TableMap$3.get(table),start=$cell.start(-1),col=map.colCount($cell.pos-start)+$cell.nodeAfter.attrs.colspan;for(let row=0;row<map.height;row++){let index=col+row*map.width-1;// For positions that are have either a different cell or the end
// of the table to their right, and either the top of the table or
// a different cell above them, add a decoration
if((col==map.width||map.map[index]!=map.map[index+1])&&(0==row||map.map[index-1]!=map.map[index-1-map.width])){let cellPos=map.map[index],pos=start+cellPos+table.nodeAt(cellPos).nodeSize-1,dom=document.createElement("div");dom.className="column-resize-handle",decorations.push(Decoration$3.widget(pos,dom))}}return DecorationSet$3.create(state.doc,decorations)}
// This file defines a plugin that handles the drawing of cell

// Creates a [plugin](http://prosemirror.net/docs/ref/#state.Plugin)
// that, when added to an editor, enables cell-selection, handles
// cell-based copy/paste, and makes sure tables stay well-formed (each
// row has the same width, and cells don't overlap).

// You should probably put this plugin near the end of your array of
// plugins, since it handles mouse and arrow key events in tables
// rather broadly, and other plugins, like the gap cursor or the
// column-width dragging plugin, might want to get a turn first to
// perform more specific behavior.
function tableEditing$3({allowTableNodeSelection:allowTableNodeSelection=!1}={}){return new Plugin$3({key:key$1,
// This piece of state is used to remember when a mouse-drag
// cell-selection is happening, so that it can continue even as
// transactions (which might move its anchor cell) come in.
state:{init(){return null},apply(tr,cur){let set=tr.getMeta(key$1);if(null!=set)return-1==set?null:set;if(null==cur||!tr.docChanged)return cur;let{deleted:deleted,pos:pos}=tr.mapping.mapResult(cur);return deleted?null:pos}},props:{decorations:drawCellSelection$3,handleDOMEvents:{mousedown:handleMouseDown$1},createSelectionBetween(view){if(null!=key$1.getState(view.state))return view.state.selection},handleTripleClick:handleTripleClick$4,handleKeyDown:handleKeyDown$3,handlePaste:handlePaste$3},appendTransaction(_,oldState,state){return normalizeSelection$3(state,fixTables$3(state,oldState),allowTableNodeSelection)}})}function updateColumns$4(node,colgroup,table,cellMinWidth,overrideCol,overrideValue){let totalWidth=0,fixedWidth=!0,nextDOM=colgroup.firstChild;const row=node.firstChild;for(let i=0,col=0;i<row.childCount;i+=1){const{colspan:colspan,colwidth:colwidth}=row.child(i).attrs;for(let j=0;j<colspan;j+=1,col+=1){const hasWidth=overrideCol===col?overrideValue:colwidth&&colwidth[j],cssWidth=hasWidth?`${hasWidth}px`:"";totalWidth+=hasWidth||cellMinWidth,hasWidth||(fixedWidth=!1),nextDOM?(nextDOM.style.width!==cssWidth&&(nextDOM.style.width=cssWidth),nextDOM=nextDOM.nextSibling):colgroup.appendChild(document.createElement("col")).style.width=cssWidth}}while(nextDOM){const after=nextDOM.nextSibling;nextDOM.parentNode.removeChild(nextDOM),nextDOM=after}fixedWidth?(table.style.width=`${totalWidth}px`,table.style.minWidth=""):(table.style.width="",table.style.minWidth=`${totalWidth}px`)}class TableView$4{constructor(node,cellMinWidth){this.node=node,this.cellMinWidth=cellMinWidth,this.dom=document.createElement("div"),this.dom.className="tableWrapper",this.table=this.dom.appendChild(document.createElement("table")),this.colgroup=this.table.appendChild(document.createElement("colgroup")),updateColumns$4(node,this.colgroup,this.table,cellMinWidth),this.contentDOM=this.table.appendChild(document.createElement("tbody"))}update(node){return node.type===this.node.type&&(this.node=node,updateColumns$4(node,this.colgroup,this.table,this.cellMinWidth),!0)}ignoreMutation(mutation){return"attributes"===mutation.type&&(mutation.target===this.table||this.colgroup.contains(mutation.target))}}function createCell$3(cellType,cellContent){return cellContent?cellType.createChecked(null,cellContent):cellType.createAndFill()}function getTableNodeTypes$3(schema){if(schema.cached.tableNodeTypes)return schema.cached.tableNodeTypes;const roles={};return Object.keys(schema.nodes).forEach((type=>{const nodeType=schema.nodes[type];nodeType.spec.tableRole&&(roles[nodeType.spec.tableRole]=nodeType)})),schema.cached.tableNodeTypes=roles,roles}function createTable$3(schema,rowsCount,colsCount,withHeaderRow,cellContent){const types=getTableNodeTypes$3(schema),headerCells=[],cells=[];for(let index=0;index<colsCount;index+=1){const cell=createCell$3(types.cell,cellContent);if(cell&&cells.push(cell),withHeaderRow){const headerCell=createCell$3(types.header_cell,cellContent);headerCell&&headerCells.push(headerCell)}}const rows=[];for(let index=0;index<rowsCount;index+=1)rows.push(types.row.createChecked(null,withHeaderRow&&0===index?headerCells:cells));return types.table.createChecked(null,rows)}function isCellSelection$3(value){return value instanceof CellSelection$3}const deleteTableWhenAllCellsSelected$3=({editor:editor})=>{const{selection:selection}=editor.state;if(!isCellSelection$3(selection))return!1;let cellCount=0;const table=findParentNodeClosestToPos$3(selection.ranges[0].$from,(node=>"table"===node.type.name));null===table||void 0===table||table.node.descendants((node=>{if("table"===node.type.name)return!1;["tableCell","tableHeader"].includes(node.type.name)&&(cellCount+=1)}));const allCellsSelected=cellCount===selection.ranges.length;return!!allCellsSelected&&(editor.commands.deleteTable(),!0)};Node$1$3.create({name:"table",
// @ts-ignore
addOptions(){return{HTMLAttributes:{},resizable:!1,handleWidth:5,cellMinWidth:25,
// TODO: fix
View:TableView$4,lastColumnResizable:!0,allowTableNodeSelection:!1}},content:"tableRow+",tableRole:"table",isolating:!0,group:"block",parseHTML(){return[{tag:"table"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["table",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes),["tbody",0]]},addCommands(){return{insertTable:({rows:rows=3,cols:cols=3,withHeaderRow:withHeaderRow=!0}={})=>({tr:tr,dispatch:dispatch,editor:editor})=>{const node=createTable$3(editor.schema,rows,cols,withHeaderRow);if(dispatch){const offset=tr.selection.anchor+1;tr.replaceSelectionWith(node).scrollIntoView().setSelection(TextSelection$3.near(tr.doc.resolve(offset)))}return!0},addColumnBefore:()=>({state:state,dispatch:dispatch})=>addColumnBefore$3(state,dispatch),addColumnAfter:()=>({state:state,dispatch:dispatch})=>addColumnAfter$3(state,dispatch),deleteColumn:()=>({state:state,dispatch:dispatch})=>deleteColumn$3(state,dispatch),addRowBefore:()=>({state:state,dispatch:dispatch})=>addRowBefore$3(state,dispatch),addRowAfter:()=>({state:state,dispatch:dispatch})=>addRowAfter$3(state,dispatch),deleteRow:()=>({state:state,dispatch:dispatch})=>deleteRow$3(state,dispatch),deleteTable:()=>({state:state,dispatch:dispatch})=>deleteTable$3(state,dispatch),mergeCells:()=>({state:state,dispatch:dispatch})=>mergeCells$3(state,dispatch),splitCell:()=>({state:state,dispatch:dispatch})=>splitCell$3(state,dispatch),toggleHeaderColumn:()=>({state:state,dispatch:dispatch})=>toggleHeader$3("column")(state,dispatch),toggleHeaderRow:()=>({state:state,dispatch:dispatch})=>toggleHeader$3("row")(state,dispatch),toggleHeaderCell:()=>({state:state,dispatch:dispatch})=>toggleHeaderCell$3(state,dispatch),mergeOrSplit:()=>({state:state,dispatch:dispatch})=>!!mergeCells$3(state,dispatch)||splitCell$3(state,dispatch),setCellAttribute:(name,value)=>({state:state,dispatch:dispatch})=>setCellAttr$3(name,value)(state,dispatch),goToNextCell:()=>({state:state,dispatch:dispatch})=>goToNextCell$3(1)(state,dispatch),goToPreviousCell:()=>({state:state,dispatch:dispatch})=>goToNextCell$3(-1)(state,dispatch),fixTables:()=>({state:state,dispatch:dispatch})=>(dispatch&&fixTables$3(state),!0),setCellSelection:position=>({tr:tr,dispatch:dispatch})=>{if(dispatch){const selection=CellSelection$3.create(tr.doc,position.anchorCell,position.headCell);
// @ts-ignore
tr.setSelection(selection)}return!0}}},addKeyboardShortcuts(){return{Tab:()=>!!this.editor.commands.goToNextCell()||!!this.editor.can().addRowAfter()&&this.editor.chain().addRowAfter().goToNextCell().run(),"Shift-Tab":()=>this.editor.commands.goToPreviousCell(),Backspace:deleteTableWhenAllCellsSelected$3,"Mod-Backspace":deleteTableWhenAllCellsSelected$3,Delete:deleteTableWhenAllCellsSelected$3,"Mod-Delete":deleteTableWhenAllCellsSelected$3}},addProseMirrorPlugins(){const isResizable=this.options.resizable&&this.editor.isEditable;return[...isResizable?[columnResizing$3({handleWidth:this.options.handleWidth,cellMinWidth:this.options.cellMinWidth,View:this.options.View,
// TODO: PR for @types/prosemirror-tables
// @ts-ignore (incorrect type)
lastColumnResizable:this.options.lastColumnResizable})]:[],tableEditing$3({allowTableNodeSelection:this.options.allowTableNodeSelection})]},extendNodeSchema(extension){const context={name:extension.name,options:extension.options,storage:extension.storage};return{tableRole:callOrReturn$3(getExtensionField$3(extension,"tableRole",context))}}}),Node$1$3.create({name:"tableRow",addOptions(){return{HTMLAttributes:{}}},content:"(tableCell | tableHeader)*",tableRole:"row",parseHTML(){return[{tag:"tr"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["tr",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes),0]}});const TableCell$3=Node$1$3.create({name:"tableCell",addOptions(){return{HTMLAttributes:{}}},content:"block+",addAttributes(){return{colspan:{default:1},rowspan:{default:1},colwidth:{default:null,parseHTML:element=>{const colwidth=element.getAttribute("colwidth"),value=colwidth?[parseInt(colwidth,10)]:null;return value}}}},tableRole:"cell",isolating:!0,parseHTML(){return[{tag:"td"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["td",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes),0]}}),TableHeader$3=Node$1$3.create({name:"tableHeader",addOptions(){return{HTMLAttributes:{}}},content:"block+",addAttributes(){return{colspan:{default:1},rowspan:{default:1},colwidth:{default:null,parseHTML:element=>{const colwidth=element.getAttribute("colwidth"),value=colwidth?[parseInt(colwidth,10)]:null;return value}}}},tableRole:"header_cell",isolating:!0,parseHTML(){return[{tag:"th"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["th",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes),0]}});Extension$3.create({name:"placeholder",addOptions(){return{emptyEditorClass:"is-editor-empty",emptyNodeClass:"is-empty",placeholder:"Write something …",showOnlyWhenEditable:!0,showOnlyCurrent:!0,includeChildren:!1}},addProseMirrorPlugins(){return[new Plugin$3({props:{decorations:({doc:doc,selection:selection})=>{const active=this.editor.isEditable||!this.options.showOnlyWhenEditable,{anchor:anchor}=selection,decorations=[];return active?(doc.descendants(((node,pos)=>{const hasAnchor=anchor>=pos&&anchor<=pos+node.nodeSize,isEmpty=!node.isLeaf&&!node.childCount;if((hasAnchor||!this.options.showOnlyCurrent)&&isEmpty){const classes=[this.options.emptyNodeClass];this.editor.isEmpty&&classes.push(this.options.emptyEditorClass);const decoration=Decoration$3.node(pos,pos+node.nodeSize,{class:classes.join(" "),"data-placeholder":"function"===typeof this.options.placeholder?this.options.placeholder({editor:this.editor,node:node,pos:pos,hasAnchor:hasAnchor}):this.options.placeholder});decorations.push(decoration)}return this.options.includeChildren})),DecorationSet$3.create(doc,decorations)):null}}})]}});const inputRegex$2$3=/^\s*>\s$/;Node$1$3.create({name:"blockquote",addOptions(){return{HTMLAttributes:{}}},content:"block+",group:"block",defining:!0,parseHTML(){return[{tag:"blockquote"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["blockquote",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setBlockquote:()=>({commands:commands})=>commands.wrapIn(this.name),toggleBlockquote:()=>({commands:commands})=>commands.toggleWrap(this.name),unsetBlockquote:()=>({commands:commands})=>commands.lift(this.name)}},addKeyboardShortcuts(){return{"Mod-Shift-b":()=>this.editor.commands.toggleBlockquote()}},addInputRules(){return[wrappingInputRule$3({find:inputRegex$2$3,type:this.type})]}}),Extension$3.create({name:"color",addOptions(){return{types:["textStyle"]}},addGlobalAttributes(){return[{types:this.options.types,attributes:{color:{default:null,parseHTML:element=>{var _a;return null===(_a=element.style.color)||void 0===_a?void 0:_a.replace(/['"]+/g,"")},renderHTML:attributes=>attributes.color?{style:`color: ${attributes.color}`}:{}}}}]},addCommands(){return{setColor:color=>({chain:chain})=>chain().setMark("textStyle",{color:color}).run(),unsetColor:()=>({chain:chain})=>chain().setMark("textStyle",{color:null}).removeEmptyTextStyle().run()}}});const HardBreak$1$3=Node$1$3.create({name:"hardBreak",addOptions(){return{keepMarks:!0,HTMLAttributes:{}}},inline:!0,group:"inline",selectable:!1,parseHTML(){return[{tag:"br"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["br",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes)]},renderText(){return"\n"},addCommands(){return{setHardBreak:()=>({commands:commands,chain:chain,state:state,editor:editor})=>commands.first([()=>commands.exitCode(),()=>commands.command((()=>{const{selection:selection,storedMarks:storedMarks}=state;if(selection.$from.parent.type.spec.isolating)return!1;const{keepMarks:keepMarks}=this.options,{splittableMarks:splittableMarks}=editor.extensionManager,marks=storedMarks||selection.$to.parentOffset&&selection.$from.marks();return chain().insertContent({type:this.name}).command((({tr:tr,dispatch:dispatch})=>{if(dispatch&&marks&&keepMarks){const filteredMarks=marks.filter((mark=>splittableMarks.includes(mark.type.name)));tr.ensureMarks(filteredMarks)}return!0})).run()}))])}},addKeyboardShortcuts(){return{"Mod-Enter":()=>this.editor.commands.setHardBreak(),"Shift-Enter":()=>this.editor.commands.setHardBreak()}}});HardBreak$1$3.extend({addKeyboardShortcuts(){return{Enter:()=>this.editor.commands.setHardBreak()}}}),Node$1$3.create({name:"horizontalRule",addOptions(){return{HTMLAttributes:{}}},group:"block",parseHTML(){return[{tag:"hr"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["hr",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes)]},addCommands(){return{setHorizontalRule:()=>({chain:chain})=>chain().insertContent({type:this.name}).command((({tr:tr,dispatch:dispatch})=>{var _a;if(dispatch){const{$to:$to}=tr.selection,posAfter=$to.end();if($to.nodeAfter)tr.setSelection(TextSelection$3.create(tr.doc,$to.pos));else{
// add node after horizontal rule if it’s the end of the document
const node=null===(_a=$to.parent.type.contentMatch.defaultType)||void 0===_a?void 0:_a.create();node&&(tr.insert(posAfter,node),tr.setSelection(TextSelection$3.create(tr.doc,posAfter)))}tr.scrollIntoView()}return!0})).run()}},addInputRules(){return[nodeInputRule$3({find:/^(?:---|—-|___\s|\*\*\*\s)$/,type:this.type})]}});const inputRegex$1$3=/(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/,Image$1$3=Node$1$3.create({name:"image",addOptions(){return{inline:!1,allowBase64:!1,HTMLAttributes:{}}},inline(){return this.options.inline},group(){return this.options.inline?"inline":"block"},draggable:!0,addAttributes(){return{src:{default:null},alt:{default:null},title:{default:null}}},parseHTML(){return[{tag:this.options.allowBase64?"img[src]":'img[src]:not([src^="data:"])'}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["img",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes)]},addCommands(){return{setImage:options=>({commands:commands})=>commands.insertContent({type:this.name,attrs:options})}},addInputRules(){return[nodeInputRule$3({find:inputRegex$1$3,type:this.type,getAttributes:match=>{const[,,alt,src,title]=match;return{src:src,alt:alt,title:title}}})]}});Image$1$3.extend({addOptions(){return{inline:!1,allowBase64:!0,HTMLAttributes:{}}},addAttributes(){return{src:{default:null},alt:{default:null},title:{default:null},style:{default:null}}}}),Extension$3.create({name:"fontSize",addOptions(){return{types:["textStyle"]}},addGlobalAttributes(){return[{types:this.options.types,attributes:{fontSize:{default:null,parseHTML:element=>element.style.fontSize.replace(/['"]+/g,""),renderHTML:attributes=>attributes.fontSize?{style:`font-size: ${attributes.fontSize}`}:{}}}}]},addCommands(){return{setFontSize:fontSize=>({chain:chain})=>chain().setMark("textStyle",{fontSize:fontSize+"px"}).run(),unsetFontSize:()=>({chain:chain})=>chain().setMark("textStyle",{fontSize:null}).removeEmptyTextStyle().run()}}});const inputRegex$8=/(?:^|\s)((?:==)((?:[^~=]+))(?:==))$/,pasteRegex$4=/(?:^|\s)((?:==)((?:[^~=]+))(?:==))/g;
/**
 * Finite State Machine generation utilities
 */
/**
 * Define a basic state machine state. j is the list of character transitions,
 * jr is the list of regex-match transitions, jd is the default state to
 * transition to t is the accepting token type, if any. If this is the terminal
 * state, then it does not emit a token.
 * @param {string|class} token to emit
 */
function State$3(token){this.j={},// IMPLEMENTATION 1
// this.j = []; // IMPLEMENTATION 2
this.jr=[],this.jd=null,this.t=token}
/**
 * Take the transition from this state to the next one on the given input.
 * If this state does not exist deterministically, will create it.
 *
 * @param {string} input character or token to transition on
 * @param {string|class} [token] token or multi-token to emit when reaching
 * this state
 */Mark$4.create({name:"highlight",addOptions(){return{multicolor:!1,HTMLAttributes:{}}},addAttributes(){return this.options.multicolor?{color:{default:null,parseHTML:element=>element.getAttribute("data-color")||element.style.backgroundColor,renderHTML:attributes=>attributes.color?{"data-color":attributes.color,style:`background-color: ${attributes.color}`}:{}}}:{}},parseHTML(){return[{tag:"mark"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["mark",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setHighlight:attributes=>({commands:commands})=>commands.setMark(this.name,attributes),toggleHighlight:attributes=>({commands:commands})=>commands.toggleMark(this.name,attributes),unsetHighlight:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-Shift-h":()=>this.editor.commands.toggleHighlight()}},addInputRules(){return[markInputRule$3({find:inputRegex$8,type:this.type})]},addPasteRules(){return[markPasteRule$3({find:pasteRegex$4,type:this.type})]}}),TableHeader$3.extend({addAttributes(){return{colspan:{default:1},rowspan:{default:1},colwidth:{default:null,parseHTML:element=>{const colwidth=element.getAttribute("colwidth"),value=colwidth?[parseInt(colwidth,10)]:null;return value},renderHTML:()=>({style:"border: 1px solid #d0d9e2;color: #2f4058;font-weight: 400;background-color: #fafbff;"})}}},parseHTML(){return[{tag:"th"}]}}),TableCell$3.extend({addAttributes(){return{colspan:{default:1},rowspan:{default:1},colwidth:{default:null,parseHTML:element=>{const colwidth=element.getAttribute("colwidth"),value=colwidth?[parseInt(colwidth,10)]:null;return value},renderHTML:()=>({style:"border: 1px solid #d0d9e2;color: #2f4058;font-weight: 400;"})}}},parseHTML(){return[{tag:"td"}]}}),Paragraph$3.extend({renderHTML({HTMLAttributes:HTMLAttributes}){return["p",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes),0]}}),State$3.prototype={
/**
   * @param {State} state
   */
accepts:function(){return!!this.t},
/**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * @param {string} input character or token to transition on
   * @param {Token|State} tokenOrState transition to a matching state
   * @returns State taken after the given input
   */
tt:function(input,tokenOrState){if(tokenOrState&&tokenOrState.j)
// State, default a basic transition
return this.j[input]=tokenOrState,tokenOrState;// See if there's a direct state transition (not regex or default)
var token=tokenOrState,nextState=this.j[input];if(nextState)// overrwites previous token
return token&&(nextState.t=token),nextState;// Create a new state for this input
nextState=makeState$3();// Take the transition using the usual default mechanisms
var templateState=takeT(this,input);return templateState?(
// Some default state transition, make a prime state based on this one
Object.assign(nextState.j,templateState.j),nextState.jr.append(templateState.jr),nextState.jr=templateState.jd,nextState.t=token||templateState.t):nextState.t=token,this.j[input]=nextState,nextState}};
/**
 * Utility function to create state without using new keyword (reduced file size
 * when minified)
 */
var makeState$3=function(){return new State$3},makeAcceptingState=function(token){return new State$3(token)},makeT=function(startState,input,nextState){
// IMPLEMENTATION 1: Add to object (fast)
startState.j[input]||(startState.j[input]=nextState);// IMPLEMENTATION 2: Add to array (slower)
// startState.j.push([input, nextState]);
},makeRegexT=function(startState,regex,nextState){startState.jr.push([regex,nextState])},takeT=function(state,input){
// IMPLEMENTATION 1: Object key lookup (faster)
var nextState=state.j[input];if(nextState)return nextState;// IMPLEMENTATION 2: List lookup (slower)
// Loop through all the state transitions and see if there's a match
// for (let i = 0; i < state.j.length; i++) {
//	const val = state.j[i][0];
//	const nextState = state.j[i][1];
// 	if (input === val) { return nextState; }
// }
for(var i=0;i<state.jr.length;i++){var regex=state.jr[i][0],_nextState=state.jr[i][1];if(regex.test(input))return _nextState}// Nowhere left to jump! Return default, if any
return state.jd},makeMultiT=function(startState,chars,nextState){for(var i=0;i<chars.length;i++)makeT(startState,chars[i],nextState)},makeBatchT=function(startState,transitions){for(var i=0;i<transitions.length;i++){var input=transitions[i][0],nextState=transitions[i][1];makeT(startState,input,nextState)}},makeChainT=function(state,str,endState,defaultStateFactory){var nextState,i=0,len=str.length;// Find the next state without a jump to the next character
while(i<len&&(nextState=state.j[str[i]]))state=nextState,i++;if(i>=len)return[];// no new tokens were added
while(i<len-1)nextState=defaultStateFactory(),makeT(state,str[i],nextState),state=nextState,i++;makeT(state,str[len-1],endState)},DOMAIN="DOMAIN",LOCALHOST$3="LOCALHOST",TLD$3="TLD",NUM$3="NUM",PROTOCOL="PROTOCOL",MAILTO="MAILTO",WS$3="WS",NL$3="NL",OPENBRACE$3="OPENBRACE",OPENBRACKET$3="OPENBRACKET",OPENANGLEBRACKET$3="OPENANGLEBRACKET",OPENPAREN$3="OPENPAREN",CLOSEBRACE$3="CLOSEBRACE",CLOSEBRACKET$3="CLOSEBRACKET",CLOSEANGLEBRACKET$3="CLOSEANGLEBRACKET",CLOSEPAREN$3="CLOSEPAREN",AMPERSAND$3="AMPERSAND",APOSTROPHE$3="APOSTROPHE",ASTERISK$3="ASTERISK",AT$3="AT",BACKSLASH$3="BACKSLASH",BACKTICK$3="BACKTICK",CARET$3="CARET",COLON$3="COLON",COMMA$3="COMMA",DOLLAR$3="DOLLAR",DOT$3="DOT",EQUALS$3="EQUALS",EXCLAMATION$3="EXCLAMATION",HYPHEN$3="HYPHEN",PERCENT$3="PERCENT",PIPE$3="PIPE",PLUS$3="PLUS",POUND$3="POUND",QUERY$3="QUERY",QUOTE$3="QUOTE",SEMI$3="SEMI",SLASH$3="SLASH",TILDE$3="TILDE",UNDERSCORE$3="UNDERSCORE",SYM$3="SYM",text$4=Object.freeze({__proto__:null,DOMAIN:DOMAIN,LOCALHOST:LOCALHOST$3,TLD:TLD$3,NUM:NUM$3,PROTOCOL:PROTOCOL,MAILTO:MAILTO,WS:WS$3,NL:NL$3,OPENBRACE:OPENBRACE$3,OPENBRACKET:OPENBRACKET$3,OPENANGLEBRACKET:OPENANGLEBRACKET$3,OPENPAREN:OPENPAREN$3,CLOSEBRACE:CLOSEBRACE$3,CLOSEBRACKET:CLOSEBRACKET$3,CLOSEANGLEBRACKET:CLOSEANGLEBRACKET$3,CLOSEPAREN:CLOSEPAREN$3,AMPERSAND:AMPERSAND$3,APOSTROPHE:APOSTROPHE$3,ASTERISK:ASTERISK$3,AT:AT$3,BACKSLASH:BACKSLASH$3,BACKTICK:BACKTICK$3,CARET:CARET$3,COLON:COLON$3,COMMA:COMMA$3,DOLLAR:DOLLAR$3,DOT:DOT$3,EQUALS:EQUALS$3,EXCLAMATION:EXCLAMATION$3,HYPHEN:HYPHEN$3,PERCENT:PERCENT$3,PIPE:PIPE$3,PLUS:PLUS$3,POUND:POUND$3,QUERY:QUERY$3,QUOTE:QUOTE$3,SEMI:SEMI$3,SLASH:SLASH$3,TILDE:TILDE$3,UNDERSCORE:UNDERSCORE$3,SYM:SYM$3}),tlds$3="aaa aarp abarth abb abbott abbvie abc able abogado abudhabi ac academy accenture accountant accountants aco actor ad adac ads adult ae aeg aero aetna af afamilycompany afl africa ag agakhan agency ai aig airbus airforce airtel akdn al alfaromeo alibaba alipay allfinanz allstate ally alsace alstom am amazon americanexpress americanfamily amex amfam amica amsterdam analytics android anquan anz ao aol apartments app apple aq aquarelle ar arab aramco archi army arpa art arte as asda asia associates at athleta attorney au auction audi audible audio auspost author auto autos avianca aw aws ax axa az azure ba baby baidu banamex bananarepublic band bank bar barcelona barclaycard barclays barefoot bargains baseball basketball bauhaus bayern bb bbc bbt bbva bcg bcn bd be beats beauty beer bentley berlin best bestbuy bet bf bg bh bharti bi bible bid bike bing bingo bio biz bj black blackfriday blockbuster blog bloomberg blue bm bms bmw bn bnpparibas bo boats boehringer bofa bom bond boo book booking bosch bostik boston bot boutique box br bradesco bridgestone broadway broker brother brussels bs bt budapest bugatti build builders business buy buzz bv bw by bz bzh ca cab cafe cal call calvinklein cam camera camp cancerresearch canon capetown capital capitalone car caravan cards care career careers cars casa case cash casino cat catering catholic cba cbn cbre cbs cc cd center ceo cern cf cfa cfd cg ch chanel channel charity chase chat cheap chintai christmas chrome church ci cipriani circle cisco citadel citi citic city cityeats ck cl claims cleaning click clinic clinique clothing cloud club clubmed cm cn co coach codes coffee college cologne com comcast commbank community company compare computer comsec condos construction consulting contact contractors cooking cookingchannel cool coop corsica country coupon coupons courses cpa cr credit creditcard creditunion cricket crown crs cruise cruises csc cu cuisinella cv cw cx cy cymru cyou cz dabur dad dance data date dating datsun day dclk dds de deal dealer deals degree delivery dell deloitte delta democrat dental dentist desi design dev dhl diamonds diet digital direct directory discount discover dish diy dj dk dm dnp do docs doctor dog domains dot download drive dtv dubai duck dunlop dupont durban dvag dvr dz earth eat ec eco edeka edu education ee eg email emerck energy engineer engineering enterprises epson equipment er ericsson erni es esq estate et etisalat eu eurovision eus events exchange expert exposed express extraspace fage fail fairwinds faith family fan fans farm farmers fashion fast fedex feedback ferrari ferrero fi fiat fidelity fido film final finance financial fire firestone firmdale fish fishing fit fitness fj fk flickr flights flir florist flowers fly fm fo foo food foodnetwork football ford forex forsale forum foundation fox fr free fresenius frl frogans frontdoor frontier ftr fujitsu fujixerox fun fund furniture futbol fyi ga gal gallery gallo gallup game games gap garden gay gb gbiz gd gdn ge gea gent genting george gf gg ggee gh gi gift gifts gives giving gl glade glass gle global globo gm gmail gmbh gmo gmx gn godaddy gold goldpoint golf goo goodyear goog google gop got gov gp gq gr grainger graphics gratis green gripe grocery group gs gt gu guardian gucci guge guide guitars guru gw gy hair hamburg hangout haus hbo hdfc hdfcbank health healthcare help helsinki here hermes hgtv hiphop hisamitsu hitachi hiv hk hkt hm hn hockey holdings holiday homedepot homegoods homes homesense honda horse hospital host hosting hot hoteles hotels hotmail house how hr hsbc ht hu hughes hyatt hyundai ibm icbc ice icu id ie ieee ifm ikano il im imamat imdb immo immobilien in inc industries infiniti info ing ink institute insurance insure int international intuit investments io ipiranga iq ir irish is ismaili ist istanbul it itau itv iveco jaguar java jcb je jeep jetzt jewelry jio jll jm jmp jnj jo jobs joburg jot joy jp jpmorgan jprs juegos juniper kaufen kddi ke kerryhotels kerrylogistics kerryproperties kfh kg kh ki kia kim kinder kindle kitchen kiwi km kn koeln komatsu kosher kp kpmg kpn kr krd kred kuokgroup kw ky kyoto kz la lacaixa lamborghini lamer lancaster lancia land landrover lanxess lasalle lat latino latrobe law lawyer lb lc lds lease leclerc lefrak legal lego lexus lgbt li lidl life lifeinsurance lifestyle lighting like lilly limited limo lincoln linde link lipsy live living lixil lk llc llp loan loans locker locus loft lol london lotte lotto love lpl lplfinancial lr ls lt ltd ltda lu lundbeck luxe luxury lv ly ma macys madrid maif maison makeup man management mango map market marketing markets marriott marshalls maserati mattel mba mc mckinsey md me med media meet melbourne meme memorial men menu merckmsd mg mh miami microsoft mil mini mint mit mitsubishi mk ml mlb mls mm mma mn mo mobi mobile moda moe moi mom monash money monster mormon mortgage moscow moto motorcycles mov movie mp mq mr ms msd mt mtn mtr mu museum mutual mv mw mx my mz na nab nagoya name nationwide natura navy nba nc ne nec net netbank netflix network neustar new news next nextdirect nexus nf nfl ng ngo nhk ni nico nike nikon ninja nissan nissay nl no nokia northwesternmutual norton now nowruz nowtv np nr nra nrw ntt nu nyc nz obi observer off office okinawa olayan olayangroup oldnavy ollo om omega one ong onl online onyourside ooo open oracle orange org organic origins osaka otsuka ott ovh pa page panasonic paris pars partners parts party passagens pay pccw pe pet pf pfizer pg ph pharmacy phd philips phone photo photography photos physio pics pictet pictures pid pin ping pink pioneer pizza pk pl place play playstation plumbing plus pm pn pnc pohl poker politie porn post pr pramerica praxi press prime pro prod productions prof progressive promo properties property protection pru prudential ps pt pub pw pwc py qa qpon quebec quest qvc racing radio raid re read realestate realtor realty recipes red redstone redumbrella rehab reise reisen reit reliance ren rent rentals repair report republican rest restaurant review reviews rexroth rich richardli ricoh ril rio rip rmit ro rocher rocks rodeo rogers room rs rsvp ru rugby ruhr run rw rwe ryukyu sa saarland safe safety sakura sale salon samsclub samsung sandvik sandvikcoromant sanofi sap sarl sas save saxo sb sbi sbs sc sca scb schaeffler schmidt scholarships school schule schwarz science scjohnson scot sd se search seat secure security seek select sener services ses seven sew sex sexy sfr sg sh shangrila sharp shaw shell shia shiksha shoes shop shopping shouji show showtime si silk sina singles site sj sk ski skin sky skype sl sling sm smart smile sn sncf so soccer social softbank software sohu solar solutions song sony soy spa space sport spot spreadbetting sr srl ss st stada staples star statebank statefarm stc stcgroup stockholm storage store stream studio study style su sucks supplies supply support surf surgery suzuki sv swatch swiftcover swiss sx sy sydney systems sz tab taipei talk taobao target tatamotors tatar tattoo tax taxi tc tci td tdk team tech technology tel temasek tennis teva tf tg th thd theater theatre tiaa tickets tienda tiffany tips tires tirol tj tjmaxx tjx tk tkmaxx tl tm tmall tn to today tokyo tools top toray toshiba total tours town toyota toys tr trade trading training travel travelchannel travelers travelersinsurance trust trv tt tube tui tunes tushu tv tvs tw tz ua ubank ubs ug uk unicom university uno uol ups us uy uz va vacations vana vanguard vc ve vegas ventures verisign versicherung vet vg vi viajes video vig viking villas vin vip virgin visa vision viva vivo vlaanderen vn vodka volkswagen volvo vote voting voto voyage vu vuelos wales walmart walter wang wanggou watch watches weather weatherchannel webcam weber website wed wedding weibo weir wf whoswho wien wiki williamhill win windows wine winners wme wolterskluwer woodside work works world wow ws wtc wtf xbox xerox xfinity xihuan xin xxx xyz yachts yahoo yamaxun yandex ye yodobashi yoga yokohama you youtube yt yun za zappos zara zero zip zm zone zuerich zw vermögensberater-ctb vermögensberatung-pwb ελ ευ бг бел дети ею католик ком қаз мкд мон москва онлайн орг рус рф сайт срб укр გე հայ ישראל קום ابوظبي اتصالات ارامكو الاردن البحرين الجزائر السعودية العليان المغرب امارات ایران بارت بازار بھارت بيتك پاکستان ڀارت تونس سودان سورية شبكة عراق عرب عمان فلسطين قطر كاثوليك كوم مصر مليسيا موريتانيا موقع همراه कॉम नेट भारत भारतम् भारोत संगठन বাংলা ভারত ভাৰত ਭਾਰਤ ભારત ଭାରତ இந்தியா இலங்கை சிங்கப்பூர் భారత్ ಭಾರತ ഭാരതം ලංකා คอม ไทย ລາວ 닷넷 닷컴 삼성 한국 アマゾン グーグル クラウド コム ストア セール ファッション ポイント みんな 世界 中信 中国 中國 中文网 亚马逊 企业 佛山 信息 健康 八卦 公司 公益 台湾 台灣 商城 商店 商标 嘉里 嘉里大酒店 在线 大众汽车 大拿 天主教 娱乐 家電 广东 微博 慈善 我爱你 手机 招聘 政务 政府 新加坡 新闻 时尚 書籍 机构 淡马锡 游戏 澳門 点看 移动 组织机构 网址 网店 网站 网络 联通 诺基亚 谷歌 购物 通販 集团 電訊盈科 飞利浦 食品 餐厅 香格里拉 香港".split(" "),LETTER$3=/(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/,EMOJI$3=/(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDD-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6])/,EMOJI_VARIATION$3=/\uFE0F/,DIGIT$3=/\d/,SPACE$3=/\s/;
/**
 * Similar to previous except it is an accepting state that emits a token
 * @param {Token} token
 */
/**
 * Initialize the scanner character-based state machine for the given start state
 * @return {State} scanner starting state
 */
function init$2$3(){var customProtocols=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],S_START=makeState$3(),S_NUM=makeAcceptingState(NUM$3),S_DOMAIN=makeAcceptingState(DOMAIN),S_DOMAIN_HYPHEN=makeState$3(),S_WS=makeAcceptingState(WS$3),DOMAIN_REGEX_TRANSITIONS=[[DIGIT$3,S_DOMAIN],[LETTER$3,S_DOMAIN],[EMOJI$3,S_DOMAIN],[EMOJI_VARIATION$3,S_DOMAIN]],makeDomainState=function(){var state=makeAcceptingState(DOMAIN);return state.j={"-":S_DOMAIN_HYPHEN},state.jr=[].concat(DOMAIN_REGEX_TRANSITIONS),state},makeNearDomainState=function(token){var state=makeDomainState();return state.t=token,state};
// Frequently used states
// States for special URL symbols that accept immediately after start
makeBatchT(S_START,[["'",makeAcceptingState(APOSTROPHE$3)],["{",makeAcceptingState(OPENBRACE$3)],["[",makeAcceptingState(OPENBRACKET$3)],["<",makeAcceptingState(OPENANGLEBRACKET$3)],["(",makeAcceptingState(OPENPAREN$3)],["}",makeAcceptingState(CLOSEBRACE$3)],["]",makeAcceptingState(CLOSEBRACKET$3)],[">",makeAcceptingState(CLOSEANGLEBRACKET$3)],[")",makeAcceptingState(CLOSEPAREN$3)],["&",makeAcceptingState(AMPERSAND$3)],["*",makeAcceptingState(ASTERISK$3)],["@",makeAcceptingState(AT$3)],["`",makeAcceptingState(BACKTICK$3)],["^",makeAcceptingState(CARET$3)],[":",makeAcceptingState(COLON$3)],[",",makeAcceptingState(COMMA$3)],["$",makeAcceptingState(DOLLAR$3)],[".",makeAcceptingState(DOT$3)],["=",makeAcceptingState(EQUALS$3)],["!",makeAcceptingState(EXCLAMATION$3)],["-",makeAcceptingState(HYPHEN$3)],["%",makeAcceptingState(PERCENT$3)],["|",makeAcceptingState(PIPE$3)],["+",makeAcceptingState(PLUS$3)],["#",makeAcceptingState(POUND$3)],["?",makeAcceptingState(QUERY$3)],['"',makeAcceptingState(QUOTE$3)],["/",makeAcceptingState(SLASH$3)],[";",makeAcceptingState(SEMI$3)],["~",makeAcceptingState(TILDE$3)],["_",makeAcceptingState(UNDERSCORE$3)],["\\",makeAcceptingState(BACKSLASH$3)]]),// Whitespace jumps
// Tokens of only non-newline whitespace are arbitrarily long
makeT(S_START,"\n",makeAcceptingState(NL$3)),makeRegexT(S_START,SPACE$3,S_WS),// If any whitespace except newline, more whitespace!
makeT(S_WS,"\n",makeState$3()),// non-accepting state
makeRegexT(S_WS,SPACE$3,S_WS);// Generates states for top-level domains
// Note that this is most accurate when tlds are in alphabetical order
for(var i=0;i<tlds$3.length;i++)makeChainT(S_START,tlds$3[i],makeNearDomainState(TLD$3),makeDomainState);// Collect the states generated by different protocls
var S_PROTOCOL_FILE=makeDomainState(),S_PROTOCOL_FTP=makeDomainState(),S_PROTOCOL_HTTP=makeDomainState(),S_MAILTO=makeDomainState();makeChainT(S_START,"file",S_PROTOCOL_FILE,makeDomainState),makeChainT(S_START,"ftp",S_PROTOCOL_FTP,makeDomainState),makeChainT(S_START,"http",S_PROTOCOL_HTTP,makeDomainState),makeChainT(S_START,"mailto",S_MAILTO,makeDomainState);// Protocol states
var S_PROTOCOL_SECURE=makeDomainState(),S_FULL_PROTOCOL=makeAcceptingState(PROTOCOL),S_FULL_MAILTO=makeAcceptingState(MAILTO);// Mailto ends with COLON
// Secure protocols (end with 's')
makeT(S_PROTOCOL_FTP,"s",S_PROTOCOL_SECURE),makeT(S_PROTOCOL_FTP,":",S_FULL_PROTOCOL),makeT(S_PROTOCOL_HTTP,"s",S_PROTOCOL_SECURE),makeT(S_PROTOCOL_HTTP,":",S_FULL_PROTOCOL),// Become protocol tokens after a COLON
makeT(S_PROTOCOL_FILE,":",S_FULL_PROTOCOL),makeT(S_PROTOCOL_SECURE,":",S_FULL_PROTOCOL),makeT(S_MAILTO,":",S_FULL_MAILTO);for(// Register custom protocols
var S_CUSTOM_PROTOCOL=makeDomainState(),_i=0;_i<customProtocols.length;_i++)makeChainT(S_START,customProtocols[_i],S_CUSTOM_PROTOCOL,makeDomainState);return makeT(S_CUSTOM_PROTOCOL,":",S_FULL_PROTOCOL),// Localhost
makeChainT(S_START,"localhost",makeNearDomainState(LOCALHOST$3),makeDomainState),// Everything else
// DOMAINs make more DOMAINs
// Number and character transitions
makeRegexT(S_START,DIGIT$3,S_NUM),makeRegexT(S_START,LETTER$3,S_DOMAIN),makeRegexT(S_START,EMOJI$3,S_DOMAIN),makeRegexT(S_START,EMOJI_VARIATION$3,S_DOMAIN),makeRegexT(S_NUM,DIGIT$3,S_NUM),makeRegexT(S_NUM,LETTER$3,S_DOMAIN),// number becomes DOMAIN
makeRegexT(S_NUM,EMOJI$3,S_DOMAIN),// number becomes DOMAIN
makeRegexT(S_NUM,EMOJI_VARIATION$3,S_DOMAIN),// number becomes DOMAIN
makeT(S_NUM,"-",S_DOMAIN_HYPHEN),// Default domain transitions
makeT(S_DOMAIN,"-",S_DOMAIN_HYPHEN),makeT(S_DOMAIN_HYPHEN,"-",S_DOMAIN_HYPHEN),makeRegexT(S_DOMAIN,DIGIT$3,S_DOMAIN),makeRegexT(S_DOMAIN,LETTER$3,S_DOMAIN),makeRegexT(S_DOMAIN,EMOJI$3,S_DOMAIN),makeRegexT(S_DOMAIN,EMOJI_VARIATION$3,S_DOMAIN),makeRegexT(S_DOMAIN_HYPHEN,DIGIT$3,S_DOMAIN),makeRegexT(S_DOMAIN_HYPHEN,LETTER$3,S_DOMAIN),makeRegexT(S_DOMAIN_HYPHEN,EMOJI$3,S_DOMAIN),makeRegexT(S_DOMAIN_HYPHEN,EMOJI_VARIATION$3,S_DOMAIN),// Set default transition for start state (some symbol)
S_START.jd=makeAcceptingState(SYM$3),S_START}
/**
	Given a string, returns an array of TOKEN instances representing the
	composition of that string.

	@method run
	@param {State} start scanner starting state
	@param {string} str input string to scan
	@return {{t: string, v: string, s: number, l: number}[]} list of tokens, each with a type and value
*/function run$1$4(start,str){
// State machine is not case sensitive, so input is tokenized in lowercased
// form (still returns the regular case though) Uses selective `toLowerCase`
// is used because lowercasing the entire string causes the length and
// character position to vary in some non-English strings with V8-based
// runtimes.
var iterable=stringToArray$3(str.replace(/[A-Z]/g,(function(c){return c.toLowerCase()}))),charCount=iterable.length,tokens=[],cursor=0,charCursor=0;// Tokenize the string
while(charCursor<charCount){var state=start,nextState=null,tokenLength=0,latestAccepting=null,sinceAccepts=-1,charsSinceAccepts=-1;while(charCursor<charCount&&(nextState=takeT(state,iterable[charCursor])))state=nextState,// Keep track of the latest accepting state
state.accepts()?(sinceAccepts=0,charsSinceAccepts=0,latestAccepting=state):sinceAccepts>=0&&(sinceAccepts+=iterable[charCursor].length,charsSinceAccepts++),tokenLength+=iterable[charCursor].length,cursor+=iterable[charCursor].length,charCursor++;// Roll back to the latest accepting state
cursor-=sinceAccepts,charCursor-=charsSinceAccepts,tokenLength-=sinceAccepts,// No more jumps, just make a new token from the last accepting one
// TODO: If possible, don't output v, instead output range where values ocur
tokens.push({t:latestAccepting.t,
// token type/name
v:str.substr(cursor-tokenLength,tokenLength),
// string value
s:cursor-tokenLength,
// start index
e:cursor})}return tokens}
/**
 * Convert a String to an Array of characters, taking into account that some
 * characters like emojis take up two string indexes.
 *
 * Adapted from core-js (MIT license)
 * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js
 *
 * @function stringToArray
 * @param {string} str
 * @returns {string[]}
 */function stringToArray$3(str){var result=[],len=str.length,index=0;while(index<len){var first=str.charCodeAt(index),second=void 0,char=first<55296||first>56319||index+1===len||(second=str.charCodeAt(index+1))<56320||second>57343?str[index]:str.slice(index,index+2);// two-index characters
result.push(char),index+=char.length}return result}
/**
 * @property {string} defaultProtocol
 * @property {{[string]: (event) => void}]} [events]
 */var defaults$3={defaultProtocol:"http",events:null,format:noop$3,formatHref:noop$3,nl2br:!1,tagName:"a",target:null,rel:null,validate:!0,truncate:0,className:null,attributes:null,ignoreTags:[]};function noop$3(val){return val}
/******************************************************************************
	Multi-Tokens
	Tokens composed of arrays of TextTokens
******************************************************************************/function inherits(parent,child){var props=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},extended=Object.create(parent.prototype);for(var p in props)extended[p]=props[p];return extended.constructor=child,child.prototype=extended,child}
/**
	Abstract class used for manufacturing tokens of text tokens. That is rather
	than the value for a token being a small string of text, it's value an array
	of text tokens.

	Used for grouping together URLs, emails, hashtags, and other potential
	creations.

	@class MultiToken
	@param {string} value
	@param {{t: string, v: string, s: number, e: number}[]} tokens
	@abstract
*/function MultiToken$3(){}// Base token
/**
 * Create a new token that can be emitted by the parser state machine
 * @param {string} type readable type of the token
 * @param {object} props properties to assign or override, including isLink = true or false
 * @returns {(value: string, tokens: {t: string, v: string, s: number, e: number}) => MultiToken} new token class
 */
function createTokenClass$3(type,props){function Token(value,tokens){this.t=type,this.v=value,this.tk=tokens}return inherits(MultiToken$3,Token,props),Token}
/**
	Represents an arbitrarily mailto email address with the prefix included
	@class MailtoEmail
	@extends MultiToken
*/MultiToken$3.prototype={
/**
  	String representing the type for this token
  	@property t
  	@default 'token'
  */
t:"token",
/**
  	Is this multitoken a link?
  	@property isLink
  	@default false
  */
isLink:!1,
/**
  	Return the string this token represents.
  	@method toString
  	@return {string}
  */
toString:function(){return this.v},
/**
  	What should the value for this token be in the `href` HTML attribute?
  	Returns the `.toString` value by default.
  		@method toHref
  	@return {string}
  */
toHref:function(){return this.toString()},
/**
   * The start index of this token in the original input string
   * @returns {number}
   */
startIndex:function(){return this.tk[0].s},
/**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
endIndex:function(){return this.tk[this.tk.length-1].e},
/**
  	Returns a hash of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
toObject:function(){var protocol=arguments.length>0&&void 0!==arguments[0]?arguments[0]:defaults$3.defaultProtocol;return{type:this.t,value:this.v,isLink:this.isLink,href:this.toHref(protocol),start:this.startIndex(),end:this.endIndex()}}};var MailtoEmail=createTokenClass$3("email",{isLink:!0}),Email$3=createTokenClass$3("email",{isLink:!0,toHref:function(){return"mailto:"+this.toString()}}),Text$4=createTokenClass$3("text"),Nl$3=createTokenClass$3("nl"),Url$3=createTokenClass$3("url",{isLink:!0,
/**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@method href
  	@param {string} protocol
  	@return {string}
  */
toHref:function(){var protocol=arguments.length>0&&void 0!==arguments[0]?arguments[0]:defaults$3.defaultProtocol,tokens=this.tk,hasProtocol=!1,hasSlashSlash=!1,result=[],i=0;// Make the first part of the domain lowercase
// Lowercase protocol
while(tokens[i].t===PROTOCOL)hasProtocol=!0,result.push(tokens[i].v),i++;// Skip slash-slash
while(tokens[i].t===SLASH$3)hasSlashSlash=!0,result.push(tokens[i].v),i++;// Continue pushing characters
for(;i<tokens.length;i++)result.push(tokens[i].v);return result=result.join(""),hasProtocol||hasSlashSlash||(result="".concat(protocol,"://").concat(result)),result},hasProtocol:function(){return this.tk[0].t===PROTOCOL}}),multi=Object.freeze({__proto__:null,MultiToken:MultiToken$3,Base:MultiToken$3,createTokenClass:createTokenClass$3,MailtoEmail:MailtoEmail,Email:Email$3,Text:Text$4,Nl:Nl$3,Url:Url$3});
/**
	Represents a list of tokens making up a valid email address
	@class Email
	@extends MultiToken
*/
/**
	Not exactly parser, more like the second-stage scanner (although we can
	theoretically hotswap the code here with a real parser in the future... but
	for a little URL-finding utility abstract syntax trees may be a little
	overkill).

	URL format: http://en.wikipedia.org/wiki/URI_scheme
	Email format: http://en.wikipedia.org/wiki/Email_address (links to RFC in
	reference)

	@module linkify
	@submodule parser
	@main run
*/
/**
 * Generate the parser multi token-based state machine
 * @returns {State} the starting state
 */
function init$1$3(){
// The universal starting state.
var S_START=makeState$3(),S_PROTOCOL=makeState$3(),S_MAILTO=makeState$3(),S_PROTOCOL_SLASH=makeState$3(),S_PROTOCOL_SLASH_SLASH=makeState$3(),S_DOMAIN=makeState$3(),S_DOMAIN_DOT=makeState$3(),S_TLD=makeAcceptingState(Url$3),S_TLD_COLON=makeState$3(),S_TLD_PORT=makeAcceptingState(Url$3),S_URL=makeAcceptingState(Url$3),S_URL_NON_ACCEPTING=makeState$3(),S_URL_OPENBRACE=makeState$3(),S_URL_OPENBRACKET=makeState$3(),S_URL_OPENANGLEBRACKET=makeState$3(),S_URL_OPENPAREN=makeState$3(),S_URL_OPENBRACE_Q=makeAcceptingState(Url$3),S_URL_OPENBRACKET_Q=makeAcceptingState(Url$3),S_URL_OPENANGLEBRACKET_Q=makeAcceptingState(Url$3),S_URL_OPENPAREN_Q=makeAcceptingState(Url$3),S_URL_OPENBRACE_SYMS=makeState$3(),S_URL_OPENBRACKET_SYMS=makeState$3(),S_URL_OPENANGLEBRACKET_SYMS=makeState$3(),S_URL_OPENPAREN_SYMS=makeState$3(),S_EMAIL_DOMAIN=makeState$3(),S_EMAIL_DOMAIN_DOT=makeState$3(),S_EMAIL=makeAcceptingState(Email$3),S_EMAIL_COLON=makeState$3(),S_EMAIL_PORT=makeAcceptingState(Email$3),S_MAILTO_EMAIL=makeAcceptingState(MailtoEmail),S_MAILTO_EMAIL_NON_ACCEPTING=makeState$3(),S_LOCALPART=makeState$3(),S_LOCALPART_AT=makeState$3(),S_LOCALPART_DOT=makeState$3(),S_NL=makeAcceptingState(Nl$3);// Intermediate states for URLs. Note that domains that begin with a protocol
// are treated slighly differently from those that don't.
// single new line
// Make path from start to protocol (with '//')
makeT(S_START,NL$3,S_NL),makeT(S_START,PROTOCOL,S_PROTOCOL),makeT(S_START,MAILTO,S_MAILTO),makeT(S_PROTOCOL,SLASH$3,S_PROTOCOL_SLASH),makeT(S_PROTOCOL_SLASH,SLASH$3,S_PROTOCOL_SLASH_SLASH),// The very first potential domain name
makeT(S_START,TLD$3,S_DOMAIN),makeT(S_START,DOMAIN,S_DOMAIN),makeT(S_START,LOCALHOST$3,S_TLD),makeT(S_START,NUM$3,S_DOMAIN),// Force URL for protocol followed by anything sane
makeT(S_PROTOCOL_SLASH_SLASH,TLD$3,S_URL),makeT(S_PROTOCOL_SLASH_SLASH,DOMAIN,S_URL),makeT(S_PROTOCOL_SLASH_SLASH,NUM$3,S_URL),makeT(S_PROTOCOL_SLASH_SLASH,LOCALHOST$3,S_URL),// Account for dots and hyphens
// hyphens are usually parts of domain names
makeT(S_DOMAIN,DOT$3,S_DOMAIN_DOT),makeT(S_EMAIL_DOMAIN,DOT$3,S_EMAIL_DOMAIN_DOT),// Hyphen can jump back to a domain name
// After the first domain and a dot, we can find either a URL or another domain
makeT(S_DOMAIN_DOT,TLD$3,S_TLD),makeT(S_DOMAIN_DOT,DOMAIN,S_DOMAIN),makeT(S_DOMAIN_DOT,NUM$3,S_DOMAIN),makeT(S_DOMAIN_DOT,LOCALHOST$3,S_DOMAIN),makeT(S_EMAIL_DOMAIN_DOT,TLD$3,S_EMAIL),makeT(S_EMAIL_DOMAIN_DOT,DOMAIN,S_EMAIL_DOMAIN),makeT(S_EMAIL_DOMAIN_DOT,NUM$3,S_EMAIL_DOMAIN),makeT(S_EMAIL_DOMAIN_DOT,LOCALHOST$3,S_EMAIL_DOMAIN),// S_TLD accepts! But the URL could be longer, try to find a match greedily
// The `run` function should be able to "rollback" to the accepting state
makeT(S_TLD,DOT$3,S_DOMAIN_DOT),makeT(S_EMAIL,DOT$3,S_EMAIL_DOMAIN_DOT),// Become real URLs after `SLASH` or `COLON NUM SLASH`
// Here PSS and non-PSS converge
makeT(S_TLD,COLON$3,S_TLD_COLON),makeT(S_TLD,SLASH$3,S_URL),makeT(S_TLD_COLON,NUM$3,S_TLD_PORT),makeT(S_TLD_PORT,SLASH$3,S_URL),makeT(S_EMAIL,COLON$3,S_EMAIL_COLON),makeT(S_EMAIL_COLON,NUM$3,S_EMAIL_PORT);// Types of characters the URL can definitely end in
var qsAccepting=[AMPERSAND$3,ASTERISK$3,AT$3,BACKSLASH$3,BACKTICK$3,CARET$3,DOLLAR$3,DOMAIN,EQUALS$3,HYPHEN$3,LOCALHOST$3,NUM$3,PERCENT$3,PIPE$3,PLUS$3,POUND$3,PROTOCOL,SLASH$3,SYM$3,TILDE$3,TLD$3,UNDERSCORE$3],qsNonAccepting=[APOSTROPHE$3,CLOSEANGLEBRACKET$3,CLOSEBRACE$3,CLOSEBRACKET$3,CLOSEPAREN$3,COLON$3,COMMA$3,DOT$3,EXCLAMATION$3,OPENANGLEBRACKET$3,OPENBRACE$3,OPENBRACKET$3,OPENPAREN$3,QUERY$3,QUOTE$3,SEMI$3];// Types of tokens that can follow a URL and be part of the query string
// but cannot be the very last characters
// Characters that cannot appear in the URL at all should be excluded
// These states are responsible primarily for determining whether or not to
// include the final round bracket.
// URL, followed by an opening bracket
makeT(S_URL,OPENBRACE$3,S_URL_OPENBRACE),makeT(S_URL,OPENBRACKET$3,S_URL_OPENBRACKET),makeT(S_URL,OPENANGLEBRACKET$3,S_URL_OPENANGLEBRACKET),makeT(S_URL,OPENPAREN$3,S_URL_OPENPAREN),// URL with extra symbols at the end, followed by an opening bracket
makeT(S_URL_NON_ACCEPTING,OPENBRACE$3,S_URL_OPENBRACE),makeT(S_URL_NON_ACCEPTING,OPENBRACKET$3,S_URL_OPENBRACKET),makeT(S_URL_NON_ACCEPTING,OPENANGLEBRACKET$3,S_URL_OPENANGLEBRACKET),makeT(S_URL_NON_ACCEPTING,OPENPAREN$3,S_URL_OPENPAREN),// Closing bracket component. This character WILL be included in the URL
makeT(S_URL_OPENBRACE,CLOSEBRACE$3,S_URL),makeT(S_URL_OPENBRACKET,CLOSEBRACKET$3,S_URL),makeT(S_URL_OPENANGLEBRACKET,CLOSEANGLEBRACKET$3,S_URL),makeT(S_URL_OPENPAREN,CLOSEPAREN$3,S_URL),makeT(S_URL_OPENBRACE_Q,CLOSEBRACE$3,S_URL),makeT(S_URL_OPENBRACKET_Q,CLOSEBRACKET$3,S_URL),makeT(S_URL_OPENANGLEBRACKET_Q,CLOSEANGLEBRACKET$3,S_URL),makeT(S_URL_OPENPAREN_Q,CLOSEPAREN$3,S_URL),makeT(S_URL_OPENBRACE_SYMS,CLOSEBRACE$3,S_URL),makeT(S_URL_OPENBRACKET_SYMS,CLOSEBRACKET$3,S_URL),makeT(S_URL_OPENANGLEBRACKET_SYMS,CLOSEANGLEBRACKET$3,S_URL),makeT(S_URL_OPENPAREN_SYMS,CLOSEPAREN$3,S_URL),// URL that beings with an opening bracket, followed by a symbols.
// Note that the final state can still be `S_URL_OPENBRACE_Q` (if the URL only
// has a single opening bracket for some reason).
makeMultiT(S_URL_OPENBRACE,qsAccepting,S_URL_OPENBRACE_Q),makeMultiT(S_URL_OPENBRACKET,qsAccepting,S_URL_OPENBRACKET_Q),makeMultiT(S_URL_OPENANGLEBRACKET,qsAccepting,S_URL_OPENANGLEBRACKET_Q),makeMultiT(S_URL_OPENPAREN,qsAccepting,S_URL_OPENPAREN_Q),makeMultiT(S_URL_OPENBRACE,qsNonAccepting,S_URL_OPENBRACE_SYMS),makeMultiT(S_URL_OPENBRACKET,qsNonAccepting,S_URL_OPENBRACKET_SYMS),makeMultiT(S_URL_OPENANGLEBRACKET,qsNonAccepting,S_URL_OPENANGLEBRACKET_SYMS),makeMultiT(S_URL_OPENPAREN,qsNonAccepting,S_URL_OPENPAREN_SYMS),// URL that begins with an opening bracket, followed by some symbols
makeMultiT(S_URL_OPENBRACE_Q,qsAccepting,S_URL_OPENBRACE_Q),makeMultiT(S_URL_OPENBRACKET_Q,qsAccepting,S_URL_OPENBRACKET_Q),makeMultiT(S_URL_OPENANGLEBRACKET_Q,qsAccepting,S_URL_OPENANGLEBRACKET_Q),makeMultiT(S_URL_OPENPAREN_Q,qsAccepting,S_URL_OPENPAREN_Q),makeMultiT(S_URL_OPENBRACE_Q,qsNonAccepting,S_URL_OPENBRACE_Q),makeMultiT(S_URL_OPENBRACKET_Q,qsNonAccepting,S_URL_OPENBRACKET_Q),makeMultiT(S_URL_OPENANGLEBRACKET_Q,qsNonAccepting,S_URL_OPENANGLEBRACKET_Q),makeMultiT(S_URL_OPENPAREN_Q,qsNonAccepting,S_URL_OPENPAREN_Q),makeMultiT(S_URL_OPENBRACE_SYMS,qsAccepting,S_URL_OPENBRACE_Q),makeMultiT(S_URL_OPENBRACKET_SYMS,qsAccepting,S_URL_OPENBRACKET_Q),makeMultiT(S_URL_OPENANGLEBRACKET_SYMS,qsAccepting,S_URL_OPENANGLEBRACKET_Q),makeMultiT(S_URL_OPENPAREN_SYMS,qsAccepting,S_URL_OPENPAREN_Q),makeMultiT(S_URL_OPENBRACE_SYMS,qsNonAccepting,S_URL_OPENBRACE_SYMS),makeMultiT(S_URL_OPENBRACKET_SYMS,qsNonAccepting,S_URL_OPENBRACKET_SYMS),makeMultiT(S_URL_OPENANGLEBRACKET_SYMS,qsNonAccepting,S_URL_OPENANGLEBRACKET_SYMS),makeMultiT(S_URL_OPENPAREN_SYMS,qsNonAccepting,S_URL_OPENPAREN_SYMS),// Account for the query string
makeMultiT(S_URL,qsAccepting,S_URL),makeMultiT(S_URL_NON_ACCEPTING,qsAccepting,S_URL),makeMultiT(S_URL,qsNonAccepting,S_URL_NON_ACCEPTING),makeMultiT(S_URL_NON_ACCEPTING,qsNonAccepting,S_URL_NON_ACCEPTING),// Email address-specific state definitions
// Note: We are not allowing '/' in email addresses since this would interfere
// with real URLs
// For addresses with the mailto prefix
// 'mailto:' followed by anything sane is a valid email
makeT(S_MAILTO,TLD$3,S_MAILTO_EMAIL),makeT(S_MAILTO,DOMAIN,S_MAILTO_EMAIL),makeT(S_MAILTO,NUM$3,S_MAILTO_EMAIL),makeT(S_MAILTO,LOCALHOST$3,S_MAILTO_EMAIL),// Greedily get more potential valid email values
makeMultiT(S_MAILTO_EMAIL,qsAccepting,S_MAILTO_EMAIL),makeMultiT(S_MAILTO_EMAIL,qsNonAccepting,S_MAILTO_EMAIL_NON_ACCEPTING),makeMultiT(S_MAILTO_EMAIL_NON_ACCEPTING,qsAccepting,S_MAILTO_EMAIL),makeMultiT(S_MAILTO_EMAIL_NON_ACCEPTING,qsNonAccepting,S_MAILTO_EMAIL_NON_ACCEPTING);// For addresses without the mailto prefix
// Tokens allowed in the localpart of the email
var localpartAccepting=[AMPERSAND$3,APOSTROPHE$3,ASTERISK$3,BACKSLASH$3,BACKTICK$3,CARET$3,CLOSEBRACE$3,DOLLAR$3,DOMAIN,EQUALS$3,HYPHEN$3,NUM$3,OPENBRACE$3,PERCENT$3,PIPE$3,PLUS$3,POUND$3,QUERY$3,SLASH$3,SYM$3,TILDE$3,TLD$3,UNDERSCORE$3];// Some of the tokens in `localpartAccepting` are already accounted for here and
// will not be overwritten (don't worry)
// States following `@` defined above
return makeMultiT(S_DOMAIN,localpartAccepting,S_LOCALPART),makeT(S_DOMAIN,AT$3,S_LOCALPART_AT),makeMultiT(S_TLD,localpartAccepting,S_LOCALPART),makeT(S_TLD,AT$3,S_LOCALPART_AT),makeMultiT(S_DOMAIN_DOT,localpartAccepting,S_LOCALPART),// Now in localpart of address
// TODO: IP addresses and what if the email starts with numbers?
makeMultiT(S_LOCALPART,localpartAccepting,S_LOCALPART),makeT(S_LOCALPART,AT$3,S_LOCALPART_AT),// close to an email address now
makeT(S_LOCALPART,DOT$3,S_LOCALPART_DOT),makeMultiT(S_LOCALPART_DOT,localpartAccepting,S_LOCALPART),makeT(S_LOCALPART_AT,TLD$3,S_EMAIL_DOMAIN),makeT(S_LOCALPART_AT,DOMAIN,S_EMAIL_DOMAIN),makeT(S_LOCALPART_AT,NUM$3,S_EMAIL_DOMAIN),makeT(S_LOCALPART_AT,LOCALHOST$3,S_EMAIL),S_START}
/**
 * Run the parser state machine on a list of scanned string-based tokens to
 * create a list of multi tokens, each of which represents a URL, email address,
 * plain text, etc.
 *
 * @param {State} start parser start state
 * @param {string} input the original input used to generate the given tokens
 * @param {{t: string, v: string, s: number, e: number}[]} tokens list of scanned tokens
 * @returns {MultiToken[]}
 */function run$5(start,input,tokens){var len=tokens.length,cursor=0,multis=[],textTokens=[];while(cursor<len){var state=start,secondState=null,nextState=null,multiLength=0,latestAccepting=null,sinceAccepts=-1;while(cursor<len&&!(secondState=takeT(state,tokens[cursor].t)))
// Starting tokens with nowhere to jump to.
// Consider these to be just plain text
textTokens.push(tokens[cursor++]);while(cursor<len&&(nextState=secondState||takeT(state,tokens[cursor].t)))
// Get the next state
secondState=null,state=nextState,// Keep track of the latest accepting state
state.accepts()?(sinceAccepts=0,latestAccepting=state):sinceAccepts>=0&&sinceAccepts++,cursor++,multiLength++;if(sinceAccepts<0)
// No accepting state was found, part of a regular text token
// Add all the tokens we looked at to the text tokens array
for(var i=cursor-multiLength;i<cursor;i++)textTokens.push(tokens[i]);else{
// Accepting state!
// First close off the textTokens (if available)
textTokens.length>0&&(multis.push(parserCreateMultiToken(Text$4,input,textTokens)),textTokens=[]),// Roll back to the latest accepting state
cursor-=sinceAccepts,multiLength-=sinceAccepts;// Create a new multitoken
var Multi=latestAccepting.t,subtokens=tokens.slice(cursor-multiLength,cursor);multis.push(parserCreateMultiToken(Multi,input,subtokens))}}// Finally close off the textTokens (if available)
return textTokens.length>0&&multis.push(parserCreateMultiToken(Text$4,input,textTokens)),multis}
/**
 * Utility function for instantiating a new multitoken with all the relevant
 * fields during parsing.
 * @param {Class<MultiToken>} Multi class to instantiate
 * @param {string} input original input string
 * @param {{t: string, v: string, s: number, e: number}[]} tokens consecutive tokens scanned from input string
 * @returns {MultiToken}
 */function parserCreateMultiToken(Multi,input,tokens){var startIdx=tokens[0].s,endIdx=tokens[tokens.length-1].e,value=input.substr(startIdx,endIdx-startIdx);return new Multi(value,tokens)}var warn$3="undefined"!==typeof console&&console&&console.warn||function(){},INIT$3={scanner:null,parser:null,pluginQueue:[],customProtocols:[],initialized:!1};// Side-effect initialization state
/**
 * Detect URLs with the following additional protocol. Anything following
 * "protocol:" will be considered a link.
 * @param {string} protocol
 */
function registerCustomProtocol$3(protocol){if(INIT$3.initialized&&warn$3('linkifyjs: already initialized - will not register custom protocol "'.concat(protocol,'" until you manually call linkify.init(). To avoid this warning, please register all custom protocols before invoking linkify the first time.')),!/^[a-z-]+$/.test(protocol))throw Error("linkifyjs: protocols containing characters other than a-z or - (hyphen) are not supported");INIT$3.customProtocols.push(protocol)}
/**
 * Initialize the linkify state machine. Called automatically the first time
 * linkify is called on a string, but may be called manually as well.
 */function init$5(){
// Initialize state machines
INIT$3.scanner={start:init$2$3(INIT$3.customProtocols),tokens:text$4},INIT$3.parser={start:init$1$3(),tokens:multi};// Initialize plugins
for(var utils={createTokenClass:createTokenClass$3},i=0;i<INIT$3.pluginQueue.length;i++)INIT$3.pluginQueue[i][1]({scanner:INIT$3.scanner,parser:INIT$3.parser,utils:utils});INIT$3.initialized=!0}
/**
	Parse a string into tokens that represent linkable and non-linkable sub-components
	@param {string} str
	@return {MultiToken[]} tokens
*/function tokenize$3(str){return INIT$3.initialized||init$5(),run$5(INIT$3.parser.start,str,run$1$4(INIT$3.scanner.start,str))}
/**
	Find a list of linkable items in the given string.
	@param {string} str string to find links in
	@param {string} [type] (optional) only find links of a specific type, e.g.,
	'url' or 'email'
*/function find$2$3(str){for(var type=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,tokens=tokenize$3(str),filtered=[],i=0;i<tokens.length;i++){var token=tokens[i];!token.isLink||type&&token.t!==type||filtered.push(token.toObject())}return filtered}
/**
 * Is the given string valid linkable text of some sort. Note that this does not
 * trim the text for you.
 *
 * Optionally pass in a second `type` param, which is the type of link to test
 * for.
 *
 * For example,
 *
 *     linkify.test(str, 'email');
 *
 * Returns `true` if str is a valid email.
 * @param {string} str string to test for links
 * @param {string} [type] optional specific link type to look for
 * @returns boolean true/false
 */function test$3(str){var type=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,tokens=tokenize$3(str);return 1===tokens.length&&tokens[0].isLink&&(!type||tokens[0].t===type)}function autolink$3(options){return new Plugin$3({key:new PluginKey$3("autolink"),appendTransaction:(transactions,oldState,newState)=>{const docChanges=transactions.some((transaction=>transaction.docChanged))&&!oldState.doc.eq(newState.doc),preventAutolink=transactions.some((transaction=>transaction.getMeta("preventAutolink")));if(!docChanges||preventAutolink)return;const{tr:tr}=newState,transform=combineTransactionSteps$3(oldState.doc,[...transactions]),{mapping:mapping}=transform,changes=getChangedRanges$3(transform);return changes.forEach((({oldRange:oldRange,newRange:newRange})=>{
// at first we check if we have to remove links
getMarksBetween$3(oldRange.from,oldRange.to,oldState.doc).filter((item=>item.mark.type===options.type)).forEach((oldMark=>{const newFrom=mapping.map(oldMark.from),newTo=mapping.map(oldMark.to),newMarks=getMarksBetween$3(newFrom,newTo,newState.doc).filter((item=>item.mark.type===options.type));if(!newMarks.length)return;const newMark=newMarks[0],oldLinkText=oldState.doc.textBetween(oldMark.from,oldMark.to,void 0," "),newLinkText=newState.doc.textBetween(newMark.from,newMark.to,void 0," "),wasLink=test$3(oldLinkText),isLink=test$3(newLinkText);
// remove only the link, if it was a link before too
// because we don’t want to remove links that were set manually
wasLink&&!isLink&&tr.removeMark(newMark.from,newMark.to,options.type)})),
// now let’s see if we can add new links
findChildrenInRange$3(newState.doc,newRange,(node=>node.isTextblock)).forEach((textBlock=>{
// we need to define a placeholder for leaf nodes
// so that the link position can be calculated correctly
const text=newState.doc.textBetween(textBlock.pos,textBlock.pos+textBlock.node.nodeSize,void 0," ");find$2$3(text).filter((link=>link.isLink)).filter((link=>!options.validate||options.validate(link.value))).map((link=>({...link,from:textBlock.pos+link.start+1,to:textBlock.pos+link.end+1})
// check if link is within the changed range
)).filter((link=>{const fromIsInRange=newRange.from>=link.from&&newRange.from<=link.to,toIsInRange=newRange.to>=link.from&&newRange.to<=link.to;return fromIsInRange||toIsInRange})).forEach((link=>{tr.addMark(link.from,link.to,options.type.create({href:link.href}))}))}))})),tr.steps.length?tr:void 0}})}function clickHandler$3(options){return new Plugin$3({key:new PluginKey$3("handleClickLink"),props:{handleClick:(view,pos,event)=>{var _a;const attrs=getAttributes$3(view.state,options.type.name),link=null===(_a=event.target)||void 0===_a?void 0:_a.closest("a");return!(!link||!attrs.href)&&(window.open(attrs.href,attrs.target),!0)}}})}function pasteHandler$3(options){return new Plugin$3({key:new PluginKey$3("handlePasteLink"),props:{handlePaste:(view,event,slice)=>{const{state:state}=view,{selection:selection}=state,{empty:empty}=selection;if(empty)return!1;let textContent="";slice.content.forEach((node=>{textContent+=node.textContent}));const link=find$2$3(textContent).find((item=>item.isLink&&item.value===textContent));return!(!textContent||!link)&&(options.editor.commands.setMark(options.type,{href:link.href}),!0)}}})}const Link$1$3=Mark$4.create({name:"link",priority:1e3,keepOnSplit:!1,onCreate(){this.options.protocols.forEach(registerCustomProtocol$3)},inclusive(){return this.options.autolink},addOptions(){return{openOnClick:!0,linkOnPaste:!0,autolink:!0,protocols:[],HTMLAttributes:{target:"_blank",rel:"noopener noreferrer nofollow",class:null},validate:void 0}},addAttributes(){return{href:{default:null},target:{default:this.options.HTMLAttributes.target},class:{default:this.options.HTMLAttributes.class}}},parseHTML(){return[{tag:'a[href]:not([href *= "javascript:" i])'}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["a",mergeAttributes$3(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setLink:attributes=>({chain:chain})=>chain().setMark(this.name,attributes).setMeta("preventAutolink",!0).run(),toggleLink:attributes=>({chain:chain})=>chain().toggleMark(this.name,attributes,{extendEmptyMarkRange:!0}).setMeta("preventAutolink",!0).run(),unsetLink:()=>({chain:chain})=>chain().unsetMark(this.name,{extendEmptyMarkRange:!0}).setMeta("preventAutolink",!0).run()}},addPasteRules(){return[markPasteRule$3({find:text=>find$2$3(text).filter((link=>!this.options.validate||this.options.validate(link.value))).filter((link=>link.isLink)).map((link=>({text:link.value,index:link.start,data:link}))),type:this.type,getAttributes:match=>{var _a;return{href:null===(_a=match.data)||void 0===_a?void 0:_a.href}}})]},addProseMirrorPlugins(){const plugins=[];return this.options.autolink&&plugins.push(autolink$3({type:this.type,validate:this.options.validate})),this.options.openOnClick&&plugins.push(clickHandler$3({type:this.type})),this.options.linkOnPaste&&plugins.push(pasteHandler$3({editor:this.editor,type:this.type})),plugins}});function _typeof$7(obj){return _typeof$7="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof$7(obj)}function _defineProperty$1$3(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _classCallCheck$3(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _defineProperties$3(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass$3(Constructor,protoProps,staticProps){return protoProps&&_defineProperties$3(Constructor.prototype,protoProps),staticProps&&_defineProperties$3(Constructor,staticProps),Object.defineProperty(Constructor,"prototype",{writable:!1}),Constructor}
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */Link$1$3.extend({addAttributes(){return{href:{default:null},target:{default:this.options.HTMLAttributes.target},style:{default:null}}}});var isBrowser$2$3="undefined"!==typeof window&&"undefined"!==typeof document&&"undefined"!==typeof navigator,timeoutDuration$1$3=function(){for(var longerTimeoutBrowsers=["Edge","Trident","Firefox"],i=0;i<longerTimeoutBrowsers.length;i+=1)if(isBrowser$2$3&&navigator.userAgent.indexOf(longerTimeoutBrowsers[i])>=0)return 1;return 0}();function microtaskDebounce$1$3(fn){var called=!1;return function(){called||(called=!0,window.Promise.resolve().then((function(){called=!1,fn()})))}}function taskDebounce$1$3(fn){var scheduled=!1;return function(){scheduled||(scheduled=!0,setTimeout((function(){scheduled=!1,fn()}),timeoutDuration$1$3))}}var supportsMicroTasks$1$3=isBrowser$2$3&&window.Promise,debounce$2$3=supportsMicroTasks$1$3?microtaskDebounce$1$3:taskDebounce$1$3;
/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction$1$3(functionToCheck){var getType={};return functionToCheck&&"[object Function]"===getType.toString.call(functionToCheck)}
/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */function getStyleComputedProperty$1$3(element,property){if(1!==element.nodeType)return[];
// NOTE: 1 DOM access here
var window=element.ownerDocument.defaultView,css=window.getComputedStyle(element,null);return property?css[property]:css}
/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */function getParentNode$1$3(element){return"HTML"===element.nodeName?element:element.parentNode||element.host}
/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */function getScrollParent$1$3(element){
// Return body, `getScroll` will take care to get the correct `scrollTop` from it
if(!element)return document.body;switch(element.nodeName){case"HTML":case"BODY":return element.ownerDocument.body;case"#document":return element.body}
// Firefox want us to check `-x` and `-y` variations as well
var _getStyleComputedProp=getStyleComputedProperty$1$3(element),overflow=_getStyleComputedProp.overflow,overflowX=_getStyleComputedProp.overflowX,overflowY=_getStyleComputedProp.overflowY;return/(auto|scroll|overlay)/.test(overflow+overflowY+overflowX)?element:getScrollParent$1$3(getParentNode$1$3(element))}
/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */function getReferenceNode$1$3(reference){return reference&&reference.referenceNode?reference.referenceNode:reference}var isIE11$1$3=isBrowser$2$3&&!(!window.MSInputMethodContext||!document.documentMode),isIE10$1$3=isBrowser$2$3&&/MSIE 10/.test(navigator.userAgent);
/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE$3$3(version){return 11===version?isIE11$1$3:10===version?isIE10$1$3:isIE11$1$3||isIE10$1$3}
/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */function getOffsetParent$1$3(element){if(!element)return document.documentElement;var noOffsetParent=isIE$3$3(10)?document.body:null,offsetParent=element.offsetParent||null;
// NOTE: 1 DOM access here
// Skip hidden elements which don't have an offsetParent
while(offsetParent===noOffsetParent&&element.nextElementSibling)offsetParent=(element=element.nextElementSibling).offsetParent;var nodeName=offsetParent&&offsetParent.nodeName;return nodeName&&"BODY"!==nodeName&&"HTML"!==nodeName?
// .offsetParent will return the closest TH, TD or TABLE in case
// no offsetParent is present, I hate this job...
-1!==["TH","TD","TABLE"].indexOf(offsetParent.nodeName)&&"static"===getStyleComputedProperty$1$3(offsetParent,"position")?getOffsetParent$1$3(offsetParent):offsetParent:element?element.ownerDocument.documentElement:document.documentElement}function isOffsetContainer$1$3(element){var nodeName=element.nodeName;return"BODY"!==nodeName&&("HTML"===nodeName||getOffsetParent$1$3(element.firstElementChild)===element)}
/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */function getRoot$1$3(node){return null!==node.parentNode?getRoot$1$3(node.parentNode):node}
/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */function findCommonOffsetParent$1$3(element1,element2){
// This check is needed to avoid errors in case one of the elements isn't defined for any reason
if(!element1||!element1.nodeType||!element2||!element2.nodeType)return document.documentElement;
// Here we make sure to give as "start" the element that comes first in the DOM
var order=element1.compareDocumentPosition(element2)&Node.DOCUMENT_POSITION_FOLLOWING,start=order?element1:element2,end=order?element2:element1,range=document.createRange();range.setStart(start,0),range.setEnd(end,0);var commonAncestorContainer=range.commonAncestorContainer;
// Both nodes are inside #document
if(element1!==commonAncestorContainer&&element2!==commonAncestorContainer||start.contains(end))return isOffsetContainer$1$3(commonAncestorContainer)?commonAncestorContainer:getOffsetParent$1$3(commonAncestorContainer);
// one of the nodes is inside shadowDOM, find which one
var element1root=getRoot$1$3(element1);return element1root.host?findCommonOffsetParent$1$3(element1root.host,element2):findCommonOffsetParent$1$3(element1,getRoot$1$3(element2).host)}
/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */function getScroll$1$3(element){var side=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"top",upperSide="top"===side?"scrollTop":"scrollLeft",nodeName=element.nodeName;if("BODY"===nodeName||"HTML"===nodeName){var html=element.ownerDocument.documentElement,scrollingElement=element.ownerDocument.scrollingElement||html;return scrollingElement[upperSide]}return element[upperSide]}
/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */function includeScroll$1$3(rect,element){var subtract=arguments.length>2&&void 0!==arguments[2]&&arguments[2],scrollTop=getScroll$1$3(element,"top"),scrollLeft=getScroll$1$3(element,"left"),modifier=subtract?-1:1;return rect.top+=scrollTop*modifier,rect.bottom+=scrollTop*modifier,rect.left+=scrollLeft*modifier,rect.right+=scrollLeft*modifier,rect}
/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */function getBordersSize$1$3(styles,axis){var sideA="x"===axis?"Left":"Top",sideB="Left"===sideA?"Right":"Bottom";return parseFloat(styles["border"+sideA+"Width"])+parseFloat(styles["border"+sideB+"Width"])}function getSize$1$3(axis,body,html,computedStyle){return Math.max(body["offset"+axis],body["scroll"+axis],html["client"+axis],html["offset"+axis],html["scroll"+axis],isIE$3$3(10)?parseInt(html["offset"+axis])+parseInt(computedStyle["margin"+("Height"===axis?"Top":"Left")])+parseInt(computedStyle["margin"+("Height"===axis?"Bottom":"Right")]):0)}function getWindowSizes$1$3(document){var body=document.body,html=document.documentElement,computedStyle=isIE$3$3(10)&&getComputedStyle(html);return{height:getSize$1$3("Height",body,html,computedStyle),width:getSize$1$3("Width",body,html,computedStyle)}}var classCallCheck$1$3=function(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")},createClass$1$3=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),defineProperty$1$3=function(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj},_extends$2$3=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target};
/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect$1$3(offsets){return _extends$2$3({},offsets,{right:offsets.left+offsets.width,bottom:offsets.top+offsets.height})}
/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */function getBoundingClientRect$1$3(element){var rect={};
// IE10 10 FIX: Please, don't ask, the element isn't
// considered in DOM in some circumstances...
// This isn't reproducible in IE10 compatibility mode of IE11
try{if(isIE$3$3(10)){rect=element.getBoundingClientRect();var scrollTop=getScroll$1$3(element,"top"),scrollLeft=getScroll$1$3(element,"left");rect.top+=scrollTop,rect.left+=scrollLeft,rect.bottom+=scrollTop,rect.right+=scrollLeft}else rect=element.getBoundingClientRect()}catch(e){}var result={left:rect.left,top:rect.top,width:rect.right-rect.left,height:rect.bottom-rect.top},sizes="HTML"===element.nodeName?getWindowSizes$1$3(element.ownerDocument):{},width=sizes.width||element.clientWidth||result.width,height=sizes.height||element.clientHeight||result.height,horizScrollbar=element.offsetWidth-width,vertScrollbar=element.offsetHeight-height;
// subtract scrollbar size from sizes
// if an hypothetical scrollbar is detected, we must be sure it's not a `border`
// we make this check conditional for performance reasons
if(horizScrollbar||vertScrollbar){var styles=getStyleComputedProperty$1$3(element);horizScrollbar-=getBordersSize$1$3(styles,"x"),vertScrollbar-=getBordersSize$1$3(styles,"y"),result.width-=horizScrollbar,result.height-=vertScrollbar}return getClientRect$1$3(result)}function getOffsetRectRelativeToArbitraryNode$1$3(children,parent){var fixedPosition=arguments.length>2&&void 0!==arguments[2]&&arguments[2],isIE10=isIE$3$3(10),isHTML="HTML"===parent.nodeName,childrenRect=getBoundingClientRect$1$3(children),parentRect=getBoundingClientRect$1$3(parent),scrollParent=getScrollParent$1$3(children),styles=getStyleComputedProperty$1$3(parent),borderTopWidth=parseFloat(styles.borderTopWidth),borderLeftWidth=parseFloat(styles.borderLeftWidth);
// In cases where the parent is fixed, we must ignore negative scroll in offset calc
fixedPosition&&isHTML&&(parentRect.top=Math.max(parentRect.top,0),parentRect.left=Math.max(parentRect.left,0));var offsets=getClientRect$1$3({top:childrenRect.top-parentRect.top-borderTopWidth,left:childrenRect.left-parentRect.left-borderLeftWidth,width:childrenRect.width,height:childrenRect.height});
// Subtract margins of documentElement in case it's being used as parent
// we do this only on HTML because it's the only element that behaves
// differently when margins are applied to it. The margins are included in
// the box of the documentElement, in the other cases not.
if(offsets.marginTop=0,offsets.marginLeft=0,!isIE10&&isHTML){var marginTop=parseFloat(styles.marginTop),marginLeft=parseFloat(styles.marginLeft);offsets.top-=borderTopWidth-marginTop,offsets.bottom-=borderTopWidth-marginTop,offsets.left-=borderLeftWidth-marginLeft,offsets.right-=borderLeftWidth-marginLeft,
// Attach marginTop and marginLeft because in some circumstances we may need them
offsets.marginTop=marginTop,offsets.marginLeft=marginLeft}return(isIE10&&!fixedPosition?parent.contains(scrollParent):parent===scrollParent&&"BODY"!==scrollParent.nodeName)&&(offsets=includeScroll$1$3(offsets,parent)),offsets}function getViewportOffsetRectRelativeToArtbitraryNode$1$3(element){var excludeScroll=arguments.length>1&&void 0!==arguments[1]&&arguments[1],html=element.ownerDocument.documentElement,relativeOffset=getOffsetRectRelativeToArbitraryNode$1$3(element,html),width=Math.max(html.clientWidth,window.innerWidth||0),height=Math.max(html.clientHeight,window.innerHeight||0),scrollTop=excludeScroll?0:getScroll$1$3(html),scrollLeft=excludeScroll?0:getScroll$1$3(html,"left"),offset={top:scrollTop-relativeOffset.top+relativeOffset.marginTop,left:scrollLeft-relativeOffset.left+relativeOffset.marginLeft,width:width,height:height};return getClientRect$1$3(offset)}
/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */function isFixed$1$3(element){var nodeName=element.nodeName;if("BODY"===nodeName||"HTML"===nodeName)return!1;if("fixed"===getStyleComputedProperty$1$3(element,"position"))return!0;var parentNode=getParentNode$1$3(element);return!!parentNode&&isFixed$1$3(parentNode)}
/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */function getFixedPositionOffsetParent$1$3(element){
// This check is needed to avoid errors in case one of the elements isn't defined for any reason
if(!element||!element.parentElement||isIE$3$3())return document.documentElement;var el=element.parentElement;while(el&&"none"===getStyleComputedProperty$1$3(el,"transform"))el=el.parentElement;return el||document.documentElement}
/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */function getBoundaries$1$3(popper,reference,padding,boundariesElement){var fixedPosition=arguments.length>4&&void 0!==arguments[4]&&arguments[4],boundaries={top:0,left:0},offsetParent=fixedPosition?getFixedPositionOffsetParent$1$3(popper):findCommonOffsetParent$1$3(popper,getReferenceNode$1$3(reference));
// NOTE: 1 DOM access here
// Handle viewport case
if("viewport"===boundariesElement)boundaries=getViewportOffsetRectRelativeToArtbitraryNode$1$3(offsetParent,fixedPosition);else{
// Handle other cases based on DOM element used as boundaries
var boundariesNode=void 0;"scrollParent"===boundariesElement?(boundariesNode=getScrollParent$1$3(getParentNode$1$3(reference)),"BODY"===boundariesNode.nodeName&&(boundariesNode=popper.ownerDocument.documentElement)):boundariesNode="window"===boundariesElement?popper.ownerDocument.documentElement:boundariesElement;var offsets=getOffsetRectRelativeToArbitraryNode$1$3(boundariesNode,offsetParent,fixedPosition);
// In case of HTML, we need a different computation
if("HTML"!==boundariesNode.nodeName||isFixed$1$3(offsetParent))
// for all the other DOM elements, this one is good
boundaries=offsets;else{var _getWindowSizes=getWindowSizes$1$3(popper.ownerDocument),height=_getWindowSizes.height,width=_getWindowSizes.width;boundaries.top+=offsets.top-offsets.marginTop,boundaries.bottom=height+offsets.top,boundaries.left+=offsets.left-offsets.marginLeft,boundaries.right=width+offsets.left}}
// Add paddings
padding=padding||0;var isPaddingNumber="number"===typeof padding;return boundaries.left+=isPaddingNumber?padding:padding.left||0,boundaries.top+=isPaddingNumber?padding:padding.top||0,boundaries.right-=isPaddingNumber?padding:padding.right||0,boundaries.bottom-=isPaddingNumber?padding:padding.bottom||0,boundaries}function getArea$1$3(_ref){var width=_ref.width,height=_ref.height;return width*height}
/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function computeAutoPlacement$1$3(placement,refRect,popper,reference,boundariesElement){var padding=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(-1===placement.indexOf("auto"))return placement;var boundaries=getBoundaries$1$3(popper,reference,padding,boundariesElement),rects={top:{width:boundaries.width,height:refRect.top-boundaries.top},right:{width:boundaries.right-refRect.right,height:boundaries.height},bottom:{width:boundaries.width,height:boundaries.bottom-refRect.bottom},left:{width:refRect.left-boundaries.left,height:boundaries.height}},sortedAreas=Object.keys(rects).map((function(key){return _extends$2$3({key:key},rects[key],{area:getArea$1$3(rects[key])})})).sort((function(a,b){return b.area-a.area})),filteredAreas=sortedAreas.filter((function(_ref2){var width=_ref2.width,height=_ref2.height;return width>=popper.clientWidth&&height>=popper.clientHeight})),computedPlacement=filteredAreas.length>0?filteredAreas[0].key:sortedAreas[0].key,variation=placement.split("-")[1];return computedPlacement+(variation?"-"+variation:"")}
/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */function getReferenceOffsets$1$3(state,popper,reference){var fixedPosition=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,commonOffsetParent=fixedPosition?getFixedPositionOffsetParent$1$3(popper):findCommonOffsetParent$1$3(popper,getReferenceNode$1$3(reference));return getOffsetRectRelativeToArbitraryNode$1$3(reference,commonOffsetParent,fixedPosition)}
/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */function getOuterSizes$1$3(element){var window=element.ownerDocument.defaultView,styles=window.getComputedStyle(element),x=parseFloat(styles.marginTop||0)+parseFloat(styles.marginBottom||0),y=parseFloat(styles.marginLeft||0)+parseFloat(styles.marginRight||0),result={width:element.offsetWidth+y,height:element.offsetHeight+x};return result}
/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */function getOppositePlacement$1$3(placement){var hash={left:"right",right:"left",bottom:"top",top:"bottom"};return placement.replace(/left|right|bottom|top/g,(function(matched){return hash[matched]}))}
/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */function getPopperOffsets$1$3(popper,referenceOffsets,placement){placement=placement.split("-")[0];
// Get popper node sizes
var popperRect=getOuterSizes$1$3(popper),popperOffsets={width:popperRect.width,height:popperRect.height},isHoriz=-1!==["right","left"].indexOf(placement),mainSide=isHoriz?"top":"left",secondarySide=isHoriz?"left":"top",measurement=isHoriz?"height":"width",secondaryMeasurement=isHoriz?"width":"height";
// Add position, width and height to our offsets object
return popperOffsets[mainSide]=referenceOffsets[mainSide]+referenceOffsets[measurement]/2-popperRect[measurement]/2,popperOffsets[secondarySide]=placement===secondarySide?referenceOffsets[secondarySide]-popperRect[secondaryMeasurement]:referenceOffsets[getOppositePlacement$1$3(secondarySide)],popperOffsets}
/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */function find$1$3(arr,check){
// use native find if supported
return Array.prototype.find?arr.find(check):arr.filter(check)[0];
// use `filter` to obtain the same behavior of `find`
}
/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */function findIndex$1$3(arr,prop,value){
// use native findIndex if supported
if(Array.prototype.findIndex)return arr.findIndex((function(cur){return cur[prop]===value}));
// use `find` + `indexOf` if `findIndex` isn't supported
var match=find$1$3(arr,(function(obj){return obj[prop]===value}));return arr.indexOf(match)}
/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */function runModifiers$1$3(modifiers,data,ends){var modifiersToRun=void 0===ends?modifiers:modifiers.slice(0,findIndex$1$3(modifiers,"name",ends));return modifiersToRun.forEach((function(modifier){modifier["function"];var fn=modifier["function"]||modifier.fn;// eslint-disable-line dot-notation
modifier.enabled&&isFunction$1$3(fn)&&(
// Add properties to offsets to make them a complete clientRect object
// we do this before each modifier to make sure the previous one doesn't
// mess with these values
data.offsets.popper=getClientRect$1$3(data.offsets.popper),data.offsets.reference=getClientRect$1$3(data.offsets.reference),data=fn(data,modifier))})),data}
/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */function update$1$3(){
// if popper is destroyed, don't perform any further update
if(!this.state.isDestroyed){var data={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};
// compute reference element offsets
data.offsets.reference=getReferenceOffsets$1$3(this.state,this.popper,this.reference,this.options.positionFixed),
// compute auto placement, store placement inside the data object,
// modifiers will be able to edit `placement` if needed
// and refer to originalPlacement to know the original value
data.placement=computeAutoPlacement$1$3(this.options.placement,data.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),
// store the computed placement inside `originalPlacement`
data.originalPlacement=data.placement,data.positionFixed=this.options.positionFixed,
// compute the popper offsets
data.offsets.popper=getPopperOffsets$1$3(this.popper,data.offsets.reference,data.placement),data.offsets.popper.position=this.options.positionFixed?"fixed":"absolute",
// run the modifiers
data=runModifiers$1$3(this.modifiers,data),
// the first `update` will call `onCreate` callback
// the other ones will call `onUpdate` callback
this.state.isCreated?this.options.onUpdate(data):(this.state.isCreated=!0,this.options.onCreate(data))}}
/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */function isModifierEnabled$1$3(modifiers,modifierName){return modifiers.some((function(_ref){var name=_ref.name,enabled=_ref.enabled;return enabled&&name===modifierName}))}
/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */function getSupportedPropertyName$1$3(property){for(var prefixes=[!1,"ms","Webkit","Moz","O"],upperProp=property.charAt(0).toUpperCase()+property.slice(1),i=0;i<prefixes.length;i++){var prefix=prefixes[i],toCheck=prefix?""+prefix+upperProp:property;if("undefined"!==typeof document.body.style[toCheck])return toCheck}return null}
/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */function destroy$1$3(){return this.state.isDestroyed=!0,
// touch DOM only if `applyStyle` modifier is enabled
isModifierEnabled$1$3(this.modifiers,"applyStyle")&&(this.popper.removeAttribute("x-placement"),this.popper.style.position="",this.popper.style.top="",this.popper.style.left="",this.popper.style.right="",this.popper.style.bottom="",this.popper.style.willChange="",this.popper.style[getSupportedPropertyName$1$3("transform")]=""),this.disableEventListeners(),
// remove the popper if user explicitly asked for the deletion on destroy
// do not use `remove` because IE11 doesn't support it
this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}
/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */function getWindow$1$3(element){var ownerDocument=element.ownerDocument;return ownerDocument?ownerDocument.defaultView:window}function attachToScrollParents$1$3(scrollParent,event,callback,scrollParents){var isBody="BODY"===scrollParent.nodeName,target=isBody?scrollParent.ownerDocument.defaultView:scrollParent;target.addEventListener(event,callback,{passive:!0}),isBody||attachToScrollParents$1$3(getScrollParent$1$3(target.parentNode),event,callback,scrollParents),scrollParents.push(target)}
/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */function setupEventListeners$1$3(reference,options,state,updateBound){
// Resize event listener on window
state.updateBound=updateBound,getWindow$1$3(reference).addEventListener("resize",state.updateBound,{passive:!0});
// Scroll event listener on scroll parents
var scrollElement=getScrollParent$1$3(reference);return attachToScrollParents$1$3(scrollElement,"scroll",state.updateBound,state.scrollParents),state.scrollElement=scrollElement,state.eventsEnabled=!0,state}
/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */function enableEventListeners$1$3(){this.state.eventsEnabled||(this.state=setupEventListeners$1$3(this.reference,this.options,this.state,this.scheduleUpdate))}
/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */function removeEventListeners$1$3(reference,state){
// Remove resize event listener on window
return getWindow$1$3(reference).removeEventListener("resize",state.updateBound),
// Remove scroll event listener on scroll parents
state.scrollParents.forEach((function(target){target.removeEventListener("scroll",state.updateBound)})),
// Reset state
state.updateBound=null,state.scrollParents=[],state.scrollElement=null,state.eventsEnabled=!1,state}
/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */function disableEventListeners$1$3(){this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=removeEventListeners$1$3(this.reference,this.state))}
/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */function isNumeric$1$3(n){return""!==n&&!isNaN(parseFloat(n))&&isFinite(n)}
/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */function setStyles$1$3(element,styles){Object.keys(styles).forEach((function(prop){var unit="";
// add unit if the value is numeric and is one of the following
-1!==["width","height","top","right","bottom","left"].indexOf(prop)&&isNumeric$1$3(styles[prop])&&(unit="px"),element.style[prop]=styles[prop]+unit}))}
/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */function setAttributes$1$3(element,attributes){Object.keys(attributes).forEach((function(prop){var value=attributes[prop];!1!==value?element.setAttribute(prop,attributes[prop]):element.removeAttribute(prop)}))}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */function applyStyle$1$3(data){
// any property present in `data.styles` will be applied to the popper,
// in this way we can make the 3rd party modifiers add custom styles to it
// Be aware, modifiers could override the properties defined in the previous
// lines of this modifier!
return setStyles$1$3(data.instance.popper,data.styles),
// any property present in `data.attributes` will be applied to the popper,
// they will be set as HTML attributes of the element
setAttributes$1$3(data.instance.popper,data.attributes),
// if arrowElement is defined and arrowStyles has some properties
data.arrowElement&&Object.keys(data.arrowStyles).length&&setStyles$1$3(data.arrowElement,data.arrowStyles),data}
/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */function applyStyleOnLoad$1$3(reference,popper,options,modifierOptions,state){
// compute reference element offsets
var referenceOffsets=getReferenceOffsets$1$3(state,popper,reference,options.positionFixed),placement=computeAutoPlacement$1$3(options.placement,referenceOffsets,popper,reference,options.modifiers.flip.boundariesElement,options.modifiers.flip.padding);
// compute auto placement, store placement inside the data object,
// modifiers will be able to edit `placement` if needed
// and refer to originalPlacement to know the original value
return popper.setAttribute("x-placement",placement),
// Apply `position` to popper before anything else because
// without the position applied we can't guarantee correct computations
setStyles$1$3(popper,{position:options.positionFixed?"fixed":"absolute"}),options}
/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */function getRoundedOffsets$1$3(data,shouldRound){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,round=Math.round,floor=Math.floor,noRound=function(v){return v},referenceWidth=round(reference.width),popperWidth=round(popper.width),isVertical=-1!==["left","right"].indexOf(data.placement),isVariation=-1!==data.placement.indexOf("-"),sameWidthParity=referenceWidth%2===popperWidth%2,bothOddWidth=referenceWidth%2===1&&popperWidth%2===1,horizontalToInteger=shouldRound?isVertical||isVariation||sameWidthParity?round:floor:noRound,verticalToInteger=shouldRound?round:noRound;return{left:horizontalToInteger(bothOddWidth&&!isVariation&&shouldRound?popper.left-1:popper.left),top:verticalToInteger(popper.top),bottom:verticalToInteger(popper.bottom),right:horizontalToInteger(popper.right)}}var isFirefox$1$3=isBrowser$2$3&&/Firefox/i.test(navigator.userAgent);
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function computeStyle$1$3(data,options){var x=options.x,y=options.y,popper=data.offsets.popper,legacyGpuAccelerationOption=find$1$3(data.instance.modifiers,(function(modifier){return"applyStyle"===modifier.name})).gpuAcceleration,gpuAcceleration=void 0!==legacyGpuAccelerationOption?legacyGpuAccelerationOption:options.gpuAcceleration,offsetParent=getOffsetParent$1$3(data.instance.popper),offsetParentRect=getBoundingClientRect$1$3(offsetParent),styles={position:popper.position},offsets=getRoundedOffsets$1$3(data,window.devicePixelRatio<2||!isFirefox$1$3),sideA="bottom"===x?"top":"bottom",sideB="right"===y?"left":"right",prefixedProperty=getSupportedPropertyName$1$3("transform"),left=void 0,top=void 0;if(top="bottom"===sideA?
// when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
// and not the bottom of the html element
"HTML"===offsetParent.nodeName?-offsetParent.clientHeight+offsets.bottom:-offsetParentRect.height+offsets.bottom:offsets.top,left="right"===sideB?"HTML"===offsetParent.nodeName?-offsetParent.clientWidth+offsets.right:-offsetParentRect.width+offsets.right:offsets.left,gpuAcceleration&&prefixedProperty)styles[prefixedProperty]="translate3d("+left+"px, "+top+"px, 0)",styles[sideA]=0,styles[sideB]=0,styles.willChange="transform";else{
// othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
var invertTop="bottom"===sideA?-1:1,invertLeft="right"===sideB?-1:1;styles[sideA]=top*invertTop,styles[sideB]=left*invertLeft,styles.willChange=sideA+", "+sideB}
// Attributes
var attributes={"x-placement":data.placement};
// Update `data` attributes, styles and arrowStyles
return data.attributes=_extends$2$3({},attributes,data.attributes),data.styles=_extends$2$3({},styles,data.styles),data.arrowStyles=_extends$2$3({},data.offsets.arrow,data.arrowStyles),data}
/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */function isModifierRequired$1$3(modifiers,requestingName,requestedName){var requesting=find$1$3(modifiers,(function(_ref){var name=_ref.name;return name===requestingName})),isRequired=!!requesting&&modifiers.some((function(modifier){return modifier.name===requestedName&&modifier.enabled&&modifier.order<requesting.order}));if(!isRequired);return isRequired}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function arrow$1$3(data,options){var _data$offsets$arrow;
// arrow depends on keepTogether in order to work
if(!isModifierRequired$1$3(data.instance.modifiers,"arrow","keepTogether"))return data;var arrowElement=options.element;
// if arrowElement is a string, suppose it's a CSS selector
if("string"===typeof arrowElement){
// if arrowElement is not found, don't run the modifier
if(arrowElement=data.instance.popper.querySelector(arrowElement),!arrowElement)return data}else
// if the arrowElement isn't a query selector we must check that the
// provided DOM node is child of its popper node
if(!data.instance.popper.contains(arrowElement))return data;var placement=data.placement.split("-")[0],_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,isVertical=-1!==["left","right"].indexOf(placement),len=isVertical?"height":"width",sideCapitalized=isVertical?"Top":"Left",side=sideCapitalized.toLowerCase(),altSide=isVertical?"left":"top",opSide=isVertical?"bottom":"right",arrowElementSize=getOuterSizes$1$3(arrowElement)[len];
// extends keepTogether behavior making sure the popper and its
// reference have enough pixels in conjunction
// top/left side
reference[opSide]-arrowElementSize<popper[side]&&(data.offsets.popper[side]-=popper[side]-(reference[opSide]-arrowElementSize)),
// bottom/right side
reference[side]+arrowElementSize>popper[opSide]&&(data.offsets.popper[side]+=reference[side]+arrowElementSize-popper[opSide]),data.offsets.popper=getClientRect$1$3(data.offsets.popper);
// compute center of the popper
var center=reference[side]+reference[len]/2-arrowElementSize/2,css=getStyleComputedProperty$1$3(data.instance.popper),popperMarginSide=parseFloat(css["margin"+sideCapitalized]),popperBorderSide=parseFloat(css["border"+sideCapitalized+"Width"]),sideValue=center-data.offsets.popper[side]-popperMarginSide-popperBorderSide;
// Compute the sideValue using the updated popper offsets
// take popper margin in account because we don't have this info available
// prevent arrowElement from being placed not contiguously to its popper
return sideValue=Math.max(Math.min(popper[len]-arrowElementSize,sideValue),0),data.arrowElement=arrowElement,data.offsets.arrow=(_data$offsets$arrow={},defineProperty$1$3(_data$offsets$arrow,side,Math.round(sideValue)),defineProperty$1$3(_data$offsets$arrow,altSide,""),_data$offsets$arrow),data}
/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */function getOppositeVariation$1$3(variation){return"end"===variation?"start":"start"===variation?"end":variation}
/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */var placements$1$3=["auto-start","auto","auto-end","top-start","top","top-end","right-start","right","right-end","bottom-end","bottom","bottom-start","left-end","left","left-start"],validPlacements$1$3=placements$1$3.slice(3);
// Get rid of `auto` `auto-start` and `auto-end`
/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise$1$3(placement){var counter=arguments.length>1&&void 0!==arguments[1]&&arguments[1],index=validPlacements$1$3.indexOf(placement),arr=validPlacements$1$3.slice(index+1).concat(validPlacements$1$3.slice(0,index));return counter?arr.reverse():arr}var BEHAVIORS$1$3={FLIP:"flip",CLOCKWISE:"clockwise",COUNTERCLOCKWISE:"counterclockwise"};
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function flip$1$3(data,options){
// if `inner` modifier is enabled, we can't use the `flip` modifier
if(isModifierEnabled$1$3(data.instance.modifiers,"inner"))return data;if(data.flipped&&data.placement===data.originalPlacement)
// seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
return data;var boundaries=getBoundaries$1$3(data.instance.popper,data.instance.reference,options.padding,options.boundariesElement,data.positionFixed),placement=data.placement.split("-")[0],placementOpposite=getOppositePlacement$1$3(placement),variation=data.placement.split("-")[1]||"",flipOrder=[];switch(options.behavior){case BEHAVIORS$1$3.FLIP:flipOrder=[placement,placementOpposite];break;case BEHAVIORS$1$3.CLOCKWISE:flipOrder=clockwise$1$3(placement);break;case BEHAVIORS$1$3.COUNTERCLOCKWISE:flipOrder=clockwise$1$3(placement,!0);break;default:flipOrder=options.behavior}return flipOrder.forEach((function(step,index){if(placement!==step||flipOrder.length===index+1)return data;placement=data.placement.split("-")[0],placementOpposite=getOppositePlacement$1$3(placement);var popperOffsets=data.offsets.popper,refOffsets=data.offsets.reference,floor=Math.floor,overlapsRef="left"===placement&&floor(popperOffsets.right)>floor(refOffsets.left)||"right"===placement&&floor(popperOffsets.left)<floor(refOffsets.right)||"top"===placement&&floor(popperOffsets.bottom)>floor(refOffsets.top)||"bottom"===placement&&floor(popperOffsets.top)<floor(refOffsets.bottom),overflowsLeft=floor(popperOffsets.left)<floor(boundaries.left),overflowsRight=floor(popperOffsets.right)>floor(boundaries.right),overflowsTop=floor(popperOffsets.top)<floor(boundaries.top),overflowsBottom=floor(popperOffsets.bottom)>floor(boundaries.bottom),overflowsBoundaries="left"===placement&&overflowsLeft||"right"===placement&&overflowsRight||"top"===placement&&overflowsTop||"bottom"===placement&&overflowsBottom,isVertical=-1!==["top","bottom"].indexOf(placement),flippedVariationByRef=!!options.flipVariations&&(isVertical&&"start"===variation&&overflowsLeft||isVertical&&"end"===variation&&overflowsRight||!isVertical&&"start"===variation&&overflowsTop||!isVertical&&"end"===variation&&overflowsBottom),flippedVariationByContent=!!options.flipVariationsByContent&&(isVertical&&"start"===variation&&overflowsRight||isVertical&&"end"===variation&&overflowsLeft||!isVertical&&"start"===variation&&overflowsBottom||!isVertical&&"end"===variation&&overflowsTop),flippedVariation=flippedVariationByRef||flippedVariationByContent;(overlapsRef||overflowsBoundaries||flippedVariation)&&(
// this boolean to detect any flip loop
data.flipped=!0,(overlapsRef||overflowsBoundaries)&&(placement=flipOrder[index+1]),flippedVariation&&(variation=getOppositeVariation$1$3(variation)),data.placement=placement+(variation?"-"+variation:""),
// this object contains `position`, we want to preserve it along with
// any additional property we may add in the future
data.offsets.popper=_extends$2$3({},data.offsets.popper,getPopperOffsets$1$3(data.instance.popper,data.offsets.reference,data.placement)),data=runModifiers$1$3(data.instance.modifiers,data,"flip"))})),data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function keepTogether$1$3(data){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,placement=data.placement.split("-")[0],floor=Math.floor,isVertical=-1!==["top","bottom"].indexOf(placement),side=isVertical?"right":"bottom",opSide=isVertical?"left":"top",measurement=isVertical?"width":"height";return popper[side]<floor(reference[opSide])&&(data.offsets.popper[opSide]=floor(reference[opSide])-popper[measurement]),popper[opSide]>floor(reference[side])&&(data.offsets.popper[opSide]=floor(reference[side])),data}
/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */function toValue$1$3(str,measurement,popperOffsets,referenceOffsets){
// separate value from unit
var split=str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),value=+split[1],unit=split[2];
// If it's not a number it's an operator, I guess
if(!value)return str;if(0===unit.indexOf("%")){var element=void 0;switch(unit){case"%p":element=popperOffsets;break;case"%":case"%r":default:element=referenceOffsets}var rect=getClientRect$1$3(element);return rect[measurement]/100*value}if("vh"===unit||"vw"===unit){
// if is a vh or vw, we calculate the size based on the viewport
var size=void 0;return size="vh"===unit?Math.max(document.documentElement.clientHeight,window.innerHeight||0):Math.max(document.documentElement.clientWidth,window.innerWidth||0),size/100*value}
// if is an explicit pixel unit, we get rid of the unit and keep the value
// if is an implicit unit, it's px, and we return just the value
return value}
/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */function parseOffset$1$3(offset,popperOffsets,referenceOffsets,basePlacement){var offsets=[0,0],useHeight=-1!==["right","left"].indexOf(basePlacement),fragments=offset.split(/(\+|\-)/).map((function(frag){return frag.trim()})),divider=fragments.indexOf(find$1$3(fragments,(function(frag){return-1!==frag.search(/,|\s/)})));
// Use height if placement is left or right and index is 0 otherwise use width
// in this way the first offset will use an axis and the second one
// will use the other one
fragments[divider]&&fragments[divider].indexOf(",");
// If divider is found, we divide the list of values and operands to divide
// them by ofset X and Y.
var splitRegex=/\s*,\s*|\s+/,ops=-1!==divider?[fragments.slice(0,divider).concat([fragments[divider].split(splitRegex)[0]]),[fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider+1))]:[fragments];
// Convert the values with units to absolute pixels to allow our computations
return ops=ops.map((function(op,index){
// Most of the units rely on the orientation of the popper
var measurement=(1===index?!useHeight:useHeight)?"height":"width",mergeWithPrevious=!1;return op.reduce((function(a,b){return""===a[a.length-1]&&-1!==["+","-"].indexOf(b)?(a[a.length-1]=b,mergeWithPrevious=!0,a):mergeWithPrevious?(a[a.length-1]+=b,mergeWithPrevious=!1,a):a.concat(b)}),[]).map((function(str){return toValue$1$3(str,measurement,popperOffsets,referenceOffsets)}))})),
// Loop trough the offsets arrays and execute the operations
ops.forEach((function(op,index){op.forEach((function(frag,index2){isNumeric$1$3(frag)&&(offsets[index]+=frag*("-"===op[index2-1]?-1:1))}))})),offsets}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */function offset$1$3(data,_ref){var offset=_ref.offset,placement=data.placement,_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,basePlacement=placement.split("-")[0],offsets=void 0;return offsets=isNumeric$1$3(+offset)?[+offset,0]:parseOffset$1$3(offset,popper,reference,basePlacement),"left"===basePlacement?(popper.top+=offsets[0],popper.left-=offsets[1]):"right"===basePlacement?(popper.top+=offsets[0],popper.left+=offsets[1]):"top"===basePlacement?(popper.left+=offsets[0],popper.top-=offsets[1]):"bottom"===basePlacement&&(popper.left+=offsets[0],popper.top+=offsets[1]),data.popper=popper,data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function preventOverflow$1$3(data,options){var boundariesElement=options.boundariesElement||getOffsetParent$1$3(data.instance.popper);
// If offsetParent is the reference element, we really want to
// go one step up and use the next offsetParent as reference to
// avoid to make this modifier completely useless and look like broken
data.instance.reference===boundariesElement&&(boundariesElement=getOffsetParent$1$3(boundariesElement));
// NOTE: DOM access here
// resets the popper's position so that the document size can be calculated excluding
// the size of the popper element itself
var transformProp=getSupportedPropertyName$1$3("transform"),popperStyles=data.instance.popper.style,top=popperStyles.top,left=popperStyles.left,transform=popperStyles[transformProp];popperStyles.top="",popperStyles.left="",popperStyles[transformProp]="";var boundaries=getBoundaries$1$3(data.instance.popper,data.instance.reference,options.padding,boundariesElement,data.positionFixed);
// NOTE: DOM access here
// restores the original style properties after the offsets have been computed
popperStyles.top=top,popperStyles.left=left,popperStyles[transformProp]=transform,options.boundaries=boundaries;var order=options.priority,popper=data.offsets.popper,check={primary:function(placement){var value=popper[placement];return popper[placement]<boundaries[placement]&&!options.escapeWithReference&&(value=Math.max(popper[placement],boundaries[placement])),defineProperty$1$3({},placement,value)},secondary:function(placement){var mainSide="right"===placement?"left":"top",value=popper[mainSide];return popper[placement]>boundaries[placement]&&!options.escapeWithReference&&(value=Math.min(popper[mainSide],boundaries[placement]-("right"===placement?popper.width:popper.height))),defineProperty$1$3({},mainSide,value)}};return order.forEach((function(placement){var side=-1!==["left","top"].indexOf(placement)?"primary":"secondary";popper=_extends$2$3({},popper,check[side](placement))})),data.offsets.popper=popper,data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function shift$1$3(data){var placement=data.placement,basePlacement=placement.split("-")[0],shiftvariation=placement.split("-")[1];
// if shift shiftvariation is specified, run the modifier
if(shiftvariation){var _data$offsets=data.offsets,reference=_data$offsets.reference,popper=_data$offsets.popper,isVertical=-1!==["bottom","top"].indexOf(basePlacement),side=isVertical?"left":"top",measurement=isVertical?"width":"height",shiftOffsets={start:defineProperty$1$3({},side,reference[side]),end:defineProperty$1$3({},side,reference[side]+reference[measurement]-popper[measurement])};data.offsets.popper=_extends$2$3({},popper,shiftOffsets[shiftvariation])}return data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function hide$1$3(data){if(!isModifierRequired$1$3(data.instance.modifiers,"hide","preventOverflow"))return data;var refRect=data.offsets.reference,bound=find$1$3(data.instance.modifiers,(function(modifier){return"preventOverflow"===modifier.name})).boundaries;if(refRect.bottom<bound.top||refRect.left>bound.right||refRect.top>bound.bottom||refRect.right<bound.left){
// Avoid unnecessary DOM access if visibility hasn't changed
if(!0===data.hide)return data;data.hide=!0,data.attributes["x-out-of-boundaries"]=""}else{
// Avoid unnecessary DOM access if visibility hasn't changed
if(!1===data.hide)return data;data.hide=!1,data.attributes["x-out-of-boundaries"]=!1}return data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function inner$1$3(data){var placement=data.placement,basePlacement=placement.split("-")[0],_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,isHoriz=-1!==["left","right"].indexOf(basePlacement),subtractLength=-1===["top","left"].indexOf(basePlacement);return popper[isHoriz?"left":"top"]=reference[basePlacement]-(subtractLength?popper[isHoriz?"width":"height"]:0),data.placement=getOppositePlacement$1$3(placement),data.offsets.popper=getClientRect$1$3(popper),data}
/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */
/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */var modifiers$1$3={
/**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
shift:{
/** @prop {number} order=100 - Index used to define the order of execution */
order:100,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:shift$1$3},
/**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
offset:{
/** @prop {number} order=200 - Index used to define the order of execution */
order:200,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:offset$1$3,
/** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
offset:0},
/**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
preventOverflow:{
/** @prop {number} order=300 - Index used to define the order of execution */
order:300,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:preventOverflow$1$3,
/**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
priority:["left","right","top","bottom"],
/**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
padding:5,
/**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
boundariesElement:"scrollParent"},
/**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
keepTogether:{
/** @prop {number} order=400 - Index used to define the order of execution */
order:400,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:keepTogether$1$3},
/**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
arrow:{
/** @prop {number} order=500 - Index used to define the order of execution */
order:500,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:arrow$1$3,
/** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
element:"[x-arrow]"},
/**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
flip:{
/** @prop {number} order=600 - Index used to define the order of execution */
order:600,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:flip$1$3,
/**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
behavior:"flip",
/**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
padding:5,
/**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
boundariesElement:"viewport",
/**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
flipVariations:!1,
/**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
flipVariationsByContent:!1},
/**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
inner:{
/** @prop {number} order=700 - Index used to define the order of execution */
order:700,
/** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
enabled:!1,
/** @prop {ModifierFn} */
fn:inner$1$3},
/**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
hide:{
/** @prop {number} order=800 - Index used to define the order of execution */
order:800,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:hide$1$3},
/**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
computeStyle:{
/** @prop {number} order=850 - Index used to define the order of execution */
order:850,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:computeStyle$1$3,
/**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
gpuAcceleration:!0,
/**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
x:"bottom",
/**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
y:"right"},
/**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
applyStyle:{
/** @prop {number} order=900 - Index used to define the order of execution */
order:900,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:applyStyle$1$3,
/** @prop {Function} */
onLoad:applyStyleOnLoad$1$3,
/**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
gpuAcceleration:void 0}},Defaults$1$3={
/**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
placement:"bottom",
/**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
positionFixed:!1,
/**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
eventsEnabled:!0,
/**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
removeOnDestroy:!1,
/**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
onCreate:function(){},
/**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
onUpdate:function(){},
/**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
modifiers:modifiers$1$3},Popper$1$3=function(){
/**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
function Popper(reference,popper){var _this=this,options=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};classCallCheck$1$3(this,Popper),this.scheduleUpdate=function(){return requestAnimationFrame(_this.update)},
// make update() debounced, so that it only runs at most once-per-tick
this.update=debounce$2$3(this.update.bind(this)),
// with {} we create a new object with the options inside it
this.options=_extends$2$3({},Popper.Defaults,options),
// init state
this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},
// get reference and popper elements (allow jQuery wrappers)
this.reference=reference&&reference.jquery?reference[0]:reference,this.popper=popper&&popper.jquery?popper[0]:popper,
// Deep merge modifiers options
this.options.modifiers={},Object.keys(_extends$2$3({},Popper.Defaults.modifiers,options.modifiers)).forEach((function(name){_this.options.modifiers[name]=_extends$2$3({},Popper.Defaults.modifiers[name]||{},options.modifiers?options.modifiers[name]:{})})),
// Refactoring modifiers' list (Object => Array)
this.modifiers=Object.keys(this.options.modifiers).map((function(name){return _extends$2$3({name:name},_this.options.modifiers[name])})).sort((function(a,b){return a.order-b.order})),
// modifiers have the ability to execute arbitrary code when Popper.js get inited
// such code is executed in the same order of its modifier
// they could add new properties to their options configuration
// BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
this.modifiers.forEach((function(modifierOptions){modifierOptions.enabled&&isFunction$1$3(modifierOptions.onLoad)&&modifierOptions.onLoad(_this.reference,_this.popper,_this.options,modifierOptions,_this.state)})),
// fire the first update to position the popper in the right place
this.update();var eventsEnabled=this.options.eventsEnabled;eventsEnabled&&
// setup event listeners, they will take care of update the position in specific situations
this.enableEventListeners(),this.state.eventsEnabled=eventsEnabled}
// We can't use class properties because they don't get listed in the
// class prototype and break stuff like Sinon stubs
return createClass$1$3(Popper,[{key:"update",value:function(){return update$1$3.call(this)}},{key:"destroy",value:function(){return destroy$1$3.call(this)}},{key:"enableEventListeners",value:function(){return enableEventListeners$1$3.call(this)}},{key:"disableEventListeners",value:function(){return disableEventListeners$1$3.call(this)}
/**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */
/**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */}]),Popper}();
/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */
/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */
Popper$1$3.Utils=("undefined"!==typeof window?window:global).PopperUtils,Popper$1$3.placements=placements$1$3,Popper$1$3.Defaults=Defaults$1$3;var isIE$2$3,Popper$2$3=Popper$1$3;function getInternetExplorerVersion$3(){var ua=window.navigator.userAgent,msie=ua.indexOf("MSIE ");if(msie>0)
// IE 10 or older => return version number
return parseInt(ua.substring(msie+5,ua.indexOf(".",msie)),10);var trident=ua.indexOf("Trident/");if(trident>0){
// IE 11 => return version number
var rv=ua.indexOf("rv:");return parseInt(ua.substring(rv+3,ua.indexOf(".",rv)),10)}var edge=ua.indexOf("Edge/");return edge>0?parseInt(ua.substring(edge+5,ua.indexOf(".",edge)),10):-1;// other browser
}

function initCompat$3(){initCompat$3.init||(initCompat$3.init=!0,isIE$2$3=-1!==getInternetExplorerVersion$3())}var script$4$3={name:"ResizeObserver",props:{emitOnMount:{type:Boolean,default:!1},ignoreWidth:{type:Boolean,default:!1},ignoreHeight:{type:Boolean,default:!1}},mounted:function(){var _this=this;initCompat$3(),this.$nextTick((function(){_this._w=_this.$el.offsetWidth,_this._h=_this.$el.offsetHeight,_this.emitOnMount&&_this.emitSize()}));var object=document.createElement("object");this._resizeObject=object,object.setAttribute("aria-hidden","true"),object.setAttribute("tabindex",-1),object.onload=this.addResizeHandlers,object.type="text/html",isIE$2$3&&this.$el.appendChild(object),object.data="about:blank",isIE$2$3||this.$el.appendChild(object)},beforeDestroy:function(){this.removeResizeHandlers()},methods:{compareAndNotify:function(){(!this.ignoreWidth&&this._w!==this.$el.offsetWidth||!this.ignoreHeight&&this._h!==this.$el.offsetHeight)&&(this._w=this.$el.offsetWidth,this._h=this.$el.offsetHeight,this.emitSize())},emitSize:function(){this.$emit("notify",{width:this._w,height:this._h})},addResizeHandlers:function(){this._resizeObject.contentDocument.defaultView.addEventListener("resize",this.compareAndNotify),this.compareAndNotify()},removeResizeHandlers:function(){this._resizeObject&&this._resizeObject.onload&&(!isIE$2$3&&this._resizeObject.contentDocument&&this._resizeObject.contentDocument.defaultView.removeEventListener("resize",this.compareAndNotify),this.$el.removeChild(this._resizeObject),this._resizeObject.onload=null,this._resizeObject=null)}}};function normalizeComponent$2$3(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier
/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);// Vue.extend constructor export interop.
var hook,options="function"===typeof script?script.options:script;// render functions
if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,// functional template
isFunctionalTemplate&&(options.functional=!0)),// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),// inject component styles
style&&style.call(this,createInjectorSSR(context)),// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(context){style.call(this,createInjectorShadow(context,this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
var originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
var existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}
/* script */var __vue_script__$4$3=script$4$3,__vue_render__$4$3=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"resize-observer",attrs:{tabindex:"-1"}})},__vue_staticRenderFns__$4$3=[];
/* template */__vue_render__$4$3._withStripped=!0;
/* style */
var __vue_inject_styles__$4$3=void 0,__vue_scope_id__$4$3="data-v-8859cc6c",__vue_module_identifier__$4$3=void 0,__vue_is_functional_template__$4$3=!1,__vue_component__$3$3=normalizeComponent$2$3({render:__vue_render__$4$3,staticRenderFns:__vue_staticRenderFns__$4$3},__vue_inject_styles__$4$3,__vue_script__$4$3,__vue_scope_id__$4$3,__vue_is_functional_template__$4$3,__vue_module_identifier__$4$3,!1,void 0,void 0,void 0);
/* scoped */function install$1$3(Vue){
// eslint-disable-next-line vue/component-definition-name-casing
Vue.component("resize-observer",__vue_component__$3$3),Vue.component("ResizeObserver",__vue_component__$3$3)}var plugin$2$3={
// eslint-disable-next-line no-undef
version:"1.0.1",install:install$1$3},GlobalVue$1$3=null;"undefined"!==typeof window?GlobalVue$1$3=window.Vue:"undefined"!==typeof global&&(GlobalVue$1$3=global.Vue),GlobalVue$1$3&&GlobalVue$1$3.use(plugin$2$3);var SVGAnimatedString$3=function(){};function convertToArray$3(value){return"string"===typeof value&&(value=value.split(" ")),value}
/**
 * Add classes to an element.
 * This method checks to ensure that the classes don't already exist before adding them.
 * It uses el.className rather than classList in order to be IE friendly.
 * @param {object} el - The element to add the classes to.
 * @param {classes} string - List of space separated classes to be added to the element.
 */function addClasses$3(el,classes){var classList,newClasses=convertToArray$3(classes);classList=el.className instanceof SVGAnimatedString$3?convertToArray$3(el.className.baseVal):convertToArray$3(el.className),newClasses.forEach((function(newClass){-1===classList.indexOf(newClass)&&classList.push(newClass)})),el instanceof SVGElement?el.setAttribute("class",classList.join(" ")):el.className=classList.join(" ")}
/**
 * Remove classes from an element.
 * It uses el.className rather than classList in order to be IE friendly.
 * @export
 * @param {any} el The element to remove the classes from.
 * @param {any} classes List of space separated classes to be removed from the element.
 */function removeClasses$3(el,classes){var classList,newClasses=convertToArray$3(classes);classList=el.className instanceof SVGAnimatedString$3?convertToArray$3(el.className.baseVal):convertToArray$3(el.className),newClasses.forEach((function(newClass){var index=classList.indexOf(newClass);-1!==index&&classList.splice(index,1)})),el instanceof SVGElement?el.setAttribute("class",classList.join(" ")):el.className=classList.join(" ")}"undefined"!==typeof window&&(SVGAnimatedString$3=window.SVGAnimatedString);var supportsPassive$3=!1;if("undefined"!==typeof window){supportsPassive$3=!1;try{var opts$3=Object.defineProperty({},"passive",{get:function(){supportsPassive$3=!0}});window.addEventListener("test",null,opts$3)}catch(e){}}function ownKeys$2$3(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread$2$3(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$2$3(Object(source),!0).forEach((function(key){_defineProperty$1$3(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$2$3(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}var DEFAULT_OPTIONS$3={container:!1,delay:0,html:!1,placement:"top",title:"",template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",offset:0},openTooltips$3=[],Tooltip$3=function(){
/**
   * Create a new Tooltip.js instance
   * @class Tooltip
   * @param {HTMLElement} reference - The DOM node used as reference of the tooltip (it can be a jQuery element).
   * @param {Object} options
   * @param {String} options.placement=bottom
   *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -end),
   *      left(-start, -end)`
   * @param {HTMLElement|String|false} options.container=false - Append the tooltip to a specific element.
   * @param {Number|Object} options.delay=0
   *      Delay showing and hiding the tooltip (ms) - does not apply to manual trigger type.
   *      If a number is supplied, delay is applied to both hide/show.
   *      Object structure is: `{ show: 500, hide: 100 }`
   * @param {Boolean} options.html=false - Insert HTML into the tooltip. If false, the content will inserted with `innerText`.
   * @param {String|PlacementFunction} options.placement='top' - One of the allowed placements, or a function returning one of them.
   * @param {String} [options.template='<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>']
   *      Base HTML to used when creating the tooltip.
   *      The tooltip's `title` will be injected into the `.tooltip-inner` or `.tooltip__inner`.
   *      `.tooltip-arrow` or `.tooltip__arrow` will become the tooltip's arrow.
   *      The outermost wrapper element should have the `.tooltip` class.
   * @param {String|HTMLElement|TitleFunction} options.title='' - Default title value if `title` attribute isn't present.
   * @param {String} [options.trigger='hover focus']
   *      How tooltip is triggered - click, hover, focus, manual.
   *      You may pass multiple triggers; separate them with a space. `manual` cannot be combined with any other trigger.
   * @param {HTMLElement} options.boundariesElement
   *      The element used as boundaries for the tooltip. For more information refer to Popper.js'
   *      [boundariesElement docs](https://popper.js.org/popper-documentation.html)
   * @param {Number|String} options.offset=0 - Offset of the tooltip relative to its reference. For more information refer to Popper.js'
   *      [offset docs](https://popper.js.org/popper-documentation.html)
   * @param {Object} options.popperOptions={} - Popper options, will be passed directly to popper instance. For more information refer to Popper.js'
   *      [options docs](https://popper.js.org/popper-documentation.html)
   * @param {string} [options.ariaId] Id used for accessibility
   * @return {Object} instance - The generated tooltip instance
   */
function Tooltip(_reference,_options){var _this=this;_classCallCheck$3(this,Tooltip),_defineProperty$1$3(this,"_events",[]),_defineProperty$1$3(this,"_setTooltipNodeEvent",(function(evt,reference,delay,options){var relatedreference=evt.relatedreference||evt.toElement||evt.relatedTarget,callback=function callback(evt2){var relatedreference2=evt2.relatedreference||evt2.toElement||evt2.relatedTarget;// Remove event listener after call
_this._tooltipNode.removeEventListener(evt.type,callback),// If the new reference is not the reference element
reference.contains(relatedreference2)||
// Schedule to hide tooltip
_this._scheduleHide(reference,options.delay,options,evt2)};return!!_this._tooltipNode.contains(relatedreference)&&(
// listen to mouseleave on the tooltip element to be able to hide the tooltip
_this._tooltipNode.addEventListener(evt.type,callback),!0)})),
// apply user options over default ones
_options=_objectSpread$2$3(_objectSpread$2$3({},DEFAULT_OPTIONS$3),_options),_reference.jquery&&(_reference=_reference[0]),this.show=this.show.bind(this),this.hide=this.hide.bind(this),// cache reference and options
this.reference=_reference,this.options=_options,// set initial state
this._isOpen=!1,this._init()}
// Public methods

/**
   * Reveals an element's tooltip. This is considered a "manual" triggering of the tooltip.
   * Tooltips with zero-length titles are never displayed.
   * @method Tooltip#show
   * @memberof Tooltip
   */return _createClass$3(Tooltip,[{key:"show",value:function(){this._show(this.reference,this.options)}
/**
     * Hides an element’s tooltip. This is considered a “manual” triggering of the tooltip.
     * @method Tooltip#hide
     * @memberof Tooltip
     */},{key:"hide",value:function(){this._hide()}
/**
     * Hides and destroys an element’s tooltip.
     * @method Tooltip#dispose
     * @memberof Tooltip
     */},{key:"dispose",value:function(){this._dispose()}
/**
     * Toggles an element’s tooltip. This is considered a “manual” triggering of the tooltip.
     * @method Tooltip#toggle
     * @memberof Tooltip
     */},{key:"toggle",value:function(){return this._isOpen?this.hide():this.show()}},{key:"setClasses",value:function(classes){this._classes=classes}},{key:"setContent",value:function(content){this.options.title=content,this._tooltipNode&&this._setContent(content,this.options)}},{key:"setOptions",value:function(options){var classesUpdated=!1,classes=options&&options.classes||directive$3.options.defaultClass;lodash_isEqual(this._classes,classes)||(this.setClasses(classes),classesUpdated=!0),options=getOptions$3(options);var needPopperUpdate=!1,needRestart=!1;for(var key in this.options.offset===options.offset&&this.options.placement===options.placement||(needPopperUpdate=!0),(this.options.template!==options.template||this.options.trigger!==options.trigger||this.options.container!==options.container||classesUpdated)&&(needRestart=!0),options)this.options[key]=options[key];if(this._tooltipNode)if(needRestart){var isOpen=this._isOpen;this.dispose(),this._init(),isOpen&&this.show()}else needPopperUpdate&&this.popperInstance.update()}
// Private methods

},{key:"_init",value:function(){
// get events list
var events="string"===typeof this.options.trigger?this.options.trigger.split(" "):[];this._isDisposed=!1,this._enableDocumentTouch=-1===events.indexOf("manual"),events=events.filter((function(trigger){return-1!==["click","hover","focus"].indexOf(trigger)})),// set event listeners
this._setEventListeners(this.reference,events,this.options),// title attribute
this.$_originalTitle=this.reference.getAttribute("title"),this.reference.removeAttribute("title"),this.reference.setAttribute("data-original-title",this.$_originalTitle)}
/**
     * Creates a new tooltip node
     * @memberof Tooltip
     * @private
     * @param {HTMLElement} reference
     * @param {String} template
     * @param {String|HTMLElement|TitleFunction} title
     * @param {Boolean} allowHtml
     * @return {HTMLelement} tooltipNode
     */},{key:"_create",value:function(reference,template){var _this2=this,tooltipGenerator=window.document.createElement("div");
// create tooltip element
tooltipGenerator.innerHTML=template.trim();var tooltipNode=tooltipGenerator.childNodes[0];// add unique ID to our tooltip (needed for accessibility reasons)
// return the generated tooltip node
return tooltipNode.id=this.options.ariaId||"tooltip_".concat(Math.random().toString(36).substr(2,10)),// Initially hide the tooltip
// The attribute will be switched in a next frame so
// CSS transitions can play
tooltipNode.setAttribute("aria-hidden","true"),this.options.autoHide&&-1!==this.options.trigger.indexOf("hover")&&(tooltipNode.addEventListener("mouseenter",(function(evt){return _this2._scheduleHide(reference,_this2.options.delay,_this2.options,evt)})),tooltipNode.addEventListener("click",(function(evt){return _this2._scheduleHide(reference,_this2.options.delay,_this2.options,evt)}))),tooltipNode}},{key:"_setContent",value:function(content,options){var _this3=this;this.asyncContent=!1,this._applyContent(content,options).then((function(){_this3.popperInstance&&_this3.popperInstance.update()}))}},{key:"_applyContent",value:function(title,options){var _this4=this;return new Promise((function(resolve,reject){var allowHtml=options.html,rootNode=_this4._tooltipNode;if(rootNode){var titleNode=rootNode.querySelector(_this4.options.innerSelector);if(1===title.nodeType){
// if title is a node, append it only if allowHtml is true
if(allowHtml){while(titleNode.firstChild)titleNode.removeChild(titleNode.firstChild);titleNode.appendChild(title)}}else{if("function"===typeof title){
// if title is a function, call it and set innerText or innerHtml depending by `allowHtml` value
var result=title();return void(result&&"function"===typeof result.then?(_this4.asyncContent=!0,options.loadingClass&&addClasses$3(rootNode,options.loadingClass),options.loadingContent&&_this4._applyContent(options.loadingContent,options),result.then((function(asyncResult){return options.loadingClass&&removeClasses$3(rootNode,options.loadingClass),_this4._applyContent(asyncResult,options)})).then(resolve).catch(reject)):_this4._applyContent(result,options).then(resolve).catch(reject))}
// if it's just a simple text, set innerText or innerHtml depending by `allowHtml` value
allowHtml?titleNode.innerHTML=title:titleNode.innerText=title}resolve()}}))}},{key:"_show",value:function(reference,options){if(options&&"string"===typeof options.container){var container=document.querySelector(options.container);if(!container)return}clearTimeout(this._disposeTimer),options=Object.assign({},options),delete options.offset;var updateClasses=!0;this._tooltipNode&&(addClasses$3(this._tooltipNode,this._classes),updateClasses=!1);var result=this._ensureShown(reference,options);return updateClasses&&this._tooltipNode&&addClasses$3(this._tooltipNode,this._classes),addClasses$3(reference,["v-tooltip-open"]),result}},{key:"_ensureShown",value:function(reference,options){var _this5=this;
// don't show if it's already visible
if(this._isOpen)return this;// if the tooltipNode already exists, just show it
if(this._isOpen=!0,openTooltips$3.push(this),this._tooltipNode)return this._tooltipNode.style.display="",this._tooltipNode.setAttribute("aria-hidden","false"),this.popperInstance.enableEventListeners(),this.popperInstance.update(),this.asyncContent&&this._setContent(options.title,options),this;// get title
var title=reference.getAttribute("title")||options.title;// don't show tooltip if no title is defined
if(!title)return this;// create tooltip node
var tooltipNode=this._create(reference,options.template);this._tooltipNode=tooltipNode,// Add `aria-describedby` to our reference element for accessibility reasons
reference.setAttribute("aria-describedby",tooltipNode.id);// append tooltip to container
var container=this._findContainer(options.container,reference);this._append(tooltipNode,container);var popperOptions=_objectSpread$2$3(_objectSpread$2$3({},options.popperOptions),{},{placement:options.placement});return popperOptions.modifiers=_objectSpread$2$3(_objectSpread$2$3({},popperOptions.modifiers),{},{arrow:{element:this.options.arrowSelector}}),options.boundariesElement&&(popperOptions.modifiers.preventOverflow={boundariesElement:options.boundariesElement}),this.popperInstance=new Popper$2$3(reference,tooltipNode,popperOptions),this._setContent(title,options),// Fix position
requestAnimationFrame((function(){!_this5._isDisposed&&_this5.popperInstance?(_this5.popperInstance.update(),// Show the tooltip
requestAnimationFrame((function(){_this5._isDisposed?_this5.dispose():_this5._isOpen&&tooltipNode.setAttribute("aria-hidden","false")}))):_this5.dispose()})),this}},{key:"_noLongerOpen",value:function(){var index=openTooltips$3.indexOf(this);-1!==index&&openTooltips$3.splice(index,1)}},{key:"_hide",value:function(){var _this6=this;
// don't hide if it's already hidden
if(!this._isOpen)return this;this._isOpen=!1,this._noLongerOpen(),// hide tooltipNode
this._tooltipNode.style.display="none",this._tooltipNode.setAttribute("aria-hidden","true"),this.popperInstance&&this.popperInstance.disableEventListeners(),clearTimeout(this._disposeTimer);var disposeTime=directive$3.options.disposeTimeout;return null!==disposeTime&&(this._disposeTimer=setTimeout((function(){_this6._tooltipNode&&(_this6._tooltipNode.removeEventListener("mouseenter",_this6.hide),_this6._tooltipNode.removeEventListener("click",_this6.hide),// Don't remove popper instance, just the HTML element
_this6._removeTooltipNode())}),disposeTime)),removeClasses$3(this.reference,["v-tooltip-open"]),this}},{key:"_removeTooltipNode",value:function(){if(this._tooltipNode){var parentNode=this._tooltipNode.parentNode;parentNode&&(parentNode.removeChild(this._tooltipNode),this.reference.removeAttribute("aria-describedby")),this._tooltipNode=null}}},{key:"_dispose",value:function(){var _this7=this;return this._isDisposed=!0,this.reference.removeAttribute("data-original-title"),this.$_originalTitle&&this.reference.setAttribute("title",this.$_originalTitle),// remove event listeners first to prevent any unexpected behaviour
this._events.forEach((function(_ref){var func=_ref.func,event=_ref.event;_this7.reference.removeEventListener(event,func)})),this._events=[],this._tooltipNode?(this._hide(),this._tooltipNode.removeEventListener("mouseenter",this.hide),this._tooltipNode.removeEventListener("click",this.hide),// destroy instance
this.popperInstance.destroy(),// destroy tooltipNode if removeOnDestroy is not set, as popperInstance.destroy() already removes the element
this.popperInstance.options.removeOnDestroy||this._removeTooltipNode()):this._noLongerOpen(),this}},{key:"_findContainer",value:function(container,reference){
// if container is a query, get the relative element
return"string"===typeof container?container=window.document.querySelector(container):!1===container&&(
// if container is `false`, set it to reference parent
container=reference.parentNode),container}
/**
     * Append tooltip to container
     * @memberof Tooltip
     * @private
     * @param {HTMLElement} tooltip
     * @param {HTMLElement|String|false} container
     */},{key:"_append",value:function(tooltipNode,container){container.appendChild(tooltipNode)}},{key:"_setEventListeners",value:function(reference,events,options){var _this8=this,directEvents=[],oppositeEvents=[];events.forEach((function(event){switch(event){case"hover":directEvents.push("mouseenter"),oppositeEvents.push("mouseleave"),_this8.options.hideOnTargetClick&&oppositeEvents.push("click");break;case"focus":directEvents.push("focus"),oppositeEvents.push("blur"),_this8.options.hideOnTargetClick&&oppositeEvents.push("click");break;case"click":directEvents.push("click"),oppositeEvents.push("click");break}})),// schedule show tooltip
directEvents.forEach((function(event){var func=function(evt){!0!==_this8._isOpen&&(evt.usedByTooltip=!0,_this8._scheduleShow(reference,options.delay,options,evt))};_this8._events.push({event:event,func:func}),reference.addEventListener(event,func)})),// schedule hide tooltip
oppositeEvents.forEach((function(event){var func=function(evt){!0!==evt.usedByTooltip&&_this8._scheduleHide(reference,options.delay,options,evt)};_this8._events.push({event:event,func:func}),reference.addEventListener(event,func)}))}},{key:"_onDocumentTouch",value:function(event){this._enableDocumentTouch&&this._scheduleHide(this.reference,this.options.delay,this.options,event)}},{key:"_scheduleShow",value:function(reference,delay,options
/*, evt */){var _this9=this,computedDelay=delay&&delay.show||delay||0;
// defaults to 0
clearTimeout(this._scheduleTimer),this._scheduleTimer=window.setTimeout((function(){return _this9._show(reference,options)}),computedDelay)}},{key:"_scheduleHide",value:function(reference,delay,options,evt){var _this10=this,computedDelay=delay&&delay.hide||delay||0;
// defaults to 0
clearTimeout(this._scheduleTimer),this._scheduleTimer=window.setTimeout((function(){if(!1!==_this10._isOpen&&_this10._tooltipNode.ownerDocument.body.contains(_this10._tooltipNode)){// if we are hiding because of a mouseleave, we must check that the new
// reference isn't the tooltip, because in this case we don't want to hide it
if("mouseleave"===evt.type){var isSet=_this10._setTooltipNodeEvent(evt,reference,delay,options);// if we set the new event, don't hide the tooltip yet
// the new event will take care to hide it if necessary
if(isSet)return}_this10._hide(reference,options)}}),computedDelay)}}]),Tooltip}();
/**
 * Placement function, its context is the Tooltip instance.
 * @memberof Tooltip
 * @callback PlacementFunction
 * @param {HTMLElement} tooltip - tooltip DOM node.
 * @param {HTMLElement} reference - reference DOM node.
 * @return {String} placement - One of the allowed placement options.
 */
/**
 * Title function, its context is the Tooltip instance.
 * @memberof Tooltip
 * @callback TitleFunction
 * @return {String} placement - The desired title.
 */
function ownKeys$1$3(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread$1$3(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$1$3(Object(source),!0).forEach((function(key){_defineProperty$1$3(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$1$3(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}// Hide tooltips on touch devices
"undefined"!==typeof document&&document.addEventListener("touchstart",(function(event){for(var i=0;i<openTooltips$3.length;i++)openTooltips$3[i]._onDocumentTouch(event)}),!supportsPassive$3||{passive:!0,capture:!0});var state$3={enabled:!0},positions$3=["top","top-start","top-end","right","right-start","right-end","bottom","bottom-start","bottom-end","left","left-start","left-end"],defaultOptions$3={
// Default tooltip placement relative to target element
defaultPlacement:"top",
// Default CSS classes applied to the tooltip element
defaultClass:"vue-tooltip-theme",
// Default CSS classes applied to the target element of the tooltip
defaultTargetClass:"has-tooltip",
// Is the content HTML by default?
defaultHtml:!0,
// Default HTML template of the tooltip element
// It must include `tooltip-arrow` & `tooltip-inner` CSS classes (can be configured, see below)
// Change if the classes conflict with other libraries (for example bootstrap)
defaultTemplate:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
// Selector used to get the arrow element in the tooltip template
defaultArrowSelector:".tooltip-arrow, .tooltip__arrow",
// Selector used to get the inner content element in the tooltip template
defaultInnerSelector:".tooltip-inner, .tooltip__inner",
// Delay (ms)
defaultDelay:0,
// Default events that trigger the tooltip
defaultTrigger:"hover focus",
// Default position offset (px)
defaultOffset:0,
// Default container where the tooltip will be appended
defaultContainer:"body",defaultBoundariesElement:void 0,defaultPopperOptions:{},
// Class added when content is loading
defaultLoadingClass:"tooltip-loading",
// Displayed when tooltip content is loading
defaultLoadingContent:"...",
// Hide on mouseover tooltip
autoHide:!0,
// Close tooltip on click on tooltip target?
defaultHideOnTargetClick:!0,
// Auto destroy tooltip DOM nodes (ms)
disposeTimeout:5e3,
// Options for popover
popover:{defaultPlacement:"bottom",
// Use the `popoverClass` prop for theming
defaultClass:"vue-popover-theme",
// Base class (change if conflicts with other libraries)
defaultBaseClass:"tooltip popover",
// Wrapper class (contains arrow and inner)
defaultWrapperClass:"wrapper",
// Inner content class
defaultInnerClass:"tooltip-inner popover-inner",
// Arrow class
defaultArrowClass:"tooltip-arrow popover-arrow",
// Class added when popover is open
defaultOpenClass:"open",defaultDelay:0,defaultTrigger:"click",defaultOffset:0,defaultContainer:"body",defaultBoundariesElement:void 0,defaultPopperOptions:{},
// Hides if clicked outside of popover
defaultAutoHide:!0,
// Update popper on content resize
defaultHandleResize:!0}};function getOptions$3(options){var result={placement:"undefined"!==typeof options.placement?options.placement:directive$3.options.defaultPlacement,delay:"undefined"!==typeof options.delay?options.delay:directive$3.options.defaultDelay,html:"undefined"!==typeof options.html?options.html:directive$3.options.defaultHtml,template:"undefined"!==typeof options.template?options.template:directive$3.options.defaultTemplate,arrowSelector:"undefined"!==typeof options.arrowSelector?options.arrowSelector:directive$3.options.defaultArrowSelector,innerSelector:"undefined"!==typeof options.innerSelector?options.innerSelector:directive$3.options.defaultInnerSelector,trigger:"undefined"!==typeof options.trigger?options.trigger:directive$3.options.defaultTrigger,offset:"undefined"!==typeof options.offset?options.offset:directive$3.options.defaultOffset,container:"undefined"!==typeof options.container?options.container:directive$3.options.defaultContainer,boundariesElement:"undefined"!==typeof options.boundariesElement?options.boundariesElement:directive$3.options.defaultBoundariesElement,autoHide:"undefined"!==typeof options.autoHide?options.autoHide:directive$3.options.autoHide,hideOnTargetClick:"undefined"!==typeof options.hideOnTargetClick?options.hideOnTargetClick:directive$3.options.defaultHideOnTargetClick,loadingClass:"undefined"!==typeof options.loadingClass?options.loadingClass:directive$3.options.defaultLoadingClass,loadingContent:"undefined"!==typeof options.loadingContent?options.loadingContent:directive$3.options.defaultLoadingContent,popperOptions:_objectSpread$1$3({},"undefined"!==typeof options.popperOptions?options.popperOptions:directive$3.options.defaultPopperOptions)};if(result.offset){var typeofOffset=_typeof$7(result.offset),offset=result.offset;// One value -> switch
("number"===typeofOffset||"string"===typeofOffset&&-1===offset.indexOf(","))&&(offset="0, ".concat(offset)),result.popperOptions.modifiers||(result.popperOptions.modifiers={}),result.popperOptions.modifiers.offset={offset:offset}}return result.trigger&&-1!==result.trigger.indexOf("click")&&(result.hideOnTargetClick=!1),result}function getPlacement$3(value,modifiers){for(var placement=value.placement,i=0;i<positions$3.length;i++){var pos=positions$3[i];modifiers[pos]&&(placement=pos)}return placement}function getContent$3(value){var type=_typeof$7(value);return"string"===type?value:!(!value||"object"!==type)&&value.content}function createTooltip$3(el,value){var modifiers=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},content=getContent$3(value),classes="undefined"!==typeof value.classes?value.classes:directive$3.options.defaultClass,opts=_objectSpread$1$3({title:content},getOptions$3(_objectSpread$1$3(_objectSpread$1$3({},"object"===_typeof$7(value)?value:{}),{},{placement:getPlacement$3(value,modifiers)}))),tooltip=el._tooltip=new Tooltip$3(el,opts);tooltip.setClasses(classes),tooltip._vueEl=el;// Class on target
var targetClasses="undefined"!==typeof value.targetClasses?value.targetClasses:directive$3.options.defaultTargetClass;return el._tooltipTargetClasses=targetClasses,addClasses$3(el,targetClasses),tooltip}function destroyTooltip$3(el){el._tooltip&&(el._tooltip.dispose(),delete el._tooltip,delete el._tooltipOldShow),el._tooltipTargetClasses&&(removeClasses$3(el,el._tooltipTargetClasses),delete el._tooltipTargetClasses)}function bind$4(el,_ref){var value=_ref.value;_ref.oldValue;var tooltip,modifiers=_ref.modifiers,content=getContent$3(value);content&&state$3.enabled?(el._tooltip?(tooltip=el._tooltip,// Content
tooltip.setContent(content),// Options
tooltip.setOptions(_objectSpread$1$3(_objectSpread$1$3({},value),{},{placement:getPlacement$3(value,modifiers)}))):tooltip=createTooltip$3(el,value,modifiers),// Manual show
"undefined"!==typeof value.show&&value.show!==el._tooltipOldShow&&(el._tooltipOldShow=value.show,value.show?tooltip.show():tooltip.hide())):destroyTooltip$3(el)}var directive$3={options:defaultOptions$3,bind:bind$4,update:bind$4,unbind:function(el){destroyTooltip$3(el)}};function addListeners$3(el){el.addEventListener("click",onClick$3),el.addEventListener("touchstart",onTouchStart$3,!!supportsPassive$3&&{passive:!0})}function removeListeners$3(el){el.removeEventListener("click",onClick$3),el.removeEventListener("touchstart",onTouchStart$3),el.removeEventListener("touchend",onTouchEnd$3),el.removeEventListener("touchcancel",onTouchCancel$3)}function onClick$3(event){var el=event.currentTarget;event.closePopover=!el.$_vclosepopover_touch,event.closeAllPopover=el.$_closePopoverModifiers&&!!el.$_closePopoverModifiers.all}function onTouchStart$3(event){if(1===event.changedTouches.length){var el=event.currentTarget;el.$_vclosepopover_touch=!0;var touch=event.changedTouches[0];el.$_vclosepopover_touchPoint=touch,el.addEventListener("touchend",onTouchEnd$3),el.addEventListener("touchcancel",onTouchCancel$3)}}function onTouchEnd$3(event){var el=event.currentTarget;if(el.$_vclosepopover_touch=!1,1===event.changedTouches.length){var touch=event.changedTouches[0],firstTouch=el.$_vclosepopover_touchPoint;event.closePopover=Math.abs(touch.screenY-firstTouch.screenY)<20&&Math.abs(touch.screenX-firstTouch.screenX)<20,event.closeAllPopover=el.$_closePopoverModifiers&&!!el.$_closePopoverModifiers.all}}function onTouchCancel$3(event){var el=event.currentTarget;el.$_vclosepopover_touch=!1}var vclosepopover$3={bind:function(el,_ref){var value=_ref.value,modifiers=_ref.modifiers;el.$_closePopoverModifiers=modifiers,("undefined"===typeof value||value)&&addListeners$3(el)},update:function(el,_ref2){var value=_ref2.value,oldValue=_ref2.oldValue,modifiers=_ref2.modifiers;el.$_closePopoverModifiers=modifiers,value!==oldValue&&("undefined"===typeof value||value?addListeners$3(el):removeListeners$3(el))},unbind:function(el){removeListeners$3(el)}};function ownKeys$3$3(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread$5(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$3$3(Object(source),!0).forEach((function(key){_defineProperty$1$3(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$3$3(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}function getDefault$3(key){var value=directive$3.options.popover[key];return"undefined"===typeof value?directive$3.options[key]:value}var isIOS$1$3=!1;"undefined"!==typeof window&&"undefined"!==typeof navigator&&(isIOS$1$3=/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream);var openPopovers$3=[],Element$1$3=function(){};"undefined"!==typeof window&&(Element$1$3=window.Element);var script$3$3={name:"VPopover",components:{ResizeObserver:__vue_component__$3$3},props:{open:{type:Boolean,default:!1},disabled:{type:Boolean,default:!1},placement:{type:String,default:function(){return getDefault$3("defaultPlacement")}},delay:{type:[String,Number,Object],default:function(){return getDefault$3("defaultDelay")}},offset:{type:[String,Number],default:function(){return getDefault$3("defaultOffset")}},trigger:{type:String,default:function(){return getDefault$3("defaultTrigger")}},container:{type:[String,Object,Element$1$3,Boolean],default:function(){return getDefault$3("defaultContainer")}},boundariesElement:{type:[String,Element$1$3],default:function(){return getDefault$3("defaultBoundariesElement")}},popperOptions:{type:Object,default:function(){return getDefault$3("defaultPopperOptions")}},popoverClass:{type:[String,Array],default:function(){return getDefault$3("defaultClass")}},popoverBaseClass:{type:[String,Array],default:function(){return directive$3.options.popover.defaultBaseClass}},popoverInnerClass:{type:[String,Array],default:function(){return directive$3.options.popover.defaultInnerClass}},popoverWrapperClass:{type:[String,Array],default:function(){return directive$3.options.popover.defaultWrapperClass}},popoverArrowClass:{type:[String,Array],default:function(){return directive$3.options.popover.defaultArrowClass}},autoHide:{type:Boolean,default:function(){return directive$3.options.popover.defaultAutoHide}},handleResize:{type:Boolean,default:function(){return directive$3.options.popover.defaultHandleResize}},openGroup:{type:String,default:null},openClass:{type:[String,Array],default:function(){return directive$3.options.popover.defaultOpenClass}},ariaId:{default:null}},data:function(){return{isOpen:!1,id:Math.random().toString(36).substr(2,10)}},computed:{cssClass:function(){return _defineProperty$1$3({},this.openClass,this.isOpen)},popoverId:function(){return"popover_".concat(null!=this.ariaId?this.ariaId:this.id)}},watch:{open:function(val){val?this.show():this.hide()},disabled:function(val,oldVal){val!==oldVal&&(val?this.hide():this.open&&this.show())},container:function(val){if(this.isOpen&&this.popperInstance){var popoverNode=this.$refs.popover,reference=this.$refs.trigger,container=this.$_findContainer(this.container,reference);if(!container)return;container.appendChild(popoverNode),this.popperInstance.scheduleUpdate()}},trigger:function(val){this.$_removeEventListeners(),this.$_addEventListeners()},placement:function(val){var _this=this;this.$_updatePopper((function(){_this.popperInstance.options.placement=val}))},offset:"$_restartPopper",boundariesElement:"$_restartPopper",popperOptions:{handler:"$_restartPopper",deep:!0}},created:function(){this.$_isDisposed=!1,this.$_mounted=!1,this.$_events=[],this.$_preventOpen=!1},mounted:function(){var popoverNode=this.$refs.popover;popoverNode.parentNode&&popoverNode.parentNode.removeChild(popoverNode),this.$_init(),this.open&&this.show()},deactivated:function(){this.hide()},beforeDestroy:function(){this.dispose()},methods:{show:function(){var _this2=this,_ref2=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},event=_ref2.event;_ref2.skipDelay;var _ref2$force=_ref2.force,force=void 0!==_ref2$force&&_ref2$force;!force&&this.disabled||(this.$_scheduleShow(event),this.$emit("show")),this.$emit("update:open",!0),this.$_beingShowed=!0,requestAnimationFrame((function(){_this2.$_beingShowed=!1}))},hide:function(){var _ref3=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},event=_ref3.event;_ref3.skipDelay,this.$_scheduleHide(event),this.$emit("hide"),this.$emit("update:open",!1)},dispose:function(){if(this.$_isDisposed=!0,this.$_removeEventListeners(),this.hide({skipDelay:!0}),this.popperInstance&&(this.popperInstance.destroy(),!this.popperInstance.options.removeOnDestroy)){var popoverNode=this.$refs.popover;popoverNode.parentNode&&popoverNode.parentNode.removeChild(popoverNode)}this.$_mounted=!1,this.popperInstance=null,this.isOpen=!1,this.$emit("dispose")},$_init:function(){-1===this.trigger.indexOf("manual")&&this.$_addEventListeners()},$_show:function(){var _this3=this,reference=this.$refs.trigger,popoverNode=this.$refs.popover;// Already open
if(clearTimeout(this.$_disposeTimer),!this.isOpen){if(// Popper is already initialized
this.popperInstance&&(this.isOpen=!0,this.popperInstance.enableEventListeners(),this.popperInstance.scheduleUpdate()),!this.$_mounted){var container=this.$_findContainer(this.container,reference);if(!container)return;container.appendChild(popoverNode),this.$_mounted=!0,this.isOpen=!1,this.popperInstance&&requestAnimationFrame((function(){_this3.hidden||(_this3.isOpen=!0)}))}if(!this.popperInstance){var popperOptions=_objectSpread$5(_objectSpread$5({},this.popperOptions),{},{placement:this.placement});if(popperOptions.modifiers=_objectSpread$5(_objectSpread$5({},popperOptions.modifiers),{},{arrow:_objectSpread$5(_objectSpread$5({},popperOptions.modifiers&&popperOptions.modifiers.arrow),{},{element:this.$refs.arrow})}),this.offset){var offset=this.$_getOffset();popperOptions.modifiers.offset=_objectSpread$5(_objectSpread$5({},popperOptions.modifiers&&popperOptions.modifiers.offset),{},{offset:offset})}this.boundariesElement&&(popperOptions.modifiers.preventOverflow=_objectSpread$5(_objectSpread$5({},popperOptions.modifiers&&popperOptions.modifiers.preventOverflow),{},{boundariesElement:this.boundariesElement})),this.popperInstance=new Popper$2$3(reference,popoverNode,popperOptions),// Fix position
requestAnimationFrame((function(){if(_this3.hidden)return _this3.hidden=!1,void _this3.$_hide();!_this3.$_isDisposed&&_this3.popperInstance?(_this3.popperInstance.scheduleUpdate(),// Show the tooltip
requestAnimationFrame((function(){if(_this3.hidden)return _this3.hidden=!1,void _this3.$_hide();_this3.$_isDisposed?_this3.dispose():_this3.isOpen=!0}))):_this3.dispose()}))}var openGroup=this.openGroup;if(openGroup)for(var popover,i=0;i<openPopovers$3.length;i++)popover=openPopovers$3[i],popover.openGroup!==openGroup&&(popover.hide(),popover.$emit("close-group"));openPopovers$3.push(this),this.$emit("apply-show")}},$_hide:function(){var _this4=this;
// Already hidden
if(this.isOpen){var index=openPopovers$3.indexOf(this);-1!==index&&openPopovers$3.splice(index,1),this.isOpen=!1,this.popperInstance&&this.popperInstance.disableEventListeners(),clearTimeout(this.$_disposeTimer);var disposeTime=directive$3.options.popover.disposeTimeout||directive$3.options.disposeTimeout;null!==disposeTime&&(this.$_disposeTimer=setTimeout((function(){var popoverNode=_this4.$refs.popover;popoverNode&&(
// Don't remove popper instance, just the HTML element
popoverNode.parentNode&&popoverNode.parentNode.removeChild(popoverNode),_this4.$_mounted=!1)}),disposeTime)),this.$emit("apply-hide")}},$_findContainer:function(container,reference){
// if container is a query, get the relative element
return"string"===typeof container?container=window.document.querySelector(container):!1===container&&(
// if container is `false`, set it to reference parent
container=reference.parentNode),container},$_getOffset:function(){var typeofOffset=_typeof$7(this.offset),offset=this.offset;// One value -> switch
return("number"===typeofOffset||"string"===typeofOffset&&-1===offset.indexOf(","))&&(offset="0, ".concat(offset)),offset},$_addEventListeners:function(){var _this5=this,reference=this.$refs.trigger,directEvents=[],oppositeEvents=[],events="string"===typeof this.trigger?this.trigger.split(" ").filter((function(trigger){return-1!==["click","hover","focus"].indexOf(trigger)})):[];events.forEach((function(event){switch(event){case"hover":directEvents.push("mouseenter"),oppositeEvents.push("mouseleave");break;case"focus":directEvents.push("focus"),oppositeEvents.push("blur");break;case"click":directEvents.push("click"),oppositeEvents.push("click");break}})),// schedule show tooltip
directEvents.forEach((function(event){var func=function(event){_this5.isOpen||(event.usedByTooltip=!0,!_this5.$_preventOpen&&_this5.show({event:event}),_this5.hidden=!1)};_this5.$_events.push({event:event,func:func}),reference.addEventListener(event,func)})),// schedule hide tooltip
oppositeEvents.forEach((function(event){var func=function(event){event.usedByTooltip||(_this5.hide({event:event}),_this5.hidden=!0)};_this5.$_events.push({event:event,func:func}),reference.addEventListener(event,func)}))},$_scheduleShow:function(){var skipDelay=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(clearTimeout(this.$_scheduleTimer),skipDelay)this.$_show();else{
// defaults to 0
var computedDelay=parseInt(this.delay&&this.delay.show||this.delay||0);this.$_scheduleTimer=setTimeout(this.$_show.bind(this),computedDelay)}},$_scheduleHide:function(){var _this6=this,event=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,skipDelay=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(clearTimeout(this.$_scheduleTimer),skipDelay)this.$_hide();else{
// defaults to 0
var computedDelay=parseInt(this.delay&&this.delay.hide||this.delay||0);this.$_scheduleTimer=setTimeout((function(){if(_this6.isOpen){// if we are hiding because of a mouseleave, we must check that the new
// reference isn't the tooltip, because in this case we don't want to hide it
if(event&&"mouseleave"===event.type){var isSet=_this6.$_setTooltipNodeEvent(event);// if we set the new event, don't hide the tooltip yet
// the new event will take care to hide it if necessary
if(isSet)return}_this6.$_hide()}}),computedDelay)}},$_setTooltipNodeEvent:function(event){var _this7=this,reference=this.$refs.trigger,popoverNode=this.$refs.popover,relatedreference=event.relatedreference||event.toElement||event.relatedTarget,callback=function callback(event2){var relatedreference2=event2.relatedreference||event2.toElement||event2.relatedTarget;// Remove event listener after call
popoverNode.removeEventListener(event.type,callback),// If the new reference is not the reference element
reference.contains(relatedreference2)||
// Schedule to hide tooltip
_this7.hide({event:event2})};return!!popoverNode.contains(relatedreference)&&(
// listen to mouseleave on the tooltip element to be able to hide the tooltip
popoverNode.addEventListener(event.type,callback),!0)},$_removeEventListeners:function(){var reference=this.$refs.trigger;this.$_events.forEach((function(_ref4){var func=_ref4.func,event=_ref4.event;reference.removeEventListener(event,func)})),this.$_events=[]},$_updatePopper:function(cb){this.popperInstance&&(cb(),this.isOpen&&this.popperInstance.scheduleUpdate())},$_restartPopper:function(){if(this.popperInstance){var isOpen=this.isOpen;this.dispose(),this.$_isDisposed=!1,this.$_init(),isOpen&&this.show({skipDelay:!0,force:!0})}},$_handleGlobalClose:function(event){var _this8=this,touch=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.$_beingShowed||(this.hide({event:event}),event.closePopover?this.$emit("close-directive"):this.$emit("auto-hide"),touch&&(this.$_preventOpen=!0,setTimeout((function(){_this8.$_preventOpen=!1}),300)))},$_handleResize:function(){this.isOpen&&this.popperInstance&&(this.popperInstance.scheduleUpdate(),this.$emit("resize"))}}};function handleGlobalClick$3(event){handleGlobalClose$3(event)}function handleGlobalTouchend$3(event){handleGlobalClose$3(event,!0)}function handleGlobalClose$3(event){
// Delay so that close directive has time to set values
for(var touch=arguments.length>1&&void 0!==arguments[1]&&arguments[1],_loop=function(i){var popover=openPopovers$3[i];if(popover.$refs.popover){var contains=popover.$refs.popover.contains(event.target);requestAnimationFrame((function(){(event.closeAllPopover||event.closePopover&&contains||popover.autoHide&&!contains)&&popover.$_handleGlobalClose(event,touch)}))}},i=0;i<openPopovers$3.length;i++)_loop(i)}function normalizeComponent$1$3(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);
// Vue.extend constructor export interop.
const options="function"===typeof script?script.options:script;
// render functions
let hook;if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,
// functional template
isFunctionalTemplate&&(options.functional=!0)),
// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),
// inject component styles
style&&style.call(this,createInjectorSSR(context)),
// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},
// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(context){style.call(this,createInjectorShadow(context,this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
const originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
const existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}
/* script */"undefined"!==typeof document&&"undefined"!==typeof window&&(isIOS$1$3?document.addEventListener("touchend",handleGlobalTouchend$3,!supportsPassive$3||{passive:!0,capture:!0}):window.addEventListener("click",handleGlobalClick$3,!0));var __vue_script__$3$3=script$3$3,__vue_render__$3$3=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"v-popover",class:_vm.cssClass},[_c("div",{ref:"trigger",staticClass:"trigger",staticStyle:{display:"inline-block"},attrs:{"aria-describedby":_vm.isOpen?_vm.popoverId:void 0,tabindex:-1!==_vm.trigger.indexOf("focus")?0:void 0}},[_vm._t("default")],2),_vm._v(" "),_c("div",{ref:"popover",class:[_vm.popoverBaseClass,_vm.popoverClass,_vm.cssClass],style:{visibility:_vm.isOpen?"visible":"hidden"},attrs:{id:_vm.popoverId,"aria-hidden":_vm.isOpen?"false":"true",tabindex:_vm.autoHide?0:void 0},on:{keyup:function($event){if(!$event.type.indexOf("key")&&_vm._k($event.keyCode,"esc",27,$event.key,["Esc","Escape"]))return null;_vm.autoHide&&_vm.hide()}}},[_c("div",{class:_vm.popoverWrapperClass},[_c("div",{ref:"inner",class:_vm.popoverInnerClass,staticStyle:{position:"relative"}},[_c("div",[_vm._t("popover",null,{isOpen:_vm.isOpen})],2),_vm._v(" "),_vm.handleResize?_c("ResizeObserver",{on:{notify:_vm.$_handleResize}}):_vm._e()],1),_vm._v(" "),_c("div",{ref:"arrow",class:_vm.popoverArrowClass})])])])},__vue_staticRenderFns__$3$3=[];
/* template */__vue_render__$3$3._withStripped=!0;
/* style */
var __vue_inject_styles__$3$3=void 0,__vue_scope_id__$3$3=void 0,__vue_module_identifier__$3$3=void 0,__vue_is_functional_template__$3$3=!1,__vue_component__$2$4=normalizeComponent$1$3({render:__vue_render__$3$3,staticRenderFns:__vue_staticRenderFns__$3$3},__vue_inject_styles__$3$3,__vue_script__$3$3,__vue_scope_id__$3$3,__vue_is_functional_template__$3$3,__vue_module_identifier__$3$3,!1,void 0,void 0,void 0);
/* scoped */function styleInject$6(css,ref){void 0===ref&&(ref={});var insertAt=ref.insertAt;if(css&&"undefined"!==typeof document){var head=document.head||document.getElementsByTagName("head")[0],style=document.createElement("style");style.type="text/css","top"===insertAt&&head.firstChild?head.insertBefore(style,head.firstChild):head.appendChild(style),style.styleSheet?style.styleSheet.cssText=css:style.appendChild(document.createTextNode(css))}}var css_248z$9=".resize-observer[data-v-8859cc6c]{position:absolute;top:0;left:0;z-index:-1;width:100%;height:100%;border:none;background-color:transparent;pointer-events:none;display:block;overflow:hidden;opacity:0}.resize-observer[data-v-8859cc6c] object{display:block;position:absolute;top:0;left:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1}";function install$4(Vue){var options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!install$4.installed){install$4.installed=!0;var finalOptions={};merge(finalOptions,defaultOptions$3,options),plugin$1$3.options=finalOptions,directive$3.options=finalOptions,Vue.directive("tooltip",directive$3),Vue.directive("close-popover",vclosepopover$3),Vue.component("VPopover",__vue_component__$2$4)}}styleInject$6(css_248z$9);var plugin$1$3={install:install$4,get enabled(){return state$3.enabled},set enabled(value){state$3.enabled=value}},GlobalVue$4=null;// Auto-install
"undefined"!==typeof window?GlobalVue$4=window.Vue:"undefined"!==typeof global&&(GlobalVue$4=global.Vue),GlobalVue$4&&GlobalVue$4.use(plugin$1$3)
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */;var isBrowser$5="undefined"!==typeof window&&"undefined"!==typeof document&&"undefined"!==typeof navigator,timeoutDuration$4=function(){for(var longerTimeoutBrowsers=["Edge","Trident","Firefox"],i=0;i<longerTimeoutBrowsers.length;i+=1)if(isBrowser$5&&navigator.userAgent.indexOf(longerTimeoutBrowsers[i])>=0)return 1;return 0}();function microtaskDebounce$4(fn){var called=!1;return function(){called||(called=!0,window.Promise.resolve().then((function(){called=!1,fn()})))}}function taskDebounce$4(fn){var scheduled=!1;return function(){scheduled||(scheduled=!0,setTimeout((function(){scheduled=!1,fn()}),timeoutDuration$4))}}var supportsMicroTasks$4=isBrowser$5&&window.Promise,debounce$5=supportsMicroTasks$4?microtaskDebounce$4:taskDebounce$4;
/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction$7(functionToCheck){var getType={};return functionToCheck&&"[object Function]"===getType.toString.call(functionToCheck)}
/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */function getStyleComputedProperty$4(element,property){if(1!==element.nodeType)return[];
// NOTE: 1 DOM access here
var window=element.ownerDocument.defaultView,css=window.getComputedStyle(element,null);return property?css[property]:css}
/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */function getParentNode$4(element){return"HTML"===element.nodeName?element:element.parentNode||element.host}
/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */function getScrollParent$4(element){
// Return body, `getScroll` will take care to get the correct `scrollTop` from it
if(!element)return document.body;switch(element.nodeName){case"HTML":case"BODY":return element.ownerDocument.body;case"#document":return element.body}
// Firefox want us to check `-x` and `-y` variations as well
var _getStyleComputedProp=getStyleComputedProperty$4(element),overflow=_getStyleComputedProp.overflow,overflowX=_getStyleComputedProp.overflowX,overflowY=_getStyleComputedProp.overflowY;return/(auto|scroll|overlay)/.test(overflow+overflowY+overflowX)?element:getScrollParent$4(getParentNode$4(element))}
/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */function getReferenceNode$4(reference){return reference&&reference.referenceNode?reference.referenceNode:reference}var isIE11$4=isBrowser$5&&!(!window.MSInputMethodContext||!document.documentMode),isIE10$4=isBrowser$5&&/MSIE 10/.test(navigator.userAgent);
/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE$6(version){return 11===version?isIE11$4:10===version?isIE10$4:isIE11$4||isIE10$4}
/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */function getOffsetParent$4(element){if(!element)return document.documentElement;var noOffsetParent=isIE$6(10)?document.body:null,offsetParent=element.offsetParent||null;
// NOTE: 1 DOM access here
// Skip hidden elements which don't have an offsetParent
while(offsetParent===noOffsetParent&&element.nextElementSibling)offsetParent=(element=element.nextElementSibling).offsetParent;var nodeName=offsetParent&&offsetParent.nodeName;return nodeName&&"BODY"!==nodeName&&"HTML"!==nodeName?
// .offsetParent will return the closest TH, TD or TABLE in case
// no offsetParent is present, I hate this job...
-1!==["TH","TD","TABLE"].indexOf(offsetParent.nodeName)&&"static"===getStyleComputedProperty$4(offsetParent,"position")?getOffsetParent$4(offsetParent):offsetParent:element?element.ownerDocument.documentElement:document.documentElement}function isOffsetContainer$4(element){var nodeName=element.nodeName;return"BODY"!==nodeName&&("HTML"===nodeName||getOffsetParent$4(element.firstElementChild)===element)}
/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */function getRoot$4(node){return null!==node.parentNode?getRoot$4(node.parentNode):node}
/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */function findCommonOffsetParent$4(element1,element2){
// This check is needed to avoid errors in case one of the elements isn't defined for any reason
if(!element1||!element1.nodeType||!element2||!element2.nodeType)return document.documentElement;
// Here we make sure to give as "start" the element that comes first in the DOM
var order=element1.compareDocumentPosition(element2)&Node.DOCUMENT_POSITION_FOLLOWING,start=order?element1:element2,end=order?element2:element1,range=document.createRange();range.setStart(start,0),range.setEnd(end,0);var commonAncestorContainer=range.commonAncestorContainer;
// Both nodes are inside #document
if(element1!==commonAncestorContainer&&element2!==commonAncestorContainer||start.contains(end))return isOffsetContainer$4(commonAncestorContainer)?commonAncestorContainer:getOffsetParent$4(commonAncestorContainer);
// one of the nodes is inside shadowDOM, find which one
var element1root=getRoot$4(element1);return element1root.host?findCommonOffsetParent$4(element1root.host,element2):findCommonOffsetParent$4(element1,getRoot$4(element2).host)}
/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */function getScroll$4(element){var side=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"top",upperSide="top"===side?"scrollTop":"scrollLeft",nodeName=element.nodeName;if("BODY"===nodeName||"HTML"===nodeName){var html=element.ownerDocument.documentElement,scrollingElement=element.ownerDocument.scrollingElement||html;return scrollingElement[upperSide]}return element[upperSide]}
/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */function includeScroll$4(rect,element){var subtract=arguments.length>2&&void 0!==arguments[2]&&arguments[2],scrollTop=getScroll$4(element,"top"),scrollLeft=getScroll$4(element,"left"),modifier=subtract?-1:1;return rect.top+=scrollTop*modifier,rect.bottom+=scrollTop*modifier,rect.left+=scrollLeft*modifier,rect.right+=scrollLeft*modifier,rect}
/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */function getBordersSize$4(styles,axis){var sideA="x"===axis?"Left":"Top",sideB="Left"===sideA?"Right":"Bottom";return parseFloat(styles["border"+sideA+"Width"])+parseFloat(styles["border"+sideB+"Width"])}function getSize$4(axis,body,html,computedStyle){return Math.max(body["offset"+axis],body["scroll"+axis],html["client"+axis],html["offset"+axis],html["scroll"+axis],isIE$6(10)?parseInt(html["offset"+axis])+parseInt(computedStyle["margin"+("Height"===axis?"Top":"Left")])+parseInt(computedStyle["margin"+("Height"===axis?"Bottom":"Right")]):0)}function getWindowSizes$4(document){var body=document.body,html=document.documentElement,computedStyle=isIE$6(10)&&getComputedStyle(html);return{height:getSize$4("Height",body,html,computedStyle),width:getSize$4("Width",body,html,computedStyle)}}var classCallCheck$4=function(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")},createClass$4=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),defineProperty$4=function(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj},_extends$8=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target};
/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect$4(offsets){return _extends$8({},offsets,{right:offsets.left+offsets.width,bottom:offsets.top+offsets.height})}
/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */function getBoundingClientRect$4(element){var rect={};
// IE10 10 FIX: Please, don't ask, the element isn't
// considered in DOM in some circumstances...
// This isn't reproducible in IE10 compatibility mode of IE11
try{if(isIE$6(10)){rect=element.getBoundingClientRect();var scrollTop=getScroll$4(element,"top"),scrollLeft=getScroll$4(element,"left");rect.top+=scrollTop,rect.left+=scrollLeft,rect.bottom+=scrollTop,rect.right+=scrollLeft}else rect=element.getBoundingClientRect()}catch(e){}var result={left:rect.left,top:rect.top,width:rect.right-rect.left,height:rect.bottom-rect.top},sizes="HTML"===element.nodeName?getWindowSizes$4(element.ownerDocument):{},width=sizes.width||element.clientWidth||result.width,height=sizes.height||element.clientHeight||result.height,horizScrollbar=element.offsetWidth-width,vertScrollbar=element.offsetHeight-height;
// subtract scrollbar size from sizes
// if an hypothetical scrollbar is detected, we must be sure it's not a `border`
// we make this check conditional for performance reasons
if(horizScrollbar||vertScrollbar){var styles=getStyleComputedProperty$4(element);horizScrollbar-=getBordersSize$4(styles,"x"),vertScrollbar-=getBordersSize$4(styles,"y"),result.width-=horizScrollbar,result.height-=vertScrollbar}return getClientRect$4(result)}function getOffsetRectRelativeToArbitraryNode$4(children,parent){var fixedPosition=arguments.length>2&&void 0!==arguments[2]&&arguments[2],isIE10=isIE$6(10),isHTML="HTML"===parent.nodeName,childrenRect=getBoundingClientRect$4(children),parentRect=getBoundingClientRect$4(parent),scrollParent=getScrollParent$4(children),styles=getStyleComputedProperty$4(parent),borderTopWidth=parseFloat(styles.borderTopWidth),borderLeftWidth=parseFloat(styles.borderLeftWidth);
// In cases where the parent is fixed, we must ignore negative scroll in offset calc
fixedPosition&&isHTML&&(parentRect.top=Math.max(parentRect.top,0),parentRect.left=Math.max(parentRect.left,0));var offsets=getClientRect$4({top:childrenRect.top-parentRect.top-borderTopWidth,left:childrenRect.left-parentRect.left-borderLeftWidth,width:childrenRect.width,height:childrenRect.height});
// Subtract margins of documentElement in case it's being used as parent
// we do this only on HTML because it's the only element that behaves
// differently when margins are applied to it. The margins are included in
// the box of the documentElement, in the other cases not.
if(offsets.marginTop=0,offsets.marginLeft=0,!isIE10&&isHTML){var marginTop=parseFloat(styles.marginTop),marginLeft=parseFloat(styles.marginLeft);offsets.top-=borderTopWidth-marginTop,offsets.bottom-=borderTopWidth-marginTop,offsets.left-=borderLeftWidth-marginLeft,offsets.right-=borderLeftWidth-marginLeft,
// Attach marginTop and marginLeft because in some circumstances we may need them
offsets.marginTop=marginTop,offsets.marginLeft=marginLeft}return(isIE10&&!fixedPosition?parent.contains(scrollParent):parent===scrollParent&&"BODY"!==scrollParent.nodeName)&&(offsets=includeScroll$4(offsets,parent)),offsets}function getViewportOffsetRectRelativeToArtbitraryNode$4(element){var excludeScroll=arguments.length>1&&void 0!==arguments[1]&&arguments[1],html=element.ownerDocument.documentElement,relativeOffset=getOffsetRectRelativeToArbitraryNode$4(element,html),width=Math.max(html.clientWidth,window.innerWidth||0),height=Math.max(html.clientHeight,window.innerHeight||0),scrollTop=excludeScroll?0:getScroll$4(html),scrollLeft=excludeScroll?0:getScroll$4(html,"left"),offset={top:scrollTop-relativeOffset.top+relativeOffset.marginTop,left:scrollLeft-relativeOffset.left+relativeOffset.marginLeft,width:width,height:height};return getClientRect$4(offset)}
/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */function isFixed$4(element){var nodeName=element.nodeName;if("BODY"===nodeName||"HTML"===nodeName)return!1;if("fixed"===getStyleComputedProperty$4(element,"position"))return!0;var parentNode=getParentNode$4(element);return!!parentNode&&isFixed$4(parentNode)}
/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */function getFixedPositionOffsetParent$4(element){
// This check is needed to avoid errors in case one of the elements isn't defined for any reason
if(!element||!element.parentElement||isIE$6())return document.documentElement;var el=element.parentElement;while(el&&"none"===getStyleComputedProperty$4(el,"transform"))el=el.parentElement;return el||document.documentElement}
/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */function getBoundaries$4(popper,reference,padding,boundariesElement){var fixedPosition=arguments.length>4&&void 0!==arguments[4]&&arguments[4],boundaries={top:0,left:0},offsetParent=fixedPosition?getFixedPositionOffsetParent$4(popper):findCommonOffsetParent$4(popper,getReferenceNode$4(reference));
// NOTE: 1 DOM access here
// Handle viewport case
if("viewport"===boundariesElement)boundaries=getViewportOffsetRectRelativeToArtbitraryNode$4(offsetParent,fixedPosition);else{
// Handle other cases based on DOM element used as boundaries
var boundariesNode=void 0;"scrollParent"===boundariesElement?(boundariesNode=getScrollParent$4(getParentNode$4(reference)),"BODY"===boundariesNode.nodeName&&(boundariesNode=popper.ownerDocument.documentElement)):boundariesNode="window"===boundariesElement?popper.ownerDocument.documentElement:boundariesElement;var offsets=getOffsetRectRelativeToArbitraryNode$4(boundariesNode,offsetParent,fixedPosition);
// In case of HTML, we need a different computation
if("HTML"!==boundariesNode.nodeName||isFixed$4(offsetParent))
// for all the other DOM elements, this one is good
boundaries=offsets;else{var _getWindowSizes=getWindowSizes$4(popper.ownerDocument),height=_getWindowSizes.height,width=_getWindowSizes.width;boundaries.top+=offsets.top-offsets.marginTop,boundaries.bottom=height+offsets.top,boundaries.left+=offsets.left-offsets.marginLeft,boundaries.right=width+offsets.left}}
// Add paddings
padding=padding||0;var isPaddingNumber="number"===typeof padding;return boundaries.left+=isPaddingNumber?padding:padding.left||0,boundaries.top+=isPaddingNumber?padding:padding.top||0,boundaries.right-=isPaddingNumber?padding:padding.right||0,boundaries.bottom-=isPaddingNumber?padding:padding.bottom||0,boundaries}function getArea$4(_ref){var width=_ref.width,height=_ref.height;return width*height}
/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function computeAutoPlacement$4(placement,refRect,popper,reference,boundariesElement){var padding=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(-1===placement.indexOf("auto"))return placement;var boundaries=getBoundaries$4(popper,reference,padding,boundariesElement),rects={top:{width:boundaries.width,height:refRect.top-boundaries.top},right:{width:boundaries.right-refRect.right,height:boundaries.height},bottom:{width:boundaries.width,height:boundaries.bottom-refRect.bottom},left:{width:refRect.left-boundaries.left,height:boundaries.height}},sortedAreas=Object.keys(rects).map((function(key){return _extends$8({key:key},rects[key],{area:getArea$4(rects[key])})})).sort((function(a,b){return b.area-a.area})),filteredAreas=sortedAreas.filter((function(_ref2){var width=_ref2.width,height=_ref2.height;return width>=popper.clientWidth&&height>=popper.clientHeight})),computedPlacement=filteredAreas.length>0?filteredAreas[0].key:sortedAreas[0].key,variation=placement.split("-")[1];return computedPlacement+(variation?"-"+variation:"")}
/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */function getReferenceOffsets$4(state,popper,reference){var fixedPosition=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,commonOffsetParent=fixedPosition?getFixedPositionOffsetParent$4(popper):findCommonOffsetParent$4(popper,getReferenceNode$4(reference));return getOffsetRectRelativeToArbitraryNode$4(reference,commonOffsetParent,fixedPosition)}
/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */function getOuterSizes$4(element){var window=element.ownerDocument.defaultView,styles=window.getComputedStyle(element),x=parseFloat(styles.marginTop||0)+parseFloat(styles.marginBottom||0),y=parseFloat(styles.marginLeft||0)+parseFloat(styles.marginRight||0),result={width:element.offsetWidth+y,height:element.offsetHeight+x};return result}
/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */function getOppositePlacement$4(placement){var hash={left:"right",right:"left",bottom:"top",top:"bottom"};return placement.replace(/left|right|bottom|top/g,(function(matched){return hash[matched]}))}
/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */function getPopperOffsets$4(popper,referenceOffsets,placement){placement=placement.split("-")[0];
// Get popper node sizes
var popperRect=getOuterSizes$4(popper),popperOffsets={width:popperRect.width,height:popperRect.height},isHoriz=-1!==["right","left"].indexOf(placement),mainSide=isHoriz?"top":"left",secondarySide=isHoriz?"left":"top",measurement=isHoriz?"height":"width",secondaryMeasurement=isHoriz?"width":"height";
// Add position, width and height to our offsets object
return popperOffsets[mainSide]=referenceOffsets[mainSide]+referenceOffsets[measurement]/2-popperRect[measurement]/2,popperOffsets[secondarySide]=placement===secondarySide?referenceOffsets[secondarySide]-popperRect[secondaryMeasurement]:referenceOffsets[getOppositePlacement$4(secondarySide)],popperOffsets}
/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */function find$5(arr,check){
// use native find if supported
return Array.prototype.find?arr.find(check):arr.filter(check)[0];
// use `filter` to obtain the same behavior of `find`
}
/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */function findIndex$4(arr,prop,value){
// use native findIndex if supported
if(Array.prototype.findIndex)return arr.findIndex((function(cur){return cur[prop]===value}));
// use `find` + `indexOf` if `findIndex` isn't supported
var match=find$5(arr,(function(obj){return obj[prop]===value}));return arr.indexOf(match)}
/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */function runModifiers$4(modifiers,data,ends){var modifiersToRun=void 0===ends?modifiers:modifiers.slice(0,findIndex$4(modifiers,"name",ends));return modifiersToRun.forEach((function(modifier){modifier["function"];var fn=modifier["function"]||modifier.fn;// eslint-disable-line dot-notation
modifier.enabled&&isFunction$7(fn)&&(
// Add properties to offsets to make them a complete clientRect object
// we do this before each modifier to make sure the previous one doesn't
// mess with these values
data.offsets.popper=getClientRect$4(data.offsets.popper),data.offsets.reference=getClientRect$4(data.offsets.reference),data=fn(data,modifier))})),data}
/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */function update$4(){
// if popper is destroyed, don't perform any further update
if(!this.state.isDestroyed){var data={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};
// compute reference element offsets
data.offsets.reference=getReferenceOffsets$4(this.state,this.popper,this.reference,this.options.positionFixed),
// compute auto placement, store placement inside the data object,
// modifiers will be able to edit `placement` if needed
// and refer to originalPlacement to know the original value
data.placement=computeAutoPlacement$4(this.options.placement,data.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),
// store the computed placement inside `originalPlacement`
data.originalPlacement=data.placement,data.positionFixed=this.options.positionFixed,
// compute the popper offsets
data.offsets.popper=getPopperOffsets$4(this.popper,data.offsets.reference,data.placement),data.offsets.popper.position=this.options.positionFixed?"fixed":"absolute",
// run the modifiers
data=runModifiers$4(this.modifiers,data),
// the first `update` will call `onCreate` callback
// the other ones will call `onUpdate` callback
this.state.isCreated?this.options.onUpdate(data):(this.state.isCreated=!0,this.options.onCreate(data))}}
/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */function isModifierEnabled$4(modifiers,modifierName){return modifiers.some((function(_ref){var name=_ref.name,enabled=_ref.enabled;return enabled&&name===modifierName}))}
/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */function getSupportedPropertyName$4(property){for(var prefixes=[!1,"ms","Webkit","Moz","O"],upperProp=property.charAt(0).toUpperCase()+property.slice(1),i=0;i<prefixes.length;i++){var prefix=prefixes[i],toCheck=prefix?""+prefix+upperProp:property;if("undefined"!==typeof document.body.style[toCheck])return toCheck}return null}
/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */function destroy$4(){return this.state.isDestroyed=!0,
// touch DOM only if `applyStyle` modifier is enabled
isModifierEnabled$4(this.modifiers,"applyStyle")&&(this.popper.removeAttribute("x-placement"),this.popper.style.position="",this.popper.style.top="",this.popper.style.left="",this.popper.style.right="",this.popper.style.bottom="",this.popper.style.willChange="",this.popper.style[getSupportedPropertyName$4("transform")]=""),this.disableEventListeners(),
// remove the popper if user explicitly asked for the deletion on destroy
// do not use `remove` because IE11 doesn't support it
this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}
/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */function getWindow$4(element){var ownerDocument=element.ownerDocument;return ownerDocument?ownerDocument.defaultView:window}function attachToScrollParents$4(scrollParent,event,callback,scrollParents){var isBody="BODY"===scrollParent.nodeName,target=isBody?scrollParent.ownerDocument.defaultView:scrollParent;target.addEventListener(event,callback,{passive:!0}),isBody||attachToScrollParents$4(getScrollParent$4(target.parentNode),event,callback,scrollParents),scrollParents.push(target)}
/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */function setupEventListeners$4(reference,options,state,updateBound){
// Resize event listener on window
state.updateBound=updateBound,getWindow$4(reference).addEventListener("resize",state.updateBound,{passive:!0});
// Scroll event listener on scroll parents
var scrollElement=getScrollParent$4(reference);return attachToScrollParents$4(scrollElement,"scroll",state.updateBound,state.scrollParents),state.scrollElement=scrollElement,state.eventsEnabled=!0,state}
/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */function enableEventListeners$4(){this.state.eventsEnabled||(this.state=setupEventListeners$4(this.reference,this.options,this.state,this.scheduleUpdate))}
/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */function removeEventListeners$4(reference,state){
// Remove resize event listener on window
return getWindow$4(reference).removeEventListener("resize",state.updateBound),
// Remove scroll event listener on scroll parents
state.scrollParents.forEach((function(target){target.removeEventListener("scroll",state.updateBound)})),
// Reset state
state.updateBound=null,state.scrollParents=[],state.scrollElement=null,state.eventsEnabled=!1,state}
/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */function disableEventListeners$4(){this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=removeEventListeners$4(this.reference,this.state))}
/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */function isNumeric$4(n){return""!==n&&!isNaN(parseFloat(n))&&isFinite(n)}
/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */function setStyles$4(element,styles){Object.keys(styles).forEach((function(prop){var unit="";
// add unit if the value is numeric and is one of the following
-1!==["width","height","top","right","bottom","left"].indexOf(prop)&&isNumeric$4(styles[prop])&&(unit="px"),element.style[prop]=styles[prop]+unit}))}
/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */function setAttributes$4(element,attributes){Object.keys(attributes).forEach((function(prop){var value=attributes[prop];!1!==value?element.setAttribute(prop,attributes[prop]):element.removeAttribute(prop)}))}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */function applyStyle$4(data){
// any property present in `data.styles` will be applied to the popper,
// in this way we can make the 3rd party modifiers add custom styles to it
// Be aware, modifiers could override the properties defined in the previous
// lines of this modifier!
return setStyles$4(data.instance.popper,data.styles),
// any property present in `data.attributes` will be applied to the popper,
// they will be set as HTML attributes of the element
setAttributes$4(data.instance.popper,data.attributes),
// if arrowElement is defined and arrowStyles has some properties
data.arrowElement&&Object.keys(data.arrowStyles).length&&setStyles$4(data.arrowElement,data.arrowStyles),data}
/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */function applyStyleOnLoad$4(reference,popper,options,modifierOptions,state){
// compute reference element offsets
var referenceOffsets=getReferenceOffsets$4(state,popper,reference,options.positionFixed),placement=computeAutoPlacement$4(options.placement,referenceOffsets,popper,reference,options.modifiers.flip.boundariesElement,options.modifiers.flip.padding);
// compute auto placement, store placement inside the data object,
// modifiers will be able to edit `placement` if needed
// and refer to originalPlacement to know the original value
return popper.setAttribute("x-placement",placement),
// Apply `position` to popper before anything else because
// without the position applied we can't guarantee correct computations
setStyles$4(popper,{position:options.positionFixed?"fixed":"absolute"}),options}
/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */function getRoundedOffsets$4(data,shouldRound){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,round=Math.round,floor=Math.floor,noRound=function(v){return v},referenceWidth=round(reference.width),popperWidth=round(popper.width),isVertical=-1!==["left","right"].indexOf(data.placement),isVariation=-1!==data.placement.indexOf("-"),sameWidthParity=referenceWidth%2===popperWidth%2,bothOddWidth=referenceWidth%2===1&&popperWidth%2===1,horizontalToInteger=shouldRound?isVertical||isVariation||sameWidthParity?round:floor:noRound,verticalToInteger=shouldRound?round:noRound;return{left:horizontalToInteger(bothOddWidth&&!isVariation&&shouldRound?popper.left-1:popper.left),top:verticalToInteger(popper.top),bottom:verticalToInteger(popper.bottom),right:horizontalToInteger(popper.right)}}var isFirefox$4=isBrowser$5&&/Firefox/i.test(navigator.userAgent);
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function computeStyle$4(data,options){var x=options.x,y=options.y,popper=data.offsets.popper,legacyGpuAccelerationOption=find$5(data.instance.modifiers,(function(modifier){return"applyStyle"===modifier.name})).gpuAcceleration,gpuAcceleration=void 0!==legacyGpuAccelerationOption?legacyGpuAccelerationOption:options.gpuAcceleration,offsetParent=getOffsetParent$4(data.instance.popper),offsetParentRect=getBoundingClientRect$4(offsetParent),styles={position:popper.position},offsets=getRoundedOffsets$4(data,window.devicePixelRatio<2||!isFirefox$4),sideA="bottom"===x?"top":"bottom",sideB="right"===y?"left":"right",prefixedProperty=getSupportedPropertyName$4("transform"),left=void 0,top=void 0;if(top="bottom"===sideA?
// when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
// and not the bottom of the html element
"HTML"===offsetParent.nodeName?-offsetParent.clientHeight+offsets.bottom:-offsetParentRect.height+offsets.bottom:offsets.top,left="right"===sideB?"HTML"===offsetParent.nodeName?-offsetParent.clientWidth+offsets.right:-offsetParentRect.width+offsets.right:offsets.left,gpuAcceleration&&prefixedProperty)styles[prefixedProperty]="translate3d("+left+"px, "+top+"px, 0)",styles[sideA]=0,styles[sideB]=0,styles.willChange="transform";else{
// othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
var invertTop="bottom"===sideA?-1:1,invertLeft="right"===sideB?-1:1;styles[sideA]=top*invertTop,styles[sideB]=left*invertLeft,styles.willChange=sideA+", "+sideB}
// Attributes
var attributes={"x-placement":data.placement};
// Update `data` attributes, styles and arrowStyles
return data.attributes=_extends$8({},attributes,data.attributes),data.styles=_extends$8({},styles,data.styles),data.arrowStyles=_extends$8({},data.offsets.arrow,data.arrowStyles),data}
/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */function isModifierRequired$4(modifiers,requestingName,requestedName){var requesting=find$5(modifiers,(function(_ref){var name=_ref.name;return name===requestingName})),isRequired=!!requesting&&modifiers.some((function(modifier){return modifier.name===requestedName&&modifier.enabled&&modifier.order<requesting.order}));if(!isRequired);return isRequired}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function arrow$5(data,options){var _data$offsets$arrow;
// arrow depends on keepTogether in order to work
if(!isModifierRequired$4(data.instance.modifiers,"arrow","keepTogether"))return data;var arrowElement=options.element;
// if arrowElement is a string, suppose it's a CSS selector
if("string"===typeof arrowElement){
// if arrowElement is not found, don't run the modifier
if(arrowElement=data.instance.popper.querySelector(arrowElement),!arrowElement)return data}else
// if the arrowElement isn't a query selector we must check that the
// provided DOM node is child of its popper node
if(!data.instance.popper.contains(arrowElement))return data;var placement=data.placement.split("-")[0],_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,isVertical=-1!==["left","right"].indexOf(placement),len=isVertical?"height":"width",sideCapitalized=isVertical?"Top":"Left",side=sideCapitalized.toLowerCase(),altSide=isVertical?"left":"top",opSide=isVertical?"bottom":"right",arrowElementSize=getOuterSizes$4(arrowElement)[len];
// extends keepTogether behavior making sure the popper and its
// reference have enough pixels in conjunction
// top/left side
reference[opSide]-arrowElementSize<popper[side]&&(data.offsets.popper[side]-=popper[side]-(reference[opSide]-arrowElementSize)),
// bottom/right side
reference[side]+arrowElementSize>popper[opSide]&&(data.offsets.popper[side]+=reference[side]+arrowElementSize-popper[opSide]),data.offsets.popper=getClientRect$4(data.offsets.popper);
// compute center of the popper
var center=reference[side]+reference[len]/2-arrowElementSize/2,css=getStyleComputedProperty$4(data.instance.popper),popperMarginSide=parseFloat(css["margin"+sideCapitalized]),popperBorderSide=parseFloat(css["border"+sideCapitalized+"Width"]),sideValue=center-data.offsets.popper[side]-popperMarginSide-popperBorderSide;
// Compute the sideValue using the updated popper offsets
// take popper margin in account because we don't have this info available
// prevent arrowElement from being placed not contiguously to its popper
return sideValue=Math.max(Math.min(popper[len]-arrowElementSize,sideValue),0),data.arrowElement=arrowElement,data.offsets.arrow=(_data$offsets$arrow={},defineProperty$4(_data$offsets$arrow,side,Math.round(sideValue)),defineProperty$4(_data$offsets$arrow,altSide,""),_data$offsets$arrow),data}
/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */function getOppositeVariation$4(variation){return"end"===variation?"start":"start"===variation?"end":variation}
/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */var placements$4=["auto-start","auto","auto-end","top-start","top","top-end","right-start","right","right-end","bottom-end","bottom","bottom-start","left-end","left","left-start"],validPlacements$4=placements$4.slice(3);
// Get rid of `auto` `auto-start` and `auto-end`
/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise$4(placement){var counter=arguments.length>1&&void 0!==arguments[1]&&arguments[1],index=validPlacements$4.indexOf(placement),arr=validPlacements$4.slice(index+1).concat(validPlacements$4.slice(0,index));return counter?arr.reverse():arr}var BEHAVIORS$4={FLIP:"flip",CLOCKWISE:"clockwise",COUNTERCLOCKWISE:"counterclockwise"};
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function flip$4(data,options){
// if `inner` modifier is enabled, we can't use the `flip` modifier
if(isModifierEnabled$4(data.instance.modifiers,"inner"))return data;if(data.flipped&&data.placement===data.originalPlacement)
// seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
return data;var boundaries=getBoundaries$4(data.instance.popper,data.instance.reference,options.padding,options.boundariesElement,data.positionFixed),placement=data.placement.split("-")[0],placementOpposite=getOppositePlacement$4(placement),variation=data.placement.split("-")[1]||"",flipOrder=[];switch(options.behavior){case BEHAVIORS$4.FLIP:flipOrder=[placement,placementOpposite];break;case BEHAVIORS$4.CLOCKWISE:flipOrder=clockwise$4(placement);break;case BEHAVIORS$4.COUNTERCLOCKWISE:flipOrder=clockwise$4(placement,!0);break;default:flipOrder=options.behavior}return flipOrder.forEach((function(step,index){if(placement!==step||flipOrder.length===index+1)return data;placement=data.placement.split("-")[0],placementOpposite=getOppositePlacement$4(placement);var popperOffsets=data.offsets.popper,refOffsets=data.offsets.reference,floor=Math.floor,overlapsRef="left"===placement&&floor(popperOffsets.right)>floor(refOffsets.left)||"right"===placement&&floor(popperOffsets.left)<floor(refOffsets.right)||"top"===placement&&floor(popperOffsets.bottom)>floor(refOffsets.top)||"bottom"===placement&&floor(popperOffsets.top)<floor(refOffsets.bottom),overflowsLeft=floor(popperOffsets.left)<floor(boundaries.left),overflowsRight=floor(popperOffsets.right)>floor(boundaries.right),overflowsTop=floor(popperOffsets.top)<floor(boundaries.top),overflowsBottom=floor(popperOffsets.bottom)>floor(boundaries.bottom),overflowsBoundaries="left"===placement&&overflowsLeft||"right"===placement&&overflowsRight||"top"===placement&&overflowsTop||"bottom"===placement&&overflowsBottom,isVertical=-1!==["top","bottom"].indexOf(placement),flippedVariationByRef=!!options.flipVariations&&(isVertical&&"start"===variation&&overflowsLeft||isVertical&&"end"===variation&&overflowsRight||!isVertical&&"start"===variation&&overflowsTop||!isVertical&&"end"===variation&&overflowsBottom),flippedVariationByContent=!!options.flipVariationsByContent&&(isVertical&&"start"===variation&&overflowsRight||isVertical&&"end"===variation&&overflowsLeft||!isVertical&&"start"===variation&&overflowsBottom||!isVertical&&"end"===variation&&overflowsTop),flippedVariation=flippedVariationByRef||flippedVariationByContent;(overlapsRef||overflowsBoundaries||flippedVariation)&&(
// this boolean to detect any flip loop
data.flipped=!0,(overlapsRef||overflowsBoundaries)&&(placement=flipOrder[index+1]),flippedVariation&&(variation=getOppositeVariation$4(variation)),data.placement=placement+(variation?"-"+variation:""),
// this object contains `position`, we want to preserve it along with
// any additional property we may add in the future
data.offsets.popper=_extends$8({},data.offsets.popper,getPopperOffsets$4(data.instance.popper,data.offsets.reference,data.placement)),data=runModifiers$4(data.instance.modifiers,data,"flip"))})),data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function keepTogether$4(data){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,placement=data.placement.split("-")[0],floor=Math.floor,isVertical=-1!==["top","bottom"].indexOf(placement),side=isVertical?"right":"bottom",opSide=isVertical?"left":"top",measurement=isVertical?"width":"height";return popper[side]<floor(reference[opSide])&&(data.offsets.popper[opSide]=floor(reference[opSide])-popper[measurement]),popper[opSide]>floor(reference[side])&&(data.offsets.popper[opSide]=floor(reference[side])),data}
/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */function toValue$4(str,measurement,popperOffsets,referenceOffsets){
// separate value from unit
var split=str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),value=+split[1],unit=split[2];
// If it's not a number it's an operator, I guess
if(!value)return str;if(0===unit.indexOf("%")){var element=void 0;switch(unit){case"%p":element=popperOffsets;break;case"%":case"%r":default:element=referenceOffsets}var rect=getClientRect$4(element);return rect[measurement]/100*value}if("vh"===unit||"vw"===unit){
// if is a vh or vw, we calculate the size based on the viewport
var size=void 0;return size="vh"===unit?Math.max(document.documentElement.clientHeight,window.innerHeight||0):Math.max(document.documentElement.clientWidth,window.innerWidth||0),size/100*value}
// if is an explicit pixel unit, we get rid of the unit and keep the value
// if is an implicit unit, it's px, and we return just the value
return value}
/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */function parseOffset$4(offset,popperOffsets,referenceOffsets,basePlacement){var offsets=[0,0],useHeight=-1!==["right","left"].indexOf(basePlacement),fragments=offset.split(/(\+|\-)/).map((function(frag){return frag.trim()})),divider=fragments.indexOf(find$5(fragments,(function(frag){return-1!==frag.search(/,|\s/)})));
// Use height if placement is left or right and index is 0 otherwise use width
// in this way the first offset will use an axis and the second one
// will use the other one
fragments[divider]&&fragments[divider].indexOf(",");
// If divider is found, we divide the list of values and operands to divide
// them by ofset X and Y.
var splitRegex=/\s*,\s*|\s+/,ops=-1!==divider?[fragments.slice(0,divider).concat([fragments[divider].split(splitRegex)[0]]),[fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider+1))]:[fragments];
// Convert the values with units to absolute pixels to allow our computations
return ops=ops.map((function(op,index){
// Most of the units rely on the orientation of the popper
var measurement=(1===index?!useHeight:useHeight)?"height":"width",mergeWithPrevious=!1;return op.reduce((function(a,b){return""===a[a.length-1]&&-1!==["+","-"].indexOf(b)?(a[a.length-1]=b,mergeWithPrevious=!0,a):mergeWithPrevious?(a[a.length-1]+=b,mergeWithPrevious=!1,a):a.concat(b)}),[]).map((function(str){return toValue$4(str,measurement,popperOffsets,referenceOffsets)}))})),
// Loop trough the offsets arrays and execute the operations
ops.forEach((function(op,index){op.forEach((function(frag,index2){isNumeric$4(frag)&&(offsets[index]+=frag*("-"===op[index2-1]?-1:1))}))})),offsets}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */function offset$4(data,_ref){var offset=_ref.offset,placement=data.placement,_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,basePlacement=placement.split("-")[0],offsets=void 0;return offsets=isNumeric$4(+offset)?[+offset,0]:parseOffset$4(offset,popper,reference,basePlacement),"left"===basePlacement?(popper.top+=offsets[0],popper.left-=offsets[1]):"right"===basePlacement?(popper.top+=offsets[0],popper.left+=offsets[1]):"top"===basePlacement?(popper.left+=offsets[0],popper.top-=offsets[1]):"bottom"===basePlacement&&(popper.left+=offsets[0],popper.top+=offsets[1]),data.popper=popper,data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function preventOverflow$4(data,options){var boundariesElement=options.boundariesElement||getOffsetParent$4(data.instance.popper);
// If offsetParent is the reference element, we really want to
// go one step up and use the next offsetParent as reference to
// avoid to make this modifier completely useless and look like broken
data.instance.reference===boundariesElement&&(boundariesElement=getOffsetParent$4(boundariesElement));
// NOTE: DOM access here
// resets the popper's position so that the document size can be calculated excluding
// the size of the popper element itself
var transformProp=getSupportedPropertyName$4("transform"),popperStyles=data.instance.popper.style,top=popperStyles.top,left=popperStyles.left,transform=popperStyles[transformProp];popperStyles.top="",popperStyles.left="",popperStyles[transformProp]="";var boundaries=getBoundaries$4(data.instance.popper,data.instance.reference,options.padding,boundariesElement,data.positionFixed);
// NOTE: DOM access here
// restores the original style properties after the offsets have been computed
popperStyles.top=top,popperStyles.left=left,popperStyles[transformProp]=transform,options.boundaries=boundaries;var order=options.priority,popper=data.offsets.popper,check={primary:function(placement){var value=popper[placement];return popper[placement]<boundaries[placement]&&!options.escapeWithReference&&(value=Math.max(popper[placement],boundaries[placement])),defineProperty$4({},placement,value)},secondary:function(placement){var mainSide="right"===placement?"left":"top",value=popper[mainSide];return popper[placement]>boundaries[placement]&&!options.escapeWithReference&&(value=Math.min(popper[mainSide],boundaries[placement]-("right"===placement?popper.width:popper.height))),defineProperty$4({},mainSide,value)}};return order.forEach((function(placement){var side=-1!==["left","top"].indexOf(placement)?"primary":"secondary";popper=_extends$8({},popper,check[side](placement))})),data.offsets.popper=popper,data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function shift$5(data){var placement=data.placement,basePlacement=placement.split("-")[0],shiftvariation=placement.split("-")[1];
// if shift shiftvariation is specified, run the modifier
if(shiftvariation){var _data$offsets=data.offsets,reference=_data$offsets.reference,popper=_data$offsets.popper,isVertical=-1!==["bottom","top"].indexOf(basePlacement),side=isVertical?"left":"top",measurement=isVertical?"width":"height",shiftOffsets={start:defineProperty$4({},side,reference[side]),end:defineProperty$4({},side,reference[side]+reference[measurement]-popper[measurement])};data.offsets.popper=_extends$8({},popper,shiftOffsets[shiftvariation])}return data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function hide$4(data){if(!isModifierRequired$4(data.instance.modifiers,"hide","preventOverflow"))return data;var refRect=data.offsets.reference,bound=find$5(data.instance.modifiers,(function(modifier){return"preventOverflow"===modifier.name})).boundaries;if(refRect.bottom<bound.top||refRect.left>bound.right||refRect.top>bound.bottom||refRect.right<bound.left){
// Avoid unnecessary DOM access if visibility hasn't changed
if(!0===data.hide)return data;data.hide=!0,data.attributes["x-out-of-boundaries"]=""}else{
// Avoid unnecessary DOM access if visibility hasn't changed
if(!1===data.hide)return data;data.hide=!1,data.attributes["x-out-of-boundaries"]=!1}return data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function inner$4(data){var placement=data.placement,basePlacement=placement.split("-")[0],_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,isHoriz=-1!==["left","right"].indexOf(basePlacement),subtractLength=-1===["top","left"].indexOf(basePlacement);return popper[isHoriz?"left":"top"]=reference[basePlacement]-(subtractLength?popper[isHoriz?"width":"height"]:0),data.placement=getOppositePlacement$4(placement),data.offsets.popper=getClientRect$4(popper),data}
/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */
/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */var modifiers$5={
/**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
shift:{
/** @prop {number} order=100 - Index used to define the order of execution */
order:100,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:shift$5},
/**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
offset:{
/** @prop {number} order=200 - Index used to define the order of execution */
order:200,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:offset$4,
/** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
offset:0},
/**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
preventOverflow:{
/** @prop {number} order=300 - Index used to define the order of execution */
order:300,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:preventOverflow$4,
/**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
priority:["left","right","top","bottom"],
/**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
padding:5,
/**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
boundariesElement:"scrollParent"},
/**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
keepTogether:{
/** @prop {number} order=400 - Index used to define the order of execution */
order:400,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:keepTogether$4},
/**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
arrow:{
/** @prop {number} order=500 - Index used to define the order of execution */
order:500,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:arrow$5,
/** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
element:"[x-arrow]"},
/**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
flip:{
/** @prop {number} order=600 - Index used to define the order of execution */
order:600,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:flip$4,
/**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
behavior:"flip",
/**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
padding:5,
/**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
boundariesElement:"viewport",
/**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
flipVariations:!1,
/**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
flipVariationsByContent:!1},
/**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
inner:{
/** @prop {number} order=700 - Index used to define the order of execution */
order:700,
/** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
enabled:!1,
/** @prop {ModifierFn} */
fn:inner$4},
/**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
hide:{
/** @prop {number} order=800 - Index used to define the order of execution */
order:800,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:hide$4},
/**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
computeStyle:{
/** @prop {number} order=850 - Index used to define the order of execution */
order:850,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:computeStyle$4,
/**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
gpuAcceleration:!0,
/**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
x:"bottom",
/**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
y:"right"},
/**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
applyStyle:{
/** @prop {number} order=900 - Index used to define the order of execution */
order:900,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:applyStyle$4,
/** @prop {Function} */
onLoad:applyStyleOnLoad$4,
/**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
gpuAcceleration:void 0}},Defaults$4={
/**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
placement:"bottom",
/**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
positionFixed:!1,
/**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
eventsEnabled:!0,
/**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
removeOnDestroy:!1,
/**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
onCreate:function(){},
/**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
onUpdate:function(){},
/**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
modifiers:modifiers$5},Popper$5=function(){
/**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
function Popper(reference,popper){var _this=this,options=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};classCallCheck$4(this,Popper),this.scheduleUpdate=function(){return requestAnimationFrame(_this.update)},
// make update() debounced, so that it only runs at most once-per-tick
this.update=debounce$5(this.update.bind(this)),
// with {} we create a new object with the options inside it
this.options=_extends$8({},Popper.Defaults,options),
// init state
this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},
// get reference and popper elements (allow jQuery wrappers)
this.reference=reference&&reference.jquery?reference[0]:reference,this.popper=popper&&popper.jquery?popper[0]:popper,
// Deep merge modifiers options
this.options.modifiers={},Object.keys(_extends$8({},Popper.Defaults.modifiers,options.modifiers)).forEach((function(name){_this.options.modifiers[name]=_extends$8({},Popper.Defaults.modifiers[name]||{},options.modifiers?options.modifiers[name]:{})})),
// Refactoring modifiers' list (Object => Array)
this.modifiers=Object.keys(this.options.modifiers).map((function(name){return _extends$8({name:name},_this.options.modifiers[name])})).sort((function(a,b){return a.order-b.order})),
// modifiers have the ability to execute arbitrary code when Popper.js get inited
// such code is executed in the same order of its modifier
// they could add new properties to their options configuration
// BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
this.modifiers.forEach((function(modifierOptions){modifierOptions.enabled&&isFunction$7(modifierOptions.onLoad)&&modifierOptions.onLoad(_this.reference,_this.popper,_this.options,modifierOptions,_this.state)})),
// fire the first update to position the popper in the right place
this.update();var eventsEnabled=this.options.eventsEnabled;eventsEnabled&&
// setup event listeners, they will take care of update the position in specific situations
this.enableEventListeners(),this.state.eventsEnabled=eventsEnabled}
// We can't use class properties because they don't get listed in the
// class prototype and break stuff like Sinon stubs
return createClass$4(Popper,[{key:"update",value:function(){return update$4.call(this)}},{key:"destroy",value:function(){return destroy$4.call(this)}},{key:"enableEventListeners",value:function(){return enableEventListeners$4.call(this)}},{key:"disableEventListeners",value:function(){return disableEventListeners$4.call(this)}
/**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */
/**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */}]),Popper}();
/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */
/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */
Popper$5.Utils=("undefined"!==typeof window?window:global).PopperUtils,Popper$5.placements=placements$4,Popper$5.Defaults=Defaults$4;
/**!
* tippy.js v4.3.5
* (c) 2017-2019 atomiks
* MIT License
*/
var css$3='.tippy-iOS{cursor:pointer!important;-webkit-tap-highlight-color:transparent}.tippy-popper{transition-timing-function:cubic-bezier(.165,.84,.44,1);max-width:calc(100% - 8px);pointer-events:none;outline:0}.tippy-popper[x-placement^=top] .tippy-backdrop{border-radius:40% 40% 0 0}.tippy-popper[x-placement^=top] .tippy-roundarrow{bottom:-7px;bottom:-6.5px;-webkit-transform-origin:50% 0;transform-origin:50% 0;margin:0 3px}.tippy-popper[x-placement^=top] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(180deg);transform:rotate(180deg)}.tippy-popper[x-placement^=top] .tippy-arrow{border-top:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;bottom:-7px;margin:0 3px;-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=top] .tippy-backdrop{-webkit-transform-origin:0 25%;transform-origin:0 25%}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-55%);transform:scale(1) translate(-50%,-55%)}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%,-45%);transform:scale(.2) translate(-50%,-45%);opacity:0}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(-20px);transform:translateY(-20px)}.tippy-popper[x-placement^=top] [data-animation=perspective]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(-10px);transform:perspective(700px) translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateX(60deg);transform:perspective(700px) rotateX(60deg)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=top] [data-animation=scale]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px) scale(.5);transform:translateY(-10px) scale(.5)}.tippy-popper[x-placement^=bottom] .tippy-backdrop{border-radius:0 0 30% 30%}.tippy-popper[x-placement^=bottom] .tippy-roundarrow{top:-7px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%;margin:0 3px}.tippy-popper[x-placement^=bottom] .tippy-roundarrow svg{position:absolute;left:0}.tippy-popper[x-placement^=bottom] .tippy-arrow{border-bottom:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;top:-7px;margin:0 3px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%}.tippy-popper[x-placement^=bottom] .tippy-backdrop{-webkit-transform-origin:0 -50%;transform-origin:0 -50%}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-45%);transform:scale(1) translate(-50%,-45%)}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%);transform:scale(.2) translate(-50%);opacity:0}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(20px);transform:translateY(20px)}.tippy-popper[x-placement^=bottom] [data-animation=perspective]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(10px);transform:perspective(700px) translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateX(-60deg);transform:perspective(700px) rotateX(-60deg)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=bottom] [data-animation=scale]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px) scale(.5);transform:translateY(10px) scale(.5)}.tippy-popper[x-placement^=left] .tippy-backdrop{border-radius:50% 0 0 50%}.tippy-popper[x-placement^=left] .tippy-roundarrow{right:-12px;-webkit-transform-origin:33.33333333% 50%;transform-origin:33.33333333% 50%;margin:3px 0}.tippy-popper[x-placement^=left] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(90deg);transform:rotate(90deg)}.tippy-popper[x-placement^=left] .tippy-arrow{border-left:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;right:-7px;margin:3px 0;-webkit-transform-origin:0 50%;transform-origin:0 50%}.tippy-popper[x-placement^=left] .tippy-backdrop{-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-75%,-50%);transform:scale(.2) translate(-75%,-50%);opacity:0}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(-20px);transform:translateX(-20px)}.tippy-popper[x-placement^=left] [data-animation=perspective]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(-10px);transform:perspective(700px) translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateY(-60deg);transform:perspective(700px) rotateY(-60deg)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=left] [data-animation=scale]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px) scale(.5);transform:translateX(-10px) scale(.5)}.tippy-popper[x-placement^=right] .tippy-backdrop{border-radius:0 50% 50% 0}.tippy-popper[x-placement^=right] .tippy-roundarrow{left:-12px;-webkit-transform-origin:66.66666666% 50%;transform-origin:66.66666666% 50%;margin:3px 0}.tippy-popper[x-placement^=right] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.tippy-popper[x-placement^=right] .tippy-arrow{border-right:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;left:-7px;margin:3px 0;-webkit-transform-origin:100% 50%;transform-origin:100% 50%}.tippy-popper[x-placement^=right] .tippy-backdrop{-webkit-transform-origin:-50% 0;transform-origin:-50% 0}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-25%,-50%);transform:scale(.2) translate(-25%,-50%);opacity:0}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(20px);transform:translateX(20px)}.tippy-popper[x-placement^=right] [data-animation=perspective]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(10px);transform:perspective(700px) translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateY(60deg);transform:perspective(700px) rotateY(60deg)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=right] [data-animation=scale]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px) scale(.5);transform:translateX(10px) scale(.5)}.tippy-tooltip{position:relative;color:#fff;border-radius:.25rem;font-size:.875rem;padding:.3125rem .5625rem;line-height:1.4;text-align:center;background-color:#333}.tippy-tooltip[data-size=small]{padding:.1875rem .375rem;font-size:.75rem}.tippy-tooltip[data-size=large]{padding:.375rem .75rem;font-size:1rem}.tippy-tooltip[data-animatefill]{overflow:hidden;background-color:initial}.tippy-tooltip[data-interactive],.tippy-tooltip[data-interactive] .tippy-roundarrow path{pointer-events:auto}.tippy-tooltip[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-tooltip[data-inertia][data-state=hidden]{transition-timing-function:ease}.tippy-arrow,.tippy-roundarrow{position:absolute;width:0;height:0}.tippy-roundarrow{width:18px;height:7px;fill:#333;pointer-events:none}.tippy-backdrop{position:absolute;background-color:#333;border-radius:50%;width:calc(110% + 2rem);left:50%;top:50%;z-index:-1;transition:all cubic-bezier(.46,.1,.52,.98);-webkit-backface-visibility:hidden;backface-visibility:hidden}.tippy-backdrop:after{content:"";float:left;padding-top:100%}.tippy-backdrop+.tippy-content{transition-property:opacity;will-change:opacity}.tippy-backdrop+.tippy-content[data-state=hidden]{opacity:0}';function _extends$1$3(){return _extends$1$3=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},_extends$1$3.apply(this,arguments)}var version$3="4.3.5",isBrowser$1$3="undefined"!==typeof window&&"undefined"!==typeof document,ua$3=isBrowser$1$3?navigator.userAgent:"",isIE$1$3=/MSIE |Trident\//.test(ua$3),isUCBrowser$3=/UCBrowser\//.test(ua$3),isIOS$4=isBrowser$1$3&&/iPhone|iPad|iPod/.test(navigator.platform)&&!window.MSStream,defaultProps$4={a11y:!0,allowHTML:!0,animateFill:!0,animation:"shift-away",appendTo:function(){return document.body},aria:"describedby",arrow:!1,arrowType:"sharp",boundary:"scrollParent",content:"",delay:0,distance:10,duration:[325,275],flip:!0,flipBehavior:"flip",flipOnUpdate:!1,followCursor:!1,hideOnClick:!0,ignoreAttributes:!1,inertia:!1,interactive:!1,interactiveBorder:2,interactiveDebounce:0,lazy:!0,maxWidth:350,multiple:!1,offset:0,onHidden:function(){},onHide:function(){},onMount:function(){},onShow:function(){},onShown:function(){},onTrigger:function(){},placement:"top",popperOptions:{},role:"tooltip",showOnInit:!1,size:"regular",sticky:!1,target:"",theme:"dark",touch:!0,touchHold:!1,trigger:"mouseenter focus",triggerTarget:null,updateDuration:0,wait:null,zIndex:9999
/**
   * If the set() method encounters one of these, the popperInstance must be
   * recreated
   */},POPPER_INSTANCE_DEPENDENCIES$3=["arrow","arrowType","boundary","distance","flip","flipBehavior","flipOnUpdate","offset","placement","popperOptions"],elementProto$3=isBrowser$1$3?Element.prototype:{},matches$4=elementProto$3.matches||elementProto$3.matchesSelector||elementProto$3.webkitMatchesSelector||elementProto$3.mozMatchesSelector||elementProto$3.msMatchesSelector;
/**
 * Ponyfill for Array.from - converts iterable values to an array
 */
function arrayFrom$3(value){return[].slice.call(value)}
/**
 * Ponyfill for Element.prototype.closest
 */function closest$3(element,selector){return closestCallback$3(element,(function(el){return matches$4.call(el,selector)}))}
/**
 * Works like Element.prototype.closest, but uses a callback instead
 */function closestCallback$3(element,callback){while(element){if(callback(element))return element;element=element.parentElement}return null}
// Passive event listener config
var PASSIVE$3={passive:!0},PADDING$3=4,PLACEMENT_ATTRIBUTE$3="x-placement",OUT_OF_BOUNDARIES_ATTRIBUTE$3="x-out-of-boundaries",IOS_CLASS$3="tippy-iOS",ACTIVE_CLASS$3="tippy-active",POPPER_CLASS$3="tippy-popper",TOOLTIP_CLASS$3="tippy-tooltip",CONTENT_CLASS$3="tippy-content",BACKDROP_CLASS$3="tippy-backdrop",ARROW_CLASS$3="tippy-arrow",ROUND_ARROW_CLASS$3="tippy-roundarrow",POPPER_SELECTOR$3=".".concat(POPPER_CLASS$3),TOOLTIP_SELECTOR$3=".".concat(TOOLTIP_CLASS$3),CONTENT_SELECTOR$3=".".concat(CONTENT_CLASS$3),BACKDROP_SELECTOR$3=".".concat(BACKDROP_CLASS$3),ARROW_SELECTOR$3=".".concat(ARROW_CLASS$3),ROUND_ARROW_SELECTOR$3=".".concat(ROUND_ARROW_CLASS$3),isUsingTouch$3=!1;function onDocumentTouch$3(){isUsingTouch$3||(isUsingTouch$3=!0,isIOS$4&&document.body.classList.add(IOS_CLASS$3),window.performance&&document.addEventListener("mousemove",onDocumentMouseMove$3))}var lastMouseMoveTime$3=0;function onDocumentMouseMove$3(){var now=performance.now();// Chrome 60+ is 1 mousemove per animation frame, use 20ms time difference
now-lastMouseMoveTime$3<20&&(isUsingTouch$3=!1,document.removeEventListener("mousemove",onDocumentMouseMove$3),isIOS$4||document.body.classList.remove(IOS_CLASS$3)),lastMouseMoveTime$3=now}function onWindowBlur$3(){var _document=document,activeElement=_document.activeElement;activeElement&&activeElement.blur&&activeElement._tippy&&activeElement.blur()}
/**
 * Adds the needed global event listeners
 */function bindGlobalEventListeners$3(){document.addEventListener("touchstart",onDocumentTouch$3,PASSIVE$3),window.addEventListener("blur",onWindowBlur$3)}var keys$4=Object.keys(defaultProps$4);
/**
 * Returns an object of optional props from data-tippy-* attributes
 */function getDataAttributeOptions$3(reference){return keys$4.reduce((function(acc,key){var valueAsString=(reference.getAttribute("data-tippy-".concat(key))||"").trim();if(!valueAsString)return acc;if("content"===key)acc[key]=valueAsString;else try{acc[key]=JSON.parse(valueAsString)}catch(e){acc[key]=valueAsString}return acc}),{})}
/**
 * Polyfills the virtual reference (plain object) with Element.prototype props
 * Mutating because DOM elements are mutated, adds `_tippy` property
 */function polyfillElementPrototypeProperties$3(virtualReference){var polyfills={isVirtual:!0,attributes:virtualReference.attributes||{},contains:function(){},setAttribute:function(key,value){virtualReference.attributes[key]=value},getAttribute:function(key){return virtualReference.attributes[key]},removeAttribute:function(key){delete virtualReference.attributes[key]},hasAttribute:function(key){return key in virtualReference.attributes},addEventListener:function(){},removeEventListener:function(){},classList:{classNames:{},add:function(key){virtualReference.classList.classNames[key]=!0},remove:function(key){delete virtualReference.classList.classNames[key]},contains:function(key){return key in virtualReference.classList.classNames}}};for(var key in polyfills)virtualReference[key]=polyfills[key]}
/**
 * Determines if a value is a "bare" virtual element (before mutations done
 * by `polyfillElementPrototypeProperties()`). JSDOM elements show up as
 * [object Object], we can check if the value is "element-like" if it has
 * `addEventListener`
 */function isBareVirtualElement$3(value){return"[object Object]"==={}.toString.call(value)&&!value.addEventListener}
/**
 * Determines if the value is a reference element
 */function isReferenceElement$3(value){return!!value._tippy&&!matches$4.call(value,POPPER_SELECTOR$3)}
/**
 * Safe .hasOwnProperty check, for prototype-less objects
 */function hasOwnProperty$4(obj,key){return{}.hasOwnProperty.call(obj,key)}
/**
 * Returns an array of elements based on the value
 */function getArrayOfElements$3(value){if(isSingular$3(value))
// TODO: VirtualReference is not compatible to type Element
return[value];if(value instanceof NodeList)return arrayFrom$3(value);if(Array.isArray(value))return value;try{return arrayFrom$3(document.querySelectorAll(value))}catch(e){return[]}}
/**
 * Returns a value at a given index depending on if it's an array or number
 */function getValue$6(value,index,defaultValue){if(Array.isArray(value)){var v=value[index];return null==v?defaultValue:v}return value}
/**
 * Debounce utility. To avoid bloating bundle size, we're only passing 1
 * argument here, a more generic function would pass all arguments. Only
 * `onMouseMove` uses this which takes the event object for now.
 */function debounce$1$3(fn,ms){
// Avoid wrapping in `setTimeout` if ms is 0 anyway
return 0===ms?fn:function(arg){clearTimeout(timeout),timeout=setTimeout((function(){fn(arg)}),ms)};var timeout}
/**
 * Prevents errors from being thrown while accessing nested modifier objects
 * in `popperOptions`
 */function getModifier$3(obj,key){return obj&&obj.modifiers&&obj.modifiers[key]}
/**
 * Determines if an array or string includes a value
 */function includes$3(a,b){return a.indexOf(b)>-1}
/**
 * Determines if the value is a real element
 */function isRealElement$3(value){return value instanceof Element}
/**
 * Determines if the value is singular-like
 */function isSingular$3(value){return!(!value||!hasOwnProperty$4(value,"isVirtual"))||isRealElement$3(value)}
/**
 * Firefox extensions don't allow setting .innerHTML directly, this will trick it
 */function innerHTML$3(){return"innerHTML"}
/**
 * Evaluates a function if one, or returns the value
 */function invokeWithArgsOrReturn$3(value,args){return"function"===typeof value?value.apply(null,args):value}
/**
 * Sets a popperInstance `flip` modifier's enabled state
 */function setFlipModifierEnabled$3(modifiers,value){modifiers.filter((function(m){return"flip"===m.name}))[0].enabled=value}
/**
 * Determines if an element can receive focus
 * Always returns true for virtual objects
 */function canReceiveFocus$3(element){return!isRealElement$3(element)||matches$4.call(element,"a[href],area[href],button,details,input,textarea,select,iframe,[tabindex]")&&!element.hasAttribute("disabled")}
/**
 * Returns a new `div` element
 */function div$3(){return document.createElement("div")}
/**
 * Applies a transition duration to a list of elements
 */function setTransitionDuration$3(els,value){els.forEach((function(el){el&&(el.style.transitionDuration="".concat(value,"ms"))}))}
/**
 * Sets the visibility state to elements so they can begin to transition
 */function setVisibilityState$3(els,state){els.forEach((function(el){el&&el.setAttribute("data-state",state)}))}
/**
 * Evaluates the props object by merging data attributes and
 * disabling conflicting options where necessary
 */function evaluateProps$3(reference,props){var out=_extends$1$3({},props,{content:invokeWithArgsOrReturn$3(props.content,[reference])},props.ignoreAttributes?{}:getDataAttributeOptions$3(reference));return(out.arrow||isUCBrowser$3)&&(out.animateFill=!1),out}
/**
 * Validates an object of options with the valid default props object
 */function validateOptions$3(options,defaultProps){Object.keys(options).forEach((function(option){if(!hasOwnProperty$4(defaultProps,option))throw new Error("[tippy]: `".concat(option,"` is not a valid option"))}))}
/**
 * Sets the innerHTML of an element
 */function setInnerHTML$3(element,html){element[innerHTML$3()]=isRealElement$3(html)?html[innerHTML$3()]:html}
/**
 * Sets the content of a tooltip
 */function setContent$4(contentEl,props){if(isRealElement$3(props.content))setInnerHTML$3(contentEl,""),contentEl.appendChild(props.content);else if("function"!==typeof props.content){var key=props.allowHTML?"innerHTML":"textContent";contentEl[key]=props.content}}
/**
 * Returns the child elements of a popper element
 */function getChildren$3(popper){return{tooltip:popper.querySelector(TOOLTIP_SELECTOR$3),backdrop:popper.querySelector(BACKDROP_SELECTOR$3),content:popper.querySelector(CONTENT_SELECTOR$3),arrow:popper.querySelector(ARROW_SELECTOR$3)||popper.querySelector(ROUND_ARROW_SELECTOR$3)}}
/**
 * Adds `data-inertia` attribute
 */function addInertia$3(tooltip){tooltip.setAttribute("data-inertia","")}
/**
 * Removes `data-inertia` attribute
 */function removeInertia$3(tooltip){tooltip.removeAttribute("data-inertia")}
/**
 * Creates an arrow element and returns it
 */function createArrowElement$3(arrowType){var arrow=div$3();return"round"===arrowType?(arrow.className=ROUND_ARROW_CLASS$3,setInnerHTML$3(arrow,'<svg viewBox="0 0 18 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z"/></svg>')):arrow.className=ARROW_CLASS$3,arrow}
/**
 * Creates a backdrop element and returns it
 */function createBackdropElement$3(){var backdrop=div$3();return backdrop.className=BACKDROP_CLASS$3,backdrop.setAttribute("data-state","hidden"),backdrop}
/**
 * Adds interactive-related attributes
 */function addInteractive$3(popper,tooltip){popper.setAttribute("tabindex","-1"),tooltip.setAttribute("data-interactive","")}
/**
 * Removes interactive-related attributes
 */function removeInteractive$3(popper,tooltip){popper.removeAttribute("tabindex"),tooltip.removeAttribute("data-interactive")}
/**
 * Add/remove transitionend listener from tooltip
 */function updateTransitionEndListener$3(tooltip,action,listener){
// UC Browser hasn't adopted the `transitionend` event despite supporting
// unprefixed transitions...
var eventName=isUCBrowser$3&&void 0!==document.body.style.webkitTransition?"webkitTransitionEnd":"transitionend";tooltip[action+"EventListener"](eventName,listener)}
/**
 * Returns the popper's placement, ignoring shifting (top-start, etc)
 */function getBasicPlacement$3(popper){var fullPlacement=popper.getAttribute(PLACEMENT_ATTRIBUTE$3);return fullPlacement?fullPlacement.split("-")[0]:""}
/**
 * Triggers reflow
 */function reflow$3(popper){popper.offsetHeight}
/**
 * Adds/removes theme from tooltip's classList
 */function updateTheme$3(tooltip,action,theme){theme.split(" ").forEach((function(themeName){tooltip.classList[action](themeName+"-theme")}))}
/**
 * Constructs the popper element and returns it
 */function createPopperElement$3(id,props){var popper=div$3();popper.className=POPPER_CLASS$3,popper.id="tippy-".concat(id),popper.style.zIndex=""+props.zIndex,popper.style.position="absolute",popper.style.top="0",popper.style.left="0",props.role&&popper.setAttribute("role",props.role);var tooltip=div$3();tooltip.className=TOOLTIP_CLASS$3,tooltip.style.maxWidth=props.maxWidth+("number"===typeof props.maxWidth?"px":""),tooltip.setAttribute("data-size",props.size),tooltip.setAttribute("data-animation",props.animation),tooltip.setAttribute("data-state","hidden"),updateTheme$3(tooltip,"add",props.theme);var content=div$3();return content.className=CONTENT_CLASS$3,content.setAttribute("data-state","hidden"),props.interactive&&addInteractive$3(popper,tooltip),props.arrow&&tooltip.appendChild(createArrowElement$3(props.arrowType)),props.animateFill&&(tooltip.appendChild(createBackdropElement$3()),tooltip.setAttribute("data-animatefill","")),props.inertia&&addInertia$3(tooltip),setContent$4(content,props),tooltip.appendChild(content),popper.appendChild(tooltip),popper}
/**
 * Updates the popper element based on the new props
 */function updatePopperElement$3(popper,prevProps,nextProps){var _getChildren=getChildren$3(popper),tooltip=_getChildren.tooltip,content=_getChildren.content,backdrop=_getChildren.backdrop,arrow=_getChildren.arrow;popper.style.zIndex=""+nextProps.zIndex,tooltip.setAttribute("data-size",nextProps.size),tooltip.setAttribute("data-animation",nextProps.animation),tooltip.style.maxWidth=nextProps.maxWidth+("number"===typeof nextProps.maxWidth?"px":""),nextProps.role?popper.setAttribute("role",nextProps.role):popper.removeAttribute("role"),prevProps.content!==nextProps.content&&setContent$4(content,nextProps),// animateFill
!prevProps.animateFill&&nextProps.animateFill?(tooltip.appendChild(createBackdropElement$3()),tooltip.setAttribute("data-animatefill","")):prevProps.animateFill&&!nextProps.animateFill&&(tooltip.removeChild(backdrop),tooltip.removeAttribute("data-animatefill")),// arrow
!prevProps.arrow&&nextProps.arrow?tooltip.appendChild(createArrowElement$3(nextProps.arrowType)):prevProps.arrow&&!nextProps.arrow&&tooltip.removeChild(arrow),// arrowType
prevProps.arrow&&nextProps.arrow&&prevProps.arrowType!==nextProps.arrowType&&tooltip.replaceChild(createArrowElement$3(nextProps.arrowType),arrow),// interactive
!prevProps.interactive&&nextProps.interactive?addInteractive$3(popper,tooltip):prevProps.interactive&&!nextProps.interactive&&removeInteractive$3(popper,tooltip),// inertia
!prevProps.inertia&&nextProps.inertia?addInertia$3(tooltip):prevProps.inertia&&!nextProps.inertia&&removeInertia$3(tooltip),// theme
prevProps.theme!==nextProps.theme&&(updateTheme$3(tooltip,"remove",prevProps.theme),updateTheme$3(tooltip,"add",nextProps.theme))}
/**
 * Hides all visible poppers on the document
 */function hideAll$3(){var _ref=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},excludedReferenceOrInstance=_ref.exclude,duration=_ref.duration;arrayFrom$3(document.querySelectorAll(POPPER_SELECTOR$3)).forEach((function(popper){var instance=popper._tippy;if(instance){var isExcluded=!1;excludedReferenceOrInstance&&(isExcluded=isReferenceElement$3(excludedReferenceOrInstance)?instance.reference===excludedReferenceOrInstance:popper===excludedReferenceOrInstance.popper),isExcluded||instance.hide(duration)}}))}
/**
 * Determines if the mouse cursor is outside of the popper's interactive border
 * region
 */function isCursorOutsideInteractiveBorder$3(popperPlacement,popperRect,event,props){if(!popperPlacement)return!0;var x=event.clientX,y=event.clientY,interactiveBorder=props.interactiveBorder,distance=props.distance,exceedsTop=popperRect.top-y>("top"===popperPlacement?interactiveBorder+distance:interactiveBorder),exceedsBottom=y-popperRect.bottom>("bottom"===popperPlacement?interactiveBorder+distance:interactiveBorder),exceedsLeft=popperRect.left-x>("left"===popperPlacement?interactiveBorder+distance:interactiveBorder),exceedsRight=x-popperRect.right>("right"===popperPlacement?interactiveBorder+distance:interactiveBorder);return exceedsTop||exceedsBottom||exceedsLeft||exceedsRight}
/**
 * Returns the distance offset, taking into account the default offset due to
 * the transform: translate() rule (10px) in CSS
 */function getOffsetDistanceInPx$3(distance){return-(distance-10)+"px"}var idCounter$3=1,mouseMoveListeners$3=[];// Workaround for IE11's lack of new MouseEvent constructor
/**
 * Creates and returns a Tippy object. We're using a closure pattern instead of
 * a class so that the exposed object API is clean without private members
 * prefixed with `_`.
 */
function createTippy$3(reference,collectionProps){var lastTriggerEventType,lastMouseMoveEvent,showTimeoutId,hideTimeoutId,scheduleHideAnimationFrameId,props=evaluateProps$3(reference,collectionProps);// If the reference shouldn't have multiple tippys, return null early
if(!props.multiple&&reference._tippy)return null;
/* ======================= 🔒 Private members 🔒 ======================= */var previousPlacement,currentMountCallback,currentTransitionEndListener,currentComputedPadding,isScheduledToShow=!1,isBeingDestroyed=!1,wasVisibleDuringPreviousUpdate=!1,hasMountCallbackRun=!1,listeners=[],debouncedOnMouseMove=debounce$1$3(onMouseMove,props.interactiveDebounce),id=idCounter$3++,popper=createPopperElement$3(id,props),popperChildren=getChildren$3(popper),popperInstance=null,state={
// Is the instance currently enabled?
isEnabled:!0,
// Is the tippy currently showing and not transitioning out?
isVisible:!1,
// Has the instance been destroyed?
isDestroyed:!1,
// Is the tippy currently mounted to the DOM?
isMounted:!1,
// Has the tippy finished transitioning in?
isShown:!1},instance={
// properties
id:id,reference:reference,popper:popper,popperChildren:popperChildren,popperInstance:popperInstance,props:props,state:state,
// methods
clearDelayTimeouts:clearDelayTimeouts,set:set,setContent:setContent,show:show,hide:hide,enable:enable,disable:disable,destroy:destroy
/* ==================== Initial instance mutations =================== */};return reference._tippy=instance,popper._tippy=instance,addTriggersToReference(),props.lazy||createPopperInstance(),props.showOnInit&&scheduleShow(),// Ensure the event listeners target can receive focus
!props.a11y||props.target||canReceiveFocus$3(getEventListenersTarget())||getEventListenersTarget().setAttribute("tabindex","0"),// Prevent a tippy with a delay from hiding if the cursor left then returned
// before it started hiding
popper.addEventListener("mouseenter",(function(event){instance.props.interactive&&instance.state.isVisible&&"mouseenter"===lastTriggerEventType&&
// We don't want props.onTrigger() to be called here, since the `event`
// object is not related to the reference element
scheduleShow(event,!0)})),popper.addEventListener("mouseleave",(function(){instance.props.interactive&&"mouseenter"===lastTriggerEventType&&document.addEventListener("mousemove",debouncedOnMouseMove)})),instance;
/* ======================= 🔒 Private methods 🔒 ======================= */
/**
   * Removes the follow cursor listener
   */function removeFollowCursorListener(){document.removeEventListener("mousemove",positionVirtualReferenceNearCursor)}
/**
   * Cleans up interactive mouse listeners
   */function cleanupInteractiveMouseListeners(){document.body.removeEventListener("mouseleave",scheduleHide),document.removeEventListener("mousemove",debouncedOnMouseMove),mouseMoveListeners$3=mouseMoveListeners$3.filter((function(listener){return listener!==debouncedOnMouseMove}))}
/**
   * Returns correct target used for event listeners
   */function getEventListenersTarget(){return instance.props.triggerTarget||reference}
/**
   * Adds the document click event listener for the instance
   */function addDocumentClickListener(){document.addEventListener("click",onDocumentClick,!0)}
/**
   * Removes the document click event listener for the instance
   */function removeDocumentClickListener(){document.removeEventListener("click",onDocumentClick,!0)}
/**
   * Returns transitionable inner elements used in show/hide methods
   */function getTransitionableElements(){return[instance.popperChildren.tooltip,instance.popperChildren.backdrop,instance.popperChildren.content]}
/**
   * Determines if the instance is in `followCursor` mode.
   * NOTE: in v5, touch devices will use `initial` behavior no matter the value.
   */function getIsInLooseFollowCursorMode(){var followCursor=instance.props.followCursor;return followCursor&&"focus"!==lastTriggerEventType||isUsingTouch$3&&"initial"===followCursor}
/**
   * Updates the tooltip's position on each animation frame
   */function makeSticky(){setTransitionDuration$3([popper],isIE$1$3?0:instance.props.updateDuration);var prevRefRect=reference.getBoundingClientRect();function updatePosition(){var currentRefRect=reference.getBoundingClientRect();// Only schedule an update if the reference rect has changed
prevRefRect.top===currentRefRect.top&&prevRefRect.right===currentRefRect.right&&prevRefRect.bottom===currentRefRect.bottom&&prevRefRect.left===currentRefRect.left||instance.popperInstance.scheduleUpdate(),prevRefRect=currentRefRect,instance.state.isMounted&&requestAnimationFrame(updatePosition)}updatePosition()}
/**
   * Invokes a callback once the tooltip has fully transitioned out
   */function onTransitionedOut(duration,callback){onTransitionEnd(duration,(function(){!instance.state.isVisible&&popper.parentNode&&popper.parentNode.contains(popper)&&callback()}))}
/**
   * Invokes a callback once the tooltip has fully transitioned in
   */function onTransitionedIn(duration,callback){onTransitionEnd(duration,callback)}
/**
   * Invokes a callback once the tooltip's CSS transition ends
   */function onTransitionEnd(duration,callback){var tooltip=instance.popperChildren.tooltip;
/**
     * Listener added as the `transitionend` handler
     */function listener(event){event.target===tooltip&&(updateTransitionEndListener$3(tooltip,"remove",listener),callback())}// Make callback synchronous if duration is 0
// `transitionend` won't fire otherwise
if(0===duration)return callback();updateTransitionEndListener$3(tooltip,"remove",currentTransitionEndListener),updateTransitionEndListener$3(tooltip,"add",listener),currentTransitionEndListener=listener}
/**
   * Adds an event listener to the reference and stores it in `listeners`
   */function on(eventType,handler){var options=arguments.length>2&&void 0!==arguments[2]&&arguments[2];getEventListenersTarget().addEventListener(eventType,handler,options),listeners.push({eventType:eventType,handler:handler,options:options})}
/**
   * Adds event listeners to the reference based on the `trigger` prop
   */function addTriggersToReference(){instance.props.touchHold&&!instance.props.target&&(on("touchstart",onTrigger,PASSIVE$3),on("touchend",onMouseLeave,PASSIVE$3)),instance.props.trigger.trim().split(" ").forEach((function(eventType){if("manual"!==eventType)// Non-delegates
if(instance.props.target)
// Delegates
switch(eventType){case"mouseenter":on("mouseover",onDelegateShow),on("mouseout",onDelegateHide);break;case"focus":on("focusin",onDelegateShow),on("focusout",onDelegateHide);break;case"click":on(eventType,onDelegateShow);break}else switch(on(eventType,onTrigger),eventType){case"mouseenter":on("mouseleave",onMouseLeave);break;case"focus":on(isIE$1$3?"focusout":"blur",onBlur);break}}))}
/**
   * Removes event listeners from the reference
   */function removeTriggersFromReference(){listeners.forEach((function(_ref){var eventType=_ref.eventType,handler=_ref.handler,options=_ref.options;getEventListenersTarget().removeEventListener(eventType,handler,options)})),listeners=[]}
/**
   * Positions the virtual reference near the cursor
   */function positionVirtualReferenceNearCursor(event){var _lastMouseMoveEvent=lastMouseMoveEvent=event,x=_lastMouseMoveEvent.clientX,y=_lastMouseMoveEvent.clientY;// Gets set once popperInstance `onCreate` has been called
if(currentComputedPadding){// If the instance is interactive, avoid updating the position unless it's
// over the reference element
var isCursorOverReference=closestCallback$3(event.target,(function(el){return el===reference})),rect=reference.getBoundingClientRect(),followCursor=instance.props.followCursor,isHorizontal="horizontal"===followCursor,isVertical="vertical"===followCursor,isVerticalPlacement=includes$3(["top","bottom"],getBasicPlacement$3(popper)),fullPlacement=popper.getAttribute(PLACEMENT_ATTRIBUTE$3),isVariation=!!fullPlacement&&!!fullPlacement.split("-")[1],size=isVerticalPlacement?popper.offsetWidth:popper.offsetHeight,halfSize=size/2,verticalIncrease=isVerticalPlacement?0:isVariation?size:halfSize,horizontalIncrease=isVerticalPlacement?isVariation?size:halfSize:0;!isCursorOverReference&&instance.props.interactive||(instance.popperInstance.reference=_extends$1$3({},instance.popperInstance.reference,{
// This will exist in next Popper.js feature release to fix #532
// @ts-ignore
referenceNode:reference,
// These `client` values don't get used by Popper.js if they are 0
clientWidth:0,clientHeight:0,getBoundingClientRect:function(){return{width:isVerticalPlacement?size:0,height:isVerticalPlacement?0:size,top:(isHorizontal?rect.top:y)-verticalIncrease,bottom:(isHorizontal?rect.bottom:y)+verticalIncrease,left:(isVertical?rect.left:x)-horizontalIncrease,right:(isVertical?rect.right:x)+horizontalIncrease}}}),instance.popperInstance.update()),"initial"===followCursor&&instance.state.isVisible&&removeFollowCursorListener()}}
/**
   * Creates the tippy instance for a delegate when it's been triggered
   */function createDelegateChildTippy(event){if(event){var targetEl=closest$3(event.target,instance.props.target);targetEl&&!targetEl._tippy&&createTippy$3(targetEl,_extends$1$3({},instance.props,{content:invokeWithArgsOrReturn$3(collectionProps.content,[targetEl]),appendTo:collectionProps.appendTo,target:"",showOnInit:!0}))}}
/**
   * Event listener invoked upon trigger
   */function onTrigger(event){instance.state.isEnabled&&!isEventListenerStopped(event)&&(instance.state.isVisible||(lastTriggerEventType=event.type,event instanceof MouseEvent&&(lastMouseMoveEvent=event,// If scrolling, `mouseenter` events can be fired if the cursor lands
// over a new target, but `mousemove` events don't get fired. This
// causes interactive tooltips to get stuck open until the cursor is
// moved
mouseMoveListeners$3.forEach((function(listener){return listener(event)})))),// Toggle show/hide when clicking click-triggered tooltips
"click"===event.type&&!1!==instance.props.hideOnClick&&instance.state.isVisible?scheduleHide():scheduleShow(event))}
/**
   * Event listener used for interactive tooltips to detect when they should
   * hide
   */function onMouseMove(event){var isCursorOverPopper=closest$3(event.target,POPPER_SELECTOR$3)===popper,isCursorOverReference=closestCallback$3(event.target,(function(el){return el===reference}));isCursorOverPopper||isCursorOverReference||isCursorOutsideInteractiveBorder$3(getBasicPlacement$3(popper),popper.getBoundingClientRect(),event,instance.props)&&(cleanupInteractiveMouseListeners(),scheduleHide())}
/**
   * Event listener invoked upon mouseleave
   */function onMouseLeave(event){if(!isEventListenerStopped(event))return instance.props.interactive?(document.body.addEventListener("mouseleave",scheduleHide),document.addEventListener("mousemove",debouncedOnMouseMove),void mouseMoveListeners$3.push(debouncedOnMouseMove)):void scheduleHide()}
/**
   * Event listener invoked upon blur
   */function onBlur(event){event.target===getEventListenersTarget()&&(instance.props.interactive&&event.relatedTarget&&popper.contains(event.relatedTarget)||scheduleHide())}
/**
   * Event listener invoked when a child target is triggered
   */function onDelegateShow(event){closest$3(event.target,instance.props.target)&&scheduleShow(event)}
/**
   * Event listener invoked when a child target should hide
   */function onDelegateHide(event){closest$3(event.target,instance.props.target)&&scheduleHide()}
/**
   * Determines if an event listener should stop further execution due to the
   * `touchHold` option
   */function isEventListenerStopped(event){var supportsTouch="ontouchstart"in window,isTouchEvent=includes$3(event.type,"touch"),touchHold=instance.props.touchHold;return supportsTouch&&isUsingTouch$3&&touchHold&&!isTouchEvent||isUsingTouch$3&&!touchHold&&isTouchEvent}
/**
   * Runs the mount callback
   */function runMountCallback(){!hasMountCallbackRun&&currentMountCallback&&(hasMountCallbackRun=!0,reflow$3(popper),currentMountCallback())}
/**
   * Creates the popper instance for the instance
   */function createPopperInstance(){var popperOptions=instance.props.popperOptions,_instance$popperChild=instance.popperChildren,tooltip=_instance$popperChild.tooltip,arrow=_instance$popperChild.arrow,preventOverflowModifier=getModifier$3(popperOptions,"preventOverflow");function applyMutations(data){instance.props.flip&&!instance.props.flipOnUpdate&&(data.flipped&&(instance.popperInstance.options.placement=data.placement),setFlipModifierEnabled$3(instance.popperInstance.modifiers,!1)),// Apply all of the popper's attributes to the tootip node as well.
// Allows users to avoid using the .tippy-popper selector for themes.
tooltip.setAttribute(PLACEMENT_ATTRIBUTE$3,data.placement),!1!==data.attributes[OUT_OF_BOUNDARIES_ATTRIBUTE$3]?tooltip.setAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE$3,""):tooltip.removeAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE$3),// Prevents a transition when changing placements (while tippy is visible)
// for scroll/resize updates
previousPlacement&&previousPlacement!==data.placement&&wasVisibleDuringPreviousUpdate&&(tooltip.style.transition="none",requestAnimationFrame((function(){tooltip.style.transition=""}))),previousPlacement=data.placement,wasVisibleDuringPreviousUpdate=instance.state.isVisible;var basicPlacement=getBasicPlacement$3(popper),styles=tooltip.style;// Account for the `distance` offset
styles.top=styles.bottom=styles.left=styles.right="",styles[basicPlacement]=getOffsetDistanceInPx$3(instance.props.distance);var padding=preventOverflowModifier&&void 0!==preventOverflowModifier.padding?preventOverflowModifier.padding:PADDING$3,isPaddingNumber="number"===typeof padding,computedPadding=_extends$1$3({top:isPaddingNumber?padding:padding.top,bottom:isPaddingNumber?padding:padding.bottom,left:isPaddingNumber?padding:padding.left,right:isPaddingNumber?padding:padding.right},!isPaddingNumber&&padding);computedPadding[basicPlacement]=isPaddingNumber?padding+instance.props.distance:(padding[basicPlacement]||0)+instance.props.distance,instance.popperInstance.modifiers.filter((function(m){return"preventOverflow"===m.name}))[0].padding=computedPadding,currentComputedPadding=computedPadding}var config=_extends$1$3({eventsEnabled:!1,placement:instance.props.placement},popperOptions,{modifiers:_extends$1$3({},popperOptions?popperOptions.modifiers:{},{preventOverflow:_extends$1$3({boundariesElement:instance.props.boundary,padding:PADDING$3},preventOverflowModifier),arrow:_extends$1$3({element:arrow,enabled:!!arrow},getModifier$3(popperOptions,"arrow")),flip:_extends$1$3({enabled:instance.props.flip,
// The tooltip is offset by 10px from the popper in CSS,
// we need to account for its distance
padding:instance.props.distance+PADDING$3,behavior:instance.props.flipBehavior},getModifier$3(popperOptions,"flip")),offset:_extends$1$3({offset:instance.props.offset},getModifier$3(popperOptions,"offset"))}),onCreate:function(data){applyMutations(data),runMountCallback(),popperOptions&&popperOptions.onCreate&&popperOptions.onCreate(data)},onUpdate:function(data){applyMutations(data),runMountCallback(),popperOptions&&popperOptions.onUpdate&&popperOptions.onUpdate(data)}});instance.popperInstance=new Popper$5(reference,popper,config)}
/**
   * Mounts the tooltip to the DOM
   */function mount(){hasMountCallbackRun=!1;var isInLooseFollowCursorMode=getIsInLooseFollowCursorMode();instance.popperInstance?(setFlipModifierEnabled$3(instance.popperInstance.modifiers,instance.props.flip),isInLooseFollowCursorMode||(instance.popperInstance.reference=reference,instance.popperInstance.enableEventListeners()),instance.popperInstance.scheduleUpdate()):(createPopperInstance(),isInLooseFollowCursorMode||instance.popperInstance.enableEventListeners());var appendTo=instance.props.appendTo,parentNode="parent"===appendTo?reference.parentNode:invokeWithArgsOrReturn$3(appendTo,[reference]);parentNode.contains(popper)||(parentNode.appendChild(popper),instance.props.onMount(instance),instance.state.isMounted=!0)}
/**
   * Setup before show() is invoked (delays, etc.)
   */function scheduleShow(event,shouldAvoidCallingOnTrigger){if(clearDelayTimeouts(),!instance.state.isVisible){// Is a delegate, create an instance for the child target
if(instance.props.target)return createDelegateChildTippy(event);if(isScheduledToShow=!0,event&&!shouldAvoidCallingOnTrigger&&instance.props.onTrigger(instance,event),instance.props.wait)return instance.props.wait(instance,event);// If the tooltip has a delay, we need to be listening to the mousemove as
// soon as the trigger event is fired, so that it's in the correct position
// upon mount.
// Edge case: if the tooltip is still mounted, but then scheduleShow() is
// called, it causes a jump.
getIsInLooseFollowCursorMode()&&!instance.state.isMounted&&(instance.popperInstance||createPopperInstance(),document.addEventListener("mousemove",positionVirtualReferenceNearCursor)),addDocumentClickListener();var delay=getValue$6(instance.props.delay,0,defaultProps$4.delay);delay?showTimeoutId=setTimeout((function(){show()}),delay):show()}}
/**
   * Setup before hide() is invoked (delays, etc.)
   */function scheduleHide(){if(clearDelayTimeouts(),!instance.state.isVisible)return removeFollowCursorListener(),void removeDocumentClickListener();isScheduledToShow=!1;var delay=getValue$6(instance.props.delay,1,defaultProps$4.delay);delay?hideTimeoutId=setTimeout((function(){instance.state.isVisible&&hide()}),delay):
// Fixes a `transitionend` problem when it fires 1 frame too
// late sometimes, we don't want hide() to be called.
scheduleHideAnimationFrameId=requestAnimationFrame((function(){hide()}))}
/**
   * Listener to handle clicks on the document to determine if the
   * instance should hide
   */function onDocumentClick(event){
// Clicked on interactive popper
if(!instance.props.interactive||!popper.contains(event.target)){// Clicked on the event listeners target
if(getEventListenersTarget().contains(event.target)){if(isUsingTouch$3)return;if(instance.state.isVisible&&includes$3(instance.props.trigger,"click"))return}!0===instance.props.hideOnClick&&(clearDelayTimeouts(),hide())}}
/* ======================= 🔑 Public methods 🔑 ======================= */
/**
   * Enables the instance to allow it to show or hide
   */function enable(){instance.state.isEnabled=!0}
/**
   * Disables the instance to disallow it to show or hide
   */function disable(){instance.state.isEnabled=!1}
/**
   * Clears pending timeouts related to the `delay` prop if any
   */function clearDelayTimeouts(){clearTimeout(showTimeoutId),clearTimeout(hideTimeoutId),cancelAnimationFrame(scheduleHideAnimationFrameId)}
/**
   * Sets new props for the instance and redraws the tooltip
   */function set(options){
// Backwards-compatible after TypeScript change
options=options||{},validateOptions$3(options,defaultProps$4),removeTriggersFromReference();var prevProps=instance.props,nextProps=evaluateProps$3(reference,_extends$1$3({},instance.props,{},options,{ignoreAttributes:!0}));nextProps.ignoreAttributes=hasOwnProperty$4(options,"ignoreAttributes")?options.ignoreAttributes||!1:prevProps.ignoreAttributes,instance.props=nextProps,addTriggersToReference(),cleanupInteractiveMouseListeners(),debouncedOnMouseMove=debounce$1$3(onMouseMove,nextProps.interactiveDebounce),updatePopperElement$3(popper,prevProps,nextProps),instance.popperChildren=getChildren$3(popper),instance.popperInstance&&(POPPER_INSTANCE_DEPENDENCIES$3.some((function(prop){return hasOwnProperty$4(options,prop)&&options[prop]!==prevProps[prop]}))?(instance.popperInstance.destroy(),createPopperInstance(),instance.state.isVisible&&instance.popperInstance.enableEventListeners(),instance.props.followCursor&&lastMouseMoveEvent&&positionVirtualReferenceNearCursor(lastMouseMoveEvent)):instance.popperInstance.update())}
/**
   * Shortcut for .set({ content: newContent })
   */function setContent(content){set({content:content})}
/**
   * Shows the tooltip
   */function show(){var duration=arguments.length>0&&void 0!==arguments[0]?arguments[0]:getValue$6(instance.props.duration,0,defaultProps$4.duration[1]);if(!instance.state.isDestroyed&&instance.state.isEnabled&&(!isUsingTouch$3||instance.props.touch)&&!getEventListenersTarget().hasAttribute("disabled")&&!1!==instance.props.onShow(instance)){addDocumentClickListener(),popper.style.visibility="visible",instance.state.isVisible=!0,instance.props.interactive&&getEventListenersTarget().classList.add(ACTIVE_CLASS$3);// Prevent a transition if the popper is at the opposite placement
var transitionableElements=getTransitionableElements();setTransitionDuration$3(transitionableElements.concat(popper),0),currentMountCallback=function(){if(instance.state.isVisible){var isInLooseFollowCursorMode=getIsInLooseFollowCursorMode();isInLooseFollowCursorMode&&lastMouseMoveEvent?positionVirtualReferenceNearCursor(lastMouseMoveEvent):isInLooseFollowCursorMode||
// Double update will apply correct mutations
instance.popperInstance.update(),instance.popperChildren.backdrop&&(instance.popperChildren.content.style.transitionDelay=Math.round(duration/12)+"ms"),instance.props.sticky&&makeSticky(),setTransitionDuration$3([popper],instance.props.updateDuration),setTransitionDuration$3(transitionableElements,duration),setVisibilityState$3(transitionableElements,"visible"),onTransitionedIn(duration,(function(){instance.props.aria&&getEventListenersTarget().setAttribute("aria-".concat(instance.props.aria),popper.id),instance.props.onShown(instance),instance.state.isShown=!0}))}},mount()}// Standardize `disabled` behavior across browsers.
// Firefox allows events on disabled elements, but Chrome doesn't.
// Using a wrapper element (i.e. <span>) is recommended.
}
/**
   * Hides the tooltip
   */function hide(){var duration=arguments.length>0&&void 0!==arguments[0]?arguments[0]:getValue$6(instance.props.duration,1,defaultProps$4.duration[1]);if(!instance.state.isDestroyed&&(instance.state.isEnabled||isBeingDestroyed)&&(!1!==instance.props.onHide(instance)||isBeingDestroyed)){removeDocumentClickListener(),popper.style.visibility="hidden",instance.state.isVisible=!1,instance.state.isShown=!1,wasVisibleDuringPreviousUpdate=!1,instance.props.interactive&&getEventListenersTarget().classList.remove(ACTIVE_CLASS$3);var transitionableElements=getTransitionableElements();setTransitionDuration$3(transitionableElements,duration),setVisibilityState$3(transitionableElements,"hidden"),onTransitionedOut(duration,(function(){isScheduledToShow||removeFollowCursorListener(),instance.props.aria&&getEventListenersTarget().removeAttribute("aria-".concat(instance.props.aria)),instance.popperInstance.disableEventListeners(),instance.popperInstance.options.placement=instance.props.placement,popper.parentNode.removeChild(popper),instance.props.onHidden(instance),instance.state.isMounted=!1}))}}
/**
   * Destroys the tooltip
   */function destroy(destroyTargetInstances){if(!instance.state.isDestroyed){isBeingDestroyed=!0,// If the popper is currently mounted to the DOM, we want to ensure it gets
// hidden and unmounted instantly upon destruction
instance.state.isMounted&&hide(0),removeTriggersFromReference(),delete reference._tippy;var target=instance.props.target;target&&destroyTargetInstances&&isRealElement$3(reference)&&arrayFrom$3(reference.querySelectorAll(target)).forEach((function(child){child._tippy&&child._tippy.destroy()})),instance.popperInstance&&instance.popperInstance.destroy(),isBeingDestroyed=!1,instance.state.isDestroyed=!0}}}
/**
 * Groups an array of instances by taking control of their props during
 * certain lifecycles.
 */function group$3(instances){var _ref=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_ref$delay=_ref.delay,delay=void 0===_ref$delay?instances[0].props.delay:_ref$delay,_ref$duration=_ref.duration,duration=void 0===_ref$duration?0:_ref$duration,isAnyTippyOpen=!1;function setIsAnyTippyOpen(value){isAnyTippyOpen=value,updateInstances()}function onShow(instance){instance._originalProps.onShow(instance),instances.forEach((function(instance){instance.set({duration:duration}),instance.state.isVisible&&instance.hide()})),setIsAnyTippyOpen(!0)}function onHide(instance){instance._originalProps.onHide(instance),setIsAnyTippyOpen(!1)}function onShown(instance){instance._originalProps.onShown(instance),instance.set({duration:instance._originalProps.duration})}function updateInstances(){instances.forEach((function(instance){instance.set({onShow:onShow,onShown:onShown,onHide:onHide,delay:isAnyTippyOpen?[0,Array.isArray(delay)?delay[1]:delay]:delay,duration:isAnyTippyOpen?duration:instance._originalProps.duration})}))}instances.forEach((function(instance){instance._originalProps?instance.set(instance._originalProps):instance._originalProps=_extends$1$3({},instance.props)})),updateInstances()}var globalEventListenersBound$3=!1;
/**
 * Exported module
 */function tippy$3(targets,options){validateOptions$3(options||{},defaultProps$4),globalEventListenersBound$3||(bindGlobalEventListeners$3(),globalEventListenersBound$3=!0);var props=_extends$1$3({},defaultProps$4,{},options);// If they are specifying a virtual positioning reference, we need to polyfill
// some native DOM props
isBareVirtualElement$3(targets)&&polyfillElementPrototypeProperties$3(targets);var instances=getArrayOfElements$3(targets).reduce((function(acc,reference){var instance=reference&&createTippy$3(reference,props);return instance&&acc.push(instance),acc}),[]);return isSingular$3(targets)?instances[0]:instances}
/**
 * Static props
 */
/**
 * Auto-init tooltips for elements with a `data-tippy="..."` attribute
 */
function autoInit$3(){arrayFrom$3(document.querySelectorAll("[data-tippy]")).forEach((function(el){var content=el.getAttribute("data-tippy");content&&tippy$3(el,{content:content})}))}
/**
 * Injects a string of CSS styles to a style node in <head>
 */
function injectCSS$3(css){if(isBrowser$1$3){var style=document.createElement("style");style.type="text/css",style.textContent=css,style.setAttribute("data-tippy-stylesheet","");var head=document.head,firstStyleOrLinkTag=head.querySelector("style,link");firstStyleOrLinkTag?head.insertBefore(style,firstStyleOrLinkTag):head.appendChild(style)}}tippy$3.version=version$3,tippy$3.defaults=defaultProps$4,
/**
 * Static methods
 */
tippy$3.setDefaults=function(partialDefaults){Object.keys(partialDefaults).forEach((function(key){
// @ts-ignore
defaultProps$4[key]=partialDefaults[key]}))},tippy$3.hideAll=hideAll$3,tippy$3.group=group$3,isBrowser$1$3&&setTimeout(autoInit$3),injectCSS$3(css$3);var commonjsGlobal$3="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof window?window:"undefined"!==typeof global?global:"undefined"!==typeof self?self:{};function createCommonjsModule$4(fn,module){return module={exports:{}},fn(module,module.exports),module.exports}var humps$3=createCommonjsModule$4((function(module){(function(global){var _processKeys=function(convert,obj,options){if(!_isObject(obj)||_isDate(obj)||_isRegExp(obj)||_isBoolean(obj)||_isFunction(obj))return obj;var output,i=0,l=0;if(_isArray(obj))for(output=[],l=obj.length;i<l;i++)output.push(_processKeys(convert,obj[i],options));else for(var key in output={},obj)Object.prototype.hasOwnProperty.call(obj,key)&&(output[convert(key,options)]=_processKeys(convert,obj[key],options));return output},separateWords=function(string,options){options=options||{};var separator=options.separator||"_",split=options.split||/(?=[A-Z])/;return string.split(split).join(separator)},camelize=function(string){return _isNumerical(string)?string:(string=string.replace(/[\-_\s]+(.)?/g,(function(match,chr){return chr?chr.toUpperCase():""})),string.substr(0,1).toLowerCase()+string.substr(1))},pascalize=function(string){var camelized=camelize(string);
// Ensure 1st char is always uppercase
return camelized.substr(0,1).toUpperCase()+camelized.substr(1)},decamelize=function(string,options){return separateWords(string,options).toLowerCase()},toString=Object.prototype.toString,_isFunction=function(obj){return"function"===typeof obj},_isObject=function(obj){return obj===Object(obj)},_isArray=function(obj){return"[object Array]"==toString.call(obj)},_isDate=function(obj){return"[object Date]"==toString.call(obj)},_isRegExp=function(obj){return"[object RegExp]"==toString.call(obj)},_isBoolean=function(obj){return"[object Boolean]"==toString.call(obj)},_isNumerical=function(obj){return obj-=0,obj===obj},_processor=function(convert,options){var callback=options&&"process"in options?options.process:options;return"function"!==typeof callback?convert:function(string,options){return callback(string,convert,options)}},humps={camelize:camelize,decamelize:decamelize,pascalize:pascalize,depascalize:decamelize,camelizeKeys:function(object,options){return _processKeys(_processor(camelize,options),object)},decamelizeKeys:function(object,options){return _processKeys(_processor(decamelize,options),object,options)},pascalizeKeys:function(object,options){return _processKeys(_processor(pascalize,options),object)},depascalizeKeys:function(){return this.decamelizeKeys.apply(this,arguments)}};
// String conversion methods
module.exports?module.exports=humps:global.humps=humps})(commonjsGlobal$3)}));function _defineProperty$5(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function ownKeys$7(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread2$4(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$7(Object(source),!0).forEach((function(key){_defineProperty$5(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$7(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}var booleanProps$3={a11y:!0,allowHTML:!0,animateFill:!0,arrow:!1,flip:!0,flipOnUpdate:!1,followCursor:!1,hideOnClick:!0,ignoreAttributes:!1,inertia:!1,interactive:!1,lazy:!0,multiple:!1,showOnInit:!1,sticky:!1,touch:!0,touchHold:!1},defaultProps$1$3=_objectSpread2$4({animation:"shift-away",appendTo:function(){return document.body},aria:"describedby",arrowType:"sharp",boundary:"scrollParent",content:"",delay:0,distance:10,duration:[325,275],flipBehavior:"flip",interactiveBorder:2,interactiveDebounce:0,maxWidth:350,offset:0,onHidden:function(){},onHide:function(){},onMount:function(){},onShow:function(){},onShown:function(){},placement:"top",popperOptions:{},role:"tooltip",size:"regular",target:"",theme:"dark",trigger:"mouseenter focus",updateDuration:0,wait:null,zIndex:9999},booleanProps$3),script$2$4={props:{to:void 0,toSelector:void 0,toElement:void 0,content:void 0,enabled:void 0,visible:void 0,triggerTarget:void 0,tag:{type:String,default:"div"},triggerTag:String,contentTag:String},data:function(){return{tip:null,options:{}}},mounted:function(){this.init()},watch:{content:function(){this.tip&&this.tip.set(this.getOptions())},enabled:function(val){this.tip&&(val?this.tip.enable():(this.tip.hide(),this.tip.disable()))},visible:function(val){this.tip&&(val?this.tip.show():this.tip.hide())}},updated:function(){this.tip&&!this.content&&this.tip.set(this.getOptions())},beforeDestroy:function(){this.tip&&this.tip.destroy()},computed:{isManualTrigger:function(){return"manual"===this.options.trigger}},methods:{init:function(){if(this.tip){try{this.tip.destroy()}catch(error){}this.tip=null}var elm=this.toElement;if(null==elm&&(elm=this.to?document.querySelector("[name='".concat(this.to,"']")):this.toSelector?document.querySelector(this.toSelector):this.$refs.trigger&&this.$refs.trigger.childElementCount>0?this.$refs.trigger:this.$el.parentElement),elm){var tip=tippy$3(elm,this.getOptions());if(tip){if(Array.isArray(tip)){if(!(tip.length>0))return;this.tip=tip[0]}this.tip=tip,this.$emit("onCreate",this.tip),this.$emit("init",this.tip),!1===this.enabled&&this.tip.disable(),this.isManualTrigger&&!0===this.visible&&this.tip.show()}}},tippy:function(){return this.tip},filterOptions:function(){for(var getValue=function(key,value){if(booleanProps$3.hasOwnProperty(key)){if(""===value)return!0;if("false"===value)return!1;if("true"===value)return!0}return value},_i=0,_Object$keys=Object.keys(this.options);_i<_Object$keys.length;_i++){var key=_Object$keys[_i];defaultProps$1$3.hasOwnProperty(key)?this.options[key]=getValue(key,this.options[key]):
// We're replacing this.options anyway, we don't have to worry about modifying the object
delete this.options[key]}return this.options},getOptions:function(){var _this=this;return this.options.content=this.content?this.content:this.$refs.content,Object.assign(this.options,humps$3.camelizeKeys(this.$attrs)),this.filterOptions(),!this.options.onShow&&this.$listeners&&this.$listeners["show"]&&(this.options.onShow=function(){var _this$$listeners$show;return(_this$$listeners$show=_this.$listeners["show"]).fns.apply(_this$$listeners$show,arguments)}),!this.options.onShow&&this.$listeners&&this.$listeners["shown"]&&(this.options.onShown=function(){var _this$$listeners$show2;return(_this$$listeners$show2=_this.$listeners["shown"]).fns.apply(_this$$listeners$show2,arguments)}),!this.options.onHidden&&this.$listeners&&this.$listeners["hidden"]&&(this.options.onHidden=function(){var _this$$listeners$hidd;return(_this$$listeners$hidd=_this.$listeners["hidden"]).fns.apply(_this$$listeners$hidd,arguments)}),!this.options.onHide&&this.$listeners&&this.$listeners["hide"]&&(this.options.onHide=function(){var _this$$listeners$hide;return(_this$$listeners$hide=_this.$listeners["hide"]).fns.apply(_this$$listeners$hide,arguments)}),!this.options.onMount&&this.$listeners&&this.$listeners["mount"]&&(this.options.onMount=function(){var _this$$listeners$moun;return(_this$$listeners$moun=_this.$listeners["mount"]).fns.apply(_this$$listeners$moun,arguments)}),this.options.triggerTarget=this.triggerTarget,this.options}}};function normalizeComponent$8(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier
/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);// Vue.extend constructor export interop.
var hook,options="function"===typeof script?script.options:script;// render functions
if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,// functional template
isFunctionalTemplate&&(options.functional=!0)),// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),// inject component styles
style&&style.call(this,createInjectorSSR(context)),// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(){style.call(this,createInjectorShadow(this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
var originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
var existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}var normalizeComponent_1$3=normalizeComponent$8,__vue_script__$2$4=script$2$4,__vue_render__$2$4=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c(_vm.tag,{tag:"component",attrs:{"data-tippy-component":""}},[_c(_vm.triggerTag||_vm.tag,{ref:"trigger",tag:"component",attrs:{"data-tippy-component-trigger":""}},[_vm._t("trigger")],2),_vm._v(" "),_c(_vm.contentTag||_vm.tag,{ref:"content",tag:"component"},[_vm._t("default")],2)],1)},__vue_staticRenderFns__$2$4=[];
/* script */__vue_render__$2$4._withStripped=!0;
/* style */
var __vue_inject_styles__$2$4=void 0,__vue_scope_id__$2$4=void 0,__vue_module_identifier__$2$4=void 0,__vue_is_functional_template__$2$4=!1,TippyComponent$3=normalizeComponent_1$3({render:__vue_render__$2$4,staticRenderFns:__vue_staticRenderFns__$2$4},__vue_inject_styles__$2$4,__vue_script__$2$4,__vue_scope_id__$2$4,__vue_is_functional_template__$2$4,__vue_module_identifier__$2$4,void 0,void 0),tippyDirective$3="tippy",plugin$5={install:function(Vue){var options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};function createTippy(el,binding,vnode){var handlers=vnode.data&&vnode.data.on||vnode.componentOptions&&vnode.componentOptions.listeners;el.setAttribute("data-tippy-directive","");var opts=deriveOpts(binding),modifiers=Object.keys(binding.modifiers||{}),placement=modifiers.find((function(modifier){return"arrow"!==modifier})),withArrow=-1!==modifiers.findIndex((function(modifier){return"arrow"===modifier}));opts=Object.assign({},options,opts),placement&&(opts.placement=opts.placement||placement),withArrow&&(opts.arrow=void 0===opts.arrow||opts.arrow),handlers&&handlers["show"]&&(opts.onShow=function(){var _handlers$show;return(_handlers$show=handlers["show"]).fns.apply(_handlers$show,arguments)}),handlers&&handlers["shown"]&&(opts.onShown=function(){var _handlers$shown;(_handlers$shown=handlers["shown"]).fns.apply(_handlers$shown,arguments)}),handlers&&handlers["hidden"]&&(opts.onHidden=function(){var _handlers$hidden;(_handlers$hidden=handlers["hidden"]).fns.apply(_handlers$hidden,arguments)}),handlers&&handlers["hide"]&&(opts.onHide=function(){var _handlers$hide;return(_handlers$hide=handlers["hide"]).fns.apply(_handlers$hide,arguments)}),handlers&&handlers["mount"]&&(opts.onMount=function(){var _handlers$mount;(_handlers$mount=handlers["mount"]).fns.apply(_handlers$mount,arguments)}),el.getAttribute("title")&&!opts.content&&(opts.content=el.getAttribute("title"),el.removeAttribute("title")),el.getAttribute("content")&&!opts.content&&(opts.content=el.getAttribute("content")),tippy$3(el,opts),opts.showOnLoad&&el._tippy.show(),Vue.nextTick((function(){handlers&&handlers["init"]&&handlers["init"].fns(el._tippy,el)}))}function deriveOpts(binding){return"string"===typeof binding.value?{content:binding.value}:binding.value||{}}tippyDirective$3=options.directive||"tippy",tippy$3.setDefaults(options||{}),Vue.directive(tippyDirective$3,{inserted:function(el,binding,vnode){Vue.nextTick((function(){createTippy(el,binding,vnode)}))},unbind:function(el){el._tippy&&el._tippy.destroy()},componentUpdated:function(el,binding,vnode){if(el._tippy){var opts=deriveOpts(binding);el.getAttribute("title")&&!opts.content&&(opts.content=el.getAttribute("title"),el.removeAttribute("title")),el.getAttribute("content")&&!opts.content&&(opts.content=el.getAttribute("content")),el._tippy.set(opts)}}})}};
/* scoped */
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;"undefined"!==typeof window&&window.Vue&&(window.Vue.use(plugin$5),window.Vue.component("tippy",TippyComponent$3));const rnds8=new Uint8Array(16);function rng(){
// lazy load so that environments that need to polyfill have a chance to do so
if(!getRandomValues&&(
// getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
getRandomValues="undefined"!==typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!getRandomValues))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return getRandomValues(rnds8)}
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */const byteToHex=[];for(let i=0;i<256;++i)byteToHex.push((i+256).toString(16).slice(1));function unsafeStringify(arr,offset=0){
// Note: Be careful editing this code!  It's been tuned for performance
// and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
return(byteToHex[arr[offset+0]]+byteToHex[arr[offset+1]]+byteToHex[arr[offset+2]]+byteToHex[arr[offset+3]]+"-"+byteToHex[arr[offset+4]]+byteToHex[arr[offset+5]]+"-"+byteToHex[arr[offset+6]]+byteToHex[arr[offset+7]]+"-"+byteToHex[arr[offset+8]]+byteToHex[arr[offset+9]]+"-"+byteToHex[arr[offset+10]]+byteToHex[arr[offset+11]]+byteToHex[arr[offset+12]]+byteToHex[arr[offset+13]]+byteToHex[arr[offset+14]]+byteToHex[arr[offset+15]]).toLowerCase()}const randomUUID="undefined"!==typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto);var forms_native={randomUUID:randomUUID};function v4(options,buf,offset){if(forms_native.randomUUID&&!buf&&!options)return forms_native.randomUUID();options=options||{};const rnds=options.random||(options.rng||rng)();// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
// Copy bytes to buffer, if provided
if(rnds[6]=15&rnds[6]|64,rnds[8]=63&rnds[8]|128,buf){offset=offset||0;for(let i=0;i<16;++i)buf[offset+i]=rnds[i];return buf}return unsafeStringify(rnds)}function _arrayLikeToArray$1(arr,len){(null==len||len>arr.length)&&(len=arr.length);for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2}function _arrayWithoutHoles$1(arr){if(Array.isArray(arr))return _arrayLikeToArray$1(arr)}function _iterableToArray$1(iter){if("undefined"!==typeof Symbol&&null!=iter[Symbol.iterator]||null!=iter["@@iterator"])return Array.from(iter)}function _unsupportedIterableToArray$1(o,minLen){if(o){if("string"===typeof o)return _arrayLikeToArray$1(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);return"Object"===n&&o.constructor&&(n=o.constructor.name),"Map"===n||"Set"===n?Array.from(o):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?_arrayLikeToArray$1(o,minLen):void 0}}function _nonIterableSpread$1(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _toConsumableArray$1(arr){return _arrayWithoutHoles$1(arr)||_iterableToArray$1(arr)||_unsupportedIterableToArray$1(arr)||_nonIterableSpread$1()}function _defineProperty$2(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function ownKeys$4(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread2$1(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$4(Object(source),!0).forEach((function(key){_defineProperty$2(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$4(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}function _typeof$3(obj){return _typeof$3="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof$3(obj)}function _regeneratorRuntime(){
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
_regeneratorRuntime=function(){return exports};var exports={},Op=Object.prototype,hasOwn=Op.hasOwnProperty,$Symbol="function"==typeof Symbol?Symbol:{},iteratorSymbol=$Symbol.iterator||"@@iterator",asyncIteratorSymbol=$Symbol.asyncIterator||"@@asyncIterator",toStringTagSymbol=$Symbol.toStringTag||"@@toStringTag";function define(obj,key,value){return Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}),obj[key]}try{define({},"")}catch(err){define=function(obj,key,value){return obj[key]=value}}function wrap(innerFn,outerFn,self,tryLocsList){var protoGenerator=outerFn&&outerFn.prototype instanceof Generator?outerFn:Generator,generator=Object.create(protoGenerator.prototype),context=new Context(tryLocsList||[]);return generator._invoke=function(innerFn,self,context){var state="suspendedStart";return function(method,arg){if("executing"===state)throw new Error("Generator is already running");if("completed"===state){if("throw"===method)throw arg;return doneResult()}for(context.method=method,context.arg=arg;;){var delegate=context.delegate;if(delegate){var delegateResult=maybeInvokeDelegate(delegate,context);if(delegateResult){if(delegateResult===ContinueSentinel)continue;return delegateResult}}if("next"===context.method)context.sent=context._sent=context.arg;else if("throw"===context.method){if("suspendedStart"===state)throw state="completed",context.arg;context.dispatchException(context.arg)}else"return"===context.method&&context.abrupt("return",context.arg);state="executing";var record=tryCatch(innerFn,self,context);if("normal"===record.type){if(state=context.done?"completed":"suspendedYield",record.arg===ContinueSentinel)continue;return{value:record.arg,done:context.done}}"throw"===record.type&&(state="completed",context.method="throw",context.arg=record.arg)}}}(innerFn,self,context),generator}function tryCatch(fn,obj,arg){try{return{type:"normal",arg:fn.call(obj,arg)}}catch(err){return{type:"throw",arg:err}}}exports.wrap=wrap;var ContinueSentinel={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var IteratorPrototype={};define(IteratorPrototype,iteratorSymbol,(function(){return this}));var getProto=Object.getPrototypeOf,NativeIteratorPrototype=getProto&&getProto(getProto(values([])));NativeIteratorPrototype&&NativeIteratorPrototype!==Op&&hasOwn.call(NativeIteratorPrototype,iteratorSymbol)&&(IteratorPrototype=NativeIteratorPrototype);var Gp=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(IteratorPrototype);function defineIteratorMethods(prototype){["next","throw","return"].forEach((function(method){define(prototype,method,(function(arg){return this._invoke(method,arg)}))}))}function AsyncIterator(generator,PromiseImpl){function invoke(method,arg,resolve,reject){var record=tryCatch(generator[method],generator,arg);if("throw"!==record.type){var result=record.arg,value=result.value;return value&&"object"==_typeof$3(value)&&hasOwn.call(value,"__await")?PromiseImpl.resolve(value.__await).then((function(value){invoke("next",value,resolve,reject)}),(function(err){invoke("throw",err,resolve,reject)})):PromiseImpl.resolve(value).then((function(unwrapped){result.value=unwrapped,resolve(result)}),(function(error){return invoke("throw",error,resolve,reject)}))}reject(record.arg)}var previousPromise;this._invoke=function(method,arg){function callInvokeWithMethodAndArg(){return new PromiseImpl((function(resolve,reject){invoke(method,arg,resolve,reject)}))}return previousPromise=previousPromise?previousPromise.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}}function maybeInvokeDelegate(delegate,context){var method=delegate.iterator[context.method];if(void 0===method){if(context.delegate=null,"throw"===context.method){if(delegate.iterator["return"]&&(context.method="return",context.arg=void 0,maybeInvokeDelegate(delegate,context),"throw"===context.method))return ContinueSentinel;context.method="throw",context.arg=new TypeError("The iterator does not provide a 'throw' method")}return ContinueSentinel}var record=tryCatch(method,delegate.iterator,context.arg);if("throw"===record.type)return context.method="throw",context.arg=record.arg,context.delegate=null,ContinueSentinel;var info=record.arg;return info?info.done?(context[delegate.resultName]=info.value,context.next=delegate.nextLoc,"return"!==context.method&&(context.method="next",context.arg=void 0),context.delegate=null,ContinueSentinel):info:(context.method="throw",context.arg=new TypeError("iterator result is not an object"),context.delegate=null,ContinueSentinel)}function pushTryEntry(locs){var entry={tryLoc:locs[0]};1 in locs&&(entry.catchLoc=locs[1]),2 in locs&&(entry.finallyLoc=locs[2],entry.afterLoc=locs[3]),this.tryEntries.push(entry)}function resetTryEntry(entry){var record=entry.completion||{};record.type="normal",delete record.arg,entry.completion=record}function Context(tryLocsList){this.tryEntries=[{tryLoc:"root"}],tryLocsList.forEach(pushTryEntry,this),this.reset(!0)}function values(iterable){if(iterable){var iteratorMethod=iterable[iteratorSymbol];if(iteratorMethod)return iteratorMethod.call(iterable);if("function"==typeof iterable.next)return iterable;if(!isNaN(iterable.length)){var i=-1,next=function next(){for(;++i<iterable.length;)if(hasOwn.call(iterable,i))return next.value=iterable[i],next.done=!1,next;return next.value=void 0,next.done=!0,next};return next.next=next}}return{next:doneResult}}function doneResult(){return{value:void 0,done:!0}}return GeneratorFunction.prototype=GeneratorFunctionPrototype,define(Gp,"constructor",GeneratorFunctionPrototype),define(GeneratorFunctionPrototype,"constructor",GeneratorFunction),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,toStringTagSymbol,"GeneratorFunction"),exports.isGeneratorFunction=function(genFun){var ctor="function"==typeof genFun&&genFun.constructor;return!!ctor&&(ctor===GeneratorFunction||"GeneratorFunction"===(ctor.displayName||ctor.name))},exports.mark=function(genFun){return Object.setPrototypeOf?Object.setPrototypeOf(genFun,GeneratorFunctionPrototype):(genFun.__proto__=GeneratorFunctionPrototype,define(genFun,toStringTagSymbol,"GeneratorFunction")),genFun.prototype=Object.create(Gp),genFun},exports.awrap=function(arg){return{__await:arg}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,asyncIteratorSymbol,(function(){return this})),exports.AsyncIterator=AsyncIterator,exports.async=function(innerFn,outerFn,self,tryLocsList,PromiseImpl){void 0===PromiseImpl&&(PromiseImpl=Promise);var iter=new AsyncIterator(wrap(innerFn,outerFn,self,tryLocsList),PromiseImpl);return exports.isGeneratorFunction(outerFn)?iter:iter.next().then((function(result){return result.done?result.value:iter.next()}))},defineIteratorMethods(Gp),define(Gp,toStringTagSymbol,"Generator"),define(Gp,iteratorSymbol,(function(){return this})),define(Gp,"toString",(function(){return"[object Generator]"})),exports.keys=function(object){var keys=[];for(var key in object)keys.push(key);return keys.reverse(),function next(){for(;keys.length;){var key=keys.pop();if(key in object)return next.value=key,next.done=!1,next}return next.done=!0,next}},exports.values=values,Context.prototype={constructor:Context,reset:function(skipTempReset){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(resetTryEntry),!skipTempReset)for(var name in this)"t"===name.charAt(0)&&hasOwn.call(this,name)&&!isNaN(+name.slice(1))&&(this[name]=void 0)},stop:function(){this.done=!0;var rootRecord=this.tryEntries[0].completion;if("throw"===rootRecord.type)throw rootRecord.arg;return this.rval},dispatchException:function(exception){if(this.done)throw exception;var context=this;function handle(loc,caught){return record.type="throw",record.arg=exception,context.next=loc,caught&&(context.method="next",context.arg=void 0),!!caught}for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i],record=entry.completion;if("root"===entry.tryLoc)return handle("end");if(entry.tryLoc<=this.prev){var hasCatch=hasOwn.call(entry,"catchLoc"),hasFinally=hasOwn.call(entry,"finallyLoc");if(hasCatch&&hasFinally){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0);if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc)}else if(hasCatch){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0)}else{if(!hasFinally)throw new Error("try statement without catch or finally");if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc)}}}},abrupt:function(type,arg){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc<=this.prev&&hasOwn.call(entry,"finallyLoc")&&this.prev<entry.finallyLoc){var finallyEntry=entry;break}}finallyEntry&&("break"===type||"continue"===type)&&finallyEntry.tryLoc<=arg&&arg<=finallyEntry.finallyLoc&&(finallyEntry=null);var record=finallyEntry?finallyEntry.completion:{};return record.type=type,record.arg=arg,finallyEntry?(this.method="next",this.next=finallyEntry.finallyLoc,ContinueSentinel):this.complete(record)},complete:function(record,afterLoc){if("throw"===record.type)throw record.arg;return"break"===record.type||"continue"===record.type?this.next=record.arg:"return"===record.type?(this.rval=this.arg=record.arg,this.method="return",this.next="end"):"normal"===record.type&&afterLoc&&(this.next=afterLoc),ContinueSentinel},finish:function(finallyLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.finallyLoc===finallyLoc)return this.complete(entry.completion,entry.afterLoc),resetTryEntry(entry),ContinueSentinel}},catch:function(tryLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc===tryLoc){var record=entry.completion;if("throw"===record.type){var thrown=record.arg;resetTryEntry(entry)}return thrown}}throw new Error("illegal catch attempt")},delegateYield:function(iterable,resultName,nextLoc){return this.delegate={iterator:values(iterable),resultName:resultName,nextLoc:nextLoc},"next"===this.method&&(this.arg=void 0),ContinueSentinel}},exports}function asyncGeneratorStep(gen,resolve,reject,_next,_throw,key,arg){try{var info=gen[key](arg),value=info.value}catch(error){return void reject(error)}info.done?resolve(value):Promise.resolve(value).then(_next,_throw)}function _asyncToGenerator(fn){return function(){var self=this,args=arguments;return new Promise((function(resolve,reject){var gen=fn.apply(self,args);function _next(value){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"next",value)}function _throw(err){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"throw",err)}_next(void 0)}))}}function _arrayWithHoles(arr){if(Array.isArray(arr))return arr}function _iterableToArrayLimit(arr,i){var _i=null==arr?null:"undefined"!==typeof Symbol&&arr[Symbol.iterator]||arr["@@iterator"];if(null!=_i){var _s,_e,_arr=[],_n=!0,_d=!1;try{for(_i=_i.call(arr);!(_n=(_s=_i.next()).done);_n=!0)if(_arr.push(_s.value),i&&_arr.length===i)break}catch(err){_d=!0,_e=err}finally{try{_n||null==_i["return"]||_i["return"]()}finally{if(_d)throw _e}}return _arr}}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_unsupportedIterableToArray$1(arr,i)||_nonIterableRest()}var isLookupTypeField=function(field){var _ref=field||{},displayType=_ref.displayType;return["LOOKUP_SIMPLE","MULTI_LOOKUP_SIMPLE"].includes(displayType)},isLookupPopupField=function(field){var _ref2=field||{},displayType=_ref2.displayType;return["LOOKUP_POPUP"].includes(displayType)},isLookupField=function(field){var _ref5=field||{},displayType=_ref5.displayType;return["LOOKUP_SIMPLE"].includes(displayType)},isMultiLookupField=function(field){var _ref6=field||{},displayType=_ref6.displayType;return["MULTI_LOOKUP_SIMPLE"].includes(displayType)},isDateTypeField=function(field){var _ref7=field||{},displayType=_ref7.displayType;return["DATETIME","DATE"].includes(displayType)},FIELD_VALUE_HASH$1={lookup:function(_ref){var _this=this,field=_ref.field,h=this.$createElement;return h("div",{class:"w-full"},[h(__vue_component__$n,{class:"width-full",key:"".concat(field.name," Value"),attrs:{field:field,hideLookupIcon:this.canHidePopupIcon,hideDropDown:this.hideDropDown,disabled:this.disableValueContainer,customOptions:this.getCustomOption()},on:_objectSpread2$1(_objectSpread2$1({},{input:function(val){return _this.$set(_this,"fieldValue",isEmpty$a(val)?null:val)}}),{},{showLookupWizard:this.showLookupWizard}),model:{value:_this.fieldValue,callback:function($$v){_this.fieldValue=$$v}}}),this.canShowLookupWizard&&h(__vue_component__$6$3,{attrs:{canShowLookupWizard:this.canShowLookupWizard,field:field},on:_objectSpread2$1({},{"update:canShowLookupWizard":function(val){return _this.canShowLookupWizard=val},setLookupFieldValue:this.setLookupFieldValue})})])},select:function(_ref2){var _this2=this,field=_ref2.field,isMultiple=_ref2.isMultiple,h=this.$createElement;return h(__vue_component__$m,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:isMultiple,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:field.options},model:{value:_this2.fieldValue,callback:function($$v){_this2.fieldValue=$$v}}})},input:function(){var _this3=this,_ref3=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},_ref3$type=_ref3.type,type=void 0===_ref3$type?"":_ref3$type,h=this.$createElement;return h(__vue_component__$p,{class:"w-full",attrs:{placeholder:"Enter a value",type:type,disabled:this.disableValueContainer},model:{value:_this3.fieldValue,callback:function($$v){_this3.fieldValue=$$v}}})},date:function(_ref4){var _this4=this,type=_ref4.type,hasTime=_ref4.hasTime,h=this.$createElement;return h(__vue_component__$5$3,{class:"w-full",attrs:{type:type,disabled:this.disableValueContainer,placeholder:"Select a date ".concat(hasTime?"time":""),account:this.account},model:{value:_this4.fieldValue,callback:function($$v){_this4.fieldValue=$$v}}})}},FIELD_DISPLAY_TYPE_HASH={NUMBER:function(){return this["input"]({type:"number"})},DECIMAL:function(){return this["input"]({type:"number"})},SELECTBOX:function(field){return this["select"]({field:field,isMultiple:!0})},MULTI_SELECTBOX:function(field){return this["select"]({field:field,isMultiple:!0})},DECISION_BOX:function(field){return this["select"]({field:field,isMultiple:!1})},DATE:function(){return this["date"]({type:"date"})},DATETIME:function(){return this["date"]({type:"datetime",hasTime:!0})},DURATION:function(){return this["input"]({type:"number"})},LOOKUP_SIMPLE:function(field){return this["lookup"]({field:field})},MULTI_LOOKUP_SIMPLE:function(field){return this["lookup"]({field:field})},LOOKUP_POPUP:function(field){return this["lookup"]({field:field})},DEFAULT:function(){return this["input"]()}},WEEK_DAYS_OPTIONS=[{label:"Monday",value:1},{label:"Tuesday",value:2},{label:"Wednesday",value:3},{label:"Thursday",value:4},{label:"Friday",value:5},{label:"Saturday",value:6},{label:"Sunday",value:7}],MONTH_OPTIONS=[{label:"January",value:1},{label:"February",value:2},{label:"March",value:3},{label:"April",value:4},{label:"May",value:5},{label:"June",value:6},{label:"July",value:7},{label:"August",value:8},{label:"September",value:9},{label:"October",value:10},{label:"November",value:11},{label:"December",value:12}],dateTimeOperator={84:"Month",85:"Day of Week",101:"Day of Month",102:"Day of Year",103:"Hours of Day",106:"Before N Days",107:"After N Days",108:"Week of Year"},WEEK_DAYS={1:"Monday",2:"Tuesday",3:"Wednesday",4:"Thursday",5:"Friday",6:"Saturday",7:"Sunday"},MONTHS=[{label:"January",value:1},{label:"February",value:2},{label:"March",value:3},{label:"April",value:4},{label:"May",value:5},{label:"June",value:6},{label:"July",value:7},{label:"August",value:8},{label:"September",value:9},{label:"October",value:10},{label:"November",value:11},{label:"December",value:12}],ordinalSuffixOf=function(day){var j=day%10,k=day%100;return"".concat(day,1==j&&11!=k?"st":2==j&&12!=k?"nd":3==j&&13!=k?"rd":"th")},SPECIAL_VALUE_HASH={SPECIAL_20:function(field){var _this=this,h=this.$createElement,_ref=field||{},_ref$displayType=_ref.displayType,displayType=void 0===_ref$displayType?"":_ref$displayType,hasTime="DATETIME"===displayType,type=displayType.toLowerCase();return h(__vue_component__$5$3,{class:"w-full",attrs:{type:"".concat(type,"range"),disabled:this.disableValueContainer,placeholder:"Select a date ".concat(hasTime?"time":""),account:this.account},model:{value:_this.fieldValue,callback:function($$v){_this.fieldValue=$$v}}})},SPECIAL_81:function(){var h=this.$createElement;
// Number - between
return h("div",{class:"flex w-full"},[h(__vue_component__$p,{class:"flex flex-grow pr-1",attrs:{type:"number",placeholder:"Enter start value"}}),h(__vue_component__$p,{class:"flex flex-grow pl-1",attrs:{type:"number",placeholder:"Enter end value"}})])},SPECIAL_84:function(field){var _this2=this,h=this.$createElement;
// Month
return h(__vue_component__$m,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:MONTH_OPTIONS},model:{value:_this2.fieldValue,callback:function($$v){_this2.fieldValue=$$v}}})},SPECIAL_85:function(field){var _this3=this,h=this.$createElement;
// Date - day of week
return h(__vue_component__$m,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:WEEK_DAYS_OPTIONS},model:{value:_this3.fieldValue,callback:function($$v){_this3.fieldValue=$$v}}})},SPECIAL_101:function(field){var _this4=this,h=this.$createElement,options=Array(30).fill().map((function(_,index){return{label:"".concat(ordinalSuffixOf(index+1)," day"),value:index+1}}));return h(__vue_component__$m,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:options},model:{value:_this4.fieldValue,callback:function($$v){_this4.fieldValue=$$v}}})},SPECIAL_103:function(field){var _this5=this,h=this.$createElement,options=Array(24).fill().map((function(_,index){return{label:"".concat(index+1," hour").concat(index>0?"s":""),value:index+1}}));return h(__vue_component__$m,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:options},model:{value:_this5.fieldValue,callback:function($$v){_this5.fieldValue=$$v}}})},SPECIAL_106:function(){var _this6=this,h=this.$createElement;
// Date - n days
return h(__vue_component__$p,{class:"flex flex-grow pr-1 w-full",attrs:{type:"number",placeholder:"Enter number of days"},model:{value:_this6.fieldValue,callback:function($$v){_this6.fieldValue=$$v}}})},SPECIAL_108:function(field){var _this7=this,h=this.$createElement,options=Array(52).fill().map((function(_,index){return{label:"".concat(index+1," week").concat(index>0?"s":""),value:index+1}}));return h(__vue_component__$m,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:options},model:{value:_this7.fieldValue,callback:function($$v){_this7.fieldValue=$$v}}})}},SPECIAL_OPERATOR_HASH={DATETIME_20:function(field){return this["SPECIAL_20"](field)},DATETIME_84:function(field){return this["SPECIAL_84"](field)},DATETIME_85:function(field){return this["SPECIAL_85"](field)},DATETIME_101:function(field){return this["SPECIAL_101"](field)},DATETIME_103:function(field){return this["SPECIAL_103"](field)},DATETIME_106:function(field){return this["SPECIAL_106"](field)},DATETIME_107:function(field){return this["SPECIAL_106"](field)},DATETIME_108:function(field){return this["SPECIAL_108"](field)},DATE_20:function(field){return this["SPECIAL_20"](field)},DATE_84:function(field){return this["SPECIAL_84"](field)},DATE_85:function(field){return this["SPECIAL_85"](field)},DATE_101:function(field){return this["SPECIAL_101"](field)},DATE_103:function(field){return this["SPECIAL_103"](field)},DATE_106:function(field){return this["SPECIAL_106"](field)},DATE_107:function(field){return this["SPECIAL_106"](field)},DATE_108:function(field){return this["SPECIAL_108"](field)},NUMBER_81:function(){return this["SPECIAL_81"]()},NUMBER_82:function(){return this["SPECIAL_81"]()}},LOOKUP_FIELD_PLACEHOLDER_MAP={people:{value:"${LOGGED_PEOPLE}",label:"Current User"},users:{value:"${LOGGED_USER}",label:"Current User"}},SPECIAL_KEY=["DATETIME_20","DATETIME_84","DATETIME_85","DATETIME_101","DATETIME_103","DATETIME_108","DATE_20","DATE_84","DATE_85","DATE_101","DATE_103","DATE_108"],script$a$1={name:"ConditionValue",props:["field","disableValueContainer","account","isSpecialOperator","operatorObj"],data:function(){return{canShowLookupWizard:!1}},computed:{fieldValue:{get:function(){var _ref=this||{},$attrs=_ref.$attrs,field=_ref.field,operatorObj=_ref.operatorObj,_ref2=$attrs||{},value=_ref2.value,_ref3=operatorObj||{},operatorId=_ref3.operatorId,_ref4=field||{},displayType=_ref4.displayType,specialKey="".concat(displayType,"_").concat(operatorId);return SPECIAL_KEY.includes(specialKey)&&!isEmpty$a(value)?this.serializeDateValues(value):value},set:function(value){this.$emit("input",value)}},
// lookup properties
canHidePopupIcon:function(){var field=this.field,_ref5=field||{},lookupModule=_ref5.lookupModule,_ref6=lookupModule||{},_ref6$showPopup=_ref6.showPopup,showPopup=void 0===_ref6$showPopup||_ref6$showPopup;return!showPopup},hideDropDown:function(){
// Have to hide dropdown for resource type fields
var field=this.field,name=field.name;return"resource"===name}},methods:_objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({serializeDateValues:function(value){var dateArray=String(value).split(","),dates=dateArray.map((function(date){return parseInt(date)}));return dates},getFieldValueDisplay:function(){var field=this.field,isSpecialOperator=this.isSpecialOperator,operatorObj=this.operatorObj,fieldObj=field.field||field,_ref7=fieldObj||{},displayType=_ref7.displayType,_ref8=operatorObj||{},operatorId=_ref8.operatorId,specialHashKey="".concat(displayType,"_").concat(operatorId);return isSpecialOperator&&!isEmpty$a(SPECIAL_OPERATOR_HASH[specialHashKey])?this[specialHashKey](field):isEmpty$a(FIELD_DISPLAY_TYPE_HASH[displayType])?this["DEFAULT"](field):this[displayType](field)},getCustomOption:function(){var _ref9=this||{},field=_ref9.field,_ref10=field||{},lookupModule=_ref10.lookupModule;if(isEmpty$a(lookupModule))return[];var _ref11=lookupModule||{},name=_ref11.name;return isEmpty$a(LOOKUP_FIELD_PLACEHOLDER_MAP[name])?[]:[LOOKUP_FIELD_PLACEHOLDER_MAP[name]]},resetValue:function(){this.$set(this,"fieldValue",null)},
// lookup methods
showLookupWizard:function(){this.canShowLookupWizard=!0},setLookupFieldValue:function(props){var selectedLookupField=this.field,field=props.field;isEmpty$a(selectedLookupField)&&(this.selectedLookupField=field);var _ref12=field||{},selectedItems=_ref12.selectedItems,_ref12$options=_ref12.options,options=void 0===_ref12$options?[]:_ref12$options,multiple=_ref12.multiple,selectedItemIds=[];if(!isEmpty$a(selectedItems))if(selectedItemIds=selectedItems.map((function(item){return item.value})),isEmpty$a(options))options=_toConsumableArray$1(selectedItems);else{var _options,ids=options.map((function(item){return item.value})),newOptions=selectedItems.filter((function(item){return!ids.includes(item.value)}));(_options=options).unshift.apply(_options,_toConsumableArray$1(newOptions))}this.$set(this.field,"options",options),this.fieldValue=multiple?selectedItemIds:selectedItemIds[0]}},FIELD_VALUE_HASH$1),FIELD_DISPLAY_TYPE_HASH),SPECIAL_OPERATOR_HASH),SPECIAL_VALUE_HASH),render:function(){var h=arguments[0];return h("div",{class:"criteria-value-container ml-2 w-full flex items-center"},[this.getFieldValueDisplay()])}};function normalizeComponent$3(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);
// Vue.extend constructor export interop.
const options="function"===typeof script?script.options:script;
// render functions
let hook;if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,
// functional template
isFunctionalTemplate&&(options.functional=!0)),
// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),
// inject component styles
style&&style.call(this,createInjectorSSR(context)),
// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},
// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(context){style.call(this,createInjectorShadow(context,this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
const originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
const existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}
/* script */const __vue_script__$a$1=script$a$1,__vue_inject_styles__$a$1=void 0,__vue_scope_id__$a$1=void 0,__vue_module_identifier__$a$1=void 0,__vue_is_functional_template__$a$1=void 0,__vue_component__$a$1=normalizeComponent$3({},__vue_inject_styles__$a$1,__vue_script__$a$1,__vue_scope_id__$a$1,__vue_is_functional_template__$a$1,__vue_module_identifier__$a$1,!1,void 0,void 0,void 0),isOldIE="undefined"!==typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
/* template */
/* style */function createInjector(context){return(id,style)=>addStyle(id,style)}let HEAD;const styles={};function addStyle(id,css){const group=isOldIE?css.media||"default":id,style=styles[group]||(styles[group]={ids:new Set,styles:[]});if(!style.ids.has(id)){style.ids.add(id);let code=css.source;if(css.map&&(
// https://developer.chrome.com/devtools/docs/javascript-debugging
// this makes source maps inside style tags work properly in Chrome
code+="\n/*# sourceURL="+css.map.sources[0]+" */",
// http://stackoverflow.com/a/26603875
code+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(css.map))))+" */"),style.element||(style.element=document.createElement("style"),style.element.type="text/css",css.media&&style.element.setAttribute("media",css.media),void 0===HEAD&&(HEAD=document.head||document.getElementsByTagName("head")[0]),HEAD.appendChild(style.element)),"styleSheet"in style.element)style.styles.push(code),style.element.styleSheet.cssText=style.styles.filter(Boolean).join("\n");else{const index=style.ids.size-1,textNode=document.createTextNode(code),nodes=style.element.childNodes;nodes[index]&&style.element.removeChild(nodes[index]),nodes.length?style.element.insertBefore(textNode,nodes[index]):style.element.appendChild(textNode)}}}function styleInject$1(css,ref){void 0===ref&&(ref={});var insertAt=ref.insertAt;if(css&&"undefined"!==typeof document){var head=document.head||document.getElementsByTagName("head")[0],style=document.createElement("style");style.type="text/css","top"===insertAt&&head.firstChild?head.insertBefore(style,head.firstChild):head.appendChild(style),style.styleSheet?style.styleSheet.cssText=css:style.appendChild(document.createTextNode(css))}}var css_248z$1="*, ::before, ::after {\n  --tw-border-opacity: 1;\n  border-color: rgba(229, 231, 235, var(--tw-border-opacity))\n}\n\n.container {\n  width: 100%\n}\n\n@media (min-width: 640px) {\n  .container {\n    max-width: 640px\n  }\n}\n\n@media (min-width: 768px) {\n  .container {\n    max-width: 768px\n  }\n}\n\n@media (min-width: 1024px) {\n  .container {\n    max-width: 1024px\n  }\n}\n\n@media (min-width: 1280px) {\n  .container {\n    max-width: 1280px\n  }\n}\n\n@media (min-width: 1536px) {\n  .container {\n    max-width: 1536px\n  }\n}\n\n.relative {\n  position: relative\n}\n\n.m-2 {\n  margin: 0.5rem\n}\n\n.mt-0 {\n  margin-top: 0px\n}\n\n.mt-5 {\n  margin-top: 1.25rem\n}\n\n.mt-0\\.5 {\n  margin-top: 0.125rem\n}\n\n.mr-2 {\n  margin-right: 0.5rem\n}\n\n.mb-2 {\n  margin-bottom: 0.5rem\n}\n\n.ml-1 {\n  margin-left: 0.25rem\n}\n\n.ml-2 {\n  margin-left: 0.5rem\n}\n\n.ml-3 {\n  margin-left: 0.75rem\n}\n\n.flex {\n  display: flex\n}\n\n.table {\n  display: table\n}\n\n.h-14 {\n  height: 3.5rem\n}\n\n.w-full {\n  width: 100%\n}\n\n.flex-grow {\n  flex-grow: 1\n}\n\n.transform {\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  transform: translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))\n}\n\n@-webkit-keyframes spin {\n  to {\n    transform: rotate(360deg)\n  }\n}\n\n@keyframes spin {\n  to {\n    transform: rotate(360deg)\n  }\n}\n\n@-webkit-keyframes ping {\n  75%, 100% {\n    transform: scale(2);\n    opacity: 0\n  }\n}\n\n@keyframes ping {\n  75%, 100% {\n    transform: scale(2);\n    opacity: 0\n  }\n}\n\n@-webkit-keyframes pulse {\n  50% {\n    opacity: .5\n  }\n}\n\n@keyframes pulse {\n  50% {\n    opacity: .5\n  }\n}\n\n@-webkit-keyframes bounce {\n  0%, 100% {\n    transform: translateY(-25%);\n    -webkit-animation-timing-function: cubic-bezier(0.8,0,1,1);\n            animation-timing-function: cubic-bezier(0.8,0,1,1)\n  }\n\n  50% {\n    transform: none;\n    -webkit-animation-timing-function: cubic-bezier(0,0,0.2,1);\n            animation-timing-function: cubic-bezier(0,0,0.2,1)\n  }\n}\n\n@keyframes bounce {\n  0%, 100% {\n    transform: translateY(-25%);\n    -webkit-animation-timing-function: cubic-bezier(0.8,0,1,1);\n            animation-timing-function: cubic-bezier(0.8,0,1,1)\n  }\n\n  50% {\n    transform: none;\n    -webkit-animation-timing-function: cubic-bezier(0,0,0.2,1);\n            animation-timing-function: cubic-bezier(0,0,0.2,1)\n  }\n}\n\n.cursor-pointer {\n  cursor: pointer\n}\n\n.cursor-not-allowed {\n  cursor: not-allowed\n}\n\n.flex-col {\n  flex-direction: column\n}\n\n.flex-wrap {\n  flex-wrap: wrap\n}\n\n.flex-nowrap {\n  flex-wrap: nowrap\n}\n\n.items-center {\n  align-items: center\n}\n\n.justify-center {\n  justify-content: center\n}\n\n.self-center {\n  align-self: center\n}\n\n.border {\n  border-width: 1px\n}\n\n.text-center {\n  text-align: center\n}\n\n.leading-5 {\n  line-height: 1.25rem\n}\n\n*, ::before, ::after {\n  --tw-shadow: 0 0 #0000\n}\n\n*, ::before, ::after {\n  --tw-ring-inset: var(--tw-empty,/*!*/ /*!*/);\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgba(59, 130, 246, 0.5);\n  --tw-ring-offset-shadow: 0 0 #0000;\n  --tw-ring-shadow: 0 0 #0000\n}\n\n.filter {\n  --tw-blur: var(--tw-empty,/*!*/ /*!*/);\n  --tw-brightness: var(--tw-empty,/*!*/ /*!*/);\n  --tw-contrast: var(--tw-empty,/*!*/ /*!*/);\n  --tw-grayscale: var(--tw-empty,/*!*/ /*!*/);\n  --tw-hue-rotate: var(--tw-empty,/*!*/ /*!*/);\n  --tw-invert: var(--tw-empty,/*!*/ /*!*/);\n  --tw-saturate: var(--tw-empty,/*!*/ /*!*/);\n  --tw-sepia: var(--tw-empty,/*!*/ /*!*/);\n  --tw-drop-shadow: var(--tw-empty,/*!*/ /*!*/);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)\n}\n\n.transition {\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms\n}\n\n.ease-in-out {\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1)\n}\n\n@media (min-width: 640px) {\n}\n\n@media (min-width: 768px) {\n}\n\n@media (min-width: 1024px) {\n}\n\n@media (min-width: 1280px) {\n}\n\n@media (min-width: 1536px) {\n}\n";styleInject$1(css_248z$1);var script$3$1={props:["field","operators","value","account"],components:{Select:__vue_component__$m,ConditionValue:__vue_component__$a$1},computed:{conditionValue:{get:function(){var _this$value;return null===(_this$value=this.value)||void 0===_this$value?void 0:_this$value.value},set:function(newVal){var inputValue=this.value,updatedObj=_objectSpread2$1(_objectSpread2$1({},inputValue),{},{value:newVal});this.$emit("input",updatedObj),this.$emit("updateFilter",updatedObj)}},errorText:function(){var field=this.field,_ref=field||{},displayName=_ref.displayName;return"Please input ".concat(displayName)},disableValueContainer:function(){var operatorId=this.operatorId,fieldOperators=this.fieldOperators,disabled=this.disabled,canDisable=!0,selectedOperator=fieldOperators.find((function(operator){return operator.id===operatorId}));return isEmpty$a(selectedOperator)||(canDisable=!(selectedOperator||{}).valueNeeded),canDisable||disabled},currentOperatorObj:function(){var _ref2=this||{},fieldOperators=_ref2.fieldOperators,operatorId=_ref2.operatorId,currentOperator=fieldOperators.find((function(operator){return operator.id===operatorId}));return currentOperator},isSpecialOperator:function(){var _ref3=this||{},currentOperatorObj=_ref3.currentOperatorObj,_ref4=currentOperatorObj||{},specialOperator=_ref4.specialOperator;return specialOperator},fieldOperators:function(){var operators=this.operators,filterOperators=this.filterOperators,field=this.field,_ref5=field||{},dataType=_ref5.dataType,fieldOperators=_ref5.operators;if(!isEmpty$a(operators)){var list=operators[dataType]||[];isEmpty$a(fieldOperators)||(list=list.concat(fieldOperators));var finalList=list.map((function(operator){var operatorId=operator.operatorId,defaultValue=operator.defaultValue,unqiueClientId=operatorId;return isEmpty$a(defaultValue)||(unqiueClientId="".concat(operatorId,"-").concat(defaultValue)),_objectSpread2$1(_objectSpread2$1({},operator),{},{id:unqiueClientId})}));// filter out special operator if special ui is not present
return finalList=finalList.filter((function(operator){var _ref6=operator||{},specialOperator=_ref6.specialOperator,operatorId=_ref6.id,_ref7=field||{},displayType=_ref7.displayType,specialHashPropName="".concat(displayType,"_").concat(operatorId);return!specialOperator||!isEmpty$a(SPECIAL_OPERATOR_HASH[specialHashPropName])})),!isEmpty$a(filterOperators)&&isFunction$8(filterOperators)&&(finalList=(finalList||[]).filter((function(operator){return filterOperators(operator,field)}))),finalList}return[]}},watch:{
// if an operator is selected which does not need value, then value container is disabled
disableValueContainer:function(value){value&&(this.conditionValue=null)},operatorId:function(newVal){var value=this.value,updatedObj=_objectSpread2$1(_objectSpread2$1({},value),{},{operatorId:newVal});this.$emit("input",updatedObj),this.$emit("updateFilter",updatedObj)}},created:function(){this.init()},data:function(){return{operatorId:null}},methods:{init:function(){var value=this.value,fieldOperators=this.fieldOperators,operatorId=value.operatorId,conditionValue=value.value;// if the operator id is empty, then we need to set default operator
if(isEmpty$a(operatorId)){var defaultOperatorId=null;if(!isEmpty$a(fieldOperators)){var defaultOperator=fieldOperators.find((function(operator){return operator.defaultSelection}))||{};defaultOperatorId=defaultOperator.operatorId}this.operatorId=defaultOperatorId}else this.operatorId=operatorId;isEmpty$a(conditionValue)||(this.conditionValue=conditionValue);var clonedCondition=cloneDeep(value);this.filterObj=clonedCondition},resetValue:function(){var ref=this.$refs.conditionValue;isEmpty$a(ref)||ref.resetValue()},validate:function(){var disableValueContainer=this.disableValueContainer,conditionValue=this.conditionValue,field=this.field,isValid=!0;return disableValueContainer||(isValid=!isEmpty$a(conditionValue)),this.$emit("isError",{field:field,isError:!isValid}),isValid}}};
/* script */const __vue_script__$3$1=script$3$1;
/* template */var __vue_render__$3$1=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"operator-value-container"},[_c("div",{staticClass:"criteria-operator-container"},[_c("Select",{staticClass:"width-full",attrs:{options:_vm.fieldOperators,labelName:"displayName",valueName:"id",filterable:!0,disabled:!1},on:{clear:_vm.resetValue},model:{value:_vm.operatorId,callback:function($$v){_vm.operatorId=$$v},expression:"operatorId"}})],1),_vm._v(" "),_c("div",{staticClass:"value-container",staticStyle:{display:"flex","flex-direction":"column"}},[_c("ConditionValue",{ref:"conditionValue",attrs:{account:_vm.account,field:_vm.field,operatorObj:_vm.currentOperatorObj,isSpecialOperator:_vm.isSpecialOperator,disableValueContainer:_vm.disableValueContainer},model:{value:_vm.conditionValue,callback:function($$v){_vm.conditionValue=$$v},expression:"conditionValue"}}),_vm._v(" "),_vm.field.isError?_c("div",{staticClass:"err-txt"},[_vm._v(_vm._s(_vm.errorText))]):_vm._e()],1)])},__vue_staticRenderFns__$3$1=[];
/* style */
const __vue_inject_styles__$3$1=function(inject){inject&&inject("data-v-3d378bb7_0",{source:".operator-value-container[data-v-3d378bb7]{display:flex;flex-wrap:nowrap}.operator-value-container .criteria-operator-container[data-v-3d378bb7]{flex:0 0 35%}.operator-value-container .value-container[data-v-3d378bb7]{flex-grow:1}.operator-value-container .value-container .err-txt[data-v-3d378bb7]{color:#f56c6c;font-size:12px;line-height:1;margin-top:4px;padding-left:8px}",map:void 0,media:void 0})},__vue_scope_id__$3$1="data-v-3d378bb7",__vue_module_identifier__$3$1=void 0,__vue_is_functional_template__$3$1=!1,__vue_component__$3$1=normalizeComponent$3({render:__vue_render__$3$1,staticRenderFns:__vue_staticRenderFns__$3$1},__vue_inject_styles__$3$1,__vue_script__$3$1,__vue_scope_id__$3$1,__vue_is_functional_template__$3$1,__vue_module_identifier__$3$1,!1,createInjector,void 0,void 0);
/* scoped */
var script$2$1={name:"spinner",props:["show","size","colour"],computed:{spinnerSize:function(){return this.size?this.size+"px":"50px"},strokeColor:function(){return this.colour?this.colour:"#fd4b92"}}};
/* script */const __vue_script__$2$1=script$2$1;
/* template */var __vue_render__$2$1=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("transition",[_c("svg",{directives:[{name:"show",rawName:"v-show",value:_vm.show,expression:"show"}],staticClass:"spinner",class:{show:_vm.show},attrs:{width:_vm.spinnerSize,height:_vm.spinnerSize,viewBox:"0 0 44 44"}},[_c("circle",{staticClass:"path",style:{stroke:_vm.strokeColor},attrs:{fill:"none","stroke-width":"4","stroke-linecap":"round",cx:"22",cy:"22",r:"20"}})])])},__vue_staticRenderFns__$2$1=[];
/* style */
const __vue_inject_styles__$2$1=function(inject){inject&&inject("data-v-688b5254_0",{source:".spinner[data-v-688b5254]{transition:opacity 50ms ease;animation:rotator-data-v-688b5254 1.4s linear infinite;animation-play-state:paused}.spinner.show[data-v-688b5254]{animation-play-state:running}.spinner.v-enter[data-v-688b5254],.spinner.v-leave-active[data-v-688b5254]{opacity:0}.spinner.v-enter-active[data-v-688b5254],.spinner.v-leave[data-v-688b5254]{opacity:1}.spinner .path[data-v-688b5254]{stroke-dasharray:126;stroke-dashoffset:0;transform-origin:center;animation:dash-data-v-688b5254 1.4s ease-in-out infinite}@-moz-keyframes rotator-data-v-688b5254{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-webkit-keyframes rotator-data-v-688b5254{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-o-keyframes rotator-data-v-688b5254{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@keyframes rotator-data-v-688b5254{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-moz-keyframes dash-data-v-688b5254{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@-webkit-keyframes dash-data-v-688b5254{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@-o-keyframes dash-data-v-688b5254{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@keyframes dash-data-v-688b5254{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}",map:void 0,media:void 0})},__vue_scope_id__$2$1="data-v-688b5254",__vue_module_identifier__$2$1=void 0,__vue_is_functional_template__$2$1=!1,__vue_component__$2$1=normalizeComponent$3({render:__vue_render__$2$1,staticRenderFns:__vue_staticRenderFns__$2$1},__vue_inject_styles__$2$1,__vue_script__$2$1,__vue_scope_id__$2$1,__vue_is_functional_template__$2$1,__vue_module_identifier__$2$1,!1,createInjector,void 0,void 0);
/* scoped */var script$1$1={components:{Checkbox:element_ui_common.Checkbox,OperatorValues:__vue_component__$3$1,Input:element_ui_common.Input,Button:element_ui_common.Button,Spinner:__vue_component__$2$1},props:["moduleName","searchParam","onSave","hideQuery","filterList","showAdvWizard"],data:function(){return{operators:[],fields:[],account:null,searchFilter:{},searchtext:"",filterObj:{},searchableFields:[],filtersFields:[],loading:!1}},created:function(){var _this=this;return _asyncToGenerator(_regeneratorRuntime().mark((function _callee(){return _regeneratorRuntime().wrap((function(_context){while(1)switch(_context.prev=_context.next){case 0:return _context.next=2,_this.init();case 2:case"end":return _context.stop()}}),_callee)})))()},computed:{filteredFields:function(){var searchtext=this.searchtext,searchableFields=this.searchableFields;return isEmpty$a(searchtext)?searchableFields:searchableFields.filter((function(field){var displayName=field.displayName,lowerCasedText=searchtext.toLowerCase(),canShow=displayName.toLowerCase().includes(lowerCasedText);return canShow}))},appliedFilters:function(){var searchParam=this.searchParam,hideQuery=this.hideQuery,filterList=this.filterList;return hideQuery?filterList:isEmpty$a(searchParam)?null:JSON.parse(searchParam)}},watch:{moduleName:function(){this.init()},filterList:function(){this.constructFilters()},showAdvWizard:function(){this.constructFilters()}},methods:{init:function(){var _this2=this;return _asyncToGenerator(_regeneratorRuntime().mark((function _callee2(){var _yield$Promise$all,_yield$Promise$all2,fields,account,operators;return _regeneratorRuntime().wrap((function(_context2){while(1)switch(_context2.prev=_context2.next){case 0:return _this2.loading=!0,_context2.next=3,Promise.all([_this2.loadFields(),_this2.fetchAccount(),_this2.loadOperators()]);case 3:_yield$Promise$all=_context2.sent,_yield$Promise$all2=_slicedToArray(_yield$Promise$all,3),fields=_yield$Promise$all2[0],account=_yield$Promise$all2[1],operators=_yield$Promise$all2[2],_this2.fields=fields,_this2.account=account,_this2.operators=operators,_this2.constructFilters(),_this2.loading=!1;case 13:case"end":return _context2.stop()}}),_callee2)})))()},fetchAccount:function(){var _this3=this;return _asyncToGenerator(_regeneratorRuntime().mark((function _callee3(){var _yield$API$get,data,error,_ref,account;return _regeneratorRuntime().wrap((function(_context3){while(1)switch(_context3.prev=_context3.next){case 0:return _context3.next=2,api/* API */.bl.get("/v2/fetchAccount");case 2:if(_yield$API$get=_context3.sent,data=_yield$API$get.data,error=_yield$API$get.error,!error){_context3.next=9;break}_this3.$message.error(error||"Error Occured"),_context3.next=11;break;case 9:return _ref=data||{},account=_ref.account,_context3.abrupt("return",account);case 11:case"end":return _context3.stop()}}),_callee3)})))()},loadOperators:function(){var _this4=this;return _asyncToGenerator(_regeneratorRuntime().mark((function _callee4(){var url,_yield$API$get2,data,error,_ref2,_ref2$message,message,_ref3,operators;return _regeneratorRuntime().wrap((function(_context4){while(1)switch(_context4.prev=_context4.next){case 0:return url="v2/filter/advanced/operators",_context4.next=3,api/* API */.bl.get(url);case 3:if(_yield$API$get2=_context4.sent,data=_yield$API$get2.data,error=_yield$API$get2.error,!error){_context4.next=11;break}_ref2=error||{},_ref2$message=_ref2.message,message=void 0===_ref2$message?"Error Occured":_ref2$message,_this4.$message.error(message),_context4.next=14;break;case 11:if(_ref3=data||{},operators=_ref3.operators,isEmpty$a(operators)){_context4.next=14;break}return _context4.abrupt("return",operators);case 14:case"end":return _context4.stop()}}),_callee4)})))()},loadFields:function(){var _this5=this;return _asyncToGenerator(_regeneratorRuntime().mark((function _callee5(){var moduleName,url,_yield$API$get3,data,error,_ref4,_ref4$message,message,_ref5,fields;return _regeneratorRuntime().wrap((function(_context5){while(1)switch(_context5.prev=_context5.next){case 0:return moduleName=_this5.moduleName,url="/v2/filter/advanced/fields/".concat(moduleName),_context5.next=4,api/* API */.bl.get(url);case 4:if(_yield$API$get3=_context5.sent,data=_yield$API$get3.data,error=_yield$API$get3.error,!error){_context5.next=12;break}_ref4=error||{},_ref4$message=_ref4.message,message=void 0===_ref4$message?"Error occured":_ref4$message,_this5.$message.error(message),_context5.next=14;break;case 12:return _ref5=data||{},fields=_ref5.fields,_context5.abrupt("return",fields.map((function(field){return isLookupPopupField(field)||isLookupTypeField(field)?_objectSpread2$1(_objectSpread2$1({},field),{},{multiple:!0,canShowCriteria:!1}):field})));case 14:case"end":return _context5.stop()}}),_callee5)})))()},setError:function(prop){var field=prop.field,isError=prop.isError;this.searchableFields=this.searchableFields.map((function(searchField){return searchField.name===field.name?_objectSpread2$1(_objectSpread2$1({},searchField),{},{isError:isError}):searchField}))},updateFilter:function(updatedField,filter){this.filtersFields=this.filtersFields.map((function(field){return field.name===updatedField.name?_objectSpread2$1(_objectSpread2$1({},field),{},{filterObj:filter}):field}))},removeAddFilter:function(checked,updatedField){checked||(this.filtersFields=this.filtersFields.map((function(field){return field.name===updatedField.name?_objectSpread2$1(_objectSpread2$1({},field),{},{filterObj:{}}):field})))},constructFilters:function(){var appliedFilters=this.appliedFilters,fields=this.fields,deserializedFields=fields.map((function(field){var clonedField=JSON.parse(JSON.stringify(field)),isMultiSupported=isLookupField(field)||isLookupPopupField(field)||isMultiLookupField(field);// Have to open multi support
if(isMultiSupported&&(
// To allow user to pick multiple values
clonedField.multiple=!0),isEmpty$a(appliedFilters))clonedField.canShowCriteria=!1,clonedField.filterObj={operatorId:null,value:null};else{var name=clonedField.name,filter=appliedFilters[name];if(clonedField.canShowCriteria=!1,isEmpty$a(filter))clonedField.filterObj={operatorId:null,value:null};else{if(clonedField.filterObj={},isMultiSupported){var _filter$value=filter.value,value=void 0===_filter$value?[]:_filter$value,placeHolderRegex=/\$\{[A-Z]+_[A-Z]+\}/,filterValues=(value||[]).map((function(val){var placeHolderArray=String(value).match(placeHolderRegex);return isEmpty$a(placeHolderArray)?Number(val):val}));clonedField.filterObj=_objectSpread2$1(_objectSpread2$1({},filter),{},{value:filterValues})}else{var filterValue,dataType=field.dataType;filterValue="STRING"===dataType||"BOOLEAN"===dataType?null!==filter&&void 0!==filter&&filter.value?filter.value.toString():null:null===filter||void 0===filter?void 0:filter.value,clonedField.filterObj=_objectSpread2$1(_objectSpread2$1({},filter),{},{value:filterValue})}clonedField.canShowCriteria=!0}}return clonedField}));this.searchableFields=deserializedFields||[],this.filtersFields=JSON.parse(JSON.stringify(deserializedFields))},applyFilter:function(){var filtersFields=this.filtersFields,$refs=this.$refs,filters={},isNotValid=!1;filtersFields.forEach((function(field){var sanitizedObj,filterObj=field.filterObj,name=field.name,_ref6=$refs["".concat(name)]||[],_ref7=_slicedToArray(_ref6,1),criteriaComp=_ref7[0];if(isEmpty$a(criteriaComp)||(isNotValid=!criteriaComp.validate()||isNotValid),!isEmpty$a(filterObj)){var filterValue,_filterObj$value=filterObj.value,value=void 0===_filterObj$value?{}:_filterObj$value;if(isEmpty$a(value)?sanitizedObj=_objectSpread2$1({},filterObj):(filterValue=isArray$3(value)?value.map(String):[value],sanitizedObj=_objectSpread2$1(_objectSpread2$1({},filterObj),{},{value:filterValue})),!isEmpty$a(filterObj)){var _ref8=filterObj||{},operatorId=_ref8.operatorId;isEmpty$a(operatorId)||(filters=_objectSpread2$1(_objectSpread2$1({},filters),{},_defineProperty$2({},name,sanitizedObj)))}}})),isNotValid||this.$emit("applyFilters",filters)}}};
/* script */const __vue_script__$1$1=script$1$1;
/* template */var __vue_render__$1$1=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _vm.loading?_c("div",{staticClass:"loading-container"},[_c("Spinner",{attrs:{show:_vm.loading,size:60}})],1):_c("div",{staticClass:"f-advanced-search-container"},[_c("div",{staticClass:"f-dialog-search-container",staticStyle:{margin:"8px 0"}},[_c("Input",{staticClass:"f-search-box",attrs:{type:"search",autofocus:!1,placeholder:"Search Fields","prefix-icon":"el-icon-search"},model:{value:_vm.searchtext,callback:function($$v){_vm.searchtext=$$v},expression:"searchtext"}})],1),_vm._v(" "),_c("div",{staticClass:"f-field-container",staticStyle:{margin:"8px"}},_vm._l(_vm.filteredFields,(function(field){return _c("div",{key:field.name+"-"+field.displayName,staticClass:"field-item"},[_c("div",{staticClass:"field-label"},[_c("Checkbox",{on:{change:function(checked){return _vm.removeAddFilter(checked,field)}},model:{value:field.canShowCriteria,callback:function($$v){_vm.$set(field,"canShowCriteria",$$v)},expression:"field.canShowCriteria"}},[_c("div",{staticClass:"name"},[_vm._v(_vm._s(field.displayName))])]),_vm._v(" "),field.canShowCriteria?_c("div",{staticClass:"field-search-criteria"},[_c("OperatorValues",{ref:""+field.name,refInFor:!0,attrs:{field:field,operators:_vm.operators,account:_vm.account},on:{updateFilter:function(filter){return _vm.updateFilter(field,filter)},isError:_vm.setError},model:{value:field.filterObj,callback:function($$v){_vm.$set(field,"filterObj",$$v)},expression:"field.filterObj"}})],1):_vm._e()],1)])})),0),_vm._v(" "),_c("div",{staticClass:"btn-container"},[_c("Button",{staticClass:"form-btn f13 bold secondary text-center text-uppercase",on:{click:function($event){return _vm.$emit("closeDialog")}}},[_vm._v("Cancel")]),_vm._v(" "),_c("Button",{staticClass:"form-btn f13 bold primary m0 text-center text-uppercase",attrs:{type:"primary"},on:{click:function($event){return _vm.applyFilter()}}},[_vm._v("\n      Apply\n    ")])],1)])},__vue_staticRenderFns__$1$1=[];
/* style */
const __vue_inject_styles__$1$1=function(inject){inject&&inject("data-v-0e2c3ff7_0",{source:".loading-container{display:flex;justify-content:center;align-items:center;height:100px}.f-advanced-search-container{width:100%;height:100%;display:flex;flex-direction:column;flex-wrap:nowrap}.f-advanced-search-container .f-dialog-search-container .f-search-box .el-input__inner{height:40px;border-radius:0;padding:15px 40px!important;font-size:14px;letter-spacing:.4px;color:#324056;text-overflow:ellipsis;white-space:nowrap;background:#fff!important;width:100%!important;outline:0;border:1px solid #dcdfe6}.f-advanced-search-container .f-dialog-search-container .f-search-box .el-input__prefix{left:15px}.f-advanced-search-container .f-dialog-search-container .f-search-box .el-input__prefix .el-input__icon{line-height:28px!important}.f-advanced-search-container .f-field-container{overflow:scroll;height:90%!important;margin:8px 0;padding:0 8px}.f-advanced-search-container .f-field-container .field-search-criteria{margin:8px 0}.f-advanced-search-container .f-field-container .field-item{margin-bottom:25px}.f-advanced-search-container .f-field-container .field-item .field-label{display:flex;margin-bottom:10px;flex-direction:column;padding:0 4px}.f-advanced-search-container .f-field-container .field-item .field-label .el-checkbox{display:flex;cursor:pointer!important}.f-advanced-search-container .f-field-container .field-item .field-label .name{padding-left:15px;font-size:14px;letter-spacing:.5px;color:#324056}.f-advanced-search-container .btn-container{display:flex}.f-advanced-search-container .btn-container .form-btn{flex:1 1 100%;padding-top:20px;padding-bottom:20px;border:none;letter-spacing:1.1px;text-align:center;text-transform:uppercase}.f-advanced-search-container .btn-container .form-btn.primary{background-color:#39b2c2;color:#fff;border-radius:0}.f-advanced-search-container .btn-container .form-btn.secondary{background-color:#f4f4f4;color:#8f8f8f}",map:void 0,media:void 0})},__vue_scope_id__$1$1=void 0,__vue_module_identifier__$1$1=void 0,__vue_is_functional_template__$1$1=!1,__vue_component__$1$1=normalizeComponent$3({render:__vue_render__$1$1,staticRenderFns:__vue_staticRenderFns__$1$1},__vue_inject_styles__$1$1,__vue_script__$1$1,__vue_scope_id__$1$1,__vue_is_functional_template__$1$1,__vue_module_identifier__$1$1,!1,createInjector,void 0,void 0);
/* scoped */var CloseIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{viewBox:"0 0 512 512",xmlns:"http://www.w3.org/2000/svg"}},[_c("path",{attrs:{d:"M309.582 257.554l185.1-188.733c14.782-15.057 14.782-39.478 0-54.534-14.767-15.072-38.702-15.072-53.484 0l-185.1 188.733L70.98 14.286c-14.75-15.073-38.718-15.073-53.484 0-14.767 15.057-14.767 39.478 0 54.534l185.116 188.734L17.088 446.721c-14.782 15.072-14.782 39.478 0 54.534 7.383 7.544 17.066 11.308 26.75 11.308 9.667 0 19.35-3.764 26.735-11.308L256.097 312.09l185.101 188.735c7.4 7.528 17.067 11.308 26.75 11.308 9.668 0 19.351-3.78 26.735-11.308 14.782-15.057 14.782-39.462 0-54.534l-185.1-188.736z"}})])}},script$c=_objectSpread2$1(_objectSpread2$1({components:{CloseIcon:CloseIcon,Tooltip:element_ui_common.Tooltip,Dropdown:element_ui_common.Dropdown,DropdownMenu:element_ui_common.DropdownMenu,DropdownItem:element_ui_common.DropdownItem},props:["moduleName","searchParam","filters","hideQuery","hideSaveAs"],computed:{checkDropDownExists:function(){var dropDownTags=this.dropDownTags;return!isEmpty$a(dropDownTags)},showTags:function(){var tagsArr=this.tagsArr;return!isEmpty$a(tagsArr)},firstThreeTags:function(){var tagsArr=this.tagsArr;return tagsArr.slice(0,3)},dropDownTags:function(){var tagsArr=this.tagsArr;return tagsArr.slice(3)},appliedFilters:function(){var searchParam=this.searchParam,hideQuery=this.hideQuery,filters=this.filters;return hideQuery?filters:isEmpty$a(searchParam)?null:JSON.parse(searchParam)}},watch:{appliedFilters:function(){this.constructTags()}},data:function(){return{tagsArr:[],fields:[],account:null,operatorsList:[]}},created:function(){var _this=this;return _asyncToGenerator(_regeneratorRuntime().mark((function _callee(){return _regeneratorRuntime().wrap((function(_context){while(1)switch(_context.prev=_context.next){case 0:_this.init();case 1:case"end":return _context.stop()}}),_callee)})))()},methods:{init:function(){var _this2=this;return _asyncToGenerator(_regeneratorRuntime().mark((function _callee2(){var _yield$Promise$all,_yield$Promise$all2,fields,account,operators;return _regeneratorRuntime().wrap((function(_context2){while(1)switch(_context2.prev=_context2.next){case 0:return _context2.next=2,Promise.all([_this2.loadFields(),_this2.fetchAccount(),_this2.loadOperators()]);case 2:_yield$Promise$all=_context2.sent,_yield$Promise$all2=_slicedToArray(_yield$Promise$all,3),fields=_yield$Promise$all2[0],account=_yield$Promise$all2[1],operators=_yield$Promise$all2[2],_this2.fields=fields,_this2.account=account,_this2.operatorsList=operators,_this2.constructTags();case 11:case"end":return _context2.stop()}}),_callee2)})))()},loadFields:function(){var _this3=this;return _asyncToGenerator(_regeneratorRuntime().mark((function _callee3(){var moduleName,url,_yield$API$get,data,error,_ref,_ref$message,message,_ref2,fields;return _regeneratorRuntime().wrap((function(_context3){while(1)switch(_context3.prev=_context3.next){case 0:return moduleName=_this3.moduleName,url="/v2/filter/advanced/fields/".concat(moduleName),_context3.next=4,api/* API */.bl.get(url);case 4:if(_yield$API$get=_context3.sent,data=_yield$API$get.data,error=_yield$API$get.error,!error){_context3.next=12;break}_ref=error||{},_ref$message=_ref.message,message=void 0===_ref$message?"Error occured":_ref$message,_this3.$message.error(message),_context3.next=14;break;case 12:return _ref2=data||{},fields=_ref2.fields,_context3.abrupt("return",fields);case 14:case"end":return _context3.stop()}}),_callee3)})))()},fetchAccount:function(){var _this4=this;return _asyncToGenerator(_regeneratorRuntime().mark((function _callee4(){var _yield$API$get2,data,error,_ref3,account;return _regeneratorRuntime().wrap((function(_context4){while(1)switch(_context4.prev=_context4.next){case 0:return _context4.next=2,api/* API */.bl.get("/v2/fetchAccount");case 2:if(_yield$API$get2=_context4.sent,data=_yield$API$get2.data,error=_yield$API$get2.error,!error){_context4.next=9;break}_this4.$message.error(error||"Error Occured"),_context4.next=11;break;case 9:return _ref3=data||{},account=_ref3.account,_context4.abrupt("return",account);case 11:case"end":return _context4.stop()}}),_callee4)})))()},loadOperators:function(){var _this5=this;return _asyncToGenerator(_regeneratorRuntime().mark((function _callee5(){var url,_yield$API$get3,data,error,_ref4,_ref4$message,message,_ref5,operators;return _regeneratorRuntime().wrap((function(_context5){while(1)switch(_context5.prev=_context5.next){case 0:return url="v2/filter/advanced/operators",_context5.next=3,api/* API */.bl.get(url);case 3:if(_yield$API$get3=_context5.sent,data=_yield$API$get3.data,error=_yield$API$get3.error,!error){_context5.next=11;break}_ref4=error||{},_ref4$message=_ref4.message,message=void 0===_ref4$message?"Error Occured":_ref4$message,_this5.$message.error(message),_context5.next=14;break;case 11:if(_ref5=data||{},operators=_ref5.operators,isEmpty$a(operators)){_context5.next=14;break}return _context5.abrupt("return",operators);case 14:case"end":return _context5.stop()}}),_callee5)})))()},checkSize:function(tag){var string="".concat(tag.fieldDisplayName," ").concat(tag.operatorDisplayName," ").concat(tag.valueStr),font="13px Arial",canvas=document.createElement("canvas"),context=canvas.getContext("2d");context.font=font;var width=context.measureText(string+", ").width,formattedWidth=Math.ceil(width);return!(formattedWidth>250)},isValueArray:function(tag){var _ref6=tag||{},valueStr=_ref6.valueStr;return isArray$3(valueStr)&&1!==valueStr.length},tagValue:function(tag){var _ref7=tag||{},valueStr=_ref7.valueStr;return isArray$3(valueStr)?valueStr[0]:valueStr},constructTags:function(){var _this6=this;return _asyncToGenerator(_regeneratorRuntime().mark((function _callee6(){var _this6$fields,fields,operatorsList,filters,labelMeta,lookupFieldsArr,tagsArr,isTagsConstructable;return _regeneratorRuntime().wrap((function(_context6){while(1)switch(_context6.prev=_context6.next){case 0:if(_this6$fields=_this6.fields,fields=void 0===_this6$fields?[]:_this6$fields,operatorsList=_this6.operatorsList,filters=_this6.appliedFilters,labelMeta={},lookupFieldsArr=[],tagsArr=[],isTagsConstructable=!isEmpty$a(filters)&&!isEmpty$a(operatorsList)&&!isEmpty$a(fields),isTagsConstructable&&Object.entries(filters).forEach((function(_ref8){var _ref9=_slicedToArray(_ref8,2),key=_ref9[0],value=_ref9[1],tagObj={};key=key.split("__")[0];var valueStr="",_ref10=value||{},valueArr=_ref10.value,operatorId=_ref10.operatorId,selectedField=_this6.getSelectedField({fields:fields,fieldName:key}),isLookupField$1=isLookupField(selectedField)||isLookupPopupField(selectedField)||isMultiLookupField(selectedField),selectedOperator=_this6.getSelectedOperator({selectedField:selectedField,operatorId:operatorId});isLookupField$1&&(labelMeta=_this6.constructLabelMeta({selectedField:selectedField,lookupFieldsArr:lookupFieldsArr,labelMeta:labelMeta,valueArr:valueArr,selectedOperator:selectedOperator}));var operatorDisplayName=_this6.getOperatorDisplayName({operator:selectedOperator}),isDefaultOperator=!isEmpty$a(selectedOperator.defaultValue),fieldDisplayName=selectedField.displayName;isDefaultOperator||(valueStr=_this6.getValueString({valueArr:valueArr,selectedField:selectedField,isLookupField:isLookupField$1,operator:selectedOperator})),tagObj={fieldName:key,fieldDisplayName:fieldDisplayName,operatorDisplayName:operatorDisplayName,valueStr:valueStr},"drillDownPattern"!=key&&tagsArr.push(tagObj)})),isEmpty$a(labelMeta)){_context6.next=10;break}return _context6.next=9,_this6.fetchLookupLabels({labelMeta:labelMeta,lookupFieldsArr:lookupFieldsArr,tagsArr:tagsArr});case 9:tagsArr=_context6.sent;case 10:_this6.tagsArr=tagsArr;case 11:case"end":return _context6.stop()}}),_callee6)})))()},getSelectedField:function(props){var fields=props.fields,fieldName=props.fieldName,selectedField=fields.find((function(field){return field.name===fieldName}));return selectedField||{}},getSelectedOperator:function(props){var operatorsList=this.operatorsList,operatorId=props.operatorId,selectedField=props.selectedField,_ref11=selectedField||{},dataType=_ref11.dataType,_ref11$operators=_ref11.operators,operators=void 0===_ref11$operators?[]:_ref11$operators,selectedOperator=operatorsList[dataType]||[];return isEmpty$a(operators)||(selectedOperator=selectedOperator.concat(operators)),selectedOperator.find((function(operator){return operator.operatorId===operatorId}))||{}},constructLabelMeta:function(props){var selectedField=props.selectedField,lookupFieldsArr=props.lookupFieldsArr,labelMeta=props.labelMeta,valueArr=props.valueArr,_props$selectedOperat=props.selectedOperator,selectedOperator=void 0===_props$selectedOperat?{}:_props$selectedOperat,name=this.getLookupModuleName({field:selectedField,operator:selectedOperator});// Have to construct the label meta keys from lookup module name
// either from the operator or from the field
lookupFieldsArr.push(selectedField);var selectedModule=labelMeta[name];if(isEmpty$a(selectedModule))labelMeta[name]=valueArr||[];else{var ids=labelMeta[name];labelMeta[name]=ids.concat(valueArr)}return labelMeta},getLookupModuleName:function(_ref12){var operator=_ref12.operator,field=_ref12.field,fieldLookupModule=dlv_umd(field,"lookupModule.name"),operatorLookupModule=dlv_umd(operator,"lookupModule.name");return isEmpty$a(operatorLookupModule)?fieldLookupModule:operatorLookupModule},getOperatorDisplayName:function(props){var operator=props.operator,_ref13=operator||{},tagDisplayName=_ref13.tagDisplayName,displayName=_ref13.displayName,operatorId=_ref13.operatorId;return[dateTimeOperator[operatorId]].includes(displayName)?"is":tagDisplayName||displayName},getValueString:function(props){var _this7=this,valueArr=props.valueArr,selectedField=props.selectedField,isLookupField=props.isLookupField,operator=props.operator,operatorId=operator.operatorId,operatorDisplayName=operator.displayName;if(!isEmpty$a(valueArr)){var valueStr="",isPicklistOrBoolean=this.isPicklistOrBoolean(selectedField),isDateTypeField$1=isDateTypeField(selectedField);if(isDateTypeField$1){if(valueStr=valueArr.reduce((function(acc,value,index){if([dateTimeOperator[operatorId]].includes(operatorDisplayName)){if([106,107,84,85].includes(operatorId))if(84===operatorId){var currentMonth=_this7.MONTHS.find((function(month){month.value==value&&currentMonth.push(month.label)}));acc+="".concat(currentMonth)}else acc+=85===operatorId?"".concat(_this7.WEEK_DAYS[value]):value;else acc+="".concat(value).concat(1==value?"st":2==value?"nd":3==value?"rd":"th");return acc+=index!==valueArr.length-1?", ":" ",acc}var dateStr=_this7.formatDate(Number(value),!0,!1);return isEmpty$a(acc)?"".concat(dateStr):"".concat(acc,", ").concat(dateStr)}),""),[dateTimeOperator[operatorId]].includes(operatorDisplayName))if([106,107].includes(operatorId)){var operatorIdKey={106:"Before",107:"After"};valueStr="".concat(operatorIdKey[operatorId]||""," ").concat(valueStr," days")}else[84,85].includes(operatorId)||(valueStr+="".concat(operatorDisplayName))}else if(isPicklistOrBoolean){var options=selectedField.options;isEmpty$a(options)||(valueStr=this.constructLabelString(valueArr,options))}else{if(isLookupField)return valueArr;valueStr=valueArr.reduce((function(acc,value){return isEmpty$a(acc)?"".concat(value):"".concat(acc,", ").concat(value)}),"")}return'"'.concat(valueStr,'"')}return""},isPicklistOrBoolean:function(field){var _ref14=field||{},displayType=_ref14.displayType;return["SELECTBOX","DECISION_BOX"].includes(displayType)},constructLabelString:function(){var valueArr=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],options=arguments.length>1?arguments[1]:void 0,valueStr="";return isArray$3(valueArr)&&(valueStr=valueArr.reduce((function(acc,value){var _ref15=options.find((function(option){return String(option.value)===value}))||{},_ref15$label=_ref15.label,label=void 0===_ref15$label?"Invalid":_ref15$label;return isEmpty$a(acc)?"".concat(label):"".concat(acc,", ").concat(label)}),"")),valueStr},fetchLookupLabels:function(props){var _this8=this;return _asyncToGenerator(_regeneratorRuntime().mark((function _callee7(){var labelMeta,lookupFieldsArr,tagsArr,_yield$API$post,data,error,_error$message,message,_ref16,label;return _regeneratorRuntime().wrap((function(_context7){while(1)switch(_context7.prev=_context7.next){case 0:return labelMeta=props.labelMeta,lookupFieldsArr=props.lookupFieldsArr,tagsArr=props.tagsArr,_context7.next=3,api/* API */.bl.post("/v2/picklist/label",{labelMeta:labelMeta});case 3:return _yield$API$post=_context7.sent,data=_yield$API$post.data,error=_yield$API$post.error,error?(_error$message=error.message,message=void 0===_error$message?"Error Occurred":_error$message,_this8.$message.error(message)):(_ref16=data||{},label=_ref16.label,tagsArr=tagsArr.map((function(tag){var fieldName=tag.fieldName,valueStr=tag.valueStr,lookupField=lookupFieldsArr.find((function(field){return field.name===fieldName}));if(lookupField){
// Have to get the value labels from lookup module name
// either from the operator or from the field
var fields=_this8.fields,filters=_this8.appliedFilters,field=_this8.getSelectedField({fields:fields,fieldName:fieldName}),currentFiter=filters[fieldName],operatorId=currentFiter.operatorId,operator=_this8.getSelectedOperator({selectedField:field,operatorId:operatorId}),name=_this8.getLookupModuleName({operator:operator,field:field}),moduleLabels=label[name]||[],labelArray=_this8.constructLabelString(valueStr,moduleLabels);tag.valueStr=labelArray}return tag}))),_context7.abrupt("return",tagsArr);case 8:case"end":return _context7.stop()}}),_callee7)})))()},formatDate:function(date,excludeTime,onlyTime){var dateformat=this.account.org.dateFormat,timeformat=this.account.org.timeFormat,timezone=this.account.org.timezone?this.account.org.timezone:"Etc/UTC";return onlyTime?moment_timezone(date).tz(timezone).format(timeformat):excludeTime?moment_timezone(date).tz(timezone).format(dateformat):moment_timezone(date).tz(timezone).format(dateformat+" "+timeformat)},clearFilter:function(tag){var appliedFilters=this.appliedFilters,hideQuery=this.hideQuery,filtersObj=this.filters,filters=deepClean$2(appliedFilters)||{},fieldName=tag.fieldName;isEmpty$a(fieldName)||delete filters[fieldName],hideQuery&&!isEmpty$a(filtersObj)?this.$emit("updateFilters",filters):isEmpty$a(filters)?this.$emit("resetFilters",filters):this.$emit("applyFilters",filters)}}},MONTHS),WEEK_DAYS);
/* script */
const __vue_script__$c=script$c;
/* template */var __vue_render__$b=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _vm.showTags?_c("div",{staticClass:"f-filter-tags-container"},[_vm._l(_vm.firstThreeTags,(function(tag,index){return _c("div",{key:index,ref:index,refInFor:!0},[_c("Tooltip",{attrs:{placement:"bottom-start",disabled:_vm.checkSize(tag)}},[_c("div",{staticClass:"f-tag-content",attrs:{slot:"content"},slot:"content"},[_vm._v("\n        "+_vm._s(tag.fieldDisplayName)+" "+_vm._s(tag.operatorDisplayName)+"\n        "+_vm._s(tag.valueStr)+"\n      ")]),_vm._v(" "),_c("div",{staticClass:"tag"},[_c("div",[_vm._v(_vm._s(tag.fieldDisplayName))]),_vm._v(" "),_c("div",{staticClass:"ftag-operator"},[_vm._v("\n          "+_vm._s(tag.operatorDisplayName)+"\n        ")]),_vm._v(" "),_c("div",{staticClass:"ftag-value-container"},[_vm._v("\n          "+_vm._s(tag.valueStr)+"\n        ")]),_vm._v(" "),_c("span",{on:{click:function($event){return _vm.clearFilter(tag)}}},[_c("CloseIcon",{staticClass:"ftag-close-icon"})],1)])])],1)})),_vm._v(" "),_vm.checkDropDownExists?_c("div",[_c("Dropdown",[_c("div",{staticClass:"tag"},[_vm._v("+"+_vm._s(_vm.dropDownTags.length))]),_vm._v(" "),_c("DropdownMenu",{staticClass:"f-tags-dropdown",attrs:{slot:"dropdown"},slot:"dropdown"},_vm._l(_vm.dropDownTags,(function(tag,index){return _c("DropdownItem",{key:index},[_c("Tooltip",{attrs:{placement:"right",disabled:_vm.checkSize(tag)}},[_c("div",{staticClass:"f-tag-content",attrs:{slot:"content"},slot:"content"},[_vm._v("\n              "+_vm._s(tag.fieldDisplayName)+" "+_vm._s(tag.operatorDisplayName)+"\n              "+_vm._s(tag.valueStr)+"\n            ")]),_vm._v(" "),_c("div",{staticClass:"dropdown-tag"},[_c("div",[_vm._v(_vm._s(tag.fieldDisplayName))]),_vm._v(" "),_c("div",{staticClass:"ftag-operator"},[_vm._v("\n                "+_vm._s(tag.operatorDisplayName)+"\n              ")]),_vm._v(" "),_c("div",{staticClass:"ftag-value-container"},[_vm._v("\n                "+_vm._s(tag.valueStr)+"\n              ")]),_vm._v(" "),_c("span",{on:{click:function($event){return _vm.clearFilter(tag)}}},[_c("CloseIcon",{staticClass:"ftag-close-icon"})],1)])])],1)})),1)],1)],1):_vm._e(),_vm._v(" "),_c("div",{staticClass:"btn-container"},[_c("Button",{staticClass:"tag-btn",on:{click:function($event){return _vm.$emit("clearFilters",!0)}}},[_vm._v("Clear all")]),_vm._v(" "),_c("Button",{directives:[{name:"show",rawName:"v-show",value:!_vm.hideSaveAs,expression:"!hideSaveAs"}],staticClass:"tag-btn"},[_vm._v("Save As")])],1)],2):_vm._e()},__vue_staticRenderFns__$b=[];
/* style */
const __vue_inject_styles__$c=function(inject){inject&&inject("data-v-52bb0d0a_0",{source:".ftag-value-container[data-v-52bb0d0a]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ftag-close-icon[data-v-52bb0d0a]{height:10px;width:10px;margin-left:8px;cursor:pointer}.f-tag-content[data-v-52bb0d0a]{max-width:250px;font-size:13px;background:#303133;color:#fff;padding:4px 8px;border-radius:4px}.ftag-operator[data-v-52bb0d0a]{margin:0 4px;color:#324056;font-size:13px;font-weight:400}.f-filter-tags-container[data-v-52bb0d0a]{background:#fff;margin:10px;padding:8px 4px;display:flex;flex-wrap:wrap;box-sizing:border-box;gap:12px}.f-filter-tags-container .tag[data-v-52bb0d0a]{cursor:pointer;display:flex;border-radius:14px;border:solid 1px rgba(58,178,193,.4705882353);background-color:#fff;color:#324056;font-size:13px;font-weight:500;height:24px;align-items:center;padding:6px 10px;box-sizing:border-box;margin-bottom:0!important;margin-right:0!important;max-width:330px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.f-filter-tags-container .tag[data-v-52bb0d0a]:hover{border-color:#3ab2c1}.f-filter-tags-container .tag-btn[data-v-52bb0d0a]{height:24px;margin:0 8px;padding:0 8px;border-radius:14px;border:solid 1px rgba(58,178,193,.4705882353);background-color:#f7feff;cursor:pointer}.f-filter-tags-container .tag-btn[data-v-52bb0d0a]:hover{border-color:#3ab2c1}.el-dropdown-link[data-v-52bb0d0a]{cursor:pointer}.el-dropdown-menu.el-popper.f-tags-dropdown[data-v-52bb0d0a]{list-style:none;width:250px;max-height:165px;overflow:scroll;box-shadow:0 1px 5px 0 rgba(0,0,0,.16);background-color:#fff;padding-inline-start:0}.el-dropdown-menu.el-popper.f-tags-dropdown li.el-dropdown-menu__item[data-v-52bb0d0a]{padding:0!important}.el-dropdown-menu.el-popper.f-tags-dropdown li .dropdown-tag[data-v-52bb0d0a]{background-color:#fff;color:#324056;font-size:13px;font-weight:500;cursor:pointer;box-sizing:border-box;width:100%;height:40px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:13px;background-color:#fff;display:flex;align-items:center;padding:4px}.el-dropdown-menu.el-popper.f-tags-dropdown li .dropdown-tag[data-v-52bb0d0a]:hover{background-color:#fafafa}.el-dropdown-menu.el-popper.f-tags-dropdown li .dropdown-tag span[data-v-52bb0d0a]{flex-grow:1;text-align:right}",map:void 0,media:void 0})},__vue_scope_id__$c="data-v-52bb0d0a",__vue_module_identifier__$c=void 0,__vue_is_functional_template__$c=!1,__vue_component__$b=normalizeComponent$3({render:__vue_render__$b,staticRenderFns:__vue_staticRenderFns__$b},__vue_inject_styles__$c,__vue_script__$c,__vue_scope_id__$c,__vue_is_functional_template__$c,__vue_module_identifier__$c,!1,createInjector,void 0,void 0);
/* scoped */var AdvancedSearch=__vue_component__$1$1,FTags=__vue_component__$b;const LOOKUP_FILTERS_MAP={1:"building",2:"asset",3:"tenantcontact",4:"clientcontact",5:"vendorcontact",6:"employee"},RESOURCE_MODULE_HASH={resource:[{label:"Asset",value:"asset"},{label:"Site",value:"site"},{label:"Building",value:"building"},{label:"Floor",value:"floor"},{label:"Space",value:"space"}],basespace:[{label:"Site",value:"site"},{label:"Building",value:"building"},{label:"Floor",value:"floor"},{label:"Space",value:"space"}]};
defineCustomElements$3();var script$b={props:["mainFieldObj","debounceTime","search"],components:{Input:element_ui_common.Input},watch:{search(newVal){""===newVal&&(this.searchText=null,this.showMainFieldSearch=!1)}},data(){return{showMainFieldSearch:!1,searchText:null,debounceTS:this.debounceTime||500}},created(){isEmpty$a(this.search)||(this.searchText=this.search),this.debounceEmitSearch=debounce(this.emitSearchText,this.debounceTS)},computed:{canShowMainFieldSearch(){let{dataTypeEnum:dataTypeEnum}=this.mainFieldObj||{};return"STRING"===dataTypeEnum}},methods:{openSearch(){this.showMainFieldSearch=!0,this.$nextTick((()=>{let searchBox=this.$refs["mainFieldSearchInput"];!isEmpty$a(searchBox)&&searchBox.focus()}))},hideMainFieldSearch(){isEmpty$a(this.searchText)&&(this.showMainFieldSearch=!1)},emitSearchText(){this.$emit("update:search",this.searchText),this.$emit("onSearch",this.searchText)},clearSearch(){this.debounceEmitSearch(),this.hideMainFieldSearch()}}};
/* script */const __vue_script__$b=script$b;
/* template */var __vue_render__$a=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",[_vm.showMainFieldSearch?_c("Input",{ref:"mainFieldSearchInput",staticClass:"fc-input-full-border2 width-auto mL-auto",attrs:{clearable:"",placeholder:"Search"},on:{blur:_vm.hideMainFieldSearch,clear:_vm.hideMainFieldSearch,change:_vm.debounceEmitSearch},model:{value:_vm.searchText,callback:function($$v){_vm.searchText=$$v},expression:"searchText"}}):_c("div",{staticClass:"f-wizard-mainfield-search",on:{click:_vm.openSearch}},[_c("fc-icon",{attrs:{group:"default",name:"search",color:"#6c6a91",size:"20"}})],1),_vm._v(" "),_vm._t("default")],2)},__vue_staticRenderFns__$a=[];
/* style */
const __vue_inject_styles__$b=function(inject){inject&&inject("data-v-5a290342_0",{source:".f-wizard-mainfield-search{height:16px!important;box-sizing:content-box;cursor:pointer;padding:3px;border-radius:4px;border:1px solid transparent}.f-wizard-mainfield-search:hover{color:#615e88;background:#f5f6f8;border-color:#dae0e8}",map:void 0,media:void 0})},__vue_scope_id__$b=void 0,__vue_module_identifier__$b=void 0,__vue_is_functional_template__$b=!1,__vue_component__$a=normalizeComponent$a({render:__vue_render__$a,staticRenderFns:__vue_staticRenderFns__$a},__vue_inject_styles__$b,__vue_script__$b,__vue_scope_id__$b,__vue_is_functional_template__$b,__vue_module_identifier__$b,!1,createInjector$7,void 0,void 0),RESOURCE_MODULE_FILTER_HASH={site:[],building:["site"],basespace:["site","building","floor","basespace"],asset:["site","building","floor","basespace"],floor:["site","building"]};
/* scoped */var script$a={name:"ResourceFilter",props:["subModuleName","siteId"],components:{Select:element_ui_common.Select,Option:element_ui_common.Option},data:()=>({isEmpty:isEmpty$a,siteOptions:[],buildingOptions:[],floorOptions:[],basespaceOptions:[],value:{site:null,building:null,basespace:null,floor:null},loading:{site:!1,building:!1,basespace:!1,floor:!1},filter:{},isResourceModuleChanged:!1,categoryOptions:[],category:null}),created(){this.init(),this.fetchCategory()},computed:{canShowCategory(){let{subModuleName:subModuleName}=this||{};return["space","asset"].includes(subModuleName)},activeFilters(){let{subModuleName:subModuleName}=this||{};return subModuleName="space"===subModuleName?"basespace":subModuleName,RESOURCE_MODULE_FILTER_HASH[subModuleName]||RESOURCE_MODULE_FILTER_HASH["site"]},categoryFilter(){let{subModuleName:subModuleName,category:category}=this||{},filter={};if(!isEmpty$a(category)){let categoryModuleName="category";"space"===subModuleName&&(categoryModuleName="spaceCategory"),filter={[categoryModuleName]:{operator:"is",value:[`${category}`]}}}return filter}},watch:{subModuleName:{handler(){this.isResourceModuleChanged=!0,this.resetValues(),this.fetchCategory()}},value:{handler(){this.setFilter()},deep:!0},category:{handler(){this.setFilter()}}},methods:{async fetchCategory(){let{subModuleName:subModuleName}=this||{};if(this.category=null,["space","asset"].includes(subModuleName)){let moduleName="spaceCategory";"asset"===subModuleName&&(moduleName="assetCategory");let props={field:{resourceLookupModuleName:moduleName}},{options:options}=await getFieldOptions$3(props);this.categoryOptions=options}else this.categoryOptions=[]},async init(){await this.loadPicklistOptions("site");let{siteId:siteId,value:value}=this||{};
// if site id is provided as prop set that as the site filter value
isEmpty$a(siteId)||(this.value={...value,site:parseInt(siteId)},this.$nextTick((()=>{this.loadPicklistOptions("building")})))},setFilter(){let{value:value,subModuleName:subModuleName,siteId:siteId,isResourceModuleChanged:isResourceModuleChanged}=this||{},filterObj={};Object.entries(value).forEach((([key,value])=>{if(!isEmpty$a(value)){let prop="site"===key?"siteId":key;prop="basespace"===prop?"space":prop,filterObj[prop]={operatorId:36,value:[`${value}`]}}}));let modifiedFilterObj=filterObj;if("asset"===subModuleName&&!isEmpty$a(modifiedFilterObj)){let priorityTree=["building","floor","space"],clonedFilterObj=(0,lodash.cloneDeep)(filterObj),activeFilterModule={};priorityTree.map((currModule=>{if(!isEmpty$a(clonedFilterObj[currModule])){let rollupFilter=clonedFilterObj[currModule];rollupFilter={...rollupFilter,operatorId:38},activeFilterModule["space"]=rollupFilter}})),activeFilterModule={...activeFilterModule,siteId:clonedFilterObj["siteId"]},modifiedFilterObj=activeFilterModule}let hasOnlySite=Object.keys(modifiedFilterObj).every((key=>"siteId"===key)),{categoryFilter:categoryFilter}=this||{};isEmpty$a(categoryFilter)||(modifiedFilterObj={...modifiedFilterObj,...categoryFilter});
// should not emit filter if we have site id prop and there is only site filter
let emitFilter=hasOnlySite&&!isEmpty$a(siteId);emitFilter||this.$emit("resourceFilter",modifiedFilterObj),this.filter=filterObj},async loadPicklistOptions(moduleName){this.$nextTick((async()=>{let{activeFilters:activeFilters,siteId:siteId}=this||{};if(activeFilters.includes(moduleName)){this.resetNextModuleValues(moduleName),this.loading[moduleName]=!0;let props={field:{resourceLookupModuleName:moduleName}},filters=this.constructPicklistFilter(moduleName);if(!isEmpty$a(filters)){let{field:field}=props||{};props={...props,field:{...field,filters:filters}}}isEmpty$a(siteId)||"site"!==moduleName||(props={...props,defaultIds:[siteId]});let{options:options}=await getFieldOptions$3(props);this[`${moduleName}Options`]=options,this.loading[moduleName]=!1}}))},constructPicklistFilter(moduleName){let{activeFilters:activeFilters,filter:filterObj}=this||{},filtersList=(0,lodash.cloneDeep)(activeFilters),currIndex=activeFilters.findIndex((module=>module===moduleName));filtersList.splice(currIndex);let filters={};return filtersList.forEach((filter=>{filter="site"===filter?"siteId":filter;let currValue=filterObj[filter];isEmpty$a(currValue)||(filters[filter]=currValue)})),filters},resetNextModuleValues(moduleName){let{activeFilters:activeFilters}=this||{},filtersList=(0,lodash.cloneDeep)(activeFilters),currIndex=filtersList.findIndex((module=>module===moduleName));filtersList.splice(0,currIndex),filtersList.forEach((filter=>{this.value[filter]=null}))},resetValues(){let{value:value}=this||{};this.value={...value,building:null,basespace:null,floor:null}}}};
/* script */const __vue_script__$a=script$a;
/* template */var __vue_render__$9=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return"site"!==_vm.subModuleName?_c("div",{staticClass:"resource-filter-header"},[_vm.canShowCategory?_c("Select",{staticClass:"f-ui-select f-ui-select-tag",attrs:{filterable:"",placeholder:"Select Category",clearable:""},model:{value:_vm.category,callback:function($$v){_vm.category=$$v},expression:"category"}},_vm._l(_vm.categoryOptions,(function(category,index){return _c("Option",{key:index,staticClass:"f-ui-select-item width100",attrs:{label:category.label,value:category.value}})})),1):_vm._e(),_vm._v(" "),_vm._l(_vm.activeFilters,(function(filter,index){return _c("div",{key:"resource-filter-"+index},["site"===filter?_c("Select",{staticClass:"f-ui-select f-ui-select-tag",attrs:{filterable:"",placeholder:"Select Site",loading:_vm.loading["site"],clearable:""},on:{change:function($event){return _vm.loadPicklistOptions("building")}},model:{value:_vm.value["site"],callback:function($$v){_vm.$set(_vm.value,"site",$$v)},expression:"value['site']"}},_vm._l(_vm.siteOptions,(function(site,index){return _c("Option",{key:index,staticClass:"f-ui-select-item width100",attrs:{label:site.label,value:site.value}})})),1):_vm._e(),_vm._v(" "),"building"===filter?_c("Select",{staticClass:"f-ui-select f-ui-select-tag",attrs:{filterable:"",disabled:_vm.isEmpty(_vm.value["site"]),placeholder:"Select Building",loading:_vm.loading["building"],clearable:""},on:{change:function($event){return _vm.loadPicklistOptions("floor")}},model:{value:_vm.value["building"],callback:function($$v){_vm.$set(_vm.value,"building",$$v)},expression:"value['building']"}},_vm._l(_vm.buildingOptions,(function(building,index){return _c("Option",{key:index,staticClass:"f-ui-select-item width100",attrs:{label:building.label,value:building.value}})})),1):_vm._e(),_vm._v(" "),"floor"===filter?_c("Select",{staticClass:"f-ui-select f-ui-select-tag",attrs:{filterable:"",disabled:_vm.isEmpty(_vm.value["building"]),placeholder:"Select Floor",loading:_vm.loading["floor"],clearable:""},on:{change:function($event){return _vm.loadPicklistOptions("basespace")}},model:{value:_vm.value["floor"],callback:function($$v){_vm.$set(_vm.value,"floor",$$v)},expression:"value['floor']"}},_vm._l(_vm.floorOptions,(function(floor,index){return _c("Option",{key:index,staticClass:"f-ui-select-item width100",attrs:{label:floor.label,value:floor.value}})})),1):_vm._e(),_vm._v(" "),"basespace"===filter?_c("Select",{staticClass:"f-ui-select f-ui-select-tag",attrs:{filterable:"",disabled:_vm.isEmpty(_vm.value["floor"]),loading:_vm.loading["basespace"],placeholder:"Select Space",clearable:""},model:{value:_vm.value["basespace"],callback:function($$v){_vm.$set(_vm.value,"basespace",$$v)},expression:"value['basespace']"}},_vm._l(_vm.basespaceOptions,(function(basespace,index){return _c("Option",{key:index,staticClass:"f-ui-select-item width100",attrs:{label:basespace.label,value:basespace.value}})})),1):_vm._e()],1)}))],2):_vm._e()},__vue_staticRenderFns__$9=[];
/* style */
const __vue_inject_styles__$a=function(inject){inject&&inject("data-v-4180fda8_0",{source:".resource-filter-header{display:flex;align-items:center;padding:10px 20px;gap:8px}.resource-filter-header .el-input__inner{height:28px!important;line-height:28px!important}.resource-filter-header .el-input__suffix i{line-height:28px!important}",map:void 0,media:void 0})},__vue_scope_id__$a=void 0,__vue_module_identifier__$a=void 0,__vue_is_functional_template__$a=!1,__vue_component__$9=normalizeComponent$a({render:__vue_render__$9,staticRenderFns:__vue_staticRenderFns__$9},__vue_inject_styles__$a,__vue_script__$a,__vue_scope_id__$a,__vue_is_functional_template__$a,__vue_module_identifier__$a,!1,createInjector$7,void 0,void 0),RESOURCE_MODULES=["site","building","floor","space","asset","basespace","resource"];
/* scoped */var script$9={props:["canShowLookupWizard","field","siteId","listUrlConfig","quickSearchEnabled","skipDecommission"],components:{Dialog:element_ui_common.Dialog,CommonList:__vue_component__$a$3,Spinner:__vue_component__$q,Pagination:__vue_component__$o,Radio:element_ui_common.Radio,Tag:element_ui_common.Tag,Button:element_ui_common.Button,EmptyIcon:EmptyIcon$3,AdvancedFilterIcon:AdvancedFilterIcon$2,AdvancedSearch:AdvancedSearch,FTags:FTags,Select:element_ui_common.Select,Option:element_ui_common.Option,MainFieldSearch:__vue_component__$a,ResourceFilters:__vue_component__$9},data:()=>({isLoading:!1,viewDetail:null,moduleList:[],perPage:10,page:1,totalCount:0,selectedItem:[],search:"",resourceModuleName:"basespace",criteria:{},showAdvWizard:!1,operators:[],filters:{},subModuleName:"",resourceSubModules:[],searchText:"",showQuickFilter:!1,resetFilter:!1,quickFilter:{},resourceFilter:{}}),watch:{showQuickFilter:{handler(newVal){if(!newVal){let{quickFilter:quickFilter}=this;isEmpty$a(quickFilter)||(this.quickFilter=null,this.loadRecords())}}},searchText(){this.page=1,this.fetchModuleList(!0)},async page(){this.isLoading=!0,await this.fetchModuleList(),this.isLoading=!1},async filters(){this.loading=!0,this.page=1,await this.fetchModuleList(),this.loading=!1},moduleName:{handler(newVal,oldVal){isEmpty$a(RESOURCE_MODULE_HASH[newVal])&&this.loadData()},immediate:!0},isLoading(newVal){!newVal&&this.multiSelect&&this.toggleSelection()},async resourceFilter(val){isEmpty$a(val)||(this.isLoading=!0,this.page=1,await this.fetchModuleList(!0),this.isLoading=!1)}},computed:{showFTags(){let{filters:filters}=this;return!isEmpty$a(filters)},actualMainfield(){let{viewDetail:viewDetail}=this,mainField=null;if(!isEmpty$a(viewDetail)){let{fields:fields}=viewDetail;mainField=(fields||[]).find((field=>{let{field:fieldObj}=field;return(fieldObj||{}).mainField}))}return mainField},isResourceModule(){let{field:field}=this,{config:config}=field||{},{isFiltersEnabled:isFiltersEnabled}=config||{};if(isFiltersEnabled)return!1;let displayName=dlv_umd(field,"field.lookupModule.name","");if(isEmpty$a(displayName)&&(displayName=dlv_umd(field,"lookupModule.name","")),!isEmpty$a(RESOURCE_MODULE_HASH[displayName])){let subModule=RESOURCE_MODULE_HASH[displayName][0];return this.subModuleName=subModule.value,this.resourceSubModules=RESOURCE_MODULE_HASH[displayName],!0}return!1},mainField(){let{viewDetail:viewDetail}=this,mainField=null;if(!isEmpty$a(viewDetail)){let{fields:fields}=viewDetail;mainField=(fields||[]).find((field=>{let{field:fieldObj}=field;return(fieldObj||{}).mainField}))}return isEmpty$a(mainField)&&(mainField={name:"name",displayName:"Name",field:{name:"name",dataTypeEnum:"STRING"}}),mainField},mainFieldName(){let{mainField:mainField}=this||{},{name:name}=mainField||{};return isEmpty$a(name)&&(name=dlv_umd(mainField,"field.name","")),name},canShowWizard:{get(){return this.canShowLookupWizard},set(value){this.$emit("update:canShowLookupWizard",value)}},moduleDisplayName(){let{field:field}=this,displayName=dlv_umd(field,"field.lookupModule.displayName","");return isEmpty$a(displayName)&&(displayName=dlv_umd(field,"lookupModule.displayName","")),displayName},moduleName(){let{field:field,subModuleName:subModuleName,listUrlConfig:listUrlConfig}=this;if(!isEmpty$a(listUrlConfig)){let{toModuleName:toModuleName}=listUrlConfig;return toModuleName}let{config:config}=field,{isFiltersEnabled:isFiltersEnabled,filterValue:filterValue,lookupModuleName:configLookupModuleName}=config||{};if(isFiltersEnabled)return configLookupModuleName||LOOKUP_FILTERS_MAP[filterValue];let displayName=dlv_umd(field,"field.lookupModule.name","");return isEmpty$a(displayName)&&(displayName=dlv_umd(field,"lookupModule.name","")),isEmpty$a(subModuleName)||(displayName=subModuleName),displayName},title(){let{moduleDisplayName:moduleDisplayName}=this;return`Choose ${moduleDisplayName}`},multiSelect(){let{field:field,listUrlConfig:listUrlConfig}=this;if(!isEmpty$a(listUrlConfig)){let{multiple:multiple}=listUrlConfig||{};return multiple}let{multiple:multiple}=field||{};return multiple},selectedLabel(){let{moduleDisplayName:moduleDisplayName}=this;return`Selected ${moduleDisplayName} `},selectedItemName(){let{selectedItem:selectedItem}=this||{},selectedItemNames=(selectedItem||[]).map((list=>list.label));return isEmpty$a(selectedItemNames)?null:selectedItemNames},selectedItemId:{get(){let{selectedItem:selectedItem,multiSelect:multiSelect}=this||{},selectedItemIds=(selectedItem||[]).map((list=>list.value));return multiSelect?selectedItemIds:selectedItemIds[0]},set(val){let{moduleList:moduleList,multiSelect:multiSelect}=this||{};multiSelect||Array.isArray(val)||(val=[val]);let selectedItem=moduleList.filter((item=>val.includes(item.id)));this.selectedItem=selectedItem.map((list=>{let{id:id}=list,{name:name}=this.mainField||{name:"name"},selectedItem={label:list[name],value:id};return selectedItem}))}},slotList(){let{actualMainfield:actualMainfield}=this,label=dlv_umd(this,"actualMainfield.field.displayName","Name"),slots=[{name:"select",isHardcodedColumn:!0,columnAttrs:{fixed:"left",width:"50"}}];if(isEmpty$a(actualMainfield))slots.push({name:"name",isHardcodedColumn:!0,columnAttrs:{fixed:"left",label:label,width:"200"}});else{let{field:field}=actualMainfield,{name:mainFieldName}=field;slots.push({criteria:JSON.stringify({name:mainFieldName})})}return slots}},created(){this.loadOperatorList(),this.debounceLoadRecord=debounce((()=>{this.loadRecords()}),600)},methods:{setResourceFilter(filter){this.resourceFilter=filter},async loadRecords(){this.isLoading=!0,await this.fetchModuleList(),this.isLoading=!1},async loadOperatorList(){let url="v2/filter/advanced/operators",{data:data,error:error}=await api/* API */.bl.get(url);if(error){let{message:message="Error Occured"}=error||{};this.$message.error(message)}else{let{operators:operators}=data||{};isEmpty$a(operators)||(this.operators=operators)}},isEmpty(val){return isEmpty$a(val)},quickSearchRecord(prop){let{showQuickFilter:showQuickFilter}=this,{filterObj:filterObj,clear:clear}=prop;this.quickFilter=filterObj,this.resetFilter=clear,showQuickFilter&&this.debounceLoadRecord()},applyFilters(filters){this.filters=filters,this.showAdvWizard=!1},getMainFieldValue(record={}){let{mainField:mainField}=this||{},{field:field}=mainField||{},{name:name}=field||{};if(isObject$5(record[name])){let{name:mainValue}=record[name];return mainValue}return record[name]||record.name},setResourceModule(val){this.subModuleName=val,this.filters=null,this.searchText="",this.resourceFilter={}},async loadData(){let promise=[],{moduleName:moduleName}=this;isEmpty$a(moduleName)||(this.initSelectedItem(),promise.push(this.fetchViewDetail()),promise.push(this.fetchModuleList()),this.isLoading=!0,await Promise.all(promise),this.isLoading=!1)},async fetchViewDetail(){let viewError,{moduleName:moduleName,listUrlConfig:listUrlConfig}=this,viewDetailsData={};if(isEmpty$a(listUrlConfig)){let url="v2/views/hidden-all",{data:data,error:error}=await api/* API */.bl.get(url,{moduleName:moduleName});viewDetailsData=data,viewError=error}else{let{toModuleName:toModuleName}=listUrlConfig||{},{data:data,error:error}=await api/* API */.bl.get("v2/views/hidden-all",{moduleName:toModuleName});viewDetailsData=data,viewError=error}if(isEmpty$a(viewError)){let{viewDetail:viewDetail}=viewDetailsData||{},{fields:fields}=viewDetail||{};fields=fields.map((field=>{let{field:fieldObj,name:name=""}=field||{},{mainField:mainField}=fieldObj||{};return mainField?{...field,columnAttrs:{fixed:"left",width:"200"}}:field})),isEmpty$a(viewDetail)||this.$set(this,"viewDetail",{...viewDetail,fields:fields})}},async fetchModuleList(force=!1){let filterObj={},{moduleName:moduleName,page:page,perPage:perPage,siteId:siteId,searchText:searchText,listUrlConfig:listUrlConfig,showQuickFilter:showQuickFilter,skipDecommission:skipDecommission,resourceFilter:resourceFilter}=this||{},{filters:filters,field:field}=this||{},{config:config,filters:fieldFilters,clientCriteria:clientCriteria}=field||{},{skipSiteFilter:skipSiteFilter}=config||{};if(RESOURCE_MODULES.includes(moduleName)&&!skipDecommission){let decommissionResourceFilter={decommission:{operatorId:15,value:["false"]}};filterObj={...filterObj,...decommissionResourceFilter}}skipSiteFilter||isEmpty$a(siteId)||(filterObj={siteId:{operatorId:36,value:[`${siteId}`]}}),isEmpty$a(resourceFilter)||(filterObj={...filterObj,...resourceFilter}),isEmpty$a(fieldFilters)||(filterObj={...filterObj,...fieldFilters}),isEmpty$a(filters)||(filterObj={...filterObj,...filters});let params={viewname:"hidden-all",includeParentFilter:!0,page:page,perPage:perPage,withCount:!0};if(showQuickFilter)if(this.quickFilter=this.$refs["lookupCommonList"].getQuickFilters(),isEmpty$a(this.quickFilter)){if(!this.resetFilter)return}else params["quickFilter"]=JSON.stringify(this.quickFilter);isEmpty$a(searchText)||(params["search"]=searchText),isEmpty$a(filterObj)||(params["filters"]=JSON.stringify(filterObj)),isEmpty$a(clientCriteria)||(params["clientCriteria"]=JSON.stringify(clientCriteria));let listMeta,recordList=[],listError=null;if(isEmpty$a(listUrlConfig)){let{list:list,error:error,meta:meta}=await api/* API */.bl.fetchAll(moduleName,params,{force:force});recordList=list,listError=error,listMeta=meta}else{let{params:listURLParams,url:url,toModuleName:toModuleName}=listUrlConfig,{data:data,error:error,meta:meta}=await api/* API */.bl.get(url,{...params,...listURLParams});recordList=data[toModuleName]||[],listError=error,listMeta=meta}isEmpty$a(listError)&&(this.moduleList=recordList,this.totalCount=dlv_umd(listMeta,"pagination.totalCount",0))},onSearchChange:debounce((async function(value){this.onSearch(value)}),700),async onSearch(value){if(this.isLoading=!0,isEmpty$a(value))await this.fetchModuleList();else{let{mainFieldName:mainFieldName}=this||{};("basespace"==this.moduleName||"asset"==this.moduleName)&&(mainFieldName="name");let filters={[mainFieldName]:{operatorId:5,value:[value]}};await this.fetchModuleList({filters:filters})}this.isLoading=!1},initSelectedItem(){let{field:field}=this,{selectedItems:selectedItems=[]}=field||{};isEmpty$a(selectedItems)||(this.selectedItem=[...selectedItems])},toggleSelection(){this.$nextTick((()=>{let{selectedItemId:selectedItemId}=this,currentSelectedList=this.moduleList.filter((list=>(selectedItemId||[]).includes((list||{}).id))),ref=this.$refs.lookupCommonList;isEmpty$a(ref)||(ref.clearSelection(),currentSelectedList.forEach((item=>{ref.toggleRowSelection(item,!0)})))}))},setSelectedItem(){let{selectedItem:selectedItem,mainField:mainField,selectedItemId:selectedItemId,multiSelect:multiSelect,field:field,mainFieldName:mainFieldName,listUrlConfig:listUrlConfig}=this;if(!isEmpty$a(listUrlConfig))return this.$emit("setListValues",selectedItem),void(this.canShowWizard=!1);if(!multiSelect&&!isEmpty$a(selectedItemId)){let selectedOption=this.moduleList.find((list=>list.id===selectedItemId));if(isEmpty$a(selectedOption)){let{selectedItems:preSelectedItems}=field;selectedOption=preSelectedItems.find((list=>list.value===selectedItemId)),selectedItem=[selectedOption]}else selectedItem=[selectedOption],selectedItem=selectedItem.map((list=>{let{id:id}=list,name=mainFieldName,selectedItem={label:list[name],value:id};return selectedItem}))}isEmpty$a(mainField)&&(mainField={name:"name"}),field.selectedItems=selectedItem;let data={field:field};this.$emit("setLookupFieldValue",data),this.canShowWizard=!1},closeLookupWizard(){this.canShowWizard=!1},handleSelection(selectedList){let nonCurrentItems=this.getNonCurrentList(this.selectedItem),currentItems=(selectedList||[]).map((list=>{let{id:id}=list,{mainFieldName:mainFieldName}=this||{};return{label:list[mainFieldName],value:id}}));this.selectedItem=[...nonCurrentItems,...currentItems]},getNonCurrentList(selectedList){let{moduleList:moduleList}=this,currentModuleList=selectedList.filter((item=>-1===moduleList.findIndex((list=>list.id===item.value))));return currentModuleList},handleSelectedClose(item){let index=this.selectedItem.findIndex((list=>list.label===item));this.selectedItem.splice(index,1),this.toggleSelection()},closeWizard(){let{listUrlConfig:listUrlConfig}=this;isEmpty$a(listUrlConfig)?this.setSelectedItem():this.closeLookupWizard()},closeAdvWizard(){this.showAdvWizard=!1},applyFilter(){let filters=this.$refs["advancedSearch"].save();this.filters=filters,this.closeAdvWizard()},updateFilters(filters){this.filters=filters}}};
/* script */const __vue_script__$9=script$9;
/* template */var __vue_render__$8=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("Dialog",{staticClass:"f-ui-forms f-ui-lookup-wizard",attrs:{visible:_vm.canShowWizard,width:"70%",top:"5vh","append-to-body":!0,"show-close":!1,"before-close":_vm.closeWizard},on:{"update:visible":function($event){_vm.canShowWizard=$event}}},[_c("template",{slot:"title"},[_vm.isResourceModule?_c("div",{staticClass:"resource-title-container"},[_c("div",{staticClass:"resource-header"},[_c("div",{staticClass:"resource-title"},[_vm._v("\n          "+_vm._s(_vm.title)+"\n        ")]),_vm._v(" "),_c("div",{staticClass:"el-dialog__close el-icon el-icon-close close-icon cursor-pointer",on:{click:_vm.closeLookupWizard}})]),_vm._v(" "),_c("div",{staticClass:"title-seperator"})]):_vm._e(),_vm._v(" "),_c("div",{staticClass:"list-actions-headers"},[_vm.isResourceModule?_c("div",{staticClass:"lookup-wizard-title"},[_c("Select",{staticClass:"f-ui-select w-full f-ui-select-tag",attrs:{"default-first-option":"",filterable:""},on:{change:_vm.setResourceModule},model:{value:_vm.subModuleName,callback:function($$v){_vm.subModuleName=$$v},expression:"subModuleName"}},_vm._l(_vm.resourceSubModules,(function(module,index){return _c("Option",{key:index,staticClass:"f-ui-select-item width100",attrs:{label:module.label,value:module.value}})})),1)],1):_c("div",{staticClass:"lookup-wizard-title"},[_vm._v("\n        "+_vm._s(_vm.title)+"\n      ")]),_vm._v(" "),_c("div",{staticClass:"ml-auto flex items-center"},[[_vm.quickSearchEnabled?[_c("div",{staticStyle:{cursor:"pointer"},on:{click:function($event){_vm.showQuickFilter=!_vm.showQuickFilter}}},[_c("fc-icon",{attrs:{group:"action",name:"search",size:"18"}})],1),_vm._v(" "),_c("span",{staticClass:"separator"},[_vm._v("|")])]:[_c("div",{staticClass:"f-mainfield-search"},[_vm.actualMainfield?_c("MainFieldSearch",{attrs:{search:_vm.searchText,mainFieldObj:_vm.actualMainfield},on:{"update:search":function($event){_vm.searchText=$event}}}):_vm._e()],1),_vm._v(" "),_vm.actualMainfield?_c("span",{staticClass:"separator"},[_vm._v("|")]):_vm._e()],_vm._v(" "),_c("div",{on:{click:function($event){_vm.showAdvWizard=!0}}},[_vm.quickSearchEnabled?[_c("fc-icon",{attrs:{group:"filter",name:"filter",size:"18"}})]:[_c("AdvancedFilterIcon",{staticClass:"advance-filter-icon"})],_vm._v(" "),_c("Dialog",{attrs:{visible:_vm.showAdvWizard,"append-to-body":!0,"show-close":!0,fullscreen:!0,"custom-class":"advance-search-dialog",title:"Filter "+_vm.moduleName+" by"},on:{"update:visible":function($event){_vm.showAdvWizard=$event}}},[_vm.showAdvWizard?[_c("AdvancedSearch",{ref:"advancedSearch",attrs:{moduleName:_vm.moduleName,hideQuery:!0,filterList:_vm.filters,showAdvWizard:_vm.showAdvWizard},on:{applyFilters:_vm.applyFilters,closeDialog:function($event){_vm.showAdvWizard=!1}}})]:_vm._e()],2)],2),_vm._v(" "),_c("span",{staticClass:"separator"},[_vm._v("|")])],_vm._v(" "),_c("Pagination",{staticClass:"self-center",attrs:{currentPage:_vm.page,total:_vm.totalCount,perPage:_vm.perPage},on:{"update:currentPage":function($event){_vm.page=$event},"update:current-page":function($event){_vm.page=$event}}}),_vm._v(" "),_vm.totalCount&&!_vm.isResourceModule?_c("span",{staticClass:"separator"},[_vm._v("|")]):_vm._e(),_vm._v(" "),_vm.isResourceModule?_vm._e():_c("div",{staticClass:"el-dialog__close el-icon el-icon-close close-icon cursor-pointer",on:{click:_vm.closeWizard}})],2)]),_vm._v(" "),_vm.isResourceModule?_c("div",["site"!==_vm.subModuleName?_c("div",{staticClass:"title-seperator"}):_vm._e(),_vm._v(" "),_c("ResourceFilters",{attrs:{subModuleName:_vm.subModuleName,siteId:_vm.siteId},on:{resourceFilter:_vm.setResourceFilter}})],1):_vm._e()]),_vm._v(" "),_vm.showFTags?_c("div",{staticClass:"wizard-f-tag-container"},[_c("FTags",{attrs:{moduleName:_vm.moduleName,filters:_vm.filters,hideQuery:!0,hideSaveAs:!0},on:{updateFilters:_vm.updateFilters,clearFilters:function($event){_vm.filters={}}}})],1):_vm._e(),_vm._v(" "),_vm.isEmpty(_vm.selectedItemName)?_vm._e():_c("div",{staticClass:"flex items-center ml-5 my-4"},[_c("div",{staticClass:"mr-3"},[_vm._v(_vm._s(_vm.selectedLabel)+":")]),_vm._v(" "),_c("div",{staticClass:"flex flex-wrap w-10/12"},_vm._l(_vm.selectedItemName,(function(name,index){return _c("Tag",{key:index,staticClass:"f-ui-tag flex items-center mr-2 my-1",on:{click:function(){return _vm.handleSelectedClose(name)}}},[_c("span",[_vm._v(_vm._s(name))]),_vm._v(" "),_vm.multiSelect?_c("i",{staticClass:"el-icon-close pointer"}):_vm._e()])})),1)]),_vm._v(" "),_vm.isLoading&&!_vm.showQuickFilter?_c("div",{staticClass:"flex justify-center"},[_c("Spinner",{attrs:{show:_vm.isLoading}})],1):_vm.isEmpty(_vm.moduleList)&&!_vm.showQuickFilter?_c("div",{staticClass:"f-ui-lookup-empty"},[_c("EmptyIcon",{staticClass:"w-40 h-40"}),_vm._v(" "),_c("div",{staticClass:"mT10 label-txt-black text-md"},[_vm._v("\n      No "+_vm._s(_vm.moduleDisplayName?_vm.moduleDisplayName:_vm.moduleName)+"s available\n    ")])],1):_c("div",{staticClass:"f-ui-lookup-table-container"},[_c("CommonList",{ref:"lookupCommonList",attrs:{viewDetail:_vm.viewDetail,records:_vm.moduleList,moduleName:_vm.moduleName,slotList:_vm.slotList,hideListSelect:!_vm.multiSelect,showQuickFilter:_vm.showQuickFilter,isLoading:_vm.isLoading},on:{"selection-change":_vm.handleSelection,quickFilter:_vm.quickSearchRecord},scopedSlots:_vm._u([{key:"select",fn:function(ref){var record=ref.record;return[_vm.multiSelect?_vm._e():_c("Radio",{attrs:{label:record.id},on:{change:_vm.setSelectedItem},model:{value:_vm.selectedItemId,callback:function($$v){_vm.selectedItemId=$$v},expression:"selectedItemId"}})]}},_vm.actualMainfield?{key:_vm.slotList[1].criteria,fn:function(ref){var record=ref.record;return[_vm._v("\n        "+_vm._s(_vm.getMainFieldValue(record)))]}}:{key:_vm.slotList[1].name,fn:function(ref){var record=ref.record;return[_vm._v("\n        "+_vm._s(_vm.getMainFieldValue(record)))]}}],null,!0)}),_vm._v(" "),_vm.multiSelect?_c("div",{staticClass:"flex mt-auto"},[_c("Button",{staticClass:"modal-btn-cancel modal-btn",on:{click:_vm.closeLookupWizard}},[_vm._v("\n        Cancel\n      ")]),_vm._v(" "),_c("Button",{staticClass:"modal-btn-save modal-btn",attrs:{type:"primary"},on:{click:_vm.setSelectedItem}},[_vm._v("\n        Save\n      ")])],1):_vm._e()],1)],2)},__vue_staticRenderFns__$8=[];
/* style */
const __vue_inject_styles__$9=function(inject){inject&&inject("data-v-35eef92f_0",{source:".advance-search-dialog.is-fullscreen{width:35%;overflow:hidden;height:100vh;display:flex;flex-direction:column;margin-right:0;margin-top:0}.advance-search-dialog .el-dialog__body{display:flex;flex-direction:column;overflow:scroll;height:100%;padding:0;margin-top:8px}.f-ui-lookup-wizard .f-mainfield-search .el-input__inner{height:26px!important;line-height:26px!important}.f-ui-lookup-wizard .f-mainfield-search .el-input__icon{line-height:26px!important}.f-ui-lookup-wizard .wizard-f-tag-container{margin-left:6px}.f-ui-lookup-wizard .el-dialog{margin-top:2vh!important}.f-ui-lookup-wizard .advance-filter-icon{box-sizing:content-box;cursor:pointer;height:15px;width:15px;padding:4px;border-radius:4px;border:1px solid transparent}.f-ui-lookup-wizard .advance-filter-icon:hover{color:#615e88;background:#f5f6f8;border-color:#dae0e8}.f-ui-lookup-wizard .resource-title-container .resource-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:4px;padding:10px 20px}.f-ui-lookup-wizard .resource-title-container .resource-title{height:28px;font-weight:500;font-size:16px}.f-ui-lookup-wizard .title-seperator{height:1px;background-color:#ebeff3}.f-ui-lookup-wizard .list-actions-headers{display:flex;align-items:center;padding:10px 20px}.f-ui-lookup-wizard .f-ui-lookup-empty{height:600px;display:flex;flex-direction:column;justify-content:center;align-items:center}.f-ui-lookup-wizard .btn-active{font-size:14px;font-weight:700;letter-spacing:.5px;color:#324056}.f-ui-lookup-wizard .btn-not-active{color:#ccc;font-weight:50}.f-ui-lookup-wizard .el-radio__label{visibility:hidden}.f-ui-lookup-wizard .lookup-wizard-title{font-size:14px;font-weight:700;color:#324056;text-transform:uppercase;line-height:24px}.f-ui-lookup-wizard .lookup-wizard-title .uppercase{text-transform:uppercase}.f-ui-lookup-wizard .lookup-wizard-title .el-input__inner{height:28px!important;line-height:28px!important}.f-ui-lookup-wizard .lookup-wizard-title .el-input__suffix i{line-height:28px!important}.f-ui-lookup-wizard .el-table__cell{padding:12px 20px!important}.f-ui-lookup-wizard .el-table__cell:first-child{padding:0 10px 0 20px!important}.f-ui-lookup-wizard .separator{font-weight:300;color:#d8d8d8!important;padding-right:10px;padding-left:10px;padding-bottom:2px}.f-ui-lookup-wizard .close-icon{font-size:15px;padding:4px 3px;border-radius:4px;border:1px solid transparent}.f-ui-lookup-wizard .close-icon:hover{color:#615e88;background:#f5f6f8;border:1px solid #dae0e8}.f-ui-lookup-wizard .el-dialog__header{border-bottom:1px solid #eee;padding:0!important}.f-ui-lookup-wizard .el-dialog__body{padding:0}.f-ui-lookup-wizard .el-dialog__body .f-ui-lookup-table-container{height:550px}.f-ui-lookup-wizard .el-dialog__body .f-ui-lookup-table-container .el-table th>.cell{font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:.5px;color:#333;white-space:nowrap}.f-ui-lookup-wizard .el-checkbox__input.is-checked .el-checkbox__inner,.f-ui-lookup-wizard .el-checkbox__input.is-indeterminate .el-checkbox__inner,.f-ui-lookup-wizard .el-radio__input.is-checked .el-radio__inner{background-color:#39b2c2;border-color:#39b2c2}.f-ui-lookup-wizard .el-checkbox__input.is-indeterminate .el-checkbox__inner{margin-left:5px}.f-ui-lookup-wizard .modal-btn-cancel{color:#8f8f8f;border-color:#8f8f8f;background-color:#f4f4f4}.f-ui-lookup-wizard .modal-btn-save{background-color:#39b2c2;color:#fff}.f-ui-lookup-wizard .modal-btn{width:50%;padding-top:18px;padding-bottom:18px;cursor:pointer;border:transparent;letter-spacing:1.1px;text-align:center;text-transform:uppercase;font-weight:500;border-radius:0;float:right;line-height:16px;cursor:pointer;margin:0}.f-ui-lookup-wizard .wizard-search-container{margin-right:5px}.f-ui-lookup-wizard .wizard-search-container .f-ui-forms .el-input__icon{display:flex;align-items:center;justify-content:center}.f-ui-lookup-wizard .wizard-search-container .f-ui-forms .f-ui-text-input .el-input__inner{height:30px;padding-left:30px}",map:void 0,media:void 0})},__vue_scope_id__$9=void 0,__vue_module_identifier__$9=void 0,__vue_is_functional_template__$9=!1,__vue_component__$8=normalizeComponent$a({render:__vue_render__$8,staticRenderFns:__vue_staticRenderFns__$8},__vue_inject_styles__$9,__vue_script__$9,__vue_scope_id__$9,__vue_is_functional_template__$9,__vue_module_identifier__$9,!1,createInjector$7,void 0,void 0);
/* scoped */var _default$2={el:{colorpicker:{confirm:"OK",clear:"Clear"},datepicker:{now:"Now",today:"Today",cancel:"Cancel",clear:"Clear",confirm:"OK",selectDate:"Select date",selectTime:"Select time",startDate:"Start Date",startTime:"Start Time",endDate:"End Date",endTime:"End Time",prevYear:"Previous Year",nextYear:"Next Year",prevMonth:"Previous Month",nextMonth:"Next Month",year:"",month1:"January",month2:"February",month3:"March",month4:"April",month5:"May",month6:"June",month7:"July",month8:"August",month9:"September",month10:"October",month11:"November",month12:"December",week:"week",weeks:{sun:"Sun",mon:"Mon",tue:"Tue",wed:"Wed",thu:"Thu",fri:"Fri",sat:"Sat"},months:{jan:"Jan",feb:"Feb",mar:"Mar",apr:"Apr",may:"May",jun:"Jun",jul:"Jul",aug:"Aug",sep:"Sep",oct:"Oct",nov:"Nov",dec:"Dec"}},select:{loading:"Loading",noMatch:"No matching data",noData:"No data",placeholder:"Select"},cascader:{noMatch:"No matching data",loading:"Loading",placeholder:"Select",noData:"No data"},pagination:{goto:"Go to",pagesize:"/page",total:"Total {total}",pageClassifier:""},messagebox:{title:"Message",confirm:"OK",cancel:"Cancel",error:"Illegal input"},upload:{deleteTip:"press delete to remove",delete:"Delete",preview:"Preview",continue:"Continue"},table:{emptyText:"No Data",confirmFilter:"Confirm",resetFilter:"Reset",clearFilter:"All",sumText:"Sum"},tree:{emptyText:"No Data"},transfer:{noMatch:"No matching data",noData:"No data",titles:["List 1","List 2"],// to be translated
filterPlaceholder:"Enter keyword",// to be translated
noCheckedFormat:"{total} items",// to be translated
hasCheckedFormat:"{checked}/{total} checked"},image:{error:"FAILED"},pageHeader:{title:"Back"},popconfirm:{confirmButtonText:"Yes",cancelButtonText:"No"},empty:{description:"No Data"}}};function getDefaultExportFromCjs(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,"default")?x["default"]:x}function getAugmentedNamespace(n){if(n.__esModule)return n;var a=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(n).forEach((function(k){var d=Object.getOwnPropertyDescriptor(n,k);Object.defineProperty(a,k,d.get?d:{enumerable:!0,get:function(){return n[k]}})})),a}function createCommonjsModule$1(fn){var module={exports:{}};return fn(module,module.exports),module.exports}var _default$1={el:{colorpicker:{confirm:"确定",clear:"清空"},datepicker:{now:"此刻",today:"今天",cancel:"取消",clear:"清空",confirm:"确定",selectDate:"选择日期",selectTime:"选择时间",startDate:"开始日期",startTime:"开始时间",endDate:"结束日期",endTime:"结束时间",prevYear:"前一年",nextYear:"后一年",prevMonth:"上个月",nextMonth:"下个月",year:"年",month1:"1 月",month2:"2 月",month3:"3 月",month4:"4 月",month5:"5 月",month6:"6 月",month7:"7 月",month8:"8 月",month9:"9 月",month10:"10 月",month11:"11 月",month12:"12 月",
// week: '周次',
weeks:{sun:"日",mon:"一",tue:"二",wed:"三",thu:"四",fri:"五",sat:"六"},months:{jan:"一月",feb:"二月",mar:"三月",apr:"四月",may:"五月",jun:"六月",jul:"七月",aug:"八月",sep:"九月",oct:"十月",nov:"十一月",dec:"十二月"}},select:{loading:"加载中",noMatch:"无匹配数据",noData:"无数据",placeholder:"请选择"},cascader:{noMatch:"无匹配数据",loading:"加载中",placeholder:"请选择",noData:"暂无数据"},pagination:{goto:"前往",pagesize:"条/页",total:"共 {total} 条",pageClassifier:"页"},messagebox:{title:"提示",confirm:"确定",cancel:"取消",error:"输入的数据不合法!"},upload:{deleteTip:"按 delete 键可删除",delete:"删除",preview:"查看图片",continue:"继续上传"},table:{emptyText:"暂无数据",confirmFilter:"筛选",resetFilter:"重置",clearFilter:"全部",sumText:"合计"},tree:{emptyText:"暂无数据"},transfer:{noMatch:"无匹配数据",noData:"无数据",titles:["列表 1","列表 2"],filterPlaceholder:"请输入搜索内容",noCheckedFormat:"共 {total} 项",hasCheckedFormat:"已选 {checked}/{total} 项"},image:{error:"加载失败"},pageHeader:{title:"返回"},popconfirm:{confirmButtonText:"确定",cancelButtonText:"取消"},empty:{description:"暂无数据"}}},zhCN=Object.defineProperty({default:_default$1},"__esModule",{value:!0}),isMergeableObject=function(value){return isNonNullObject(value)&&!isSpecial(value)};function isNonNullObject(value){return!!value&&"object"===typeof value}function isSpecial(value){var stringValue=Object.prototype.toString.call(value);return"[object RegExp]"===stringValue||"[object Date]"===stringValue||isReactElement(value)}
// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol="function"===typeof Symbol&&Symbol.for,REACT_ELEMENT_TYPE=canUseSymbol?Symbol.for("react.element"):60103;function isReactElement(value){return value.$$typeof===REACT_ELEMENT_TYPE}function emptyTarget(val){return Array.isArray(val)?[]:{}}function cloneIfNecessary(value,optionsArgument){var clone=optionsArgument&&!0===optionsArgument.clone;return clone&&isMergeableObject(value)?deepmerge(emptyTarget(value),value,optionsArgument):value}function defaultArrayMerge(target,source,optionsArgument){var destination=target.slice();return source.forEach((function(e,i){"undefined"===typeof destination[i]?destination[i]=cloneIfNecessary(e,optionsArgument):isMergeableObject(e)?destination[i]=deepmerge(target[i],e,optionsArgument):-1===target.indexOf(e)&&destination.push(cloneIfNecessary(e,optionsArgument))})),destination}function mergeObject(target,source,optionsArgument){var destination={};return isMergeableObject(target)&&Object.keys(target).forEach((function(key){destination[key]=cloneIfNecessary(target[key],optionsArgument)})),Object.keys(source).forEach((function(key){isMergeableObject(source[key])&&target[key]?destination[key]=deepmerge(target[key],source[key],optionsArgument):destination[key]=cloneIfNecessary(source[key],optionsArgument)})),destination}function deepmerge(target,source,optionsArgument){var sourceIsArray=Array.isArray(source),targetIsArray=Array.isArray(target),options=optionsArgument||{arrayMerge:defaultArrayMerge},sourceAndTargetTypesMatch=sourceIsArray===targetIsArray;if(sourceAndTargetTypesMatch){if(sourceIsArray){var arrayMerge=options.arrayMerge||defaultArrayMerge;return arrayMerge(target,source,optionsArgument)}return mergeObject(target,source,optionsArgument)}return cloneIfNecessary(source,optionsArgument)}deepmerge.all=function(array,optionsArgument){if(!Array.isArray(array)||array.length<2)throw new Error("first argument should be an array with at least two elements");
// we are sure there are at least 2 values, so it is safe to have no initial value
return array.reduce((function(prev,next){return deepmerge(prev,next,optionsArgument)}))};var deepmerge_1=deepmerge,es=Object.freeze({__proto__:null,default:deepmerge_1}),types=createCommonjsModule$1((function(module,exports){exports.__esModule=!0,exports.isDefined=exports.isUndefined=exports.isFunction=void 0;var _typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj};exports.isString=isString,exports.isObject=isObject,exports.isHtmlElement=isHtmlElement;var _vue2=_interopRequireDefault(vue_runtime_esm["default"]);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function isString(obj){return"[object String]"===Object.prototype.toString.call(obj)}function isObject(obj){return"[object Object]"===Object.prototype.toString.call(obj)}function isHtmlElement(node){return node&&node.nodeType===Node.ELEMENT_NODE}
/**
 *  - Inspired:
 *    https://github.com/jashkenas/underscore/blob/master/modules/isFunction.js
 */var isFunction=function(functionToCheck){var getType={};return functionToCheck&&"[object Function]"===getType.toString.call(functionToCheck)};"object"===("undefined"===typeof Int8Array?"undefined":_typeof(Int8Array))||!_vue2.default.prototype.$isServer&&"function"===typeof document.childNodes||(exports.isFunction=isFunction=function(obj){return"function"===typeof obj||!1}),exports.isFunction=isFunction,exports.isUndefined=function(val){return void 0===val},exports.isDefined=function(val){return void 0!==val&&null!==val}})),util=createCommonjsModule$1((function(module,exports){exports.__esModule=!0,exports.isMac=exports.isEmpty=exports.isEqual=exports.arrayEquals=exports.looseEqual=exports.capitalize=exports.kebabCase=exports.autoprefixer=exports.isFirefox=exports.isEdge=exports.isIE=exports.coerceTruthyValueToArray=exports.arrayFind=exports.arrayFindIndex=exports.escapeRegexpString=exports.valueEquals=exports.generateId=exports.getValueByPath=void 0;var _typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj};exports.noop=noop,exports.hasOwn=hasOwn,exports.toObject=toObject,exports.getPropByPath=getPropByPath,exports.rafThrottle=rafThrottle,exports.objToArray=objToArray;var _vue2=_interopRequireDefault(vue_runtime_esm["default"]);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}var hasOwnProperty=Object.prototype.hasOwnProperty;function noop(){}function hasOwn(obj,key){return hasOwnProperty.call(obj,key)}function extend(to,_from){for(var key in _from)to[key]=_from[key];return to}function toObject(arr){for(var res={},i=0;i<arr.length;i++)arr[i]&&extend(res,arr[i]);return res}function getPropByPath(obj,path,strict){var tempObj=obj;path=path.replace(/\[(\w+)\]/g,".$1"),path=path.replace(/^\./,"");for(var keyArr=path.split("."),i=0,len=keyArr.length;i<len-1;++i){if(!tempObj&&!strict)break;var key=keyArr[i];if(!(key in tempObj)){if(strict)throw new Error("please transfer a valid prop path to form item!");break}tempObj=tempObj[key]}return{o:tempObj,k:keyArr[i],v:tempObj?tempObj[keyArr[i]]:null}}exports.getValueByPath=function(object,prop){prop=prop||"";for(var paths=prop.split("."),current=object,result=null,i=0,j=paths.length;i<j;i++){var path=paths[i];if(!current)break;if(i===j-1){result=current[path];break}current=current[path]}return result},exports.generateId=function(){return Math.floor(1e4*Math.random())},exports.valueEquals=function(a,b){
// see: https://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript
if(a===b)return!0;if(!(a instanceof Array))return!1;if(!(b instanceof Array))return!1;if(a.length!==b.length)return!1;for(var i=0;i!==a.length;++i)if(a[i]!==b[i])return!1;return!0},exports.escapeRegexpString=function(){var value=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return String(value).replace(/[|\\{}()[\]^$+*?.]/g,"\\$&")};
// TODO: use native Array.find, Array.findIndex when IE support is dropped
var arrayFindIndex=exports.arrayFindIndex=function(arr,pred){for(var i=0;i!==arr.length;++i)if(pred(arr[i]))return i;return-1};exports.arrayFind=function(arr,pred){var idx=arrayFindIndex(arr,pred);return-1!==idx?arr[idx]:void 0},
// coerce truthy value to array
exports.coerceTruthyValueToArray=function(val){return Array.isArray(val)?val:val?[val]:[]},exports.isIE=function(){return!_vue2.default.prototype.$isServer&&!isNaN(Number(document.documentMode))},exports.isEdge=function(){return!_vue2.default.prototype.$isServer&&navigator.userAgent.indexOf("Edge")>-1},exports.isFirefox=function(){return!_vue2.default.prototype.$isServer&&!!window.navigator.userAgent.match(/firefox/i)},exports.autoprefixer=function(style){if("object"!==("undefined"===typeof style?"undefined":_typeof(style)))return style;var rules=["transform","transition","animation"],prefixes=["ms-","webkit-"];return rules.forEach((function(rule){var value=style[rule];rule&&value&&prefixes.forEach((function(prefix){style[prefix+rule]=value}))})),style},exports.kebabCase=function(str){var hyphenateRE=/([^-])([A-Z])/g;return str.replace(hyphenateRE,"$1-$2").replace(hyphenateRE,"$1-$2").toLowerCase()},exports.capitalize=function(str){return(0,types.isString)(str)?str.charAt(0).toUpperCase()+str.slice(1):str};var looseEqual=exports.looseEqual=function(a,b){var isObjectA=(0,types.isObject)(a),isObjectB=(0,types.isObject)(b);return isObjectA&&isObjectB?JSON.stringify(a)===JSON.stringify(b):!isObjectA&&!isObjectB&&String(a)===String(b)},arrayEquals=exports.arrayEquals=function(arrayA,arrayB){if(arrayA=arrayA||[],arrayB=arrayB||[],arrayA.length!==arrayB.length)return!1;for(var i=0;i<arrayA.length;i++)if(!looseEqual(arrayA[i],arrayB[i]))return!1;return!0};exports.isEqual=function(value1,value2){return Array.isArray(value1)&&Array.isArray(value2)?arrayEquals(value1,value2):looseEqual(value1,value2)};var isEmpty=exports.isEmpty=function(val){
// null or undefined
if(null==val)return!0;if("boolean"===typeof val)return!1;if("number"===typeof val)return!val;if(val instanceof Error)return""===val.message;switch(Object.prototype.toString.call(val)){
// String or Array
case"[object String]":case"[object Array]":return!val.length;
// Map or Set or File
case"[object File]":case"[object Map]":case"[object Set]":return!val.size;
// Plain Object
case"[object Object]":return!Object.keys(val).length}return!1};function rafThrottle(fn){var locked=!1;return function(){for(var _this=this,_len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];locked||(locked=!0,window.requestAnimationFrame((function(_){fn.apply(_this,args),locked=!1})))}}function objToArray(obj){return Array.isArray(obj)?obj:isEmpty(obj)?[]:[obj]}exports.isMac=function(){return!_vue2.default.prototype.$isServer&&/macintosh|mac os x/i.test(navigator.userAgent)}})),_typeof$2="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_default=function(Vue){
/**
   * template
   *
   * @param {String} string
   * @param {Array} ...args
   * @return {String}
   */
function template(string){for(var _len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];return 1===args.length&&"object"===_typeof$2(args[0])&&(args=args[0]),args&&args.hasOwnProperty||(args={}),string.replace(RE_NARGS,(function(match,prefix,i,index){var result=void 0;return"{"===string[index-1]&&"}"===string[index+match.length]?i:(result=(0,util.hasOwn)(args,i)?args[i]:null,null===result||void 0===result?"":result)}))}return template},RE_NARGS=/(%|)\{([0-9a-zA-Z_]+)\}/g,format=Object.defineProperty({default:_default},"__esModule",{value:!0}),_deepmerge=getAugmentedNamespace(es),locale=createCommonjsModule$1((function(module,exports){exports.__esModule=!0,exports.i18n=exports.use=exports.t=void 0;var _zhCN2=_interopRequireDefault(zhCN),_vue2=_interopRequireDefault(vue_runtime_esm["default"]),_deepmerge2=_interopRequireDefault(_deepmerge),_format2=_interopRequireDefault(format);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}var format$1=(0,_format2.default)(_vue2.default),lang=_zhCN2.default,merged=!1,i18nHandler=function(){var vuei18n=Object.getPrototypeOf(this||_vue2.default).$t;if("function"===typeof vuei18n&&_vue2.default.locale)return merged||(merged=!0,_vue2.default.locale(_vue2.default.config.lang,(0,_deepmerge2.default)(lang,_vue2.default.locale(_vue2.default.config.lang)||{},{clone:!0}))),vuei18n.apply(this,arguments)},t=exports.t=function(path,options){var value=i18nHandler.apply(this,arguments);if(null!==value&&void 0!==value)return value;for(var array=path.split("."),current=lang,i=0,j=array.length;i<j;i++){var property=array[i];if(value=current[property],i===j-1)return format$1(value,options);if(!value)return"";current=value}return""},use=exports.use=function(l){lang=l||lang},i18n=exports.i18n=function(fn){i18nHandler=fn||i18nHandler};exports.default={use:use,t:t,i18n:i18n}})),locale$1=getDefaultExportFromCjs(locale);
// configure language
locale$1.use(_default$2);var script$8={name:"Datepicker",props:["appendToBody","value","value-format","format","default-value","placeholder","disabled","editable","picker-options","type","prefix-icon","clear-icon","start-placeholder","end-placeholder","hideClear","account"],components:{DatePicker:element_ui_common.DatePicker},mounted(){this.init()},data(){return{timeinorg:[]}},computed:{isRangeType(){let{type:type}=this||{};return["daterange","datetimerange"].includes(type)},defaultFormats(){let{timeformat:timeformat,dateformat:dateformat}=this;return dateformat=dateformat.replaceAll("Y","y"),dateformat=dateformat.replaceAll("D","d"),{date:dateformat,month:"yyyy-MM",datetime:`${dateformat} ${timeformat}`,time:`${timeformat}`,week:"yyyywWW",timerange:`${timeformat}`,daterange:`${dateformat}`,monthrange:"yyyy-MM",datetimerange:`${dateformat} ${timeformat}`,year:"yyyy"}},pickerFormat(){let{defaultFormats:defaultFormats,type:type,format:format}=this||{};return isEmpty$a(format)&&!isEmpty$a(defaultFormats[type])?defaultFormats[type]:format},ttime:{get(){let{value:value,isRangeType:isRangeType}=this||{};return isEmpty$a(value)?isRangeType?[]:"":isRangeType?value.map((val=>this.getTimeInSystemZone(val))):this.getTimeInSystemZone(value)},set(value){let{isRangeType:isRangeType}=this,timeInOrg=[];if(isRangeType){if(isEmpty$a(value))timeInOrg=[];else for(let time in value)timeInOrg[time]=this.getDateInOrg(value[time]);this.$emit("input",timeInOrg),this.$emit("change",timeInOrg)}else{let modifiedTimeFormat=this.getDateInOrg(value);this.$emit("input",modifiedTimeFormat),this.$emit("change",modifiedTimeFormat)}}},dateformat(){let{account:account={}}=this||{},dateFormat=dlv_umd(account,"org.dateFormat","DD-MMM-YYYY");return dateFormat||"DD-MMM-YYYY"},timeformat(){let{account:account={}}=this||{},timeFormat=dlv_umd(account,"org.timeFormat");return 2===timeFormat?"hh:mm A":"HH:mm"},timezone(){let timezone,{account:account={}}=this||{};if((account||{}).timezone){let{timezone:accountTimeZone}=account||{};timezone=accountTimeZone||"Etc/UTC"}else{let orgTimeZone=dlv_umd(account,"org.timezone");timezone=orgTimeZone||"Etc/UTC"}return timezone}},methods:{init(){let{isRangeType:isRangeType,value:value}=this,timeInOrg=[];if(isRangeType){if(isEmpty$a(value))timeInOrg=[];else for(let time in value){let timeVal=parseInt(value[time]);timeInOrg[time]=this.getDateInOrg(timeVal)}this.$emit("input",timeInOrg)}else if(!isEmpty$a(value)){let isPlaceHoldersEnabled=Constants$3.FIELD_PLACEHOLDERS.includes(value)||!1;isPlaceHoldersEnabled||this.$emit("input",this.getDateInOrg(parseInt(value)))}this.$emit("initialized")},focus(){this.$refs["date-picker"].focus()},getTimeInSystemZone(value){let{timezone:timezone}=this||{};return new Date(moment_timezone.tz(value,timezone||"Etc/UTC").format("YYYY-MM-DD HH:mm:ss"))},getDateInOrg(date){let{timezone:timezone}=this||{};return moment_timezone.tz(moment_timezone(date).format("YYYY-MM-DD HH:mm:ss"),timezone).valueOf()}}};
/* script */const __vue_script__$8=script$8;
/* template */var __vue_render__$7=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"f-ui-forms"},[_c("DatePicker",{ref:"date-picker",staticClass:"f-ui-date-picker",attrs:{appendToBody:_vm.appendToBody,clearable:!_vm.hideClear,type:_vm.type,"value-format":_vm.valueFormat,format:_vm.pickerFormat,placeholder:_vm.placeholder,disabled:_vm.disabled,editable:_vm.editable,"default-value":_vm.defaultValue,"picker-options":_vm.pickerOptions,"prefix-icon":_vm.prefixIcon,"clear-icon":_vm.clearIcon,"start-placeholder":_vm.startPlaceholder,"end-placeholder":_vm.endPlaceholder,"popper-class":"f-date-picker-popper"},model:{value:_vm.ttime,callback:function($$v){_vm.ttime=$$v},expression:"ttime"}})],1)},__vue_staticRenderFns__$7=[];
/* style */
const __vue_inject_styles__$8=void 0,__vue_scope_id__$8=void 0,__vue_module_identifier__$8=void 0,__vue_is_functional_template__$8=!1,__vue_component__$7=normalizeComponent$a({render:__vue_render__$7,staticRenderFns:__vue_staticRenderFns__$7},__vue_inject_styles__$8,__vue_script__$8,__vue_scope_id__$8,__vue_is_functional_template__$8,__vue_module_identifier__$8,!1,void 0,void 0,void 0);
/* scoped */
/*! @license DOMPurify 2.4.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.7/LICENSE */
function _typeof$1(obj){return _typeof$1="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof$1(obj)}function _setPrototypeOf(o,p){return _setPrototypeOf=Object.setPrototypeOf||function(o,p){return o.__proto__=p,o},_setPrototypeOf(o,p)}function _isNativeReflectConstruct(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}function _construct(Parent,args,Class){return _construct=_isNativeReflectConstruct()?Reflect.construct:function(Parent,args,Class){var a=[null];a.push.apply(a,args);var Constructor=Function.bind.apply(Parent,a),instance=new Constructor;return Class&&_setPrototypeOf(instance,Class.prototype),instance},_construct.apply(null,arguments)}function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_unsupportedIterableToArray(arr)||_nonIterableSpread()}function _arrayWithoutHoles(arr){if(Array.isArray(arr))return _arrayLikeToArray(arr)}function _iterableToArray(iter){if("undefined"!==typeof Symbol&&null!=iter[Symbol.iterator]||null!=iter["@@iterator"])return Array.from(iter)}function _unsupportedIterableToArray(o,minLen){if(o){if("string"===typeof o)return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);return"Object"===n&&o.constructor&&(n=o.constructor.name),"Map"===n||"Set"===n?Array.from(o):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?_arrayLikeToArray(o,minLen):void 0}}function _arrayLikeToArray(arr,len){(null==len||len>arr.length)&&(len=arr.length);for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var hasOwnProperty$1=Object.hasOwnProperty,setPrototypeOf=Object.setPrototypeOf,isFrozen=Object.isFrozen,getPrototypeOf=Object.getPrototypeOf,getOwnPropertyDescriptor=Object.getOwnPropertyDescriptor,freeze=Object.freeze,seal=Object.seal,create=Object.create,_ref="undefined"!==typeof Reflect&&Reflect,apply$1=_ref.apply,construct=_ref.construct;apply$1||(apply$1=function(fun,thisValue,args){return fun.apply(thisValue,args)}),freeze||(freeze=function(x){return x}),seal||(seal=function(x){return x}),construct||(construct=function(Func,args){return _construct(Func,_toConsumableArray(args))});var arrayForEach=unapply(Array.prototype.forEach),arrayPop=unapply(Array.prototype.pop),arrayPush=unapply(Array.prototype.push),stringToLowerCase=unapply(String.prototype.toLowerCase),stringToString=unapply(String.prototype.toString),stringMatch=unapply(String.prototype.match),stringReplace=unapply(String.prototype.replace),stringIndexOf=unapply(String.prototype.indexOf),stringTrim=unapply(String.prototype.trim),regExpTest=unapply(RegExp.prototype.test),typeErrorCreate=unconstruct(TypeError);function unapply(func){return function(thisArg){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];return apply$1(func,thisArg,args)}}function unconstruct(func){return function(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++)args[_key2]=arguments[_key2];return construct(func,args)}}
/* Add properties to a lookup table */function addToSet(set,array,transformCaseFunc){var _transformCaseFunc;transformCaseFunc=null!==(_transformCaseFunc=transformCaseFunc)&&void 0!==_transformCaseFunc?_transformCaseFunc:stringToLowerCase,setPrototypeOf&&
// Make 'in' and truthy checks like Boolean(set.constructor)
// independent of any properties defined on Object.prototype.
// Prevent prototype setters from intercepting set as a this value.
setPrototypeOf(set,null);var l=array.length;while(l--){var element=array[l];if("string"===typeof element){var lcElement=transformCaseFunc(element);lcElement!==element&&(
// Config presets (e.g. tags.js, attrs.js) are immutable.
isFrozen(array)||(array[l]=lcElement),element=lcElement)}set[element]=!0}return set}
/* Shallow clone an object */function clone(object){var property,newObject=create(null);for(property in object)!0===apply$1(hasOwnProperty$1,object,[property])&&(newObject[property]=object[property]);return newObject}
/* IE10 doesn't support __lookupGetter__ so lets'
 * simulate it. It also automatically checks
 * if the prop is function or getter and behaves
 * accordingly. */function lookupGetter(object,prop){while(null!==object){var desc=getOwnPropertyDescriptor(object,prop);if(desc){if(desc.get)return unapply(desc.get);if("function"===typeof desc.value)return unapply(desc.value)}object=getPrototypeOf(object)}function fallbackValue(element){return null}return fallbackValue}var html$1=freeze(["a","abbr","acronym","address","area","article","aside","audio","b","bdi","bdo","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","content","data","datalist","dd","decorator","del","details","dfn","dialog","dir","div","dl","dt","element","em","fieldset","figcaption","figure","font","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","img","input","ins","kbd","label","legend","li","main","map","mark","marquee","menu","menuitem","meter","nav","nobr","ol","optgroup","option","output","p","picture","pre","progress","q","rp","rt","ruby","s","samp","section","select","shadow","small","source","spacer","span","strike","strong","style","sub","summary","sup","table","tbody","td","template","textarea","tfoot","th","thead","time","tr","track","tt","u","ul","var","video","wbr"]),svg$1=freeze(["svg","a","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","circle","clippath","defs","desc","ellipse","filter","font","g","glyph","glyphref","hkern","image","line","lineargradient","marker","mask","metadata","mpath","path","pattern","polygon","polyline","radialgradient","rect","stop","style","switch","symbol","text","textpath","title","tref","tspan","view","vkern"]),svgFilters=freeze(["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]),svgDisallowed=freeze(["animate","color-profile","cursor","discard","fedropshadow","font-face","font-face-format","font-face-name","font-face-src","font-face-uri","foreignobject","hatch","hatchpath","mesh","meshgradient","meshpatch","meshrow","missing-glyph","script","set","solidcolor","unknown","use"]),mathMl$1=freeze(["math","menclose","merror","mfenced","mfrac","mglyph","mi","mlabeledtr","mmultiscripts","mn","mo","mover","mpadded","mphantom","mroot","mrow","ms","mspace","msqrt","mstyle","msub","msup","msubsup","mtable","mtd","mtext","mtr","munder","munderover"]),mathMlDisallowed=freeze(["maction","maligngroup","malignmark","mlongdiv","mscarries","mscarry","msgroup","mstack","msline","msrow","semantics","annotation","annotation-xml","mprescripts","none"]),forms_text=freeze(["#text"]),html=freeze(["accept","action","align","alt","autocapitalize","autocomplete","autopictureinpicture","autoplay","background","bgcolor","border","capture","cellpadding","cellspacing","checked","cite","class","clear","color","cols","colspan","controls","controlslist","coords","crossorigin","datetime","decoding","default","dir","disabled","disablepictureinpicture","disableremoteplayback","download","draggable","enctype","enterkeyhint","face","for","headers","height","hidden","high","href","hreflang","id","inputmode","integrity","ismap","kind","label","lang","list","loading","loop","low","max","maxlength","media","method","min","minlength","multiple","muted","name","nonce","noshade","novalidate","nowrap","open","optimum","pattern","placeholder","playsinline","poster","preload","pubdate","radiogroup","readonly","rel","required","rev","reversed","role","rows","rowspan","spellcheck","scope","selected","shape","size","sizes","span","srclang","start","src","srcset","step","style","summary","tabindex","title","translate","type","usemap","valign","value","width","xmlns","slot"]),svg=freeze(["accent-height","accumulate","additive","alignment-baseline","ascent","attributename","attributetype","azimuth","basefrequency","baseline-shift","begin","bias","by","class","clip","clippathunits","clip-path","clip-rule","color","color-interpolation","color-interpolation-filters","color-profile","color-rendering","cx","cy","d","dx","dy","diffuseconstant","direction","display","divisor","dur","edgemode","elevation","end","fill","fill-opacity","fill-rule","filter","filterunits","flood-color","flood-opacity","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","fx","fy","g1","g2","glyph-name","glyphref","gradientunits","gradienttransform","height","href","id","image-rendering","in","in2","k","k1","k2","k3","k4","kerning","keypoints","keysplines","keytimes","lang","lengthadjust","letter-spacing","kernelmatrix","kernelunitlength","lighting-color","local","marker-end","marker-mid","marker-start","markerheight","markerunits","markerwidth","maskcontentunits","maskunits","max","mask","media","method","mode","min","name","numoctaves","offset","operator","opacity","order","orient","orientation","origin","overflow","paint-order","path","pathlength","patterncontentunits","patterntransform","patternunits","points","preservealpha","preserveaspectratio","primitiveunits","r","rx","ry","radius","refx","refy","repeatcount","repeatdur","restart","result","rotate","scale","seed","shape-rendering","specularconstant","specularexponent","spreadmethod","startoffset","stddeviation","stitchtiles","stop-color","stop-opacity","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke","stroke-width","style","surfacescale","systemlanguage","tabindex","targetx","targety","transform","transform-origin","text-anchor","text-decoration","text-rendering","textlength","type","u1","u2","unicode","values","viewbox","visibility","version","vert-adv-y","vert-origin-x","vert-origin-y","width","word-spacing","wrap","writing-mode","xchannelselector","ychannelselector","x","x1","x2","xmlns","y","y1","y2","z","zoomandpan"]),mathMl=freeze(["accent","accentunder","align","bevelled","close","columnsalign","columnlines","columnspan","denomalign","depth","dir","display","displaystyle","encoding","fence","frame","height","href","id","largeop","length","linethickness","lspace","lquote","mathbackground","mathcolor","mathsize","mathvariant","maxsize","minsize","movablelimits","notation","numalign","open","rowalign","rowlines","rowspacing","rowspan","rspace","rquote","scriptlevel","scriptminsize","scriptsizemultiplier","selection","separator","separators","stretchy","subscriptshift","supscriptshift","symmetric","voffset","width","xmlns"]),xml=freeze(["xlink:href","xml:id","xlink:title","xml:space","xmlns:xlink"]),MUSTACHE_EXPR=seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm),ERB_EXPR=seal(/<%[\w\W]*|[\w\W]*%>/gm),TMPLIT_EXPR=seal(/\${[\w\W]*}/gm),DATA_ATTR=seal(/^data-[\-\w.\u00B7-\uFFFF]/),ARIA_ATTR=seal(/^aria-[\-\w]+$/),IS_ALLOWED_URI=seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i),IS_SCRIPT_OR_DATA=seal(/^(?:\w+script|data):/i),ATTR_WHITESPACE=seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),DOCTYPE_NAME=seal(/^html$/i),getGlobal=function(){return"undefined"===typeof window?null:window},_createTrustedTypesPolicy=function(trustedTypes,document){if("object"!==_typeof$1(trustedTypes)||"function"!==typeof trustedTypes.createPolicy)return null;// Allow the callers to control the unique policy name
// by adding a data-tt-policy-suffix to the script element with the DOMPurify.
// Policy creation with duplicate names throws in Trusted Types.
var suffix=null,ATTR_NAME="data-tt-policy-suffix";document.currentScript&&document.currentScript.hasAttribute(ATTR_NAME)&&(suffix=document.currentScript.getAttribute(ATTR_NAME));var policyName="dompurify"+(suffix?"#"+suffix:"");try{return trustedTypes.createPolicy(policyName,{createHTML:function(html){return html},createScriptURL:function(scriptUrl){return scriptUrl}})}catch(_){return null}};// SVG
function createDOMPurify(){var window=arguments.length>0&&void 0!==arguments[0]?arguments[0]:getGlobal(),DOMPurify=function(root){return createDOMPurify(root)};if(
/**
   * Version label, exposed for easier checks
   * if DOMPurify is up to date or not
   */
DOMPurify.version="2.4.7",
/**
   * Array of elements that DOMPurify removed during sanitation.
   * Empty if nothing was removed.
   */
DOMPurify.removed=[],!window||!window.document||9!==window.document.nodeType)
// Not running in a browser, provide a factory function
// so that you can pass your own Window
return DOMPurify.isSupported=!1,DOMPurify;var originalDocument=window.document,document=window.document,DocumentFragment=window.DocumentFragment,HTMLTemplateElement=window.HTMLTemplateElement,Node=window.Node,Element=window.Element,NodeFilter=window.NodeFilter,_window$NamedNodeMap=window.NamedNodeMap,NamedNodeMap=void 0===_window$NamedNodeMap?window.NamedNodeMap||window.MozNamedAttrMap:_window$NamedNodeMap,HTMLFormElement=window.HTMLFormElement,DOMParser=window.DOMParser,trustedTypes=window.trustedTypes,ElementPrototype=Element.prototype,cloneNode=lookupGetter(ElementPrototype,"cloneNode"),getNextSibling=lookupGetter(ElementPrototype,"nextSibling"),getChildNodes=lookupGetter(ElementPrototype,"childNodes"),getParentNode=lookupGetter(ElementPrototype,"parentNode");// As per issue #47, the web-components registry is inherited by a
// new document created via createHTMLDocument. As per the spec
// (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
// a new empty registry is used when creating a template contents owner
// document, so we use that as our parent document to ensure nothing
// is inherited.
if("function"===typeof HTMLTemplateElement){var template=document.createElement("template");template.content&&template.content.ownerDocument&&(document=template.content.ownerDocument)}var trustedTypesPolicy=_createTrustedTypesPolicy(trustedTypes,originalDocument),emptyHTML=trustedTypesPolicy?trustedTypesPolicy.createHTML(""):"",_document=document,implementation=_document.implementation,createNodeIterator=_document.createNodeIterator,createDocumentFragment=_document.createDocumentFragment,getElementsByTagName=_document.getElementsByTagName,importNode=originalDocument.importNode,documentMode={};try{documentMode=clone(document).documentMode?document.documentMode:{}}catch(_){}var hooks={};
/**
   * Expose whether this browser supports running the full DOMPurify.
   */DOMPurify.isSupported="function"===typeof getParentNode&&implementation&&void 0!==implementation.createHTMLDocument&&9!==documentMode;var PARSER_MEDIA_TYPE,transformCaseFunc,MUSTACHE_EXPR$1=MUSTACHE_EXPR,ERB_EXPR$1=ERB_EXPR,TMPLIT_EXPR$1=TMPLIT_EXPR,DATA_ATTR$1=DATA_ATTR,ARIA_ATTR$1=ARIA_ATTR,IS_SCRIPT_OR_DATA$1=IS_SCRIPT_OR_DATA,ATTR_WHITESPACE$1=ATTR_WHITESPACE,IS_ALLOWED_URI$1=IS_ALLOWED_URI,ALLOWED_TAGS=null,DEFAULT_ALLOWED_TAGS=addToSet({},[].concat(_toConsumableArray(html$1),_toConsumableArray(svg$1),_toConsumableArray(svgFilters),_toConsumableArray(mathMl$1),_toConsumableArray(forms_text))),ALLOWED_ATTR=null,DEFAULT_ALLOWED_ATTR=addToSet({},[].concat(_toConsumableArray(html),_toConsumableArray(svg),_toConsumableArray(mathMl),_toConsumableArray(xml))),CUSTOM_ELEMENT_HANDLING=Object.seal(Object.create(null,{tagNameCheck:{writable:!0,configurable:!1,enumerable:!0,value:null},attributeNameCheck:{writable:!0,configurable:!1,enumerable:!0,value:null},allowCustomizedBuiltInElements:{writable:!0,configurable:!1,enumerable:!0,value:!1}})),FORBID_TAGS=null,FORBID_ATTR=null,ALLOW_ARIA_ATTR=!0,ALLOW_DATA_ATTR=!0,ALLOW_UNKNOWN_PROTOCOLS=!1,ALLOW_SELF_CLOSE_IN_ATTR=!0,SAFE_FOR_TEMPLATES=!1,WHOLE_DOCUMENT=!1,SET_CONFIG=!1,FORCE_BODY=!1,RETURN_DOM=!1,RETURN_DOM_FRAGMENT=!1,RETURN_TRUSTED_TYPE=!1,SANITIZE_DOM=!0,SANITIZE_NAMED_PROPS=!1,SANITIZE_NAMED_PROPS_PREFIX="user-content-",KEEP_CONTENT=!0,IN_PLACE=!1,USE_PROFILES={},FORBID_CONTENTS=null,DEFAULT_FORBID_CONTENTS=addToSet({},["annotation-xml","audio","colgroup","desc","foreignobject","head","iframe","math","mi","mn","mo","ms","mtext","noembed","noframes","noscript","plaintext","script","style","svg","template","thead","title","video","xmp"]),DATA_URI_TAGS=null,DEFAULT_DATA_URI_TAGS=addToSet({},["audio","video","img","source","image","track"]),URI_SAFE_ATTRIBUTES=null,DEFAULT_URI_SAFE_ATTRIBUTES=addToSet({},["alt","class","for","id","label","name","pattern","placeholder","role","summary","title","value","style","xmlns"]),MATHML_NAMESPACE="http://www.w3.org/1998/Math/MathML",SVG_NAMESPACE="http://www.w3.org/2000/svg",HTML_NAMESPACE="http://www.w3.org/1999/xhtml",NAMESPACE=HTML_NAMESPACE,IS_EMPTY_INPUT=!1,ALLOWED_NAMESPACES=null,DEFAULT_ALLOWED_NAMESPACES=addToSet({},[MATHML_NAMESPACE,SVG_NAMESPACE,HTML_NAMESPACE],stringToString),SUPPORTED_PARSER_MEDIA_TYPES=["application/xhtml+xml","text/html"],DEFAULT_PARSER_MEDIA_TYPE="text/html",CONFIG=null,formElement=document.createElement("form"),isRegexOrFunction=function(testValue){return testValue instanceof RegExp||testValue instanceof Function},_parseConfig=function(cfg){CONFIG&&CONFIG===cfg||(
/* Shield configuration object from tampering */
cfg&&"object"===_typeof$1(cfg)||(cfg={})
/* Shield configuration object from prototype pollution */,cfg=clone(cfg),PARSER_MEDIA_TYPE=
// eslint-disable-next-line unicorn/prefer-includes
PARSER_MEDIA_TYPE=-1===SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE)?DEFAULT_PARSER_MEDIA_TYPE:cfg.PARSER_MEDIA_TYPE,// HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
transformCaseFunc="application/xhtml+xml"===PARSER_MEDIA_TYPE?stringToString:stringToLowerCase,
/* Set configuration parameters */
ALLOWED_TAGS="ALLOWED_TAGS"in cfg?addToSet({},cfg.ALLOWED_TAGS,transformCaseFunc):DEFAULT_ALLOWED_TAGS,ALLOWED_ATTR="ALLOWED_ATTR"in cfg?addToSet({},cfg.ALLOWED_ATTR,transformCaseFunc):DEFAULT_ALLOWED_ATTR,ALLOWED_NAMESPACES="ALLOWED_NAMESPACES"in cfg?addToSet({},cfg.ALLOWED_NAMESPACES,stringToString):DEFAULT_ALLOWED_NAMESPACES,URI_SAFE_ATTRIBUTES="ADD_URI_SAFE_ATTR"in cfg?addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES),
// eslint-disable-line indent
cfg.ADD_URI_SAFE_ATTR,
// eslint-disable-line indent
transformCaseFunc):DEFAULT_URI_SAFE_ATTRIBUTES,DATA_URI_TAGS="ADD_DATA_URI_TAGS"in cfg?addToSet(clone(DEFAULT_DATA_URI_TAGS),
// eslint-disable-line indent
cfg.ADD_DATA_URI_TAGS,
// eslint-disable-line indent
transformCaseFunc):DEFAULT_DATA_URI_TAGS,FORBID_CONTENTS="FORBID_CONTENTS"in cfg?addToSet({},cfg.FORBID_CONTENTS,transformCaseFunc):DEFAULT_FORBID_CONTENTS,FORBID_TAGS="FORBID_TAGS"in cfg?addToSet({},cfg.FORBID_TAGS,transformCaseFunc):{},FORBID_ATTR="FORBID_ATTR"in cfg?addToSet({},cfg.FORBID_ATTR,transformCaseFunc):{},USE_PROFILES="USE_PROFILES"in cfg&&cfg.USE_PROFILES,ALLOW_ARIA_ATTR=!1!==cfg.ALLOW_ARIA_ATTR,// Default true
ALLOW_DATA_ATTR=!1!==cfg.ALLOW_DATA_ATTR,// Default true
ALLOW_UNKNOWN_PROTOCOLS=cfg.ALLOW_UNKNOWN_PROTOCOLS||!1,// Default false
ALLOW_SELF_CLOSE_IN_ATTR=!1!==cfg.ALLOW_SELF_CLOSE_IN_ATTR,// Default true
SAFE_FOR_TEMPLATES=cfg.SAFE_FOR_TEMPLATES||!1,// Default false
WHOLE_DOCUMENT=cfg.WHOLE_DOCUMENT||!1,// Default false
RETURN_DOM=cfg.RETURN_DOM||!1,// Default false
RETURN_DOM_FRAGMENT=cfg.RETURN_DOM_FRAGMENT||!1,// Default false
RETURN_TRUSTED_TYPE=cfg.RETURN_TRUSTED_TYPE||!1,// Default false
FORCE_BODY=cfg.FORCE_BODY||!1,// Default false
SANITIZE_DOM=!1!==cfg.SANITIZE_DOM,// Default true
SANITIZE_NAMED_PROPS=cfg.SANITIZE_NAMED_PROPS||!1,// Default false
KEEP_CONTENT=!1!==cfg.KEEP_CONTENT,// Default true
IN_PLACE=cfg.IN_PLACE||!1,// Default false
IS_ALLOWED_URI$1=cfg.ALLOWED_URI_REGEXP||IS_ALLOWED_URI$1,NAMESPACE=cfg.NAMESPACE||HTML_NAMESPACE,CUSTOM_ELEMENT_HANDLING=cfg.CUSTOM_ELEMENT_HANDLING||{},cfg.CUSTOM_ELEMENT_HANDLING&&isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)&&(CUSTOM_ELEMENT_HANDLING.tagNameCheck=cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck),cfg.CUSTOM_ELEMENT_HANDLING&&isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)&&(CUSTOM_ELEMENT_HANDLING.attributeNameCheck=cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck),cfg.CUSTOM_ELEMENT_HANDLING&&"boolean"===typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements&&(CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements=cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements),SAFE_FOR_TEMPLATES&&(ALLOW_DATA_ATTR=!1),RETURN_DOM_FRAGMENT&&(RETURN_DOM=!0)
/* Parse profile info */,USE_PROFILES&&(ALLOWED_TAGS=addToSet({},_toConsumableArray(forms_text)),ALLOWED_ATTR=[],!0===USE_PROFILES.html&&(addToSet(ALLOWED_TAGS,html$1),addToSet(ALLOWED_ATTR,html)),!0===USE_PROFILES.svg&&(addToSet(ALLOWED_TAGS,svg$1),addToSet(ALLOWED_ATTR,svg),addToSet(ALLOWED_ATTR,xml)),!0===USE_PROFILES.svgFilters&&(addToSet(ALLOWED_TAGS,svgFilters),addToSet(ALLOWED_ATTR,svg),addToSet(ALLOWED_ATTR,xml)),!0===USE_PROFILES.mathMl&&(addToSet(ALLOWED_TAGS,mathMl$1),addToSet(ALLOWED_ATTR,mathMl),addToSet(ALLOWED_ATTR,xml)))
/* Merge configuration parameters */,cfg.ADD_TAGS&&(ALLOWED_TAGS===DEFAULT_ALLOWED_TAGS&&(ALLOWED_TAGS=clone(ALLOWED_TAGS)),addToSet(ALLOWED_TAGS,cfg.ADD_TAGS,transformCaseFunc)),cfg.ADD_ATTR&&(ALLOWED_ATTR===DEFAULT_ALLOWED_ATTR&&(ALLOWED_ATTR=clone(ALLOWED_ATTR)),addToSet(ALLOWED_ATTR,cfg.ADD_ATTR,transformCaseFunc)),cfg.ADD_URI_SAFE_ATTR&&addToSet(URI_SAFE_ATTRIBUTES,cfg.ADD_URI_SAFE_ATTR,transformCaseFunc),cfg.FORBID_CONTENTS&&(FORBID_CONTENTS===DEFAULT_FORBID_CONTENTS&&(FORBID_CONTENTS=clone(FORBID_CONTENTS)),addToSet(FORBID_CONTENTS,cfg.FORBID_CONTENTS,transformCaseFunc))
/* Add #text in case KEEP_CONTENT is set to true */,KEEP_CONTENT&&(ALLOWED_TAGS["#text"]=!0)
/* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */,WHOLE_DOCUMENT&&addToSet(ALLOWED_TAGS,["html","head","body"])
/* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */,ALLOWED_TAGS.table&&(addToSet(ALLOWED_TAGS,["tbody"]),delete FORBID_TAGS.tbody),// Prevent further manipulation of configuration.
// Not available in IE8, Safari 5, etc.
freeze&&freeze(cfg),CONFIG=cfg)},MATHML_TEXT_INTEGRATION_POINTS=addToSet({},["mi","mo","mn","ms","mtext"]),HTML_INTEGRATION_POINTS=addToSet({},["foreignobject","desc","title","annotation-xml"]),COMMON_SVG_AND_HTML_ELEMENTS=addToSet({},["title","style","font","a","script"]),ALL_SVG_TAGS=addToSet({},svg$1);addToSet(ALL_SVG_TAGS,svgFilters),addToSet(ALL_SVG_TAGS,svgDisallowed);var ALL_MATHML_TAGS=addToSet({},mathMl$1);addToSet(ALL_MATHML_TAGS,mathMlDisallowed);
/**
   *
   *
   * @param  {Element} element a DOM element whose namespace is being checked
   * @returns {boolean} Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */
var _checkValidNamespace=function(element){var parent=getParentNode(element);// In JSDOM, if we're inside shadow DOM, then parentNode
// can be null. We just simulate parent in this case.
parent&&parent.tagName||(parent={namespaceURI:NAMESPACE,tagName:"template"});var tagName=stringToLowerCase(element.tagName),parentTagName=stringToLowerCase(parent.tagName);return!!ALLOWED_NAMESPACES[element.namespaceURI]&&(element.namespaceURI===SVG_NAMESPACE?
// The only way to switch from HTML namespace to SVG
// is via <svg>. If it happens via any other tag, then
// it should be killed.
parent.namespaceURI===HTML_NAMESPACE?"svg"===tagName:// The only way to switch from MathML to SVG is via`
// svg if parent is either <annotation-xml> or MathML
// text integration points.
parent.namespaceURI===MATHML_NAMESPACE?"svg"===tagName&&("annotation-xml"===parentTagName||MATHML_TEXT_INTEGRATION_POINTS[parentTagName]):Boolean(ALL_SVG_TAGS[tagName]):element.namespaceURI===MATHML_NAMESPACE?
// The only way to switch from HTML namespace to MathML
// is via <math>. If it happens via any other tag, then
// it should be killed.
parent.namespaceURI===HTML_NAMESPACE?"math"===tagName:// The only way to switch from SVG to MathML is via
// <math> and HTML integration points
parent.namespaceURI===SVG_NAMESPACE?"math"===tagName&&HTML_INTEGRATION_POINTS[parentTagName]:Boolean(ALL_MATHML_TAGS[tagName]):element.namespaceURI===HTML_NAMESPACE?
// The only way to switch from SVG to HTML is via
// HTML integration points, and from MathML to HTML
// is via MathML text integration points
!(parent.namespaceURI===SVG_NAMESPACE&&!HTML_INTEGRATION_POINTS[parentTagName])&&(!(parent.namespaceURI===MATHML_NAMESPACE&&!MATHML_TEXT_INTEGRATION_POINTS[parentTagName])&&(!ALL_MATHML_TAGS[tagName]&&(COMMON_SVG_AND_HTML_ELEMENTS[tagName]||!ALL_SVG_TAGS[tagName]))):!("application/xhtml+xml"!==PARSER_MEDIA_TYPE||!ALLOWED_NAMESPACES[element.namespaceURI]))},_forceRemove=function(node){arrayPush(DOMPurify.removed,{element:node});try{
// eslint-disable-next-line unicorn/prefer-dom-node-remove
node.parentNode.removeChild(node)}catch(_){try{node.outerHTML=emptyHTML}catch(_){node.remove()}}},_removeAttribute=function(name,node){try{arrayPush(DOMPurify.removed,{attribute:node.getAttributeNode(name),from:node})}catch(_){arrayPush(DOMPurify.removed,{attribute:null,from:node})}// We void attribute values for unremovable "is"" attributes
if(node.removeAttribute(name),"is"===name&&!ALLOWED_ATTR[name])if(RETURN_DOM||RETURN_DOM_FRAGMENT)try{_forceRemove(node)}catch(_){}else try{node.setAttribute(name,"")}catch(_){}},_initDocument=function(dirty){
/* Create a HTML document */
var doc,leadingWhitespace;if(FORCE_BODY)dirty="<remove></remove>"+dirty;else{
/* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
var matches=stringMatch(dirty,/^[\r\n\t ]+/);leadingWhitespace=matches&&matches[0]}"application/xhtml+xml"===PARSER_MEDIA_TYPE&&NAMESPACE===HTML_NAMESPACE&&(
// Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
dirty='<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>'+dirty+"</body></html>");var dirtyPayload=trustedTypesPolicy?trustedTypesPolicy.createHTML(dirty):dirty;
/*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */if(NAMESPACE===HTML_NAMESPACE)try{doc=(new DOMParser).parseFromString(dirtyPayload,PARSER_MEDIA_TYPE)}catch(_){}
/* Use createHTMLDocument in case DOMParser is not available */if(!doc||!doc.documentElement){doc=implementation.createDocument(NAMESPACE,"template",null);try{doc.documentElement.innerHTML=IS_EMPTY_INPUT?emptyHTML:dirtyPayload}catch(_){// Syntax error if dirtyPayload is invalid xml
}}var body=doc.body||doc.documentElement;
/* Work on whole document or just its body */
return dirty&&leadingWhitespace&&body.insertBefore(document.createTextNode(leadingWhitespace),body.childNodes[0]||null),NAMESPACE===HTML_NAMESPACE?getElementsByTagName.call(doc,WHOLE_DOCUMENT?"html":"body")[0]:WHOLE_DOCUMENT?doc.documentElement:body},_createIterator=function(root){return createNodeIterator.call(root.ownerDocument||root,root,
// eslint-disable-next-line no-bitwise
NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT|NodeFilter.SHOW_TEXT,null,!1)},_isClobbered=function(elm){return elm instanceof HTMLFormElement&&("string"!==typeof elm.nodeName||"string"!==typeof elm.textContent||"function"!==typeof elm.removeChild||!(elm.attributes instanceof NamedNodeMap)||"function"!==typeof elm.removeAttribute||"function"!==typeof elm.setAttribute||"string"!==typeof elm.namespaceURI||"function"!==typeof elm.insertBefore||"function"!==typeof elm.hasChildNodes)},_isNode=function(object){return"object"===_typeof$1(Node)?object instanceof Node:object&&"object"===_typeof$1(object)&&"number"===typeof object.nodeType&&"string"===typeof object.nodeName},_executeHook=function(entryPoint,currentNode,data){hooks[entryPoint]&&arrayForEach(hooks[entryPoint],(function(hook){hook.call(DOMPurify,currentNode,data,CONFIG)}))},_sanitizeElements=function(currentNode){var content;
/* Execute a hook if present */
/* Check if element is clobbered or can clobber */
if(_executeHook("beforeSanitizeElements",currentNode,null),_isClobbered(currentNode))return _forceRemove(currentNode),!0;
/* Check if tagname contains Unicode */if(regExpTest(/[\u0080-\uFFFF]/,currentNode.nodeName))return _forceRemove(currentNode),!0;
/* Now let's check the element's type and name */var tagName=transformCaseFunc(currentNode.nodeName);
/* Execute a hook if present */
/* Detect mXSS attempts abusing namespace confusion */
if(_executeHook("uponSanitizeElement",currentNode,{tagName:tagName,allowedTags:ALLOWED_TAGS}),currentNode.hasChildNodes()&&!_isNode(currentNode.firstElementChild)&&(!_isNode(currentNode.content)||!_isNode(currentNode.content.firstElementChild))&&regExpTest(/<[/\w]/g,currentNode.innerHTML)&&regExpTest(/<[/\w]/g,currentNode.textContent))return _forceRemove(currentNode),!0;
/* Mitigate a problem with templates inside select */if("select"===tagName&&regExpTest(/<template/i,currentNode.innerHTML))return _forceRemove(currentNode),!0;
/* Remove element if anything forbids its presence */if(!ALLOWED_TAGS[tagName]||FORBID_TAGS[tagName]){
/* Check if we have a custom element to handle */
if(!FORBID_TAGS[tagName]&&_basicCustomElementTest(tagName)){if(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp&&regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck,tagName))return!1;if(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))return!1}
/* Keep content except for bad-listed elements */if(KEEP_CONTENT&&!FORBID_CONTENTS[tagName]){var parentNode=getParentNode(currentNode)||currentNode.parentNode,childNodes=getChildNodes(currentNode)||currentNode.childNodes;if(childNodes&&parentNode)for(var childCount=childNodes.length,i=childCount-1;i>=0;--i)parentNode.insertBefore(cloneNode(childNodes[i],!0),getNextSibling(currentNode))}return _forceRemove(currentNode),!0}
/* Check whether element has a valid namespace */return currentNode instanceof Element&&!_checkValidNamespace(currentNode)?(_forceRemove(currentNode),!0):
/* Make sure that older browsers don't get fallback-tag mXSS */
"noscript"!==tagName&&"noembed"!==tagName&&"noframes"!==tagName||!regExpTest(/<\/no(script|embed|frames)/i,currentNode.innerHTML)?(
/* Sanitize element content to be template-safe */
SAFE_FOR_TEMPLATES&&3===currentNode.nodeType&&(
/* Get the element's text content */
content=currentNode.textContent,content=stringReplace(content,MUSTACHE_EXPR$1," "),content=stringReplace(content,ERB_EXPR$1," "),content=stringReplace(content,TMPLIT_EXPR$1," "),currentNode.textContent!==content&&(arrayPush(DOMPurify.removed,{element:currentNode.cloneNode()}),currentNode.textContent=content))
/* Execute a hook if present */,_executeHook("afterSanitizeElements",currentNode,null),!1):(_forceRemove(currentNode),!0)},_isValidAttribute=function(lcTag,lcName,value){
/* Make sure attribute cannot clobber */
if(SANITIZE_DOM&&("id"===lcName||"name"===lcName)&&(value in document||value in formElement))return!1;
/* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */if(ALLOW_DATA_ATTR&&!FORBID_ATTR[lcName]&&regExpTest(DATA_ATTR$1,lcName));else if(ALLOW_ARIA_ATTR&&regExpTest(ARIA_ATTR$1,lcName));else if(!ALLOWED_ATTR[lcName]||FORBID_ATTR[lcName]){if(
// First condition does a very basic check if a) it's basically a valid custom element tagname AND
// b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
// and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
!(_basicCustomElementTest(lcTag)&&(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp&&regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck,lcTag)||CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag))&&(CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp&&regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck,lcName)||CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName))||
// Alternative, second condition checks if it's an `is`-attribute, AND
// the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
"is"===lcName&&CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements&&(CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp&&regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck,value)||CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function&&CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))))return!1;
/* Check value is safe. First, is attr inert? If so, is safe */}else if(URI_SAFE_ATTRIBUTES[lcName]);else if(regExpTest(IS_ALLOWED_URI$1,stringReplace(value,ATTR_WHITESPACE$1,"")));else if("src"!==lcName&&"xlink:href"!==lcName&&"href"!==lcName||"script"===lcTag||0!==stringIndexOf(value,"data:")||!DATA_URI_TAGS[lcTag]){if(ALLOW_UNKNOWN_PROTOCOLS&&!regExpTest(IS_SCRIPT_OR_DATA$1,stringReplace(value,ATTR_WHITESPACE$1,"")));else if(value)return!1}else;return!0},_basicCustomElementTest=function(tagName){return tagName.indexOf("-")>0},_sanitizeAttributes=function(currentNode){var attr,value,lcName,l;
/* Execute a hook if present */
_executeHook("beforeSanitizeAttributes",currentNode,null);var attributes=currentNode.attributes;
/* Check if we have attributes; if not we might have a text node */if(attributes){var hookEvent={attrName:"",attrValue:"",keepAttr:!0,allowedAttributes:ALLOWED_ATTR};l=attributes.length;
/* Go backwards over all attributes; safely remove bad ones */
while(l--){attr=attributes[l];var _attr=attr,name=_attr.name,namespaceURI=_attr.namespaceURI;
/* Did the hooks approve of the attribute? */
if(value="value"===name?attr.value:stringTrim(attr.value),lcName=transformCaseFunc(name),
/* Execute a hook if present */
hookEvent.attrName=lcName,hookEvent.attrValue=value,hookEvent.keepAttr=!0,hookEvent.forceKeepAttr=void 0,// Allows developers to see this is a property they can set
_executeHook("uponSanitizeAttribute",currentNode,hookEvent),value=hookEvent.attrValue,!hookEvent.forceKeepAttr&&(
/* Remove attribute */
_removeAttribute(name,currentNode),hookEvent.keepAttr))
/* Work around a security issue in jQuery 3.0 */
if(ALLOW_SELF_CLOSE_IN_ATTR||!regExpTest(/\/>/i,value)){
/* Sanitize attribute content to be template-safe */
SAFE_FOR_TEMPLATES&&(value=stringReplace(value,MUSTACHE_EXPR$1," "),value=stringReplace(value,ERB_EXPR$1," "),value=stringReplace(value,TMPLIT_EXPR$1," "))
/* Is `value` valid for this attribute? */;var lcTag=transformCaseFunc(currentNode.nodeName);if(_isValidAttribute(lcTag,lcName,value)){
/* Handle attributes that require Trusted Types */
if(
/* Full DOM Clobbering protection via namespace isolation,
       * Prefix id and name attributes with `user-content-`
       */
!SANITIZE_NAMED_PROPS||"id"!==lcName&&"name"!==lcName||(
// Remove the attribute with this value
_removeAttribute(name,currentNode),// Prefix the value and later re-create the attribute with the sanitized value
value=SANITIZE_NAMED_PROPS_PREFIX+value),trustedTypesPolicy&&"object"===_typeof$1(trustedTypes)&&"function"===typeof trustedTypes.getAttributeType)if(namespaceURI);else switch(trustedTypes.getAttributeType(lcTag,lcName)){case"TrustedHTML":value=trustedTypesPolicy.createHTML(value);break;case"TrustedScriptURL":value=trustedTypesPolicy.createScriptURL(value);break}
/* Handle invalid data-* attribute set by try-catching it */try{namespaceURI?currentNode.setAttributeNS(namespaceURI,name,value):
/* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
currentNode.setAttribute(name,value),arrayPop(DOMPurify.removed)}catch(_){}}}else _removeAttribute(name,currentNode)}
/* Execute a hook if present */_executeHook("afterSanitizeAttributes",currentNode,null)}},_sanitizeShadowDOM=function _sanitizeShadowDOM(fragment){var shadowNode,shadowIterator=_createIterator(fragment);
/* Execute a hook if present */
_executeHook("beforeSanitizeShadowDOM",fragment,null);while(shadowNode=shadowIterator.nextNode())
/* Execute a hook if present */
_executeHook("uponSanitizeShadowNode",shadowNode,null),
/* Sanitize tags and elements */
_sanitizeElements(shadowNode)||(
/* Deep shadow DOM detected */
shadowNode.content instanceof DocumentFragment&&_sanitizeShadowDOM(shadowNode.content)
/* Check attributes, sanitize if necessary */,_sanitizeAttributes(shadowNode));
/* Execute a hook if present */_executeHook("afterSanitizeShadowDOM",fragment,null)};
/**
   * _forceRemove
   *
   * @param  {Node} node a DOM node
   */
/**
   * Sanitize
   * Public method providing core sanitation functionality
   *
   * @param {String|Node} dirty string or DOM node
   * @param {Object} configuration object
   */
// eslint-disable-next-line complexity
return DOMPurify.sanitize=function(dirty){var body,importedNode,currentNode,oldNode,returnNode,cfg=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};
/* Stringify, in case dirty is an object */
if(
/* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
IS_EMPTY_INPUT=!dirty,IS_EMPTY_INPUT&&(dirty="\x3c!--\x3e"),"string"!==typeof dirty&&!_isNode(dirty)){if("function"!==typeof dirty.toString)throw typeErrorCreate("toString is not a function");if(dirty=dirty.toString(),"string"!==typeof dirty)throw typeErrorCreate("dirty is not a string, aborting")}
/* Check we can run. Otherwise fall back or ignore */if(!DOMPurify.isSupported){if("object"===_typeof$1(window.toStaticHTML)||"function"===typeof window.toStaticHTML){if("string"===typeof dirty)return window.toStaticHTML(dirty);if(_isNode(dirty))return window.toStaticHTML(dirty.outerHTML)}return dirty}
/* Assign config vars */if(SET_CONFIG||_parseConfig(cfg)
/* Clean up removed elements */,DOMPurify.removed=[],
/* Check if dirty is correctly typed for IN_PLACE */
"string"===typeof dirty&&(IN_PLACE=!1),IN_PLACE){
/* Do some early pre-sanitization to avoid unsafe root nodes */
if(dirty.nodeName){var tagName=transformCaseFunc(dirty.nodeName);if(!ALLOWED_TAGS[tagName]||FORBID_TAGS[tagName])throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place")}}else if(dirty instanceof Node)
/* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
body=_initDocument("\x3c!----\x3e"),importedNode=body.ownerDocument.importNode(dirty,!0),1===importedNode.nodeType&&"BODY"===importedNode.nodeName||"HTML"===importedNode.nodeName?
/* Node is already a body, use as is */
body=importedNode:
// eslint-disable-next-line unicorn/prefer-dom-node-append
body.appendChild(importedNode);else{
/* Exit directly if we have nothing to do */
if(!RETURN_DOM&&!SAFE_FOR_TEMPLATES&&!WHOLE_DOCUMENT&&
// eslint-disable-next-line unicorn/prefer-includes
-1===dirty.indexOf("<"))return trustedTypesPolicy&&RETURN_TRUSTED_TYPE?trustedTypesPolicy.createHTML(dirty):dirty;
/* Initialize the document to work on */
/* Check we have a DOM node from the data */
if(body=_initDocument(dirty),!body)return RETURN_DOM?null:RETURN_TRUSTED_TYPE?emptyHTML:""}
/* Remove first element node (ours) if FORCE_BODY is set */body&&FORCE_BODY&&_forceRemove(body.firstChild)
/* Get node iterator */;var nodeIterator=_createIterator(IN_PLACE?dirty:body);
/* Now start iterating over the created document */while(currentNode=nodeIterator.nextNode())
/* Fix IE's strange behavior with manipulated textNodes #89 */
3===currentNode.nodeType&&currentNode===oldNode||_sanitizeElements(currentNode)||(
/* Shadow DOM detected, sanitize it */
currentNode.content instanceof DocumentFragment&&_sanitizeShadowDOM(currentNode.content)
/* Check attributes, sanitize if necessary */,_sanitizeAttributes(currentNode),oldNode=currentNode)
/* Sanitize tags and elements */;
/* If we sanitized `dirty` in-place, return it. */
if(oldNode=null,IN_PLACE)return dirty;
/* Return sanitized string or DOM */if(RETURN_DOM){if(RETURN_DOM_FRAGMENT){returnNode=createDocumentFragment.call(body.ownerDocument);while(body.firstChild)
// eslint-disable-next-line unicorn/prefer-dom-node-append
returnNode.appendChild(body.firstChild)}else returnNode=body;return(ALLOWED_ATTR.shadowroot||ALLOWED_ATTR.shadowrootmod)&&(
/*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
returnNode=importNode.call(originalDocument,returnNode,!0)),returnNode}var serializedHTML=WHOLE_DOCUMENT?body.outerHTML:body.innerHTML;
/* Serialize doctype if allowed */return WHOLE_DOCUMENT&&ALLOWED_TAGS["!doctype"]&&body.ownerDocument&&body.ownerDocument.doctype&&body.ownerDocument.doctype.name&&regExpTest(DOCTYPE_NAME,body.ownerDocument.doctype.name)&&(serializedHTML="<!DOCTYPE "+body.ownerDocument.doctype.name+">\n"+serializedHTML)
/* Sanitize final string template-safe */,SAFE_FOR_TEMPLATES&&(serializedHTML=stringReplace(serializedHTML,MUSTACHE_EXPR$1," "),serializedHTML=stringReplace(serializedHTML,ERB_EXPR$1," "),serializedHTML=stringReplace(serializedHTML,TMPLIT_EXPR$1," ")),trustedTypesPolicy&&RETURN_TRUSTED_TYPE?trustedTypesPolicy.createHTML(serializedHTML):serializedHTML},
/**
   * Public method to set the configuration once
   * setConfig
   *
   * @param {Object} cfg configuration object
   */
DOMPurify.setConfig=function(cfg){_parseConfig(cfg),SET_CONFIG=!0},
/**
   * Public method to remove the configuration
   * clearConfig
   *
   */
DOMPurify.clearConfig=function(){CONFIG=null,SET_CONFIG=!1},
/**
   * Public method to check if an attribute value is valid.
   * Uses last set config, if any. Otherwise, uses config defaults.
   * isValidAttribute
   *
   * @param  {string} tag Tag name of containing element.
   * @param  {string} attr Attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
   */
DOMPurify.isValidAttribute=function(tag,attr,value){
/* Initialize shared config vars if necessary. */
CONFIG||_parseConfig({});var lcTag=transformCaseFunc(tag),lcName=transformCaseFunc(attr);return _isValidAttribute(lcTag,lcName,value)},
/**
   * AddHook
   * Public method to add DOMPurify hooks
   *
   * @param {String} entryPoint entry point for the hook to add
   * @param {Function} hookFunction function to execute
   */
DOMPurify.addHook=function(entryPoint,hookFunction){"function"===typeof hookFunction&&(hooks[entryPoint]=hooks[entryPoint]||[],arrayPush(hooks[entryPoint],hookFunction))},
/**
   * RemoveHook
   * Public method to remove a DOMPurify hook at a given entryPoint
   * (pops it from the stack of hooks if more are present)
   *
   * @param {String} entryPoint entry point for the hook to remove
   * @return {Function} removed(popped) hook
   */
DOMPurify.removeHook=function(entryPoint){if(hooks[entryPoint])return arrayPop(hooks[entryPoint])},
/**
   * RemoveHooks
   * Public method to remove all DOMPurify hooks at a given entryPoint
   *
   * @param  {String} entryPoint entry point for the hooks to remove
   */
DOMPurify.removeHooks=function(entryPoint){hooks[entryPoint]&&(hooks[entryPoint]=[])},
/**
   * RemoveAllHooks
   * Public method to remove all DOMPurify hooks
   *
   */
DOMPurify.removeAllHooks=function(){hooks={}},DOMPurify}var purify=createDOMPurify();
/**
 * Util to sanitize html and text content from users.
 * Should be used when sending html to server (insertHTML) and when displaying html using v-html
 *
 * @param  html The raw html that must be sanitized
 */function sanitize(html){return purify.sanitize(html,{ADD_ATTR:["target"]})}
// ::- Persistent data structure representing an ordered mapping from
// strings to values, with some convenient update methods.
function OrderedMap(content){this.content=content}function findDiffStart(a,b,pos){for(let i=0;;i++){if(i==a.childCount||i==b.childCount)return a.childCount==b.childCount?null:pos;let childA=a.child(i),childB=b.child(i);if(childA!=childB){if(!childA.sameMarkup(childB))return pos;if(childA.isText&&childA.text!=childB.text){for(let j=0;childA.text[j]==childB.text[j];j++)pos++;return pos}if(childA.content.size||childB.content.size){let inner=findDiffStart(childA.content,childB.content,pos+1);if(null!=inner)return inner}pos+=childA.nodeSize}else pos+=childA.nodeSize}}function findDiffEnd(a,b,posA,posB){for(let iA=a.childCount,iB=b.childCount;;){if(0==iA||0==iB)return iA==iB?null:{a:posA,b:posB};let childA=a.child(--iA),childB=b.child(--iB),size=childA.nodeSize;if(childA!=childB){if(!childA.sameMarkup(childB))return{a:posA,b:posB};if(childA.isText&&childA.text!=childB.text){let same=0,minSize=Math.min(childA.text.length,childB.text.length);while(same<minSize&&childA.text[childA.text.length-same-1]==childB.text[childB.text.length-same-1])same++,posA--,posB--;return{a:posA,b:posB}}if(childA.content.size||childB.content.size){let inner=findDiffEnd(childA.content,childB.content,posA-1,posB-1);if(inner)return inner}posA-=size,posB-=size}else posA-=size,posB-=size}}
/**
A fragment represents a node's collection of child nodes.

Like nodes, fragments are persistent data structures, and you
should not mutate them or their content. Rather, you create new
instances whenever needed. The API tries to make this easy.
*/OrderedMap.prototype={constructor:OrderedMap,find:function(key){for(var i=0;i<this.content.length;i+=2)if(this.content[i]===key)return i;return-1},
// :: (string) → ?any
// Retrieve the value stored under `key`, or return undefined when
// no such key exists.
get:function(key){var found=this.find(key);return-1==found?void 0:this.content[found+1]},
// :: (string, any, ?string) → OrderedMap
// Create a new map by replacing the value of `key` with a new
// value, or adding a binding to the end of the map. If `newKey` is
// given, the key of the binding will be replaced with that key.
update:function(key,value,newKey){var self=newKey&&newKey!=key?this.remove(newKey):this,found=self.find(key),content=self.content.slice();return-1==found?content.push(newKey||key,value):(content[found+1]=value,newKey&&(content[found]=newKey)),new OrderedMap(content)},
// :: (string) → OrderedMap
// Return a map with the given key removed, if it existed.
remove:function(key){var found=this.find(key);if(-1==found)return this;var content=this.content.slice();return content.splice(found,2),new OrderedMap(content)},
// :: (string, any) → OrderedMap
// Add a new key to the start of the map.
addToStart:function(key,value){return new OrderedMap([key,value].concat(this.remove(key).content))},
// :: (string, any) → OrderedMap
// Add a new key to the end of the map.
addToEnd:function(key,value){var content=this.remove(key).content.slice();return content.push(key,value),new OrderedMap(content)},
// :: (string, string, any) → OrderedMap
// Add a key after the given key. If `place` is not found, the new
// key is added to the end.
addBefore:function(place,key,value){var without=this.remove(key),content=without.content.slice(),found=without.find(place);return content.splice(-1==found?content.length:found,0,key,value),new OrderedMap(content)},
// :: ((key: string, value: any))
// Call the given function for each key/value pair in the map, in
// order.
forEach:function(f){for(var i=0;i<this.content.length;i+=2)f(this.content[i],this.content[i+1])},
// :: (union<Object, OrderedMap>) → OrderedMap
// Create a new map by prepending the keys in this map that don't
// appear in `map` before the keys in `map`.
prepend:function(map){return map=OrderedMap.from(map),map.size?new OrderedMap(map.content.concat(this.subtract(map).content)):this},
// :: (union<Object, OrderedMap>) → OrderedMap
// Create a new map by appending the keys in this map that don't
// appear in `map` after the keys in `map`.
append:function(map){return map=OrderedMap.from(map),map.size?new OrderedMap(this.subtract(map).content.concat(map.content)):this},
// :: (union<Object, OrderedMap>) → OrderedMap
// Create a map containing all the keys in this map that don't
// appear in `map`.
subtract:function(map){var result=this;map=OrderedMap.from(map);for(var i=0;i<map.content.length;i+=2)result=result.remove(map.content[i]);return result},
// :: () → Object
// Turn ordered map into a plain object.
toObject:function(){var result={};return this.forEach((function(key,value){result[key]=value})),result},
// :: number
// The amount of keys in this map.
get size(){return this.content.length>>1}},
// :: (?union<Object, OrderedMap>) → OrderedMap
// Return a map with the given content. If null, create an empty
// map. If given an ordered map, return that map itself. If given an
// object, create a map from the object's properties.
OrderedMap.from=function(value){if(value instanceof OrderedMap)return value;var content=[];if(value)for(var prop in value)content.push(prop,value[prop]);return new OrderedMap(content)};class Fragment{
/**
    @internal
    */
constructor(
/**
    @internal
    */
content,size){if(this.content=content,this.size=size||0,null==size)for(let i=0;i<content.length;i++)this.size+=content[i].nodeSize}
/**
    Invoke a callback for all descendant nodes between the given two
    positions (relative to start of this fragment). Doesn't descend
    into a node when the callback returns `false`.
    */nodesBetween(from,to,f,nodeStart=0,parent){for(let i=0,pos=0;pos<to;i++){let child=this.content[i],end=pos+child.nodeSize;if(end>from&&!1!==f(child,nodeStart+pos,parent||null,i)&&child.content.size){let start=pos+1;child.nodesBetween(Math.max(0,from-start),Math.min(child.content.size,to-start),f,nodeStart+start)}pos=end}}
/**
    Call the given callback for every descendant node. `pos` will be
    relative to the start of the fragment. The callback may return
    `false` to prevent traversal of a given node's children.
    */descendants(f){this.nodesBetween(0,this.size,f)}
/**
    Extract the text between `from` and `to`. See the same method on
    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
    */textBetween(from,to,blockSeparator,leafText){let text="",separated=!0;return this.nodesBetween(from,to,((node,pos)=>{node.isText?(text+=node.text.slice(Math.max(from,pos)-pos,to-pos),separated=!blockSeparator):node.isLeaf?(leafText?text+="function"===typeof leafText?leafText(node):leafText:node.type.spec.leafText&&(text+=node.type.spec.leafText(node)),separated=!blockSeparator):!separated&&node.isBlock&&(text+=blockSeparator,separated=!0)}),0),text}
/**
    Create a new fragment containing the combined content of this
    fragment and the other.
    */append(other){if(!other.size)return this;if(!this.size)return other;let last=this.lastChild,first=other.firstChild,content=this.content.slice(),i=0;for(last.isText&&last.sameMarkup(first)&&(content[content.length-1]=last.withText(last.text+first.text),i=1);i<other.content.length;i++)content.push(other.content[i]);return new Fragment(content,this.size+other.size)}
/**
    Cut out the sub-fragment between the two given positions.
    */cut(from,to=this.size){if(0==from&&to==this.size)return this;let result=[],size=0;if(to>from)for(let i=0,pos=0;pos<to;i++){let child=this.content[i],end=pos+child.nodeSize;end>from&&((pos<from||end>to)&&(child=child.isText?child.cut(Math.max(0,from-pos),Math.min(child.text.length,to-pos)):child.cut(Math.max(0,from-pos-1),Math.min(child.content.size,to-pos-1))),result.push(child),size+=child.nodeSize),pos=end}return new Fragment(result,size)}
/**
    @internal
    */cutByIndex(from,to){return from==to?Fragment.empty:0==from&&to==this.content.length?this:new Fragment(this.content.slice(from,to))}
/**
    Create a new fragment in which the node at the given index is
    replaced by the given node.
    */replaceChild(index,node){let current=this.content[index];if(current==node)return this;let copy=this.content.slice(),size=this.size+node.nodeSize-current.nodeSize;return copy[index]=node,new Fragment(copy,size)}
/**
    Create a new fragment by prepending the given node to this
    fragment.
    */addToStart(node){return new Fragment([node].concat(this.content),this.size+node.nodeSize)}
/**
    Create a new fragment by appending the given node to this
    fragment.
    */addToEnd(node){return new Fragment(this.content.concat(node),this.size+node.nodeSize)}
/**
    Compare this fragment to another one.
    */eq(other){if(this.content.length!=other.content.length)return!1;for(let i=0;i<this.content.length;i++)if(!this.content[i].eq(other.content[i]))return!1;return!0}
/**
    The first child of the fragment, or `null` if it is empty.
    */get firstChild(){return this.content.length?this.content[0]:null}
/**
    The last child of the fragment, or `null` if it is empty.
    */get lastChild(){return this.content.length?this.content[this.content.length-1]:null}
/**
    The number of child nodes in this fragment.
    */get childCount(){return this.content.length}
/**
    Get the child node at the given index. Raise an error when the
    index is out of range.
    */child(index){let found=this.content[index];if(!found)throw new RangeError("Index "+index+" out of range for "+this);return found}
/**
    Get the child node at the given index, if it exists.
    */maybeChild(index){return this.content[index]||null}
/**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */forEach(f){for(let i=0,p=0;i<this.content.length;i++){let child=this.content[i];f(child,p,i),p+=child.nodeSize}}
/**
    Find the first position at which this fragment and another
    fragment differ, or `null` if they are the same.
    */findDiffStart(other,pos=0){return findDiffStart(this,other,pos)}
/**
    Find the first position, searching from the end, at which this
    fragment and the given fragment differ, or `null` if they are
    the same. Since this position will not be the same in both
    nodes, an object with two separate positions is returned.
    */findDiffEnd(other,pos=this.size,otherPos=other.size){return findDiffEnd(this,other,pos,otherPos)}
/**
    Find the index and inner offset corresponding to a given relative
    position in this fragment. The result object will be reused
    (overwritten) the next time the function is called. (Not public.)
    */findIndex(pos,round=-1){if(0==pos)return retIndex(0,pos);if(pos==this.size)return retIndex(this.content.length,pos);if(pos>this.size||pos<0)throw new RangeError(`Position ${pos} outside of fragment (${this})`);for(let i=0,curPos=0;;i++){let cur=this.child(i),end=curPos+cur.nodeSize;if(end>=pos)return end==pos||round>0?retIndex(i+1,end):retIndex(i,curPos);curPos=end}}
/**
    Return a debugging string that describes this fragment.
    */toString(){return"<"+this.toStringInner()+">"}
/**
    @internal
    */toStringInner(){return this.content.join(", ")}
/**
    Create a JSON-serializeable representation of this fragment.
    */toJSON(){return this.content.length?this.content.map((n=>n.toJSON())):null}
/**
    Deserialize a fragment from its JSON representation.
    */static fromJSON(schema,value){if(!value)return Fragment.empty;if(!Array.isArray(value))throw new RangeError("Invalid input for Fragment.fromJSON");return new Fragment(value.map(schema.nodeFromJSON))}
/**
    Build a fragment from an array of nodes. Ensures that adjacent
    text nodes with the same marks are joined together.
    */static fromArray(array){if(!array.length)return Fragment.empty;let joined,size=0;for(let i=0;i<array.length;i++){let node=array[i];size+=node.nodeSize,i&&node.isText&&array[i-1].sameMarkup(node)?(joined||(joined=array.slice(0,i)),joined[joined.length-1]=node.withText(joined[joined.length-1].text+node.text)):joined&&joined.push(node)}return new Fragment(joined||array,size)}
/**
    Create a fragment from something that can be interpreted as a
    set of nodes. For `null`, it returns the empty fragment. For a
    fragment, the fragment itself. For a node or array of nodes, a
    fragment containing those nodes.
    */static from(nodes){if(!nodes)return Fragment.empty;if(nodes instanceof Fragment)return nodes;if(Array.isArray(nodes))return this.fromArray(nodes);if(nodes.attrs)return new Fragment([nodes],nodes.nodeSize);throw new RangeError("Can not convert "+nodes+" to a Fragment"+(nodes.nodesBetween?" (looks like multiple versions of prosemirror-model were loaded)":""))}}
/**
An empty fragment. Intended to be reused whenever a node doesn't
contain anything (rather than allocating a new empty fragment for
each leaf node).
*/Fragment.empty=new Fragment([],0);const found={index:0,offset:0};function retIndex(index,offset){return found.index=index,found.offset=offset,found}function compareDeep(a,b){if(a===b)return!0;if(!a||"object"!=typeof a||!b||"object"!=typeof b)return!1;let array=Array.isArray(a);if(Array.isArray(b)!=array)return!1;if(array){if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(!compareDeep(a[i],b[i]))return!1}else{for(let p in a)if(!(p in b)||!compareDeep(a[p],b[p]))return!1;for(let p in b)if(!(p in a))return!1}return!0}
/**
A mark is a piece of information that can be attached to a node,
such as it being emphasized, in code font, or a link. It has a
type and optionally a set of attributes that provide further
information (such as the target of the link). Marks are created
through a `Schema`, which controls which types exist and which
attributes they have.
*/class Mark$1{
/**
    @internal
    */
constructor(
/**
    The type of this mark.
    */
type,
/**
    The attributes associated with this mark.
    */
attrs){this.type=type,this.attrs=attrs}
/**
    Given a set of marks, create a new set which contains this one as
    well, in the right position. If this mark is already in the set,
    the set itself is returned. If any marks that are set to be
    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
    those are replaced by this one.
    */addToSet(set){let copy,placed=!1;for(let i=0;i<set.length;i++){let other=set[i];if(this.eq(other))return set;if(this.type.excludes(other.type))copy||(copy=set.slice(0,i));else{if(other.type.excludes(this.type))return set;!placed&&other.type.rank>this.type.rank&&(copy||(copy=set.slice(0,i)),copy.push(this),placed=!0),copy&&copy.push(other)}}return copy||(copy=set.slice()),placed||copy.push(this),copy}
/**
    Remove this mark from the given set, returning a new set. If this
    mark is not in the set, the set itself is returned.
    */removeFromSet(set){for(let i=0;i<set.length;i++)if(this.eq(set[i]))return set.slice(0,i).concat(set.slice(i+1));return set}
/**
    Test whether this mark is in the given set of marks.
    */isInSet(set){for(let i=0;i<set.length;i++)if(this.eq(set[i]))return!0;return!1}
/**
    Test whether this mark has the same type and attributes as
    another mark.
    */eq(other){return this==other||this.type==other.type&&compareDeep(this.attrs,other.attrs)}
/**
    Convert this mark to a JSON-serializeable representation.
    */toJSON(){let obj={type:this.type.name};for(let _ in this.attrs){obj.attrs=this.attrs;break}return obj}
/**
    Deserialize a mark from JSON.
    */static fromJSON(schema,json){if(!json)throw new RangeError("Invalid input for Mark.fromJSON");let type=schema.marks[json.type];if(!type)throw new RangeError(`There is no mark type ${json.type} in this schema`);return type.create(json.attrs)}
/**
    Test whether two sets of marks are identical.
    */static sameSet(a,b){if(a==b)return!0;if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(!a[i].eq(b[i]))return!1;return!0}
/**
    Create a properly sorted mark set from null, a single mark, or an
    unsorted array of marks.
    */static setFrom(marks){if(!marks||Array.isArray(marks)&&0==marks.length)return Mark$1.none;if(marks instanceof Mark$1)return[marks];let copy=marks.slice();return copy.sort(((a,b)=>a.type.rank-b.type.rank)),copy}}
/**
The empty set of marks.
*/Mark$1.none=[];
/**
Error type raised by [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) when
given an invalid replacement.
*/
class ReplaceError extends Error{}
/*
ReplaceError = function(this: any, message: string) {
  let err = Error.call(this, message)
  ;(err as any).__proto__ = ReplaceError.prototype
  return err
} as any

ReplaceError.prototype = Object.create(Error.prototype)
ReplaceError.prototype.constructor = ReplaceError
ReplaceError.prototype.name = "ReplaceError"
*/
/**
A slice represents a piece cut out of a larger document. It
stores not only a fragment, but also the depth up to which nodes on
both side are ‘open’ (cut through).
*/class Slice{
/**
    Create a slice. When specifying a non-zero open depth, you must
    make sure that there are nodes of at least that depth at the
    appropriate side of the fragment—i.e. if the fragment is an
    empty paragraph node, `openStart` and `openEnd` can't be greater
    than 1.
    
    It is not necessary for the content of open nodes to conform to
    the schema's content constraints, though it should be a valid
    start/end/middle for such a node, depending on which sides are
    open.
    */
constructor(
/**
    The slice's content.
    */
content,
/**
    The open depth at the start of the fragment.
    */
openStart,
/**
    The open depth at the end.
    */
openEnd){this.content=content,this.openStart=openStart,this.openEnd=openEnd}
/**
    The size this slice would add when inserted into a document.
    */get size(){return this.content.size-this.openStart-this.openEnd}
/**
    @internal
    */insertAt(pos,fragment){let content=insertInto(this.content,pos+this.openStart,fragment);return content&&new Slice(content,this.openStart,this.openEnd)}
/**
    @internal
    */removeBetween(from,to){return new Slice(removeRange(this.content,from+this.openStart,to+this.openStart),this.openStart,this.openEnd)}
/**
    Tests whether this slice is equal to another slice.
    */eq(other){return this.content.eq(other.content)&&this.openStart==other.openStart&&this.openEnd==other.openEnd}
/**
    @internal
    */toString(){return this.content+"("+this.openStart+","+this.openEnd+")"}
/**
    Convert a slice to a JSON-serializable representation.
    */toJSON(){if(!this.content.size)return null;let json={content:this.content.toJSON()};return this.openStart>0&&(json.openStart=this.openStart),this.openEnd>0&&(json.openEnd=this.openEnd),json}
/**
    Deserialize a slice from its JSON representation.
    */static fromJSON(schema,json){if(!json)return Slice.empty;let openStart=json.openStart||0,openEnd=json.openEnd||0;if("number"!=typeof openStart||"number"!=typeof openEnd)throw new RangeError("Invalid input for Slice.fromJSON");return new Slice(Fragment.fromJSON(schema,json.content),openStart,openEnd)}
/**
    Create a slice from a fragment by taking the maximum possible
    open value on both side of the fragment.
    */static maxOpen(fragment,openIsolating=!0){let openStart=0,openEnd=0;for(let n=fragment.firstChild;n&&!n.isLeaf&&(openIsolating||!n.type.spec.isolating);n=n.firstChild)openStart++;for(let n=fragment.lastChild;n&&!n.isLeaf&&(openIsolating||!n.type.spec.isolating);n=n.lastChild)openEnd++;return new Slice(fragment,openStart,openEnd)}}
/**
The empty slice.
*/function removeRange(content,from,to){let{index:index,offset:offset}=content.findIndex(from),child=content.maybeChild(index),{index:indexTo,offset:offsetTo}=content.findIndex(to);if(offset==from||child.isText){if(offsetTo!=to&&!content.child(indexTo).isText)throw new RangeError("Removing non-flat range");return content.cut(0,from).append(content.cut(to))}if(index!=indexTo)throw new RangeError("Removing non-flat range");return content.replaceChild(index,child.copy(removeRange(child.content,from-offset-1,to-offset-1)))}function insertInto(content,dist,insert,parent){let{index:index,offset:offset}=content.findIndex(dist),child=content.maybeChild(index);if(offset==dist||child.isText)return parent&&!parent.canReplace(index,index,insert)?null:content.cut(0,dist).append(insert).append(content.cut(dist));let inner=insertInto(child.content,dist-offset-1,insert);return inner&&content.replaceChild(index,child.copy(inner))}function replace($from,$to,slice){if(slice.openStart>$from.depth)throw new ReplaceError("Inserted content deeper than insertion position");if($from.depth-slice.openStart!=$to.depth-slice.openEnd)throw new ReplaceError("Inconsistent open depths");return replaceOuter($from,$to,slice,0)}function replaceOuter($from,$to,slice,depth){let index=$from.index(depth),node=$from.node(depth);if(index==$to.index(depth)&&depth<$from.depth-slice.openStart){let inner=replaceOuter($from,$to,slice,depth+1);return node.copy(node.content.replaceChild(index,inner))}if(slice.content.size){if(slice.openStart||slice.openEnd||$from.depth!=depth||$to.depth!=depth){let{start:start,end:end}=prepareSliceForReplace(slice,$from);return forms_close(node,replaceThreeWay($from,start,end,$to,depth))}{// Simple, flat case
let parent=$from.parent,content=parent.content;return forms_close(parent,content.cut(0,$from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))}}return forms_close(node,replaceTwoWay($from,$to,depth))}function checkJoin(main,sub){if(!sub.type.compatibleContent(main.type))throw new ReplaceError("Cannot join "+sub.type.name+" onto "+main.type.name)}function joinable$1($before,$after,depth){let node=$before.node(depth);return checkJoin(node,$after.node(depth)),node}function addNode(child,target){let last=target.length-1;last>=0&&child.isText&&child.sameMarkup(target[last])?target[last]=child.withText(target[last].text+child.text):target.push(child)}function addRange($start,$end,depth,target){let node=($end||$start).node(depth),startIndex=0,endIndex=$end?$end.index(depth):node.childCount;$start&&(startIndex=$start.index(depth),$start.depth>depth?startIndex++:$start.textOffset&&(addNode($start.nodeAfter,target),startIndex++));for(let i=startIndex;i<endIndex;i++)addNode(node.child(i),target);$end&&$end.depth==depth&&$end.textOffset&&addNode($end.nodeBefore,target)}function forms_close(node,content){return node.type.checkContent(content),node.copy(content)}function replaceThreeWay($from,$start,$end,$to,depth){let openStart=$from.depth>depth&&joinable$1($from,$start,depth+1),openEnd=$to.depth>depth&&joinable$1($end,$to,depth+1),content=[];return addRange(null,$from,depth,content),openStart&&openEnd&&$start.index(depth)==$end.index(depth)?(checkJoin(openStart,openEnd),addNode(forms_close(openStart,replaceThreeWay($from,$start,$end,$to,depth+1)),content)):(openStart&&addNode(forms_close(openStart,replaceTwoWay($from,$start,depth+1)),content),addRange($start,$end,depth,content),openEnd&&addNode(forms_close(openEnd,replaceTwoWay($end,$to,depth+1)),content)),addRange($to,null,depth,content),new Fragment(content)}function replaceTwoWay($from,$to,depth){let content=[];if(addRange(null,$from,depth,content),$from.depth>depth){let type=joinable$1($from,$to,depth+1);addNode(forms_close(type,replaceTwoWay($from,$to,depth+1)),content)}return addRange($to,null,depth,content),new Fragment(content)}function prepareSliceForReplace(slice,$along){let extra=$along.depth-slice.openStart,parent=$along.node(extra),node=parent.copy(slice.content);for(let i=extra-1;i>=0;i--)node=$along.node(i).copy(Fragment.from(node));return{start:node.resolveNoCache(slice.openStart+extra),end:node.resolveNoCache(node.content.size-slice.openEnd-extra)}}
/**
You can [_resolve_](https://prosemirror.net/docs/ref/#model.Node.resolve) a position to get more
information about it. Objects of this class represent such a
resolved position, providing various pieces of context
information, and some helper methods.

Throughout this interface, methods that take an optional `depth`
parameter will interpret undefined as `this.depth` and negative
numbers as `this.depth + value`.
*/Slice.empty=new Slice(Fragment.empty,0,0);class ResolvedPos{
/**
    @internal
    */
constructor(
/**
    The position that was resolved.
    */
pos,
/**
    @internal
    */
path,
/**
    The offset this position has into its parent node.
    */
parentOffset){this.pos=pos,this.path=path,this.parentOffset=parentOffset,this.depth=path.length/3-1}
/**
    @internal
    */resolveDepth(val){return null==val?this.depth:val<0?this.depth+val:val}
/**
    The parent node that the position points into. Note that even if
    a position points into a text node, that node is not considered
    the parent—text nodes are ‘flat’ in this model, and have no content.
    */get parent(){return this.node(this.depth)}
/**
    The root node in which the position was resolved.
    */get doc(){return this.node(0)}
/**
    The ancestor node at the given level. `p.node(p.depth)` is the
    same as `p.parent`.
    */node(depth){return this.path[3*this.resolveDepth(depth)]}
/**
    The index into the ancestor at the given level. If this points
    at the 3rd node in the 2nd paragraph on the top level, for
    example, `p.index(0)` is 1 and `p.index(1)` is 2.
    */index(depth){return this.path[3*this.resolveDepth(depth)+1]}
/**
    The index pointing after this position into the ancestor at the
    given level.
    */indexAfter(depth){return depth=this.resolveDepth(depth),this.index(depth)+(depth!=this.depth||this.textOffset?1:0)}
/**
    The (absolute) position at the start of the node at the given
    level.
    */start(depth){return depth=this.resolveDepth(depth),0==depth?0:this.path[3*depth-1]+1}
/**
    The (absolute) position at the end of the node at the given
    level.
    */end(depth){return depth=this.resolveDepth(depth),this.start(depth)+this.node(depth).content.size}
/**
    The (absolute) position directly before the wrapping node at the
    given level, or, when `depth` is `this.depth + 1`, the original
    position.
    */before(depth){if(depth=this.resolveDepth(depth),!depth)throw new RangeError("There is no position before the top-level node");return depth==this.depth+1?this.pos:this.path[3*depth-1]}
/**
    The (absolute) position directly after the wrapping node at the
    given level, or the original position when `depth` is `this.depth + 1`.
    */after(depth){if(depth=this.resolveDepth(depth),!depth)throw new RangeError("There is no position after the top-level node");return depth==this.depth+1?this.pos:this.path[3*depth-1]+this.path[3*depth].nodeSize}
/**
    When this position points into a text node, this returns the
    distance between the position and the start of the text node.
    Will be zero for positions that point between nodes.
    */get textOffset(){return this.pos-this.path[this.path.length-1]}
/**
    Get the node directly after the position, if any. If the position
    points into a text node, only the part of that node after the
    position is returned.
    */get nodeAfter(){let parent=this.parent,index=this.index(this.depth);if(index==parent.childCount)return null;let dOff=this.pos-this.path[this.path.length-1],child=parent.child(index);return dOff?parent.child(index).cut(dOff):child}
/**
    Get the node directly before the position, if any. If the
    position points into a text node, only the part of that node
    before the position is returned.
    */get nodeBefore(){let index=this.index(this.depth),dOff=this.pos-this.path[this.path.length-1];return dOff?this.parent.child(index).cut(0,dOff):0==index?null:this.parent.child(index-1)}
/**
    Get the position at the given index in the parent node at the
    given depth (which defaults to `this.depth`).
    */posAtIndex(index,depth){depth=this.resolveDepth(depth);let node=this.path[3*depth],pos=0==depth?0:this.path[3*depth-1]+1;for(let i=0;i<index;i++)pos+=node.child(i).nodeSize;return pos}
/**
    Get the marks at this position, factoring in the surrounding
    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
    position is at the start of a non-empty node, the marks of the
    node after it (if any) are returned.
    */marks(){let parent=this.parent,index=this.index();
// In an empty parent, return the empty array
if(0==parent.content.size)return Mark$1.none;
// When inside a text node, just return the text node's marks
if(this.textOffset)return parent.child(index).marks;let main=parent.maybeChild(index-1),other=parent.maybeChild(index);
// If the `after` flag is true of there is no node before, make
// the node after this position the main reference.
if(!main){let tmp=main;main=other,other=tmp}
// Use all marks in the main node, except those that have
// `inclusive` set to false and are not present in the other node.
let marks=main.marks;for(var i=0;i<marks.length;i++)!1!==marks[i].type.spec.inclusive||other&&marks[i].isInSet(other.marks)||(marks=marks[i--].removeFromSet(marks));return marks}
/**
    Get the marks after the current position, if any, except those
    that are non-inclusive and not present at position `$end`. This
    is mostly useful for getting the set of marks to preserve after a
    deletion. Will return `null` if this position is at the end of
    its parent node or its parent node isn't a textblock (in which
    case no marks should be preserved).
    */marksAcross($end){let after=this.parent.maybeChild(this.index());if(!after||!after.isInline)return null;let marks=after.marks,next=$end.parent.maybeChild($end.index());for(var i=0;i<marks.length;i++)!1!==marks[i].type.spec.inclusive||next&&marks[i].isInSet(next.marks)||(marks=marks[i--].removeFromSet(marks));return marks}
/**
    The depth up to which this position and the given (non-resolved)
    position share the same parent nodes.
    */sharedDepth(pos){for(let depth=this.depth;depth>0;depth--)if(this.start(depth)<=pos&&this.end(depth)>=pos)return depth;return 0}
/**
    Returns a range based on the place where this position and the
    given position diverge around block content. If both point into
    the same textblock, for example, a range around that textblock
    will be returned. If they point into different blocks, the range
    around those blocks in their shared ancestor is returned. You can
    pass in an optional predicate that will be called with a parent
    node to see if a range into that parent is acceptable.
    */blockRange(other=this,pred){if(other.pos<this.pos)return other.blockRange(this);for(let d=this.depth-(this.parent.inlineContent||this.pos==other.pos?1:0);d>=0;d--)if(other.pos<=this.end(d)&&(!pred||pred(this.node(d))))return new NodeRange(this,other,d);return null}
/**
    Query whether the given position shares the same parent node.
    */sameParent(other){return this.pos-this.parentOffset==other.pos-other.parentOffset}
/**
    Return the greater of this and the given position.
    */max(other){return other.pos>this.pos?other:this}
/**
    Return the smaller of this and the given position.
    */min(other){return other.pos<this.pos?other:this}
/**
    @internal
    */toString(){let str="";for(let i=1;i<=this.depth;i++)str+=(str?"/":"")+this.node(i).type.name+"_"+this.index(i-1);return str+":"+this.parentOffset}
/**
    @internal
    */static resolve(doc,pos){if(!(pos>=0&&pos<=doc.content.size))throw new RangeError("Position "+pos+" out of range");let path=[],start=0,parentOffset=pos;for(let node=doc;;){let{index:index,offset:offset}=node.content.findIndex(parentOffset),rem=parentOffset-offset;if(path.push(node,index,start+offset),!rem)break;if(node=node.child(index),node.isText)break;parentOffset=rem-1,start+=offset+1}return new ResolvedPos(pos,path,parentOffset)}
/**
    @internal
    */static resolveCached(doc,pos){for(let i=0;i<resolveCache.length;i++){let cached=resolveCache[i];if(cached.pos==pos&&cached.doc==doc)return cached}let result=resolveCache[resolveCachePos]=ResolvedPos.resolve(doc,pos);return resolveCachePos=(resolveCachePos+1)%resolveCacheSize,result}}let resolveCache=[],resolveCachePos=0,resolveCacheSize=12;
/**
Represents a flat range of content, i.e. one that starts and
ends in the same node.
*/class NodeRange{
/**
    Construct a node range. `$from` and `$to` should point into the
    same node until at least the given `depth`, since a node range
    denotes an adjacent set of nodes in a single parent node.
    */
constructor(
/**
    A resolved position along the start of the content. May have a
    `depth` greater than this object's `depth` property, since
    these are the positions that were used to compute the range,
    not re-resolved positions directly at its boundaries.
    */
$from,
/**
    A position along the end of the content. See
    caveat for [`$from`](https://prosemirror.net/docs/ref/#model.NodeRange.$from).
    */
$to,
/**
    The depth of the node that this range points into.
    */
depth){this.$from=$from,this.$to=$to,this.depth=depth}
/**
    The position at the start of the range.
    */get start(){return this.$from.before(this.depth+1)}
/**
    The position at the end of the range.
    */get end(){return this.$to.after(this.depth+1)}
/**
    The parent node that the range points into.
    */get parent(){return this.$from.node(this.depth)}
/**
    The start index of the range in the parent node.
    */get startIndex(){return this.$from.index(this.depth)}
/**
    The end index of the range in the parent node.
    */get endIndex(){return this.$to.indexAfter(this.depth)}}const emptyAttrs=Object.create(null);
/**
This class represents a node in the tree that makes up a
ProseMirror document. So a document is an instance of `Node`, with
children that are also instances of `Node`.

Nodes are persistent data structures. Instead of changing them, you
create new ones with the content you want. Old ones keep pointing
at the old document shape. This is made cheaper by sharing
structure between the old and new data as much as possible, which a
tree shape like this (without back pointers) makes easy.

**Do not** directly mutate the properties of a `Node` object. See
[the guide](/docs/guide/#doc) for more information.
*/class Node$2{
/**
    @internal
    */
constructor(
/**
    The type of node that this is.
    */
type,
/**
    An object mapping attribute names to values. The kind of
    attributes allowed and required are
    [determined](https://prosemirror.net/docs/ref/#model.NodeSpec.attrs) by the node type.
    */
attrs,
// A fragment holding the node's children.
content,
/**
    The marks (things like whether it is emphasized or part of a
    link) applied to this node.
    */
marks=Mark$1.none){this.type=type,this.attrs=attrs,this.marks=marks,this.content=content||Fragment.empty}
/**
    The size of this node, as defined by the integer-based [indexing
    scheme](/docs/guide/#doc.indexing). For text nodes, this is the
    amount of characters. For other leaf nodes, it is one. For
    non-leaf nodes, it is the size of the content plus two (the
    start and end token).
    */get nodeSize(){return this.isLeaf?1:2+this.content.size}
/**
    The number of children that the node has.
    */get childCount(){return this.content.childCount}
/**
    Get the child node at the given index. Raises an error when the
    index is out of range.
    */child(index){return this.content.child(index)}
/**
    Get the child node at the given index, if it exists.
    */maybeChild(index){return this.content.maybeChild(index)}
/**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */forEach(f){this.content.forEach(f)}
/**
    Invoke a callback for all descendant nodes recursively between
    the given two positions that are relative to start of this
    node's content. The callback is invoked with the node, its
    parent-relative position, its parent node, and its child index.
    When the callback returns false for a given node, that node's
    children will not be recursed over. The last parameter can be
    used to specify a starting position to count from.
    */nodesBetween(from,to,f,startPos=0){this.content.nodesBetween(from,to,f,startPos,this)}
/**
    Call the given callback for every descendant node. Doesn't
    descend into a node when the callback returns `false`.
    */descendants(f){this.nodesBetween(0,this.content.size,f)}
/**
    Concatenates all the text nodes found in this fragment and its
    children.
    */get textContent(){return this.isLeaf&&this.type.spec.leafText?this.type.spec.leafText(this):this.textBetween(0,this.content.size,"")}
/**
    Get all text between positions `from` and `to`. When
    `blockSeparator` is given, it will be inserted to separate text
    from different block nodes. If `leafText` is given, it'll be
    inserted for every non-text leaf node encountered, otherwise
    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
    */textBetween(from,to,blockSeparator,leafText){return this.content.textBetween(from,to,blockSeparator,leafText)}
/**
    Returns this node's first child, or `null` if there are no
    children.
    */get firstChild(){return this.content.firstChild}
/**
    Returns this node's last child, or `null` if there are no
    children.
    */get lastChild(){return this.content.lastChild}
/**
    Test whether two nodes represent the same piece of document.
    */eq(other){return this==other||this.sameMarkup(other)&&this.content.eq(other.content)}
/**
    Compare the markup (type, attributes, and marks) of this node to
    those of another. Returns `true` if both have the same markup.
    */sameMarkup(other){return this.hasMarkup(other.type,other.attrs,other.marks)}
/**
    Check whether this node's markup correspond to the given type,
    attributes, and marks.
    */hasMarkup(type,attrs,marks){return this.type==type&&compareDeep(this.attrs,attrs||type.defaultAttrs||emptyAttrs)&&Mark$1.sameSet(this.marks,marks||Mark$1.none)}
/**
    Create a new node with the same markup as this node, containing
    the given content (or empty, if no content is given).
    */copy(content=null){return content==this.content?this:new Node$2(this.type,this.attrs,content,this.marks)}
/**
    Create a copy of this node, with the given set of marks instead
    of the node's own marks.
    */mark(marks){return marks==this.marks?this:new Node$2(this.type,this.attrs,this.content,marks)}
/**
    Create a copy of this node with only the content between the
    given positions. If `to` is not given, it defaults to the end of
    the node.
    */cut(from,to=this.content.size){return 0==from&&to==this.content.size?this:this.copy(this.content.cut(from,to))}
/**
    Cut out the part of the document between the given positions, and
    return it as a `Slice` object.
    */slice(from,to=this.content.size,includeParents=!1){if(from==to)return Slice.empty;let $from=this.resolve(from),$to=this.resolve(to),depth=includeParents?0:$from.sharedDepth(to),start=$from.start(depth),node=$from.node(depth),content=node.content.cut($from.pos-start,$to.pos-start);return new Slice(content,$from.depth-depth,$to.depth-depth)}
/**
    Replace the part of the document between the given positions with
    the given slice. The slice must 'fit', meaning its open sides
    must be able to connect to the surrounding content, and its
    content nodes must be valid children for the node they are placed
    into. If any of this is violated, an error of type
    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
    */replace(from,to,slice){return replace(this.resolve(from),this.resolve(to),slice)}
/**
    Find the node directly after the given position.
    */nodeAt(pos){for(let node=this;;){let{index:index,offset:offset}=node.content.findIndex(pos);if(node=node.maybeChild(index),!node)return null;if(offset==pos||node.isText)return node;pos-=offset+1}}
/**
    Find the (direct) child node after the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */childAfter(pos){let{index:index,offset:offset}=this.content.findIndex(pos);return{node:this.content.maybeChild(index),index:index,offset:offset}}
/**
    Find the (direct) child node before the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */childBefore(pos){if(0==pos)return{node:null,index:0,offset:0};let{index:index,offset:offset}=this.content.findIndex(pos);if(offset<pos)return{node:this.content.child(index),index:index,offset:offset};let node=this.content.child(index-1);return{node:node,index:index-1,offset:offset-node.nodeSize}}
/**
    Resolve the given position in the document, returning an
    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
    */resolve(pos){return ResolvedPos.resolveCached(this,pos)}
/**
    @internal
    */resolveNoCache(pos){return ResolvedPos.resolve(this,pos)}
/**
    Test whether a given mark or mark type occurs in this document
    between the two given positions.
    */rangeHasMark(from,to,type){let found=!1;return to>from&&this.nodesBetween(from,to,(node=>(type.isInSet(node.marks)&&(found=!0),!found))),found}
/**
    True when this is a block (non-inline node)
    */get isBlock(){return this.type.isBlock}
/**
    True when this is a textblock node, a block node with inline
    content.
    */get isTextblock(){return this.type.isTextblock}
/**
    True when this node allows inline content.
    */get inlineContent(){return this.type.inlineContent}
/**
    True when this is an inline node (a text node or a node that can
    appear among text).
    */get isInline(){return this.type.isInline}
/**
    True when this is a text node.
    */get isText(){return this.type.isText}
/**
    True when this is a leaf node.
    */get isLeaf(){return this.type.isLeaf}
/**
    True when this is an atom, i.e. when it does not have directly
    editable content. This is usually the same as `isLeaf`, but can
    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
    on a node's spec (typically used when the node is displayed as
    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
    */get isAtom(){return this.type.isAtom}
/**
    Return a string representation of this node for debugging
    purposes.
    */toString(){if(this.type.spec.toDebugString)return this.type.spec.toDebugString(this);let name=this.type.name;return this.content.size&&(name+="("+this.content.toStringInner()+")"),wrapMarks(this.marks,name)}
/**
    Get the content match in this node at the given index.
    */contentMatchAt(index){let match=this.type.contentMatch.matchFragment(this.content,0,index);if(!match)throw new Error("Called contentMatchAt on a node with invalid content");return match}
/**
    Test whether replacing the range between `from` and `to` (by
    child index) with the given replacement fragment (which defaults
    to the empty fragment) would leave the node's content valid. You
    can optionally pass `start` and `end` indices into the
    replacement fragment.
    */canReplace(from,to,replacement=Fragment.empty,start=0,end=replacement.childCount){let one=this.contentMatchAt(from).matchFragment(replacement,start,end),two=one&&one.matchFragment(this.content,to);if(!two||!two.validEnd)return!1;for(let i=start;i<end;i++)if(!this.type.allowsMarks(replacement.child(i).marks))return!1;return!0}
/**
    Test whether replacing the range `from` to `to` (by index) with
    a node of the given type would leave the node's content valid.
    */canReplaceWith(from,to,type,marks){if(marks&&!this.type.allowsMarks(marks))return!1;let start=this.contentMatchAt(from).matchType(type),end=start&&start.matchFragment(this.content,to);return!!end&&end.validEnd}
/**
    Test whether the given node's content could be appended to this
    node. If that node is empty, this will only return true if there
    is at least one node type that can appear in both nodes (to avoid
    merging completely incompatible nodes).
    */canAppend(other){return other.content.size?this.canReplace(this.childCount,this.childCount,other.content):this.type.compatibleContent(other.type)}
/**
    Check whether this node and its descendants conform to the
    schema, and raise error when they do not.
    */check(){this.type.checkContent(this.content);let copy=Mark$1.none;for(let i=0;i<this.marks.length;i++)copy=this.marks[i].addToSet(copy);if(!Mark$1.sameSet(copy,this.marks))throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m=>m.type.name))}`);this.content.forEach((node=>node.check()))}
/**
    Return a JSON-serializeable representation of this node.
    */toJSON(){let obj={type:this.type.name};for(let _ in this.attrs){obj.attrs=this.attrs;break}return this.content.size&&(obj.content=this.content.toJSON()),this.marks.length&&(obj.marks=this.marks.map((n=>n.toJSON()))),obj}
/**
    Deserialize a node from its JSON representation.
    */static fromJSON(schema,json){if(!json)throw new RangeError("Invalid input for Node.fromJSON");let marks=null;if(json.marks){if(!Array.isArray(json.marks))throw new RangeError("Invalid mark data for Node.fromJSON");marks=json.marks.map(schema.markFromJSON)}if("text"==json.type){if("string"!=typeof json.text)throw new RangeError("Invalid text node in JSON");return schema.text(json.text,marks)}let content=Fragment.fromJSON(schema,json.content);return schema.nodeType(json.type).create(json.attrs,content,marks)}}Node$2.prototype.text=void 0;class TextNode extends Node$2{
/**
    @internal
    */
constructor(type,attrs,content,marks){if(super(type,attrs,null,marks),!content)throw new RangeError("Empty text nodes are not allowed");this.text=content}toString(){return this.type.spec.toDebugString?this.type.spec.toDebugString(this):wrapMarks(this.marks,JSON.stringify(this.text))}get textContent(){return this.text}textBetween(from,to){return this.text.slice(from,to)}get nodeSize(){return this.text.length}mark(marks){return marks==this.marks?this:new TextNode(this.type,this.attrs,this.text,marks)}withText(text){return text==this.text?this:new TextNode(this.type,this.attrs,text,this.marks)}cut(from=0,to=this.text.length){return 0==from&&to==this.text.length?this:this.withText(this.text.slice(from,to))}eq(other){return this.sameMarkup(other)&&this.text==other.text}toJSON(){let base=super.toJSON();return base.text=this.text,base}}function wrapMarks(marks,str){for(let i=marks.length-1;i>=0;i--)str=marks[i].type.name+"("+str+")";return str}
/**
Instances of this class represent a match state of a node type's
[content expression](https://prosemirror.net/docs/ref/#model.NodeSpec.content), and can be used to
find out whether further content matches here, and whether a given
position is a valid end of the node.
*/class ContentMatch{
/**
    @internal
    */
constructor(
/**
    True when this match state represents a valid end of the node.
    */
validEnd){this.validEnd=validEnd,
/**
        @internal
        */
this.next=[],
/**
        @internal
        */
this.wrapCache=[]}
/**
    @internal
    */static parse(string,nodeTypes){let stream=new TokenStream(string,nodeTypes);if(null==stream.next)return ContentMatch.empty;let expr=parseExpr(stream);stream.next&&stream.err("Unexpected trailing text");let match=dfa(nfa(expr));return checkForDeadEnds(match,stream),match}
/**
    Match a node type, returning a match after that node if
    successful.
    */matchType(type){for(let i=0;i<this.next.length;i++)if(this.next[i].type==type)return this.next[i].next;return null}
/**
    Try to match a fragment. Returns the resulting match when
    successful.
    */matchFragment(frag,start=0,end=frag.childCount){let cur=this;for(let i=start;cur&&i<end;i++)cur=cur.matchType(frag.child(i).type);return cur}
/**
    @internal
    */get inlineContent(){return 0!=this.next.length&&this.next[0].type.isInline}
/**
    Get the first matching node type at this match position that can
    be generated.
    */get defaultType(){for(let i=0;i<this.next.length;i++){let{type:type}=this.next[i];if(!type.isText&&!type.hasRequiredAttrs())return type}return null}
/**
    @internal
    */compatible(other){for(let i=0;i<this.next.length;i++)for(let j=0;j<other.next.length;j++)if(this.next[i].type==other.next[j].type)return!0;return!1}
/**
    Try to match the given fragment, and if that fails, see if it can
    be made to match by inserting nodes in front of it. When
    successful, return a fragment of inserted nodes (which may be
    empty if nothing had to be inserted). When `toEnd` is true, only
    return a fragment if the resulting match goes to the end of the
    content expression.
    */fillBefore(after,toEnd=!1,startIndex=0){let seen=[this];function search(match,types){let finished=match.matchFragment(after,startIndex);if(finished&&(!toEnd||finished.validEnd))return Fragment.from(types.map((tp=>tp.createAndFill())));for(let i=0;i<match.next.length;i++){let{type:type,next:next}=match.next[i];if(!type.isText&&!type.hasRequiredAttrs()&&-1==seen.indexOf(next)){seen.push(next);let found=search(next,types.concat(type));if(found)return found}}return null}return search(this,[])}
/**
    Find a set of wrapping node types that would allow a node of the
    given type to appear at this position. The result may be empty
    (when it fits directly) and will be null when no such wrapping
    exists.
    */findWrapping(target){for(let i=0;i<this.wrapCache.length;i+=2)if(this.wrapCache[i]==target)return this.wrapCache[i+1];let computed=this.computeWrapping(target);return this.wrapCache.push(target,computed),computed}
/**
    @internal
    */computeWrapping(target){let seen=Object.create(null),active=[{match:this,type:null,via:null}];while(active.length){let current=active.shift(),match=current.match;if(match.matchType(target)){let result=[];for(let obj=current;obj.type;obj=obj.via)result.push(obj.type);return result.reverse()}for(let i=0;i<match.next.length;i++){let{type:type,next:next}=match.next[i];type.isLeaf||type.hasRequiredAttrs()||type.name in seen||current.type&&!next.validEnd||(active.push({match:type.contentMatch,type:type,via:current}),seen[type.name]=!0)}}return null}
/**
    The number of outgoing edges this node has in the finite
    automaton that describes the content expression.
    */get edgeCount(){return this.next.length}
/**
    Get the _n_​th outgoing edge from this node in the finite
    automaton that describes the content expression.
    */edge(n){if(n>=this.next.length)throw new RangeError(`There's no ${n}th edge in this content match`);return this.next[n]}
/**
    @internal
    */toString(){let seen=[];function scan(m){seen.push(m);for(let i=0;i<m.next.length;i++)-1==seen.indexOf(m.next[i].next)&&scan(m.next[i].next)}return scan(this),seen.map(((m,i)=>{let out=i+(m.validEnd?"*":" ")+" ";for(let i=0;i<m.next.length;i++)out+=(i?", ":"")+m.next[i].type.name+"->"+seen.indexOf(m.next[i].next);return out})).join("\n")}}
/**
@internal
*/ContentMatch.empty=new ContentMatch(!0);class TokenStream{constructor(string,nodeTypes){this.string=string,this.nodeTypes=nodeTypes,this.inline=null,this.pos=0,this.tokens=string.split(/\s*(?=\b|\W|$)/),""==this.tokens[this.tokens.length-1]&&this.tokens.pop(),""==this.tokens[0]&&this.tokens.shift()}get next(){return this.tokens[this.pos]}eat(tok){return this.next==tok&&(this.pos++||!0)}err(str){throw new SyntaxError(str+" (in content expression '"+this.string+"')")}}function parseExpr(stream){let exprs=[];do{exprs.push(parseExprSeq(stream))}while(stream.eat("|"));return 1==exprs.length?exprs[0]:{type:"choice",exprs:exprs}}function parseExprSeq(stream){let exprs=[];do{exprs.push(parseExprSubscript(stream))}while(stream.next&&")"!=stream.next&&"|"!=stream.next);return 1==exprs.length?exprs[0]:{type:"seq",exprs:exprs}}function parseExprSubscript(stream){let expr=parseExprAtom(stream);for(;;)if(stream.eat("+"))expr={type:"plus",expr:expr};else if(stream.eat("*"))expr={type:"star",expr:expr};else if(stream.eat("?"))expr={type:"opt",expr:expr};else{if(!stream.eat("{"))break;expr=parseExprRange(stream,expr)}return expr}function parseNum(stream){/\D/.test(stream.next)&&stream.err("Expected number, got '"+stream.next+"'");let result=Number(stream.next);return stream.pos++,result}function parseExprRange(stream,expr){let min=parseNum(stream),max=min;return stream.eat(",")&&(max="}"!=stream.next?parseNum(stream):-1),stream.eat("}")||stream.err("Unclosed braced range"),{type:"range",min:min,max:max,expr:expr}}function resolveName(stream,name){let types=stream.nodeTypes,type=types[name];if(type)return[type];let result=[];for(let typeName in types){let type=types[typeName];type.groups.indexOf(name)>-1&&result.push(type)}return 0==result.length&&stream.err("No node type or group '"+name+"' found"),result}function parseExprAtom(stream){if(stream.eat("(")){let expr=parseExpr(stream);return stream.eat(")")||stream.err("Missing closing paren"),expr}if(!/\W/.test(stream.next)){let exprs=resolveName(stream,stream.next).map((type=>(null==stream.inline?stream.inline=type.isInline:stream.inline!=type.isInline&&stream.err("Mixing inline and block content"),{type:"name",value:type})));return stream.pos++,1==exprs.length?exprs[0]:{type:"choice",exprs:exprs}}stream.err("Unexpected token '"+stream.next+"'")}
/**
Construct an NFA from an expression as returned by the parser. The
NFA is represented as an array of states, which are themselves
arrays of edges, which are `{term, to}` objects. The first state is
the entry state and the last node is the success state.

Note that unlike typical NFAs, the edge ordering in this one is
significant, in that it is used to contruct filler content when
necessary.
*/function nfa(expr){let nfa=[[]];return connect(compile(expr,0),node()),nfa;function node(){return nfa.push([])-1}function edge(from,to,term){let edge={term:term,to:to};return nfa[from].push(edge),edge}function connect(edges,to){edges.forEach((edge=>edge.to=to))}function compile(expr,from){if("choice"==expr.type)return expr.exprs.reduce(((out,expr)=>out.concat(compile(expr,from))),[]);if("seq"!=expr.type){if("star"==expr.type){let loop=node();return edge(from,loop),connect(compile(expr.expr,loop),loop),[edge(loop)]}if("plus"==expr.type){let loop=node();return connect(compile(expr.expr,from),loop),connect(compile(expr.expr,loop),loop),[edge(loop)]}if("opt"==expr.type)return[edge(from)].concat(compile(expr.expr,from));if("range"==expr.type){let cur=from;for(let i=0;i<expr.min;i++){let next=node();connect(compile(expr.expr,cur),next),cur=next}if(-1==expr.max)connect(compile(expr.expr,cur),cur);else for(let i=expr.min;i<expr.max;i++){let next=node();edge(cur,next),connect(compile(expr.expr,cur),next),cur=next}return[edge(cur)]}if("name"==expr.type)return[edge(from,void 0,expr.value)];throw new Error("Unknown expr type")}for(let i=0;;i++){let next=compile(expr.exprs[i],from);if(i==expr.exprs.length-1)return next;connect(next,from=node())}}}function cmp(a,b){return b-a}
// Get the set of nodes reachable by null edges from `node`. Omit
// nodes with only a single null-out-edge, since they may lead to
// needless duplicated nodes.
function nullFrom(nfa,node){let result=[];return scan(node),result.sort(cmp);function scan(node){let edges=nfa[node];if(1==edges.length&&!edges[0].term)return scan(edges[0].to);result.push(node);for(let i=0;i<edges.length;i++){let{term:term,to:to}=edges[i];term||-1!=result.indexOf(to)||scan(to)}}}
// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set
// of state objects (`ContentMatch` instances) with transitions
// between them.
function dfa(nfa){let labeled=Object.create(null);return explore(nullFrom(nfa,0));function explore(states){let out=[];states.forEach((node=>{nfa[node].forEach((({term:term,to:to})=>{if(!term)return;let set;for(let i=0;i<out.length;i++)out[i][0]==term&&(set=out[i][1]);nullFrom(nfa,to).forEach((node=>{set||out.push([term,set=[]]),-1==set.indexOf(node)&&set.push(node)}))}))}));let state=labeled[states.join(",")]=new ContentMatch(states.indexOf(nfa.length-1)>-1);for(let i=0;i<out.length;i++){let states=out[i][1].sort(cmp);state.next.push({type:out[i][0],next:labeled[states.join(",")]||explore(states)})}return state}}function checkForDeadEnds(match,stream){for(let i=0,work=[match];i<work.length;i++){let state=work[i],dead=!state.validEnd,nodes=[];for(let j=0;j<state.next.length;j++){let{type:type,next:next}=state.next[j];nodes.push(type.name),!dead||type.isText||type.hasRequiredAttrs()||(dead=!1),-1==work.indexOf(next)&&work.push(next)}dead&&stream.err("Only non-generatable nodes ("+nodes.join(", ")+") in a required position (see https://prosemirror.net/docs/guide/#generatable)")}}
// For node types where all attrs have a default value (or which don't
// have any attributes), build up a single reusable default attribute
// object, and use it for all nodes that don't specify specific
// attributes.
function defaultAttrs(attrs){let defaults=Object.create(null);for(let attrName in attrs){let attr=attrs[attrName];if(!attr.hasDefault)return null;defaults[attrName]=attr.default}return defaults}function computeAttrs(attrs,value){let built=Object.create(null);for(let name in attrs){let given=value&&value[name];if(void 0===given){let attr=attrs[name];if(!attr.hasDefault)throw new RangeError("No value supplied for attribute "+name);given=attr.default}built[name]=given}return built}function initAttrs(attrs){let result=Object.create(null);if(attrs)for(let name in attrs)result[name]=new Attribute(attrs[name]);return result}
/**
Node types are objects allocated once per `Schema` and used to
[tag](https://prosemirror.net/docs/ref/#model.Node.type) `Node` instances. They contain information
about the node type, such as its name and what kind of node it
represents.
*/class NodeType$1{
/**
    @internal
    */
constructor(
/**
    The name the node type has in this schema.
    */
name,
/**
    A link back to the `Schema` the node type belongs to.
    */
schema,
/**
    The spec that this type is based on
    */
spec){this.name=name,this.schema=schema,this.spec=spec,
/**
        The set of marks allowed in this node. `null` means all marks
        are allowed.
        */
this.markSet=null,this.groups=spec.group?spec.group.split(" "):[],this.attrs=initAttrs(spec.attrs),this.defaultAttrs=defaultAttrs(this.attrs),this.contentMatch=null,this.inlineContent=null,this.isBlock=!(spec.inline||"text"==name),this.isText="text"==name}
/**
    True if this is an inline type.
    */get isInline(){return!this.isBlock}
/**
    True if this is a textblock type, a block that contains inline
    content.
    */get isTextblock(){return this.isBlock&&this.inlineContent}
/**
    True for node types that allow no content.
    */get isLeaf(){return this.contentMatch==ContentMatch.empty}
/**
    True when this node is an atom, i.e. when it does not have
    directly editable content.
    */get isAtom(){return this.isLeaf||!!this.spec.atom}
/**
    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
    */get whitespace(){return this.spec.whitespace||(this.spec.code?"pre":"normal")}
/**
    Tells you whether this node type has any required attributes.
    */hasRequiredAttrs(){for(let n in this.attrs)if(this.attrs[n].isRequired)return!0;return!1}
/**
    Indicates whether this node allows some of the same content as
    the given node type.
    */compatibleContent(other){return this==other||this.contentMatch.compatible(other.contentMatch)}
/**
    @internal
    */computeAttrs(attrs){return!attrs&&this.defaultAttrs?this.defaultAttrs:computeAttrs(this.attrs,attrs)}
/**
    Create a `Node` of this type. The given attributes are
    checked and defaulted (you can pass `null` to use the type's
    defaults entirely, if no required attributes exist). `content`
    may be a `Fragment`, a node, an array of nodes, or
    `null`. Similarly `marks` may be `null` to default to the empty
    set of marks.
    */create(attrs=null,content,marks){if(this.isText)throw new Error("NodeType.create can't construct text nodes");return new Node$2(this,this.computeAttrs(attrs),Fragment.from(content),Mark$1.setFrom(marks))}
/**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
    against the node type's content restrictions, and throw an error
    if it doesn't match.
    */createChecked(attrs=null,content,marks){return content=Fragment.from(content),this.checkContent(content),new Node$2(this,this.computeAttrs(attrs),content,Mark$1.setFrom(marks))}
/**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
    necessary to add nodes to the start or end of the given fragment
    to make it fit the node. If no fitting wrapping can be found,
    return null. Note that, due to the fact that required nodes can
    always be created, this will always succeed if you pass null or
    `Fragment.empty` as content.
    */createAndFill(attrs=null,content,marks){if(attrs=this.computeAttrs(attrs),content=Fragment.from(content),content.size){let before=this.contentMatch.fillBefore(content);if(!before)return null;content=before.append(content)}let matched=this.contentMatch.matchFragment(content),after=matched&&matched.fillBefore(Fragment.empty,!0);return after?new Node$2(this,attrs,content.append(after),Mark$1.setFrom(marks)):null}
/**
    Returns true if the given fragment is valid content for this node
    type with the given attributes.
    */validContent(content){let result=this.contentMatch.matchFragment(content);if(!result||!result.validEnd)return!1;for(let i=0;i<content.childCount;i++)if(!this.allowsMarks(content.child(i).marks))return!1;return!0}
/**
    Throws a RangeError if the given fragment is not valid content for this
    node type.
    @internal
    */checkContent(content){if(!this.validContent(content))throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0,50)}`)}
/**
    Check whether the given mark type is allowed in this node.
    */allowsMarkType(markType){return null==this.markSet||this.markSet.indexOf(markType)>-1}
/**
    Test whether the given set of marks are allowed in this node.
    */allowsMarks(marks){if(null==this.markSet)return!0;for(let i=0;i<marks.length;i++)if(!this.allowsMarkType(marks[i].type))return!1;return!0}
/**
    Removes the marks that are not allowed in this node from the given set.
    */allowedMarks(marks){if(null==this.markSet)return marks;let copy;for(let i=0;i<marks.length;i++)this.allowsMarkType(marks[i].type)?copy&&copy.push(marks[i]):copy||(copy=marks.slice(0,i));return copy?copy.length?copy:Mark$1.none:marks}
/**
    @internal
    */static compile(nodes,schema){let result=Object.create(null);nodes.forEach(((name,spec)=>result[name]=new NodeType$1(name,schema,spec)));let topType=schema.spec.topNode||"doc";if(!result[topType])throw new RangeError("Schema is missing its top node type ('"+topType+"')");if(!result.text)throw new RangeError("Every schema needs a 'text' type");for(let _ in result.text.attrs)throw new RangeError("The text node type should not have attributes");return result}}
// Attribute descriptors
class Attribute{constructor(options){this.hasDefault=Object.prototype.hasOwnProperty.call(options,"default"),this.default=options.default}get isRequired(){return!this.hasDefault}}
// Marks
/**
Like nodes, marks (which are associated with nodes to signify
things like emphasis or being part of a link) are
[tagged](https://prosemirror.net/docs/ref/#model.Mark.type) with type objects, which are
instantiated once per `Schema`.
*/class MarkType{
/**
    @internal
    */
constructor(
/**
    The name of the mark type.
    */
name,
/**
    @internal
    */
rank,
/**
    The schema that this mark type instance is part of.
    */
schema,
/**
    The spec on which the type is based.
    */
spec){this.name=name,this.rank=rank,this.schema=schema,this.spec=spec,this.attrs=initAttrs(spec.attrs),this.excluded=null;let defaults=defaultAttrs(this.attrs);this.instance=defaults?new Mark$1(this,defaults):null}
/**
    Create a mark of this type. `attrs` may be `null` or an object
    containing only some of the mark's attributes. The others, if
    they have defaults, will be added.
    */create(attrs=null){return!attrs&&this.instance?this.instance:new Mark$1(this,computeAttrs(this.attrs,attrs))}
/**
    @internal
    */static compile(marks,schema){let result=Object.create(null),rank=0;return marks.forEach(((name,spec)=>result[name]=new MarkType(name,rank++,schema,spec))),result}
/**
    When there is a mark of this type in the given set, a new set
    without it is returned. Otherwise, the input set is returned.
    */removeFromSet(set){for(var i=0;i<set.length;i++)set[i].type==this&&(set=set.slice(0,i).concat(set.slice(i+1)),i--);return set}
/**
    Tests whether there is a mark of this type in the given set.
    */isInSet(set){for(let i=0;i<set.length;i++)if(set[i].type==this)return set[i]}
/**
    Queries whether a given mark type is
    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
    */excludes(other){return this.excluded.indexOf(other)>-1}}
/**
A document schema. Holds [node](https://prosemirror.net/docs/ref/#model.NodeType) and [mark
type](https://prosemirror.net/docs/ref/#model.MarkType) objects for the nodes and marks that may
occur in conforming documents, and provides functionality for
creating and deserializing such documents.

When given, the type parameters provide the names of the nodes and
marks in this schema.
*/class Schema{
/**
    Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
    */
constructor(spec){
/**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
this.cached=Object.create(null);let instanceSpec=this.spec={};for(let prop in spec)instanceSpec[prop]=spec[prop];instanceSpec.nodes=OrderedMap.from(spec.nodes),instanceSpec.marks=OrderedMap.from(spec.marks||{}),this.nodes=NodeType$1.compile(this.spec.nodes,this),this.marks=MarkType.compile(this.spec.marks,this);let contentExprCache=Object.create(null);for(let prop in this.nodes){if(prop in this.marks)throw new RangeError(prop+" can not be both a node and a mark");let type=this.nodes[prop],contentExpr=type.spec.content||"",markExpr=type.spec.marks;type.contentMatch=contentExprCache[contentExpr]||(contentExprCache[contentExpr]=ContentMatch.parse(contentExpr,this.nodes)),type.inlineContent=type.contentMatch.inlineContent,type.markSet="_"==markExpr?null:markExpr?gatherMarks(this,markExpr.split(" ")):""!=markExpr&&type.inlineContent?null:[]}for(let prop in this.marks){let type=this.marks[prop],excl=type.spec.excludes;type.excluded=null==excl?[type]:""==excl?[]:gatherMarks(this,excl.split(" "))}this.nodeFromJSON=this.nodeFromJSON.bind(this),this.markFromJSON=this.markFromJSON.bind(this),this.topNodeType=this.nodes[this.spec.topNode||"doc"],this.cached.wrappings=Object.create(null)}
/**
    Create a node in this schema. The `type` may be a string or a
    `NodeType` instance. Attributes will be extended with defaults,
    `content` may be a `Fragment`, `null`, a `Node`, or an array of
    nodes.
    */node(type,attrs=null,content,marks){if("string"==typeof type)type=this.nodeType(type);else{if(!(type instanceof NodeType$1))throw new RangeError("Invalid node type: "+type);if(type.schema!=this)throw new RangeError("Node type from different schema used ("+type.name+")")}return type.createChecked(attrs,content,marks)}
/**
    Create a text node in the schema. Empty text nodes are not
    allowed.
    */text(text,marks){let type=this.nodes.text;return new TextNode(type,type.defaultAttrs,text,Mark$1.setFrom(marks))}
/**
    Create a mark with the given type and attributes.
    */mark(type,attrs){return"string"==typeof type&&(type=this.marks[type]),type.create(attrs)}
/**
    Deserialize a node from its JSON representation. This method is
    bound.
    */nodeFromJSON(json){return Node$2.fromJSON(this,json)}
/**
    Deserialize a mark from its JSON representation. This method is
    bound.
    */markFromJSON(json){return Mark$1.fromJSON(this,json)}
/**
    @internal
    */nodeType(name){let found=this.nodes[name];if(!found)throw new RangeError("Unknown node type: "+name);return found}}function gatherMarks(schema,marks){let found=[];for(let i=0;i<marks.length;i++){let name=marks[i],mark=schema.marks[name],ok=mark;if(mark)found.push(mark);else for(let prop in schema.marks){let mark=schema.marks[prop];("_"==name||mark.spec.group&&mark.spec.group.split(" ").indexOf(name)>-1)&&found.push(ok=mark)}if(!ok)throw new SyntaxError("Unknown mark type: '"+marks[i]+"'")}return found}
/**
A DOM parser represents a strategy for parsing DOM content into a
ProseMirror document conforming to a given schema. Its behavior is
defined by an array of [rules](https://prosemirror.net/docs/ref/#model.ParseRule).
*/class DOMParser$1{
/**
    Create a parser that targets the given schema, using the given
    parsing rules.
    */
constructor(
/**
    The schema into which the parser parses.
    */
schema,
/**
    The set of [parse rules](https://prosemirror.net/docs/ref/#model.ParseRule) that the parser
    uses, in order of precedence.
    */
rules){this.schema=schema,this.rules=rules,
/**
        @internal
        */
this.tags=[],
/**
        @internal
        */
this.styles=[],rules.forEach((rule=>{rule.tag?this.tags.push(rule):rule.style&&this.styles.push(rule)})),
// Only normalize list elements when lists in the schema can't directly contain themselves
this.normalizeLists=!this.tags.some((r=>{if(!/^(ul|ol)\b/.test(r.tag)||!r.node)return!1;let node=schema.nodes[r.node];return node.contentMatch.matchType(node)}))}
/**
    Parse a document from the content of a DOM node.
    */parse(dom,options={}){let context=new ParseContext(this,options,!1);return context.addAll(dom,options.from,options.to),context.finish()}
/**
    Parses the content of the given DOM node, like
    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
    options. But unlike that method, which produces a whole node,
    this one returns a slice that is open at the sides, meaning that
    the schema constraints aren't applied to the start of nodes to
    the left of the input and the end of nodes at the end.
    */parseSlice(dom,options={}){let context=new ParseContext(this,options,!0);return context.addAll(dom,options.from,options.to),Slice.maxOpen(context.finish())}
/**
    @internal
    */matchTag(dom,context,after){for(let i=after?this.tags.indexOf(after)+1:0;i<this.tags.length;i++){let rule=this.tags[i];if(matches$1(dom,rule.tag)&&(void 0===rule.namespace||dom.namespaceURI==rule.namespace)&&(!rule.context||context.matchesContext(rule.context))){if(rule.getAttrs){let result=rule.getAttrs(dom);if(!1===result)continue;rule.attrs=result||void 0}return rule}}}
/**
    @internal
    */matchStyle(prop,value,context,after){for(let i=after?this.styles.indexOf(after)+1:0;i<this.styles.length;i++){let rule=this.styles[i],style=rule.style;if(!(0!=style.indexOf(prop)||rule.context&&!context.matchesContext(rule.context)||
// Test that the style string either precisely matches the prop,
// or has an '=' sign after the prop, followed by the given
// value.
style.length>prop.length&&(61!=style.charCodeAt(prop.length)||style.slice(prop.length+1)!=value))){if(rule.getAttrs){let result=rule.getAttrs(value);if(!1===result)continue;rule.attrs=result||void 0}return rule}}}
/**
    @internal
    */static schemaRules(schema){let result=[];function insert(rule){let priority=null==rule.priority?50:rule.priority,i=0;for(;i<result.length;i++){let next=result[i],nextPriority=null==next.priority?50:next.priority;if(nextPriority<priority)break}result.splice(i,0,rule)}for(let name in schema.marks){let rules=schema.marks[name].spec.parseDOM;rules&&rules.forEach((rule=>{insert(rule=copy(rule)),rule.mark||rule.ignore||rule.clearMark||(rule.mark=name)}))}for(let name in schema.nodes){let rules=schema.nodes[name].spec.parseDOM;rules&&rules.forEach((rule=>{insert(rule=copy(rule)),rule.node||rule.ignore||rule.mark||(rule.node=name)}))}return result}
/**
    Construct a DOM parser using the parsing rules listed in a
    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
    */static fromSchema(schema){return schema.cached.domParser||(schema.cached.domParser=new DOMParser$1(schema,DOMParser$1.schemaRules(schema)))}}const blockTags={address:!0,article:!0,aside:!0,blockquote:!0,canvas:!0,dd:!0,div:!0,dl:!0,fieldset:!0,figcaption:!0,figure:!0,footer:!0,form:!0,h1:!0,h2:!0,h3:!0,h4:!0,h5:!0,h6:!0,header:!0,hgroup:!0,hr:!0,li:!0,noscript:!0,ol:!0,output:!0,p:!0,pre:!0,section:!0,table:!0,tfoot:!0,ul:!0},ignoreTags={head:!0,noscript:!0,object:!0,script:!0,style:!0,title:!0},listTags={ol:!0,ul:!0},OPT_PRESERVE_WS=1,OPT_PRESERVE_WS_FULL=2,OPT_OPEN_LEFT=4;function wsOptionsFor(type,preserveWhitespace,base){return null!=preserveWhitespace?(preserveWhitespace?OPT_PRESERVE_WS:0)|("full"===preserveWhitespace?OPT_PRESERVE_WS_FULL:0):type&&"pre"==type.whitespace?OPT_PRESERVE_WS|OPT_PRESERVE_WS_FULL:base&~OPT_OPEN_LEFT}class NodeContext{constructor(type,attrs,
// Marks applied to this node itself
marks,
// Marks that can't apply here, but will be used in children if possible
pendingMarks,solid,match,options){this.type=type,this.attrs=attrs,this.marks=marks,this.pendingMarks=pendingMarks,this.solid=solid,this.options=options,this.content=[],
// Marks applied to the node's children
this.activeMarks=Mark$1.none,
// Nested Marks with same type
this.stashMarks=[],this.match=match||(options&OPT_OPEN_LEFT?null:type.contentMatch)}findWrapping(node){if(!this.match){if(!this.type)return[];let fill=this.type.contentMatch.fillBefore(Fragment.from(node));if(!fill){let wrap,start=this.type.contentMatch;return(wrap=start.findWrapping(node.type))?(this.match=start,wrap):null}this.match=this.type.contentMatch.matchFragment(fill)}return this.match.findWrapping(node.type)}finish(openEnd){if(!(this.options&OPT_PRESERVE_WS)){// Strip trailing whitespace
let m,last=this.content[this.content.length-1];if(last&&last.isText&&(m=/[ \t\r\n\u000c]+$/.exec(last.text))){let text=last;last.text.length==m[0].length?this.content.pop():this.content[this.content.length-1]=text.withText(text.text.slice(0,text.text.length-m[0].length))}}let content=Fragment.from(this.content);return!openEnd&&this.match&&(content=content.append(this.match.fillBefore(Fragment.empty,!0))),this.type?this.type.create(this.attrs,content,this.marks):content}popFromStashMark(mark){for(let i=this.stashMarks.length-1;i>=0;i--)if(mark.eq(this.stashMarks[i]))return this.stashMarks.splice(i,1)[0]}applyPending(nextType){for(let i=0,pending=this.pendingMarks;i<pending.length;i++){let mark=pending[i];(this.type?this.type.allowsMarkType(mark.type):markMayApply(mark.type,nextType))&&!mark.isInSet(this.activeMarks)&&(this.activeMarks=mark.addToSet(this.activeMarks),this.pendingMarks=mark.removeFromSet(this.pendingMarks))}}inlineContext(node){return this.type?this.type.inlineContent:this.content.length?this.content[0].isInline:node.parentNode&&!blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase())}}class ParseContext{constructor(
// The parser we are using.
parser,
// The options passed to this parse.
options,isOpen){this.parser=parser,this.options=options,this.isOpen=isOpen,this.open=0;let topContext,topNode=options.topNode,topOptions=wsOptionsFor(null,options.preserveWhitespace,0)|(isOpen?OPT_OPEN_LEFT:0);topContext=topNode?new NodeContext(topNode.type,topNode.attrs,Mark$1.none,Mark$1.none,!0,options.topMatch||topNode.type.contentMatch,topOptions):new NodeContext(isOpen?null:parser.schema.topNodeType,null,Mark$1.none,Mark$1.none,!0,null,topOptions),this.nodes=[topContext],this.find=options.findPositions,this.needsBlock=!1}get top(){return this.nodes[this.open]}
// Add a DOM node to the content. Text is inserted as text node,
// otherwise, the node is passed to `addElement` or, if it has a
// `style` attribute, `addElementWithStyles`.
addDOM(dom){if(3==dom.nodeType)this.addTextNode(dom);else if(1==dom.nodeType){let style=dom.getAttribute("style");if(style){let marks=this.readStyles(parseStyles(style));if(!marks)return;// A style with ignore: true
let[addMarks,removeMarks]=marks,top=this.top;for(let i=0;i<removeMarks.length;i++)this.removePendingMark(removeMarks[i],top);for(let i=0;i<addMarks.length;i++)this.addPendingMark(addMarks[i]);this.addElement(dom);for(let i=0;i<addMarks.length;i++)this.removePendingMark(addMarks[i],top);for(let i=0;i<removeMarks.length;i++)this.addPendingMark(removeMarks[i])}else this.addElement(dom)}}addTextNode(dom){let value=dom.nodeValue,top=this.top;if(top.options&OPT_PRESERVE_WS_FULL||top.inlineContext(dom)||/[^ \t\r\n\u000c]/.test(value)){if(top.options&OPT_PRESERVE_WS)value=top.options&OPT_PRESERVE_WS_FULL?value.replace(/\r\n?/g,"\n"):value.replace(/\r?\n|\r/g," ");else
// If this starts with whitespace, and there is no node before it, or
// a hard break, or a text node that ends with whitespace, strip the
// leading space.
if(value=value.replace(/[ \t\r\n\u000c]+/g," "),/^[ \t\r\n\u000c]/.test(value)&&this.open==this.nodes.length-1){let nodeBefore=top.content[top.content.length-1],domNodeBefore=dom.previousSibling;(!nodeBefore||domNodeBefore&&"BR"==domNodeBefore.nodeName||nodeBefore.isText&&/[ \t\r\n\u000c]$/.test(nodeBefore.text))&&(value=value.slice(1))}value&&this.insertNode(this.parser.schema.text(value)),this.findInText(dom)}else this.findInside(dom)}
// Try to find a handler for the given tag and use that to parse. If
// none is found, the element's content nodes are added directly.
addElement(dom,matchAfter){let ruleID,name=dom.nodeName.toLowerCase();listTags.hasOwnProperty(name)&&this.parser.normalizeLists&&normalizeList(dom);let rule=this.options.ruleFromNode&&this.options.ruleFromNode(dom)||(ruleID=this.parser.matchTag(dom,this,matchAfter));if(rule?rule.ignore:ignoreTags.hasOwnProperty(name))this.findInside(dom),this.ignoreFallback(dom);else if(!rule||rule.skip||rule.closeParent){rule&&rule.closeParent?this.open=Math.max(0,this.open-1):rule&&rule.skip.nodeType&&(dom=rule.skip);let sync,top=this.top,oldNeedsBlock=this.needsBlock;if(blockTags.hasOwnProperty(name))top.content.length&&top.content[0].isInline&&this.open&&(this.open--,top=this.top),sync=!0,top.type||(this.needsBlock=!0);else if(!dom.firstChild)return void this.leafFallback(dom);this.addAll(dom),sync&&this.sync(top),this.needsBlock=oldNeedsBlock}else this.addElementByRule(dom,rule,!1===rule.consuming?ruleID:void 0)}
// Called for leaf DOM nodes that would otherwise be ignored
leafFallback(dom){"BR"==dom.nodeName&&this.top.type&&this.top.type.inlineContent&&this.addTextNode(dom.ownerDocument.createTextNode("\n"))}
// Called for ignored nodes
ignoreFallback(dom){
// Ignored BR nodes should at least create an inline context
"BR"!=dom.nodeName||this.top.type&&this.top.type.inlineContent||this.findPlace(this.parser.schema.text("-"))}
// Run any style parser associated with the node's styles. Either
// return an array of marks, or null to indicate some of the styles
// had a rule with `ignore` set.
readStyles(styles){let add=Mark$1.none,remove=Mark$1.none;style:for(let i=0;i<styles.length;i+=2)for(let after;;){let rule=this.parser.matchStyle(styles[i],styles[i+1],this,after);if(!rule)continue style;if(rule.ignore)return null;if(rule.clearMark?this.top.pendingMarks.forEach((m=>{rule.clearMark(m)&&(remove=m.addToSet(remove))})):add=this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(add),!1!==rule.consuming)break;after=rule}return[add,remove]}
// Look up a handler for the given node. If none are found, return
// false. Otherwise, apply it, use its return value to drive the way
// the node's content is wrapped, and return true.
addElementByRule(dom,rule,continueAfter){let sync,nodeType,mark;if(rule.node)nodeType=this.parser.schema.nodes[rule.node],nodeType.isLeaf?this.insertNode(nodeType.create(rule.attrs))||this.leafFallback(dom):sync=this.enter(nodeType,rule.attrs||null,rule.preserveWhitespace);else{let markType=this.parser.schema.marks[rule.mark];mark=markType.create(rule.attrs),this.addPendingMark(mark)}let startIn=this.top;if(nodeType&&nodeType.isLeaf)this.findInside(dom);else if(continueAfter)this.addElement(dom,continueAfter);else if(rule.getContent)this.findInside(dom),rule.getContent(dom,this.parser.schema).forEach((node=>this.insertNode(node)));else{let contentDOM=dom;"string"==typeof rule.contentElement?contentDOM=dom.querySelector(rule.contentElement):"function"==typeof rule.contentElement?contentDOM=rule.contentElement(dom):rule.contentElement&&(contentDOM=rule.contentElement),this.findAround(dom,contentDOM,!0),this.addAll(contentDOM)}sync&&this.sync(startIn)&&this.open--,mark&&this.removePendingMark(mark,startIn)}
// Add all child nodes between `startIndex` and `endIndex` (or the
// whole node, if not given). If `sync` is passed, use it to
// synchronize after every block element.
addAll(parent,startIndex,endIndex){let index=startIndex||0;for(let dom=startIndex?parent.childNodes[startIndex]:parent.firstChild,end=null==endIndex?null:parent.childNodes[endIndex];dom!=end;dom=dom.nextSibling,++index)this.findAtPoint(parent,index),this.addDOM(dom);this.findAtPoint(parent,index)}
// Try to find a way to fit the given node type into the current
// context. May add intermediate wrappers and/or leave non-solid
// nodes that we're in.
findPlace(node){let route,sync;for(let depth=this.open;depth>=0;depth--){let cx=this.nodes[depth],found=cx.findWrapping(node);if(found&&(!route||route.length>found.length)&&(route=found,sync=cx,!found.length))break;if(cx.solid)break}if(!route)return!1;this.sync(sync);for(let i=0;i<route.length;i++)this.enterInner(route[i],null,!1);return!0}
// Try to insert the given node, adjusting the context when needed.
insertNode(node){if(node.isInline&&this.needsBlock&&!this.top.type){let block=this.textblockFromContext();block&&this.enterInner(block)}if(this.findPlace(node)){this.closeExtra();let top=this.top;top.applyPending(node.type),top.match&&(top.match=top.match.matchType(node.type));let marks=top.activeMarks;for(let i=0;i<node.marks.length;i++)top.type&&!top.type.allowsMarkType(node.marks[i].type)||(marks=node.marks[i].addToSet(marks));return top.content.push(node.mark(marks)),!0}return!1}
// Try to start a node of the given type, adjusting the context when
// necessary.
enter(type,attrs,preserveWS){let ok=this.findPlace(type.create(attrs));return ok&&this.enterInner(type,attrs,!0,preserveWS),ok}
// Open a node of the given type
enterInner(type,attrs=null,solid=!1,preserveWS){this.closeExtra();let top=this.top;top.applyPending(type),top.match=top.match&&top.match.matchType(type);let options=wsOptionsFor(type,preserveWS,top.options);top.options&OPT_OPEN_LEFT&&0==top.content.length&&(options|=OPT_OPEN_LEFT),this.nodes.push(new NodeContext(type,attrs,top.activeMarks,top.pendingMarks,solid,null,options)),this.open++}
// Make sure all nodes above this.open are finished and added to
// their parents
closeExtra(openEnd=!1){let i=this.nodes.length-1;if(i>this.open){for(;i>this.open;i--)this.nodes[i-1].content.push(this.nodes[i].finish(openEnd));this.nodes.length=this.open+1}}finish(){return this.open=0,this.closeExtra(this.isOpen),this.nodes[0].finish(this.isOpen||this.options.topOpen)}sync(to){for(let i=this.open;i>=0;i--)if(this.nodes[i]==to)return this.open=i,!0;return!1}get currentPos(){this.closeExtra();let pos=0;for(let i=this.open;i>=0;i--){let content=this.nodes[i].content;for(let j=content.length-1;j>=0;j--)pos+=content[j].nodeSize;i&&pos++}return pos}findAtPoint(parent,offset){if(this.find)for(let i=0;i<this.find.length;i++)this.find[i].node==parent&&this.find[i].offset==offset&&(this.find[i].pos=this.currentPos)}findInside(parent){if(this.find)for(let i=0;i<this.find.length;i++)null==this.find[i].pos&&1==parent.nodeType&&parent.contains(this.find[i].node)&&(this.find[i].pos=this.currentPos)}findAround(parent,content,before){if(parent!=content&&this.find)for(let i=0;i<this.find.length;i++)if(null==this.find[i].pos&&1==parent.nodeType&&parent.contains(this.find[i].node)){let pos=content.compareDocumentPosition(this.find[i].node);pos&(before?2:4)&&(this.find[i].pos=this.currentPos)}}findInText(textNode){if(this.find)for(let i=0;i<this.find.length;i++)this.find[i].node==textNode&&(this.find[i].pos=this.currentPos-(textNode.nodeValue.length-this.find[i].offset))}
// Determines whether the given context string matches this context.
matchesContext(context){if(context.indexOf("|")>-1)return context.split(/\s*\|\s*/).some(this.matchesContext,this);let parts=context.split("/"),option=this.options.context,useRoot=!this.isOpen&&(!option||option.parent.type==this.nodes[0].type),minDepth=-(option?option.depth+1:0)+(useRoot?0:1),match=(i,depth)=>{for(;i>=0;i--){let part=parts[i];if(""==part){if(i==parts.length-1||0==i)continue;for(;depth>=minDepth;depth--)if(match(i-1,depth))return!0;return!1}{let next=depth>0||0==depth&&useRoot?this.nodes[depth].type:option&&depth>=minDepth?option.node(depth-minDepth).type:null;if(!next||next.name!=part&&-1==next.groups.indexOf(part))return!1;depth--}}return!0};return match(parts.length-1,this.open)}textblockFromContext(){let $context=this.options.context;if($context)for(let d=$context.depth;d>=0;d--){let deflt=$context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;if(deflt&&deflt.isTextblock&&deflt.defaultAttrs)return deflt}for(let name in this.parser.schema.nodes){let type=this.parser.schema.nodes[name];if(type.isTextblock&&type.defaultAttrs)return type}}addPendingMark(mark){let found=findSameMarkInSet(mark,this.top.pendingMarks);found&&this.top.stashMarks.push(found),this.top.pendingMarks=mark.addToSet(this.top.pendingMarks)}removePendingMark(mark,upto){for(let depth=this.open;depth>=0;depth--){let level=this.nodes[depth],found=level.pendingMarks.lastIndexOf(mark);if(found>-1)level.pendingMarks=mark.removeFromSet(level.pendingMarks);else{level.activeMarks=mark.removeFromSet(level.activeMarks);let stashMark=level.popFromStashMark(mark);stashMark&&level.type&&level.type.allowsMarkType(stashMark.type)&&(level.activeMarks=stashMark.addToSet(level.activeMarks))}if(level==upto)break}}}
// Kludge to work around directly nested list nodes produced by some
// tools and allowed by browsers to mean that the nested list is
// actually part of the list item above it.
function normalizeList(dom){for(let child=dom.firstChild,prevItem=null;child;child=child.nextSibling){let name=1==child.nodeType?child.nodeName.toLowerCase():null;name&&listTags.hasOwnProperty(name)&&prevItem?(prevItem.appendChild(child),child=prevItem):"li"==name?prevItem=child:name&&(prevItem=null)}}
// Apply a CSS selector.
function matches$1(dom,selector){return(dom.matches||dom.msMatchesSelector||dom.webkitMatchesSelector||dom.mozMatchesSelector).call(dom,selector)}
// Tokenize a style attribute into property/value pairs.
function parseStyles(style){let m,re=/\s*([\w-]+)\s*:\s*([^;]+)/g,result=[];while(m=re.exec(style))result.push(m[1],m[2].trim());return result}function copy(obj){let copy={};for(let prop in obj)copy[prop]=obj[prop];return copy}
// Used when finding a mark at the top level of a fragment parse.
// Checks whether it would be reasonable to apply a given mark type to
// a given node, by looking at the way the mark occurs in the schema.
function markMayApply(markType,nodeType){let nodes=nodeType.schema.nodes;for(let name in nodes){let parent=nodes[name];if(!parent.allowsMarkType(markType))continue;let seen=[],scan=match=>{seen.push(match);for(let i=0;i<match.edgeCount;i++){let{type:type,next:next}=match.edge(i);if(type==nodeType)return!0;if(seen.indexOf(next)<0&&scan(next))return!0}};if(scan(parent.contentMatch))return!0}}function findSameMarkInSet(mark,set){for(let i=0;i<set.length;i++)if(mark.eq(set[i]))return set[i]}
/**
A DOM serializer knows how to convert ProseMirror nodes and
marks of various types to DOM nodes.
*/class DOMSerializer{
/**
    Create a serializer. `nodes` should map node names to functions
    that take a node and return a description of the corresponding
    DOM. `marks` does the same for mark names, but also gets an
    argument that tells it whether the mark's content is block or
    inline content (for typical use, it'll always be inline). A mark
    serializer may be `null` to indicate that marks of that type
    should not be serialized.
    */
constructor(
/**
    The node serialization functions.
    */
nodes,
/**
    The mark serialization functions.
    */
marks){this.nodes=nodes,this.marks=marks}
/**
    Serialize the content of this fragment to a DOM fragment. When
    not in the browser, the `document` option, containing a DOM
    document, should be passed so that the serializer can create
    nodes.
    */serializeFragment(fragment,options={},target){target||(target=doc$1(options).createDocumentFragment());let top=target,active=[];return fragment.forEach((node=>{if(active.length||node.marks.length){let keep=0,rendered=0;while(keep<active.length&&rendered<node.marks.length){let next=node.marks[rendered];if(this.marks[next.type.name]){if(!next.eq(active[keep][0])||!1===next.type.spec.spanning)break;keep++,rendered++}else rendered++}while(keep<active.length)top=active.pop()[1];while(rendered<node.marks.length){let add=node.marks[rendered++],markDOM=this.serializeMark(add,node.isInline,options);markDOM&&(active.push([add,top]),top.appendChild(markDOM.dom),top=markDOM.contentDOM||markDOM.dom)}}top.appendChild(this.serializeNodeInner(node,options))})),target}
/**
    @internal
    */serializeNodeInner(node,options){let{dom:dom,contentDOM:contentDOM}=DOMSerializer.renderSpec(doc$1(options),this.nodes[node.type.name](node));if(contentDOM){if(node.isLeaf)throw new RangeError("Content hole not allowed in a leaf node spec");this.serializeFragment(node.content,options,contentDOM)}return dom}
/**
    Serialize this node to a DOM node. This can be useful when you
    need to serialize a part of a document, as opposed to the whole
    document. To serialize a whole document, use
    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
    its [content](https://prosemirror.net/docs/ref/#model.Node.content).
    */serializeNode(node,options={}){let dom=this.serializeNodeInner(node,options);for(let i=node.marks.length-1;i>=0;i--){let wrap=this.serializeMark(node.marks[i],node.isInline,options);wrap&&((wrap.contentDOM||wrap.dom).appendChild(dom),dom=wrap.dom)}return dom}
/**
    @internal
    */serializeMark(mark,inline,options={}){let toDOM=this.marks[mark.type.name];return toDOM&&DOMSerializer.renderSpec(doc$1(options),toDOM(mark,inline))}
/**
    Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
    the spec has a hole (zero) in it, `contentDOM` will point at the
    node with the hole.
    */static renderSpec(doc,structure,xmlNS=null){if("string"==typeof structure)return{dom:doc.createTextNode(structure)};if(null!=structure.nodeType)return{dom:structure};if(structure.dom&&null!=structure.dom.nodeType)return structure;let contentDOM,tagName=structure[0],space=tagName.indexOf(" ");space>0&&(xmlNS=tagName.slice(0,space),tagName=tagName.slice(space+1));let dom=xmlNS?doc.createElementNS(xmlNS,tagName):doc.createElement(tagName),attrs=structure[1],start=1;if(attrs&&"object"==typeof attrs&&null==attrs.nodeType&&!Array.isArray(attrs)){start=2;for(let name in attrs)if(null!=attrs[name]){let space=name.indexOf(" ");space>0?dom.setAttributeNS(name.slice(0,space),name.slice(space+1),attrs[name]):dom.setAttribute(name,attrs[name])}}for(let i=start;i<structure.length;i++){let child=structure[i];if(0===child){if(i<structure.length-1||i>start)throw new RangeError("Content hole must be the only child of its parent node");return{dom:dom,contentDOM:dom}}{let{dom:inner,contentDOM:innerContent}=DOMSerializer.renderSpec(doc,child,xmlNS);if(dom.appendChild(inner),innerContent){if(contentDOM)throw new RangeError("Multiple content holes");contentDOM=innerContent}}}return{dom:dom,contentDOM:contentDOM}}
/**
    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
    properties in a schema's node and mark specs.
    */static fromSchema(schema){return schema.cached.domSerializer||(schema.cached.domSerializer=new DOMSerializer(this.nodesFromSchema(schema),this.marksFromSchema(schema)))}
/**
    Gather the serializers in a schema's node specs into an object.
    This can be useful as a base to build a custom serializer from.
    */static nodesFromSchema(schema){let result=gatherToDOM(schema.nodes);return result.text||(result.text=node=>node.text),result}
/**
    Gather the serializers in a schema's mark specs into an object.
    */static marksFromSchema(schema){return gatherToDOM(schema.marks)}}function gatherToDOM(obj){let result={};for(let name in obj){let toDOM=obj[name].spec.toDOM;toDOM&&(result[name]=toDOM)}return result}function doc$1(options){return options.document||window.document}
// Recovery values encode a range index and an offset. They are
// represented as numbers, because tons of them will be created when
// mapping, for example, a large number of decorations. The number's
// lower 16 bits provide the index, the remaining bits the offset.

// Note: We intentionally don't use bit shift operators to en- and
// decode these, since those clip to 32 bits, which we might in rare
// cases want to overflow. A 64-bit float can represent 48-bit
// integers precisely.
const lower16=65535,factor16=Math.pow(2,16);function makeRecover(index,offset){return index+offset*factor16}function recoverIndex(value){return value&lower16}function recoverOffset(value){return(value-(value&lower16))/factor16}const DEL_BEFORE=1,DEL_AFTER=2,DEL_ACROSS=4,DEL_SIDE=8;
/**
An object representing a mapped position with extra
information.
*/class MapResult{
/**
    @internal
    */
constructor(
/**
    The mapped version of the position.
    */
pos,
/**
    @internal
    */
delInfo,
/**
    @internal
    */
recover){this.pos=pos,this.delInfo=delInfo,this.recover=recover}
/**
    Tells you whether the position was deleted, that is, whether the
    step removed the token on the side queried (via the `assoc`)
    argument from the document.
    */get deleted(){return(this.delInfo&DEL_SIDE)>0}
/**
    Tells you whether the token before the mapped position was deleted.
    */get deletedBefore(){return(this.delInfo&(DEL_BEFORE|DEL_ACROSS))>0}
/**
    True when the token after the mapped position was deleted.
    */get deletedAfter(){return(this.delInfo&(DEL_AFTER|DEL_ACROSS))>0}
/**
    Tells whether any of the steps mapped through deletes across the
    position (including both the token before and after the
    position).
    */get deletedAcross(){return(this.delInfo&DEL_ACROSS)>0}}
/**
A map describing the deletions and insertions made by a step, which
can be used to find the correspondence between positions in the
pre-step version of a document and the same position in the
post-step version.
*/class StepMap{
/**
    Create a position map. The modifications to the document are
    represented as an array of numbers, in which each group of three
    represents a modified chunk as `[start, oldSize, newSize]`.
    */
constructor(
/**
    @internal
    */
ranges,
/**
    @internal
    */
inverted=!1){if(this.ranges=ranges,this.inverted=inverted,!ranges.length&&StepMap.empty)return StepMap.empty}
/**
    @internal
    */recover(value){let diff=0,index=recoverIndex(value);if(!this.inverted)for(let i=0;i<index;i++)diff+=this.ranges[3*i+2]-this.ranges[3*i+1];return this.ranges[3*index]+diff+recoverOffset(value)}mapResult(pos,assoc=1){return this._map(pos,assoc,!1)}map(pos,assoc=1){return this._map(pos,assoc,!0)}
/**
    @internal
    */_map(pos,assoc,simple){let diff=0,oldIndex=this.inverted?2:1,newIndex=this.inverted?1:2;for(let i=0;i<this.ranges.length;i+=3){let start=this.ranges[i]-(this.inverted?diff:0);if(start>pos)break;let oldSize=this.ranges[i+oldIndex],newSize=this.ranges[i+newIndex],end=start+oldSize;if(pos<=end){let side=oldSize?pos==start?-1:pos==end?1:assoc:assoc,result=start+diff+(side<0?0:newSize);if(simple)return result;let recover=pos==(assoc<0?start:end)?null:makeRecover(i/3,pos-start),del=pos==start?DEL_AFTER:pos==end?DEL_BEFORE:DEL_ACROSS;return(assoc<0?pos!=start:pos!=end)&&(del|=DEL_SIDE),new MapResult(result,del,recover)}diff+=newSize-oldSize}return simple?pos+diff:new MapResult(pos+diff,0,null)}
/**
    @internal
    */touches(pos,recover){let diff=0,index=recoverIndex(recover),oldIndex=this.inverted?2:1,newIndex=this.inverted?1:2;for(let i=0;i<this.ranges.length;i+=3){let start=this.ranges[i]-(this.inverted?diff:0);if(start>pos)break;let oldSize=this.ranges[i+oldIndex],end=start+oldSize;if(pos<=end&&i==3*index)return!0;diff+=this.ranges[i+newIndex]-oldSize}return!1}
/**
    Calls the given function on each of the changed ranges included in
    this map.
    */forEach(f){let oldIndex=this.inverted?2:1,newIndex=this.inverted?1:2;for(let i=0,diff=0;i<this.ranges.length;i+=3){let start=this.ranges[i],oldStart=start-(this.inverted?diff:0),newStart=start+(this.inverted?0:diff),oldSize=this.ranges[i+oldIndex],newSize=this.ranges[i+newIndex];f(oldStart,oldStart+oldSize,newStart,newStart+newSize),diff+=newSize-oldSize}}
/**
    Create an inverted version of this map. The result can be used to
    map positions in the post-step document to the pre-step document.
    */invert(){return new StepMap(this.ranges,!this.inverted)}
/**
    @internal
    */toString(){return(this.inverted?"-":"")+JSON.stringify(this.ranges)}
/**
    Create a map that moves all positions by offset `n` (which may be
    negative). This can be useful when applying steps meant for a
    sub-document to a larger document, or vice-versa.
    */static offset(n){return 0==n?StepMap.empty:new StepMap(n<0?[0,-n,0]:[0,0,n])}}
/**
A StepMap that contains no changed ranges.
*/StepMap.empty=new StepMap([]);
/**
A mapping represents a pipeline of zero or more [step
maps](https://prosemirror.net/docs/ref/#transform.StepMap). It has special provisions for losslessly
handling mapping positions through a series of steps in which some
steps are inverted versions of earlier steps. (This comes up when
‘[rebasing](/docs/guide/#transform.rebasing)’ steps for
collaboration or history management.)
*/
class Mapping{
/**
    Create a new mapping with the given position maps.
    */
constructor(
/**
    The step maps in this mapping.
    */
maps=[]
/**
    @internal
    */,mirror,
/**
    The starting position in the `maps` array, used when `map` or
    `mapResult` is called.
    */
from=0
/**
    The end position in the `maps` array.
    */,to=maps.length){this.maps=maps,this.mirror=mirror,this.from=from,this.to=to}
/**
    Create a mapping that maps only through a part of this one.
    */slice(from=0,to=this.maps.length){return new Mapping(this.maps,this.mirror,from,to)}
/**
    @internal
    */copy(){return new Mapping(this.maps.slice(),this.mirror&&this.mirror.slice(),this.from,this.to)}
/**
    Add a step map to the end of this mapping. If `mirrors` is
    given, it should be the index of the step map that is the mirror
    image of this one.
    */appendMap(map,mirrors){this.to=this.maps.push(map),null!=mirrors&&this.setMirror(this.maps.length-1,mirrors)}
/**
    Add all the step maps in a given mapping to this one (preserving
    mirroring information).
    */appendMapping(mapping){for(let i=0,startSize=this.maps.length;i<mapping.maps.length;i++){let mirr=mapping.getMirror(i);this.appendMap(mapping.maps[i],null!=mirr&&mirr<i?startSize+mirr:void 0)}}
/**
    Finds the offset of the step map that mirrors the map at the
    given offset, in this mapping (as per the second argument to
    `appendMap`).
    */getMirror(n){if(this.mirror)for(let i=0;i<this.mirror.length;i++)if(this.mirror[i]==n)return this.mirror[i+(i%2?-1:1)]}
/**
    @internal
    */setMirror(n,m){this.mirror||(this.mirror=[]),this.mirror.push(n,m)}
/**
    Append the inverse of the given mapping to this one.
    */appendMappingInverted(mapping){for(let i=mapping.maps.length-1,totalSize=this.maps.length+mapping.maps.length;i>=0;i--){let mirr=mapping.getMirror(i);this.appendMap(mapping.maps[i].invert(),null!=mirr&&mirr>i?totalSize-mirr-1:void 0)}}
/**
    Create an inverted version of this mapping.
    */invert(){let inverse=new Mapping;return inverse.appendMappingInverted(this),inverse}
/**
    Map a position through this mapping.
    */map(pos,assoc=1){if(this.mirror)return this._map(pos,assoc,!0);for(let i=this.from;i<this.to;i++)pos=this.maps[i].map(pos,assoc);return pos}
/**
    Map a position through this mapping, returning a mapping
    result.
    */mapResult(pos,assoc=1){return this._map(pos,assoc,!1)}
/**
    @internal
    */_map(pos,assoc,simple){let delInfo=0;for(let i=this.from;i<this.to;i++){let map=this.maps[i],result=map.mapResult(pos,assoc);if(null!=result.recover){let corr=this.getMirror(i);if(null!=corr&&corr>i&&corr<this.to){i=corr,pos=this.maps[corr].recover(result.recover);continue}}delInfo|=result.delInfo,pos=result.pos}return simple?pos:new MapResult(pos,delInfo,null)}}const stepsByID=Object.create(null);
/**
A step object represents an atomic change. It generally applies
only to the document it was created for, since the positions
stored in it will only make sense for that document.

New steps are defined by creating classes that extend `Step`,
overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`
methods, and registering your class with a unique
JSON-serialization identifier using
[`Step.jsonID`](https://prosemirror.net/docs/ref/#transform.Step^jsonID).
*/class Step{
/**
    Get the step map that represents the changes made by this step,
    and which can be used to transform between positions in the old
    and the new document.
    */
getMap(){return StepMap.empty}
/**
    Try to merge this step with another one, to be applied directly
    after it. Returns the merged step when possible, null if the
    steps can't be merged.
    */merge(other){return null}
/**
    Deserialize a step from its JSON representation. Will call
    through to the step class' own implementation of this method.
    */static fromJSON(schema,json){if(!json||!json.stepType)throw new RangeError("Invalid input for Step.fromJSON");let type=stepsByID[json.stepType];if(!type)throw new RangeError(`No step type ${json.stepType} defined`);return type.fromJSON(schema,json)}
/**
    To be able to serialize steps to JSON, each step needs a string
    ID to attach to its JSON representation. Use this method to
    register an ID for your step classes. Try to pick something
    that's unlikely to clash with steps from other modules.
    */static jsonID(id,stepClass){if(id in stepsByID)throw new RangeError("Duplicate use of step JSON ID "+id);return stepsByID[id]=stepClass,stepClass.prototype.jsonID=id,stepClass}}
/**
The result of [applying](https://prosemirror.net/docs/ref/#transform.Step.apply) a step. Contains either a
new document or a failure value.
*/class StepResult{
/**
    @internal
    */
constructor(
/**
    The transformed document, if successful.
    */
doc,
/**
    The failure message, if unsuccessful.
    */
failed){this.doc=doc,this.failed=failed}
/**
    Create a successful step result.
    */static ok(doc){return new StepResult(doc,null)}
/**
    Create a failed step result.
    */static fail(message){return new StepResult(null,message)}
/**
    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
    arguments. Create a successful result if it succeeds, and a
    failed one if it throws a `ReplaceError`.
    */static fromReplace(doc,from,to,slice){try{return StepResult.ok(doc.replace(from,to,slice))}catch(e){if(e instanceof ReplaceError)return StepResult.fail(e.message);throw e}}}function mapFragment(fragment,f,parent){let mapped=[];for(let i=0;i<fragment.childCount;i++){let child=fragment.child(i);child.content.size&&(child=child.copy(mapFragment(child.content,f,child))),child.isInline&&(child=f(child,parent,i)),mapped.push(child)}return Fragment.fromArray(mapped)}
/**
Add a mark to all inline content between two positions.
*/class AddMarkStep extends Step{
/**
    Create a mark step.
    */
constructor(
/**
    The start of the marked range.
    */
from,
/**
    The end of the marked range.
    */
to,
/**
    The mark to add.
    */
mark){super(),this.from=from,this.to=to,this.mark=mark}apply(doc){let oldSlice=doc.slice(this.from,this.to),$from=doc.resolve(this.from),parent=$from.node($from.sharedDepth(this.to)),slice=new Slice(mapFragment(oldSlice.content,((node,parent)=>node.isAtom&&parent.type.allowsMarkType(this.mark.type)?node.mark(this.mark.addToSet(node.marks)):node),parent),oldSlice.openStart,oldSlice.openEnd);return StepResult.fromReplace(doc,this.from,this.to,slice)}invert(){return new RemoveMarkStep(this.from,this.to,this.mark)}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1);return from.deleted&&to.deleted||from.pos>=to.pos?null:new AddMarkStep(from.pos,to.pos,this.mark)}merge(other){return other instanceof AddMarkStep&&other.mark.eq(this.mark)&&this.from<=other.to&&this.to>=other.from?new AddMarkStep(Math.min(this.from,other.from),Math.max(this.to,other.to),this.mark):null}toJSON(){return{stepType:"addMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to)throw new RangeError("Invalid input for AddMarkStep.fromJSON");return new AddMarkStep(json.from,json.to,schema.markFromJSON(json.mark))}}Step.jsonID("addMark",AddMarkStep);
/**
Remove a mark from all inline content between two positions.
*/
class RemoveMarkStep extends Step{
/**
    Create a mark-removing step.
    */
constructor(
/**
    The start of the unmarked range.
    */
from,
/**
    The end of the unmarked range.
    */
to,
/**
    The mark to remove.
    */
mark){super(),this.from=from,this.to=to,this.mark=mark}apply(doc){let oldSlice=doc.slice(this.from,this.to),slice=new Slice(mapFragment(oldSlice.content,(node=>node.mark(this.mark.removeFromSet(node.marks))),doc),oldSlice.openStart,oldSlice.openEnd);return StepResult.fromReplace(doc,this.from,this.to,slice)}invert(){return new AddMarkStep(this.from,this.to,this.mark)}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1);return from.deleted&&to.deleted||from.pos>=to.pos?null:new RemoveMarkStep(from.pos,to.pos,this.mark)}merge(other){return other instanceof RemoveMarkStep&&other.mark.eq(this.mark)&&this.from<=other.to&&this.to>=other.from?new RemoveMarkStep(Math.min(this.from,other.from),Math.max(this.to,other.to),this.mark):null}toJSON(){return{stepType:"removeMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to)throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");return new RemoveMarkStep(json.from,json.to,schema.markFromJSON(json.mark))}}Step.jsonID("removeMark",RemoveMarkStep);
/**
Add a mark to a specific node.
*/
class AddNodeMarkStep extends Step{
/**
    Create a node mark step.
    */
constructor(
/**
    The position of the target node.
    */
pos,
/**
    The mark to add.
    */
mark){super(),this.pos=pos,this.mark=mark}apply(doc){let node=doc.nodeAt(this.pos);if(!node)return StepResult.fail("No node at mark step's position");let updated=node.type.create(node.attrs,null,this.mark.addToSet(node.marks));return StepResult.fromReplace(doc,this.pos,this.pos+1,new Slice(Fragment.from(updated),0,node.isLeaf?0:1))}invert(doc){let node=doc.nodeAt(this.pos);if(node){let newSet=this.mark.addToSet(node.marks);if(newSet.length==node.marks.length){for(let i=0;i<node.marks.length;i++)if(!node.marks[i].isInSet(newSet))return new AddNodeMarkStep(this.pos,node.marks[i]);return new AddNodeMarkStep(this.pos,this.mark)}}return new RemoveNodeMarkStep(this.pos,this.mark)}map(mapping){let pos=mapping.mapResult(this.pos,1);return pos.deletedAfter?null:new AddNodeMarkStep(pos.pos,this.mark)}toJSON(){return{stepType:"addNodeMark",pos:this.pos,mark:this.mark.toJSON()}}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.pos)throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");return new AddNodeMarkStep(json.pos,schema.markFromJSON(json.mark))}}Step.jsonID("addNodeMark",AddNodeMarkStep);
/**
Remove a mark from a specific node.
*/
class RemoveNodeMarkStep extends Step{
/**
    Create a mark-removing step.
    */
constructor(
/**
    The position of the target node.
    */
pos,
/**
    The mark to remove.
    */
mark){super(),this.pos=pos,this.mark=mark}apply(doc){let node=doc.nodeAt(this.pos);if(!node)return StepResult.fail("No node at mark step's position");let updated=node.type.create(node.attrs,null,this.mark.removeFromSet(node.marks));return StepResult.fromReplace(doc,this.pos,this.pos+1,new Slice(Fragment.from(updated),0,node.isLeaf?0:1))}invert(doc){let node=doc.nodeAt(this.pos);return node&&this.mark.isInSet(node.marks)?new AddNodeMarkStep(this.pos,this.mark):this}map(mapping){let pos=mapping.mapResult(this.pos,1);return pos.deletedAfter?null:new RemoveNodeMarkStep(pos.pos,this.mark)}toJSON(){return{stepType:"removeNodeMark",pos:this.pos,mark:this.mark.toJSON()}}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.pos)throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");return new RemoveNodeMarkStep(json.pos,schema.markFromJSON(json.mark))}}Step.jsonID("removeNodeMark",RemoveNodeMarkStep);
/**
Replace a part of the document with a slice of new content.
*/
class ReplaceStep extends Step{
/**
    The given `slice` should fit the 'gap' between `from` and
    `to`—the depths must line up, and the surrounding nodes must be
    able to be joined with the open sides of the slice. When
    `structure` is true, the step will fail if the content between
    from and to is not just a sequence of closing and then opening
    tokens (this is to guard against rebased replace steps
    overwriting something they weren't supposed to).
    */
constructor(
/**
    The start position of the replaced range.
    */
from,
/**
    The end position of the replaced range.
    */
to,
/**
    The slice to insert.
    */
slice,
/**
    @internal
    */
structure=!1){super(),this.from=from,this.to=to,this.slice=slice,this.structure=structure}apply(doc){return this.structure&&contentBetween(doc,this.from,this.to)?StepResult.fail("Structure replace would overwrite content"):StepResult.fromReplace(doc,this.from,this.to,this.slice)}getMap(){return new StepMap([this.from,this.to-this.from,this.slice.size])}invert(doc){return new ReplaceStep(this.from,this.from+this.slice.size,doc.slice(this.from,this.to))}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1);return from.deletedAcross&&to.deletedAcross?null:new ReplaceStep(from.pos,Math.max(from.pos,to.pos),this.slice)}merge(other){if(!(other instanceof ReplaceStep)||other.structure||this.structure)return null;if(this.from+this.slice.size!=other.from||this.slice.openEnd||other.slice.openStart){if(other.to!=this.from||this.slice.openStart||other.slice.openEnd)return null;{let slice=this.slice.size+other.slice.size==0?Slice.empty:new Slice(other.slice.content.append(this.slice.content),other.slice.openStart,this.slice.openEnd);return new ReplaceStep(other.from,this.to,slice,this.structure)}}{let slice=this.slice.size+other.slice.size==0?Slice.empty:new Slice(this.slice.content.append(other.slice.content),this.slice.openStart,other.slice.openEnd);return new ReplaceStep(this.from,this.to+(other.to-other.from),slice,this.structure)}}toJSON(){let json={stepType:"replace",from:this.from,to:this.to};return this.slice.size&&(json.slice=this.slice.toJSON()),this.structure&&(json.structure=!0),json}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to)throw new RangeError("Invalid input for ReplaceStep.fromJSON");return new ReplaceStep(json.from,json.to,Slice.fromJSON(schema,json.slice),!!json.structure)}}Step.jsonID("replace",ReplaceStep);
/**
Replace a part of the document with a slice of content, but
preserve a range of the replaced content by moving it into the
slice.
*/
class ReplaceAroundStep extends Step{
/**
    Create a replace-around step with the given range and gap.
    `insert` should be the point in the slice into which the content
    of the gap should be moved. `structure` has the same meaning as
    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
    */
constructor(
/**
    The start position of the replaced range.
    */
from,
/**
    The end position of the replaced range.
    */
to,
/**
    The start of preserved range.
    */
gapFrom,
/**
    The end of preserved range.
    */
gapTo,
/**
    The slice to insert.
    */
slice,
/**
    The position in the slice where the preserved range should be
    inserted.
    */
insert,
/**
    @internal
    */
structure=!1){super(),this.from=from,this.to=to,this.gapFrom=gapFrom,this.gapTo=gapTo,this.slice=slice,this.insert=insert,this.structure=structure}apply(doc){if(this.structure&&(contentBetween(doc,this.from,this.gapFrom)||contentBetween(doc,this.gapTo,this.to)))return StepResult.fail("Structure gap-replace would overwrite content");let gap=doc.slice(this.gapFrom,this.gapTo);if(gap.openStart||gap.openEnd)return StepResult.fail("Gap is not a flat range");let inserted=this.slice.insertAt(this.insert,gap.content);return inserted?StepResult.fromReplace(doc,this.from,this.to,inserted):StepResult.fail("Content does not fit in gap")}getMap(){return new StepMap([this.from,this.gapFrom-this.from,this.insert,this.gapTo,this.to-this.gapTo,this.slice.size-this.insert])}invert(doc){let gap=this.gapTo-this.gapFrom;return new ReplaceAroundStep(this.from,this.from+this.slice.size+gap,this.from+this.insert,this.from+this.insert+gap,doc.slice(this.from,this.to).removeBetween(this.gapFrom-this.from,this.gapTo-this.from),this.gapFrom-this.from,this.structure)}map(mapping){let from=mapping.mapResult(this.from,1),to=mapping.mapResult(this.to,-1),gapFrom=mapping.map(this.gapFrom,-1),gapTo=mapping.map(this.gapTo,1);return from.deletedAcross&&to.deletedAcross||gapFrom<from.pos||gapTo>to.pos?null:new ReplaceAroundStep(from.pos,to.pos,gapFrom,gapTo,this.slice,this.insert,this.structure)}toJSON(){let json={stepType:"replaceAround",from:this.from,to:this.to,gapFrom:this.gapFrom,gapTo:this.gapTo,insert:this.insert};return this.slice.size&&(json.slice=this.slice.toJSON()),this.structure&&(json.structure=!0),json}
/**
    @internal
    */static fromJSON(schema,json){if("number"!=typeof json.from||"number"!=typeof json.to||"number"!=typeof json.gapFrom||"number"!=typeof json.gapTo||"number"!=typeof json.insert)throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");return new ReplaceAroundStep(json.from,json.to,json.gapFrom,json.gapTo,Slice.fromJSON(schema,json.slice),json.insert,!!json.structure)}}function contentBetween(doc,from,to){let $from=doc.resolve(from),dist=to-from,depth=$from.depth;while(dist>0&&depth>0&&$from.indexAfter(depth)==$from.node(depth).childCount)depth--,dist--;if(dist>0){let next=$from.node(depth).maybeChild($from.indexAfter(depth));while(dist>0){if(!next||next.isLeaf)return!0;next=next.firstChild,dist--}}return!1}function addMark(tr,from,to,mark){let removing,adding,removed=[],added=[];tr.doc.nodesBetween(from,to,((node,pos,parent)=>{if(!node.isInline)return;let marks=node.marks;if(!mark.isInSet(marks)&&parent.type.allowsMarkType(mark.type)){let start=Math.max(pos,from),end=Math.min(pos+node.nodeSize,to),newSet=mark.addToSet(marks);for(let i=0;i<marks.length;i++)marks[i].isInSet(newSet)||(removing&&removing.to==start&&removing.mark.eq(marks[i])?removing.to=end:removed.push(removing=new RemoveMarkStep(start,end,marks[i])));adding&&adding.to==start?adding.to=end:added.push(adding=new AddMarkStep(start,end,mark))}})),removed.forEach((s=>tr.step(s))),added.forEach((s=>tr.step(s)))}function removeMark(tr,from,to,mark){let matched=[],step=0;tr.doc.nodesBetween(from,to,((node,pos)=>{if(!node.isInline)return;step++;let toRemove=null;if(mark instanceof MarkType){let found,set=node.marks;while(found=mark.isInSet(set))(toRemove||(toRemove=[])).push(found),set=found.removeFromSet(set)}else mark?mark.isInSet(node.marks)&&(toRemove=[mark]):toRemove=node.marks;if(toRemove&&toRemove.length){let end=Math.min(pos+node.nodeSize,to);for(let i=0;i<toRemove.length;i++){let found,style=toRemove[i];for(let j=0;j<matched.length;j++){let m=matched[j];m.step==step-1&&style.eq(matched[j].style)&&(found=m)}found?(found.to=end,found.step=step):matched.push({style:style,from:Math.max(pos,from),to:end,step:step})}}})),matched.forEach((m=>tr.step(new RemoveMarkStep(m.from,m.to,m.style))))}function clearIncompatible(tr,pos,parentType,match=parentType.contentMatch){let node=tr.doc.nodeAt(pos),delSteps=[],cur=pos+1;for(let i=0;i<node.childCount;i++){let child=node.child(i),end=cur+child.nodeSize,allowed=match.matchType(child.type);if(allowed){match=allowed;for(let j=0;j<child.marks.length;j++)parentType.allowsMarkType(child.marks[j].type)||tr.step(new RemoveMarkStep(cur,end,child.marks[j]))}else delSteps.push(new ReplaceStep(cur,end,Slice.empty));cur=end}if(!match.validEnd){let fill=match.fillBefore(Fragment.empty,!0);tr.replace(cur,cur,new Slice(fill,0,0))}for(let i=delSteps.length-1;i>=0;i--)tr.step(delSteps[i])}function canCut(node,start,end){return(0==start||node.canReplace(start,node.childCount))&&(end==node.childCount||node.canReplace(0,end))}
/**
Try to find a target depth to which the content in the given range
can be lifted. Will not go across
[isolating](https://prosemirror.net/docs/ref/#model.NodeSpec.isolating) parent nodes.
*/function liftTarget(range){let parent=range.parent,content=parent.content.cutByIndex(range.startIndex,range.endIndex);for(let depth=range.depth;;--depth){let node=range.$from.node(depth),index=range.$from.index(depth),endIndex=range.$to.indexAfter(depth);if(depth<range.depth&&node.canReplace(index,endIndex,content))return depth;if(0==depth||node.type.spec.isolating||!canCut(node,index,endIndex))break}return null}function lift$2(tr,range,target){let{$from:$from,$to:$to,depth:depth}=range,gapStart=$from.before(depth+1),gapEnd=$to.after(depth+1),start=gapStart,end=gapEnd,before=Fragment.empty,openStart=0;for(let d=depth,splitting=!1;d>target;d--)splitting||$from.index(d)>0?(splitting=!0,before=Fragment.from($from.node(d).copy(before)),openStart++):start--;let after=Fragment.empty,openEnd=0;for(let d=depth,splitting=!1;d>target;d--)splitting||$to.after(d+1)<$to.end(d)?(splitting=!0,after=Fragment.from($to.node(d).copy(after)),openEnd++):end++;tr.step(new ReplaceAroundStep(start,end,gapStart,gapEnd,new Slice(before.append(after),openStart,openEnd),before.size-openStart,!0))}
/**
Try to find a valid way to wrap the content in the given range in a
node of the given type. May introduce extra nodes around and inside
the wrapper node, if necessary. Returns null if no valid wrapping
could be found. When `innerRange` is given, that range's content is
used as the content to fit into the wrapping, instead of the
content of `range`.
*/function findWrapping(range,nodeType,attrs=null,innerRange=range){let around=findWrappingOutside(range,nodeType),inner=around&&findWrappingInside(innerRange,nodeType);return inner?around.map(withAttrs).concat({type:nodeType,attrs:attrs}).concat(inner.map(withAttrs)):null}function withAttrs(type){return{type:type,attrs:null}}function findWrappingOutside(range,type){let{parent:parent,startIndex:startIndex,endIndex:endIndex}=range,around=parent.contentMatchAt(startIndex).findWrapping(type);if(!around)return null;let outer=around.length?around[0]:type;return parent.canReplaceWith(startIndex,endIndex,outer)?around:null}function findWrappingInside(range,type){let{parent:parent,startIndex:startIndex,endIndex:endIndex}=range,inner=parent.child(startIndex),inside=type.contentMatch.findWrapping(inner.type);if(!inside)return null;let lastType=inside.length?inside[inside.length-1]:type,innerMatch=lastType.contentMatch;for(let i=startIndex;innerMatch&&i<endIndex;i++)innerMatch=innerMatch.matchType(parent.child(i).type);return innerMatch&&innerMatch.validEnd?inside:null}function wrap(tr,range,wrappers){let content=Fragment.empty;for(let i=wrappers.length-1;i>=0;i--){if(content.size){let match=wrappers[i].type.contentMatch.matchFragment(content);if(!match||!match.validEnd)throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper")}content=Fragment.from(wrappers[i].type.create(wrappers[i].attrs,content))}let start=range.start,end=range.end;tr.step(new ReplaceAroundStep(start,end,start,end,new Slice(content,0,0),wrappers.length,!0))}function setBlockType$1(tr,from,to,type,attrs){if(!type.isTextblock)throw new RangeError("Type given to setBlockType should be a textblock");let mapFrom=tr.steps.length;tr.doc.nodesBetween(from,to,((node,pos)=>{if(node.isTextblock&&!node.hasMarkup(type,attrs)&&canChangeType(tr.doc,tr.mapping.slice(mapFrom).map(pos),type)){
// Ensure all markup that isn't allowed in the new node type is cleared
tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos,1),type);let mapping=tr.mapping.slice(mapFrom),startM=mapping.map(pos,1),endM=mapping.map(pos+node.nodeSize,1);return tr.step(new ReplaceAroundStep(startM,endM,startM+1,endM-1,new Slice(Fragment.from(type.create(attrs,null,node.marks)),0,0),1,!0)),!1}}))}function canChangeType(doc,pos,type){let $pos=doc.resolve(pos),index=$pos.index();return $pos.parent.canReplaceWith(index,index+1,type)}
/**
Change the type, attributes, and/or marks of the node at `pos`.
When `type` isn't given, the existing node type is preserved,
*/function setNodeMarkup(tr,pos,type,attrs,marks){let node=tr.doc.nodeAt(pos);if(!node)throw new RangeError("No node at given position");type||(type=node.type);let newNode=type.create(attrs,null,marks||node.marks);if(node.isLeaf)return tr.replaceWith(pos,pos+node.nodeSize,newNode);if(!type.validContent(node.content))throw new RangeError("Invalid content for node type "+type.name);tr.step(new ReplaceAroundStep(pos,pos+node.nodeSize,pos+1,pos+node.nodeSize-1,new Slice(Fragment.from(newNode),0,0),1,!0))}
/**
Check whether splitting at the given position is allowed.
*/function canSplit(doc,pos,depth=1,typesAfter){let $pos=doc.resolve(pos),base=$pos.depth-depth,innerType=typesAfter&&typesAfter[typesAfter.length-1]||$pos.parent;if(base<0||$pos.parent.type.spec.isolating||!$pos.parent.canReplace($pos.index(),$pos.parent.childCount)||!innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(),$pos.parent.childCount)))return!1;for(let d=$pos.depth-1,i=depth-2;d>base;d--,i--){let node=$pos.node(d),index=$pos.index(d);if(node.type.spec.isolating)return!1;let rest=node.content.cutByIndex(index,node.childCount),after=typesAfter&&typesAfter[i]||node;if(after!=node&&(rest=rest.replaceChild(0,after.type.create(after.attrs))),!node.canReplace(index+1,node.childCount)||!after.type.validContent(rest))return!1}let index=$pos.indexAfter(base),baseType=typesAfter&&typesAfter[0];return $pos.node(base).canReplaceWith(index,index,baseType?baseType.type:$pos.node(base+1).type)}function split(tr,pos,depth=1,typesAfter){let $pos=tr.doc.resolve(pos),before=Fragment.empty,after=Fragment.empty;for(let d=$pos.depth,e=$pos.depth-depth,i=depth-1;d>e;d--,i--){before=Fragment.from($pos.node(d).copy(before));let typeAfter=typesAfter&&typesAfter[i];after=Fragment.from(typeAfter?typeAfter.type.create(typeAfter.attrs,after):$pos.node(d).copy(after))}tr.step(new ReplaceStep(pos,pos,new Slice(before.append(after),depth,depth),!0))}
/**
Test whether the blocks before and after a given position can be
joined.
*/function canJoin(doc,pos){let $pos=doc.resolve(pos),index=$pos.index();return joinable($pos.nodeBefore,$pos.nodeAfter)&&$pos.parent.canReplace(index,index+1)}function joinable(a,b){return!(!a||!b||a.isLeaf||!a.canAppend(b))}
/**
Find an ancestor of the given position that can be joined to the
block before (or after if `dir` is positive). Returns the joinable
point, if any.
*/function joinPoint(doc,pos,dir=-1){let $pos=doc.resolve(pos);for(let d=$pos.depth;;d--){let before,after,index=$pos.index(d);if(d==$pos.depth?(before=$pos.nodeBefore,after=$pos.nodeAfter):dir>0?(before=$pos.node(d+1),index++,after=$pos.node(d).maybeChild(index)):(before=$pos.node(d).maybeChild(index-1),after=$pos.node(d+1)),before&&!before.isTextblock&&joinable(before,after)&&$pos.node(d).canReplace(index,index+1))return pos;if(0==d)break;pos=dir<0?$pos.before(d):$pos.after(d)}}function join(tr,pos,depth){let step=new ReplaceStep(pos-depth,pos+depth,Slice.empty,!0);tr.step(step)}
/**
Try to find a point where a node of the given type can be inserted
near `pos`, by searching up the node hierarchy when `pos` itself
isn't a valid place but is at the start or end of a node. Return
null if no position was found.
*/function insertPoint(doc,pos,nodeType){let $pos=doc.resolve(pos);if($pos.parent.canReplaceWith($pos.index(),$pos.index(),nodeType))return pos;if(0==$pos.parentOffset)for(let d=$pos.depth-1;d>=0;d--){let index=$pos.index(d);if($pos.node(d).canReplaceWith(index,index,nodeType))return $pos.before(d+1);if(index>0)return null}if($pos.parentOffset==$pos.parent.content.size)for(let d=$pos.depth-1;d>=0;d--){let index=$pos.indexAfter(d);if($pos.node(d).canReplaceWith(index,index,nodeType))return $pos.after(d+1);if(index<$pos.node(d).childCount)return null}return null}
/**
Finds a position at or around the given position where the given
slice can be inserted. Will look at parent nodes' nearest boundary
and try there, even if the original position wasn't directly at the
start or end of that node. Returns null when no position was found.
*/function dropPoint(doc,pos,slice){let $pos=doc.resolve(pos);if(!slice.content.size)return pos;let content=slice.content;for(let i=0;i<slice.openStart;i++)content=content.firstChild.content;for(let pass=1;pass<=(0==slice.openStart&&slice.size?2:1);pass++)for(let d=$pos.depth;d>=0;d--){let bias=d==$pos.depth?0:$pos.pos<=($pos.start(d+1)+$pos.end(d+1))/2?-1:1,insertPos=$pos.index(d)+(bias>0?1:0),parent=$pos.node(d),fits=!1;if(1==pass)fits=parent.canReplace(insertPos,insertPos,content);else{let wrapping=parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);fits=wrapping&&parent.canReplaceWith(insertPos,insertPos,wrapping[0])}if(fits)return 0==bias?$pos.pos:bias<0?$pos.before(d+1):$pos.after(d+1)}return null}
/**
‘Fit’ a slice into a given position in the document, producing a
[step](https://prosemirror.net/docs/ref/#transform.Step) that inserts it. Will return null if
there's no meaningful way to insert the slice here, or inserting it
would be a no-op (an empty slice over an empty range).
*/function replaceStep(doc,from,to=from,slice=Slice.empty){if(from==to&&!slice.size)return null;let $from=doc.resolve(from),$to=doc.resolve(to);
// Optimization -- avoid work if it's obvious that it's not needed.
return fitsTrivially($from,$to,slice)?new ReplaceStep(from,to,slice):new Fitter($from,$to,slice).fit()}function fitsTrivially($from,$to,slice){return!slice.openStart&&!slice.openEnd&&$from.start()==$to.start()&&$from.parent.canReplace($from.index(),$to.index(),slice.content)}
// Algorithm for 'placing' the elements of a slice into a gap:

// We consider the content of each node that is open to the left to be
// independently placeable. I.e. in <p("foo"), p("bar")>, when the
// paragraph on the left is open, "foo" can be placed (somewhere on
// the left side of the replacement gap) independently from p("bar").

// This class tracks the state of the placement progress in the
// following properties:

//  - `frontier` holds a stack of `{type, match}` objects that
//    represent the open side of the replacement. It starts at
//    `$from`, then moves forward as content is placed, and is finally
//    reconciled with `$to`.

//  - `unplaced` is a slice that represents the content that hasn't
//    been placed yet.

//  - `placed` is a fragment of placed content. Its open-start value
//    is implicit in `$from`, and its open-end value in `frontier`.
Step.jsonID("replaceAround",ReplaceAroundStep);class Fitter{constructor($from,$to,unplaced){this.$from=$from,this.$to=$to,this.unplaced=unplaced,this.frontier=[],this.placed=Fragment.empty;for(let i=0;i<=$from.depth;i++){let node=$from.node(i);this.frontier.push({type:node.type,match:node.contentMatchAt($from.indexAfter(i))})}for(let i=$from.depth;i>0;i--)this.placed=Fragment.from($from.node(i).copy(this.placed))}get depth(){return this.frontier.length-1}fit(){
// As long as there's unplaced content, try to place some of it.
// If that fails, either increase the open score of the unplaced
// slice, or drop nodes from it, and then try again.
while(this.unplaced.size){let fit=this.findFittable();fit?this.placeNodes(fit):this.openMore()||this.dropNode()}
// When there's inline content directly after the frontier _and_
// directly after `this.$to`, we must generate a `ReplaceAround`
// step that pulls that content into the node after the frontier.
// That means the fitting must be done to the end of the textblock
// node after `this.$to`, not `this.$to` itself.
let moveInline=this.mustMoveInline(),placedSize=this.placed.size-this.depth-this.$from.depth,$from=this.$from,$to=this.close(moveInline<0?this.$to:$from.doc.resolve(moveInline));if(!$to)return null;
// If closing to `$to` succeeded, create a step
let content=this.placed,openStart=$from.depth,openEnd=$to.depth;while(openStart&&openEnd&&1==content.childCount)// Normalize by dropping open parent nodes
content=content.firstChild.content,openStart--,openEnd--;let slice=new Slice(content,openStart,openEnd);return moveInline>-1?new ReplaceAroundStep($from.pos,moveInline,this.$to.pos,this.$to.end(),slice,placedSize):slice.size||$from.pos!=this.$to.pos?new ReplaceStep($from.pos,$to.pos,slice):null}
// Find a position on the start spine of `this.unplaced` that has
// content that can be moved somewhere on the frontier. Returns two
// depths, one for the slice and one for the frontier.
findFittable(){let startDepth=this.unplaced.openStart;for(let cur=this.unplaced.content,d=0,openEnd=this.unplaced.openEnd;d<startDepth;d++){let node=cur.firstChild;if(cur.childCount>1&&(openEnd=0),node.type.spec.isolating&&openEnd<=d){startDepth=d;break}cur=node.content}
// Only try wrapping nodes (pass 2) after finding a place without
// wrapping failed.
for(let pass=1;pass<=2;pass++)for(let sliceDepth=1==pass?startDepth:this.unplaced.openStart;sliceDepth>=0;sliceDepth--){let fragment,parent=null;sliceDepth?(parent=contentAt(this.unplaced.content,sliceDepth-1).firstChild,fragment=parent.content):fragment=this.unplaced.content;let first=fragment.firstChild;for(let frontierDepth=this.depth;frontierDepth>=0;frontierDepth--){let wrap,{type:type,match:match}=this.frontier[frontierDepth],inject=null;
// In pass 1, if the next node matches, or there is no next
// node but the parents look compatible, we've found a
// place.
if(1==pass&&(first?match.matchType(first.type)||(inject=match.fillBefore(Fragment.from(first),!1)):parent&&type.compatibleContent(parent.type)))return{sliceDepth:sliceDepth,frontierDepth:frontierDepth,parent:parent,inject:inject};
// In pass 2, look for a set of wrapping nodes that make
// `first` fit here.
// Don't continue looking further up if the parent node
// would fit here.
if(2==pass&&first&&(wrap=match.findWrapping(first.type)))return{sliceDepth:sliceDepth,frontierDepth:frontierDepth,parent:parent,wrap:wrap};if(parent&&match.matchType(parent.type))break}}}openMore(){let{content:content,openStart:openStart,openEnd:openEnd}=this.unplaced,inner=contentAt(content,openStart);return!(!inner.childCount||inner.firstChild.isLeaf)&&(this.unplaced=new Slice(content,openStart+1,Math.max(openEnd,inner.size+openStart>=content.size-openEnd?openStart+1:0)),!0)}dropNode(){let{content:content,openStart:openStart,openEnd:openEnd}=this.unplaced,inner=contentAt(content,openStart);if(inner.childCount<=1&&openStart>0){let openAtEnd=content.size-openStart<=openStart+inner.size;this.unplaced=new Slice(dropFromFragment(content,openStart-1,1),openStart-1,openAtEnd?openStart-1:openEnd)}else this.unplaced=new Slice(dropFromFragment(content,openStart,1),openStart,openEnd)}
// Move content from the unplaced slice at `sliceDepth` to the
// frontier node at `frontierDepth`. Close that frontier node when
// applicable.
placeNodes({sliceDepth:sliceDepth,frontierDepth:frontierDepth,parent:parent,inject:inject,wrap:wrap}){while(this.depth>frontierDepth)this.closeFrontierNode();if(wrap)for(let i=0;i<wrap.length;i++)this.openFrontierNode(wrap[i]);let slice=this.unplaced,fragment=parent?parent.content:slice.content,openStart=slice.openStart-sliceDepth,taken=0,add=[],{match:match,type:type}=this.frontier[frontierDepth];if(inject){for(let i=0;i<inject.childCount;i++)add.push(inject.child(i));match=match.matchFragment(inject)}
// Computes the amount of (end) open nodes at the end of the
// fragment. When 0, the parent is open, but no more. When
// negative, nothing is open.
let openEndCount=fragment.size+sliceDepth-(slice.content.size-slice.openEnd);
// Scan over the fragment, fitting as many child nodes as
// possible.
while(taken<fragment.childCount){let next=fragment.child(taken),matches=match.matchType(next.type);if(!matches)break;taken++,(taken>1||0==openStart||next.content.size)&&(// Drop empty open nodes
match=matches,add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)),1==taken?openStart:0,taken==fragment.childCount?openEndCount:-1)))}let toEnd=taken==fragment.childCount;toEnd||(openEndCount=-1),this.placed=addToFragment(this.placed,frontierDepth,Fragment.from(add)),this.frontier[frontierDepth].match=match,
// If the parent types match, and the entire node was moved, and
// it's not open, close this frontier node right away.
toEnd&&openEndCount<0&&parent&&parent.type==this.frontier[this.depth].type&&this.frontier.length>1&&this.closeFrontierNode();
// Add new frontier nodes for any open nodes at the end.
for(let i=0,cur=fragment;i<openEndCount;i++){let node=cur.lastChild;this.frontier.push({type:node.type,match:node.contentMatchAt(node.childCount)}),cur=node.content}
// Update `this.unplaced`. Drop the entire node from which we
// placed it we got to its end, otherwise just drop the placed
// nodes.
this.unplaced=toEnd?0==sliceDepth?Slice.empty:new Slice(dropFromFragment(slice.content,sliceDepth-1,1),sliceDepth-1,openEndCount<0?slice.openEnd:sliceDepth-1):new Slice(dropFromFragment(slice.content,sliceDepth,taken),slice.openStart,slice.openEnd)}mustMoveInline(){if(!this.$to.parent.isTextblock)return-1;let level,top=this.frontier[this.depth];if(!top.type.isTextblock||!contentAfterFits(this.$to,this.$to.depth,top.type,top.match,!1)||this.$to.depth==this.depth&&(level=this.findCloseLevel(this.$to))&&level.depth==this.depth)return-1;let{depth:depth}=this.$to,after=this.$to.after(depth);while(depth>1&&after==this.$to.end(--depth))++after;return after}findCloseLevel($to){scan:for(let i=Math.min(this.depth,$to.depth);i>=0;i--){let{match:match,type:type}=this.frontier[i],dropInner=i<$to.depth&&$to.end(i+1)==$to.pos+($to.depth-(i+1)),fit=contentAfterFits($to,i,type,match,dropInner);if(fit){for(let d=i-1;d>=0;d--){let{match:match,type:type}=this.frontier[d],matches=contentAfterFits($to,d,type,match,!0);if(!matches||matches.childCount)continue scan}return{depth:i,fit:fit,move:dropInner?$to.doc.resolve($to.after(i+1)):$to}}}}close($to){let close=this.findCloseLevel($to);if(!close)return null;while(this.depth>close.depth)this.closeFrontierNode();close.fit.childCount&&(this.placed=addToFragment(this.placed,close.depth,close.fit)),$to=close.move;for(let d=close.depth+1;d<=$to.depth;d++){let node=$to.node(d),add=node.type.contentMatch.fillBefore(node.content,!0,$to.index(d));this.openFrontierNode(node.type,node.attrs,add)}return $to}openFrontierNode(type,attrs=null,content){let top=this.frontier[this.depth];top.match=top.match.matchType(type),this.placed=addToFragment(this.placed,this.depth,Fragment.from(type.create(attrs,content))),this.frontier.push({type:type,match:type.contentMatch})}closeFrontierNode(){let open=this.frontier.pop(),add=open.match.fillBefore(Fragment.empty,!0);add.childCount&&(this.placed=addToFragment(this.placed,this.frontier.length,add))}}function dropFromFragment(fragment,depth,count){return 0==depth?fragment.cutByIndex(count,fragment.childCount):fragment.replaceChild(0,fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content,depth-1,count)))}function addToFragment(fragment,depth,content){return 0==depth?fragment.append(content):fragment.replaceChild(fragment.childCount-1,fragment.lastChild.copy(addToFragment(fragment.lastChild.content,depth-1,content)))}function contentAt(fragment,depth){for(let i=0;i<depth;i++)fragment=fragment.firstChild.content;return fragment}function closeNodeStart(node,openStart,openEnd){if(openStart<=0)return node;let frag=node.content;return openStart>1&&(frag=frag.replaceChild(0,closeNodeStart(frag.firstChild,openStart-1,1==frag.childCount?openEnd-1:0))),openStart>0&&(frag=node.type.contentMatch.fillBefore(frag).append(frag),openEnd<=0&&(frag=frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty,!0)))),node.copy(frag)}function contentAfterFits($to,depth,type,match,open){let node=$to.node(depth),index=open?$to.indexAfter(depth):$to.index(depth);if(index==node.childCount&&!type.compatibleContent(node.type))return null;let fit=match.fillBefore(node.content,!0,index);return fit&&!invalidMarks(type,node.content,index)?fit:null}function invalidMarks(type,fragment,start){for(let i=start;i<fragment.childCount;i++)if(!type.allowsMarks(fragment.child(i).marks))return!0;return!1}function definesContent(type){return type.spec.defining||type.spec.definingForContent}function replaceRange(tr,from,to,slice){if(!slice.size)return tr.deleteRange(from,to);let $from=tr.doc.resolve(from),$to=tr.doc.resolve(to);if(fitsTrivially($from,$to,slice))return tr.step(new ReplaceStep(from,to,slice));let targetDepths=coveredDepths($from,tr.doc.resolve(to));
// Can't replace the whole document, so remove 0 if it's present
0==targetDepths[targetDepths.length-1]&&targetDepths.pop();
// Negative numbers represent not expansion over the whole node at
// that depth, but replacing from $from.before(-D) to $to.pos.
let preferredTarget=-($from.depth+1);targetDepths.unshift(preferredTarget);
// This loop picks a preferred target depth, if one of the covering
// depths is not outside of a defining node, and adds negative
// depths for any depth that has $from at its start and does not
// cross a defining node.
for(let d=$from.depth,pos=$from.pos-1;d>0;d--,pos--){let spec=$from.node(d).type.spec;if(spec.defining||spec.definingAsContext||spec.isolating)break;targetDepths.indexOf(d)>-1?preferredTarget=d:$from.before(d)==pos&&targetDepths.splice(1,0,-d)}
// Try to fit each possible depth of the slice into each possible
// target depth, starting with the preferred depths.
let preferredTargetIndex=targetDepths.indexOf(preferredTarget),leftNodes=[],preferredDepth=slice.openStart;for(let content=slice.content,i=0;;i++){let node=content.firstChild;if(leftNodes.push(node),i==slice.openStart)break;content=node.content}
// Back up preferredDepth to cover defining textblocks directly
// above it, possibly skipping a non-defining textblock.
for(let d=preferredDepth-1;d>=0;d--){let type=leftNodes[d].type,def=definesContent(type);if(def&&$from.node(preferredTargetIndex).type!=type)preferredDepth=d;else if(def||!type.isTextblock)break}for(let j=slice.openStart;j>=0;j--){let openDepth=(j+preferredDepth+1)%(slice.openStart+1),insert=leftNodes[openDepth];if(insert)for(let i=0;i<targetDepths.length;i++){
// Loop over possible expansion levels, starting with the
// preferred one
let targetDepth=targetDepths[(i+preferredTargetIndex)%targetDepths.length],expand=!0;targetDepth<0&&(expand=!1,targetDepth=-targetDepth);let parent=$from.node(targetDepth-1),index=$from.index(targetDepth-1);if(parent.canReplaceWith(index,index,insert.type,insert.marks))return tr.replace($from.before(targetDepth),expand?$to.after(targetDepth):to,new Slice(closeFragment(slice.content,0,slice.openStart,openDepth),openDepth,slice.openEnd))}}let startSteps=tr.steps.length;for(let i=targetDepths.length-1;i>=0;i--){if(tr.replace(from,to,slice),tr.steps.length>startSteps)break;let depth=targetDepths[i];depth<0||(from=$from.before(depth),to=$to.after(depth))}}function closeFragment(fragment,depth,oldOpen,newOpen,parent){if(depth<oldOpen){let first=fragment.firstChild;fragment=fragment.replaceChild(0,first.copy(closeFragment(first.content,depth+1,oldOpen,newOpen,first)))}if(depth>newOpen){let match=parent.contentMatchAt(0),start=match.fillBefore(fragment).append(fragment);fragment=start.append(match.matchFragment(start).fillBefore(Fragment.empty,!0))}return fragment}function replaceRangeWith(tr,from,to,node){if(!node.isInline&&from==to&&tr.doc.resolve(from).parent.content.size){let point=insertPoint(tr.doc,from,node.type);null!=point&&(from=to=point)}tr.replaceRange(from,to,new Slice(Fragment.from(node),0,0))}function deleteRange$1(tr,from,to){let $from=tr.doc.resolve(from),$to=tr.doc.resolve(to),covered=coveredDepths($from,$to);for(let i=0;i<covered.length;i++){let depth=covered[i],last=i==covered.length-1;if(last&&0==depth||$from.node(depth).type.contentMatch.validEnd)return tr.delete($from.start(depth),$to.end(depth));if(depth>0&&(last||$from.node(depth-1).canReplace($from.index(depth-1),$to.indexAfter(depth-1))))return tr.delete($from.before(depth),$to.after(depth))}for(let d=1;d<=$from.depth&&d<=$to.depth;d++)if(from-$from.start(d)==$from.depth-d&&to>$from.end(d)&&$to.end(d)-to!=$to.depth-d)return tr.delete($from.before(d),to);tr.delete(from,to)}
// Returns an array of all depths for which $from - $to spans the
// whole content of the nodes at that depth.
function coveredDepths($from,$to){let result=[],minDepth=Math.min($from.depth,$to.depth);for(let d=minDepth;d>=0;d--){let start=$from.start(d);if(start<$from.pos-($from.depth-d)||$to.end(d)>$to.pos+($to.depth-d)||$from.node(d).type.spec.isolating||$to.node(d).type.spec.isolating)break;(start==$to.start(d)||d==$from.depth&&d==$to.depth&&$from.parent.inlineContent&&$to.parent.inlineContent&&d&&$to.start(d-1)==start-1)&&result.push(d)}return result}
/**
Update an attribute in a specific node.
*/class AttrStep extends Step{
/**
    Construct an attribute step.
    */
constructor(
/**
    The position of the target node.
    */
pos,
/**
    The attribute to set.
    */
attr,
// The attribute's new value.
value){super(),this.pos=pos,this.attr=attr,this.value=value}apply(doc){let node=doc.nodeAt(this.pos);if(!node)return StepResult.fail("No node at attribute step's position");let attrs=Object.create(null);for(let name in node.attrs)attrs[name]=node.attrs[name];attrs[this.attr]=this.value;let updated=node.type.create(attrs,null,node.marks);return StepResult.fromReplace(doc,this.pos,this.pos+1,new Slice(Fragment.from(updated),0,node.isLeaf?0:1))}getMap(){return StepMap.empty}invert(doc){return new AttrStep(this.pos,this.attr,doc.nodeAt(this.pos).attrs[this.attr])}map(mapping){let pos=mapping.mapResult(this.pos,1);return pos.deletedAfter?null:new AttrStep(pos.pos,this.attr,this.value)}toJSON(){return{stepType:"attr",pos:this.pos,attr:this.attr,value:this.value}}static fromJSON(schema,json){if("number"!=typeof json.pos||"string"!=typeof json.attr)throw new RangeError("Invalid input for AttrStep.fromJSON");return new AttrStep(json.pos,json.attr,json.value)}}Step.jsonID("attr",AttrStep);
/**
@internal
*/
let TransformError=class extends Error{};TransformError=function TransformError(message){let err=Error.call(this,message);return err.__proto__=TransformError.prototype,err},TransformError.prototype=Object.create(Error.prototype),TransformError.prototype.constructor=TransformError,TransformError.prototype.name="TransformError";
/**
Abstraction to build up and track an array of
[steps](https://prosemirror.net/docs/ref/#transform.Step) representing a document transformation.

Most transforming methods return the `Transform` object itself, so
that they can be chained.
*/
class Transform{
/**
    Create a transform that starts with the given document.
    */
constructor(
/**
    The current document (the result of applying the steps in the
    transform).
    */
doc){this.doc=doc,
/**
        The steps in this transform.
        */
this.steps=[],
/**
        The documents before each of the steps.
        */
this.docs=[],
/**
        A mapping with the maps for each of the steps in this transform.
        */
this.mapping=new Mapping}
/**
    The starting document.
    */get before(){return this.docs.length?this.docs[0]:this.doc}
/**
    Apply a new step in this transform, saving the result. Throws an
    error when the step fails.
    */step(step){let result=this.maybeStep(step);if(result.failed)throw new TransformError(result.failed);return this}
/**
    Try to apply a step in this transformation, ignoring it if it
    fails. Returns the step result.
    */maybeStep(step){let result=step.apply(this.doc);return result.failed||this.addStep(step,result.doc),result}
/**
    True when the document has been changed (when there are any
    steps).
    */get docChanged(){return this.steps.length>0}
/**
    @internal
    */addStep(step,doc){this.docs.push(this.doc),this.steps.push(step),this.mapping.appendMap(step.getMap()),this.doc=doc}
/**
    Replace the part of the document between `from` and `to` with the
    given `slice`.
    */replace(from,to=from,slice=Slice.empty){let step=replaceStep(this.doc,from,to,slice);return step&&this.step(step),this}
/**
    Replace the given range with the given content, which may be a
    fragment, node, or array of nodes.
    */replaceWith(from,to,content){return this.replace(from,to,new Slice(Fragment.from(content),0,0))}
/**
    Delete the content between the given positions.
    */delete(from,to){return this.replace(from,to,Slice.empty)}
/**
    Insert the given content at the given position.
    */insert(pos,content){return this.replaceWith(pos,pos,content)}
/**
    Replace a range of the document with a given slice, using
    `from`, `to`, and the slice's
    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
    than fixed start and end points. This method may grow the
    replaced area or close open nodes in the slice in order to get a
    fit that is more in line with WYSIWYG expectations, by dropping
    fully covered parent nodes of the replaced region when they are
    marked [non-defining as
    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
    open parent node from the slice that _is_ marked as [defining
    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
    
    This is the method, for example, to handle paste. The similar
    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
    primitive tool which will _not_ move the start and end of its given
    range, and is useful in situations where you need more precise
    control over what happens.
    */replaceRange(from,to,slice){return replaceRange(this,from,to,slice),this}
/**
    Replace the given range with a node, but use `from` and `to` as
    hints, rather than precise positions. When from and to are the same
    and are at the start or end of a parent node in which the given
    node doesn't fit, this method may _move_ them out towards a parent
    that does allow the given node to be placed. When the given range
    completely covers a parent node, this method may completely replace
    that parent node.
    */replaceRangeWith(from,to,node){return replaceRangeWith(this,from,to,node),this}
/**
    Delete the given range, expanding it to cover fully covered
    parent nodes until a valid replace is found.
    */deleteRange(from,to){return deleteRange$1(this,from,to),this}
/**
    Split the content in the given range off from its parent, if there
    is sibling content before or after it, and move it up the tree to
    the depth specified by `target`. You'll probably want to use
    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
    sure the lift is valid.
    */lift(range,target){return lift$2(this,range,target),this}
/**
    Join the blocks around the given position. If depth is 2, their
    last and first siblings are also joined, and so on.
    */join(pos,depth=1){return join(this,pos,depth),this}
/**
    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
    The wrappers are assumed to be valid in this position, and should
    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
    */wrap(range,wrappers){return wrap(this,range,wrappers),this}
/**
    Set the type of all textblocks (partly) between `from` and `to` to
    the given node type with the given attributes.
    */setBlockType(from,to=from,type,attrs=null){return setBlockType$1(this,from,to,type,attrs),this}
/**
    Change the type, attributes, and/or marks of the node at `pos`.
    When `type` isn't given, the existing node type is preserved,
    */setNodeMarkup(pos,type,attrs=null,marks){return setNodeMarkup(this,pos,type,attrs,marks),this}
/**
    Set a single attribute on a given node to a new value.
    */setNodeAttribute(pos,attr,value){return this.step(new AttrStep(pos,attr,value)),this}
/**
    Add a mark to the node at position `pos`.
    */addNodeMark(pos,mark){return this.step(new AddNodeMarkStep(pos,mark)),this}
/**
    Remove a mark (or a mark of the given type) from the node at
    position `pos`.
    */removeNodeMark(pos,mark){if(!(mark instanceof Mark$1)){let node=this.doc.nodeAt(pos);if(!node)throw new RangeError("No node at position "+pos);if(mark=mark.isInSet(node.marks),!mark)return this}return this.step(new RemoveNodeMarkStep(pos,mark)),this}
/**
    Split the node at the given position, and optionally, if `depth` is
    greater than one, any number of nodes above that. By default, the
    parts split off will inherit the node type of the original node.
    This can be changed by passing an array of types and attributes to
    use after the split.
    */split(pos,depth=1,typesAfter){return split(this,pos,depth,typesAfter),this}
/**
    Add the given mark to the inline content between `from` and `to`.
    */addMark(from,to,mark){return addMark(this,from,to,mark),this}
/**
    Remove marks from inline nodes between `from` and `to`. When
    `mark` is a single mark, remove precisely that mark. When it is
    a mark type, remove all marks of that type. When it is null,
    remove all marks of any type.
    */removeMark(from,to,mark){return removeMark(this,from,to,mark),this}
/**
    Removes all marks and nodes from the content of the node at
    `pos` that don't match the given new parent node type. Accepts
    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
    third argument.
    */clearIncompatible(pos,parentType,match){return clearIncompatible(this,pos,parentType,match),this}}const classesById=Object.create(null);
/**
Superclass for editor selections. Every selection type should
extend this. Should not be instantiated directly.
*/class Selection{
/**
    Initialize a selection with the head and anchor and ranges. If no
    ranges are given, constructs a single range across `$anchor` and
    `$head`.
    */
constructor(
/**
    The resolved anchor of the selection (the side that stays in
    place when the selection is modified).
    */
$anchor,
/**
    The resolved head of the selection (the side that moves when
    the selection is modified).
    */
$head,ranges){this.$anchor=$anchor,this.$head=$head,this.ranges=ranges||[new SelectionRange($anchor.min($head),$anchor.max($head))]}
/**
    The selection's anchor, as an unresolved position.
    */get anchor(){return this.$anchor.pos}
/**
    The selection's head.
    */get head(){return this.$head.pos}
/**
    The lower bound of the selection's main range.
    */get from(){return this.$from.pos}
/**
    The upper bound of the selection's main range.
    */get to(){return this.$to.pos}
/**
    The resolved lower  bound of the selection's main range.
    */get $from(){return this.ranges[0].$from}
/**
    The resolved upper bound of the selection's main range.
    */get $to(){return this.ranges[0].$to}
/**
    Indicates whether the selection contains any content.
    */get empty(){let ranges=this.ranges;for(let i=0;i<ranges.length;i++)if(ranges[i].$from.pos!=ranges[i].$to.pos)return!1;return!0}
/**
    Get the content of this selection as a slice.
    */content(){return this.$from.doc.slice(this.from,this.to,!0)}
/**
    Replace the selection with a slice or, if no slice is given,
    delete the selection. Will append to the given transaction.
    */replace(tr,content=Slice.empty){
// Put the new selection at the position after the inserted
// content. When that ended in an inline node, search backwards,
// to get the position after that node. If not, search forward.
let lastNode=content.content.lastChild,lastParent=null;for(let i=0;i<content.openEnd;i++)lastParent=lastNode,lastNode=lastNode.lastChild;let mapFrom=tr.steps.length,ranges=this.ranges;for(let i=0;i<ranges.length;i++){let{$from:$from,$to:$to}=ranges[i],mapping=tr.mapping.slice(mapFrom);tr.replaceRange(mapping.map($from.pos),mapping.map($to.pos),i?Slice.empty:content),0==i&&selectionToInsertionEnd$1(tr,mapFrom,(lastNode?lastNode.isInline:lastParent&&lastParent.isTextblock)?-1:1)}}
/**
    Replace the selection with the given node, appending the changes
    to the given transaction.
    */replaceWith(tr,node){let mapFrom=tr.steps.length,ranges=this.ranges;for(let i=0;i<ranges.length;i++){let{$from:$from,$to:$to}=ranges[i],mapping=tr.mapping.slice(mapFrom),from=mapping.map($from.pos),to=mapping.map($to.pos);i?tr.deleteRange(from,to):(tr.replaceRangeWith(from,to,node),selectionToInsertionEnd$1(tr,mapFrom,node.isInline?-1:1))}}
/**
    Find a valid cursor or leaf node selection starting at the given
    position and searching back if `dir` is negative, and forward if
    positive. When `textOnly` is true, only consider cursor
    selections. Will return null when no valid selection position is
    found.
    */static findFrom($pos,dir,textOnly=!1){let inner=$pos.parent.inlineContent?new TextSelection($pos):findSelectionIn($pos.node(0),$pos.parent,$pos.pos,$pos.index(),dir,textOnly);if(inner)return inner;for(let depth=$pos.depth-1;depth>=0;depth--){let found=dir<0?findSelectionIn($pos.node(0),$pos.node(depth),$pos.before(depth+1),$pos.index(depth),dir,textOnly):findSelectionIn($pos.node(0),$pos.node(depth),$pos.after(depth+1),$pos.index(depth)+1,dir,textOnly);if(found)return found}return null}
/**
    Find a valid cursor or leaf node selection near the given
    position. Searches forward first by default, but if `bias` is
    negative, it will search backwards first.
    */static near($pos,bias=1){return this.findFrom($pos,bias)||this.findFrom($pos,-bias)||new AllSelection($pos.node(0))}
/**
    Find the cursor or leaf node selection closest to the start of
    the given document. Will return an
    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
    exists.
    */static atStart(doc){return findSelectionIn(doc,doc,0,0,1)||new AllSelection(doc)}
/**
    Find the cursor or leaf node selection closest to the end of the
    given document.
    */static atEnd(doc){return findSelectionIn(doc,doc,doc.content.size,doc.childCount,-1)||new AllSelection(doc)}
/**
    Deserialize the JSON representation of a selection. Must be
    implemented for custom classes (as a static class method).
    */static fromJSON(doc,json){if(!json||!json.type)throw new RangeError("Invalid input for Selection.fromJSON");let cls=classesById[json.type];if(!cls)throw new RangeError(`No selection type ${json.type} defined`);return cls.fromJSON(doc,json)}
/**
    To be able to deserialize selections from JSON, custom selection
    classes must register themselves with an ID string, so that they
    can be disambiguated. Try to pick something that's unlikely to
    clash with classes from other modules.
    */static jsonID(id,selectionClass){if(id in classesById)throw new RangeError("Duplicate use of selection JSON ID "+id);return classesById[id]=selectionClass,selectionClass.prototype.jsonID=id,selectionClass}
/**
    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
    which is a value that can be mapped without having access to a
    current document, and later resolved to a real selection for a
    given document again. (This is used mostly by the history to
    track and restore old selections.) The default implementation of
    this method just converts the selection to a text selection and
    returns the bookmark for that.
    */getBookmark(){return TextSelection.between(this.$anchor,this.$head).getBookmark()}}Selection.prototype.visible=!0;
/**
Represents a selected range in a document.
*/
class SelectionRange{
/**
    Create a range.
    */
constructor(
/**
    The lower bound of the range.
    */
$from,
/**
    The upper bound of the range.
    */
$to){this.$from=$from,this.$to=$to}}let warnedAboutTextSelection=!1;function checkTextSelection($pos){warnedAboutTextSelection||$pos.parent.inlineContent||(warnedAboutTextSelection=!0)}
/**
A text selection represents a classical editor selection, with a
head (the moving side) and anchor (immobile side), both of which
point into textblock nodes. It can be empty (a regular cursor
position).
*/class TextSelection extends Selection{
/**
    Construct a text selection between the given points.
    */
constructor($anchor,$head=$anchor){checkTextSelection($anchor),checkTextSelection($head),super($anchor,$head)}
/**
    Returns a resolved position if this is a cursor selection (an
    empty text selection), and null otherwise.
    */get $cursor(){return this.$anchor.pos==this.$head.pos?this.$head:null}map(doc,mapping){let $head=doc.resolve(mapping.map(this.head));if(!$head.parent.inlineContent)return Selection.near($head);let $anchor=doc.resolve(mapping.map(this.anchor));return new TextSelection($anchor.parent.inlineContent?$anchor:$head,$head)}replace(tr,content=Slice.empty){if(super.replace(tr,content),content==Slice.empty){let marks=this.$from.marksAcross(this.$to);marks&&tr.ensureMarks(marks)}}eq(other){return other instanceof TextSelection&&other.anchor==this.anchor&&other.head==this.head}getBookmark(){return new TextBookmark(this.anchor,this.head)}toJSON(){return{type:"text",anchor:this.anchor,head:this.head}}
/**
    @internal
    */static fromJSON(doc,json){if("number"!=typeof json.anchor||"number"!=typeof json.head)throw new RangeError("Invalid input for TextSelection.fromJSON");return new TextSelection(doc.resolve(json.anchor),doc.resolve(json.head))}
/**
    Create a text selection from non-resolved positions.
    */static create(doc,anchor,head=anchor){let $anchor=doc.resolve(anchor);return new this($anchor,head==anchor?$anchor:doc.resolve(head))}
/**
    Return a text selection that spans the given positions or, if
    they aren't text positions, find a text selection near them.
    `bias` determines whether the method searches forward (default)
    or backwards (negative number) first. Will fall back to calling
    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
    doesn't contain a valid text position.
    */static between($anchor,$head,bias){let dPos=$anchor.pos-$head.pos;if(bias&&!dPos||(bias=dPos>=0?1:-1),!$head.parent.inlineContent){let found=Selection.findFrom($head,bias,!0)||Selection.findFrom($head,-bias,!0);if(!found)return Selection.near($head,bias);$head=found.$head}return $anchor.parent.inlineContent||(0==dPos?$anchor=$head:($anchor=(Selection.findFrom($anchor,-bias,!0)||Selection.findFrom($anchor,bias,!0)).$anchor,$anchor.pos<$head.pos!=dPos<0&&($anchor=$head))),new TextSelection($anchor,$head)}}Selection.jsonID("text",TextSelection);class TextBookmark{constructor(anchor,head){this.anchor=anchor,this.head=head}map(mapping){return new TextBookmark(mapping.map(this.anchor),mapping.map(this.head))}resolve(doc){return TextSelection.between(doc.resolve(this.anchor),doc.resolve(this.head))}}
/**
A node selection is a selection that points at a single node. All
nodes marked [selectable](https://prosemirror.net/docs/ref/#model.NodeSpec.selectable) can be the
target of a node selection. In such a selection, `from` and `to`
point directly before and after the selected node, `anchor` equals
`from`, and `head` equals `to`..
*/class NodeSelection extends Selection{
/**
    Create a node selection. Does not verify the validity of its
    argument.
    */
constructor($pos){let node=$pos.nodeAfter,$end=$pos.node(0).resolve($pos.pos+node.nodeSize);super($pos,$end),this.node=node}map(doc,mapping){let{deleted:deleted,pos:pos}=mapping.mapResult(this.anchor),$pos=doc.resolve(pos);return deleted?Selection.near($pos):new NodeSelection($pos)}content(){return new Slice(Fragment.from(this.node),0,0)}eq(other){return other instanceof NodeSelection&&other.anchor==this.anchor}toJSON(){return{type:"node",anchor:this.anchor}}getBookmark(){return new NodeBookmark(this.anchor)}
/**
    @internal
    */static fromJSON(doc,json){if("number"!=typeof json.anchor)throw new RangeError("Invalid input for NodeSelection.fromJSON");return new NodeSelection(doc.resolve(json.anchor))}
/**
    Create a node selection from non-resolved positions.
    */static create(doc,from){return new NodeSelection(doc.resolve(from))}
/**
    Determines whether the given node may be selected as a node
    selection.
    */static isSelectable(node){return!node.isText&&!1!==node.type.spec.selectable}}NodeSelection.prototype.visible=!1,Selection.jsonID("node",NodeSelection);class NodeBookmark{constructor(anchor){this.anchor=anchor}map(mapping){let{deleted:deleted,pos:pos}=mapping.mapResult(this.anchor);return deleted?new TextBookmark(pos,pos):new NodeBookmark(pos)}resolve(doc){let $pos=doc.resolve(this.anchor),node=$pos.nodeAfter;return node&&NodeSelection.isSelectable(node)?new NodeSelection($pos):Selection.near($pos)}}
/**
A selection type that represents selecting the whole document
(which can not necessarily be expressed with a text selection, when
there are for example leaf block nodes at the start or end of the
document).
*/class AllSelection extends Selection{
/**
    Create an all-selection over the given document.
    */
constructor(doc){super(doc.resolve(0),doc.resolve(doc.content.size))}replace(tr,content=Slice.empty){if(content==Slice.empty){tr.delete(0,tr.doc.content.size);let sel=Selection.atStart(tr.doc);sel.eq(tr.selection)||tr.setSelection(sel)}else super.replace(tr,content)}toJSON(){return{type:"all"}}
/**
    @internal
    */static fromJSON(doc){return new AllSelection(doc)}map(doc){return new AllSelection(doc)}eq(other){return other instanceof AllSelection}getBookmark(){return AllBookmark}}Selection.jsonID("all",AllSelection);const AllBookmark={map(){return this},resolve(doc){return new AllSelection(doc)}};
// FIXME we'll need some awareness of text direction when scanning for selections
// Try to find a selection inside the given node. `pos` points at the
// position where the search starts. When `text` is true, only return
// text selections.
function findSelectionIn(doc,node,pos,index,dir,text=!1){if(node.inlineContent)return TextSelection.create(doc,pos);for(let i=index-(dir>0?0:1);dir>0?i<node.childCount:i>=0;i+=dir){let child=node.child(i);if(child.isAtom){if(!text&&NodeSelection.isSelectable(child))return NodeSelection.create(doc,pos-(dir<0?child.nodeSize:0))}else{let inner=findSelectionIn(doc,child,pos+dir,dir<0?child.childCount:0,dir,text);if(inner)return inner}pos+=child.nodeSize*dir}return null}function selectionToInsertionEnd$1(tr,startLen,bias){let last=tr.steps.length-1;if(last<startLen)return;let step=tr.steps[last];if(!(step instanceof ReplaceStep||step instanceof ReplaceAroundStep))return;let end,map=tr.mapping.maps[last];map.forEach(((_from,_to,_newFrom,newTo)=>{null==end&&(end=newTo)})),tr.setSelection(Selection.near(tr.doc.resolve(end),bias))}const UPDATED_SEL=1,UPDATED_MARKS=2,UPDATED_SCROLL=4;
/**
An editor state transaction, which can be applied to a state to
create an updated state. Use
[`EditorState.tr`](https://prosemirror.net/docs/ref/#state.EditorState.tr) to create an instance.

Transactions track changes to the document (they are a subclass of
[`Transform`](https://prosemirror.net/docs/ref/#transform.Transform)), but also other state changes,
like selection updates and adjustments of the set of [stored
marks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks). In addition, you can store
metadata properties in a transaction, which are extra pieces of
information that client code or plugins can use to describe what a
transaction represents, so that they can update their [own
state](https://prosemirror.net/docs/ref/#state.StateField) accordingly.

The [editor view](https://prosemirror.net/docs/ref/#view.EditorView) uses a few metadata properties:
it will attach a property `"pointer"` with the value `true` to
selection transactions directly caused by mouse or touch input, and
a `"uiEvent"` property of that may be `"paste"`, `"cut"`, or `"drop"`.
*/class Transaction extends Transform{
/**
    @internal
    */
constructor(state){super(state.doc),
// The step count for which the current selection is valid.
this.curSelectionFor=0,
// Bitfield to track which aspects of the state were updated by
// this transaction.
this.updated=0,
// Object used to store metadata properties for the transaction.
this.meta=Object.create(null),this.time=Date.now(),this.curSelection=state.selection,this.storedMarks=state.storedMarks}
/**
    The transaction's current selection. This defaults to the editor
    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
    transaction, but can be overwritten with
    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
    */get selection(){return this.curSelectionFor<this.steps.length&&(this.curSelection=this.curSelection.map(this.doc,this.mapping.slice(this.curSelectionFor)),this.curSelectionFor=this.steps.length),this.curSelection}
/**
    Update the transaction's current selection. Will determine the
    selection that the editor gets when the transaction is applied.
    */setSelection(selection){if(selection.$from.doc!=this.doc)throw new RangeError("Selection passed to setSelection must point at the current document");return this.curSelection=selection,this.curSelectionFor=this.steps.length,this.updated=(this.updated|UPDATED_SEL)&~UPDATED_MARKS,this.storedMarks=null,this}
/**
    Whether the selection was explicitly updated by this transaction.
    */get selectionSet(){return(this.updated&UPDATED_SEL)>0}
/**
    Set the current stored marks.
    */setStoredMarks(marks){return this.storedMarks=marks,this.updated|=UPDATED_MARKS,this}
/**
    Make sure the current stored marks or, if that is null, the marks
    at the selection, match the given set of marks. Does nothing if
    this is already the case.
    */ensureMarks(marks){return Mark$1.sameSet(this.storedMarks||this.selection.$from.marks(),marks)||this.setStoredMarks(marks),this}
/**
    Add a mark to the set of stored marks.
    */addStoredMark(mark){return this.ensureMarks(mark.addToSet(this.storedMarks||this.selection.$head.marks()))}
/**
    Remove a mark or mark type from the set of stored marks.
    */removeStoredMark(mark){return this.ensureMarks(mark.removeFromSet(this.storedMarks||this.selection.$head.marks()))}
/**
    Whether the stored marks were explicitly set for this transaction.
    */get storedMarksSet(){return(this.updated&UPDATED_MARKS)>0}
/**
    @internal
    */addStep(step,doc){super.addStep(step,doc),this.updated=this.updated&~UPDATED_MARKS,this.storedMarks=null}
/**
    Update the timestamp for the transaction.
    */setTime(time){return this.time=time,this}
/**
    Replace the current selection with the given slice.
    */replaceSelection(slice){return this.selection.replace(this,slice),this}
/**
    Replace the selection with the given node. When `inheritMarks` is
    true and the content is inline, it inherits the marks from the
    place where it is inserted.
    */replaceSelectionWith(node,inheritMarks=!0){let selection=this.selection;return inheritMarks&&(node=node.mark(this.storedMarks||(selection.empty?selection.$from.marks():selection.$from.marksAcross(selection.$to)||Mark$1.none))),selection.replaceWith(this,node),this}
/**
    Delete the selection.
    */deleteSelection(){return this.selection.replace(this),this}
/**
    Replace the given range, or the selection if no range is given,
    with a text node containing the given string.
    */insertText(text,from,to){let schema=this.doc.type.schema;if(null==from)return text?this.replaceSelectionWith(schema.text(text),!0):this.deleteSelection();{if(null==to&&(to=from),to=null==to?from:to,!text)return this.deleteRange(from,to);let marks=this.storedMarks;if(!marks){let $from=this.doc.resolve(from);marks=to==from?$from.marks():$from.marksAcross(this.doc.resolve(to))}return this.replaceRangeWith(from,to,schema.text(text,marks)),this.selection.empty||this.setSelection(Selection.near(this.selection.$to)),this}}
/**
    Store a metadata property in this transaction, keyed either by
    name or by plugin.
    */setMeta(key,value){return this.meta["string"==typeof key?key:key.key]=value,this}
/**
    Retrieve a metadata property for a given name or plugin.
    */getMeta(key){return this.meta["string"==typeof key?key:key.key]}
/**
    Returns true if this transaction doesn't contain any metadata,
    and can thus safely be extended.
    */get isGeneric(){for(let _ in this.meta)return!1;return!0}
/**
    Indicate that the editor should scroll the selection into view
    when updated to the state produced by this transaction.
    */scrollIntoView(){return this.updated|=UPDATED_SCROLL,this}
/**
    True when this transaction has had `scrollIntoView` called on it.
    */get scrolledIntoView(){return(this.updated&UPDATED_SCROLL)>0}}function bind$1(f,self){return self&&f?f.bind(self):f}class FieldDesc{constructor(name,desc,self){this.name=name,this.init=bind$1(desc.init,self),this.apply=bind$1(desc.apply,self)}}const baseFields=[new FieldDesc("doc",{init(config){return config.doc||config.schema.topNodeType.createAndFill()},apply(tr){return tr.doc}}),new FieldDesc("selection",{init(config,instance){return config.selection||Selection.atStart(instance.doc)},apply(tr){return tr.selection}}),new FieldDesc("storedMarks",{init(config){return config.storedMarks||null},apply(tr,_marks,_old,state){return state.selection.$cursor?tr.storedMarks:null}}),new FieldDesc("scrollToSelection",{init(){return 0},apply(tr,prev){return tr.scrolledIntoView?prev+1:prev}})];
// Object wrapping the part of a state object that stays the same
// across transactions. Stored in the state's `config` property.
class Configuration{constructor(schema,plugins){this.schema=schema,this.plugins=[],this.pluginsByKey=Object.create(null),this.fields=baseFields.slice(),plugins&&plugins.forEach((plugin=>{if(this.pluginsByKey[plugin.key])throw new RangeError("Adding different instances of a keyed plugin ("+plugin.key+")");this.plugins.push(plugin),this.pluginsByKey[plugin.key]=plugin,plugin.spec.state&&this.fields.push(new FieldDesc(plugin.key,plugin.spec.state,plugin))}))}}
/**
The state of a ProseMirror editor is represented by an object of
this type. A state is a persistent data structure—it isn't
updated, but rather a new state value is computed from an old one
using the [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) method.

A state holds a number of built-in fields, and plugins can
[define](https://prosemirror.net/docs/ref/#state.PluginSpec.state) additional fields.
*/class EditorState{
/**
    @internal
    */
constructor(
/**
    @internal
    */
config){this.config=config}
/**
    The schema of the state's document.
    */get schema(){return this.config.schema}
/**
    The plugins that are active in this state.
    */get plugins(){return this.config.plugins}
/**
    Apply the given transaction to produce a new state.
    */apply(tr){return this.applyTransaction(tr).state}
/**
    @internal
    */filterTransaction(tr,ignore=-1){for(let i=0;i<this.config.plugins.length;i++)if(i!=ignore){let plugin=this.config.plugins[i];if(plugin.spec.filterTransaction&&!plugin.spec.filterTransaction.call(plugin,tr,this))return!1}return!0}
/**
    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
    returns the precise transactions that were applied (which might
    be influenced by the [transaction
    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
    plugins) along with the new state.
    */applyTransaction(rootTr){if(!this.filterTransaction(rootTr))return{state:this,transactions:[]};let trs=[rootTr],newState=this.applyInner(rootTr),seen=null;
// This loop repeatedly gives plugins a chance to respond to
// transactions as new transactions are added, making sure to only
// pass the transactions the plugin did not see before.
for(;;){let haveNew=!1;for(let i=0;i<this.config.plugins.length;i++){let plugin=this.config.plugins[i];if(plugin.spec.appendTransaction){let n=seen?seen[i].n:0,oldState=seen?seen[i].state:this,tr=n<trs.length&&plugin.spec.appendTransaction.call(plugin,n?trs.slice(n):trs,oldState,newState);if(tr&&newState.filterTransaction(tr,i)){if(tr.setMeta("appendedTransaction",rootTr),!seen){seen=[];for(let j=0;j<this.config.plugins.length;j++)seen.push(j<i?{state:newState,n:trs.length}:{state:this,n:0})}trs.push(tr),newState=newState.applyInner(tr),haveNew=!0}seen&&(seen[i]={state:newState,n:trs.length})}}if(!haveNew)return{state:newState,transactions:trs}}}
/**
    @internal
    */applyInner(tr){if(!tr.before.eq(this.doc))throw new RangeError("Applying a mismatched transaction");let newInstance=new EditorState(this.config),fields=this.config.fields;for(let i=0;i<fields.length;i++){let field=fields[i];newInstance[field.name]=field.apply(tr,this[field.name],this,newInstance)}return newInstance}
/**
    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
    */get tr(){return new Transaction(this)}
/**
    Create a new state.
    */static create(config){let $config=new Configuration(config.doc?config.doc.type.schema:config.schema,config.plugins),instance=new EditorState($config);for(let i=0;i<$config.fields.length;i++)instance[$config.fields[i].name]=$config.fields[i].init(config,instance);return instance}
/**
    Create a new state based on this one, but with an adjusted set
    of active plugins. State fields that exist in both sets of
    plugins are kept unchanged. Those that no longer exist are
    dropped, and those that are new are initialized using their
    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
    configuration object..
    */reconfigure(config){let $config=new Configuration(this.schema,config.plugins),fields=$config.fields,instance=new EditorState($config);for(let i=0;i<fields.length;i++){let name=fields[i].name;instance[name]=this.hasOwnProperty(name)?this[name]:fields[i].init(config,instance)}return instance}
/**
    Serialize this state to JSON. If you want to serialize the state
    of plugins, pass an object mapping property names to use in the
    resulting JSON object to plugin objects. The argument may also be
    a string or number, in which case it is ignored, to support the
    way `JSON.stringify` calls `toString` methods.
    */toJSON(pluginFields){let result={doc:this.doc.toJSON(),selection:this.selection.toJSON()};if(this.storedMarks&&(result.storedMarks=this.storedMarks.map((m=>m.toJSON()))),pluginFields&&"object"==typeof pluginFields)for(let prop in pluginFields){if("doc"==prop||"selection"==prop)throw new RangeError("The JSON fields `doc` and `selection` are reserved");let plugin=pluginFields[prop],state=plugin.spec.state;state&&state.toJSON&&(result[prop]=state.toJSON.call(plugin,this[plugin.key]))}return result}
/**
    Deserialize a JSON representation of a state. `config` should
    have at least a `schema` field, and should contain array of
    plugins to initialize the state with. `pluginFields` can be used
    to deserialize the state of plugins, by associating plugin
    instances with the property names they use in the JSON object.
    */static fromJSON(config,json,pluginFields){if(!json)throw new RangeError("Invalid input for EditorState.fromJSON");if(!config.schema)throw new RangeError("Required config field 'schema' missing");let $config=new Configuration(config.schema,config.plugins),instance=new EditorState($config);return $config.fields.forEach((field=>{if("doc"==field.name)instance.doc=Node$2.fromJSON(config.schema,json.doc);else if("selection"==field.name)instance.selection=Selection.fromJSON(instance.doc,json.selection);else if("storedMarks"==field.name)json.storedMarks&&(instance.storedMarks=json.storedMarks.map(config.schema.markFromJSON));else{if(pluginFields)for(let prop in pluginFields){let plugin=pluginFields[prop],state=plugin.spec.state;if(plugin.key==field.name&&state&&state.fromJSON&&Object.prototype.hasOwnProperty.call(json,prop))return void(instance[field.name]=state.fromJSON.call(plugin,config,json[prop],instance))}instance[field.name]=field.init(config,instance)}})),instance}}function bindProps(obj,self,target){for(let prop in obj){let val=obj[prop];val instanceof Function?val=val.bind(self):"handleDOMEvents"==prop&&(val=bindProps(val,self,{})),target[prop]=val}return target}
/**
Plugins bundle functionality that can be added to an editor.
They are part of the [editor state](https://prosemirror.net/docs/ref/#state.EditorState) and
may influence that state and the view that contains it.
*/class Plugin{
/**
    Create a plugin.
    */
constructor(
/**
    The plugin's [spec object](https://prosemirror.net/docs/ref/#state.PluginSpec).
    */
spec){this.spec=spec,
/**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
this.props={},spec.props&&bindProps(spec.props,this,this.props),this.key=spec.key?spec.key.key:createKey("plugin")}
/**
    Extract the plugin's state field from an editor state.
    */getState(state){return state[this.key]}}const keys$1=Object.create(null);function createKey(name){return name in keys$1?name+"$"+ ++keys$1[name]:(keys$1[name]=0,name+"$")}
/**
A key is used to [tag](https://prosemirror.net/docs/ref/#state.PluginSpec.key) plugins in a way
that makes it possible to find them, given an editor state.
Assigning a key does mean only one plugin of that type can be
active in a state.
*/class PluginKey{
/**
    Create a plugin key.
    */
constructor(name="key"){this.key=createKey(name)}
/**
    Get the active plugin with this key, if any, from an editor
    state.
    */get(state){return state.config.pluginsByKey[this.key]}
/**
    Get the plugin's state from an editor state.
    */getState(state){return state[this.key]}}const domIndex=function(node){for(var index=0;;index++)if(node=node.previousSibling,!node)return index},parentNode=function(node){let parent=node.assignedSlot||node.parentNode;return parent&&11==parent.nodeType?parent.host:parent};let reusedRange=null;
// Note that this will always return the same range, because DOM range
// objects are every expensive, and keep slowing down subsequent DOM
// updates, for some reason.
const textRange=function(node,from,to){let range=reusedRange||(reusedRange=document.createRange());return range.setEnd(node,null==to?node.nodeValue.length:to),range.setStart(node,from||0),range},isEquivalentPosition=function(node,off,targetNode,targetOff){return targetNode&&(scanFor(node,off,targetNode,targetOff,-1)||scanFor(node,off,targetNode,targetOff,1))},atomElements=/^(img|br|input|textarea|hr)$/i;
// Scans forward and backward through DOM positions equivalent to the
// given one to see if the two are in the same place (i.e. after a
// text node vs at the end of that text node)
function scanFor(node,off,targetNode,targetOff,dir){for(;;){if(node==targetNode&&off==targetOff)return!0;if(off==(dir<0?0:nodeSize(node))){let parent=node.parentNode;if(!parent||1!=parent.nodeType||hasBlockDesc(node)||atomElements.test(node.nodeName)||"false"==node.contentEditable)return!1;off=domIndex(node)+(dir<0?0:1),node=parent}else{if(1!=node.nodeType)return!1;if(node=node.childNodes[off+(dir<0?-1:0)],"false"==node.contentEditable)return!1;off=dir<0?nodeSize(node):0}}}function nodeSize(node){return 3==node.nodeType?node.nodeValue.length:node.childNodes.length}function isOnEdge(node,offset,parent){for(let atStart=0==offset,atEnd=offset==nodeSize(node);atStart||atEnd;){if(node==parent)return!0;let index=domIndex(node);if(node=node.parentNode,!node)return!1;atStart=atStart&&0==index,atEnd=atEnd&&index==nodeSize(node)}}function hasBlockDesc(dom){let desc;for(let cur=dom;cur;cur=cur.parentNode)if(desc=cur.pmViewDesc)break;return desc&&desc.node&&desc.node.isBlock&&(desc.dom==dom||desc.contentDOM==dom)}
// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523
// (isCollapsed inappropriately returns true in shadow dom)
const selectionCollapsed=function(domSel){return domSel.focusNode&&isEquivalentPosition(domSel.focusNode,domSel.focusOffset,domSel.anchorNode,domSel.anchorOffset)};function keyEvent(keyCode,key){let event=document.createEvent("Event");return event.initEvent("keydown",!0,!0),event.keyCode=keyCode,event.key=event.code=key,event}function deepActiveElement(doc){let elt=doc.activeElement;while(elt&&elt.shadowRoot)elt=elt.shadowRoot.activeElement;return elt}const nav="undefined"!=typeof navigator?navigator:null,doc="undefined"!=typeof document?document:null,agent=nav&&nav.userAgent||"",ie_edge=/Edge\/(\d+)/.exec(agent),ie_upto10=/MSIE \d/.exec(agent),ie_11up=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent),ie$1=!!(ie_upto10||ie_11up||ie_edge),ie_version=ie_upto10?document.documentMode:ie_11up?+ie_11up[1]:ie_edge?+ie_edge[1]:0,gecko=!ie$1&&/gecko\/(\d+)/i.test(agent);gecko&&(/Firefox\/(\d+)/.exec(agent)||[0,0])[1];const _chrome=!ie$1&&/Chrome\/(\d+)/.exec(agent),chrome$1=!!_chrome,chrome_version=_chrome?+_chrome[1]:0,safari=!ie$1&&!!nav&&/Apple Computer/.test(nav.vendor),ios=safari&&(/Mobile\/\w+/.test(agent)||!!nav&&nav.maxTouchPoints>2),mac$2=ios||!!nav&&/Mac/.test(nav.platform),android=/Android \d/.test(agent),webkit=!!doc&&"webkitFontSmoothing"in doc.documentElement.style,webkit_version=webkit?+(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent)||[0,0])[1]:0;function windowRect(doc){return{left:0,right:doc.documentElement.clientWidth,top:0,bottom:doc.documentElement.clientHeight}}function getSide(value,side){return"number"==typeof value?value:value[side]}function clientRect(node){let rect=node.getBoundingClientRect(),scaleX=rect.width/node.offsetWidth||1,scaleY=rect.height/node.offsetHeight||1;
// Adjust for elements with style "transform: scale()"
// Make sure scrollbar width isn't included in the rectangle
return{left:rect.left,right:rect.left+node.clientWidth*scaleX,top:rect.top,bottom:rect.top+node.clientHeight*scaleY}}function scrollRectIntoView(view,rect,startDOM){let scrollThreshold=view.someProp("scrollThreshold")||0,scrollMargin=view.someProp("scrollMargin")||5,doc=view.dom.ownerDocument;for(let parent=startDOM||view.dom;;parent=parentNode(parent)){if(!parent)break;if(1!=parent.nodeType)continue;let elt=parent,atTop=elt==doc.body,bounding=atTop?windowRect(doc):clientRect(elt),moveX=0,moveY=0;if(rect.top<bounding.top+getSide(scrollThreshold,"top")?moveY=-(bounding.top-rect.top+getSide(scrollMargin,"top")):rect.bottom>bounding.bottom-getSide(scrollThreshold,"bottom")&&(moveY=rect.bottom-bounding.bottom+getSide(scrollMargin,"bottom")),rect.left<bounding.left+getSide(scrollThreshold,"left")?moveX=-(bounding.left-rect.left+getSide(scrollMargin,"left")):rect.right>bounding.right-getSide(scrollThreshold,"right")&&(moveX=rect.right-bounding.right+getSide(scrollMargin,"right")),moveX||moveY)if(atTop)doc.defaultView.scrollBy(moveX,moveY);else{let startX=elt.scrollLeft,startY=elt.scrollTop;moveY&&(elt.scrollTop+=moveY),moveX&&(elt.scrollLeft+=moveX);let dX=elt.scrollLeft-startX,dY=elt.scrollTop-startY;rect={left:rect.left-dX,top:rect.top-dY,right:rect.right-dX,bottom:rect.bottom-dY}}if(atTop)break}}
// Store the scroll position of the editor's parent nodes, along with
// the top position of an element near the top of the editor, which
// will be used to make sure the visible viewport remains stable even
// when the size of the content above changes.
function storeScrollPos(view){let refDOM,refTop,rect=view.dom.getBoundingClientRect(),startY=Math.max(0,rect.top);for(let x=(rect.left+rect.right)/2,y=startY+1;y<Math.min(innerHeight,rect.bottom);y+=5){let dom=view.root.elementFromPoint(x,y);if(!dom||dom==view.dom||!view.dom.contains(dom))continue;let localRect=dom.getBoundingClientRect();if(localRect.top>=startY-20){refDOM=dom,refTop=localRect.top;break}}return{refDOM:refDOM,refTop:refTop,stack:scrollStack(view.dom)}}function scrollStack(dom){let stack=[],doc=dom.ownerDocument;for(let cur=dom;cur;cur=parentNode(cur))if(stack.push({dom:cur,top:cur.scrollTop,left:cur.scrollLeft}),dom==doc)break;return stack}
// Reset the scroll position of the editor's parent nodes to that what
// it was before, when storeScrollPos was called.
function resetScrollPos({refDOM:refDOM,refTop:refTop,stack:stack}){let newRefTop=refDOM?refDOM.getBoundingClientRect().top:0;restoreScrollStack(stack,0==newRefTop?0:newRefTop-refTop)}function restoreScrollStack(stack,dTop){for(let i=0;i<stack.length;i++){let{dom:dom,top:top,left:left}=stack[i];dom.scrollTop!=top+dTop&&(dom.scrollTop=top+dTop),dom.scrollLeft!=left&&(dom.scrollLeft=left)}}let preventScrollSupported=null;
// Feature-detects support for .focus({preventScroll: true}), and uses
// a fallback kludge when not supported.
function focusPreventScroll(dom){if(dom.setActive)return dom.setActive();// in IE
if(preventScrollSupported)return dom.focus(preventScrollSupported);let stored=scrollStack(dom);dom.focus(null==preventScrollSupported?{get preventScroll(){return preventScrollSupported={preventScroll:!0},!0}}:void 0),preventScrollSupported||(preventScrollSupported=!1,restoreScrollStack(stored,0))}function findOffsetInNode(node,coords){let closest,coordsClosest,dxClosest=2e8,offset=0,rowBot=coords.top,rowTop=coords.top;for(let child=node.firstChild,childIndex=0;child;child=child.nextSibling,childIndex++){let rects;if(1==child.nodeType)rects=child.getClientRects();else{if(3!=child.nodeType)continue;rects=textRange(child).getClientRects()}for(let i=0;i<rects.length;i++){let rect=rects[i];if(rect.top<=rowBot&&rect.bottom>=rowTop){rowBot=Math.max(rect.bottom,rowBot),rowTop=Math.min(rect.top,rowTop);let dx=rect.left>coords.left?rect.left-coords.left:rect.right<coords.left?coords.left-rect.right:0;if(dx<dxClosest){closest=child,dxClosest=dx,coordsClosest=dx&&3==closest.nodeType?{left:rect.right<coords.left?rect.right:rect.left,top:coords.top}:coords,1==child.nodeType&&dx&&(offset=childIndex+(coords.left>=(rect.left+rect.right)/2?1:0));continue}}!closest&&(coords.left>=rect.right&&coords.top>=rect.top||coords.left>=rect.left&&coords.top>=rect.bottom)&&(offset=childIndex+1)}}return closest&&3==closest.nodeType?findOffsetInText(closest,coordsClosest):!closest||dxClosest&&1==closest.nodeType?{node:node,offset:offset}:findOffsetInNode(closest,coordsClosest)}function findOffsetInText(node,coords){let len=node.nodeValue.length,range=document.createRange();for(let i=0;i<len;i++){range.setEnd(node,i+1),range.setStart(node,i);let rect=singleRect(range,1);if(rect.top!=rect.bottom&&inRect(coords,rect))return{node:node,offset:i+(coords.left>=(rect.left+rect.right)/2?1:0)}}return{node:node,offset:0}}function inRect(coords,rect){return coords.left>=rect.left-1&&coords.left<=rect.right+1&&coords.top>=rect.top-1&&coords.top<=rect.bottom+1}function targetKludge(dom,coords){let parent=dom.parentNode;return parent&&/^li$/i.test(parent.nodeName)&&coords.left<dom.getBoundingClientRect().left?parent:dom}function posFromElement(view,elt,coords){let{node:node,offset:offset}=findOffsetInNode(elt,coords),bias=-1;if(1==node.nodeType&&!node.firstChild){let rect=node.getBoundingClientRect();bias=rect.left!=rect.right&&coords.left>(rect.left+rect.right)/2?1:-1}return view.docView.posFromDOM(node,offset,bias)}function posFromCaret(view,node,offset,coords){
// Browser (in caretPosition/RangeFromPoint) will agressively
// normalize towards nearby inline nodes. Since we are interested in
// positions between block nodes too, we first walk up the hierarchy
// of nodes to see if there are block nodes that the coordinates
// fall outside of. If so, we take the position before/after that
// block. If not, we call `posFromDOM` on the raw node/offset.
let outsideBlock=-1;for(let cur=node,sawBlock=!1;;){if(cur==view.dom)break;let desc=view.docView.nearestDesc(cur,!0);if(!desc)return null;if(1==desc.dom.nodeType&&(desc.node.isBlock&&desc.parent&&!sawBlock||!desc.contentDOM)){let rect=desc.dom.getBoundingClientRect();if(desc.node.isBlock&&desc.parent&&!sawBlock&&(sawBlock=!0,rect.left>coords.left||rect.top>coords.top?outsideBlock=desc.posBefore:(rect.right<coords.left||rect.bottom<coords.top)&&(outsideBlock=desc.posAfter)),!desc.contentDOM&&outsideBlock<0){
// If we are inside a leaf, return the side of the leaf closer to the coords
let before=desc.node.isBlock?coords.top<(rect.top+rect.bottom)/2:coords.left<(rect.left+rect.right)/2;return before?desc.posBefore:desc.posAfter}}cur=desc.dom.parentNode}return outsideBlock>-1?outsideBlock:view.docView.posFromDOM(node,offset,-1)}function elementFromPoint(element,coords,box){let len=element.childNodes.length;if(len&&box.top<box.bottom)for(let startI=Math.max(0,Math.min(len-1,Math.floor(len*(coords.top-box.top)/(box.bottom-box.top))-2)),i=startI;;){let child=element.childNodes[i];if(1==child.nodeType){let rects=child.getClientRects();for(let j=0;j<rects.length;j++){let rect=rects[j];if(inRect(coords,rect))return elementFromPoint(child,coords,rect)}}if((i=(i+1)%len)==startI)break}return element}
// Given an x,y position on the editor, get the position in the document.
function posAtCoords(view,coords){let node,doc=view.dom.ownerDocument,offset=0;if(doc.caretPositionFromPoint)try{// Firefox throws for this call in hard-to-predict circumstances (#994)
let pos=doc.caretPositionFromPoint(coords.left,coords.top);pos&&({offsetNode:node,offset:offset}=pos)}catch(_){}if(!node&&doc.caretRangeFromPoint){let range=doc.caretRangeFromPoint(coords.left,coords.top);range&&({startContainer:node,startOffset:offset}=range)}let pos,elt=(view.root.elementFromPoint?view.root:doc).elementFromPoint(coords.left,coords.top);if(!elt||!view.dom.contains(1!=elt.nodeType?elt.parentNode:elt)){let box=view.dom.getBoundingClientRect();if(!inRect(coords,box))return null;if(elt=elementFromPoint(view.dom,coords,box),!elt)return null}
// Safari's caretRangeFromPoint returns nonsense when on a draggable element
if(safari)for(let p=elt;node&&p;p=parentNode(p))p.draggable&&(node=void 0);if(elt=targetKludge(elt,coords),node){if(gecko&&1==node.nodeType&&(
// Firefox will sometimes return offsets into <input> nodes, which
// have no actual children, from caretPositionFromPoint (#953)
offset=Math.min(offset,node.childNodes.length),offset<node.childNodes.length)){let box,next=node.childNodes[offset];"IMG"==next.nodeName&&(box=next.getBoundingClientRect()).right<=coords.left&&box.bottom>coords.top&&offset++}
// Suspiciously specific kludge to work around caret*FromPoint
// never returning a position at the end of the document
node==view.dom&&offset==node.childNodes.length-1&&1==node.lastChild.nodeType&&coords.top>node.lastChild.getBoundingClientRect().bottom?pos=view.state.doc.content.size:0!=offset&&1==node.nodeType&&"BR"==node.childNodes[offset-1].nodeName||(pos=posFromCaret(view,node,offset,coords))}null==pos&&(pos=posFromElement(view,elt,coords));let desc=view.docView.nearestDesc(elt,!0);return{pos:pos,inside:desc?desc.posAtStart-desc.border:-1}}function singleRect(target,bias){let rects=target.getClientRects();return rects.length?rects[bias<0?0:rects.length-1]:target.getBoundingClientRect()}const BIDI=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
// Given a position in the document model, get a bounding box of the
// character at that position, relative to the window.
function coordsAtPos(view,pos,side){let{node:node,offset:offset,atom:atom}=view.docView.domFromPos(pos,side<0?-1:1),supportEmptyRange=webkit||gecko;if(3==node.nodeType){
// These browsers support querying empty text ranges. Prefer that in
// bidi context or when at the end of a node.
if(!supportEmptyRange||!BIDI.test(node.nodeValue)&&(side<0?offset:offset!=node.nodeValue.length)){let from=offset,to=offset,takeSide=side<0?1:-1;return side<0&&!offset?(to++,takeSide=-1):side>=0&&offset==node.nodeValue.length?(from--,takeSide=1):side<0?from--:to++,flattenV(singleRect(textRange(node,from,to),1),takeSide<0)}{let rect=singleRect(textRange(node,offset,offset),side);
// Firefox returns bad results (the position before the space)
// when querying a position directly after line-broken
// whitespace. Detect this situation and and kludge around it
if(gecko&&offset&&/\s/.test(node.nodeValue[offset-1])&&offset<node.nodeValue.length){let rectBefore=singleRect(textRange(node,offset-1,offset-1),-1);if(rectBefore.top==rect.top){let rectAfter=singleRect(textRange(node,offset,offset+1),-1);if(rectAfter.top!=rect.top)return flattenV(rectAfter,rectAfter.left<rectBefore.left)}}return rect}}let $dom=view.state.doc.resolve(pos-(atom||0));
// Return a horizontal line in block context
if(!$dom.parent.inlineContent){if(null==atom&&offset&&(side<0||offset==nodeSize(node))){let before=node.childNodes[offset-1];if(1==before.nodeType)return flattenH(before.getBoundingClientRect(),!1)}if(null==atom&&offset<nodeSize(node)){let after=node.childNodes[offset];if(1==after.nodeType)return flattenH(after.getBoundingClientRect(),!0)}return flattenH(node.getBoundingClientRect(),side>=0)}
// Inline, not in text node (this is not Bidi-safe)
if(null==atom&&offset&&(side<0||offset==nodeSize(node))){let before=node.childNodes[offset-1],target=3==before.nodeType?textRange(before,nodeSize(before)-(supportEmptyRange?0:1)):1!=before.nodeType||"BR"==before.nodeName&&before.nextSibling?null:before;if(target)return flattenV(singleRect(target,1),!1)}if(null==atom&&offset<nodeSize(node)){let after=node.childNodes[offset];while(after.pmViewDesc&&after.pmViewDesc.ignoreForCoords)after=after.nextSibling;let target=after?3==after.nodeType?textRange(after,0,supportEmptyRange?0:1):1==after.nodeType?after:null:null;if(target)return flattenV(singleRect(target,-1),!0)}
// All else failed, just try to get a rectangle for the target node
return flattenV(singleRect(3==node.nodeType?textRange(node):node,-side),side>=0)}function flattenV(rect,left){if(0==rect.width)return rect;let x=left?rect.left:rect.right;return{top:rect.top,bottom:rect.bottom,left:x,right:x}}function flattenH(rect,top){if(0==rect.height)return rect;let y=top?rect.top:rect.bottom;return{top:y,bottom:y,left:rect.left,right:rect.right}}function withFlushedState(view,state,f){let viewState=view.state,active=view.root.activeElement;viewState!=state&&view.updateState(state),active!=view.dom&&view.focus();try{return f()}finally{viewState!=state&&view.updateState(viewState),active!=view.dom&&active&&active.focus()}}
// Whether vertical position motion in a given direction
// from a position would leave a text block.
function endOfTextblockVertical(view,state,dir){let sel=state.selection,$pos="up"==dir?sel.$from:sel.$to;return withFlushedState(view,state,(()=>{let{node:dom}=view.docView.domFromPos($pos.pos,"up"==dir?-1:1);for(;;){let nearest=view.docView.nearestDesc(dom,!0);if(!nearest)break;if(nearest.node.isBlock){dom=nearest.contentDOM||nearest.dom;break}dom=nearest.dom.parentNode}let coords=coordsAtPos(view,$pos.pos,1);for(let child=dom.firstChild;child;child=child.nextSibling){let boxes;if(1==child.nodeType)boxes=child.getClientRects();else{if(3!=child.nodeType)continue;boxes=textRange(child,0,child.nodeValue.length).getClientRects()}for(let i=0;i<boxes.length;i++){let box=boxes[i];if(box.bottom>box.top+1&&("up"==dir?coords.top-box.top>2*(box.bottom-coords.top):box.bottom-coords.bottom>2*(coords.bottom-box.top)))return!1}}return!0}))}const maybeRTL=/[\u0590-\u08ac]/;function endOfTextblockHorizontal(view,state,dir){let{$head:$head}=state.selection;if(!$head.parent.isTextblock)return!1;let offset=$head.parentOffset,atStart=!offset,atEnd=offset==$head.parent.content.size,sel=view.domSelection();
// If the textblock is all LTR, or the browser doesn't support
// Selection.modify (Edge), fall back to a primitive approach
return maybeRTL.test($head.parent.textContent)&&sel.modify?withFlushedState(view,state,(()=>{
// This is a huge hack, but appears to be the best we can
// currently do: use `Selection.modify` to move the selection by
// one character, and see if that moves the cursor out of the
// textblock (or doesn't move it at all, when at the start/end of
// the document).
let{focusNode:oldNode,focusOffset:oldOff,anchorNode:anchorNode,anchorOffset:anchorOffset}=view.domSelectionRange(),oldBidiLevel=sel.caretBidiLevel;sel.modify("move",dir,"character");let parentDOM=$head.depth?view.docView.domAfterPos($head.before()):view.dom,{focusNode:newNode,focusOffset:newOff}=view.domSelectionRange(),result=newNode&&!parentDOM.contains(1==newNode.nodeType?newNode:newNode.parentNode)||oldNode==newNode&&oldOff==newOff;
// Restore the previous selection
try{sel.collapse(anchorNode,anchorOffset),oldNode&&(oldNode!=anchorNode||oldOff!=anchorOffset)&&sel.extend&&sel.extend(oldNode,oldOff)}catch(_){}return null!=oldBidiLevel&&(sel.caretBidiLevel=oldBidiLevel),result})):"left"==dir||"backward"==dir?atStart:atEnd}let cachedState=null,cachedDir=null,cachedResult=!1;function endOfTextblock(view,state,dir){return cachedState==state&&cachedDir==dir?cachedResult:(cachedState=state,cachedDir=dir,cachedResult="up"==dir||"down"==dir?endOfTextblockVertical(view,state,dir):endOfTextblockHorizontal(view,state,dir))}
// View descriptions are data structures that describe the DOM that is
// used to represent the editor's content. They are used for:

// - Incremental redrawing when the document changes

// - Figuring out what part of the document a given DOM position
//   corresponds to

// - Wiring in custom implementations of the editing interface for a
//   given node

// They form a doubly-linked mutable tree, starting at `view.docView`.
const NOT_DIRTY=0,CHILD_DIRTY=1,CONTENT_DIRTY=2,NODE_DIRTY=3;
// Superclass for the various kinds of descriptions. Defines their
// basic structure and shared methods.
class ViewDesc{constructor(parent,children,dom,
// This is the node that holds the child views. It may be null for
// descs that don't have children.
contentDOM){this.parent=parent,this.children=children,this.dom=dom,this.contentDOM=contentDOM,this.dirty=NOT_DIRTY,
// An expando property on the DOM node provides a link back to its
// description.
dom.pmViewDesc=this}
// Used to check whether a given description corresponds to a
// widget/mark/node.
matchesWidget(widget){return!1}matchesMark(mark){return!1}matchesNode(node,outerDeco,innerDeco){return!1}matchesHack(nodeName){return!1}
// When parsing in-editor content (in domchange.js), we allow
// descriptions to determine the parse rules that should be used to
// parse them.
parseRule(){return null}
// Used by the editor's event handler to ignore events that come
// from certain descs.
stopEvent(event){return!1}
// The size of the content represented by this desc.
get size(){let size=0;for(let i=0;i<this.children.length;i++)size+=this.children[i].size;return size}
// For block nodes, this represents the space taken up by their
// start/end tokens.
get border(){return 0}destroy(){this.parent=void 0,this.dom.pmViewDesc==this&&(this.dom.pmViewDesc=void 0);for(let i=0;i<this.children.length;i++)this.children[i].destroy()}posBeforeChild(child){for(let i=0,pos=this.posAtStart;;i++){let cur=this.children[i];if(cur==child)return pos;pos+=cur.size}}get posBefore(){return this.parent.posBeforeChild(this)}get posAtStart(){return this.parent?this.parent.posBeforeChild(this)+this.border:0}get posAfter(){return this.posBefore+this.size}get posAtEnd(){return this.posAtStart+this.size-2*this.border}localPosFromDOM(dom,offset,bias){
// If the DOM position is in the content, use the child desc after
// it to figure out a position.
if(this.contentDOM&&this.contentDOM.contains(1==dom.nodeType?dom:dom.parentNode)){if(bias<0){let domBefore,desc;if(dom==this.contentDOM)domBefore=dom.childNodes[offset-1];else{while(dom.parentNode!=this.contentDOM)dom=dom.parentNode;domBefore=dom.previousSibling}while(domBefore&&(!(desc=domBefore.pmViewDesc)||desc.parent!=this))domBefore=domBefore.previousSibling;return domBefore?this.posBeforeChild(desc)+desc.size:this.posAtStart}{let domAfter,desc;if(dom==this.contentDOM)domAfter=dom.childNodes[offset];else{while(dom.parentNode!=this.contentDOM)dom=dom.parentNode;domAfter=dom.nextSibling}while(domAfter&&(!(desc=domAfter.pmViewDesc)||desc.parent!=this))domAfter=domAfter.nextSibling;return domAfter?this.posBeforeChild(desc):this.posAtEnd}}
// Otherwise, use various heuristics, falling back on the bias
// parameter, to determine whether to return the position at the
// start or at the end of this view desc.
let atEnd;if(dom==this.dom&&this.contentDOM)atEnd=offset>domIndex(this.contentDOM);else if(this.contentDOM&&this.contentDOM!=this.dom&&this.dom.contains(this.contentDOM))atEnd=2&dom.compareDocumentPosition(this.contentDOM);else if(this.dom.firstChild){if(0==offset)for(let search=dom;;search=search.parentNode){if(search==this.dom){atEnd=!1;break}if(search.previousSibling)break}if(null==atEnd&&offset==dom.childNodes.length)for(let search=dom;;search=search.parentNode){if(search==this.dom){atEnd=!0;break}if(search.nextSibling)break}}return(null==atEnd?bias>0:atEnd)?this.posAtEnd:this.posAtStart}nearestDesc(dom,onlyNodes=!1){for(let first=!0,cur=dom;cur;cur=cur.parentNode){let nodeDOM,desc=this.getDesc(cur);if(desc&&(!onlyNodes||desc.node)){
// If dom is outside of this desc's nodeDOM, don't count it.
if(!first||!(nodeDOM=desc.nodeDOM)||(1==nodeDOM.nodeType?nodeDOM.contains(1==dom.nodeType?dom:dom.parentNode):nodeDOM==dom))return desc;first=!1}}}getDesc(dom){let desc=dom.pmViewDesc;for(let cur=desc;cur;cur=cur.parent)if(cur==this)return desc}posFromDOM(dom,offset,bias){for(let scan=dom;scan;scan=scan.parentNode){let desc=this.getDesc(scan);if(desc)return desc.localPosFromDOM(dom,offset,bias)}return-1}
// Find the desc for the node after the given pos, if any. (When a
// parent node overrode rendering, there might not be one.)
descAt(pos){for(let i=0,offset=0;i<this.children.length;i++){let child=this.children[i],end=offset+child.size;if(offset==pos&&end!=offset){while(!child.border&&child.children.length)child=child.children[0];return child}if(pos<end)return child.descAt(pos-offset-child.border);offset=end}}domFromPos(pos,side){if(!this.contentDOM)return{node:this.dom,offset:0,atom:pos+1};
// First find the position in the child array
let i=0,offset=0;for(let curPos=0;i<this.children.length;i++){let child=this.children[i],end=curPos+child.size;if(end>pos||child instanceof TrailingHackViewDesc){offset=pos-curPos;break}curPos=end}
// If this points into the middle of a child, call through
if(offset)return this.children[i].domFromPos(offset-this.children[i].border,side);
// Go back if there were any zero-length widgets with side >= 0 before this point
for(let prev;i&&!(prev=this.children[i-1]).size&&prev instanceof WidgetViewDesc&&prev.side>=0;i--);
// Scan towards the first useable node
if(side<=0){let prev,enter=!0;for(;;i--,enter=!1)if(prev=i?this.children[i-1]:null,!prev||prev.dom.parentNode==this.contentDOM)break;return prev&&side&&enter&&!prev.border&&!prev.domAtom?prev.domFromPos(prev.size,side):{node:this.contentDOM,offset:prev?domIndex(prev.dom)+1:0}}{let next,enter=!0;for(;;i++,enter=!1)if(next=i<this.children.length?this.children[i]:null,!next||next.dom.parentNode==this.contentDOM)break;return next&&enter&&!next.border&&!next.domAtom?next.domFromPos(0,side):{node:this.contentDOM,offset:next?domIndex(next.dom):this.contentDOM.childNodes.length}}}
// Used to find a DOM range in a single parent for a given changed
// range.
parseRange(from,to,base=0){if(0==this.children.length)return{node:this.contentDOM,from:from,to:to,fromOffset:0,toOffset:this.contentDOM.childNodes.length};let fromOffset=-1,toOffset=-1;for(let offset=base,i=0;;i++){let child=this.children[i],end=offset+child.size;if(-1==fromOffset&&from<=end){let childBase=offset+child.border;
// FIXME maybe descend mark views to parse a narrower range?
if(from>=childBase&&to<=end-child.border&&child.node&&child.contentDOM&&this.contentDOM.contains(child.contentDOM))return child.parseRange(from,to,childBase);from=offset;for(let j=i;j>0;j--){let prev=this.children[j-1];if(prev.size&&prev.dom.parentNode==this.contentDOM&&!prev.emptyChildAt(1)){fromOffset=domIndex(prev.dom)+1;break}from-=prev.size}-1==fromOffset&&(fromOffset=0)}if(fromOffset>-1&&(end>to||i==this.children.length-1)){to=end;for(let j=i+1;j<this.children.length;j++){let next=this.children[j];if(next.size&&next.dom.parentNode==this.contentDOM&&!next.emptyChildAt(-1)){toOffset=domIndex(next.dom);break}to+=next.size}-1==toOffset&&(toOffset=this.contentDOM.childNodes.length);break}offset=end}return{node:this.contentDOM,from:from,to:to,fromOffset:fromOffset,toOffset:toOffset}}emptyChildAt(side){if(this.border||!this.contentDOM||!this.children.length)return!1;let child=this.children[side<0?0:this.children.length-1];return 0==child.size||child.emptyChildAt(side)}domAfterPos(pos){let{node:node,offset:offset}=this.domFromPos(pos,0);if(1!=node.nodeType||offset==node.childNodes.length)throw new RangeError("No node after pos "+pos);return node.childNodes[offset]}
// View descs are responsible for setting any selection that falls
// entirely inside of them, so that custom implementations can do
// custom things with the selection. Note that this falls apart when
// a selection starts in such a node and ends in another, in which
// case we just use whatever domFromPos produces as a best effort.
setSelection(anchor,head,root,force=!1){
// If the selection falls entirely in a child, give it to that child
let from=Math.min(anchor,head),to=Math.max(anchor,head);for(let i=0,offset=0;i<this.children.length;i++){let child=this.children[i],end=offset+child.size;if(from>offset&&to<end)return child.setSelection(anchor-offset-child.border,head-offset-child.border,root,force);offset=end}let anchorDOM=this.domFromPos(anchor,anchor?-1:1),headDOM=head==anchor?anchorDOM:this.domFromPos(head,head?-1:1),domSel=root.getSelection(),brKludge=!1;
// On Firefox, using Selection.collapse to put the cursor after a
// BR node for some reason doesn't always work (#1073). On Safari,
// the cursor sometimes inexplicable visually lags behind its
// reported position in such situations (#1092).
if((gecko||safari)&&anchor==head){let{node:node,offset:offset}=anchorDOM;if(3==node.nodeType){
// Issue #1128
if(brKludge=!(!offset||"\n"!=node.nodeValue[offset-1]),brKludge&&offset==node.nodeValue.length)for(let after,scan=node;scan;scan=scan.parentNode){if(after=scan.nextSibling){"BR"==after.nodeName&&(anchorDOM=headDOM={node:after.parentNode,offset:domIndex(after)+1});break}let desc=scan.pmViewDesc;if(desc&&desc.node&&desc.node.isBlock)break}}else{let prev=node.childNodes[offset-1];brKludge=prev&&("BR"==prev.nodeName||"false"==prev.contentEditable)}}
// Firefox can act strangely when the selection is in front of an
// uneditable node. See #1163 and https://bugzilla.mozilla.org/show_bug.cgi?id=1709536
if(gecko&&domSel.focusNode&&domSel.focusNode!=headDOM.node&&1==domSel.focusNode.nodeType){let after=domSel.focusNode.childNodes[domSel.focusOffset];after&&"false"==after.contentEditable&&(force=!0)}if(!(force||brKludge&&safari)&&isEquivalentPosition(anchorDOM.node,anchorDOM.offset,domSel.anchorNode,domSel.anchorOffset)&&isEquivalentPosition(headDOM.node,headDOM.offset,domSel.focusNode,domSel.focusOffset))return;
// Selection.extend can be used to create an 'inverted' selection
// (one where the focus is before the anchor), but not all
// browsers support it yet.
let domSelExtended=!1;if((domSel.extend||anchor==head)&&!brKludge){domSel.collapse(anchorDOM.node,anchorDOM.offset);try{anchor!=head&&domSel.extend(headDOM.node,headDOM.offset),domSelExtended=!0}catch(_){
// In some cases with Chrome the selection is empty after calling
// collapse, even when it should be valid. This appears to be a bug, but
// it is difficult to isolate. If this happens fallback to the old path
// without using extend.
// Similarly, this could crash on Safari if the editor is hidden, and
// there was no selection.
}}if(!domSelExtended){if(anchor>head){let tmp=anchorDOM;anchorDOM=headDOM,headDOM=tmp}let range=document.createRange();range.setEnd(headDOM.node,headDOM.offset),range.setStart(anchorDOM.node,anchorDOM.offset),domSel.removeAllRanges(),domSel.addRange(range)}}ignoreMutation(mutation){return!this.contentDOM&&"selection"!=mutation.type}get contentLost(){return this.contentDOM&&this.contentDOM!=this.dom&&!this.dom.contains(this.contentDOM)}
// Remove a subtree of the element tree that has been touched
// by a DOM change, so that the next update will redraw it.
markDirty(from,to){for(let offset=0,i=0;i<this.children.length;i++){let child=this.children[i],end=offset+child.size;if(offset==end?from<=end&&to>=offset:from<end&&to>offset){let startInside=offset+child.border,endInside=end-child.border;if(from>=startInside&&to<=endInside)return this.dirty=from==offset||to==end?CONTENT_DIRTY:CHILD_DIRTY,void(from!=startInside||to!=endInside||!child.contentLost&&child.dom.parentNode==this.contentDOM?child.markDirty(from-startInside,to-startInside):child.dirty=NODE_DIRTY);child.dirty=child.dom!=child.contentDOM||child.dom.parentNode!=this.contentDOM||child.children.length?NODE_DIRTY:CONTENT_DIRTY}offset=end}this.dirty=CONTENT_DIRTY}markParentsDirty(){let level=1;for(let node=this.parent;node;node=node.parent,level++){let dirty=1==level?CONTENT_DIRTY:CHILD_DIRTY;node.dirty<dirty&&(node.dirty=dirty)}}get domAtom(){return!1}get ignoreForCoords(){return!1}}
// A widget desc represents a widget decoration, which is a DOM node
// drawn between the document nodes.
class WidgetViewDesc extends ViewDesc{constructor(parent,widget,view,pos){let self,dom=widget.type.toDOM;if("function"==typeof dom&&(dom=dom(view,(()=>self?self.parent?self.parent.posBeforeChild(self):void 0:pos))),!widget.type.spec.raw){if(1!=dom.nodeType){let wrap=document.createElement("span");wrap.appendChild(dom),dom=wrap}dom.contentEditable="false",dom.classList.add("ProseMirror-widget")}super(parent,[],dom,null),this.widget=widget,this.widget=widget,self=this}matchesWidget(widget){return this.dirty==NOT_DIRTY&&widget.type.eq(this.widget.type)}parseRule(){return{ignore:!0}}stopEvent(event){let stop=this.widget.spec.stopEvent;return!!stop&&stop(event)}ignoreMutation(mutation){return"selection"!=mutation.type||this.widget.spec.ignoreSelection}destroy(){this.widget.type.destroy(this.dom),super.destroy()}get domAtom(){return!0}get side(){return this.widget.type.side}}class CompositionViewDesc extends ViewDesc{constructor(parent,dom,textDOM,text){super(parent,[],dom,null),this.textDOM=textDOM,this.text=text}get size(){return this.text.length}localPosFromDOM(dom,offset){return dom!=this.textDOM?this.posAtStart+(offset?this.size:0):this.posAtStart+offset}domFromPos(pos){return{node:this.textDOM,offset:pos}}ignoreMutation(mut){return"characterData"===mut.type&&mut.target.nodeValue==mut.oldValue}}
// A mark desc represents a mark. May have multiple children,
// depending on how the mark is split. Note that marks are drawn using
// a fixed nesting order, for simplicity and predictability, so in
// some cases they will be split more often than would appear
// necessary.
class MarkViewDesc extends ViewDesc{constructor(parent,mark,dom,contentDOM){super(parent,[],dom,contentDOM),this.mark=mark}static create(parent,mark,inline,view){let custom=view.nodeViews[mark.type.name],spec=custom&&custom(mark,view,inline);return spec&&spec.dom||(spec=DOMSerializer.renderSpec(document,mark.type.spec.toDOM(mark,inline))),new MarkViewDesc(parent,mark,spec.dom,spec.contentDOM||spec.dom)}parseRule(){return this.dirty&NODE_DIRTY||this.mark.type.spec.reparseInView?null:{mark:this.mark.type.name,attrs:this.mark.attrs,contentElement:this.contentDOM||void 0}}matchesMark(mark){return this.dirty!=NODE_DIRTY&&this.mark.eq(mark)}markDirty(from,to){
// Move dirty info to nearest node view
if(super.markDirty(from,to),this.dirty!=NOT_DIRTY){let parent=this.parent;while(!parent.node)parent=parent.parent;parent.dirty<this.dirty&&(parent.dirty=this.dirty),this.dirty=NOT_DIRTY}}slice(from,to,view){let copy=MarkViewDesc.create(this.parent,this.mark,!0,view),nodes=this.children,size=this.size;to<size&&(nodes=replaceNodes(nodes,to,size,view)),from>0&&(nodes=replaceNodes(nodes,0,from,view));for(let i=0;i<nodes.length;i++)nodes[i].parent=copy;return copy.children=nodes,copy}}
// Node view descs are the main, most common type of view desc, and
// correspond to an actual node in the document. Unlike mark descs,
// they populate their child array themselves.
class NodeViewDesc extends ViewDesc{constructor(parent,node,outerDeco,innerDeco,dom,contentDOM,nodeDOM,view,pos){super(parent,[],dom,contentDOM),this.node=node,this.outerDeco=outerDeco,this.innerDeco=innerDeco,this.nodeDOM=nodeDOM,contentDOM&&this.updateChildren(view,pos)}
// By default, a node is rendered using the `toDOM` method from the
// node type spec. But client code can use the `nodeViews` spec to
// supply a custom node view, which can influence various aspects of
// the way the node works.
// (Using subclassing for this was intentionally decided against,
// since it'd require exposing a whole slew of finicky
// implementation details to the user code that they probably will
// never need.)
static create(parent,node,outerDeco,innerDeco,view,pos){let descObj,custom=view.nodeViews[node.type.name],spec=custom&&custom(node,view,(()=>
// (This is a function that allows the custom view to find its
// own position)
descObj?descObj.parent?descObj.parent.posBeforeChild(descObj):void 0:pos),outerDeco,innerDeco),dom=spec&&spec.dom,contentDOM=spec&&spec.contentDOM;if(node.isText)if(dom){if(3!=dom.nodeType)throw new RangeError("Text must be rendered as a DOM text node")}else dom=document.createTextNode(node.text);else dom||({dom:dom,contentDOM:contentDOM}=DOMSerializer.renderSpec(document,node.type.spec.toDOM(node)));contentDOM||node.isText||"BR"==dom.nodeName||(// Chrome gets confused by <br contenteditable=false>
dom.hasAttribute("contenteditable")||(dom.contentEditable="false"),node.type.spec.draggable&&(dom.draggable=!0));let nodeDOM=dom;return dom=applyOuterDeco(dom,outerDeco,node),spec?descObj=new CustomNodeViewDesc(parent,node,outerDeco,innerDeco,dom,contentDOM||null,nodeDOM,spec,view,pos+1):node.isText?new TextViewDesc(parent,node,outerDeco,innerDeco,dom,nodeDOM,view):new NodeViewDesc(parent,node,outerDeco,innerDeco,dom,contentDOM||null,nodeDOM,view,pos+1)}parseRule(){
// Experimental kludge to allow opt-in re-parsing of nodes
if(this.node.type.spec.reparseInView)return null;
// FIXME the assumption that this can always return the current
// attrs means that if the user somehow manages to change the
// attrs in the dom, that won't be picked up. Not entirely sure
// whether this is a problem
let rule={node:this.node.type.name,attrs:this.node.attrs};if("pre"==this.node.type.whitespace&&(rule.preserveWhitespace="full"),this.contentDOM)if(this.contentLost){
// Chrome likes to randomly recreate parent nodes when
// backspacing things. When that happens, this tries to find the
// new parent.
for(let i=this.children.length-1;i>=0;i--){let child=this.children[i];if(this.dom.contains(child.dom.parentNode)){rule.contentElement=child.dom.parentNode;break}}rule.contentElement||(rule.getContent=()=>Fragment.empty)}else rule.contentElement=this.contentDOM;else rule.getContent=()=>this.node.content;return rule}matchesNode(node,outerDeco,innerDeco){return this.dirty==NOT_DIRTY&&node.eq(this.node)&&sameOuterDeco(outerDeco,this.outerDeco)&&innerDeco.eq(this.innerDeco)}get size(){return this.node.nodeSize}get border(){return this.node.isLeaf?0:1}
// Syncs `this.children` to match `this.node.content` and the local
// decorations, possibly introducing nesting for marks. Then, in a
// separate step, syncs the DOM inside `this.contentDOM` to
// `this.children`.
updateChildren(view,pos){let inline=this.node.inlineContent,off=pos,composition=view.composing?this.localCompositionInfo(view,pos):null,localComposition=composition&&composition.pos>-1?composition:null,compositionInChild=composition&&composition.pos<0,updater=new ViewTreeUpdater(this,localComposition&&localComposition.node,view);iterDeco(this.node,this.innerDeco,((widget,i,insideNode)=>{widget.spec.marks?updater.syncToMarks(widget.spec.marks,inline,view):widget.type.side>=0&&!insideNode&&updater.syncToMarks(i==this.node.childCount?Mark$1.none:this.node.child(i).marks,inline,view),
// If the next node is a desc matching this widget, reuse it,
// otherwise insert the widget as a new view desc.
updater.placeWidget(widget,view,off)}),((child,outerDeco,innerDeco,i)=>{
// Try several strategies for drawing this node
let compIndex;
// Make sure the wrapping mark descs match the node's marks.
updater.syncToMarks(child.marks,inline,view),updater.findNodeMatch(child,outerDeco,innerDeco,i)||compositionInChild&&view.state.selection.from>off&&view.state.selection.to<off+child.nodeSize&&(compIndex=updater.findIndexWithChild(composition.node))>-1&&updater.updateNodeAt(child,outerDeco,innerDeco,compIndex,view)||updater.updateNextNode(child,outerDeco,innerDeco,view,i)||
// Add it as a new view
updater.addNode(child,outerDeco,innerDeco,view,off),off+=child.nodeSize})),
// Drop all remaining descs after the current position.
updater.syncToMarks([],inline,view),this.node.isTextblock&&updater.addTextblockHacks(),updater.destroyRest(),
// Sync the DOM if anything changed
(updater.changed||this.dirty==CONTENT_DIRTY)&&(
// May have to protect focused DOM from being changed if a composition is active
localComposition&&this.protectLocalComposition(view,localComposition),renderDescs(this.contentDOM,this.children,view),ios&&iosHacks(this.dom))}localCompositionInfo(view,pos){
// Only do something if both the selection and a focused text node
// are inside of this node
let{from:from,to:to}=view.state.selection;if(!(view.state.selection instanceof TextSelection)||from<pos||to>pos+this.node.content.size)return null;let sel=view.domSelectionRange(),textNode=nearbyTextNode(sel.focusNode,sel.focusOffset);if(!textNode||!this.dom.contains(textNode.parentNode))return null;if(this.node.inlineContent){
// Find the text in the focused node in the node, stop if it's not
// there (may have been modified through other means, in which
// case it should overwritten)
let text=textNode.nodeValue,textPos=findTextInFragment(this.node.content,text,from-pos,to-pos);return textPos<0?null:{node:textNode,pos:textPos,text:text}}return{node:textNode,pos:-1,text:""}}protectLocalComposition(view,{node:node,pos:pos,text:text}){
// The node is already part of a local view desc, leave it there
if(this.getDesc(node))return;
// Create a composition view for the orphaned nodes
let topNode=node;for(;;topNode=topNode.parentNode){if(topNode.parentNode==this.contentDOM)break;while(topNode.previousSibling)topNode.parentNode.removeChild(topNode.previousSibling);while(topNode.nextSibling)topNode.parentNode.removeChild(topNode.nextSibling);topNode.pmViewDesc&&(topNode.pmViewDesc=void 0)}let desc=new CompositionViewDesc(this,topNode,node,text);view.input.compositionNodes.push(desc),
// Patch up this.children to contain the composition view
this.children=replaceNodes(this.children,pos,pos+text.length,view,desc)}
// If this desc must be updated to match the given node decoration,
// do so and return true.
update(node,outerDeco,innerDeco,view){return!(this.dirty==NODE_DIRTY||!node.sameMarkup(this.node))&&(this.updateInner(node,outerDeco,innerDeco,view),!0)}updateInner(node,outerDeco,innerDeco,view){this.updateOuterDeco(outerDeco),this.node=node,this.innerDeco=innerDeco,this.contentDOM&&this.updateChildren(view,this.posAtStart),this.dirty=NOT_DIRTY}updateOuterDeco(outerDeco){if(sameOuterDeco(outerDeco,this.outerDeco))return;let needsWrap=1!=this.nodeDOM.nodeType,oldDOM=this.dom;this.dom=patchOuterDeco(this.dom,this.nodeDOM,computeOuterDeco(this.outerDeco,this.node,needsWrap),computeOuterDeco(outerDeco,this.node,needsWrap)),this.dom!=oldDOM&&(oldDOM.pmViewDesc=void 0,this.dom.pmViewDesc=this),this.outerDeco=outerDeco}
// Mark this node as being the selected node.
selectNode(){1==this.nodeDOM.nodeType&&this.nodeDOM.classList.add("ProseMirror-selectednode"),!this.contentDOM&&this.node.type.spec.draggable||(this.dom.draggable=!0)}
// Remove selected node marking from this node.
deselectNode(){1==this.nodeDOM.nodeType&&this.nodeDOM.classList.remove("ProseMirror-selectednode"),!this.contentDOM&&this.node.type.spec.draggable||this.dom.removeAttribute("draggable")}get domAtom(){return this.node.isAtom}}
// Create a view desc for the top-level document node, to be exported
// and used by the view class.
function docViewDesc(doc,outerDeco,innerDeco,dom,view){return applyOuterDeco(dom,outerDeco,doc),new NodeViewDesc(void 0,doc,outerDeco,innerDeco,dom,dom,dom,view,0)}class TextViewDesc extends NodeViewDesc{constructor(parent,node,outerDeco,innerDeco,dom,nodeDOM,view){super(parent,node,outerDeco,innerDeco,dom,null,nodeDOM,view,0)}parseRule(){let skip=this.nodeDOM.parentNode;while(skip&&skip!=this.dom&&!skip.pmIsDeco)skip=skip.parentNode;return{skip:skip||!0}}update(node,outerDeco,innerDeco,view){return!(this.dirty==NODE_DIRTY||this.dirty!=NOT_DIRTY&&!this.inParent()||!node.sameMarkup(this.node))&&(this.updateOuterDeco(outerDeco),this.dirty==NOT_DIRTY&&node.text==this.node.text||node.text==this.nodeDOM.nodeValue||(this.nodeDOM.nodeValue=node.text,view.trackWrites==this.nodeDOM&&(view.trackWrites=null)),this.node=node,this.dirty=NOT_DIRTY,!0)}inParent(){let parentDOM=this.parent.contentDOM;for(let n=this.nodeDOM;n;n=n.parentNode)if(n==parentDOM)return!0;return!1}domFromPos(pos){return{node:this.nodeDOM,offset:pos}}localPosFromDOM(dom,offset,bias){return dom==this.nodeDOM?this.posAtStart+Math.min(offset,this.node.text.length):super.localPosFromDOM(dom,offset,bias)}ignoreMutation(mutation){return"characterData"!=mutation.type&&"selection"!=mutation.type}slice(from,to,view){let node=this.node.cut(from,to),dom=document.createTextNode(node.text);return new TextViewDesc(this.parent,node,this.outerDeco,this.innerDeco,dom,dom,view)}markDirty(from,to){super.markDirty(from,to),this.dom==this.nodeDOM||0!=from&&to!=this.nodeDOM.nodeValue.length||(this.dirty=NODE_DIRTY)}get domAtom(){return!1}}
// A dummy desc used to tag trailing BR or IMG nodes created to work
// around contentEditable terribleness.
class TrailingHackViewDesc extends ViewDesc{parseRule(){return{ignore:!0}}matchesHack(nodeName){return this.dirty==NOT_DIRTY&&this.dom.nodeName==nodeName}get domAtom(){return!0}get ignoreForCoords(){return"IMG"==this.dom.nodeName}}
// A separate subclass is used for customized node views, so that the
// extra checks only have to be made for nodes that are actually
// customized.
class CustomNodeViewDesc extends NodeViewDesc{constructor(parent,node,outerDeco,innerDeco,dom,contentDOM,nodeDOM,spec,view,pos){super(parent,node,outerDeco,innerDeco,dom,contentDOM,nodeDOM,view,pos),this.spec=spec}
// A custom `update` method gets to decide whether the update goes
// through. If it does, and there's a `contentDOM` node, our logic
// updates the children.
update(node,outerDeco,innerDeco,view){if(this.dirty==NODE_DIRTY)return!1;if(this.spec.update){let result=this.spec.update(node,outerDeco,innerDeco);return result&&this.updateInner(node,outerDeco,innerDeco,view),result}return!(!this.contentDOM&&!node.isLeaf)&&super.update(node,outerDeco,innerDeco,view)}selectNode(){this.spec.selectNode?this.spec.selectNode():super.selectNode()}deselectNode(){this.spec.deselectNode?this.spec.deselectNode():super.deselectNode()}setSelection(anchor,head,root,force){this.spec.setSelection?this.spec.setSelection(anchor,head,root):super.setSelection(anchor,head,root,force)}destroy(){this.spec.destroy&&this.spec.destroy(),super.destroy()}stopEvent(event){return!!this.spec.stopEvent&&this.spec.stopEvent(event)}ignoreMutation(mutation){return this.spec.ignoreMutation?this.spec.ignoreMutation(mutation):super.ignoreMutation(mutation)}}
// Sync the content of the given DOM node with the nodes associated
// with the given array of view descs, recursing into mark descs
// because this should sync the subtree for a whole node at a time.
function renderDescs(parentDOM,descs,view){let dom=parentDOM.firstChild,written=!1;for(let i=0;i<descs.length;i++){let desc=descs[i],childDOM=desc.dom;if(childDOM.parentNode==parentDOM){while(childDOM!=dom)dom=rm(dom),written=!0;dom=dom.nextSibling}else written=!0,parentDOM.insertBefore(childDOM,dom);if(desc instanceof MarkViewDesc){let pos=dom?dom.previousSibling:parentDOM.lastChild;renderDescs(desc.contentDOM,desc.children,view),dom=pos?pos.nextSibling:parentDOM.firstChild}}while(dom)dom=rm(dom),written=!0;written&&view.trackWrites==parentDOM&&(view.trackWrites=null)}const OuterDecoLevel=function(nodeName){nodeName&&(this.nodeName=nodeName)};OuterDecoLevel.prototype=Object.create(null);const noDeco=[new OuterDecoLevel];function computeOuterDeco(outerDeco,node,needsWrap){if(0==outerDeco.length)return noDeco;let top=needsWrap?noDeco[0]:new OuterDecoLevel,result=[top];for(let i=0;i<outerDeco.length;i++){let attrs=outerDeco[i].type.attrs;if(attrs){attrs.nodeName&&result.push(top=new OuterDecoLevel(attrs.nodeName));for(let name in attrs){let val=attrs[name];null!=val&&(needsWrap&&1==result.length&&result.push(top=new OuterDecoLevel(node.isInline?"span":"div")),"class"==name?top.class=(top.class?top.class+" ":"")+val:"style"==name?top.style=(top.style?top.style+";":"")+val:"nodeName"!=name&&(top[name]=val))}}}return result}function patchOuterDeco(outerDOM,nodeDOM,prevComputed,curComputed){
// Shortcut for trivial case
if(prevComputed==noDeco&&curComputed==noDeco)return nodeDOM;let curDOM=nodeDOM;for(let i=0;i<curComputed.length;i++){let deco=curComputed[i],prev=prevComputed[i];if(i){let parent;prev&&prev.nodeName==deco.nodeName&&curDOM!=outerDOM&&(parent=curDOM.parentNode)&&parent.nodeName.toLowerCase()==deco.nodeName||(parent=document.createElement(deco.nodeName),parent.pmIsDeco=!0,parent.appendChild(curDOM),prev=noDeco[0]),curDOM=parent}patchAttributes(curDOM,prev||noDeco[0],deco)}return curDOM}function patchAttributes(dom,prev,cur){for(let name in prev)"class"==name||"style"==name||"nodeName"==name||name in cur||dom.removeAttribute(name);for(let name in cur)"class"!=name&&"style"!=name&&"nodeName"!=name&&cur[name]!=prev[name]&&dom.setAttribute(name,cur[name]);if(prev.class!=cur.class){let prevList=prev.class?prev.class.split(" ").filter(Boolean):[],curList=cur.class?cur.class.split(" ").filter(Boolean):[];for(let i=0;i<prevList.length;i++)-1==curList.indexOf(prevList[i])&&dom.classList.remove(prevList[i]);for(let i=0;i<curList.length;i++)-1==prevList.indexOf(curList[i])&&dom.classList.add(curList[i]);0==dom.classList.length&&dom.removeAttribute("class")}if(prev.style!=cur.style){if(prev.style){let m,prop=/\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g;while(m=prop.exec(prev.style))dom.style.removeProperty(m[1])}cur.style&&(dom.style.cssText+=cur.style)}}function applyOuterDeco(dom,deco,node){return patchOuterDeco(dom,dom,noDeco,computeOuterDeco(deco,node,1!=dom.nodeType))}function sameOuterDeco(a,b){if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(!a[i].type.eq(b[i].type))return!1;return!0}
// Remove a DOM node and return its next sibling.
function rm(dom){let next=dom.nextSibling;return dom.parentNode.removeChild(dom),next}
// Helper class for incrementally updating a tree of mark descs and
// the widget and node descs inside of them.
class ViewTreeUpdater{constructor(top,lock,view){this.lock=lock,this.view=view,
// Index into `this.top`'s child array, represents the current
// update position.
this.index=0,
// When entering a mark, the current top and index are pushed
// onto this.
this.stack=[],
// Tracks whether anything was changed
this.changed=!1,this.top=top,this.preMatch=preMatch(top.node.content,top)}
// Destroy and remove the children between the given indices in
// `this.top`.
destroyBetween(start,end){if(start!=end){for(let i=start;i<end;i++)this.top.children[i].destroy();this.top.children.splice(start,end-start),this.changed=!0}}
// Destroy all remaining children in `this.top`.
destroyRest(){this.destroyBetween(this.index,this.top.children.length)}
// Sync the current stack of mark descs with the given array of
// marks, reusing existing mark descs when possible.
syncToMarks(marks,inline,view){let keep=0,depth=this.stack.length>>1,maxKeep=Math.min(depth,marks.length);while(keep<maxKeep&&(keep==depth-1?this.top:this.stack[keep+1<<1]).matchesMark(marks[keep])&&!1!==marks[keep].type.spec.spanning)keep++;while(keep<depth)this.destroyRest(),this.top.dirty=NOT_DIRTY,this.index=this.stack.pop(),this.top=this.stack.pop(),depth--;while(depth<marks.length){this.stack.push(this.top,this.index+1);let found=-1;for(let i=this.index;i<Math.min(this.index+3,this.top.children.length);i++){let next=this.top.children[i];if(next.matchesMark(marks[depth])&&!this.isLocked(next.dom)){found=i;break}}if(found>-1)found>this.index&&(this.changed=!0,this.destroyBetween(this.index,found)),this.top=this.top.children[this.index];else{let markDesc=MarkViewDesc.create(this.top,marks[depth],inline,view);this.top.children.splice(this.index,0,markDesc),this.top=markDesc,this.changed=!0}this.index=0,depth++}}
// Try to find a node desc matching the given data. Skip over it and
// return true when successful.
findNodeMatch(node,outerDeco,innerDeco,index){let targetDesc,found=-1;if(index>=this.preMatch.index&&(targetDesc=this.preMatch.matches[index-this.preMatch.index]).parent==this.top&&targetDesc.matchesNode(node,outerDeco,innerDeco))found=this.top.children.indexOf(targetDesc,this.index);else for(let i=this.index,e=Math.min(this.top.children.length,i+5);i<e;i++){let child=this.top.children[i];if(child.matchesNode(node,outerDeco,innerDeco)&&!this.preMatch.matched.has(child)){found=i;break}}return!(found<0)&&(this.destroyBetween(this.index,found),this.index++,!0)}updateNodeAt(node,outerDeco,innerDeco,index,view){let child=this.top.children[index];return child.dirty==NODE_DIRTY&&child.dom==child.contentDOM&&(child.dirty=CONTENT_DIRTY),!!child.update(node,outerDeco,innerDeco,view)&&(this.destroyBetween(this.index,index),this.index++,!0)}findIndexWithChild(domNode){for(;;){let parent=domNode.parentNode;if(!parent)return-1;if(parent==this.top.contentDOM){let desc=domNode.pmViewDesc;if(desc)for(let i=this.index;i<this.top.children.length;i++)if(this.top.children[i]==desc)return i;return-1}domNode=parent}}
// Try to update the next node, if any, to the given data. Checks
// pre-matches to avoid overwriting nodes that could still be used.
updateNextNode(node,outerDeco,innerDeco,view,index){for(let i=this.index;i<this.top.children.length;i++){let next=this.top.children[i];if(next instanceof NodeViewDesc){let preMatch=this.preMatch.matched.get(next);if(null!=preMatch&&preMatch!=index)return!1;let nextDOM=next.dom,locked=this.isLocked(nextDOM)&&!(node.isText&&next.node&&next.node.isText&&next.nodeDOM.nodeValue==node.text&&next.dirty!=NODE_DIRTY&&sameOuterDeco(outerDeco,next.outerDeco));
// Can't update if nextDOM is or contains this.lock, except if
// it's a text node whose content already matches the new text
// and whose decorations match the new ones.
if(!locked&&next.update(node,outerDeco,innerDeco,view))return this.destroyBetween(this.index,i),next.dom!=nextDOM&&(this.changed=!0),this.index++,!0;break}}return!1}
// Insert the node as a newly created node desc.
addNode(node,outerDeco,innerDeco,view,pos){this.top.children.splice(this.index++,0,NodeViewDesc.create(this.top,node,outerDeco,innerDeco,view,pos)),this.changed=!0}placeWidget(widget,view,pos){let next=this.index<this.top.children.length?this.top.children[this.index]:null;if(!next||!next.matchesWidget(widget)||widget!=next.widget&&next.widget.type.toDOM.parentNode){let desc=new WidgetViewDesc(this.top,widget,view,pos);this.top.children.splice(this.index++,0,desc),this.changed=!0}else this.index++}
// Make sure a textblock looks and behaves correctly in
// contentEditable.
addTextblockHacks(){let lastChild=this.top.children[this.index-1],parent=this.top;while(lastChild instanceof MarkViewDesc)parent=lastChild,lastChild=parent.children[parent.children.length-1];(!lastChild||// Empty textblock
!(lastChild instanceof TextViewDesc)||/\n$/.test(lastChild.node.text)||this.view.requiresGeckoHackNode&&/\s$/.test(lastChild.node.text))&&(
// Avoid bugs in Safari's cursor drawing (#1165) and Chrome's mouse selection (#1152)
(safari||chrome$1)&&lastChild&&"false"==lastChild.dom.contentEditable&&this.addHackNode("IMG",parent),this.addHackNode("BR",this.top))}addHackNode(nodeName,parent){if(parent==this.top&&this.index<parent.children.length&&parent.children[this.index].matchesHack(nodeName))this.index++;else{let dom=document.createElement(nodeName);"IMG"==nodeName&&(dom.className="ProseMirror-separator",dom.alt=""),"BR"==nodeName&&(dom.className="ProseMirror-trailingBreak");let hack=new TrailingHackViewDesc(this.top,[],dom,null);parent!=this.top?parent.children.push(hack):parent.children.splice(this.index++,0,hack),this.changed=!0}}isLocked(node){return this.lock&&(node==this.lock||1==node.nodeType&&node.contains(this.lock.parentNode))}}
// Iterate from the end of the fragment and array of descs to find
// directly matching ones, in order to avoid overeagerly reusing those
// for other nodes. Returns the fragment index of the first node that
// is part of the sequence of matched nodes at the end of the
// fragment.
function preMatch(frag,parentDesc){let curDesc=parentDesc,descI=curDesc.children.length,fI=frag.childCount,matched=new Map,matches=[];outer:while(fI>0){let desc;for(;;)if(descI){let next=curDesc.children[descI-1];if(!(next instanceof MarkViewDesc)){desc=next,descI--;break}curDesc=next,descI=next.children.length}else{if(curDesc==parentDesc)break outer;
// FIXME
descI=curDesc.parent.children.indexOf(curDesc),curDesc=curDesc.parent}let node=desc.node;if(node){if(node!=frag.child(fI-1))break;--fI,matched.set(desc,fI),matches.push(desc)}}return{index:fI,matched:matched,matches:matches.reverse()}}function compareSide(a,b){return a.type.side-b.type.side}
// This function abstracts iterating over the nodes and decorations in
// a fragment. Calls `onNode` for each node, with its local and child
// decorations. Splits text nodes when there is a decoration starting
// or ending inside of them. Calls `onWidget` for each widget.
function iterDeco(parent,deco,onWidget,onNode){let locals=deco.locals(parent),offset=0;
// Simple, cheap variant for when there are no local decorations
if(0==locals.length){for(let i=0;i<parent.childCount;i++){let child=parent.child(i);onNode(child,locals,deco.forChild(offset,child),i),offset+=child.nodeSize}return}let decoIndex=0,active=[],restNode=null;for(let parentIndex=0;;){if(decoIndex<locals.length&&locals[decoIndex].to==offset){let widgets,widget=locals[decoIndex++];while(decoIndex<locals.length&&locals[decoIndex].to==offset)(widgets||(widgets=[widget])).push(locals[decoIndex++]);if(widgets){widgets.sort(compareSide);for(let i=0;i<widgets.length;i++)onWidget(widgets[i],parentIndex,!!restNode)}else onWidget(widget,parentIndex,!!restNode)}let child,index;if(restNode)index=-1,child=restNode,restNode=null;else{if(!(parentIndex<parent.childCount))break;index=parentIndex,child=parent.child(parentIndex++)}for(let i=0;i<active.length;i++)active[i].to<=offset&&active.splice(i--,1);while(decoIndex<locals.length&&locals[decoIndex].from<=offset&&locals[decoIndex].to>offset)active.push(locals[decoIndex++]);let end=offset+child.nodeSize;if(child.isText){let cutAt=end;decoIndex<locals.length&&locals[decoIndex].from<cutAt&&(cutAt=locals[decoIndex].from);for(let i=0;i<active.length;i++)active[i].to<cutAt&&(cutAt=active[i].to);cutAt<end&&(restNode=child.cut(cutAt-offset),child=child.cut(0,cutAt-offset),end=cutAt,index=-1)}let outerDeco=child.isInline&&!child.isLeaf?active.filter((d=>!d.inline)):active.slice();onNode(child,outerDeco,deco.forChild(offset,child),index),offset=end}}
// List markers in Mobile Safari will mysteriously disappear
// sometimes. This works around that.
function iosHacks(dom){if("UL"==dom.nodeName||"OL"==dom.nodeName){let oldCSS=dom.style.cssText;dom.style.cssText=oldCSS+"; list-style: square !important",window.getComputedStyle(dom).listStyle,dom.style.cssText=oldCSS}}function nearbyTextNode(node,offset){for(;;){if(3==node.nodeType)return node;if(1==node.nodeType&&offset>0){if(node.childNodes.length>offset&&3==node.childNodes[offset].nodeType)return node.childNodes[offset];node=node.childNodes[offset-1],offset=nodeSize(node)}else{if(!(1==node.nodeType&&offset<node.childNodes.length))return null;node=node.childNodes[offset],offset=0}}}
// Find a piece of text in an inline fragment, overlapping from-to
function findTextInFragment(frag,text,from,to){for(let i=0,pos=0;i<frag.childCount&&pos<=to;){let child=frag.child(i++),childStart=pos;if(pos+=child.nodeSize,!child.isText)continue;let str=child.text;while(i<frag.childCount){let next=frag.child(i++);if(pos+=next.nodeSize,!next.isText)break;str+=next.text}if(pos>=from){let found=childStart<to?str.lastIndexOf(text,to-childStart-1):-1;if(found>=0&&found+text.length+childStart>=from)return childStart+found;if(from==to&&str.length>=to+text.length-childStart&&str.slice(to-childStart,to-childStart+text.length)==text)return to}}return-1}
// Replace range from-to in an array of view descs with replacement
// (may be null to just delete). This goes very much against the grain
// of the rest of this code, which tends to create nodes with the
// right shape in one go, rather than messing with them after
// creation, but is necessary in the composition hack.
function replaceNodes(nodes,from,to,view,replacement){let result=[];for(let i=0,off=0;i<nodes.length;i++){let child=nodes[i],start=off,end=off+=child.size;start>=to||end<=from?result.push(child):(start<from&&result.push(child.slice(0,from-start,view)),replacement&&(result.push(replacement),replacement=void 0),end>to&&result.push(child.slice(to-start,child.size,view)))}return result}function selectionFromDOM(view,origin=null){let domSel=view.domSelectionRange(),doc=view.state.doc;if(!domSel.focusNode)return null;let nearestDesc=view.docView.nearestDesc(domSel.focusNode),inWidget=nearestDesc&&0==nearestDesc.size,head=view.docView.posFromDOM(domSel.focusNode,domSel.focusOffset,1);if(head<0)return null;let $anchor,selection,$head=doc.resolve(head);if(selectionCollapsed(domSel)){$anchor=$head;while(nearestDesc&&!nearestDesc.node)nearestDesc=nearestDesc.parent;let nearestDescNode=nearestDesc.node;if(nearestDesc&&nearestDescNode.isAtom&&NodeSelection.isSelectable(nearestDescNode)&&nearestDesc.parent&&(!nearestDescNode.isInline||!isOnEdge(domSel.focusNode,domSel.focusOffset,nearestDesc.dom))){let pos=nearestDesc.posBefore;selection=new NodeSelection(head==pos?$head:doc.resolve(pos))}}else{let anchor=view.docView.posFromDOM(domSel.anchorNode,domSel.anchorOffset,1);if(anchor<0)return null;$anchor=doc.resolve(anchor)}if(!selection){let bias="pointer"==origin||view.state.selection.head<$head.pos&&!inWidget?1:-1;selection=selectionBetween(view,$anchor,$head,bias)}return selection}function editorOwnsSelection(view){return view.editable?view.hasFocus():hasSelection(view)&&document.activeElement&&document.activeElement.contains(view.dom)}function selectionToDOM(view,force=!1){let sel=view.state.selection;if(syncNodeSelection(view,sel),editorOwnsSelection(view)){
// The delayed drag selection causes issues with Cell Selections
// in Safari. And the drag selection delay is to workarond issues
// which only present in Chrome.
if(!force&&view.input.mouseDown&&view.input.mouseDown.allowDefault&&chrome$1){let domSel=view.domSelectionRange(),curSel=view.domObserver.currentSelection;if(domSel.anchorNode&&curSel.anchorNode&&isEquivalentPosition(domSel.anchorNode,domSel.anchorOffset,curSel.anchorNode,curSel.anchorOffset))return view.input.mouseDown.delayedSelectionSync=!0,void view.domObserver.setCurSelection()}if(view.domObserver.disconnectSelection(),view.cursorWrapper)selectCursorWrapper(view);else{let resetEditableFrom,resetEditableTo,{anchor:anchor,head:head}=sel;!brokenSelectBetweenUneditable||sel instanceof TextSelection||(sel.$from.parent.inlineContent||(resetEditableFrom=temporarilyEditableNear(view,sel.from)),sel.empty||sel.$from.parent.inlineContent||(resetEditableTo=temporarilyEditableNear(view,sel.to))),view.docView.setSelection(anchor,head,view.root,force),brokenSelectBetweenUneditable&&(resetEditableFrom&&resetEditable(resetEditableFrom),resetEditableTo&&resetEditable(resetEditableTo)),sel.visible?view.dom.classList.remove("ProseMirror-hideselection"):(view.dom.classList.add("ProseMirror-hideselection"),"onselectionchange"in document&&removeClassOnSelectionChange(view))}view.domObserver.setCurSelection(),view.domObserver.connectSelection()}}
// Kludge to work around Webkit not allowing a selection to start/end
// between non-editable block nodes. We briefly make something
// editable, set the selection, then set it uneditable again.
const brokenSelectBetweenUneditable=safari||chrome$1&&chrome_version<63;function temporarilyEditableNear(view,pos){let{node:node,offset:offset}=view.docView.domFromPos(pos,0),after=offset<node.childNodes.length?node.childNodes[offset]:null,before=offset?node.childNodes[offset-1]:null;if(safari&&after&&"false"==after.contentEditable)return setEditable(after);if((!after||"false"==after.contentEditable)&&(!before||"false"==before.contentEditable)){if(after)return setEditable(after);if(before)return setEditable(before)}}function setEditable(element){return element.contentEditable="true",safari&&element.draggable&&(element.draggable=!1,element.wasDraggable=!0),element}function resetEditable(element){element.contentEditable="false",element.wasDraggable&&(element.draggable=!0,element.wasDraggable=null)}function removeClassOnSelectionChange(view){let doc=view.dom.ownerDocument;doc.removeEventListener("selectionchange",view.input.hideSelectionGuard);let domSel=view.domSelectionRange(),node=domSel.anchorNode,offset=domSel.anchorOffset;doc.addEventListener("selectionchange",view.input.hideSelectionGuard=()=>{domSel.anchorNode==node&&domSel.anchorOffset==offset||(doc.removeEventListener("selectionchange",view.input.hideSelectionGuard),setTimeout((()=>{editorOwnsSelection(view)&&!view.state.selection.visible||view.dom.classList.remove("ProseMirror-hideselection")}),20))})}function selectCursorWrapper(view){let domSel=view.domSelection(),range=document.createRange(),node=view.cursorWrapper.dom,img="IMG"==node.nodeName;img?range.setEnd(node.parentNode,domIndex(node)+1):range.setEnd(node,0),range.collapse(!1),domSel.removeAllRanges(),domSel.addRange(range),
// Kludge to kill 'control selection' in IE11 when selecting an
// invisible cursor wrapper, since that would result in those weird
// resize handles and a selection that considers the absolutely
// positioned wrapper, rather than the root editable node, the
// focused element.
!img&&!view.state.selection.visible&&ie$1&&ie_version<=11&&(node.disabled=!0,node.disabled=!1)}function syncNodeSelection(view,sel){if(sel instanceof NodeSelection){let desc=view.docView.descAt(sel.from);desc!=view.lastSelectedViewDesc&&(clearNodeSelection(view),desc&&desc.selectNode(),view.lastSelectedViewDesc=desc)}else clearNodeSelection(view)}
// Clear all DOM statefulness of the last node selection.
function clearNodeSelection(view){view.lastSelectedViewDesc&&(view.lastSelectedViewDesc.parent&&view.lastSelectedViewDesc.deselectNode(),view.lastSelectedViewDesc=void 0)}function selectionBetween(view,$anchor,$head,bias){return view.someProp("createSelectionBetween",(f=>f(view,$anchor,$head)))||TextSelection.between($anchor,$head,bias)}function hasFocusAndSelection(view){return!(view.editable&&!view.hasFocus())&&hasSelection(view)}function hasSelection(view){let sel=view.domSelectionRange();if(!sel.anchorNode)return!1;try{
// Firefox will raise 'permission denied' errors when accessing
// properties of `sel.anchorNode` when it's in a generated CSS
// element.
return view.dom.contains(3==sel.anchorNode.nodeType?sel.anchorNode.parentNode:sel.anchorNode)&&(view.editable||view.dom.contains(3==sel.focusNode.nodeType?sel.focusNode.parentNode:sel.focusNode))}catch(_){return!1}}function anchorInRightPlace(view){let anchorDOM=view.docView.domFromPos(view.state.selection.anchor,0),domSel=view.domSelectionRange();return isEquivalentPosition(anchorDOM.node,anchorDOM.offset,domSel.anchorNode,domSel.anchorOffset)}function moveSelectionBlock(state,dir){let{$anchor:$anchor,$head:$head}=state.selection,$side=dir>0?$anchor.max($head):$anchor.min($head),$start=$side.parent.inlineContent?$side.depth?state.doc.resolve(dir>0?$side.after():$side.before()):null:$side;return $start&&Selection.findFrom($start,dir)}function apply(view,sel){return view.dispatch(view.state.tr.setSelection(sel).scrollIntoView()),!0}function selectHorizontally(view,dir,mods){let sel=view.state.selection;if(!(sel instanceof TextSelection)){if(sel instanceof NodeSelection&&sel.node.isInline)return apply(view,new TextSelection(dir>0?sel.$to:sel.$from));{let next=moveSelectionBlock(view.state,dir);return!!next&&apply(view,next)}}if(!sel.empty||mods.indexOf("s")>-1)return!1;if(view.endOfTextblock(dir>0?"right":"left")){let next=moveSelectionBlock(view.state,dir);return!!(next&&next instanceof NodeSelection)&&apply(view,next)}if(!(mac$2&&mods.indexOf("m")>-1)){let desc,$head=sel.$head,node=$head.textOffset?null:dir<0?$head.nodeBefore:$head.nodeAfter;if(!node||node.isText)return!1;let nodePos=dir<0?$head.pos-node.nodeSize:$head.pos;return!!(node.isAtom||(desc=view.docView.descAt(nodePos))&&!desc.contentDOM)&&(NodeSelection.isSelectable(node)?apply(view,new NodeSelection(dir<0?view.state.doc.resolve($head.pos-node.nodeSize):$head)):!!webkit&&apply(view,new TextSelection(view.state.doc.resolve(dir<0?nodePos:nodePos+node.nodeSize))))}}function nodeLen(node){return 3==node.nodeType?node.nodeValue.length:node.childNodes.length}function isIgnorable(dom){let desc=dom.pmViewDesc;return desc&&0==desc.size&&(dom.nextSibling||"BR"!=dom.nodeName)}
// Make sure the cursor isn't directly after one or more ignored
// nodes, which will confuse the browser's cursor motion logic.
function skipIgnoredNodesLeft(view){let sel=view.domSelectionRange(),node=sel.focusNode,offset=sel.focusOffset;if(!node)return;let moveNode,moveOffset,force=!1;
// Gecko will do odd things when the selection is directly in front
// of a non-editable node, so in that case, move it into the next
// node if possible. Issue prosemirror/prosemirror#832.
for(gecko&&1==node.nodeType&&offset<nodeLen(node)&&isIgnorable(node.childNodes[offset])&&(force=!0);;)if(offset>0){if(1!=node.nodeType)break;{let before=node.childNodes[offset-1];if(isIgnorable(before))moveNode=node,moveOffset=--offset;else{if(3!=before.nodeType)break;node=before,offset=node.nodeValue.length}}}else{if(isBlockNode(node))break;{let prev=node.previousSibling;while(prev&&isIgnorable(prev))moveNode=node.parentNode,moveOffset=domIndex(prev),prev=prev.previousSibling;if(prev)node=prev,offset=nodeLen(node);else{if(node=node.parentNode,node==view.dom)break;offset=0}}}force?setSelFocus(view,node,offset):moveNode&&setSelFocus(view,moveNode,moveOffset)}
// Make sure the cursor isn't directly before one or more ignored
// nodes.
function skipIgnoredNodesRight(view){let sel=view.domSelectionRange(),node=sel.focusNode,offset=sel.focusOffset;if(!node)return;let moveNode,moveOffset,len=nodeLen(node);for(;;)if(offset<len){if(1!=node.nodeType)break;let after=node.childNodes[offset];if(!isIgnorable(after))break;moveNode=node,moveOffset=++offset}else{if(isBlockNode(node))break;{let next=node.nextSibling;while(next&&isIgnorable(next))moveNode=next.parentNode,moveOffset=domIndex(next)+1,next=next.nextSibling;if(next)node=next,offset=0,len=nodeLen(node);else{if(node=node.parentNode,node==view.dom)break;offset=len=0}}}moveNode&&setSelFocus(view,moveNode,moveOffset)}function isBlockNode(dom){let desc=dom.pmViewDesc;return desc&&desc.node&&desc.node.isBlock}function setSelFocus(view,node,offset){let sel=view.domSelection();if(selectionCollapsed(sel)){let range=document.createRange();range.setEnd(node,offset),range.setStart(node,offset),sel.removeAllRanges(),sel.addRange(range)}else sel.extend&&sel.extend(node,offset);view.domObserver.setCurSelection();let{state:state}=view;
// If no state update ends up happening, reset the selection.
setTimeout((()=>{view.state==state&&selectionToDOM(view)}),50)}
// Check whether vertical selection motion would involve node
// selections. If so, apply it (if not, the result is left to the
// browser)
function selectVertically(view,dir,mods){let sel=view.state.selection;if(sel instanceof TextSelection&&!sel.empty||mods.indexOf("s")>-1)return!1;if(mac$2&&mods.indexOf("m")>-1)return!1;let{$from:$from,$to:$to}=sel;if(!$from.parent.inlineContent||view.endOfTextblock(dir<0?"up":"down")){let next=moveSelectionBlock(view.state,dir);if(next&&next instanceof NodeSelection)return apply(view,next)}if(!$from.parent.inlineContent){let side=dir<0?$from:$to,beyond=sel instanceof AllSelection?Selection.near(side,dir):Selection.findFrom(side,dir);return!!beyond&&apply(view,beyond)}return!1}function stopNativeHorizontalDelete(view,dir){if(!(view.state.selection instanceof TextSelection))return!0;let{$head:$head,$anchor:$anchor,empty:empty}=view.state.selection;if(!$head.sameParent($anchor))return!0;if(!empty)return!1;if(view.endOfTextblock(dir>0?"forward":"backward"))return!0;let nextNode=!$head.textOffset&&(dir<0?$head.nodeBefore:$head.nodeAfter);if(nextNode&&!nextNode.isText){let tr=view.state.tr;return dir<0?tr.delete($head.pos-nextNode.nodeSize,$head.pos):tr.delete($head.pos,$head.pos+nextNode.nodeSize),view.dispatch(tr),!0}return!1}function switchEditable(view,node,state){view.domObserver.stop(),node.contentEditable=state,view.domObserver.start()}
// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821
// In which Safari (and at some point in the past, Chrome) does really
// wrong things when the down arrow is pressed when the cursor is
// directly at the start of a textblock and has an uneditable node
// after it
function safariDownArrowBug(view){if(!safari||view.state.selection.$head.parentOffset>0)return!1;let{focusNode:focusNode,focusOffset:focusOffset}=view.domSelectionRange();if(focusNode&&1==focusNode.nodeType&&0==focusOffset&&focusNode.firstChild&&"false"==focusNode.firstChild.contentEditable){let child=focusNode.firstChild;switchEditable(view,child,"true"),setTimeout((()=>switchEditable(view,child,"false")),20)}return!1}
// A backdrop key mapping used to make sure we always suppress keys
// that have a dangerous default effect, even if the commands they are
// bound to return false, and to make sure that cursor-motion keys
// find a cursor (as opposed to a node selection) when pressed. For
// cursor-motion keys, the code in the handlers also takes care of
// block selections.
function getMods(event){let result="";return event.ctrlKey&&(result+="c"),event.metaKey&&(result+="m"),event.altKey&&(result+="a"),event.shiftKey&&(result+="s"),result}function captureKeyDown(view,event){let code=event.keyCode,mods=getMods(event);return 8==code||mac$2&&72==code&&"c"==mods?stopNativeHorizontalDelete(view,-1)||skipIgnoredNodesLeft(view):46==code||mac$2&&68==code&&"c"==mods?stopNativeHorizontalDelete(view,1)||skipIgnoredNodesRight(view):13==code||27==code||(37==code||mac$2&&66==code&&"c"==mods?selectHorizontally(view,-1,mods)||skipIgnoredNodesLeft(view):39==code||mac$2&&70==code&&"c"==mods?selectHorizontally(view,1,mods)||skipIgnoredNodesRight(view):38==code||mac$2&&80==code&&"c"==mods?selectVertically(view,-1,mods)||skipIgnoredNodesLeft(view):40==code||mac$2&&78==code&&"c"==mods?safariDownArrowBug(view)||selectVertically(view,1,mods)||skipIgnoredNodesRight(view):mods==(mac$2?"m":"c")&&(66==code||73==code||89==code||90==code))}function serializeForClipboard(view,slice){view.someProp("transformCopied",(f=>{slice=f(slice,view)}));let context=[],{content:content,openStart:openStart,openEnd:openEnd}=slice;while(openStart>1&&openEnd>1&&1==content.childCount&&1==content.firstChild.childCount){openStart--,openEnd--;let node=content.firstChild;context.push(node.type.name,node.attrs!=node.type.defaultAttrs?node.attrs:null),content=node.content}let serializer=view.someProp("clipboardSerializer")||DOMSerializer.fromSchema(view.state.schema),doc=detachedDoc(),wrap=doc.createElement("div");wrap.appendChild(serializer.serializeFragment(content,{document:doc}));let needsWrap,firstChild=wrap.firstChild,wrappers=0;while(firstChild&&1==firstChild.nodeType&&(needsWrap=wrapMap[firstChild.nodeName.toLowerCase()])){for(let i=needsWrap.length-1;i>=0;i--){let wrapper=doc.createElement(needsWrap[i]);while(wrap.firstChild)wrapper.appendChild(wrap.firstChild);wrap.appendChild(wrapper),wrappers++}firstChild=wrap.firstChild}firstChild&&1==firstChild.nodeType&&firstChild.setAttribute("data-pm-slice",`${openStart} ${openEnd}${wrappers?` -${wrappers}`:""} ${JSON.stringify(context)}`);let text=view.someProp("clipboardTextSerializer",(f=>f(slice,view)))||slice.content.textBetween(0,slice.content.size,"\n\n");return{dom:wrap,text:text}}
// Read a slice of content from the clipboard (or drop data).
function parseFromClipboard(view,text,html,plainText,$context){let dom,slice,inCode=$context.parent.type.spec.code;if(!html&&!text)return null;let asText=text&&(plainText||inCode||!html);if(asText){if(view.someProp("transformPastedText",(f=>{text=f(text,inCode||plainText,view)})),inCode)return text?new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g,"\n"))),0,0):Slice.empty;let parsed=view.someProp("clipboardTextParser",(f=>f(text,$context,plainText,view)));if(parsed)slice=parsed;else{let marks=$context.marks(),{schema:schema}=view.state,serializer=DOMSerializer.fromSchema(schema);dom=document.createElement("div"),text.split(/(?:\r\n?|\n)+/).forEach((block=>{let p=dom.appendChild(document.createElement("p"));block&&p.appendChild(serializer.serializeNode(schema.text(block,marks)))}))}}else view.someProp("transformPastedHTML",(f=>{html=f(html,view)})),dom=readHTML(html),webkit&&restoreReplacedSpaces(dom);let contextNode=dom&&dom.querySelector("[data-pm-slice]"),sliceData=contextNode&&/^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice")||"");if(sliceData&&sliceData[3])for(let i=+sliceData[3];i>0;i--){let child=dom.firstChild;while(child&&1!=child.nodeType)child=child.nextSibling;if(!child)break;dom=child}if(!slice){let parser=view.someProp("clipboardParser")||view.someProp("domParser")||DOMParser$1.fromSchema(view.state.schema);slice=parser.parseSlice(dom,{preserveWhitespace:!(!asText&&!sliceData),context:$context,ruleFromNode(dom){return"BR"!=dom.nodeName||dom.nextSibling||!dom.parentNode||inlineParents.test(dom.parentNode.nodeName)?null:{ignore:!0}}})}if(sliceData)slice=addContext(closeSlice(slice,+sliceData[1],+sliceData[2]),sliceData[4]);else if(// HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent
slice=Slice.maxOpen(normalizeSiblings(slice.content,$context),!0),slice.openStart||slice.openEnd){let openStart=0,openEnd=0;for(let node=slice.content.firstChild;openStart<slice.openStart&&!node.type.spec.isolating;openStart++,node=node.firstChild);for(let node=slice.content.lastChild;openEnd<slice.openEnd&&!node.type.spec.isolating;openEnd++,node=node.lastChild);slice=closeSlice(slice,openStart,openEnd)}return view.someProp("transformPasted",(f=>{slice=f(slice,view)})),slice}const inlineParents=/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
// Takes a slice parsed with parseSlice, which means there hasn't been
// any content-expression checking done on the top nodes, tries to
// find a parent node in the current context that might fit the nodes,
// and if successful, rebuilds the slice so that it fits into that parent.

// This addresses the problem that Transform.replace expects a
// coherent slice, and will fail to place a set of siblings that don't
// fit anywhere in the schema.
function normalizeSiblings(fragment,$context){if(fragment.childCount<2)return fragment;for(let d=$context.depth;d>=0;d--){let lastWrap,parent=$context.node(d),match=parent.contentMatchAt($context.index(d)),result=[];if(fragment.forEach((node=>{if(!result)return;let inLast,wrap=match.findWrapping(node.type);if(!wrap)return result=null;if(inLast=result.length&&lastWrap.length&&addToSibling(wrap,lastWrap,node,result[result.length-1],0))result[result.length-1]=inLast;else{result.length&&(result[result.length-1]=closeRight(result[result.length-1],lastWrap.length));let wrapped=withWrappers(node,wrap);result.push(wrapped),match=match.matchType(wrapped.type),lastWrap=wrap}})),result)return Fragment.from(result)}return fragment}function withWrappers(node,wrap,from=0){for(let i=wrap.length-1;i>=from;i--)node=wrap[i].create(null,Fragment.from(node));return node}
// Used to group adjacent nodes wrapped in similar parents by
// normalizeSiblings into the same parent node
function addToSibling(wrap,lastWrap,node,sibling,depth){if(depth<wrap.length&&depth<lastWrap.length&&wrap[depth]==lastWrap[depth]){let inner=addToSibling(wrap,lastWrap,node,sibling.lastChild,depth+1);if(inner)return sibling.copy(sibling.content.replaceChild(sibling.childCount-1,inner));let match=sibling.contentMatchAt(sibling.childCount);if(match.matchType(depth==wrap.length-1?node.type:wrap[depth+1]))return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node,wrap,depth+1))))}}function closeRight(node,depth){if(0==depth)return node;let fragment=node.content.replaceChild(node.childCount-1,closeRight(node.lastChild,depth-1)),fill=node.contentMatchAt(node.childCount).fillBefore(Fragment.empty,!0);return node.copy(fragment.append(fill))}function closeRange(fragment,side,from,to,depth,openEnd){let node=side<0?fragment.firstChild:fragment.lastChild,inner=node.content;return depth<to-1&&(inner=closeRange(inner,side,from,to,depth+1,openEnd)),depth>=from&&(inner=side<0?node.contentMatchAt(0).fillBefore(inner,fragment.childCount>1||openEnd<=depth).append(inner):inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty,!0))),fragment.replaceChild(side<0?0:fragment.childCount-1,node.copy(inner))}function closeSlice(slice,openStart,openEnd){return openStart<slice.openStart&&(slice=new Slice(closeRange(slice.content,-1,openStart,slice.openStart,0,slice.openEnd),openStart,slice.openEnd)),openEnd<slice.openEnd&&(slice=new Slice(closeRange(slice.content,1,openEnd,slice.openEnd,0,0),slice.openStart,openEnd)),slice}
// Trick from jQuery -- some elements must be wrapped in other
// elements for innerHTML to work. I.e. if you do `div.innerHTML =
// "<td>..</td>"` the table cells are ignored.
const wrapMap={thead:["table"],tbody:["table"],tfoot:["table"],caption:["table"],colgroup:["table"],col:["table","colgroup"],tr:["table","tbody"],td:["table","tbody","tr"],th:["table","tbody","tr"]};let _detachedDoc=null;function detachedDoc(){return _detachedDoc||(_detachedDoc=document.implementation.createHTMLDocument("title"))}function readHTML(html){let metas=/^(\s*<meta [^>]*>)*/.exec(html);metas&&(html=html.slice(metas[0].length));let wrap,elt=detachedDoc().createElement("div"),firstTag=/<([a-z][^>\s]+)/i.exec(html);if((wrap=firstTag&&wrapMap[firstTag[1].toLowerCase()])&&(html=wrap.map((n=>"<"+n+">")).join("")+html+wrap.map((n=>"</"+n+">")).reverse().join("")),elt.innerHTML=html,wrap)for(let i=0;i<wrap.length;i++)elt=elt.querySelector(wrap[i])||elt;return elt}
// Webkit browsers do some hard-to-predict replacement of regular
// spaces with non-breaking spaces when putting content on the
// clipboard. This tries to convert such non-breaking spaces (which
// will be wrapped in a plain span on Chrome, a span with class
// Apple-converted-space on Safari) back to regular spaces.
function restoreReplacedSpaces(dom){let nodes=dom.querySelectorAll(chrome$1?"span:not([class]):not([style])":"span.Apple-converted-space");for(let i=0;i<nodes.length;i++){let node=nodes[i];1==node.childNodes.length&&" "==node.textContent&&node.parentNode&&node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "),node)}}function addContext(slice,context){if(!slice.size)return slice;let array,schema=slice.content.firstChild.type.schema;try{array=JSON.parse(context)}catch(e){return slice}let{content:content,openStart:openStart,openEnd:openEnd}=slice;for(let i=array.length-2;i>=0;i-=2){let type=schema.nodes[array[i]];if(!type||type.hasRequiredAttrs())break;content=Fragment.from(type.create(array[i+1],content)),openStart++,openEnd++}return new Slice(content,openStart,openEnd)}
// A collection of DOM events that occur within the editor, and callback functions
// to invoke when the event fires.
const handlers={},editHandlers={},passiveHandlers={touchstart:!0,touchmove:!0};class InputState{constructor(){this.shiftKey=!1,this.mouseDown=null,this.lastKeyCode=null,this.lastKeyCodeTime=0,this.lastClick={time:0,x:0,y:0,type:""},this.lastSelectionOrigin=null,this.lastSelectionTime=0,this.lastIOSEnter=0,this.lastIOSEnterFallbackTimeout=-1,this.lastFocus=0,this.lastTouch=0,this.lastAndroidDelete=0,this.composing=!1,this.composingTimeout=-1,this.compositionNodes=[],this.compositionEndedAt=-2e8,this.domChangeCount=0,this.eventHandlers=Object.create(null),this.hideSelectionGuard=null}}function initInput(view){for(let event in handlers){let handler=handlers[event];view.dom.addEventListener(event,view.input.eventHandlers[event]=event=>{!eventBelongsToView(view,event)||runCustomHandler(view,event)||!view.editable&&event.type in editHandlers||handler(view,event)},passiveHandlers[event]?{passive:!0}:void 0)}
// On Safari, for reasons beyond my understanding, adding an input
// event handler makes an issue where the composition vanishes when
// you press enter go away.
safari&&view.dom.addEventListener("input",(()=>null)),ensureListeners(view)}function setSelectionOrigin(view,origin){view.input.lastSelectionOrigin=origin,view.input.lastSelectionTime=Date.now()}function destroyInput(view){view.domObserver.stop();for(let type in view.input.eventHandlers)view.dom.removeEventListener(type,view.input.eventHandlers[type]);clearTimeout(view.input.composingTimeout),clearTimeout(view.input.lastIOSEnterFallbackTimeout)}function ensureListeners(view){view.someProp("handleDOMEvents",(currentHandlers=>{for(let type in currentHandlers)view.input.eventHandlers[type]||view.dom.addEventListener(type,view.input.eventHandlers[type]=event=>runCustomHandler(view,event))}))}function runCustomHandler(view,event){return view.someProp("handleDOMEvents",(handlers=>{let handler=handlers[event.type];return!!handler&&(handler(view,event)||event.defaultPrevented)}))}function eventBelongsToView(view,event){if(!event.bubbles)return!0;if(event.defaultPrevented)return!1;for(let node=event.target;node!=view.dom;node=node.parentNode)if(!node||11==node.nodeType||node.pmViewDesc&&node.pmViewDesc.stopEvent(event))return!1;return!0}function dispatchEvent(view,event){runCustomHandler(view,event)||!handlers[event.type]||!view.editable&&event.type in editHandlers||handlers[event.type](view,event)}function eventCoords(event){return{left:event.clientX,top:event.clientY}}function isNear(event,click){let dx=click.x-event.clientX,dy=click.y-event.clientY;return dx*dx+dy*dy<100}function runHandlerOnContext(view,propName,pos,inside,event){if(-1==inside)return!1;let $pos=view.state.doc.resolve(inside);for(let i=$pos.depth+1;i>0;i--)if(view.someProp(propName,(f=>i>$pos.depth?f(view,pos,$pos.nodeAfter,$pos.before(i),event,!0):f(view,pos,$pos.node(i),$pos.before(i),event,!1))))return!0;return!1}function updateSelection(view,selection,origin){view.focused||view.focus();let tr=view.state.tr.setSelection(selection);"pointer"==origin&&tr.setMeta("pointer",!0),view.dispatch(tr)}function selectClickedLeaf(view,inside){if(-1==inside)return!1;let $pos=view.state.doc.resolve(inside),node=$pos.nodeAfter;return!!(node&&node.isAtom&&NodeSelection.isSelectable(node))&&(updateSelection(view,new NodeSelection($pos),"pointer"),!0)}function selectClickedNode(view,inside){if(-1==inside)return!1;let selectedNode,selectAt,sel=view.state.selection;sel instanceof NodeSelection&&(selectedNode=sel.node);let $pos=view.state.doc.resolve(inside);for(let i=$pos.depth+1;i>0;i--){let node=i>$pos.depth?$pos.nodeAfter:$pos.node(i);if(NodeSelection.isSelectable(node)){selectAt=selectedNode&&sel.$from.depth>0&&i>=sel.$from.depth&&$pos.before(sel.$from.depth+1)==sel.$from.pos?$pos.before(sel.$from.depth):$pos.before(i);break}}return null!=selectAt&&(updateSelection(view,NodeSelection.create(view.state.doc,selectAt),"pointer"),!0)}function handleSingleClick(view,pos,inside,event,selectNode){return runHandlerOnContext(view,"handleClickOn",pos,inside,event)||view.someProp("handleClick",(f=>f(view,pos,event)))||(selectNode?selectClickedNode(view,inside):selectClickedLeaf(view,inside))}function handleDoubleClick(view,pos,inside,event){return runHandlerOnContext(view,"handleDoubleClickOn",pos,inside,event)||view.someProp("handleDoubleClick",(f=>f(view,pos,event)))}function handleTripleClick$1(view,pos,inside,event){return runHandlerOnContext(view,"handleTripleClickOn",pos,inside,event)||view.someProp("handleTripleClick",(f=>f(view,pos,event)))||defaultTripleClick(view,inside,event)}function defaultTripleClick(view,inside,event){if(0!=event.button)return!1;let doc=view.state.doc;if(-1==inside)return!!doc.inlineContent&&(updateSelection(view,TextSelection.create(doc,0,doc.content.size),"pointer"),!0);let $pos=doc.resolve(inside);for(let i=$pos.depth+1;i>0;i--){let node=i>$pos.depth?$pos.nodeAfter:$pos.node(i),nodePos=$pos.before(i);if(node.inlineContent)updateSelection(view,TextSelection.create(doc,nodePos+1,nodePos+1+node.content.size),"pointer");else{if(!NodeSelection.isSelectable(node))continue;updateSelection(view,NodeSelection.create(doc,nodePos),"pointer")}return!0}}function forceDOMFlush(view){return endComposition(view)}editHandlers.keydown=(view,_event)=>{let event=_event;if(view.input.shiftKey=16==event.keyCode||event.shiftKey,!inOrNearComposition(view,event)&&(view.input.lastKeyCode=event.keyCode,view.input.lastKeyCodeTime=Date.now(),!android||!chrome$1||13!=event.keyCode))
// On iOS, if we preventDefault enter key presses, the virtual
// keyboard gets confused. So the hack here is to set a flag that
// makes the DOM change code recognize that what just happens should
// be replaced by whatever the Enter key handlers do.
if(229!=event.keyCode&&view.domObserver.forceFlush(),!ios||13!=event.keyCode||event.ctrlKey||event.altKey||event.metaKey)view.someProp("handleKeyDown",(f=>f(view,event)))||captureKeyDown(view,event)?event.preventDefault():setSelectionOrigin(view,"key");else{let now=Date.now();view.input.lastIOSEnter=now,view.input.lastIOSEnterFallbackTimeout=setTimeout((()=>{view.input.lastIOSEnter==now&&(view.someProp("handleKeyDown",(f=>f(view,keyEvent(13,"Enter")))),view.input.lastIOSEnter=0)}),200)}},editHandlers.keyup=(view,event)=>{16==event.keyCode&&(view.input.shiftKey=!1)},editHandlers.keypress=(view,_event)=>{let event=_event;if(inOrNearComposition(view,event)||!event.charCode||event.ctrlKey&&!event.altKey||mac$2&&event.metaKey)return;if(view.someProp("handleKeyPress",(f=>f(view,event))))return void event.preventDefault();let sel=view.state.selection;if(!(sel instanceof TextSelection)||!sel.$from.sameParent(sel.$to)){let text=String.fromCharCode(event.charCode);/[\r\n]/.test(text)||view.someProp("handleTextInput",(f=>f(view,sel.$from.pos,sel.$to.pos,text)))||view.dispatch(view.state.tr.insertText(text).scrollIntoView()),event.preventDefault()}};const selectNodeModifier=mac$2?"metaKey":"ctrlKey";handlers.mousedown=(view,_event)=>{let event=_event;view.input.shiftKey=event.shiftKey;let flushed=forceDOMFlush(view),now=Date.now(),type="singleClick";now-view.input.lastClick.time<500&&isNear(event,view.input.lastClick)&&!event[selectNodeModifier]&&("singleClick"==view.input.lastClick.type?type="doubleClick":"doubleClick"==view.input.lastClick.type&&(type="tripleClick")),view.input.lastClick={time:now,x:event.clientX,y:event.clientY,type:type};let pos=view.posAtCoords(eventCoords(event));pos&&("singleClick"==type?(view.input.mouseDown&&view.input.mouseDown.done(),view.input.mouseDown=new MouseDown(view,pos,event,!!flushed)):("doubleClick"==type?handleDoubleClick:handleTripleClick$1)(view,pos.pos,pos.inside,event)?event.preventDefault():setSelectionOrigin(view,"pointer"))};class MouseDown{constructor(view,pos,event,flushed){let targetNode,targetPos;if(this.view=view,this.pos=pos,this.event=event,this.flushed=flushed,this.delayedSelectionSync=!1,this.mightDrag=null,this.startDoc=view.state.doc,this.selectNode=!!event[selectNodeModifier],this.allowDefault=event.shiftKey,pos.inside>-1)targetNode=view.state.doc.nodeAt(pos.inside),targetPos=pos.inside;else{let $pos=view.state.doc.resolve(pos.pos);targetNode=$pos.parent,targetPos=$pos.depth?$pos.before():0}const target=flushed?null:event.target,targetDesc=target?view.docView.nearestDesc(target,!0):null;this.target=targetDesc?targetDesc.dom:null;let{selection:selection}=view.state;(0==event.button&&targetNode.type.spec.draggable&&!1!==targetNode.type.spec.selectable||selection instanceof NodeSelection&&selection.from<=targetPos&&selection.to>targetPos)&&(this.mightDrag={node:targetNode,pos:targetPos,addAttr:!(!this.target||this.target.draggable),setUneditable:!(!this.target||!gecko||this.target.hasAttribute("contentEditable"))}),this.target&&this.mightDrag&&(this.mightDrag.addAttr||this.mightDrag.setUneditable)&&(this.view.domObserver.stop(),this.mightDrag.addAttr&&(this.target.draggable=!0),this.mightDrag.setUneditable&&setTimeout((()=>{this.view.input.mouseDown==this&&this.target.setAttribute("contentEditable","false")}),20),this.view.domObserver.start()),view.root.addEventListener("mouseup",this.up=this.up.bind(this)),view.root.addEventListener("mousemove",this.move=this.move.bind(this)),setSelectionOrigin(view,"pointer")}done(){this.view.root.removeEventListener("mouseup",this.up),this.view.root.removeEventListener("mousemove",this.move),this.mightDrag&&this.target&&(this.view.domObserver.stop(),this.mightDrag.addAttr&&this.target.removeAttribute("draggable"),this.mightDrag.setUneditable&&this.target.removeAttribute("contentEditable"),this.view.domObserver.start()),this.delayedSelectionSync&&setTimeout((()=>selectionToDOM(this.view))),this.view.input.mouseDown=null}up(event){if(this.done(),!this.view.dom.contains(event.target))return;let pos=this.pos;this.view.state.doc!=this.startDoc&&(pos=this.view.posAtCoords(eventCoords(event))),this.updateAllowDefault(event),this.allowDefault||!pos?setSelectionOrigin(this.view,"pointer"):handleSingleClick(this.view,pos.pos,pos.inside,event,this.selectNode)?event.preventDefault():0==event.button&&(this.flushed||
// Safari ignores clicks on draggable elements
safari&&this.mightDrag&&!this.mightDrag.node.isAtom||
// Chrome will sometimes treat a node selection as a
// cursor, but still report that the node is selected
// when asked through getSelection. You'll then get a
// situation where clicking at the point where that
// (hidden) cursor is doesn't change the selection, and
// thus doesn't get a reaction from ProseMirror. This
// works around that.
chrome$1&&!this.view.state.selection.visible&&Math.min(Math.abs(pos.pos-this.view.state.selection.from),Math.abs(pos.pos-this.view.state.selection.to))<=2)?(updateSelection(this.view,Selection.near(this.view.state.doc.resolve(pos.pos)),"pointer"),event.preventDefault()):setSelectionOrigin(this.view,"pointer")}move(event){this.updateAllowDefault(event),setSelectionOrigin(this.view,"pointer"),0==event.buttons&&this.done()}updateAllowDefault(event){!this.allowDefault&&(Math.abs(this.event.x-event.clientX)>4||Math.abs(this.event.y-event.clientY)>4)&&(this.allowDefault=!0)}}function inOrNearComposition(view,event){return!!view.composing||
// See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
// On Japanese input method editors (IMEs), the Enter key is used to confirm character
// selection. On Safari, when Enter is pressed, compositionend and keydown events are
// emitted. The keydown event triggers newline insertion, which we don't want.
// This method returns true if the keydown event should be ignored.
// We only ignore it once, as pressing Enter a second time *should* insert a newline.
// Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.
// This guards against the case where compositionend is triggered without the keyboard
// (e.g. character confirmation may be done with the mouse), and keydown is triggered
// afterwards- we wouldn't want to ignore the keydown event in this case.
!!(safari&&Math.abs(event.timeStamp-view.input.compositionEndedAt)<500)&&(view.input.compositionEndedAt=-2e8,!0)}
// Drop active composition after 5 seconds of inactivity on Android
handlers.touchstart=view=>{view.input.lastTouch=Date.now(),forceDOMFlush(view),setSelectionOrigin(view,"pointer")},handlers.touchmove=view=>{view.input.lastTouch=Date.now(),setSelectionOrigin(view,"pointer")},handlers.contextmenu=view=>forceDOMFlush(view);const timeoutComposition=android?5e3:-1;function scheduleComposeEnd(view,delay){clearTimeout(view.input.composingTimeout),delay>-1&&(view.input.composingTimeout=setTimeout((()=>endComposition(view)),delay))}function clearComposition(view){view.composing&&(view.input.composing=!1,view.input.compositionEndedAt=timestampFromCustomEvent());while(view.input.compositionNodes.length>0)view.input.compositionNodes.pop().markParentsDirty()}function timestampFromCustomEvent(){let event=document.createEvent("Event");return event.initEvent("event",!0,!0),event.timeStamp}
/**
@internal
*/function endComposition(view,forceUpdate=!1){if(!(android&&view.domObserver.flushingSoon>=0)){if(view.domObserver.forceFlush(),clearComposition(view),forceUpdate||view.docView&&view.docView.dirty){let sel=selectionFromDOM(view);return sel&&!sel.eq(view.state.selection)?view.dispatch(view.state.tr.setSelection(sel)):view.updateState(view.state),!0}return!1}}function captureCopy(view,dom){
// The extra wrapper is somehow necessary on IE/Edge to prevent the
// content from being mangled when it is put onto the clipboard
if(!view.dom.parentNode)return;let wrap=view.dom.parentNode.appendChild(document.createElement("div"));wrap.appendChild(dom),wrap.style.cssText="position: fixed; left: -10000px; top: 10px";let sel=getSelection(),range=document.createRange();range.selectNodeContents(dom),
// Done because IE will fire a selectionchange moving the selection
// to its start when removeAllRanges is called and the editor still
// has focus (which will mess up the editor's selection state).
view.dom.blur(),sel.removeAllRanges(),sel.addRange(range),setTimeout((()=>{wrap.parentNode&&wrap.parentNode.removeChild(wrap),view.focus()}),50)}
// This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard API—all the objects and methods are
// there, they just don't work, and they are hard to test.
editHandlers.compositionstart=editHandlers.compositionupdate=view=>{if(!view.composing){view.domObserver.flush();let{state:state}=view,$pos=state.selection.$from;if(state.selection.empty&&(state.storedMarks||!$pos.textOffset&&$pos.parentOffset&&$pos.nodeBefore.marks.some((m=>!1===m.type.spec.inclusive))))
// Need to wrap the cursor in mark nodes different from the ones in the DOM context
view.markCursor=view.state.storedMarks||$pos.marks(),endComposition(view,!0),view.markCursor=null;else
// In firefox, if the cursor is after but outside a marked node,
// the inserted text won't inherit the marks. So this moves it
// inside if necessary.
if(endComposition(view),gecko&&state.selection.empty&&$pos.parentOffset&&!$pos.textOffset&&$pos.nodeBefore.marks.length){let sel=view.domSelectionRange();for(let node=sel.focusNode,offset=sel.focusOffset;node&&1==node.nodeType&&0!=offset;){let before=offset<0?node.lastChild:node.childNodes[offset-1];if(!before)break;if(3==before.nodeType){view.domSelection().collapse(before,before.nodeValue.length);break}node=before,offset=-1}}view.input.composing=!0}scheduleComposeEnd(view,timeoutComposition)},editHandlers.compositionend=(view,event)=>{view.composing&&(view.input.composing=!1,view.input.compositionEndedAt=event.timeStamp,scheduleComposeEnd(view,20))};const brokenClipboardAPI=ie$1&&ie_version<15||ios&&webkit_version<604;function sliceSingleNode(slice){return 0==slice.openStart&&0==slice.openEnd&&1==slice.content.childCount?slice.content.firstChild:null}function capturePaste(view,event){if(!view.dom.parentNode)return;let plainText=view.input.shiftKey||view.state.selection.$from.parent.type.spec.code,target=view.dom.parentNode.appendChild(document.createElement(plainText?"textarea":"div"));plainText||(target.contentEditable="true"),target.style.cssText="position: fixed; left: -10000px; top: 10px",target.focus(),setTimeout((()=>{view.focus(),target.parentNode&&target.parentNode.removeChild(target),plainText?doPaste(view,target.value,null,view.input.shiftKey,event):doPaste(view,target.textContent,target.innerHTML,view.input.shiftKey,event)}),50)}function doPaste(view,text,html,preferPlain,event){let slice=parseFromClipboard(view,text,html,preferPlain,view.state.selection.$from);if(view.someProp("handlePaste",(f=>f(view,event,slice||Slice.empty))))return!0;if(!slice)return!1;let singleNode=sliceSingleNode(slice),tr=singleNode?view.state.tr.replaceSelectionWith(singleNode,view.input.shiftKey):view.state.tr.replaceSelection(slice);return view.dispatch(tr.scrollIntoView().setMeta("paste",!0).setMeta("uiEvent","paste")),!0}handlers.copy=editHandlers.cut=(view,_event)=>{let event=_event,sel=view.state.selection,cut="cut"==event.type;if(sel.empty)return;
// IE and Edge's clipboard interface is completely broken
let data=brokenClipboardAPI?null:event.clipboardData,slice=sel.content(),{dom:dom,text:text}=serializeForClipboard(view,slice);data?(event.preventDefault(),data.clearData(),data.setData("text/html",dom.innerHTML),data.setData("text/plain",text)):captureCopy(view,dom),cut&&view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent","cut"))},editHandlers.paste=(view,_event)=>{let event=_event;
// Handling paste from JavaScript during composition is very poorly
// handled by browsers, so as a dodgy but preferable kludge, we just
// let the browser do its native thing there, except on Android,
// where the editor is almost always composing.
if(view.composing&&!android)return;let data=brokenClipboardAPI?null:event.clipboardData;data&&doPaste(view,data.getData("text/plain"),data.getData("text/html"),view.input.shiftKey,event)?event.preventDefault():capturePaste(view,event)};class Dragging{constructor(slice,move){this.slice=slice,this.move=move}}const dragCopyModifier=mac$2?"altKey":"ctrlKey";handlers.dragstart=(view,_event)=>{let event=_event,mouseDown=view.input.mouseDown;if(mouseDown&&mouseDown.done(),!event.dataTransfer)return;let sel=view.state.selection,pos=sel.empty?null:view.posAtCoords(eventCoords(event));if(pos&&pos.pos>=sel.from&&pos.pos<=(sel instanceof NodeSelection?sel.to-1:sel.to));else if(mouseDown&&mouseDown.mightDrag)view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc,mouseDown.mightDrag.pos)));else if(event.target&&1==event.target.nodeType){let desc=view.docView.nearestDesc(event.target,!0);desc&&desc.node.type.spec.draggable&&desc!=view.docView&&view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc,desc.posBefore)))}let slice=view.state.selection.content(),{dom:dom,text:text}=serializeForClipboard(view,slice);event.dataTransfer.clearData(),event.dataTransfer.setData(brokenClipboardAPI?"Text":"text/html",dom.innerHTML),
// See https://github.com/ProseMirror/prosemirror/issues/1156
event.dataTransfer.effectAllowed="copyMove",brokenClipboardAPI||event.dataTransfer.setData("text/plain",text),view.dragging=new Dragging(slice,!event[dragCopyModifier])},handlers.dragend=view=>{let dragging=view.dragging;window.setTimeout((()=>{view.dragging==dragging&&(view.dragging=null)}),50)},editHandlers.dragover=editHandlers.dragenter=(_,e)=>e.preventDefault(),editHandlers.drop=(view,_event)=>{let event=_event,dragging=view.dragging;if(view.dragging=null,!event.dataTransfer)return;let eventPos=view.posAtCoords(eventCoords(event));if(!eventPos)return;let $mouse=view.state.doc.resolve(eventPos.pos),slice=dragging&&dragging.slice;slice?view.someProp("transformPasted",(f=>{slice=f(slice,view)})):slice=parseFromClipboard(view,event.dataTransfer.getData(brokenClipboardAPI?"Text":"text/plain"),brokenClipboardAPI?null:event.dataTransfer.getData("text/html"),!1,$mouse);let move=!(!dragging||event[dragCopyModifier]);if(view.someProp("handleDrop",(f=>f(view,event,slice||Slice.empty,move))))return void event.preventDefault();if(!slice)return;event.preventDefault();let insertPos=slice?dropPoint(view.state.doc,$mouse.pos,slice):$mouse.pos;null==insertPos&&(insertPos=$mouse.pos);let tr=view.state.tr;move&&tr.deleteSelection();let pos=tr.mapping.map(insertPos),isNode=0==slice.openStart&&0==slice.openEnd&&1==slice.content.childCount,beforeInsert=tr.doc;if(isNode?tr.replaceRangeWith(pos,pos,slice.content.firstChild):tr.replaceRange(pos,pos,slice),tr.doc.eq(beforeInsert))return;let $pos=tr.doc.resolve(pos);if(isNode&&NodeSelection.isSelectable(slice.content.firstChild)&&$pos.nodeAfter&&$pos.nodeAfter.sameMarkup(slice.content.firstChild))tr.setSelection(new NodeSelection($pos));else{let end=tr.mapping.map(insertPos);tr.mapping.maps[tr.mapping.maps.length-1].forEach(((_from,_to,_newFrom,newTo)=>end=newTo)),tr.setSelection(selectionBetween(view,$pos,tr.doc.resolve(end)))}view.focus(),view.dispatch(tr.setMeta("uiEvent","drop"))},handlers.focus=view=>{view.input.lastFocus=Date.now(),view.focused||(view.domObserver.stop(),view.dom.classList.add("ProseMirror-focused"),view.domObserver.start(),view.focused=!0,setTimeout((()=>{view.docView&&view.hasFocus()&&!view.domObserver.currentSelection.eq(view.domSelectionRange())&&selectionToDOM(view)}),20))},handlers.blur=(view,_event)=>{let event=_event;view.focused&&(view.domObserver.stop(),view.dom.classList.remove("ProseMirror-focused"),view.domObserver.start(),event.relatedTarget&&view.dom.contains(event.relatedTarget)&&view.domObserver.currentSelection.clear(),view.focused=!1)},handlers.beforeinput=(view,_event)=>{let event=_event;
// We should probably do more with beforeinput events, but support
// is so spotty that I'm still waiting to see where they are going.
// Very specific hack to deal with backspace sometimes failing on
// Chrome Android when after an uneditable node.
if(chrome$1&&android&&"deleteContentBackward"==event.inputType){view.domObserver.flushSoon();let{domChangeCount:domChangeCount}=view.input;setTimeout((()=>{if(view.input.domChangeCount!=domChangeCount)return;// Event already had some effect
// This bug tends to close the virtual keyboard, so we refocus
if(view.dom.blur(),view.focus(),view.someProp("handleKeyDown",(f=>f(view,keyEvent(8,"Backspace")))))return;let{$cursor:$cursor}=view.state.selection;
// Crude approximation of backspace behavior when no command handled it
$cursor&&$cursor.pos>0&&view.dispatch(view.state.tr.delete($cursor.pos-1,$cursor.pos).scrollIntoView())}),50)}};
// Make sure all handlers get registered
for(let prop in editHandlers)handlers[prop]=editHandlers[prop];function compareObjs(a,b){if(a==b)return!0;for(let p in a)if(a[p]!==b[p])return!1;for(let p in b)if(!(p in a))return!1;return!0}class WidgetType{constructor(toDOM,spec){this.toDOM=toDOM,this.spec=spec||noSpec,this.side=this.spec.side||0}map(mapping,span,offset,oldOffset){let{pos:pos,deleted:deleted}=mapping.mapResult(span.from+oldOffset,this.side<0?-1:1);return deleted?null:new Decoration(pos-offset,pos-offset,this)}valid(){return!0}eq(other){return this==other||other instanceof WidgetType&&(this.spec.key&&this.spec.key==other.spec.key||this.toDOM==other.toDOM&&compareObjs(this.spec,other.spec))}destroy(node){this.spec.destroy&&this.spec.destroy(node)}}class InlineType{constructor(attrs,spec){this.attrs=attrs,this.spec=spec||noSpec}map(mapping,span,offset,oldOffset){let from=mapping.map(span.from+oldOffset,this.spec.inclusiveStart?-1:1)-offset,to=mapping.map(span.to+oldOffset,this.spec.inclusiveEnd?1:-1)-offset;return from>=to?null:new Decoration(from,to,this)}valid(_,span){return span.from<span.to}eq(other){return this==other||other instanceof InlineType&&compareObjs(this.attrs,other.attrs)&&compareObjs(this.spec,other.spec)}static is(span){return span.type instanceof InlineType}destroy(){}}class NodeType{constructor(attrs,spec){this.attrs=attrs,this.spec=spec||noSpec}map(mapping,span,offset,oldOffset){let from=mapping.mapResult(span.from+oldOffset,1);if(from.deleted)return null;let to=mapping.mapResult(span.to+oldOffset,-1);return to.deleted||to.pos<=from.pos?null:new Decoration(from.pos-offset,to.pos-offset,this)}valid(node,span){let child,{index:index,offset:offset}=node.content.findIndex(span.from);return offset==span.from&&!(child=node.child(index)).isText&&offset+child.nodeSize==span.to}eq(other){return this==other||other instanceof NodeType&&compareObjs(this.attrs,other.attrs)&&compareObjs(this.spec,other.spec)}destroy(){}}
/**
Decoration objects can be provided to the view through the
[`decorations` prop](https://prosemirror.net/docs/ref/#view.EditorProps.decorations). They come in
several variants—see the static members of this class for details.
*/class Decoration{
/**
    @internal
    */
constructor(
/**
    The start position of the decoration.
    */
from,
/**
    The end position. Will be the same as `from` for [widget
    decorations](https://prosemirror.net/docs/ref/#view.Decoration^widget).
    */
to,
/**
    @internal
    */
type){this.from=from,this.to=to,this.type=type}
/**
    @internal
    */copy(from,to){return new Decoration(from,to,this.type)}
/**
    @internal
    */eq(other,offset=0){return this.type.eq(other.type)&&this.from+offset==other.from&&this.to+offset==other.to}
/**
    @internal
    */map(mapping,offset,oldOffset){return this.type.map(mapping,this,offset,oldOffset)}
/**
    Creates a widget decoration, which is a DOM node that's shown in
    the document at the given position. It is recommended that you
    delay rendering the widget by passing a function that will be
    called when the widget is actually drawn in a view, but you can
    also directly pass a DOM node. `getPos` can be used to find the
    widget's current document position.
    */static widget(pos,toDOM,spec){return new Decoration(pos,pos,new WidgetType(toDOM,spec))}
/**
    Creates an inline decoration, which adds the given attributes to
    each inline node between `from` and `to`.
    */static inline(from,to,attrs,spec){return new Decoration(from,to,new InlineType(attrs,spec))}
/**
    Creates a node decoration. `from` and `to` should point precisely
    before and after a node in the document. That node, and only that
    node, will receive the given attributes.
    */static node(from,to,attrs,spec){return new Decoration(from,to,new NodeType(attrs,spec))}
/**
    The spec provided when creating this decoration. Can be useful
    if you've stored extra information in that object.
    */get spec(){return this.type.spec}
/**
    @internal
    */get inline(){return this.type instanceof InlineType}}const none=[],noSpec={};
/**
A collection of [decorations](https://prosemirror.net/docs/ref/#view.Decoration), organized in such
a way that the drawing algorithm can efficiently use and compare
them. This is a persistent data structure—it is not modified,
updates create a new value.
*/class DecorationSet{
/**
    @internal
    */
constructor(local,children){this.local=local.length?local:none,this.children=children.length?children:none}
/**
    Create a set of decorations, using the structure of the given
    document.
    */static create(doc,decorations){return decorations.length?buildTree(decorations,doc,0,noSpec):empty}
/**
    Find all decorations in this set which touch the given range
    (including decorations that start or end directly at the
    boundaries) and match the given predicate on their spec. When
    `start` and `end` are omitted, all decorations in the set are
    considered. When `predicate` isn't given, all decorations are
    assumed to match.
    */find(start,end,predicate){let result=[];return this.findInner(null==start?0:start,null==end?1e9:end,result,0,predicate),result}findInner(start,end,result,offset,predicate){for(let i=0;i<this.local.length;i++){let span=this.local[i];span.from<=end&&span.to>=start&&(!predicate||predicate(span.spec))&&result.push(span.copy(span.from+offset,span.to+offset))}for(let i=0;i<this.children.length;i+=3)if(this.children[i]<end&&this.children[i+1]>start){let childOff=this.children[i]+1;this.children[i+2].findInner(start-childOff,end-childOff,result,offset+childOff,predicate)}}
/**
    Map the set of decorations in response to a change in the
    document.
    */map(mapping,doc,options){return this==empty||0==mapping.maps.length?this:this.mapInner(mapping,doc,0,0,options||noSpec)}
/**
    @internal
    */mapInner(mapping,node,offset,oldOffset,options){let newLocal;for(let i=0;i<this.local.length;i++){let mapped=this.local[i].map(mapping,offset,oldOffset);mapped&&mapped.type.valid(node,mapped)?(newLocal||(newLocal=[])).push(mapped):options.onRemove&&options.onRemove(this.local[i].spec)}return this.children.length?mapChildren(this.children,newLocal||[],mapping,node,offset,oldOffset,options):newLocal?new DecorationSet(newLocal.sort(byPos),none):empty}
/**
    Add the given array of decorations to the ones in the set,
    producing a new set. Needs access to the current document to
    create the appropriate tree structure.
    */add(doc,decorations){return decorations.length?this==empty?DecorationSet.create(doc,decorations):this.addInner(doc,decorations,0):this}addInner(doc,decorations,offset){let children,childIndex=0;doc.forEach(((childNode,childOffset)=>{let found,baseOffset=childOffset+offset;if(found=takeSpansForNode(decorations,childNode,baseOffset)){children||(children=this.children.slice());while(childIndex<children.length&&children[childIndex]<childOffset)childIndex+=3;children[childIndex]==childOffset?children[childIndex+2]=children[childIndex+2].addInner(childNode,found,baseOffset+1):children.splice(childIndex,0,childOffset,childOffset+childNode.nodeSize,buildTree(found,childNode,baseOffset+1,noSpec)),childIndex+=3}}));let local=moveSpans(childIndex?withoutNulls(decorations):decorations,-offset);for(let i=0;i<local.length;i++)local[i].type.valid(doc,local[i])||local.splice(i--,1);return new DecorationSet(local.length?this.local.concat(local).sort(byPos):this.local,children||this.children)}
/**
    Create a new set that contains the decorations in this set, minus
    the ones in the given array.
    */remove(decorations){return 0==decorations.length||this==empty?this:this.removeInner(decorations,0)}removeInner(decorations,offset){let children=this.children,local=this.local;for(let i=0;i<children.length;i+=3){let found,from=children[i]+offset,to=children[i+1]+offset;for(let span,j=0;j<decorations.length;j++)(span=decorations[j])&&span.from>from&&span.to<to&&(decorations[j]=null,(found||(found=[])).push(span));if(!found)continue;children==this.children&&(children=this.children.slice());let removed=children[i+2].removeInner(found,from+1);removed!=empty?children[i+2]=removed:(children.splice(i,3),i-=3)}if(local.length)for(let span,i=0;i<decorations.length;i++)if(span=decorations[i])for(let j=0;j<local.length;j++)local[j].eq(span,offset)&&(local==this.local&&(local=this.local.slice()),local.splice(j--,1));return children==this.children&&local==this.local?this:local.length||children.length?new DecorationSet(local,children):empty}
/**
    @internal
    */forChild(offset,node){if(this==empty)return this;if(node.isLeaf)return DecorationSet.empty;let child,local;for(let i=0;i<this.children.length;i+=3)if(this.children[i]>=offset){this.children[i]==offset&&(child=this.children[i+2]);break}let start=offset+1,end=start+node.content.size;for(let i=0;i<this.local.length;i++){let dec=this.local[i];if(dec.from<end&&dec.to>start&&dec.type instanceof InlineType){let from=Math.max(start,dec.from)-start,to=Math.min(end,dec.to)-start;from<to&&(local||(local=[])).push(dec.copy(from,to))}}if(local){let localSet=new DecorationSet(local.sort(byPos),none);return child?new DecorationGroup([localSet,child]):localSet}return child||empty}
/**
    @internal
    */eq(other){if(this==other)return!0;if(!(other instanceof DecorationSet)||this.local.length!=other.local.length||this.children.length!=other.children.length)return!1;for(let i=0;i<this.local.length;i++)if(!this.local[i].eq(other.local[i]))return!1;for(let i=0;i<this.children.length;i+=3)if(this.children[i]!=other.children[i]||this.children[i+1]!=other.children[i+1]||!this.children[i+2].eq(other.children[i+2]))return!1;return!0}
/**
    @internal
    */locals(node){return removeOverlap(this.localsInner(node))}
/**
    @internal
    */localsInner(node){if(this==empty)return none;if(node.inlineContent||!this.local.some(InlineType.is))return this.local;let result=[];for(let i=0;i<this.local.length;i++)this.local[i].type instanceof InlineType||result.push(this.local[i]);return result}}
/**
The empty set of decorations.
*/DecorationSet.empty=new DecorationSet([],[]),
/**
@internal
*/
DecorationSet.removeOverlap=removeOverlap;const empty=DecorationSet.empty;
// An abstraction that allows the code dealing with decorations to
// treat multiple DecorationSet objects as if it were a single object
// with (a subset of) the same interface.
class DecorationGroup{constructor(members){this.members=members}map(mapping,doc){const mappedDecos=this.members.map((member=>member.map(mapping,doc,noSpec)));return DecorationGroup.from(mappedDecos)}forChild(offset,child){if(child.isLeaf)return DecorationSet.empty;let found=[];for(let i=0;i<this.members.length;i++){let result=this.members[i].forChild(offset,child);result!=empty&&(result instanceof DecorationGroup?found=found.concat(result.members):found.push(result))}return DecorationGroup.from(found)}eq(other){if(!(other instanceof DecorationGroup)||other.members.length!=this.members.length)return!1;for(let i=0;i<this.members.length;i++)if(!this.members[i].eq(other.members[i]))return!1;return!0}locals(node){let result,sorted=!0;for(let i=0;i<this.members.length;i++){let locals=this.members[i].localsInner(node);if(locals.length)if(result){sorted&&(result=result.slice(),sorted=!1);for(let j=0;j<locals.length;j++)result.push(locals[j])}else result=locals}return result?removeOverlap(sorted?result:result.sort(byPos)):none}
// Create a group for the given array of decoration sets, or return
// a single set when possible.
static from(members){switch(members.length){case 0:return empty;case 1:return members[0];default:return new DecorationGroup(members.every((m=>m instanceof DecorationSet))?members:members.reduce(((r,m)=>r.concat(m instanceof DecorationSet?m:m.members)),[]))}}}function mapChildren(oldChildren,newLocal,mapping,node,offset,oldOffset,options){let children=oldChildren.slice();
// Mark the children that are directly touched by changes, and
// move those that are after the changes.
for(let i=0,baseOffset=oldOffset;i<mapping.maps.length;i++){let moved=0;mapping.maps[i].forEach(((oldStart,oldEnd,newStart,newEnd)=>{let dSize=newEnd-newStart-(oldEnd-oldStart);for(let i=0;i<children.length;i+=3){let end=children[i+1];if(end<0||oldStart>end+baseOffset-moved)continue;let start=children[i]+baseOffset-moved;oldEnd>=start?children[i+1]=oldStart<=start?-2:-1:newStart>=offset&&dSize&&(children[i]+=dSize,children[i+1]+=dSize)}moved+=dSize})),baseOffset=mapping.maps[i].map(baseOffset,-1)}
// Find the child nodes that still correspond to a single node,
// recursively call mapInner on them and update their positions.
let mustRebuild=!1;for(let i=0;i<children.length;i+=3)if(children[i+1]<0){// Touched nodes
if(-2==children[i+1]){mustRebuild=!0,children[i+1]=-1;continue}let from=mapping.map(oldChildren[i]+oldOffset),fromLocal=from-offset;if(fromLocal<0||fromLocal>=node.content.size){mustRebuild=!0;continue}
// Must read oldChildren because children was tagged with -1
let to=mapping.map(oldChildren[i+1]+oldOffset,-1),toLocal=to-offset,{index:index,offset:childOffset}=node.content.findIndex(fromLocal),childNode=node.maybeChild(index);if(childNode&&childOffset==fromLocal&&childOffset+childNode.nodeSize==toLocal){let mapped=children[i+2].mapInner(mapping,childNode,from+1,oldChildren[i]+oldOffset+1,options);mapped!=empty?(children[i]=fromLocal,children[i+1]=toLocal,children[i+2]=mapped):(children[i+1]=-2,mustRebuild=!0)}else mustRebuild=!0}
// Remaining children must be collected and rebuilt into the appropriate structure
if(mustRebuild){let decorations=mapAndGatherRemainingDecorations(children,oldChildren,newLocal,mapping,offset,oldOffset,options),built=buildTree(decorations,node,0,options);newLocal=built.local;for(let i=0;i<children.length;i+=3)children[i+1]<0&&(children.splice(i,3),i-=3);for(let i=0,j=0;i<built.children.length;i+=3){let from=built.children[i];while(j<children.length&&children[j]<from)j+=3;children.splice(j,0,built.children[i],built.children[i+1],built.children[i+2])}}return new DecorationSet(newLocal.sort(byPos),children)}function moveSpans(spans,offset){if(!offset||!spans.length)return spans;let result=[];for(let i=0;i<spans.length;i++){let span=spans[i];result.push(new Decoration(span.from+offset,span.to+offset,span.type))}return result}function mapAndGatherRemainingDecorations(children,oldChildren,decorations,mapping,offset,oldOffset,options){
// Gather all decorations from the remaining marked children
function gather(set,oldOffset){for(let i=0;i<set.local.length;i++){let mapped=set.local[i].map(mapping,offset,oldOffset);mapped?decorations.push(mapped):options.onRemove&&options.onRemove(set.local[i].spec)}for(let i=0;i<set.children.length;i+=3)gather(set.children[i+2],set.children[i]+oldOffset+1)}for(let i=0;i<children.length;i+=3)-1==children[i+1]&&gather(children[i+2],oldChildren[i]+oldOffset+1);return decorations}function takeSpansForNode(spans,node,offset){if(node.isLeaf)return null;let end=offset+node.nodeSize,found=null;for(let span,i=0;i<spans.length;i++)(span=spans[i])&&span.from>offset&&span.to<end&&((found||(found=[])).push(span),spans[i]=null);return found}function withoutNulls(array){let result=[];for(let i=0;i<array.length;i++)null!=array[i]&&result.push(array[i]);return result}
// Build up a tree that corresponds to a set of decorations. `offset`
// is a base offset that should be subtracted from the `from` and `to`
// positions in the spans (so that we don't have to allocate new spans
// for recursive calls).
function buildTree(spans,node,offset,options){let children=[],hasNulls=!1;node.forEach(((childNode,localStart)=>{let found=takeSpansForNode(spans,childNode,localStart+offset);if(found){hasNulls=!0;let subtree=buildTree(found,childNode,offset+localStart+1,options);subtree!=empty&&children.push(localStart,localStart+childNode.nodeSize,subtree)}}));let locals=moveSpans(hasNulls?withoutNulls(spans):spans,-offset).sort(byPos);for(let i=0;i<locals.length;i++)locals[i].type.valid(node,locals[i])||(options.onRemove&&options.onRemove(locals[i].spec),locals.splice(i--,1));return locals.length||children.length?new DecorationSet(locals,children):empty}
// Used to sort decorations so that ones with a low start position
// come first, and within a set with the same start position, those
// with an smaller end position come first.
function byPos(a,b){return a.from-b.from||a.to-b.to}
// Scan a sorted array of decorations for partially overlapping spans,
// and split those so that only fully overlapping spans are left (to
// make subsequent rendering easier). Will return the input array if
// no partially overlapping spans are found (the common case).
function removeOverlap(spans){let working=spans;for(let i=0;i<working.length-1;i++){let span=working[i];if(span.from!=span.to)for(let j=i+1;j<working.length;j++){let next=working[j];if(next.from!=span.from){next.from<span.to&&(working==spans&&(working=spans.slice()),
// The end of this one overlaps with a subsequent span. Split
// this one.
working[i]=span.copy(span.from,next.from),insertAhead(working,j,span.copy(next.from,span.to)));break}next.to!=span.to&&(working==spans&&(working=spans.slice()),
// Followed by a partially overlapping larger span. Split that
// span.
working[j]=next.copy(next.from,span.to),insertAhead(working,j+1,next.copy(span.to,next.to)))}}return working}function insertAhead(array,i,deco){while(i<array.length&&byPos(deco,array[i])>0)i++;array.splice(i,0,deco)}
// Get the decorations associated with the current props of a view.
function viewDecorations(view){let found=[];return view.someProp("decorations",(f=>{let result=f(view.state);result&&result!=empty&&found.push(result)})),view.cursorWrapper&&found.push(DecorationSet.create(view.state.doc,[view.cursorWrapper.deco])),DecorationGroup.from(found)}const observeOptions={childList:!0,characterData:!0,characterDataOldValue:!0,attributes:!0,attributeOldValue:!0,subtree:!0},useCharData=ie$1&&ie_version<=11;
// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified
class SelectionState{constructor(){this.anchorNode=null,this.anchorOffset=0,this.focusNode=null,this.focusOffset=0}set(sel){this.anchorNode=sel.anchorNode,this.anchorOffset=sel.anchorOffset,this.focusNode=sel.focusNode,this.focusOffset=sel.focusOffset}clear(){this.anchorNode=this.focusNode=null}eq(sel){return sel.anchorNode==this.anchorNode&&sel.anchorOffset==this.anchorOffset&&sel.focusNode==this.focusNode&&sel.focusOffset==this.focusOffset}}class DOMObserver{constructor(view,handleDOMChange){this.view=view,this.handleDOMChange=handleDOMChange,this.queue=[],this.flushingSoon=-1,this.observer=null,this.currentSelection=new SelectionState,this.onCharData=null,this.suppressingSelectionUpdates=!1,this.observer=window.MutationObserver&&new window.MutationObserver((mutations=>{for(let i=0;i<mutations.length;i++)this.queue.push(mutations[i]);
// IE11 will sometimes (on backspacing out a single character
// text node after a BR node) call the observer callback
// before actually updating the DOM, which will cause
// ProseMirror to miss the change (see #930)
ie$1&&ie_version<=11&&mutations.some((m=>"childList"==m.type&&m.removedNodes.length||"characterData"==m.type&&m.oldValue.length>m.target.nodeValue.length))?this.flushSoon():this.flush()})),useCharData&&(this.onCharData=e=>{this.queue.push({target:e.target,type:"characterData",oldValue:e.prevValue}),this.flushSoon()}),this.onSelectionChange=this.onSelectionChange.bind(this)}flushSoon(){this.flushingSoon<0&&(this.flushingSoon=window.setTimeout((()=>{this.flushingSoon=-1,this.flush()}),20))}forceFlush(){this.flushingSoon>-1&&(window.clearTimeout(this.flushingSoon),this.flushingSoon=-1,this.flush())}start(){this.observer&&(this.observer.takeRecords(),this.observer.observe(this.view.dom,observeOptions)),this.onCharData&&this.view.dom.addEventListener("DOMCharacterDataModified",this.onCharData),this.connectSelection()}stop(){if(this.observer){let take=this.observer.takeRecords();if(take.length){for(let i=0;i<take.length;i++)this.queue.push(take[i]);window.setTimeout((()=>this.flush()),20)}this.observer.disconnect()}this.onCharData&&this.view.dom.removeEventListener("DOMCharacterDataModified",this.onCharData),this.disconnectSelection()}connectSelection(){this.view.dom.ownerDocument.addEventListener("selectionchange",this.onSelectionChange)}disconnectSelection(){this.view.dom.ownerDocument.removeEventListener("selectionchange",this.onSelectionChange)}suppressSelectionUpdates(){this.suppressingSelectionUpdates=!0,setTimeout((()=>this.suppressingSelectionUpdates=!1),50)}onSelectionChange(){if(hasFocusAndSelection(this.view)){if(this.suppressingSelectionUpdates)return selectionToDOM(this.view);
// Deletions on IE11 fire their events in the wrong order, giving
// us a selection change event before the DOM changes are
// reported.
if(ie$1&&ie_version<=11&&!this.view.state.selection.empty){let sel=this.view.domSelectionRange();
// Selection.isCollapsed isn't reliable on IE
if(sel.focusNode&&isEquivalentPosition(sel.focusNode,sel.focusOffset,sel.anchorNode,sel.anchorOffset))return this.flushSoon()}this.flush()}}setCurSelection(){this.currentSelection.set(this.view.domSelectionRange())}ignoreSelectionChange(sel){if(!sel.focusNode)return!0;let container,ancestors=new Set;for(let scan=sel.focusNode;scan;scan=parentNode(scan))ancestors.add(scan);for(let scan=sel.anchorNode;scan;scan=parentNode(scan))if(ancestors.has(scan)){container=scan;break}let desc=container&&this.view.docView.nearestDesc(container);return desc&&desc.ignoreMutation({type:"selection",target:3==container.nodeType?container.parentNode:container})?(this.setCurSelection(),!0):void 0}flush(){let{view:view}=this;if(!view.docView||this.flushingSoon>-1)return;let mutations=this.observer?this.observer.takeRecords():[];this.queue.length&&(mutations=this.queue.concat(mutations),this.queue.length=0);let sel=view.domSelectionRange(),newSel=!this.suppressingSelectionUpdates&&!this.currentSelection.eq(sel)&&hasFocusAndSelection(view)&&!this.ignoreSelectionChange(sel),from=-1,to=-1,typeOver=!1,added=[];if(view.editable)for(let i=0;i<mutations.length;i++){let result=this.registerMutation(mutations[i],added);result&&(from=from<0?result.from:Math.min(result.from,from),to=to<0?result.to:Math.max(result.to,to),result.typeOver&&(typeOver=!0))}if(gecko&&added.length>1){let brs=added.filter((n=>"BR"==n.nodeName));if(2==brs.length){let a=brs[0],b=brs[1];a.parentNode&&a.parentNode.parentNode==b.parentNode?b.remove():a.remove()}}let readSel=null;
// If it looks like the browser has reset the selection to the
// start of the document after focus, restore the selection from
// the state
from<0&&newSel&&view.input.lastFocus>Date.now()-200&&Math.max(view.input.lastTouch,view.input.lastClick.time)<Date.now()-300&&selectionCollapsed(sel)&&(readSel=selectionFromDOM(view))&&readSel.eq(Selection.near(view.state.doc.resolve(0),1))?(view.input.lastFocus=0,selectionToDOM(view),this.currentSelection.set(sel),view.scrollToSelection()):(from>-1||newSel)&&(from>-1&&(view.docView.markDirty(from,to),checkCSS(view)),this.handleDOMChange(from,to,typeOver,added),view.docView&&view.docView.dirty?view.updateState(view.state):this.currentSelection.eq(sel)||selectionToDOM(view),this.currentSelection.set(sel))}registerMutation(mut,added){
// Ignore mutations inside nodes that were already noted as inserted
if(added.indexOf(mut.target)>-1)return null;let desc=this.view.docView.nearestDesc(mut.target);if("attributes"==mut.type&&(desc==this.view.docView||"contenteditable"==mut.attributeName||
// Firefox sometimes fires spurious events for null/empty styles
"style"==mut.attributeName&&!mut.oldValue&&!mut.target.getAttribute("style")))return null;if(!desc||desc.ignoreMutation(mut))return null;if("childList"==mut.type){for(let i=0;i<mut.addedNodes.length;i++)added.push(mut.addedNodes[i]);if(desc.contentDOM&&desc.contentDOM!=desc.dom&&!desc.contentDOM.contains(mut.target))return{from:desc.posBefore,to:desc.posAfter};let prev=mut.previousSibling,next=mut.nextSibling;if(ie$1&&ie_version<=11&&mut.addedNodes.length)
// IE11 gives us incorrect next/prev siblings for some
// insertions, so if there are added nodes, recompute those
for(let i=0;i<mut.addedNodes.length;i++){let{previousSibling:previousSibling,nextSibling:nextSibling}=mut.addedNodes[i];(!previousSibling||Array.prototype.indexOf.call(mut.addedNodes,previousSibling)<0)&&(prev=previousSibling),(!nextSibling||Array.prototype.indexOf.call(mut.addedNodes,nextSibling)<0)&&(next=nextSibling)}let fromOffset=prev&&prev.parentNode==mut.target?domIndex(prev)+1:0,from=desc.localPosFromDOM(mut.target,fromOffset,-1),toOffset=next&&next.parentNode==mut.target?domIndex(next):mut.target.childNodes.length,to=desc.localPosFromDOM(mut.target,toOffset,1);return{from:from,to:to}}return"attributes"==mut.type?{from:desc.posAtStart-desc.border,to:desc.posAtEnd+desc.border}:{from:desc.posAtStart,to:desc.posAtEnd,
// An event was generated for a text change that didn't change
// any text. Mark the dom change to fall back to assuming the
// selection was typed over with an identical value if it can't
// find another change.
typeOver:mut.target.nodeValue==mut.oldValue}}}let cssChecked=new WeakMap,cssCheckWarned=!1;function checkCSS(view){if(!cssChecked.has(view)&&(cssChecked.set(view,null),-1!==["normal","nowrap","pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace))){if(view.requiresGeckoHackNode=gecko,cssCheckWarned)return;cssCheckWarned=!0}}
// Used to work around a Safari Selection/shadow DOM bug
// Based on https://github.com/codemirror/dev/issues/414 fix
function safariShadowSelectionRange(view){let found;function read(event){event.preventDefault(),event.stopImmediatePropagation(),found=event.getTargetRanges()[0]}
// Because Safari (at least in 2018-2022) doesn't provide regular
// access to the selection inside a shadowRoot, we have to perform a
// ridiculous hack to get at it—using `execCommand` to trigger a
// `beforeInput` event so that we can read the target range from the
// event.
view.dom.addEventListener("beforeinput",read,!0),document.execCommand("indent"),view.dom.removeEventListener("beforeinput",read,!0);let anchorNode=found.startContainer,anchorOffset=found.startOffset,focusNode=found.endContainer,focusOffset=found.endOffset,currentAnchor=view.domAtPos(view.state.selection.anchor);
// Since such a range doesn't distinguish between anchor and head,
// use a heuristic that flips it around if its end matches the
// current anchor.
return isEquivalentPosition(currentAnchor.node,currentAnchor.offset,focusNode,focusOffset)&&([anchorNode,anchorOffset,focusNode,focusOffset]=[focusNode,focusOffset,anchorNode,anchorOffset]),{anchorNode:anchorNode,anchorOffset:anchorOffset,focusNode:focusNode,focusOffset:focusOffset}}
// Note that all referencing and parsing is done with the
// start-of-operation selection and document, since that's the one
// that the DOM represents. If any changes came in in the meantime,
// the modification is mapped over those before it is applied, in
// readDOMChange.
function parseBetween(view,from_,to_){let find,{node:parent,fromOffset:fromOffset,toOffset:toOffset,from:from,to:to}=view.docView.parseRange(from_,to_),domSel=view.domSelectionRange(),anchor=domSel.anchorNode;
// Work around issue in Chrome where backspacing sometimes replaces
// the deleted content with a random BR node (issues #799, #831)
if(anchor&&view.dom.contains(1==anchor.nodeType?anchor:anchor.parentNode)&&(find=[{node:anchor,offset:domSel.anchorOffset}],selectionCollapsed(domSel)||find.push({node:domSel.focusNode,offset:domSel.focusOffset})),chrome$1&&8===view.input.lastKeyCode)for(let off=toOffset;off>fromOffset;off--){let node=parent.childNodes[off-1],desc=node.pmViewDesc;if("BR"==node.nodeName&&!desc){toOffset=off;break}if(!desc||desc.size)break}let startDoc=view.state.doc,parser=view.someProp("domParser")||DOMParser$1.fromSchema(view.state.schema),$from=startDoc.resolve(from),sel=null,doc=parser.parse(parent,{topNode:$from.parent,topMatch:$from.parent.contentMatchAt($from.index()),topOpen:!0,from:fromOffset,to:toOffset,preserveWhitespace:"pre"!=$from.parent.type.whitespace||"full",findPositions:find,ruleFromNode:ruleFromNode,context:$from});if(find&&null!=find[0].pos){let anchor=find[0].pos,head=find[1]&&find[1].pos;null==head&&(head=anchor),sel={anchor:anchor+from,head:head+from}}return{doc:doc,sel:sel,from:from,to:to}}function ruleFromNode(dom){let desc=dom.pmViewDesc;if(desc)return desc.parseRule();if("BR"==dom.nodeName&&dom.parentNode){
// Safari replaces the list item or table cell with a BR
// directly in the list node (?!) if you delete the last
// character in a list item or table cell (#708, #862)
if(safari&&/^(ul|ol)$/i.test(dom.parentNode.nodeName)){let skip=document.createElement("div");return skip.appendChild(document.createElement("li")),{skip:skip}}if(dom.parentNode.lastChild==dom||safari&&/^(tr|table)$/i.test(dom.parentNode.nodeName))return{ignore:!0}}else if("IMG"==dom.nodeName&&dom.getAttribute("mark-placeholder"))return{ignore:!0};return null}const isInline=/^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;function readDOMChange(view,from,to,typeOver,addedNodes){if(from<0){let origin=view.input.lastSelectionTime>Date.now()-50?view.input.lastSelectionOrigin:null,newSel=selectionFromDOM(view,origin);if(newSel&&!view.state.selection.eq(newSel)){if(chrome$1&&android&&13===view.input.lastKeyCode&&Date.now()-100<view.input.lastKeyCodeTime&&view.someProp("handleKeyDown",(f=>f(view,keyEvent(13,"Enter")))))return;let tr=view.state.tr.setSelection(newSel);"pointer"==origin?tr.setMeta("pointer",!0):"key"==origin&&tr.scrollIntoView(),view.dispatch(tr)}return}let $before=view.state.doc.resolve(from),shared=$before.sharedDepth(to);from=$before.before(shared+1),to=view.state.doc.resolve(to).after(shared+1);let preferredPos,preferredSide,sel=view.state.selection,parse=parseBetween(view,from,to),doc=view.state.doc,compare=doc.slice(parse.from,parse.to);
// Prefer anchoring to end when Backspace is pressed
8===view.input.lastKeyCode&&Date.now()-100<view.input.lastKeyCodeTime?(preferredPos=view.state.selection.to,preferredSide="end"):(preferredPos=view.state.selection.from,preferredSide="start"),view.input.lastKeyCode=null;let change=findDiff(compare.content,parse.doc.content,parse.from,preferredPos,preferredSide);if((ios&&view.input.lastIOSEnter>Date.now()-225||android)&&addedNodes.some((n=>1==n.nodeType&&!isInline.test(n.nodeName)))&&(!change||change.endA>=change.endB)&&view.someProp("handleKeyDown",(f=>f(view,keyEvent(13,"Enter")))))return void(view.input.lastIOSEnter=0);if(!change){if(!(typeOver&&sel instanceof TextSelection&&!sel.empty&&sel.$head.sameParent(sel.$anchor))||view.composing||parse.sel&&parse.sel.anchor!=parse.sel.head){if(parse.sel){let sel=resolveSelection(view,view.state.doc,parse.sel);sel&&!sel.eq(view.state.selection)&&view.dispatch(view.state.tr.setSelection(sel))}return}change={start:sel.from,endA:sel.to,endB:sel.to}}
// Chrome sometimes leaves the cursor before the inserted text when
// composing after a cursor wrapper. This moves it forward.
if(chrome$1&&view.cursorWrapper&&parse.sel&&parse.sel.anchor==view.cursorWrapper.deco.from&&parse.sel.head==parse.sel.anchor){let size=change.endB-change.start;parse.sel={anchor:parse.sel.anchor+size,head:parse.sel.anchor+size}}view.input.domChangeCount++,
// Handle the case where overwriting a selection by typing matches
// the start or end of the selected content, creating a change
// that's smaller than what was actually overwritten.
view.state.selection.from<view.state.selection.to&&change.start==change.endB&&view.state.selection instanceof TextSelection&&(change.start>view.state.selection.from&&change.start<=view.state.selection.from+2&&view.state.selection.from>=parse.from?change.start=view.state.selection.from:change.endA<view.state.selection.to&&change.endA>=view.state.selection.to-2&&view.state.selection.to<=parse.to&&(change.endB+=view.state.selection.to-change.endA,change.endA=view.state.selection.to)),
// IE11 will insert a non-breaking space _ahead_ of the space after
// the cursor space when adding a space before another space. When
// that happened, adjust the change to cover the space instead.
ie$1&&ie_version<=11&&change.endB==change.start+1&&change.endA==change.start&&change.start>parse.from&&"  "==parse.doc.textBetween(change.start-parse.from-1,change.start-parse.from+1)&&(change.start--,change.endA--,change.endB--);let nextSel,$from=parse.doc.resolveNoCache(change.start-parse.from),$to=parse.doc.resolveNoCache(change.endB-parse.from),$fromA=doc.resolve(change.start),inlineChange=$from.sameParent($to)&&$from.parent.inlineContent&&$fromA.end()>=change.endA;
// If this looks like the effect of pressing Enter (or was recorded
// as being an iOS enter press), just dispatch an Enter key instead.
if((ios&&view.input.lastIOSEnter>Date.now()-225&&(!inlineChange||addedNodes.some((n=>"DIV"==n.nodeName||"P"==n.nodeName)))||!inlineChange&&$from.pos<parse.doc.content.size&&(nextSel=Selection.findFrom(parse.doc.resolve($from.pos+1),1,!0))&&nextSel.head==$to.pos)&&view.someProp("handleKeyDown",(f=>f(view,keyEvent(13,"Enter")))))return void(view.input.lastIOSEnter=0);
// Same for backspace
if(view.state.selection.anchor>change.start&&looksLikeJoin(doc,change.start,change.endA,$from,$to)&&view.someProp("handleKeyDown",(f=>f(view,keyEvent(8,"Backspace")))))// #820
return void(android&&chrome$1&&view.domObserver.suppressSelectionUpdates());
// Chrome Android will occasionally, during composition, delete the
// entire composition and then immediately insert it again. This is
// used to detect that situation.
chrome$1&&android&&change.endB==change.start&&(view.input.lastAndroidDelete=Date.now()),
// This tries to detect Android virtual keyboard
// enter-and-pick-suggestion action. That sometimes (see issue
// #1059) first fires a DOM mutation, before moving the selection to
// the newly created block. And then, because ProseMirror cleans up
// the DOM selection, it gives up moving the selection entirely,
// leaving the cursor in the wrong place. When that happens, we drop
// the new paragraph from the initial change, and fire a simulated
// enter key afterwards.
android&&!inlineChange&&$from.start()!=$to.start()&&0==$to.parentOffset&&$from.depth==$to.depth&&parse.sel&&parse.sel.anchor==parse.sel.head&&parse.sel.head==change.endA&&(change.endB-=2,$to=parse.doc.resolveNoCache(change.endB-parse.from),setTimeout((()=>{view.someProp("handleKeyDown",(function(f){return f(view,keyEvent(13,"Enter"))}))}),20));let tr,storedMarks,markChange,chFrom=change.start,chTo=change.endA;if(inlineChange)if($from.pos==$to.pos)// Deletion
// IE11 sometimes weirdly moves the DOM selection around after
// backspacing out the first element in a textblock
ie$1&&ie_version<=11&&0==$from.parentOffset&&(view.domObserver.suppressSelectionUpdates(),setTimeout((()=>selectionToDOM(view)),20)),tr=view.state.tr.delete(chFrom,chTo),storedMarks=doc.resolve(change.start).marksAcross(doc.resolve(change.endA));else if(// Adding or removing a mark
change.endA==change.endB&&(markChange=isMarkChange($from.parent.content.cut($from.parentOffset,$to.parentOffset),$fromA.parent.content.cut($fromA.parentOffset,change.endA-$fromA.start()))))tr=view.state.tr,"add"==markChange.type?tr.addMark(chFrom,chTo,markChange.mark):tr.removeMark(chFrom,chTo,markChange.mark);else if($from.parent.child($from.index()).isText&&$from.index()==$to.index()-($to.textOffset?0:1)){
// Both positions in the same text node -- simply insert text
let text=$from.parent.textBetween($from.parentOffset,$to.parentOffset);if(view.someProp("handleTextInput",(f=>f(view,chFrom,chTo,text))))return;tr=view.state.tr.insertText(text,chFrom,chTo)}if(tr||(tr=view.state.tr.replace(chFrom,chTo,parse.doc.slice(change.start-parse.from,change.endB-parse.from))),parse.sel){let sel=resolveSelection(view,tr.doc,parse.sel);
// Chrome Android will sometimes, during composition, report the
// selection in the wrong place. If it looks like that is
// happening, don't update the selection.
// Edge just doesn't move the cursor forward when you start typing
// in an empty block or between br nodes.
sel&&!(chrome$1&&android&&view.composing&&sel.empty&&(change.start!=change.endB||view.input.lastAndroidDelete<Date.now()-100)&&(sel.head==chFrom||sel.head==tr.mapping.map(chTo)-1)||ie$1&&sel.empty&&sel.head==chFrom)&&tr.setSelection(sel)}storedMarks&&tr.ensureMarks(storedMarks),view.dispatch(tr.scrollIntoView())}function resolveSelection(view,doc,parsedSel){return Math.max(parsedSel.anchor,parsedSel.head)>doc.content.size?null:selectionBetween(view,doc.resolve(parsedSel.anchor),doc.resolve(parsedSel.head))}
// Given two same-length, non-empty fragments of inline content,
// determine whether the first could be created from the second by
// removing or adding a single mark type.
function isMarkChange(cur,prev){let type,mark,update,curMarks=cur.firstChild.marks,prevMarks=prev.firstChild.marks,added=curMarks,removed=prevMarks;for(let i=0;i<prevMarks.length;i++)added=prevMarks[i].removeFromSet(added);for(let i=0;i<curMarks.length;i++)removed=curMarks[i].removeFromSet(removed);if(1==added.length&&0==removed.length)mark=added[0],type="add",update=node=>node.mark(mark.addToSet(node.marks));else{if(0!=added.length||1!=removed.length)return null;mark=removed[0],type="remove",update=node=>node.mark(mark.removeFromSet(node.marks))}let updated=[];for(let i=0;i<prev.childCount;i++)updated.push(update(prev.child(i)));if(Fragment.from(updated).eq(cur))return{mark:mark,type:type}}function looksLikeJoin(old,start,end,$newStart,$newEnd){if(!$newStart.parent.isTextblock||
// The content must have shrunk
end-start<=$newEnd.pos-$newStart.pos||
// newEnd must point directly at or after the end of the block that newStart points into
skipClosingAndOpening($newStart,!0,!1)<$newEnd.pos)return!1;let $start=old.resolve(start);
// Start must be at the end of a block
if($start.parentOffset<$start.parent.content.size||!$start.parent.isTextblock)return!1;let $next=old.resolve(skipClosingAndOpening($start,!0,!0));
// The next textblock must start before end and end near it
return!(!$next.parent.isTextblock||$next.pos>end||skipClosingAndOpening($next,!0,!1)<end)&&$newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
// The fragments after the join point must match
}function skipClosingAndOpening($pos,fromEnd,mayOpen){let depth=$pos.depth,end=fromEnd?$pos.end():$pos.pos;while(depth>0&&(fromEnd||$pos.indexAfter(depth)==$pos.node(depth).childCount))depth--,end++,fromEnd=!1;if(mayOpen){let next=$pos.node(depth).maybeChild($pos.indexAfter(depth));while(next&&!next.isLeaf)next=next.firstChild,end++}return end}function findDiff(a,b,pos,preferredPos,preferredSide){let start=a.findDiffStart(b,pos);if(null==start)return null;let{a:endA,b:endB}=a.findDiffEnd(b,pos+a.size,pos+b.size);if("end"==preferredSide){let adjust=Math.max(0,start-Math.min(endA,endB));preferredPos-=endA+adjust-start}if(endA<start&&a.size<b.size){let move=preferredPos<=start&&preferredPos>=endA?start-preferredPos:0;start-=move,endB=start+(endB-endA),endA=start}else if(endB<start){let move=preferredPos<=start&&preferredPos>=endB?start-preferredPos:0;start-=move,endA=start+(endA-endB),endB=start}return{start:start,endA:endA,endB:endB}}
/**
An editor view manages the DOM structure that represents an
editable document. Its state and behavior are determined by its
[props](https://prosemirror.net/docs/ref/#view.DirectEditorProps).
*/class EditorView{
/**
    Create a view. `place` may be a DOM node that the editor should
    be appended to, a function that will place it into the document,
    or an object whose `mount` property holds the node to use as the
    document container. If it is `null`, the editor will not be
    added to the document.
    */
constructor(place,props){this._root=null,
/**
        @internal
        */
this.focused=!1,
/**
        Kludge used to work around a Chrome bug @internal
        */
this.trackWrites=null,this.mounted=!1,
/**
        @internal
        */
this.markCursor=null,
/**
        @internal
        */
this.cursorWrapper=null,
/**
        @internal
        */
this.lastSelectedViewDesc=void 0,
/**
        @internal
        */
this.input=new InputState,this.prevDirectPlugins=[],this.pluginViews=[],
/**
        Holds `true` when a hack node is needed in Firefox to prevent the
        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
        @internal
        */
this.requiresGeckoHackNode=!1,
/**
        When editor content is being dragged, this object contains
        information about the dragged slice and whether it is being
        copied or moved. At any other time, it is null.
        */
this.dragging=null,this._props=props,this.state=props.state,this.directPlugins=props.plugins||[],this.directPlugins.forEach(checkStateComponent),this.dispatch=this.dispatch.bind(this),this.dom=place&&place.mount||document.createElement("div"),place&&(place.appendChild?place.appendChild(this.dom):"function"==typeof place?place(this.dom):place.mount&&(this.mounted=!0)),this.editable=getEditable(this),updateCursorWrapper(this),this.nodeViews=buildNodeViews(this),this.docView=docViewDesc(this.state.doc,computeDocDeco(this),viewDecorations(this),this.dom,this),this.domObserver=new DOMObserver(this,((from,to,typeOver,added)=>readDOMChange(this,from,to,typeOver,added))),this.domObserver.start(),initInput(this),this.updatePluginViews()}
/**
    Holds `true` when a
    [composition](https://w3c.github.io/uievents/#events-compositionevents)
    is active.
    */get composing(){return this.input.composing}
/**
    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
    */get props(){if(this._props.state!=this.state){let prev=this._props;this._props={};for(let name in prev)this._props[name]=prev[name];this._props.state=this.state}return this._props}
/**
    Update the view's props. Will immediately cause an update to
    the DOM.
    */update(props){props.handleDOMEvents!=this._props.handleDOMEvents&&ensureListeners(this);let prevProps=this._props;this._props=props,props.plugins&&(props.plugins.forEach(checkStateComponent),this.directPlugins=props.plugins),this.updateStateInner(props.state,prevProps)}
/**
    Update the view by updating existing props object with the object
    given as argument. Equivalent to `view.update(Object.assign({},
    view.props, props))`.
    */setProps(props){let updated={};for(let name in this._props)updated[name]=this._props[name];updated.state=this.state;for(let name in props)updated[name]=props[name];this.update(updated)}
/**
    Update the editor's `state` prop, without touching any of the
    other props.
    */updateState(state){this.updateStateInner(state,this._props)}updateStateInner(state,prevProps){let prev=this.state,redraw=!1,updateSel=!1;
// When stored marks are added, stop composition, so that they can
// be displayed.
state.storedMarks&&this.composing&&(clearComposition(this),updateSel=!0),this.state=state;let pluginsChanged=prev.plugins!=state.plugins||this._props.plugins!=prevProps.plugins;if(pluginsChanged||this._props.plugins!=prevProps.plugins||this._props.nodeViews!=prevProps.nodeViews){let nodeViews=buildNodeViews(this);changedNodeViews(nodeViews,this.nodeViews)&&(this.nodeViews=nodeViews,redraw=!0)}(pluginsChanged||prevProps.handleDOMEvents!=this._props.handleDOMEvents)&&ensureListeners(this),this.editable=getEditable(this),updateCursorWrapper(this);let innerDeco=viewDecorations(this),outerDeco=computeDocDeco(this),scroll=prev.plugins==state.plugins||prev.doc.eq(state.doc)?state.scrollToSelection>prev.scrollToSelection?"to selection":"preserve":"reset",updateDoc=redraw||!this.docView.matchesNode(state.doc,outerDeco,innerDeco);!updateDoc&&state.selection.eq(prev.selection)||(updateSel=!0);let oldScrollPos="preserve"==scroll&&updateSel&&null==this.dom.style.overflowAnchor&&storeScrollPos(this);if(updateSel){this.domObserver.stop();
// Work around an issue in Chrome, IE, and Edge where changing
// the DOM around an active selection puts it into a broken
// state where the thing the user sees differs from the
// selection reported by the Selection object (#710, #973,
// #1011, #1013, #1035).
let forceSelUpdate=updateDoc&&(ie$1||chrome$1)&&!this.composing&&!prev.selection.empty&&!state.selection.empty&&selectionContextChanged(prev.selection,state.selection);if(updateDoc){
// If the node that the selection points into is written to,
// Chrome sometimes starts misreporting the selection, so this
// tracks that and forces a selection reset when our update
// did write to the node.
let chromeKludge=chrome$1?this.trackWrites=this.domSelectionRange().focusNode:null;!redraw&&this.docView.update(state.doc,outerDeco,innerDeco,this)||(this.docView.updateOuterDeco([]),this.docView.destroy(),this.docView=docViewDesc(state.doc,outerDeco,innerDeco,this.dom,this)),chromeKludge&&!this.trackWrites&&(forceSelUpdate=!0)}
// Work around for an issue where an update arriving right between
// a DOM selection change and the "selectionchange" event for it
// can cause a spurious DOM selection update, disrupting mouse
// drag selection.
forceSelUpdate||!(this.input.mouseDown&&this.domObserver.currentSelection.eq(this.domSelectionRange())&&anchorInRightPlace(this))?selectionToDOM(this,forceSelUpdate):(syncNodeSelection(this,state.selection),this.domObserver.setCurSelection()),this.domObserver.start()}this.updatePluginViews(prev),"reset"==scroll?this.dom.scrollTop=0:"to selection"==scroll?this.scrollToSelection():oldScrollPos&&resetScrollPos(oldScrollPos)}
/**
    @internal
    */scrollToSelection(){let startDOM=this.domSelectionRange().focusNode;if(this.someProp("handleScrollToSelection",(f=>f(this))));else if(this.state.selection instanceof NodeSelection){let target=this.docView.domAfterPos(this.state.selection.from);1==target.nodeType&&scrollRectIntoView(this,target.getBoundingClientRect(),startDOM)}else scrollRectIntoView(this,this.coordsAtPos(this.state.selection.head,1),startDOM)}destroyPluginViews(){let view;while(view=this.pluginViews.pop())view.destroy&&view.destroy()}updatePluginViews(prevState){if(prevState&&prevState.plugins==this.state.plugins&&this.directPlugins==this.prevDirectPlugins)for(let i=0;i<this.pluginViews.length;i++){let pluginView=this.pluginViews[i];pluginView.update&&pluginView.update(this,prevState)}else{this.prevDirectPlugins=this.directPlugins,this.destroyPluginViews();for(let i=0;i<this.directPlugins.length;i++){let plugin=this.directPlugins[i];plugin.spec.view&&this.pluginViews.push(plugin.spec.view(this))}for(let i=0;i<this.state.plugins.length;i++){let plugin=this.state.plugins[i];plugin.spec.view&&this.pluginViews.push(plugin.spec.view(this))}}}someProp(propName,f){let value,prop=this._props&&this._props[propName];if(null!=prop&&(value=f?f(prop):prop))return value;for(let i=0;i<this.directPlugins.length;i++){let prop=this.directPlugins[i].props[propName];if(null!=prop&&(value=f?f(prop):prop))return value}let plugins=this.state.plugins;if(plugins)for(let i=0;i<plugins.length;i++){let prop=plugins[i].props[propName];if(null!=prop&&(value=f?f(prop):prop))return value}}
/**
    Query whether the view has focus.
    */hasFocus(){
// Work around IE not handling focus correctly if resize handles are shown.
// If the cursor is inside an element with resize handles, activeElement
// will be that element instead of this.dom.
if(ie$1){
// If activeElement is within this.dom, and there are no other elements
// setting `contenteditable` to false in between, treat it as focused.
let node=this.root.activeElement;if(node==this.dom)return!0;if(!node||!this.dom.contains(node))return!1;while(node&&this.dom!=node&&this.dom.contains(node)){if("false"==node.contentEditable)return!1;node=node.parentElement}return!0}return this.root.activeElement==this.dom}
/**
    Focus the editor.
    */focus(){this.domObserver.stop(),this.editable&&focusPreventScroll(this.dom),selectionToDOM(this),this.domObserver.start()}
/**
    Get the document root in which the editor exists. This will
    usually be the top-level `document`, but might be a [shadow
    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
    root if the editor is inside one.
    */get root(){let cached=this._root;if(null==cached)for(let search=this.dom.parentNode;search;search=search.parentNode)if(9==search.nodeType||11==search.nodeType&&search.host)return search.getSelection||(Object.getPrototypeOf(search).getSelection=()=>search.ownerDocument.getSelection()),this._root=search;return cached||document}
/**
    Given a pair of viewport coordinates, return the document
    position that corresponds to them. May return null if the given
    coordinates aren't inside of the editor. When an object is
    returned, its `pos` property is the position nearest to the
    coordinates, and its `inside` property holds the position of the
    inner node that the position falls inside of, or -1 if it is at
    the top level, not in any node.
    */posAtCoords(coords){return posAtCoords(this,coords)}
/**
    Returns the viewport rectangle at a given document position.
    `left` and `right` will be the same number, as this returns a
    flat cursor-ish rectangle. If the position is between two things
    that aren't directly adjacent, `side` determines which element
    is used. When < 0, the element before the position is used,
    otherwise the element after.
    */coordsAtPos(pos,side=1){return coordsAtPos(this,pos,side)}
/**
    Find the DOM position that corresponds to the given document
    position. When `side` is negative, find the position as close as
    possible to the content before the position. When positive,
    prefer positions close to the content after the position. When
    zero, prefer as shallow a position as possible.
    
    Note that you should **not** mutate the editor's internal DOM,
    only inspect it (and even that is usually not necessary).
    */domAtPos(pos,side=0){return this.docView.domFromPos(pos,side)}
/**
    Find the DOM node that represents the document node after the
    given position. May return `null` when the position doesn't point
    in front of a node or if the node is inside an opaque node view.
    
    This is intended to be able to call things like
    `getBoundingClientRect` on that DOM node. Do **not** mutate the
    editor DOM directly, or add styling this way, since that will be
    immediately overriden by the editor as it redraws the node.
    */nodeDOM(pos){let desc=this.docView.descAt(pos);return desc?desc.nodeDOM:null}
/**
    Find the document position that corresponds to a given DOM
    position. (Whenever possible, it is preferable to inspect the
    document structure directly, rather than poking around in the
    DOM, but sometimes—for example when interpreting an event
    target—you don't have a choice.)
    
    The `bias` parameter can be used to influence which side of a DOM
    node to use when the position is inside a leaf node.
    */posAtDOM(node,offset,bias=-1){let pos=this.docView.posFromDOM(node,offset,bias);if(null==pos)throw new RangeError("DOM position not inside the editor");return pos}
/**
    Find out whether the selection is at the end of a textblock when
    moving in a given direction. When, for example, given `"left"`,
    it will return true if moving left from the current cursor
    position would leave that position's parent textblock. Will apply
    to the view's current state by default, but it is possible to
    pass a different state.
    */endOfTextblock(dir,state){return endOfTextblock(this,state||this.state,dir)}
/**
    Run the editor's paste logic with the given HTML string. The
    `event`, if given, will be passed to the
    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
    */pasteHTML(html,event){return doPaste(this,"",html,!1,event||new ClipboardEvent("paste"))}
/**
    Run the editor's paste logic with the given plain-text input.
    */pasteText(text,event){return doPaste(this,text,null,!0,event||new ClipboardEvent("paste"))}
/**
    Removes the editor from the DOM and destroys all [node
    views](https://prosemirror.net/docs/ref/#view.NodeView).
    */destroy(){this.docView&&(destroyInput(this),this.destroyPluginViews(),this.mounted?(this.docView.update(this.state.doc,[],viewDecorations(this),this),this.dom.textContent=""):this.dom.parentNode&&this.dom.parentNode.removeChild(this.dom),this.docView.destroy(),this.docView=null)}
/**
    This is true when the view has been
    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
    used anymore).
    */get isDestroyed(){return null==this.docView}
/**
    Used for testing.
    */dispatchEvent(event){return dispatchEvent(this,event)}
/**
    Dispatch a transaction. Will call
    [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
    when given, and otherwise defaults to applying the transaction to
    the current state and calling
    [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
    This method is bound to the view instance, so that it can be
    easily passed around.
    */dispatch(tr){let dispatchTransaction=this._props.dispatchTransaction;dispatchTransaction?dispatchTransaction.call(this,tr):this.updateState(this.state.apply(tr))}
/**
    @internal
    */domSelectionRange(){return safari&&11===this.root.nodeType&&deepActiveElement(this.dom.ownerDocument)==this.dom?safariShadowSelectionRange(this):this.domSelection()}
/**
    @internal
    */domSelection(){return this.root.getSelection()}}function computeDocDeco(view){let attrs=Object.create(null);return attrs.class="ProseMirror",attrs.contenteditable=String(view.editable),attrs.translate="no",view.someProp("attributes",(value=>{if("function"==typeof value&&(value=value(view.state)),value)for(let attr in value)"class"==attr&&(attrs.class+=" "+value[attr]),"style"==attr?attrs.style=(attrs.style?attrs.style+";":"")+value[attr]:attrs[attr]||"contenteditable"==attr||"nodeName"==attr||(attrs[attr]=String(value[attr]))})),[Decoration.node(0,view.state.doc.content.size,attrs)]}function updateCursorWrapper(view){if(view.markCursor){let dom=document.createElement("img");dom.className="ProseMirror-separator",dom.setAttribute("mark-placeholder","true"),dom.setAttribute("alt",""),view.cursorWrapper={dom:dom,deco:Decoration.widget(view.state.selection.head,dom,{raw:!0,marks:view.markCursor})}}else view.cursorWrapper=null}function getEditable(view){return!view.someProp("editable",(value=>!1===value(view.state)))}function selectionContextChanged(sel1,sel2){let depth=Math.min(sel1.$anchor.sharedDepth(sel1.head),sel2.$anchor.sharedDepth(sel2.head));return sel1.$anchor.start(depth)!=sel2.$anchor.start(depth)}function buildNodeViews(view){let result=Object.create(null);function add(obj){for(let prop in obj)Object.prototype.hasOwnProperty.call(result,prop)||(result[prop]=obj[prop])}return view.someProp("nodeViews",add),view.someProp("markViews",add),result}function changedNodeViews(a,b){let nA=0,nB=0;for(let prop in a){if(a[prop]!=b[prop])return!0;nA++}for(let _ in b)nB++;return nA!=nB}function checkStateComponent(plugin){if(plugin.spec.state||plugin.spec.filterTransaction||plugin.spec.appendTransaction)throw new RangeError("Plugins passed directly to the view must not have a state component")}var base={8:"Backspace",9:"Tab",10:"Enter",12:"NumLock",13:"Enter",16:"Shift",17:"Control",18:"Alt",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",44:"PrintScreen",45:"Insert",46:"Delete",59:";",61:"=",91:"Meta",92:"Meta",106:"*",107:"+",108:",",109:"-",110:".",111:"/",144:"NumLock",145:"ScrollLock",160:"Shift",161:"Shift",162:"Control",163:"Control",164:"Alt",165:"Alt",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},shift$2={48:")",49:"!",50:"@",51:"#",52:"$",53:"%",54:"^",55:"&",56:"*",57:"(",59:":",61:"+",173:"_",186:":",187:"+",188:"<",189:"_",190:">",191:"?",192:"~",219:"{",220:"|",221:"}",222:'"'},chrome="undefined"!=typeof navigator&&/Chrome\/(\d+)/.exec(navigator.userAgent);"undefined"!=typeof navigator&&/Gecko\/\d+/.test(navigator.userAgent);
// Fill in the digit keys
for(var mac$1="undefined"!=typeof navigator&&/Mac/.test(navigator.platform),ie="undefined"!=typeof navigator&&/MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent),brokenModifierNames=mac$1||chrome&&+chrome[1]<57,i=0;i<10;i++)base[48+i]=base[96+i]=String(i);
// The function keys
for(i=1;i<=24;i++)base[i+111]="F"+i;
// And the alphabetic keys
for(i=65;i<=90;i++)base[i]=String.fromCharCode(i+32),shift$2[i]=String.fromCharCode(i);
// For each code that doesn't have a shift-equivalent, copy the base name
for(var code in base)shift$2.hasOwnProperty(code)||(shift$2[code]=base[code]);function keyName(event){var ignoreKey=brokenModifierNames&&(event.ctrlKey||event.altKey||event.metaKey)||ie&&event.shiftKey&&event.key&&1==event.key.length||"Unidentified"==event.key,name=!ignoreKey&&event.key||(event.shiftKey?shift$2:base)[event.keyCode]||event.key||"Unidentified";
// Edge sometimes produces wrong names (Issue #3)
return"Esc"==name&&(name="Escape"),"Del"==name&&(name="Delete"),
// https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
"Left"==name&&(name="ArrowLeft"),"Up"==name&&(name="ArrowUp"),"Right"==name&&(name="ArrowRight"),"Down"==name&&(name="ArrowDown"),name}const mac="undefined"!=typeof navigator&&/Mac|iP(hone|[oa]d)/.test(navigator.platform);function normalizeKeyName$1(name){let alt,ctrl,shift,meta,parts=name.split(/-(?!$)/),result=parts[parts.length-1];"Space"==result&&(result=" ");for(let i=0;i<parts.length-1;i++){let mod=parts[i];if(/^(cmd|meta|m)$/i.test(mod))meta=!0;else if(/^a(lt)?$/i.test(mod))alt=!0;else if(/^(c|ctrl|control)$/i.test(mod))ctrl=!0;else if(/^s(hift)?$/i.test(mod))shift=!0;else{if(!/^mod$/i.test(mod))throw new Error("Unrecognized modifier name: "+mod);mac?meta=!0:ctrl=!0}}return alt&&(result="Alt-"+result),ctrl&&(result="Ctrl-"+result),meta&&(result="Meta-"+result),shift&&(result="Shift-"+result),result}function normalize(map){let copy=Object.create(null);for(let prop in map)copy[normalizeKeyName$1(prop)]=map[prop];return copy}function modifiers$2(name,event,shift=!0){return event.altKey&&(name="Alt-"+name),event.ctrlKey&&(name="Ctrl-"+name),event.metaKey&&(name="Meta-"+name),shift&&event.shiftKey&&(name="Shift-"+name),name}
/**
Create a keymap plugin for the given set of bindings.

Bindings should map key names to [command](https://prosemirror.net/docs/ref/#commands)-style
functions, which will be called with `(EditorState, dispatch,
EditorView)` arguments, and should return true when they've handled
the key. Note that the view argument isn't part of the command
protocol, but can be used as an escape hatch if a binding needs to
directly interact with the UI.

Key names may be strings like `"Shift-Ctrl-Enter"`—a key
identifier prefixed with zero or more modifiers. Key identifiers
are based on the strings that can appear in
[`KeyEvent.key`](https:developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).
Use lowercase letters to refer to letter keys (or uppercase letters
if you want shift to be held). You may use `"Space"` as an alias
for the `" "` name.

Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or
`a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or
`Meta-`) are recognized. For characters that are created by holding
shift, the `Shift-` prefix is implied, and should not be added
explicitly.

You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on
other platforms.

You can add multiple keymap plugins to an editor. The order in
which they appear determines their precedence (the ones early in
the array get to dispatch first).
*/function keymap(bindings){return new Plugin({props:{handleKeyDown:keydownHandler(bindings)}})}
/**
Given a set of bindings (using the same format as
[`keymap`](https://prosemirror.net/docs/ref/#keymap.keymap)), return a [keydown
handler](https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyDown) that handles them.
*/function keydownHandler(bindings){let map=normalize(bindings);return function(view,event){let baseName,name=keyName(event),direct=map[modifiers$2(name,event)];if(direct&&direct(view.state,view.dispatch,view))return!0;
// A character key
if(1==name.length&&" "!=name){if(event.shiftKey){
// In case the name was already modified by shift, try looking
// it up without its shift modifier
let noShift=map[modifiers$2(name,event,!1)];if(noShift&&noShift(view.state,view.dispatch,view))return!0}if((event.shiftKey||event.altKey||event.metaKey||name.charCodeAt(0)>127)&&(baseName=base[event.keyCode])&&baseName!=name){
// Try falling back to the keyCode when there's a modifier
// active or the character produced isn't ASCII, and our table
// produces a different name from the the keyCode. See #668,
// #1060
let fromCode=map[modifiers$2(baseName,event)];if(fromCode&&fromCode(view.state,view.dispatch,view))return!0}}return!1}}
/**
Delete the selection, if there is one.
*/const deleteSelection$1=(state,dispatch)=>!state.selection.empty&&(dispatch&&dispatch(state.tr.deleteSelection().scrollIntoView()),!0);function atBlockStart(state,view){let{$cursor:$cursor}=state.selection;return!$cursor||(view?!view.endOfTextblock("backward",state):$cursor.parentOffset>0)?null:$cursor}
/**
If the selection is empty and at the start of a textblock, try to
reduce the distance between that block and the one before it—if
there's a block directly before it that can be joined, join them.
If not, try to move the selected block closer to the next one in
the document structure by lifting it out of its parent or moving it
into a parent of the previous block. Will use the view for accurate
(bidi-aware) start-of-textblock detection if given.
*/const joinBackward$1=(state,dispatch,view)=>{let $cursor=atBlockStart(state,view);if(!$cursor)return!1;let $cut=findCutBefore($cursor);
// If there is no node before this, try to lift
if(!$cut){let range=$cursor.blockRange(),target=range&&liftTarget(range);return null!=target&&(dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0)}let before=$cut.nodeBefore;
// Apply the joining algorithm
if(!before.type.spec.isolating&&deleteBarrier(state,$cut,dispatch))return!0;
// If the node below has no content and the node above is
// selectable, delete the node below and select the one above.
if(0==$cursor.parent.content.size&&(textblockAt(before,"end")||NodeSelection.isSelectable(before))){let delStep=replaceStep(state.doc,$cursor.before(),$cursor.after(),Slice.empty);if(delStep&&delStep.slice.size<delStep.to-delStep.from){if(dispatch){let tr=state.tr.step(delStep);tr.setSelection(textblockAt(before,"end")?Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos,-1)),-1):NodeSelection.create(tr.doc,$cut.pos-before.nodeSize)),dispatch(tr.scrollIntoView())}return!0}}
// If the node before is an atom, delete it
return!(!before.isAtom||$cut.depth!=$cursor.depth-1)&&(dispatch&&dispatch(state.tr.delete($cut.pos-before.nodeSize,$cut.pos).scrollIntoView()),!0)};function textblockAt(node,side,only=!1){for(let scan=node;scan;scan="start"==side?scan.firstChild:scan.lastChild){if(scan.isTextblock)return!0;if(only&&1!=scan.childCount)return!1}return!1}
/**
When the selection is empty and at the start of a textblock, select
the node before that textblock, if possible. This is intended to be
bound to keys like backspace, after
[`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward) or other deleting
commands, as a fall-back behavior when the schema doesn't allow
deletion at the selected point.
*/const selectNodeBackward$1=(state,dispatch,view)=>{let{$head:$head,empty:empty}=state.selection,$cut=$head;if(!empty)return!1;if($head.parent.isTextblock){if(view?!view.endOfTextblock("backward",state):$head.parentOffset>0)return!1;$cut=findCutBefore($head)}let node=$cut&&$cut.nodeBefore;return!(!node||!NodeSelection.isSelectable(node))&&(dispatch&&dispatch(state.tr.setSelection(NodeSelection.create(state.doc,$cut.pos-node.nodeSize)).scrollIntoView()),!0)};function findCutBefore($pos){if(!$pos.parent.type.spec.isolating)for(let i=$pos.depth-1;i>=0;i--){if($pos.index(i)>0)return $pos.doc.resolve($pos.before(i+1));if($pos.node(i).type.spec.isolating)break}return null}function atBlockEnd(state,view){let{$cursor:$cursor}=state.selection;return!$cursor||(view?!view.endOfTextblock("forward",state):$cursor.parentOffset<$cursor.parent.content.size)?null:$cursor}
/**
If the selection is empty and the cursor is at the end of a
textblock, try to reduce or remove the boundary between that block
and the one after it, either by joining them or by moving the other
block closer to this one in the tree structure. Will use the view
for accurate start-of-textblock detection if given.
*/const joinForward$1=(state,dispatch,view)=>{let $cursor=atBlockEnd(state,view);if(!$cursor)return!1;let $cut=findCutAfter($cursor);
// If there is no node after this, there's nothing to do
if(!$cut)return!1;let after=$cut.nodeAfter;
// Try the joining algorithm
if(deleteBarrier(state,$cut,dispatch))return!0;
// If the node above has no content and the node below is
// selectable, delete the node above and select the one below.
if(0==$cursor.parent.content.size&&(textblockAt(after,"start")||NodeSelection.isSelectable(after))){let delStep=replaceStep(state.doc,$cursor.before(),$cursor.after(),Slice.empty);if(delStep&&delStep.slice.size<delStep.to-delStep.from){if(dispatch){let tr=state.tr.step(delStep);tr.setSelection(textblockAt(after,"start")?Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)),1):NodeSelection.create(tr.doc,tr.mapping.map($cut.pos))),dispatch(tr.scrollIntoView())}return!0}}
// If the next node is an atom, delete it
return!(!after.isAtom||$cut.depth!=$cursor.depth-1)&&(dispatch&&dispatch(state.tr.delete($cut.pos,$cut.pos+after.nodeSize).scrollIntoView()),!0)},selectNodeForward$1=(state,dispatch,view)=>{let{$head:$head,empty:empty}=state.selection,$cut=$head;if(!empty)return!1;if($head.parent.isTextblock){if(view?!view.endOfTextblock("forward",state):$head.parentOffset<$head.parent.content.size)return!1;$cut=findCutAfter($head)}let node=$cut&&$cut.nodeAfter;return!(!node||!NodeSelection.isSelectable(node))&&(dispatch&&dispatch(state.tr.setSelection(NodeSelection.create(state.doc,$cut.pos)).scrollIntoView()),!0)};
/**
When the selection is empty and at the end of a textblock, select
the node coming after that textblock, if possible. This is intended
to be bound to keys like delete, after
[`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward) and similar deleting
commands, to provide a fall-back behavior when the schema doesn't
allow deletion at the selected point.
*/function findCutAfter($pos){if(!$pos.parent.type.spec.isolating)for(let i=$pos.depth-1;i>=0;i--){let parent=$pos.node(i);if($pos.index(i)+1<parent.childCount)return $pos.doc.resolve($pos.after(i+1));if(parent.type.spec.isolating)break}return null}
/**
Join the selected block or, if there is a text selection, the
closest ancestor block of the selection that can be joined, with
the sibling above it.
*/const joinUp$1=(state,dispatch)=>{let point,sel=state.selection,nodeSel=sel instanceof NodeSelection;if(nodeSel){if(sel.node.isTextblock||!canJoin(state.doc,sel.from))return!1;point=sel.from}else if(point=joinPoint(state.doc,sel.from,-1),null==point)return!1;if(dispatch){let tr=state.tr.join(point);nodeSel&&tr.setSelection(NodeSelection.create(tr.doc,point-state.doc.resolve(point).nodeBefore.nodeSize)),dispatch(tr.scrollIntoView())}return!0},joinDown$1=(state,dispatch)=>{let point,sel=state.selection;if(sel instanceof NodeSelection){if(sel.node.isTextblock||!canJoin(state.doc,sel.to))return!1;point=sel.to}else if(point=joinPoint(state.doc,sel.to,1),null==point)return!1;return dispatch&&dispatch(state.tr.join(point).scrollIntoView()),!0},lift$1=(state,dispatch)=>{let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to),target=range&&liftTarget(range);return null!=target&&(dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0)},newlineInCode$1=(state,dispatch)=>{let{$head:$head,$anchor:$anchor}=state.selection;return!(!$head.parent.type.spec.code||!$head.sameParent($anchor))&&(dispatch&&dispatch(state.tr.insertText("\n").scrollIntoView()),!0)};
/**
Join the selected block, or the closest ancestor of the selection
that can be joined, with the sibling after it.
*/function defaultBlockAt$1(match){for(let i=0;i<match.edgeCount;i++){let{type:type}=match.edge(i);if(type.isTextblock&&!type.hasRequiredAttrs())return type}return null}
/**
When the selection is in a node with a truthy
[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, create a
default block after the code block, and move the cursor there.
*/const exitCode$1=(state,dispatch)=>{let{$head:$head,$anchor:$anchor}=state.selection;if(!$head.parent.type.spec.code||!$head.sameParent($anchor))return!1;let above=$head.node(-1),after=$head.indexAfter(-1),type=defaultBlockAt$1(above.contentMatchAt(after));if(!type||!above.canReplaceWith(after,after,type))return!1;if(dispatch){let pos=$head.after(),tr=state.tr.replaceWith(pos,pos,type.createAndFill());tr.setSelection(Selection.near(tr.doc.resolve(pos),1)),dispatch(tr.scrollIntoView())}return!0},createParagraphNear$1=(state,dispatch)=>{let sel=state.selection,{$from:$from,$to:$to}=sel;if(sel instanceof AllSelection||$from.parent.inlineContent||$to.parent.inlineContent)return!1;let type=defaultBlockAt$1($to.parent.contentMatchAt($to.indexAfter()));if(!type||!type.isTextblock)return!1;if(dispatch){let side=(!$from.parentOffset&&$to.index()<$to.parent.childCount?$from:$to).pos,tr=state.tr.insert(side,type.createAndFill());tr.setSelection(TextSelection.create(tr.doc,side+1)),dispatch(tr.scrollIntoView())}return!0},liftEmptyBlock$1=(state,dispatch)=>{let{$cursor:$cursor}=state.selection;if(!$cursor||$cursor.parent.content.size)return!1;if($cursor.depth>1&&$cursor.after()!=$cursor.end(-1)){let before=$cursor.before();if(canSplit(state.doc,before))return dispatch&&dispatch(state.tr.split(before).scrollIntoView()),!0}let range=$cursor.blockRange(),target=range&&liftTarget(range);return null!=target&&(dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0)},selectParentNode$1=(state,dispatch)=>{let pos,{$from:$from,to:to}=state.selection,same=$from.sharedDepth(to);return 0!=same&&(pos=$from.before(same),dispatch&&dispatch(state.tr.setSelection(NodeSelection.create(state.doc,pos))),!0)};
/**
If a block node is selected, create an empty paragraph before (if
it is its parent's first child) or after it.
*/function joinMaybeClear(state,$pos,dispatch){let before=$pos.nodeBefore,after=$pos.nodeAfter,index=$pos.index();return!!(before&&after&&before.type.compatibleContent(after.type))&&(!before.content.size&&$pos.parent.canReplace(index-1,index)?(dispatch&&dispatch(state.tr.delete($pos.pos-before.nodeSize,$pos.pos).scrollIntoView()),!0):!(!$pos.parent.canReplace(index,index+1)||!after.isTextblock&&!canJoin(state.doc,$pos.pos))&&(dispatch&&dispatch(state.tr.clearIncompatible($pos.pos,before.type,before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView()),!0))}function deleteBarrier(state,$cut,dispatch){let conn,match,before=$cut.nodeBefore,after=$cut.nodeAfter;if(before.type.spec.isolating||after.type.spec.isolating)return!1;if(joinMaybeClear(state,$cut,dispatch))return!0;let canDelAfter=$cut.parent.canReplace($cut.index(),$cut.index()+1);if(canDelAfter&&(conn=(match=before.contentMatchAt(before.childCount)).findWrapping(after.type))&&match.matchType(conn[0]||after.type).validEnd){if(dispatch){let end=$cut.pos+after.nodeSize,wrap=Fragment.empty;for(let i=conn.length-1;i>=0;i--)wrap=Fragment.from(conn[i].create(null,wrap));wrap=Fragment.from(before.copy(wrap));let tr=state.tr.step(new ReplaceAroundStep($cut.pos-1,end,$cut.pos,end,new Slice(wrap,1,0),conn.length,!0)),joinAt=end+2*conn.length;canJoin(tr.doc,joinAt)&&tr.join(joinAt),dispatch(tr.scrollIntoView())}return!0}let selAfter=Selection.findFrom($cut,1),range=selAfter&&selAfter.$from.blockRange(selAfter.$to),target=range&&liftTarget(range);if(null!=target&&target>=$cut.depth)return dispatch&&dispatch(state.tr.lift(range,target).scrollIntoView()),!0;if(canDelAfter&&textblockAt(after,"start",!0)&&textblockAt(before,"end")){let at=before,wrap=[];for(;;){if(wrap.push(at),at.isTextblock)break;at=at.lastChild}let afterText=after,afterDepth=1;for(;!afterText.isTextblock;afterText=afterText.firstChild)afterDepth++;if(at.canReplace(at.childCount,at.childCount,afterText.content)){if(dispatch){let end=Fragment.empty;for(let i=wrap.length-1;i>=0;i--)end=Fragment.from(wrap[i].copy(end));let tr=state.tr.step(new ReplaceAroundStep($cut.pos-wrap.length,$cut.pos+after.nodeSize,$cut.pos+afterDepth,$cut.pos+after.nodeSize-afterDepth,new Slice(end,wrap.length,0),0,!0));dispatch(tr.scrollIntoView())}return!0}}return!1}function selectTextblockSide(side){return function(state,dispatch){let sel=state.selection,$pos=side<0?sel.$from:sel.$to,depth=$pos.depth;while($pos.node(depth).isInline){if(!depth)return!1;depth--}return!!$pos.node(depth).isTextblock&&(dispatch&&dispatch(state.tr.setSelection(TextSelection.create(state.doc,side<0?$pos.start(depth):$pos.end(depth)))),!0)}}
/**
Moves the cursor to the start of current text block.
*/const selectTextblockStart$1=selectTextblockSide(-1),selectTextblockEnd$1=selectTextblockSide(1);
/**
Moves the cursor to the end of current text block.
*/
// Parameterized commands
/**
Wrap the selection in a node of the given type with the given
attributes.
*/
function wrapIn$1(nodeType,attrs=null){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to),wrapping=range&&findWrapping(range,nodeType,attrs);return!!wrapping&&(dispatch&&dispatch(state.tr.wrap(range,wrapping).scrollIntoView()),!0)}}
/**
Returns a command that tries to set the selected textblocks to the
given node type with the given attributes.
*/function setBlockType(nodeType,attrs=null){return function(state,dispatch){let applicable=!1;for(let i=0;i<state.selection.ranges.length&&!applicable;i++){let{$from:{pos:from},$to:{pos:to}}=state.selection.ranges[i];state.doc.nodesBetween(from,to,((node,pos)=>{if(applicable)return!1;if(node.isTextblock&&!node.hasMarkup(nodeType,attrs))if(node.type==nodeType)applicable=!0;else{let $pos=state.doc.resolve(pos),index=$pos.index();applicable=$pos.parent.canReplaceWith(index,index+1,nodeType)}}))}if(!applicable)return!1;if(dispatch){let tr=state.tr;for(let i=0;i<state.selection.ranges.length;i++){let{$from:{pos:from},$to:{pos:to}}=state.selection.ranges[i];tr.setBlockType(from,to,nodeType,attrs)}dispatch(tr.scrollIntoView())}return!0}}
/**
Returns a command function that wraps the selection in a list with
the given type an attributes. If `dispatch` is null, only return a
value to indicate whether this is possible, but don't actually
perform the change.
*/
function wrapInList$1(listType,attrs=null){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to),doJoin=!1,outerRange=range;if(!range)return!1;
// This is at the top of an existing list item
if(range.depth>=2&&$from.node(range.depth-1).type.compatibleContent(listType)&&0==range.startIndex){
// Don't do anything if this is the top of the list
if(0==$from.index(range.depth-1))return!1;let $insert=state.doc.resolve(range.start-2);outerRange=new NodeRange($insert,$insert,range.depth),range.endIndex<range.parent.childCount&&(range=new NodeRange($from,state.doc.resolve($to.end(range.depth)),range.depth)),doJoin=!0}let wrap=findWrapping(outerRange,listType,attrs,range);return!!wrap&&(dispatch&&dispatch(doWrapInList(state.tr,range,wrap,doJoin,listType).scrollIntoView()),!0)}}function doWrapInList(tr,range,wrappers,joinBefore,listType){let content=Fragment.empty;for(let i=wrappers.length-1;i>=0;i--)content=Fragment.from(wrappers[i].type.create(wrappers[i].attrs,content));tr.step(new ReplaceAroundStep(range.start-(joinBefore?2:0),range.end,range.start,range.end,new Slice(content,0,0),wrappers.length,!0));let found=0;for(let i=0;i<wrappers.length;i++)wrappers[i].type==listType&&(found=i+1);let splitDepth=wrappers.length-found,splitPos=range.start+wrappers.length-(joinBefore?2:0),parent=range.parent;for(let i=range.startIndex,e=range.endIndex,first=!0;i<e;i++,first=!1)!first&&canSplit(tr.doc,splitPos,splitDepth)&&(tr.split(splitPos,splitDepth),splitPos+=2*splitDepth),splitPos+=parent.child(i).nodeSize;return tr}
/**
Create a command to lift the list item around the selection up into
a wrapping list.
*/function liftListItem$1(itemType){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to,(node=>node.childCount>0&&node.firstChild.type==itemType));return!!range&&(!dispatch||($from.node(range.depth-1).type==itemType?liftToOuterList(state,dispatch,itemType,range):liftOutOfList(state,dispatch,range)))}}function liftToOuterList(state,dispatch,itemType,range){let tr=state.tr,end=range.end,endOfList=range.$to.end(range.depth);end<endOfList&&(
// There are siblings after the lifted items, which must become
// children of the last item
tr.step(new ReplaceAroundStep(end-1,endOfList,end,endOfList,new Slice(Fragment.from(itemType.create(null,range.parent.copy())),1,0),1,!0)),range=new NodeRange(tr.doc.resolve(range.$from.pos),tr.doc.resolve(endOfList),range.depth));const target=liftTarget(range);if(null==target)return!1;tr.lift(range,target);let after=tr.mapping.map(end,-1)-1;return canJoin(tr.doc,after)&&tr.join(after),dispatch(tr.scrollIntoView()),!0}function liftOutOfList(state,dispatch,range){let tr=state.tr,list=range.parent;
// Merge the list items into a single big item
for(let pos=range.end,i=range.endIndex-1,e=range.startIndex;i>e;i--)pos-=list.child(i).nodeSize,tr.delete(pos-1,pos+1);let $start=tr.doc.resolve(range.start),item=$start.nodeAfter;if(tr.mapping.map(range.end)!=range.start+$start.nodeAfter.nodeSize)return!1;let atStart=0==range.startIndex,atEnd=range.endIndex==list.childCount,parent=$start.node(-1),indexBefore=$start.index(-1);if(!parent.canReplace(indexBefore+(atStart?0:1),indexBefore+1,item.content.append(atEnd?Fragment.empty:Fragment.from(list))))return!1;let start=$start.pos,end=start+item.nodeSize;
// Strip off the surrounding list. At the sides where we're not at
// the end of the list, the existing list is closed. At sides where
// this is the end, it is overwritten to its end.
return tr.step(new ReplaceAroundStep(start-(atStart?1:0),end+(atEnd?1:0),start+1,end-1,new Slice((atStart?Fragment.empty:Fragment.from(list.copy(Fragment.empty))).append(atEnd?Fragment.empty:Fragment.from(list.copy(Fragment.empty))),atStart?0:1,atEnd?0:1),atStart?0:1)),dispatch(tr.scrollIntoView()),!0}
/**
Create a command to sink the list item around the selection down
into an inner list.
*/function sinkListItem$1(itemType){return function(state,dispatch){let{$from:$from,$to:$to}=state.selection,range=$from.blockRange($to,(node=>node.childCount>0&&node.firstChild.type==itemType));if(!range)return!1;let startIndex=range.startIndex;if(0==startIndex)return!1;let parent=range.parent,nodeBefore=parent.child(startIndex-1);if(nodeBefore.type!=itemType)return!1;if(dispatch){let nestedBefore=nodeBefore.lastChild&&nodeBefore.lastChild.type==parent.type,inner=Fragment.from(nestedBefore?itemType.create():null),slice=new Slice(Fragment.from(itemType.create(null,Fragment.from(parent.type.create(null,inner)))),nestedBefore?3:1,0),before=range.start,after=range.end;dispatch(state.tr.step(new ReplaceAroundStep(before-(nestedBefore?3:1),after,before,after,slice,1,!0)).scrollIntoView())}return!0}}function createChainableState(config){const{state:state,transaction:transaction}=config;let{selection:selection}=transaction,{doc:doc}=transaction,{storedMarks:storedMarks}=transaction;return{...state,apply:state.apply.bind(state),applyTransaction:state.applyTransaction.bind(state),filterTransaction:state.filterTransaction,plugins:state.plugins,schema:state.schema,reconfigure:state.reconfigure.bind(state),toJSON:state.toJSON.bind(state),get storedMarks(){return storedMarks},get selection(){return selection},get doc(){return doc},get tr(){return selection=transaction.selection,doc=transaction.doc,storedMarks=transaction.storedMarks,transaction}}}"undefined"!=typeof navigator?/Mac|iP(hone|[oa]d)/.test(navigator.platform):"undefined"!=typeof os&&os.platform&&os.platform();class CommandManager{constructor(props){this.editor=props.editor,this.rawCommands=this.editor.extensionManager.commands,this.customState=props.state}get hasCustomState(){return!!this.customState}get state(){return this.customState||this.editor.state}get commands(){const{rawCommands:rawCommands,editor:editor,state:state}=this,{view:view}=editor,{tr:tr}=state,props=this.buildProps(tr);return Object.fromEntries(Object.entries(rawCommands).map((([name,command])=>{const method=(...args)=>{const callback=command(...args)(props);return tr.getMeta("preventDispatch")||this.hasCustomState||view.dispatch(tr),callback};return[name,method]})))}get chain(){return()=>this.createChain()}get can(){return()=>this.createCan()}createChain(startTr,shouldDispatch=!0){const{rawCommands:rawCommands,editor:editor,state:state}=this,{view:view}=editor,callbacks=[],hasStartTransaction=!!startTr,tr=startTr||state.tr,run=()=>(hasStartTransaction||!shouldDispatch||tr.getMeta("preventDispatch")||this.hasCustomState||view.dispatch(tr),callbacks.every((callback=>!0===callback))),chain={...Object.fromEntries(Object.entries(rawCommands).map((([name,command])=>{const chainedCommand=(...args)=>{const props=this.buildProps(tr,shouldDispatch),callback=command(...args)(props);return callbacks.push(callback),chain};return[name,chainedCommand]}))),run:run};return chain}createCan(startTr){const{rawCommands:rawCommands,state:state}=this,dispatch=!1,tr=startTr||state.tr,props=this.buildProps(tr,dispatch),formattedCommands=Object.fromEntries(Object.entries(rawCommands).map((([name,command])=>[name,(...args)=>command(...args)({...props,dispatch:void 0})])));return{...formattedCommands,chain:()=>this.createChain(tr,dispatch)}}buildProps(tr,shouldDispatch=!0){const{rawCommands:rawCommands,editor:editor,state:state}=this,{view:view}=editor;state.storedMarks&&tr.setStoredMarks(state.storedMarks);const props={tr:tr,editor:editor,view:view,state:createChainableState({state:state,transaction:tr}),dispatch:shouldDispatch?()=>{}:void 0,chain:()=>this.createChain(tr),can:()=>this.createCan(tr),get commands(){return Object.fromEntries(Object.entries(rawCommands).map((([name,command])=>[name,(...args)=>command(...args)(props)])))}};return props}}class EventEmitter{constructor(){this.callbacks={}}on(event,fn){return this.callbacks[event]||(this.callbacks[event]=[]),this.callbacks[event].push(fn),this}emit(event,...args){const callbacks=this.callbacks[event];return callbacks&&callbacks.forEach((callback=>callback.apply(this,args))),this}off(event,fn){const callbacks=this.callbacks[event];return callbacks&&(fn?this.callbacks[event]=callbacks.filter((callback=>callback!==fn)):delete this.callbacks[event]),this}removeAllListeners(){this.callbacks={}}}function getExtensionField(extension,field,context){if(void 0===extension.config[field]&&extension.parent)return getExtensionField(extension.parent,field,context);if("function"===typeof extension.config[field]){const value=extension.config[field].bind({...context,parent:extension.parent?getExtensionField(extension.parent,field,context):null});return value}return extension.config[field]}function splitExtensions(extensions){const baseExtensions=extensions.filter((extension=>"extension"===extension.type)),nodeExtensions=extensions.filter((extension=>"node"===extension.type)),markExtensions=extensions.filter((extension=>"mark"===extension.type));return{baseExtensions:baseExtensions,nodeExtensions:nodeExtensions,markExtensions:markExtensions}}
/**
 * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.
 * @param extensions List of extensions
 */function getAttributesFromExtensions(extensions){const extensionAttributes=[],{nodeExtensions:nodeExtensions,markExtensions:markExtensions}=splitExtensions(extensions),nodeAndMarkExtensions=[...nodeExtensions,...markExtensions],defaultAttribute={default:null,rendered:!0,renderHTML:null,parseHTML:null,keepOnSplit:!0,isRequired:!1};return extensions.forEach((extension=>{const context={name:extension.name,options:extension.options,storage:extension.storage},addGlobalAttributes=getExtensionField(extension,"addGlobalAttributes",context);if(!addGlobalAttributes)return;
// TODO: remove `as GlobalAttributes`
const globalAttributes=addGlobalAttributes();globalAttributes.forEach((globalAttribute=>{globalAttribute.types.forEach((type=>{Object.entries(globalAttribute.attributes).forEach((([name,attribute])=>{extensionAttributes.push({type:type,name:name,attribute:{...defaultAttribute,...attribute}})}))}))}))})),nodeAndMarkExtensions.forEach((extension=>{const context={name:extension.name,options:extension.options,storage:extension.storage},addAttributes=getExtensionField(extension,"addAttributes",context);if(!addAttributes)return;
// TODO: remove `as Attributes`
const attributes=addAttributes();Object.entries(attributes).forEach((([name,attribute])=>{const mergedAttr={...defaultAttribute,...attribute};"function"===typeof(null===mergedAttr||void 0===mergedAttr?void 0:mergedAttr.default)&&(mergedAttr.default=mergedAttr.default()),(null===mergedAttr||void 0===mergedAttr?void 0:mergedAttr.isRequired)&&void 0===(null===mergedAttr||void 0===mergedAttr?void 0:mergedAttr.default)&&delete mergedAttr.default,extensionAttributes.push({type:extension.name,name:name,attribute:mergedAttr})}))})),extensionAttributes}function getNodeType(nameOrType,schema){if("string"===typeof nameOrType){if(!schema.nodes[nameOrType])throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);return schema.nodes[nameOrType]}return nameOrType}function mergeAttributes(...objects){return objects.filter((item=>!!item)).reduce(((items,item)=>{const mergedAttributes={...items};return Object.entries(item).forEach((([key,value])=>{const exists=mergedAttributes[key];mergedAttributes[key]=exists?"class"===key?[mergedAttributes[key],value].join(" "):"style"===key?[mergedAttributes[key],value].join("; "):value:value})),mergedAttributes}),{})}function getRenderedAttributes(nodeOrMark,extensionAttributes){return extensionAttributes.filter((item=>item.attribute.rendered)).map((item=>item.attribute.renderHTML?item.attribute.renderHTML(nodeOrMark.attrs)||{}:{[item.name]:nodeOrMark.attrs[item.name]})).reduce(((attributes,attribute)=>mergeAttributes(attributes,attribute)),{})}function isFunction$2(value){return"function"===typeof value}
/**
 * Optionally calls `value` as a function.
 * Otherwise it is returned directly.
 * @param value Function or any value.
 * @param context Optional context to bind to function.
 * @param props Optional props to pass to function.
 */function callOrReturn(value,context=void 0,...props){return isFunction$2(value)?context?value.bind(context)(...props):value(...props):value}function isEmptyObject(value={}){return 0===Object.keys(value).length&&value.constructor===Object}function fromString(value){return"string"!==typeof value?value:value.match(/^[+-]?(?:\d*\.)?\d+$/)?Number(value):"true"===value||"false"!==value&&value}
/**
 * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).
 * Cancels when `getAttrs` returned `false`.
 * @param parseRule ProseMirror ParseRule
 * @param extensionAttributes List of attributes to inject
 */function injectExtensionAttributesToParseRule(parseRule,extensionAttributes){return parseRule.style?parseRule:{...parseRule,getAttrs:node=>{const oldAttributes=parseRule.getAttrs?parseRule.getAttrs(node):parseRule.attrs;if(!1===oldAttributes)return!1;const newAttributes=extensionAttributes.reduce(((items,item)=>{const value=item.attribute.parseHTML?item.attribute.parseHTML(node):fromString(node.getAttribute(item.name));return null===value||void 0===value?items:{...items,[item.name]:value}}),{});return{...oldAttributes,...newAttributes}}}}function cleanUpSchemaItem(data){return Object.fromEntries(
// @ts-ignore
Object.entries(data).filter((([key,value])=>("attrs"!==key||!isEmptyObject(value))&&(null!==value&&void 0!==value))))}function getSchemaByResolvedExtensions(extensions,editor){var _a;const allAttributes=getAttributesFromExtensions(extensions),{nodeExtensions:nodeExtensions,markExtensions:markExtensions}=splitExtensions(extensions),topNode=null===(_a=nodeExtensions.find((extension=>getExtensionField(extension,"topNode"))))||void 0===_a?void 0:_a.name,nodes=Object.fromEntries(nodeExtensions.map((extension=>{const extensionAttributes=allAttributes.filter((attribute=>attribute.type===extension.name)),context={name:extension.name,options:extension.options,storage:extension.storage,editor:editor},extraNodeFields=extensions.reduce(((fields,e)=>{const extendNodeSchema=getExtensionField(e,"extendNodeSchema",context);return{...fields,...extendNodeSchema?extendNodeSchema(extension):{}}}),{}),schema=cleanUpSchemaItem({...extraNodeFields,content:callOrReturn(getExtensionField(extension,"content",context)),marks:callOrReturn(getExtensionField(extension,"marks",context)),group:callOrReturn(getExtensionField(extension,"group",context)),inline:callOrReturn(getExtensionField(extension,"inline",context)),atom:callOrReturn(getExtensionField(extension,"atom",context)),selectable:callOrReturn(getExtensionField(extension,"selectable",context)),draggable:callOrReturn(getExtensionField(extension,"draggable",context)),code:callOrReturn(getExtensionField(extension,"code",context)),defining:callOrReturn(getExtensionField(extension,"defining",context)),isolating:callOrReturn(getExtensionField(extension,"isolating",context)),attrs:Object.fromEntries(extensionAttributes.map((extensionAttribute=>{var _a;return[extensionAttribute.name,{default:null===(_a=null===extensionAttribute||void 0===extensionAttribute?void 0:extensionAttribute.attribute)||void 0===_a?void 0:_a.default}]})))}),parseHTML=callOrReturn(getExtensionField(extension,"parseHTML",context));parseHTML&&(schema.parseDOM=parseHTML.map((parseRule=>injectExtensionAttributesToParseRule(parseRule,extensionAttributes))));const renderHTML=getExtensionField(extension,"renderHTML",context);renderHTML&&(schema.toDOM=node=>renderHTML({node:node,HTMLAttributes:getRenderedAttributes(node,extensionAttributes)}));const renderText=getExtensionField(extension,"renderText",context);return renderText&&(schema.toText=renderText),[extension.name,schema]}))),marks=Object.fromEntries(markExtensions.map((extension=>{const extensionAttributes=allAttributes.filter((attribute=>attribute.type===extension.name)),context={name:extension.name,options:extension.options,storage:extension.storage,editor:editor},extraMarkFields=extensions.reduce(((fields,e)=>{const extendMarkSchema=getExtensionField(e,"extendMarkSchema",context);return{...fields,...extendMarkSchema?extendMarkSchema(extension):{}}}),{}),schema=cleanUpSchemaItem({...extraMarkFields,inclusive:callOrReturn(getExtensionField(extension,"inclusive",context)),excludes:callOrReturn(getExtensionField(extension,"excludes",context)),group:callOrReturn(getExtensionField(extension,"group",context)),spanning:callOrReturn(getExtensionField(extension,"spanning",context)),code:callOrReturn(getExtensionField(extension,"code",context)),attrs:Object.fromEntries(extensionAttributes.map((extensionAttribute=>{var _a;return[extensionAttribute.name,{default:null===(_a=null===extensionAttribute||void 0===extensionAttribute?void 0:extensionAttribute.attribute)||void 0===_a?void 0:_a.default}]})))}),parseHTML=callOrReturn(getExtensionField(extension,"parseHTML",context));parseHTML&&(schema.parseDOM=parseHTML.map((parseRule=>injectExtensionAttributesToParseRule(parseRule,extensionAttributes))));const renderHTML=getExtensionField(extension,"renderHTML",context);return renderHTML&&(schema.toDOM=mark=>renderHTML({mark:mark,HTMLAttributes:getRenderedAttributes(mark,extensionAttributes)})),[extension.name,schema]})));return new Schema({topNode:topNode,nodes:nodes,marks:marks})}function getSchemaTypeByName(name,schema){return schema.nodes[name]||schema.marks[name]||null}function isExtensionRulesEnabled(extension,enabled){return Array.isArray(enabled)?enabled.some((enabledExtension=>{const name="string"===typeof enabledExtension?enabledExtension:enabledExtension.name;return name===extension.name})):enabled}const getTextContentFromNodes=($from,maxMatch=500)=>{let textBefore="";const sliceEndPos=$from.parentOffset;return $from.parent.nodesBetween(Math.max(0,sliceEndPos-maxMatch),sliceEndPos,((node,pos,parent,index)=>{var _a,_b;const chunk=(null===(_b=(_a=node.type.spec).toText)||void 0===_b?void 0:_b.call(_a,{node:node,pos:pos,parent:parent,index:index}))||node.textContent||"%leaf%";textBefore+=chunk.slice(0,Math.max(0,sliceEndPos-pos))})),textBefore};function isRegExp(value){return"[object RegExp]"===Object.prototype.toString.call(value)}class InputRule{constructor(config){this.find=config.find,this.handler=config.handler}}const inputRuleMatcherHandler=(text,find)=>{if(isRegExp(find))return find.exec(text);const inputRuleMatch=find(text);if(!inputRuleMatch)return null;const result=[inputRuleMatch.text];return result.index=inputRuleMatch.index,result.input=text,result.data=inputRuleMatch.data,inputRuleMatch.replaceWith&&(inputRuleMatch.text.includes(inputRuleMatch.replaceWith),result.push(inputRuleMatch.replaceWith)),result};function run$1$1(config){var _a;const{editor:editor,from:from,to:to,text:text,rules:rules,plugin:plugin}=config,{view:view}=editor;if(view.composing)return!1;const $from=view.state.doc.resolve(from);if(
// check for code node
$from.parent.type.spec.code||(null===(_a=$from.nodeBefore||$from.nodeAfter)||void 0===_a?void 0:_a.marks.find((mark=>mark.type.spec.code))))return!1;let matched=!1;const textBefore=getTextContentFromNodes($from)+text;return rules.forEach((rule=>{if(matched)return;const match=inputRuleMatcherHandler(textBefore,rule.find);if(!match)return;const tr=view.state.tr,state=createChainableState({state:view.state,transaction:tr}),range={from:from-(match[0].length-text.length),to:to},{commands:commands,chain:chain,can:can}=new CommandManager({editor:editor,state:state}),handler=rule.handler({state:state,range:range,match:match,commands:commands,chain:chain,can:can});
// stop if there are no changes
null!==handler&&tr.steps.length&&(
// store transform as meta data
// so we can undo input rules within the `undoInputRules` command
tr.setMeta(plugin,{transform:tr,from:from,to:to,text:text}),view.dispatch(tr),matched=!0)})),matched}
/**
 * Create an input rules plugin. When enabled, it will cause text
 * input that matches any of the given rules to trigger the rule’s
 * action.
 */function inputRulesPlugin(props){const{editor:editor,rules:rules}=props,plugin=new Plugin({state:{init(){return null},apply(tr,prev){const stored=tr.getMeta(plugin);return stored||(tr.selectionSet||tr.docChanged?null:prev)}},props:{handleTextInput(view,from,to,text){return run$1$1({editor:editor,from:from,to:to,text:text,rules:rules,plugin:plugin})},handleDOMEvents:{compositionend:view=>(setTimeout((()=>{const{$cursor:$cursor}=view.state.selection;$cursor&&run$1$1({editor:editor,from:$cursor.pos,to:$cursor.pos,text:"",rules:rules,plugin:plugin})})),!1)},
// add support for input rules to trigger on enter
// this is useful for example for code blocks
handleKeyDown(view,event){if("Enter"!==event.key)return!1;const{$cursor:$cursor}=view.state.selection;return!!$cursor&&run$1$1({editor:editor,from:$cursor.pos,to:$cursor.pos,text:"\n",rules:rules,plugin:plugin})}},
// @ts-ignore
isInputRules:!0});return plugin}function isNumber(value){return"number"===typeof value}class PasteRule{constructor(config){this.find=config.find,this.handler=config.handler}}const pasteRuleMatcherHandler=(text,find)=>{if(isRegExp(find))return[...text.matchAll(find)];const matches=find(text);return matches?matches.map((pasteRuleMatch=>{const result=[pasteRuleMatch.text];return result.index=pasteRuleMatch.index,result.input=text,result.data=pasteRuleMatch.data,pasteRuleMatch.replaceWith&&(pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith),result.push(pasteRuleMatch.replaceWith)),result})):[]};function run$2(config){const{editor:editor,state:state,from:from,to:to,rule:rule}=config,{commands:commands,chain:chain,can:can}=new CommandManager({editor:editor,state:state}),handlers=[];state.doc.nodesBetween(from,to,((node,pos)=>{if(!node.isTextblock||node.type.spec.code)return;const resolvedFrom=Math.max(from,pos),resolvedTo=Math.min(to,pos+node.content.size),textToMatch=node.textBetween(resolvedFrom-pos,resolvedTo-pos,void 0,"￼"),matches=pasteRuleMatcherHandler(textToMatch,rule.find);matches.forEach((match=>{if(void 0===match.index)return;const start=resolvedFrom+match.index+1,end=start+match[0].length,range={from:state.tr.mapping.map(start),to:state.tr.mapping.map(end)},handler=rule.handler({state:state,range:range,match:match,commands:commands,chain:chain,can:can});handlers.push(handler)}))}));const success=handlers.every((handler=>null!==handler));return success}
/**
 * Create an paste rules plugin. When enabled, it will cause pasted
 * text that matches any of the given rules to trigger the rule’s
 * action.
 */function pasteRulesPlugin(props){const{editor:editor,rules:rules}=props;let dragSourceElement=null,isPastedFromProseMirror=!1,isDroppedFromProseMirror=!1;const plugins=rules.map((rule=>new Plugin({
// we register a global drag handler to track the current drag source element
view(view){const handleDragstart=event=>{var _a;dragSourceElement=(null===(_a=view.dom.parentElement)||void 0===_a?void 0:_a.contains(event.target))?view.dom.parentElement:null};return window.addEventListener("dragstart",handleDragstart),{destroy(){window.removeEventListener("dragstart",handleDragstart)}}},props:{handleDOMEvents:{drop:view=>(isDroppedFromProseMirror=dragSourceElement===view.dom.parentElement,!1),paste:(view,event)=>{var _a;const html=null===(_a=event.clipboardData)||void 0===_a?void 0:_a.getData("text/html");return isPastedFromProseMirror=!!(null===html||void 0===html?void 0:html.includes("data-pm-slice")),!1}}},appendTransaction:(transactions,oldState,state)=>{const transaction=transactions[0],isPaste="paste"===transaction.getMeta("uiEvent")&&!isPastedFromProseMirror,isDrop="drop"===transaction.getMeta("uiEvent")&&!isDroppedFromProseMirror;if(!isPaste&&!isDrop)return;
// stop if there is no changed range
const from=oldState.doc.content.findDiffStart(state.doc.content),to=oldState.doc.content.findDiffEnd(state.doc.content);if(!isNumber(from)||!to||from===to.b)return;
// build a chainable state
// so we can use a single transaction for all paste rules
const tr=state.tr,chainableState=createChainableState({state:state,transaction:tr}),handler=run$2({editor:editor,state:chainableState,from:Math.max(from-1,0),to:to.b-1,rule:rule});
// stop if there are no changes
return handler&&tr.steps.length?tr:void 0}})));return plugins}function findDuplicates(items){const filtered=items.filter(((el,index)=>items.indexOf(el)!==index));return[...new Set(filtered)]}class ExtensionManager{constructor(extensions,editor){this.splittableMarks=[],this.editor=editor,this.extensions=ExtensionManager.resolve(extensions),this.schema=getSchemaByResolvedExtensions(this.extensions,editor),this.extensions.forEach((extension=>{var _a;
// store extension storage in editor
this.editor.extensionStorage[extension.name]=extension.storage;const context={name:extension.name,options:extension.options,storage:extension.storage,editor:this.editor,type:getSchemaTypeByName(extension.name,this.schema)};if("mark"===extension.type){const keepOnSplit=null===(_a=callOrReturn(getExtensionField(extension,"keepOnSplit",context)))||void 0===_a||_a;keepOnSplit&&this.splittableMarks.push(extension.name)}const onBeforeCreate=getExtensionField(extension,"onBeforeCreate",context);onBeforeCreate&&this.editor.on("beforeCreate",onBeforeCreate);const onCreate=getExtensionField(extension,"onCreate",context);onCreate&&this.editor.on("create",onCreate);const onUpdate=getExtensionField(extension,"onUpdate",context);onUpdate&&this.editor.on("update",onUpdate);const onSelectionUpdate=getExtensionField(extension,"onSelectionUpdate",context);onSelectionUpdate&&this.editor.on("selectionUpdate",onSelectionUpdate);const onTransaction=getExtensionField(extension,"onTransaction",context);onTransaction&&this.editor.on("transaction",onTransaction);const onFocus=getExtensionField(extension,"onFocus",context);onFocus&&this.editor.on("focus",onFocus);const onBlur=getExtensionField(extension,"onBlur",context);onBlur&&this.editor.on("blur",onBlur);const onDestroy=getExtensionField(extension,"onDestroy",context);onDestroy&&this.editor.on("destroy",onDestroy)}))}static resolve(extensions){const resolvedExtensions=ExtensionManager.sort(ExtensionManager.flatten(extensions)),duplicatedNames=findDuplicates(resolvedExtensions.map((extension=>extension.name)));return duplicatedNames.length,resolvedExtensions}static flatten(extensions){return extensions.map((extension=>{const context={name:extension.name,options:extension.options,storage:extension.storage},addExtensions=getExtensionField(extension,"addExtensions",context);return addExtensions?[extension,...this.flatten(addExtensions())]:extension})).flat(10)}static sort(extensions){const defaultPriority=100;return extensions.sort(((a,b)=>{const priorityA=getExtensionField(a,"priority")||defaultPriority,priorityB=getExtensionField(b,"priority")||defaultPriority;return priorityA>priorityB?-1:priorityA<priorityB?1:0}))}get commands(){return this.extensions.reduce(((commands,extension)=>{const context={name:extension.name,options:extension.options,storage:extension.storage,editor:this.editor,type:getSchemaTypeByName(extension.name,this.schema)},addCommands=getExtensionField(extension,"addCommands",context);return addCommands?{...commands,...addCommands()}:commands}),{})}get plugins(){const{editor:editor}=this,extensions=ExtensionManager.sort([...this.extensions].reverse()),inputRules=[],pasteRules=[],allPlugins=extensions.map((extension=>{const context={name:extension.name,options:extension.options,storage:extension.storage,editor:editor,type:getSchemaTypeByName(extension.name,this.schema)},plugins=[],addKeyboardShortcuts=getExtensionField(extension,"addKeyboardShortcuts",context);let defaultBindings={};
// bind exit handling
if("mark"===extension.type&&extension.config.exitable&&(defaultBindings.ArrowRight=()=>Mark.handleExit({editor:editor,mark:extension})),addKeyboardShortcuts){const bindings=Object.fromEntries(Object.entries(addKeyboardShortcuts()).map((([shortcut,method])=>[shortcut,()=>method({editor:editor})])));defaultBindings={...defaultBindings,...bindings}}const keyMapPlugin=keymap(defaultBindings);plugins.push(keyMapPlugin);const addInputRules=getExtensionField(extension,"addInputRules",context);isExtensionRulesEnabled(extension,editor.options.enableInputRules)&&addInputRules&&inputRules.push(...addInputRules());const addPasteRules=getExtensionField(extension,"addPasteRules",context);isExtensionRulesEnabled(extension,editor.options.enablePasteRules)&&addPasteRules&&pasteRules.push(...addPasteRules());const addProseMirrorPlugins=getExtensionField(extension,"addProseMirrorPlugins",context);if(addProseMirrorPlugins){const proseMirrorPlugins=addProseMirrorPlugins();plugins.push(...proseMirrorPlugins)}return plugins})).flat();
// With ProseMirror, first plugins within an array are executed first.
// In Tiptap, we provide the ability to override plugins,
// so it feels more natural to run plugins at the end of an array first.
// That’s why we have to reverse the `extensions` array and sort again
// based on the `priority` option.
return[inputRulesPlugin({editor:editor,rules:inputRules}),...pasteRulesPlugin({editor:editor,rules:pasteRules}),...allPlugins]}get attributes(){return getAttributesFromExtensions(this.extensions)}get nodeViews(){const{editor:editor}=this,{nodeExtensions:nodeExtensions}=splitExtensions(this.extensions);return Object.fromEntries(nodeExtensions.filter((extension=>!!getExtensionField(extension,"addNodeView"))).map((extension=>{const extensionAttributes=this.attributes.filter((attribute=>attribute.type===extension.name)),context={name:extension.name,options:extension.options,storage:extension.storage,editor:editor,type:getNodeType(extension.name,this.schema)},addNodeView=getExtensionField(extension,"addNodeView",context);if(!addNodeView)return[];const nodeview=(node,view,getPos,decorations)=>{const HTMLAttributes=getRenderedAttributes(node,extensionAttributes);return addNodeView()({editor:editor,node:node,getPos:getPos,decorations:decorations,HTMLAttributes:HTMLAttributes,extension:extension})};return[extension.name,nodeview]})))}}
// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts
function getType(value){return Object.prototype.toString.call(value).slice(8,-1)}function isPlainObject(value){return"Object"===getType(value)&&(value.constructor===Object&&Object.getPrototypeOf(value)===Object.prototype)}function mergeDeep(target,source){const output={...target};return isPlainObject(target)&&isPlainObject(source)&&Object.keys(source).forEach((key=>{isPlainObject(source[key])?key in target?output[key]=mergeDeep(target[key],source[key]):Object.assign(output,{[key]:source[key]}):Object.assign(output,{[key]:source[key]})})),output}class Extension{constructor(config={}){this.type="extension",this.name="extension",this.parent=null,this.child=null,this.config={name:this.name,defaultOptions:{}},this.config={...this.config,...config},this.name=this.config.name,config.defaultOptions,
// TODO: remove `addOptions` fallback
this.options=this.config.defaultOptions,this.config.addOptions&&(this.options=callOrReturn(getExtensionField(this,"addOptions",{name:this.name}))),this.storage=callOrReturn(getExtensionField(this,"addStorage",{name:this.name,options:this.options}))||{}}static create(config={}){return new Extension(config)}configure(options={}){
// return a new instance so we can use the same extension
// with different calls of `configure`
const extension=this.extend();return extension.options=mergeDeep(this.options,options),extension.storage=callOrReturn(getExtensionField(extension,"addStorage",{name:extension.name,options:extension.options})),extension}extend(extendedConfig={}){const extension=new Extension(extendedConfig);return extension.parent=this,this.child=extension,extension.name=extendedConfig.name?extendedConfig.name:extension.parent.name,extendedConfig.defaultOptions,extension.options=callOrReturn(getExtensionField(extension,"addOptions",{name:extension.name})),extension.storage=callOrReturn(getExtensionField(extension,"addStorage",{name:extension.name,options:extension.options})),extension}}function getTextBetween(startNode,range,options){const{from:from,to:to}=range,{blockSeparator:blockSeparator="\n\n",textSerializers:textSerializers={}}=options||{};let text="",separated=!0;return startNode.nodesBetween(from,to,((node,pos,parent,index)=>{var _a;const textSerializer=null===textSerializers||void 0===textSerializers?void 0:textSerializers[node.type.name];textSerializer?(node.isBlock&&!separated&&(text+=blockSeparator,separated=!0),parent&&(text+=textSerializer({node:node,pos:pos,parent:parent,index:index,range:range}))):node.isText?(text+=null===(_a=null===node||void 0===node?void 0:node.text)||void 0===_a?void 0:_a.slice(Math.max(from,pos)-pos,to-pos),// eslint-disable-line
separated=!1):node.isBlock&&!separated&&(text+=blockSeparator,separated=!0)})),text}function getTextSerializersFromSchema(schema){return Object.fromEntries(Object.entries(schema.nodes).filter((([,node])=>node.spec.toText)).map((([name,node])=>[name,node.spec.toText])))}const ClipboardTextSerializer=Extension.create({name:"clipboardTextSerializer",addProseMirrorPlugins(){return[new Plugin({key:new PluginKey("clipboardTextSerializer"),props:{clipboardTextSerializer:()=>{const{editor:editor}=this,{state:state,schema:schema}=editor,{doc:doc,selection:selection}=state,{ranges:ranges}=selection,from=Math.min(...ranges.map((range=>range.$from.pos))),to=Math.max(...ranges.map((range=>range.$to.pos))),textSerializers=getTextSerializersFromSchema(schema),range={from:from,to:to};return getTextBetween(doc,range,{textSerializers:textSerializers})}}})]}}),forms_blur=()=>({editor:editor,view:view})=>(requestAnimationFrame((()=>{var _a;editor.isDestroyed||(view.dom.blur(),
// Browsers should remove the caret on blur but safari does not.
// See: https://github.com/ueberdosis/tiptap/issues/2405
null===(_a=null===window||void 0===window?void 0:window.getSelection())||void 0===_a||_a.removeAllRanges())})),!0),clearContent=(emitUpdate=!1)=>({commands:commands})=>commands.setContent("",emitUpdate),clearNodes=()=>({state:state,tr:tr,dispatch:dispatch})=>{const{selection:selection}=tr,{ranges:ranges}=selection;return!dispatch||(ranges.forEach((({$from:$from,$to:$to})=>{state.doc.nodesBetween($from.pos,$to.pos,((node,pos)=>{if(node.type.isText)return;const{doc:doc,mapping:mapping}=tr,$mappedFrom=doc.resolve(mapping.map(pos)),$mappedTo=doc.resolve(mapping.map(pos+node.nodeSize)),nodeRange=$mappedFrom.blockRange($mappedTo);if(!nodeRange)return;const targetLiftDepth=liftTarget(nodeRange);if(node.type.isTextblock){const{defaultType:defaultType}=$mappedFrom.parent.contentMatchAt($mappedFrom.index());tr.setNodeMarkup(nodeRange.start,defaultType)}(targetLiftDepth||0===targetLiftDepth)&&tr.lift(nodeRange,targetLiftDepth)}))})),!0)},command=fn=>props=>fn(props),createParagraphNear=()=>({state:state,dispatch:dispatch})=>createParagraphNear$1(state,dispatch),deleteCurrentNode=()=>({tr:tr,dispatch:dispatch})=>{const{selection:selection}=tr,currentNode=selection.$anchor.node();
// if there is content inside the current node, break out of this command
if(currentNode.content.size>0)return!1;const $pos=tr.selection.$anchor;for(let depth=$pos.depth;depth>0;depth-=1){const node=$pos.node(depth);if(node.type===currentNode.type){if(dispatch){const from=$pos.before(depth),to=$pos.after(depth);tr.delete(from,to).scrollIntoView()}return!0}}return!1},deleteNode=typeOrName=>({tr:tr,state:state,dispatch:dispatch})=>{const type=getNodeType(typeOrName,state.schema),$pos=tr.selection.$anchor;for(let depth=$pos.depth;depth>0;depth-=1){const node=$pos.node(depth);if(node.type===type){if(dispatch){const from=$pos.before(depth),to=$pos.after(depth);tr.delete(from,to).scrollIntoView()}return!0}}return!1},deleteRange=range=>({tr:tr,dispatch:dispatch})=>{const{from:from,to:to}=range;return dispatch&&tr.delete(from,to),!0},deleteSelection=()=>({state:state,dispatch:dispatch})=>deleteSelection$1(state,dispatch),enter=()=>({commands:commands})=>commands.keyboardShortcut("Enter"),exitCode=()=>({state:state,dispatch:dispatch})=>exitCode$1(state,dispatch)
/**
 * Check if object1 includes object2
 * @param object1 Object
 * @param object2 Object
 */;function objectIncludes(object1,object2,options={strict:!0}){const keys=Object.keys(object2);return!keys.length||keys.every((key=>options.strict?object2[key]===object1[key]:isRegExp(object2[key])?object2[key].test(object1[key]):object2[key]===object1[key]))}function findMarkInSet(marks,type,attributes={}){return marks.find((item=>item.type===type&&objectIncludes(item.attrs,attributes)))}function isMarkInSet(marks,type,attributes={}){return!!findMarkInSet(marks,type,attributes)}function getMarkRange($pos,type,attributes={}){if(!$pos||!type)return;let start=$pos.parent.childAfter($pos.parentOffset);if($pos.parentOffset===start.offset&&0!==start.offset&&(start=$pos.parent.childBefore($pos.parentOffset)),!start.node)return;const mark=findMarkInSet([...start.node.marks],type,attributes);if(!mark)return;let startIndex=start.index,startPos=$pos.start()+start.offset,endIndex=startIndex+1,endPos=startPos+start.node.nodeSize;findMarkInSet([...start.node.marks],type,attributes);while(startIndex>0&&mark.isInSet($pos.parent.child(startIndex-1).marks))startIndex-=1,startPos-=$pos.parent.child(startIndex).nodeSize;while(endIndex<$pos.parent.childCount&&isMarkInSet([...$pos.parent.child(endIndex).marks],type,attributes))endPos+=$pos.parent.child(endIndex).nodeSize,endIndex+=1;return{from:startPos,to:endPos}}function getMarkType(nameOrType,schema){if("string"===typeof nameOrType){if(!schema.marks[nameOrType])throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);return schema.marks[nameOrType]}return nameOrType}const extendMarkRange=(typeOrName,attributes={})=>({tr:tr,state:state,dispatch:dispatch})=>{const type=getMarkType(typeOrName,state.schema),{doc:doc,selection:selection}=tr,{$from:$from,from:from,to:to}=selection;if(dispatch){const range=getMarkRange($from,type,attributes);if(range&&range.from<=from&&range.to>=to){const newSelection=TextSelection.create(doc,range.from,range.to);tr.setSelection(newSelection)}}return!0},first=commands=>props=>{const items="function"===typeof commands?commands(props):commands;for(let i=0;i<items.length;i+=1)if(items[i](props))return!0;return!1};function isTextSelection(value){return value instanceof TextSelection}function minMax(value=0,min=0,max=0){return Math.min(Math.max(value,min),max)}function resolveFocusPosition(doc,position=null){if(!position)return null;const selectionAtStart=Selection.atStart(doc),selectionAtEnd=Selection.atEnd(doc);if("start"===position||!0===position)return selectionAtStart;if("end"===position)return selectionAtEnd;const minPos=selectionAtStart.from,maxPos=selectionAtEnd.to;return"all"===position?TextSelection.create(doc,minMax(0,minPos,maxPos),minMax(doc.content.size,minPos,maxPos)):TextSelection.create(doc,minMax(position,minPos,maxPos),minMax(position,minPos,maxPos))}function isiOS(){return["iPad Simulator","iPhone Simulator","iPod Simulator","iPad","iPhone","iPod"].includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document}const forms_focus=(position=null,options={})=>({editor:editor,view:view,tr:tr,dispatch:dispatch})=>{options={scrollIntoView:!0,...options};const delayedFocus=()=>{
// focus within `requestAnimationFrame` breaks focus on iOS
// so we have to call this
isiOS()&&view.dom.focus(),
// For React we have to focus asynchronously. Otherwise wild things happen.
// see: https://github.com/ueberdosis/tiptap/issues/1520
requestAnimationFrame((()=>{editor.isDestroyed||(view.focus(),(null===options||void 0===options?void 0:options.scrollIntoView)&&editor.commands.scrollIntoView())}))};if(view.hasFocus()&&null===position||!1===position)return!0;
// we don’t try to resolve a NodeSelection or CellSelection
if(dispatch&&null===position&&!isTextSelection(editor.state.selection))return delayedFocus(),!0;
// pass through tr.doc instead of editor.state.doc
// since transactions could change the editors state before this command has been run
const selection=resolveFocusPosition(tr.doc,position)||editor.state.selection,isSameSelection=editor.state.selection.eq(selection);return dispatch&&(isSameSelection||tr.setSelection(selection),
// `tr.setSelection` resets the stored marks
// so we’ll restore them if the selection is the same as before
isSameSelection&&tr.storedMarks&&tr.setStoredMarks(tr.storedMarks),delayedFocus()),!0},forEach=(items,fn)=>props=>items.every(((item,index)=>fn(item,{...props,index:index}))),insertContent=(value,options)=>({tr:tr,commands:commands})=>commands.insertContentAt({from:tr.selection.from,to:tr.selection.to},value,options);function elementFromString(value){
// add a wrapper to preserve leading and trailing whitespace
const wrappedValue=`<body>${value}</body>`;return(new window.DOMParser).parseFromString(wrappedValue,"text/html").body}function createNodeFromContent(content,schema,options){if(options={slice:!0,parseOptions:{},...options},"object"===typeof content&&null!==content)try{return Array.isArray(content)&&content.length>0?Fragment.fromArray(content.map((item=>schema.nodeFromJSON(item)))):schema.nodeFromJSON(content)}catch(error){return createNodeFromContent("",schema,options)}if("string"===typeof content){const parser=DOMParser$1.fromSchema(schema);return options.slice?parser.parseSlice(elementFromString(content),options.parseOptions).content:parser.parse(elementFromString(content),options.parseOptions)}return createNodeFromContent("",schema,options)}
// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466
function selectionToInsertionEnd(tr,startLen,bias){const last=tr.steps.length-1;if(last<startLen)return;const step=tr.steps[last];if(!(step instanceof ReplaceStep||step instanceof ReplaceAroundStep))return;const map=tr.mapping.maps[last];let end=0;map.forEach(((_from,_to,_newFrom,newTo)=>{0===end&&(end=newTo)})),tr.setSelection(Selection.near(tr.doc.resolve(end),bias))}const isFragment=nodeOrFragment=>nodeOrFragment.toString().startsWith("<"),insertContentAt=(position,value,options)=>({tr:tr,dispatch:dispatch,editor:editor})=>{if(dispatch){options={parseOptions:{},updateSelection:!0,...options};const content=createNodeFromContent(value,editor.schema,{parseOptions:{preserveWhitespace:"full",...options.parseOptions}});
// don’t dispatch an empty fragment because this can lead to strange errors
if("<>"===content.toString())return!0;let{from:from,to:to}="number"===typeof position?{from:position,to:position}:position,isOnlyTextContent=!0,isOnlyBlockContent=!0;const nodes=isFragment(content)?content:[content];
// check if we can replace the wrapping node by
// the newly inserted content
// example:
// replace an empty paragraph by an inserted image
// instead of inserting the image below the paragraph
if(nodes.forEach((node=>{
// check if added node is valid
node.check(),isOnlyTextContent=!!isOnlyTextContent&&(node.isText&&0===node.marks.length),isOnlyBlockContent=!!isOnlyBlockContent&&node.isBlock})),from===to&&isOnlyBlockContent){const{parent:parent}=tr.doc.resolve(from),isEmptyTextBlock=parent.isTextblock&&!parent.type.spec.code&&!parent.childCount;isEmptyTextBlock&&(from-=1,to+=1)}
// if there is only plain text we have to use `insertText`
// because this will keep the current marks
isOnlyTextContent?
// if value is string, we can use it directly
// otherwise if it is an array, we have to join it
Array.isArray(value)?tr.insertText(value.map((v=>v.text||"")).join(""),from,to):"object"===typeof value&&value&&value.text?tr.insertText(value.text,from,to):tr.insertText(value,from,to):tr.replaceWith(from,to,content),
// set cursor at end of inserted content
options.updateSelection&&selectionToInsertionEnd(tr,tr.steps.length-1,-1)}return!0},joinUp=()=>({state:state,dispatch:dispatch})=>joinUp$1(state,dispatch),joinDown=()=>({state:state,dispatch:dispatch})=>joinDown$1(state,dispatch),joinBackward=()=>({state:state,dispatch:dispatch})=>joinBackward$1(state,dispatch),joinForward=()=>({state:state,dispatch:dispatch})=>joinForward$1(state,dispatch);function isMacOS(){return"undefined"!==typeof navigator&&/Mac/.test(navigator.platform)}function normalizeKeyName(name){const parts=name.split(/-(?!$)/);let alt,ctrl,shift,meta,result=parts[parts.length-1];"Space"===result&&(result=" ");for(let i=0;i<parts.length-1;i+=1){const mod=parts[i];if(/^(cmd|meta|m)$/i.test(mod))meta=!0;else if(/^a(lt)?$/i.test(mod))alt=!0;else if(/^(c|ctrl|control)$/i.test(mod))ctrl=!0;else if(/^s(hift)?$/i.test(mod))shift=!0;else{if(!/^mod$/i.test(mod))throw new Error(`Unrecognized modifier name: ${mod}`);isiOS()||isMacOS()?meta=!0:ctrl=!0}}return alt&&(result=`Alt-${result}`),ctrl&&(result=`Ctrl-${result}`),meta&&(result=`Meta-${result}`),shift&&(result=`Shift-${result}`),result}const keyboardShortcut=name=>({editor:editor,view:view,tr:tr,dispatch:dispatch})=>{const keys=normalizeKeyName(name).split(/-(?!$)/),key=keys.find((item=>!["Alt","Ctrl","Meta","Shift"].includes(item))),event=new KeyboardEvent("keydown",{key:"Space"===key?" ":key,altKey:keys.includes("Alt"),ctrlKey:keys.includes("Ctrl"),metaKey:keys.includes("Meta"),shiftKey:keys.includes("Shift"),bubbles:!0,cancelable:!0}),capturedTransaction=editor.captureTransaction((()=>{view.someProp("handleKeyDown",(f=>f(view,event)))}));return null===capturedTransaction||void 0===capturedTransaction||capturedTransaction.steps.forEach((step=>{const newStep=step.map(tr.mapping);newStep&&dispatch&&tr.maybeStep(newStep)})),!0};function isNodeActive(state,typeOrName,attributes={}){const{from:from,to:to,empty:empty}=state.selection,type=typeOrName?getNodeType(typeOrName,state.schema):null,nodeRanges=[];state.doc.nodesBetween(from,to,((node,pos)=>{if(node.isText)return;const relativeFrom=Math.max(from,pos),relativeTo=Math.min(to,pos+node.nodeSize);nodeRanges.push({node:node,from:relativeFrom,to:relativeTo})}));const selectionRange=to-from,matchedNodeRanges=nodeRanges.filter((nodeRange=>!type||type.name===nodeRange.node.type.name)).filter((nodeRange=>objectIncludes(nodeRange.node.attrs,attributes,{strict:!1})));if(empty)return!!matchedNodeRanges.length;const range=matchedNodeRanges.reduce(((sum,nodeRange)=>sum+nodeRange.to-nodeRange.from),0);return range>=selectionRange}const lift=(typeOrName,attributes={})=>({state:state,dispatch:dispatch})=>{const type=getNodeType(typeOrName,state.schema),isActive=isNodeActive(state,type,attributes);return!!isActive&&lift$1(state,dispatch)},liftEmptyBlock=()=>({state:state,dispatch:dispatch})=>liftEmptyBlock$1(state,dispatch),liftListItem=typeOrName=>({state:state,dispatch:dispatch})=>{const type=getNodeType(typeOrName,state.schema);return liftListItem$1(type)(state,dispatch)},newlineInCode=()=>({state:state,dispatch:dispatch})=>newlineInCode$1(state,dispatch);function getSchemaTypeNameByName(name,schema){return schema.nodes[name]?"node":schema.marks[name]?"mark":null}
/**
 * Remove a property or an array of properties from an object
 * @param obj Object
 * @param key Key to remove
 */function deleteProps(obj,propOrProps){const props="string"===typeof propOrProps?[propOrProps]:propOrProps;return Object.keys(obj).reduce(((newObj,prop)=>(props.includes(prop)||(newObj[prop]=obj[prop]),newObj)),{})}const resetAttributes=(typeOrName,attributes)=>({tr:tr,state:state,dispatch:dispatch})=>{let nodeType=null,markType=null;const schemaType=getSchemaTypeNameByName("string"===typeof typeOrName?typeOrName:typeOrName.name,state.schema);return!!schemaType&&("node"===schemaType&&(nodeType=getNodeType(typeOrName,state.schema)),"mark"===schemaType&&(markType=getMarkType(typeOrName,state.schema)),dispatch&&tr.selection.ranges.forEach((range=>{state.doc.nodesBetween(range.$from.pos,range.$to.pos,((node,pos)=>{nodeType&&nodeType===node.type&&tr.setNodeMarkup(pos,void 0,deleteProps(node.attrs,attributes)),markType&&node.marks.length&&node.marks.forEach((mark=>{markType===mark.type&&tr.addMark(pos,pos+node.nodeSize,markType.create(deleteProps(mark.attrs,attributes)))}))}))})),!0)},scrollIntoView=()=>({tr:tr,dispatch:dispatch})=>(dispatch&&tr.scrollIntoView(),!0),selectAll=()=>({tr:tr,commands:commands})=>commands.setTextSelection({from:0,to:tr.doc.content.size}),selectNodeBackward=()=>({state:state,dispatch:dispatch})=>selectNodeBackward$1(state,dispatch),selectNodeForward=()=>({state:state,dispatch:dispatch})=>selectNodeForward$1(state,dispatch),selectParentNode=()=>({state:state,dispatch:dispatch})=>selectParentNode$1(state,dispatch)
// @ts-ignore
,selectTextblockEnd=()=>({state:state,dispatch:dispatch})=>selectTextblockEnd$1(state,dispatch)
// @ts-ignore
,selectTextblockStart=()=>({state:state,dispatch:dispatch})=>selectTextblockStart$1(state,dispatch);function createDocument(content,schema,parseOptions={}){return createNodeFromContent(content,schema,{slice:!1,parseOptions:parseOptions})}const setContent$1=(content,emitUpdate=!1,parseOptions={})=>({tr:tr,editor:editor,dispatch:dispatch})=>{const{doc:doc}=tr,document=createDocument(content,editor.schema,parseOptions);return dispatch&&tr.replaceWith(0,doc.content.size,document).setMeta("preventUpdate",!emitUpdate),!0}
/**
 * Returns a new `Transform` based on all steps of the passed transactions.
 */;function combineTransactionSteps(oldDoc,transactions){const transform=new Transform(oldDoc);return transactions.forEach((transaction=>{transaction.steps.forEach((step=>{transform.step(step)}))})),transform}function defaultBlockAt(match){for(let i=0;i<match.edgeCount;i+=1){const{type:type}=match.edge(i);if(type.isTextblock&&!type.hasRequiredAttrs())return type}return null}
/**
 * Same as `findChildren` but searches only within a `range`.
 */function findChildrenInRange(node,range,predicate){const nodesWithPos=[];
// if (range.from === range.to) {
//   const nodeAt = node.nodeAt(range.from)
//   if (nodeAt) {
//     nodesWithPos.push({
//       node: nodeAt,
//       pos: range.from,
//     })
//   }
// }
return node.nodesBetween(range.from,range.to,((child,pos)=>{predicate(child)&&nodesWithPos.push({node:child,pos:pos})})),nodesWithPos}function findParentNodeClosestToPos($pos,predicate){for(let i=$pos.depth;i>0;i-=1){const node=$pos.node(i);if(predicate(node))return{pos:i>0?$pos.before(i):0,start:$pos.start(i),depth:i,node:node}}}function findParentNode(predicate){return selection=>findParentNodeClosestToPos(selection.$from,predicate)}function getHTMLFromFragment(fragment,schema){const documentFragment=DOMSerializer.fromSchema(schema).serializeFragment(fragment),temporaryDocument=document.implementation.createHTMLDocument(),container=temporaryDocument.createElement("div");return container.appendChild(documentFragment),container.innerHTML}function getText(node,options){const range={from:0,to:node.content.size};return getTextBetween(node,range,options)}function getMarkAttributes(state,typeOrName){const type=getMarkType(typeOrName,state.schema),{from:from,to:to,empty:empty}=state.selection,marks=[];empty?(state.storedMarks&&marks.push(...state.storedMarks),marks.push(...state.selection.$head.marks())):state.doc.nodesBetween(from,to,(node=>{marks.push(...node.marks)}));const mark=marks.find((markItem=>markItem.type.name===type.name));return mark?{...mark.attrs}:{}}function getNodeAttributes(state,typeOrName){const type=getNodeType(typeOrName,state.schema),{from:from,to:to}=state.selection,nodes=[];state.doc.nodesBetween(from,to,(node=>{nodes.push(node)}));const node=nodes.reverse().find((nodeItem=>nodeItem.type.name===type.name));return node?{...node.attrs}:{}}function getAttributes(state,typeOrName){const schemaType=getSchemaTypeNameByName("string"===typeof typeOrName?typeOrName:typeOrName.name,state.schema);return"node"===schemaType?getNodeAttributes(state,typeOrName):"mark"===schemaType?getMarkAttributes(state,typeOrName):{}}
/**
 * Removes duplicated values within an array.
 * Supports numbers, strings and objects.
 */function removeDuplicates(array,by=JSON.stringify){const seen={};return array.filter((item=>{const key=by(item);return!Object.prototype.hasOwnProperty.call(seen,key)&&(seen[key]=!0)}))}
/**
 * Removes duplicated ranges and ranges that are
 * fully captured by other ranges.
 */function simplifyChangedRanges(changes){const uniqueChanges=removeDuplicates(changes);return 1===uniqueChanges.length?uniqueChanges:uniqueChanges.filter(((change,index)=>{const rest=uniqueChanges.filter(((_,i)=>i!==index));return!rest.some((otherChange=>change.oldRange.from>=otherChange.oldRange.from&&change.oldRange.to<=otherChange.oldRange.to&&change.newRange.from>=otherChange.newRange.from&&change.newRange.to<=otherChange.newRange.to))}))}
/**
 * Returns a list of changed ranges
 * based on the first and last state of all steps.
 */function getChangedRanges(transform){const{mapping:mapping,steps:steps}=transform,changes=[];return mapping.maps.forEach(((stepMap,index)=>{const ranges=[];
// This accounts for step changes where no range was actually altered
// e.g. when setting a mark, node attribute, etc.
// @ts-ignore
if(stepMap.ranges.length)stepMap.forEach(((from,to)=>{ranges.push({from:from,to:to})}));else{const{from:from,to:to}=steps[index];if(void 0===from||void 0===to)return;ranges.push({from:from,to:to})}ranges.forEach((({from:from,to:to})=>{const newStart=mapping.slice(index).map(from,-1),newEnd=mapping.slice(index).map(to),oldStart=mapping.invert().map(newStart,-1),oldEnd=mapping.invert().map(newEnd);changes.push({oldRange:{from:oldStart,to:oldEnd},newRange:{from:newStart,to:newEnd}})}))})),simplifyChangedRanges(changes)}function getMarksBetween(from,to,doc){const marks=[];
// get all inclusive marks on empty selection
return from===to?doc.resolve(from).marks().forEach((mark=>{const $pos=doc.resolve(from-1),range=getMarkRange($pos,mark.type);range&&marks.push({mark:mark,...range})})):doc.nodesBetween(from,to,((node,pos)=>{marks.push(...node.marks.map((mark=>({from:pos,to:pos+node.nodeSize,mark:mark}))))})),marks}function getSplittedAttributes(extensionAttributes,typeName,attributes){return Object.fromEntries(Object.entries(attributes).filter((([name])=>{const extensionAttribute=extensionAttributes.find((item=>item.type===typeName&&item.name===name));return!!extensionAttribute&&extensionAttribute.attribute.keepOnSplit})))}function isMarkActive(state,typeOrName,attributes={}){const{empty:empty,ranges:ranges}=state.selection,type=typeOrName?getMarkType(typeOrName,state.schema):null;if(empty)return!!(state.storedMarks||state.selection.$from.marks()).filter((mark=>!type||type.name===mark.type.name)).find((mark=>objectIncludes(mark.attrs,attributes,{strict:!1})));let selectionRange=0;const markRanges=[];if(ranges.forEach((({$from:$from,$to:$to})=>{const from=$from.pos,to=$to.pos;state.doc.nodesBetween(from,to,((node,pos)=>{if(!node.isText&&!node.marks.length)return;const relativeFrom=Math.max(from,pos),relativeTo=Math.min(to,pos+node.nodeSize),range=relativeTo-relativeFrom;selectionRange+=range,markRanges.push(...node.marks.map((mark=>({mark:mark,from:relativeFrom,to:relativeTo}))))}))})),0===selectionRange)return!1;
// calculate range of matched mark
const matchedRange=markRanges.filter((markRange=>!type||type.name===markRange.mark.type.name)).filter((markRange=>objectIncludes(markRange.mark.attrs,attributes,{strict:!1}))).reduce(((sum,markRange)=>sum+markRange.to-markRange.from),0),excludedRange=markRanges.filter((markRange=>!type||markRange.mark.type!==type&&markRange.mark.type.excludes(type))).reduce(((sum,markRange)=>sum+markRange.to-markRange.from),0),range=matchedRange>0?matchedRange+excludedRange:matchedRange;
// calculate range of marks that excludes the searched mark
// for example `code` doesn’t allow any other marks
return range>=selectionRange}function isActive(state,name,attributes={}){if(!name)return isNodeActive(state,null,attributes)||isMarkActive(state,null,attributes);const schemaType=getSchemaTypeNameByName(name,state.schema);return"node"===schemaType?isNodeActive(state,name,attributes):"mark"===schemaType&&isMarkActive(state,name,attributes)}function isList(name,extensions){const{nodeExtensions:nodeExtensions}=splitExtensions(extensions),extension=nodeExtensions.find((item=>item.name===name));if(!extension)return!1;const context={name:extension.name,options:extension.options,storage:extension.storage},group=callOrReturn(getExtensionField(extension,"group",context));return"string"===typeof group&&group.split(" ").includes("list")}function isNodeEmpty(node){var _a;const defaultContent=null===(_a=node.type.createAndFill())||void 0===_a?void 0:_a.toJSON(),content=node.toJSON();return JSON.stringify(defaultContent)===JSON.stringify(content)}function canSetMark(state,tr,newMarkType){var _a;const{selection:selection}=tr;let cursor=null;if(isTextSelection(selection)&&(cursor=selection.$cursor),cursor){const currentMarks=null!==(_a=state.storedMarks)&&void 0!==_a?_a:cursor.marks();
// There can be no current marks that exclude the new mark
return!!newMarkType.isInSet(currentMarks)||!currentMarks.some((mark=>mark.type.excludes(newMarkType)))}const{ranges:ranges}=selection;return ranges.some((({$from:$from,$to:$to})=>{let someNodeSupportsMark=0===$from.depth&&(state.doc.inlineContent&&state.doc.type.allowsMarkType(newMarkType));return state.doc.nodesBetween($from.pos,$to.pos,((node,_pos,parent)=>{
// If we already found a mark that we can enable, return false to bypass the remaining search
if(someNodeSupportsMark)return!1;if(node.isInline){const parentAllowsMarkType=!parent||parent.type.allowsMarkType(newMarkType),currentMarksAllowMarkType=!!newMarkType.isInSet(node.marks)||!node.marks.some((otherMark=>otherMark.type.excludes(newMarkType)));someNodeSupportsMark=parentAllowsMarkType&&currentMarksAllowMarkType}return!someNodeSupportsMark})),someNodeSupportsMark}))}const setMark=(typeOrName,attributes={})=>({tr:tr,state:state,dispatch:dispatch})=>{const{selection:selection}=tr,{empty:empty,ranges:ranges}=selection,type=getMarkType(typeOrName,state.schema);if(dispatch)if(empty){const oldAttributes=getMarkAttributes(state,type);tr.addStoredMark(type.create({...oldAttributes,...attributes}))}else ranges.forEach((range=>{const from=range.$from.pos,to=range.$to.pos;state.doc.nodesBetween(from,to,((node,pos)=>{const trimmedFrom=Math.max(pos,from),trimmedTo=Math.min(pos+node.nodeSize,to),someHasMark=node.marks.find((mark=>mark.type===type));
// if there is already a mark of this type
// we know that we have to merge its attributes
// otherwise we add a fresh new mark
someHasMark?node.marks.forEach((mark=>{type===mark.type&&tr.addMark(trimmedFrom,trimmedTo,type.create({...mark.attrs,...attributes}))})):tr.addMark(trimmedFrom,trimmedTo,type.create(attributes))}))}));return canSetMark(state,tr,type)},setMeta=(key,value)=>({tr:tr})=>(tr.setMeta(key,value),!0),setNode=(typeOrName,attributes={})=>({state:state,dispatch:dispatch,chain:chain})=>{const type=getNodeType(typeOrName,state.schema);
// TODO: use a fallback like insertContent?
return!!type.isTextblock&&chain().command((({commands:commands})=>{const canSetBlock=setBlockType(type,attributes)(state);return!!canSetBlock||commands.clearNodes()})).command((({state:updatedState})=>setBlockType(type,attributes)(updatedState,dispatch))).run()},setNodeSelection=position=>({tr:tr,dispatch:dispatch})=>{if(dispatch){const{doc:doc}=tr,from=minMax(position,0,doc.content.size),selection=NodeSelection.create(doc,from);tr.setSelection(selection)}return!0},setTextSelection=position=>({tr:tr,dispatch:dispatch})=>{if(dispatch){const{doc:doc}=tr,{from:from,to:to}="number"===typeof position?{from:position,to:position}:position,minPos=TextSelection.atStart(doc).from,maxPos=TextSelection.atEnd(doc).to,resolvedFrom=minMax(from,minPos,maxPos),resolvedEnd=minMax(to,minPos,maxPos),selection=TextSelection.create(doc,resolvedFrom,resolvedEnd);tr.setSelection(selection)}return!0},sinkListItem=typeOrName=>({state:state,dispatch:dispatch})=>{const type=getNodeType(typeOrName,state.schema);return sinkListItem$1(type)(state,dispatch)};function ensureMarks(state,splittableMarks){const marks=state.storedMarks||state.selection.$to.parentOffset&&state.selection.$from.marks();if(marks){const filteredMarks=marks.filter((mark=>null===splittableMarks||void 0===splittableMarks?void 0:splittableMarks.includes(mark.type.name)));state.tr.ensureMarks(filteredMarks)}}const splitBlock=({keepMarks:keepMarks=!0}={})=>({tr:tr,state:state,dispatch:dispatch,editor:editor})=>{const{selection:selection,doc:doc}=tr,{$from:$from,$to:$to}=selection,extensionAttributes=editor.extensionManager.attributes,newAttributes=getSplittedAttributes(extensionAttributes,$from.node().type.name,$from.node().attrs);if(selection instanceof NodeSelection&&selection.node.isBlock)return!(!$from.parentOffset||!canSplit(doc,$from.pos))&&(dispatch&&(keepMarks&&ensureMarks(state,editor.extensionManager.splittableMarks),tr.split($from.pos).scrollIntoView()),!0);if(!$from.parent.isBlock)return!1;if(dispatch){const atEnd=$to.parentOffset===$to.parent.content.size;selection instanceof TextSelection&&tr.deleteSelection();const deflt=0===$from.depth?void 0:defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));let types=atEnd&&deflt?[{type:deflt,attrs:newAttributes}]:void 0,can=canSplit(tr.doc,tr.mapping.map($from.pos),1,types);if(types||can||!canSplit(tr.doc,tr.mapping.map($from.pos),1,deflt?[{type:deflt}]:void 0)||(can=!0,types=deflt?[{type:deflt,attrs:newAttributes}]:void 0),can&&(tr.split(tr.mapping.map($from.pos),1,types),deflt&&!atEnd&&!$from.parentOffset&&$from.parent.type!==deflt)){const first=tr.mapping.map($from.before()),$first=tr.doc.resolve(first);$from.node(-1).canReplaceWith($first.index(),$first.index()+1,deflt)&&tr.setNodeMarkup(tr.mapping.map($from.before()),deflt)}keepMarks&&ensureMarks(state,editor.extensionManager.splittableMarks),tr.scrollIntoView()}return!0},splitListItem=typeOrName=>({tr:tr,state:state,dispatch:dispatch,editor:editor})=>{var _a;const type=getNodeType(typeOrName,state.schema),{$from:$from,$to:$to}=state.selection,node=state.selection.node;if(node&&node.isBlock||$from.depth<2||!$from.sameParent($to))return!1;const grandParent=$from.node(-1);if(grandParent.type!==type)return!1;const extensionAttributes=editor.extensionManager.attributes;if(0===$from.parent.content.size&&$from.node(-1).childCount===$from.indexAfter(-1)){
// In an empty block. If this is a nested list, the wrapping
// list item should be split. Otherwise, bail out and let next
// command handle lifting.
if(2===$from.depth||$from.node(-3).type!==type||$from.index(-2)!==$from.node(-2).childCount-1)return!1;if(dispatch){let wrap=Fragment.empty;
// eslint-disable-next-line
const depthBefore=$from.index(-1)?1:$from.index(-2)?2:3;
// Build a fragment containing empty versions of the structure
// from the outer list item to the parent node of the cursor
for(let d=$from.depth-depthBefore;d>=$from.depth-3;d-=1)wrap=Fragment.from($from.node(d).copy(wrap));
// eslint-disable-next-line
const depthAfter=$from.indexAfter(-1)<$from.node(-2).childCount?1:$from.indexAfter(-2)<$from.node(-3).childCount?2:3,newNextTypeAttributes=getSplittedAttributes(extensionAttributes,$from.node().type.name,$from.node().attrs),nextType=(null===(_a=type.contentMatch.defaultType)||void 0===_a?void 0:_a.createAndFill(newNextTypeAttributes))||void 0;
// Add a second list item with an empty default start node
wrap=wrap.append(Fragment.from(type.createAndFill(null,nextType)||void 0));const start=$from.before($from.depth-(depthBefore-1));tr.replace(start,$from.after(-depthAfter),new Slice(wrap,4-depthBefore,0));let sel=-1;tr.doc.nodesBetween(start,tr.doc.content.size,((n,pos)=>{if(sel>-1)return!1;n.isTextblock&&0===n.content.size&&(sel=pos+1)})),sel>-1&&tr.setSelection(TextSelection.near(tr.doc.resolve(sel))),tr.scrollIntoView()}return!0}const nextType=$to.pos===$from.end()?grandParent.contentMatchAt(0).defaultType:null,newTypeAttributes=getSplittedAttributes(extensionAttributes,grandParent.type.name,grandParent.attrs),newNextTypeAttributes=getSplittedAttributes(extensionAttributes,$from.node().type.name,$from.node().attrs);tr.delete($from.pos,$to.pos);const types=nextType?[{type:type,attrs:newTypeAttributes},{type:nextType,attrs:newNextTypeAttributes}]:[{type:type,attrs:newTypeAttributes}];if(!canSplit(tr.doc,$from.pos,2))return!1;if(dispatch){const{selection:selection,storedMarks:storedMarks}=state,{splittableMarks:splittableMarks}=editor.extensionManager,marks=storedMarks||selection.$to.parentOffset&&selection.$from.marks();if(tr.split($from.pos,2,types).scrollIntoView(),!marks||!dispatch)return!0;const filteredMarks=marks.filter((mark=>splittableMarks.includes(mark.type.name)));tr.ensureMarks(filteredMarks)}return!0},joinListBackwards=(tr,listType)=>{const list=findParentNode((node=>node.type===listType))(tr.selection);if(!list)return!0;const before=tr.doc.resolve(Math.max(0,list.pos-1)).before(list.depth);if(void 0===before)return!0;const nodeBefore=tr.doc.nodeAt(before),canJoinBackwards=list.node.type===(null===nodeBefore||void 0===nodeBefore?void 0:nodeBefore.type)&&canJoin(tr.doc,list.pos);return!canJoinBackwards||(tr.join(list.pos),!0)},joinListForwards=(tr,listType)=>{const list=findParentNode((node=>node.type===listType))(tr.selection);if(!list)return!0;const after=tr.doc.resolve(list.start).after(list.depth);if(void 0===after)return!0;const nodeAfter=tr.doc.nodeAt(after),canJoinForwards=list.node.type===(null===nodeAfter||void 0===nodeAfter?void 0:nodeAfter.type)&&canJoin(tr.doc,after);return!canJoinForwards||(tr.join(after),!0)},toggleList=(listTypeOrName,itemTypeOrName,keepMarks,attributes={})=>({editor:editor,tr:tr,state:state,dispatch:dispatch,chain:chain,commands:commands,can:can})=>{const{extensions:extensions,splittableMarks:splittableMarks}=editor.extensionManager,listType=getNodeType(listTypeOrName,state.schema),itemType=getNodeType(itemTypeOrName,state.schema),{selection:selection,storedMarks:storedMarks}=state,{$from:$from,$to:$to}=selection,range=$from.blockRange($to),marks=storedMarks||selection.$to.parentOffset&&selection.$from.marks();if(!range)return!1;const parentList=findParentNode((node=>isList(node.type.name,extensions)))(selection);if(range.depth>=1&&parentList&&range.depth-parentList.depth<=1){
// remove list
if(parentList.node.type===listType)return commands.liftListItem(itemType);
// change list type
if(isList(parentList.node.type.name,extensions)&&listType.validContent(parentList.node.content)&&dispatch)return chain().command((()=>(tr.setNodeMarkup(parentList.pos,listType),!0))).command((()=>joinListBackwards(tr,listType))).command((()=>joinListForwards(tr,listType))).run()}return keepMarks&&marks&&dispatch?chain().command((()=>{const canWrapInList=can().wrapInList(listType,attributes),filteredMarks=marks.filter((mark=>splittableMarks.includes(mark.type.name)));return tr.ensureMarks(filteredMarks),!!canWrapInList||commands.clearNodes()})).wrapInList(listType,attributes).command((()=>joinListBackwards(tr,listType))).command((()=>joinListForwards(tr,listType))).run():chain().command((()=>{const canWrapInList=can().wrapInList(listType,attributes);return!!canWrapInList||commands.clearNodes()})).wrapInList(listType,attributes).command((()=>joinListBackwards(tr,listType))).command((()=>joinListForwards(tr,listType))).run()},toggleMark=(typeOrName,attributes={},options={})=>({state:state,commands:commands})=>{const{extendEmptyMarkRange:extendEmptyMarkRange=!1}=options,type=getMarkType(typeOrName,state.schema),isActive=isMarkActive(state,type,attributes);return isActive?commands.unsetMark(type,{extendEmptyMarkRange:extendEmptyMarkRange}):commands.setMark(type,attributes)},toggleNode=(typeOrName,toggleTypeOrName,attributes={})=>({state:state,commands:commands})=>{const type=getNodeType(typeOrName,state.schema),toggleType=getNodeType(toggleTypeOrName,state.schema),isActive=isNodeActive(state,type,attributes);return isActive?commands.setNode(toggleType):commands.setNode(type,attributes)},toggleWrap=(typeOrName,attributes={})=>({state:state,commands:commands})=>{const type=getNodeType(typeOrName,state.schema),isActive=isNodeActive(state,type,attributes);return isActive?commands.lift(type):commands.wrapIn(type,attributes)},undoInputRule=()=>({state:state,dispatch:dispatch})=>{const plugins=state.plugins;for(let i=0;i<plugins.length;i+=1){const plugin=plugins[i];let undoable;
// @ts-ignore
// eslint-disable-next-line
if(plugin.spec.isInputRules&&(undoable=plugin.getState(state))){if(dispatch){const tr=state.tr,toUndo=undoable.transform;for(let j=toUndo.steps.length-1;j>=0;j-=1)tr.step(toUndo.steps[j].invert(toUndo.docs[j]));if(undoable.text){const marks=tr.doc.resolve(undoable.from).marks();tr.replaceWith(undoable.from,undoable.to,state.schema.text(undoable.text,marks))}else tr.delete(undoable.from,undoable.to)}return!0}}return!1},unsetAllMarks=()=>({tr:tr,dispatch:dispatch})=>{const{selection:selection}=tr,{empty:empty,ranges:ranges}=selection;return empty||dispatch&&ranges.forEach((range=>{tr.removeMark(range.$from.pos,range.$to.pos)})),!0},unsetMark=(typeOrName,options={})=>({tr:tr,state:state,dispatch:dispatch})=>{var _a;const{extendEmptyMarkRange:extendEmptyMarkRange=!1}=options,{selection:selection}=tr,type=getMarkType(typeOrName,state.schema),{$from:$from,empty:empty,ranges:ranges}=selection;if(!dispatch)return!0;if(empty&&extendEmptyMarkRange){let{from:from,to:to}=selection;const attrs=null===(_a=$from.marks().find((mark=>mark.type===type)))||void 0===_a?void 0:_a.attrs,range=getMarkRange($from,type,attrs);range&&(from=range.from,to=range.to),tr.removeMark(from,to,type)}else ranges.forEach((range=>{tr.removeMark(range.$from.pos,range.$to.pos,type)}));return tr.removeStoredMark(type),!0},updateAttributes=(typeOrName,attributes={})=>({tr:tr,state:state,dispatch:dispatch})=>{let nodeType=null,markType=null;const schemaType=getSchemaTypeNameByName("string"===typeof typeOrName?typeOrName:typeOrName.name,state.schema);return!!schemaType&&("node"===schemaType&&(nodeType=getNodeType(typeOrName,state.schema)),"mark"===schemaType&&(markType=getMarkType(typeOrName,state.schema)),dispatch&&tr.selection.ranges.forEach((range=>{const from=range.$from.pos,to=range.$to.pos;state.doc.nodesBetween(from,to,((node,pos)=>{nodeType&&nodeType===node.type&&tr.setNodeMarkup(pos,void 0,{...node.attrs,...attributes}),markType&&node.marks.length&&node.marks.forEach((mark=>{if(markType===mark.type){const trimmedFrom=Math.max(pos,from),trimmedTo=Math.min(pos+node.nodeSize,to);tr.addMark(trimmedFrom,trimmedTo,markType.create({...mark.attrs,...attributes}))}}))}))})),!0)},wrapIn=(typeOrName,attributes={})=>({state:state,dispatch:dispatch})=>{const type=getNodeType(typeOrName,state.schema);return wrapIn$1(type,attributes)(state,dispatch)},wrapInList=(typeOrName,attributes={})=>({state:state,dispatch:dispatch})=>{const type=getNodeType(typeOrName,state.schema);return wrapInList$1(type,attributes)(state,dispatch)};var commands=Object.freeze({__proto__:null,blur:forms_blur,clearContent:clearContent,clearNodes:clearNodes,command:command,createParagraphNear:createParagraphNear,deleteCurrentNode:deleteCurrentNode,deleteNode:deleteNode,deleteRange:deleteRange,deleteSelection:deleteSelection,enter:enter,exitCode:exitCode,extendMarkRange:extendMarkRange,first:first,focus:forms_focus,forEach:forEach,insertContent:insertContent,insertContentAt:insertContentAt,joinUp:joinUp,joinDown:joinDown,joinBackward:joinBackward,joinForward:joinForward,keyboardShortcut:keyboardShortcut,lift:lift,liftEmptyBlock:liftEmptyBlock,liftListItem:liftListItem,newlineInCode:newlineInCode,resetAttributes:resetAttributes,scrollIntoView:scrollIntoView,selectAll:selectAll,selectNodeBackward:selectNodeBackward,selectNodeForward:selectNodeForward,selectParentNode:selectParentNode,selectTextblockEnd:selectTextblockEnd,selectTextblockStart:selectTextblockStart,setContent:setContent$1,setMark:setMark,setMeta:setMeta,setNode:setNode,setNodeSelection:setNodeSelection,setTextSelection:setTextSelection,sinkListItem:sinkListItem,splitBlock:splitBlock,splitListItem:splitListItem,toggleList:toggleList,toggleMark:toggleMark,toggleNode:toggleNode,toggleWrap:toggleWrap,undoInputRule:undoInputRule,unsetAllMarks:unsetAllMarks,unsetMark:unsetMark,updateAttributes:updateAttributes,wrapIn:wrapIn,wrapInList:wrapInList});const Commands=Extension.create({name:"commands",addCommands(){return{...commands}}}),Editable=Extension.create({name:"editable",addProseMirrorPlugins(){return[new Plugin({key:new PluginKey("editable"),props:{editable:()=>this.editor.options.editable}})]}}),FocusEvents=Extension.create({name:"focusEvents",addProseMirrorPlugins(){const{editor:editor}=this;return[new Plugin({key:new PluginKey("focusEvents"),props:{handleDOMEvents:{focus:(view,event)=>{editor.isFocused=!0;const transaction=editor.state.tr.setMeta("focus",{event:event}).setMeta("addToHistory",!1);return view.dispatch(transaction),!1},blur:(view,event)=>{editor.isFocused=!1;const transaction=editor.state.tr.setMeta("blur",{event:event}).setMeta("addToHistory",!1);return view.dispatch(transaction),!1}}}})]}}),Keymap=Extension.create({name:"keymap",addKeyboardShortcuts(){const handleBackspace=()=>this.editor.commands.first((({commands:commands})=>[()=>commands.undoInputRule()
// maybe convert first text block node to default node
,()=>commands.command((({tr:tr})=>{const{selection:selection,doc:doc}=tr,{empty:empty,$anchor:$anchor}=selection,{pos:pos,parent:parent}=$anchor,isAtStart=Selection.atStart(doc).from===pos;return!(!(empty&&isAtStart&&parent.type.isTextblock)||parent.textContent.length)&&commands.clearNodes()})),()=>commands.deleteSelection(),()=>commands.joinBackward(),()=>commands.selectNodeBackward()])),handleDelete=()=>this.editor.commands.first((({commands:commands})=>[()=>commands.deleteSelection(),()=>commands.deleteCurrentNode(),()=>commands.joinForward(),()=>commands.selectNodeForward()])),handleEnter=()=>this.editor.commands.first((({commands:commands})=>[()=>commands.newlineInCode(),()=>commands.createParagraphNear(),()=>commands.liftEmptyBlock(),()=>commands.splitBlock()])),baseKeymap={Enter:handleEnter,"Mod-Enter":()=>this.editor.commands.exitCode(),Backspace:handleBackspace,"Mod-Backspace":handleBackspace,"Shift-Backspace":handleBackspace,Delete:handleDelete,"Mod-Delete":handleDelete,"Mod-a":()=>this.editor.commands.selectAll()},pcKeymap={...baseKeymap},macKeymap={...baseKeymap,"Ctrl-h":handleBackspace,"Alt-Backspace":handleBackspace,"Ctrl-d":handleDelete,"Ctrl-Alt-Backspace":handleDelete,"Alt-Delete":handleDelete,"Alt-d":handleDelete,"Ctrl-a":()=>this.editor.commands.selectTextblockStart(),"Ctrl-e":()=>this.editor.commands.selectTextblockEnd()};return isiOS()||isMacOS()?macKeymap:pcKeymap},addProseMirrorPlugins(){return[
// With this plugin we check if the whole document was selected and deleted.
// In this case we will additionally call `clearNodes()` to convert e.g. a heading
// to a paragraph if necessary.
// This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
// with many other commands.
new Plugin({key:new PluginKey("clearDocument"),appendTransaction:(transactions,oldState,newState)=>{const docChanges=transactions.some((transaction=>transaction.docChanged))&&!oldState.doc.eq(newState.doc);if(!docChanges)return;const{empty:empty,from:from,to:to}=oldState.selection,allFrom=Selection.atStart(oldState.doc).from,allEnd=Selection.atEnd(oldState.doc).to,allWasSelected=from===allFrom&&to===allEnd;if(empty||!allWasSelected)return;const isEmpty=0===newState.doc.textBetween(0,newState.doc.content.size," "," ").length;if(!isEmpty)return;const tr=newState.tr,state=createChainableState({state:newState,transaction:tr}),{commands:commands}=new CommandManager({editor:this.editor,state:state});return commands.clearNodes(),tr.steps.length?tr:void 0}})]}}),Tabindex=Extension.create({name:"tabindex",addProseMirrorPlugins(){return[new Plugin({key:new PluginKey("tabindex"),props:{attributes:this.editor.isEditable?{tabindex:"0"}:{}}})]}});var extensions=Object.freeze({__proto__:null,ClipboardTextSerializer:ClipboardTextSerializer,Commands:Commands,Editable:Editable,FocusEvents:FocusEvents,Keymap:Keymap,Tabindex:Tabindex});const style='.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: "liga" 0; /* the above doesn\'t seem to work in Edge */\n}\n\n.ProseMirror [contenteditable="false"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable="false"] [contenteditable="true"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: "";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}';function createStyleTag(style,nonce){const tiptapStyleTag=document.querySelector("style[data-tiptap-style]");if(null!==tiptapStyleTag)return tiptapStyleTag;const styleNode=document.createElement("style");return nonce&&styleNode.setAttribute("nonce",nonce),styleNode.setAttribute("data-tiptap-style",""),styleNode.innerHTML=style,document.getElementsByTagName("head")[0].appendChild(styleNode),styleNode}class Editor$1 extends EventEmitter{constructor(options={}){super(),this.isFocused=!1,this.extensionStorage={},this.options={element:document.createElement("div"),content:"",injectCSS:!0,injectNonce:void 0,extensions:[],autofocus:!1,editable:!0,editorProps:{},parseOptions:{},enableInputRules:!0,enablePasteRules:!0,enableCoreExtensions:!0,onBeforeCreate:()=>null,onCreate:()=>null,onUpdate:()=>null,onSelectionUpdate:()=>null,onTransaction:()=>null,onFocus:()=>null,onBlur:()=>null,onDestroy:()=>null},this.isCapturingTransaction=!1,this.capturedTransaction=null,this.setOptions(options),this.createExtensionManager(),this.createCommandManager(),this.createSchema(),this.on("beforeCreate",this.options.onBeforeCreate),this.emit("beforeCreate",{editor:this}),this.createView(),this.injectCSS(),this.on("create",this.options.onCreate),this.on("update",this.options.onUpdate),this.on("selectionUpdate",this.options.onSelectionUpdate),this.on("transaction",this.options.onTransaction),this.on("focus",this.options.onFocus),this.on("blur",this.options.onBlur),this.on("destroy",this.options.onDestroy),window.setTimeout((()=>{this.isDestroyed||(this.commands.focus(this.options.autofocus),this.emit("create",{editor:this}))}),0)}
/**
     * Returns the editor storage.
     */get storage(){return this.extensionStorage}
/**
     * An object of all registered commands.
     */get commands(){return this.commandManager.commands}
/**
     * Create a command chain to call multiple commands at once.
     */chain(){return this.commandManager.chain()}
/**
     * Check if a command or a command chain can be executed. Without executing it.
     */can(){return this.commandManager.can()}
/**
     * Inject CSS styles.
     */injectCSS(){this.options.injectCSS&&document&&(this.css=createStyleTag(style,this.options.injectNonce))}
/**
     * Update editor options.
     *
     * @param options A list of options
     */setOptions(options={}){this.options={...this.options,...options},this.view&&this.state&&!this.isDestroyed&&(this.options.editorProps&&this.view.setProps(this.options.editorProps),this.view.updateState(this.state))}
/**
     * Update editable state of the editor.
     */setEditable(editable,emitUpdate=!0){this.setOptions({editable:editable}),emitUpdate&&this.emit("update",{editor:this,transaction:this.state.tr})}
/**
     * Returns whether the editor is editable.
     */get isEditable(){
// since plugins are applied after creating the view
// `editable` is always `true` for one tick.
// that’s why we also have to check for `options.editable`
return this.options.editable&&this.view&&this.view.editable}
/**
     * Returns the editor state.
     */get state(){return this.view.state}
/**
     * Register a ProseMirror plugin.
     *
     * @param plugin A ProseMirror plugin
     * @param handlePlugins Control how to merge the plugin into the existing plugins.
     */registerPlugin(plugin,handlePlugins){const plugins=isFunction$2(handlePlugins)?handlePlugins(plugin,[...this.state.plugins]):[...this.state.plugins,plugin],state=this.state.reconfigure({plugins:plugins});this.view.updateState(state)}
/**
     * Unregister a ProseMirror plugin.
     *
     * @param nameOrPluginKey The plugins name
     */unregisterPlugin(nameOrPluginKey){if(this.isDestroyed)return;
// @ts-ignore
const name="string"===typeof nameOrPluginKey?`${nameOrPluginKey}$`:nameOrPluginKey.key,state=this.state.reconfigure({
// @ts-ignore
plugins:this.state.plugins.filter((plugin=>!plugin.key.startsWith(name)))});this.view.updateState(state)}
/**
     * Creates an extension manager.
     */createExtensionManager(){const coreExtensions=this.options.enableCoreExtensions?Object.values(extensions):[],allExtensions=[...coreExtensions,...this.options.extensions].filter((extension=>["extension","node","mark"].includes(null===extension||void 0===extension?void 0:extension.type)));this.extensionManager=new ExtensionManager(allExtensions,this)}
/**
     * Creates an command manager.
     */createCommandManager(){this.commandManager=new CommandManager({editor:this})}
/**
     * Creates a ProseMirror schema.
     */createSchema(){this.schema=this.extensionManager.schema}
/**
     * Creates a ProseMirror view.
     */createView(){const doc=createDocument(this.options.content,this.schema,this.options.parseOptions),selection=resolveFocusPosition(doc,this.options.autofocus);this.view=new EditorView(this.options.element,{...this.options.editorProps,dispatchTransaction:this.dispatchTransaction.bind(this),state:EditorState.create({doc:doc,selection:selection||void 0})});
// `editor.view` is not yet available at this time.
// Therefore we will add all plugins and node views directly afterwards.
const newState=this.state.reconfigure({plugins:this.extensionManager.plugins});this.view.updateState(newState),this.createNodeViews();
// Let’s store the editor instance in the DOM element.
// So we’ll have access to it for tests.
const dom=this.view.dom;dom.editor=this}
/**
     * Creates all node views.
     */createNodeViews(){this.view.setProps({nodeViews:this.extensionManager.nodeViews})}captureTransaction(fn){this.isCapturingTransaction=!0,fn(),this.isCapturingTransaction=!1;const tr=this.capturedTransaction;return this.capturedTransaction=null,tr}
/**
     * The callback over which to send transactions (state updates) produced by the view.
     *
     * @param transaction An editor state transaction
     */dispatchTransaction(transaction){
// if the editor / the view of the editor was destroyed
// the transaction should not be dispatched as there is no view anymore.
if(this.view.isDestroyed)return;if(this.isCapturingTransaction)return this.capturedTransaction?void transaction.steps.forEach((step=>{var _a;return null===(_a=this.capturedTransaction)||void 0===_a?void 0:_a.step(step)})):void(this.capturedTransaction=transaction);const state=this.state.apply(transaction),selectionHasChanged=!this.state.selection.eq(state.selection);this.view.updateState(state),this.emit("transaction",{editor:this,transaction:transaction}),selectionHasChanged&&this.emit("selectionUpdate",{editor:this,transaction:transaction});const focus=transaction.getMeta("focus"),blur=transaction.getMeta("blur");focus&&this.emit("focus",{editor:this,event:focus.event,transaction:transaction}),blur&&this.emit("blur",{editor:this,event:blur.event,transaction:transaction}),transaction.docChanged&&!transaction.getMeta("preventUpdate")&&this.emit("update",{editor:this,transaction:transaction})}
/**
     * Get attributes of the currently selected node or mark.
     */getAttributes(nameOrType){return getAttributes(this.state,nameOrType)}isActive(nameOrAttributes,attributesOrUndefined){const name="string"===typeof nameOrAttributes?nameOrAttributes:null,attributes="string"===typeof nameOrAttributes?attributesOrUndefined:nameOrAttributes;return isActive(this.state,name,attributes)}
/**
     * Get the document as JSON.
     */getJSON(){return this.state.doc.toJSON()}
/**
     * Get the document as HTML.
     */getHTML(){return getHTMLFromFragment(this.state.doc.content,this.schema)}
/**
     * Get the document as text.
     */getText(options){const{blockSeparator:blockSeparator="\n\n",textSerializers:textSerializers={}}=options||{};return getText(this.state.doc,{blockSeparator:blockSeparator,textSerializers:{...getTextSerializersFromSchema(this.schema),...textSerializers}})}
/**
     * Check if there is no content.
     */get isEmpty(){return isNodeEmpty(this.state.doc)}
/**
     * Get the number of characters for the current document.
     *
     * @deprecated
     */getCharacterCount(){return this.state.doc.content.size-2}
/**
     * Destroy the editor.
     */destroy(){this.emit("destroy"),this.view&&this.view.destroy(),this.removeAllListeners()}
/**
     * Check if the editor is already destroyed.
     */get isDestroyed(){var _a;
// @ts-ignore
return!(null===(_a=this.view)||void 0===_a?void 0:_a.docView)}}
/**
 * Build an input rule that adds a mark when the
 * matched text is typed into it.
 */function markInputRule(config){return new InputRule({find:config.find,handler:({state:state,range:range,match:match})=>{const attributes=callOrReturn(config.getAttributes,void 0,match);if(!1===attributes||null===attributes)return null;const{tr:tr}=state,captureGroup=match[match.length-1],fullMatch=match[0];let markEnd=range.to;if(captureGroup){const startSpaces=fullMatch.search(/\S/),textStart=range.from+fullMatch.indexOf(captureGroup),textEnd=textStart+captureGroup.length,excludedMarks=getMarksBetween(range.from,range.to,state.doc).filter((item=>{
// @ts-ignore
const excluded=item.mark.type.excluded;return excluded.find((type=>type===config.type&&type!==item.mark.type))})).filter((item=>item.to>textStart));if(excludedMarks.length)return null;textEnd<range.to&&tr.delete(textEnd,range.to),textStart>range.from&&tr.delete(range.from+startSpaces,textStart),markEnd=range.from+startSpaces+captureGroup.length,tr.addMark(range.from+startSpaces,markEnd,config.type.create(attributes||{})),tr.removeStoredMark(config.type)}}})}
/**
 * Build an input rule that adds a node when the
 * matched text is typed into it.
 */function nodeInputRule(config){return new InputRule({find:config.find,handler:({state:state,range:range,match:match})=>{const attributes=callOrReturn(config.getAttributes,void 0,match)||{},{tr:tr}=state,start=range.from;let end=range.to;if(match[1]){const offset=match[0].lastIndexOf(match[1]);let matchStart=start+offset;matchStart>end?matchStart=end:end=matchStart+match[1].length;
// insert last typed character
const lastChar=match[0][match[0].length-1];tr.insertText(lastChar,start+match[0].length-1),
// insert node from input rule
tr.replaceWith(matchStart,end,config.type.create(attributes))}else match[0]&&tr.replaceWith(start,end,config.type.create(attributes))}})}
/**
 * Build an input rule that changes the type of a textblock when the
 * matched text is typed into it. When using a regular expresion you’ll
 * probably want the regexp to start with `^`, so that the pattern can
 * only occur at the start of a textblock.
 */function textblockTypeInputRule(config){return new InputRule({find:config.find,handler:({state:state,range:range,match:match})=>{const $start=state.doc.resolve(range.from),attributes=callOrReturn(config.getAttributes,void 0,match)||{};if(!$start.node(-1).canReplaceWith($start.index(-1),$start.indexAfter(-1),config.type))return null;state.tr.delete(range.from,range.to).setBlockType(range.from,range.from,config.type,attributes)}})}
/**
 * Build an input rule for automatically wrapping a textblock when a
 * given string is typed. When using a regular expresion you’ll
 * probably want the regexp to start with `^`, so that the pattern can
 * only occur at the start of a textblock.
 *
 * `type` is the type of node to wrap in.
 *
 * By default, if there’s a node with the same type above the newly
 * wrapped node, the rule will try to join those
 * two nodes. You can pass a join predicate, which takes a regular
 * expression match and the node before the wrapped node, and can
 * return a boolean to indicate whether a join should happen.
 */function wrappingInputRule(config){return new InputRule({find:config.find,handler:({state:state,range:range,match:match,chain:chain})=>{const attributes=callOrReturn(config.getAttributes,void 0,match)||{},tr=state.tr.delete(range.from,range.to),$start=tr.doc.resolve(range.from),blockRange=$start.blockRange(),wrapping=blockRange&&findWrapping(blockRange,config.type,attributes);if(!wrapping)return null;if(tr.wrap(blockRange,wrapping),config.keepMarks&&config.editor){const{selection:selection,storedMarks:storedMarks}=state,{splittableMarks:splittableMarks}=config.editor.extensionManager,marks=storedMarks||selection.$to.parentOffset&&selection.$from.marks();if(marks){const filteredMarks=marks.filter((mark=>splittableMarks.includes(mark.type.name)));tr.ensureMarks(filteredMarks)}}if(config.keepAttributes){
/** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */
const nodeType="bulletList"===config.type.name||"orderedList"===config.type.name?"listItem":"taskList";chain().updateAttributes(nodeType,attributes).run()}const before=tr.doc.resolve(range.from-1).nodeBefore;before&&before.type===config.type&&canJoin(tr.doc,range.from-1)&&(!config.joinPredicate||config.joinPredicate(match,before))&&tr.join(range.from-1)}})}class Mark{constructor(config={}){this.type="mark",this.name="mark",this.parent=null,this.child=null,this.config={name:this.name,defaultOptions:{}},this.config={...this.config,...config},this.name=this.config.name,config.defaultOptions,
// TODO: remove `addOptions` fallback
this.options=this.config.defaultOptions,this.config.addOptions&&(this.options=callOrReturn(getExtensionField(this,"addOptions",{name:this.name}))),this.storage=callOrReturn(getExtensionField(this,"addStorage",{name:this.name,options:this.options}))||{}}static create(config={}){return new Mark(config)}configure(options={}){
// return a new instance so we can use the same extension
// with different calls of `configure`
const extension=this.extend();return extension.options=mergeDeep(this.options,options),extension.storage=callOrReturn(getExtensionField(extension,"addStorage",{name:extension.name,options:extension.options})),extension}extend(extendedConfig={}){const extension=new Mark(extendedConfig);return extension.parent=this,this.child=extension,extension.name=extendedConfig.name?extendedConfig.name:extension.parent.name,extendedConfig.defaultOptions,extension.options=callOrReturn(getExtensionField(extension,"addOptions",{name:extension.name})),extension.storage=callOrReturn(getExtensionField(extension,"addStorage",{name:extension.name,options:extension.options})),extension}static handleExit({editor:editor,mark:mark}){const{tr:tr}=editor.state,currentPos=editor.state.selection.$from,isAtEnd=currentPos.pos===currentPos.end();if(isAtEnd){const currentMarks=currentPos.marks(),isInMark=!!currentMarks.find((m=>(null===m||void 0===m?void 0:m.type.name)===mark.name));if(!isInMark)return!1;const removeMark=currentMarks.find((m=>(null===m||void 0===m?void 0:m.type.name)===mark.name));return removeMark&&tr.removeStoredMark(removeMark),tr.insertText(" ",currentPos.pos),editor.view.dispatch(tr),!0}return!1}}class Node$1{constructor(config={}){this.type="node",this.name="node",this.parent=null,this.child=null,this.config={name:this.name,defaultOptions:{}},this.config={...this.config,...config},this.name=this.config.name,config.defaultOptions,
// TODO: remove `addOptions` fallback
this.options=this.config.defaultOptions,this.config.addOptions&&(this.options=callOrReturn(getExtensionField(this,"addOptions",{name:this.name}))),this.storage=callOrReturn(getExtensionField(this,"addStorage",{name:this.name,options:this.options}))||{}}static create(config={}){return new Node$1(config)}configure(options={}){
// return a new instance so we can use the same extension
// with different calls of `configure`
const extension=this.extend();return extension.options=mergeDeep(this.options,options),extension.storage=callOrReturn(getExtensionField(extension,"addStorage",{name:extension.name,options:extension.options})),extension}extend(extendedConfig={}){const extension=new Node$1(extendedConfig);return extension.parent=this,this.child=extension,extension.name=extendedConfig.name?extendedConfig.name:extension.parent.name,extendedConfig.defaultOptions,extension.options=callOrReturn(getExtensionField(extension,"addOptions",{name:extension.name})),extension.storage=callOrReturn(getExtensionField(extension,"addStorage",{name:extension.name,options:extension.options})),extension}}
/**
 * Build an paste rule that adds a mark when the
 * matched text is pasted into it.
 */function markPasteRule(config){return new PasteRule({find:config.find,handler:({state:state,range:range,match:match})=>{const attributes=callOrReturn(config.getAttributes,void 0,match);if(!1===attributes||null===attributes)return null;const{tr:tr}=state,captureGroup=match[match.length-1],fullMatch=match[0];let markEnd=range.to;if(captureGroup){const startSpaces=fullMatch.search(/\S/),textStart=range.from+fullMatch.indexOf(captureGroup),textEnd=textStart+captureGroup.length,excludedMarks=getMarksBetween(range.from,range.to,state.doc).filter((item=>{
// @ts-ignore
const excluded=item.mark.type.excluded;return excluded.find((type=>type===config.type&&type!==item.mark.type))})).filter((item=>item.to>textStart));if(excludedMarks.length)return null;textEnd<range.to&&tr.delete(textEnd,range.to),textStart>range.from&&tr.delete(range.from+startSpaces,textStart),markEnd=range.from+startSpaces+captureGroup.length,tr.addMark(range.from+startSpaces,markEnd,config.type.create(attributes||{})),tr.removeStoredMark(config.type)}}})}class Editor extends Editor$1{constructor(){super(...arguments),this.contentComponent=null}}const EditorContent={name:"EditorContent",props:{editor:{default:null,type:Object}},watch:{editor:{immediate:!0,handler(editor){editor&&editor.options.element&&this.$nextTick((()=>{const element=this.$el;element&&editor.options.element.firstChild&&(element.append(...editor.options.element.childNodes),editor.contentComponent=this,editor.setOptions({element:element}),editor.createNodeViews())}))}}},render(createElement){return createElement("div")},beforeDestroy(){const{editor:editor}=this;if(!editor)return;if(editor.isDestroyed||editor.view.setProps({nodeViews:{}}),editor.contentComponent=null,!editor.options.element.firstChild)return;const newElement=document.createElement("div");newElement.append(...editor.options.element.childNodes),editor.setOptions({element:newElement})}};var Tick={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"16",height:"16"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M10 15.172l9.192-9.193 1.415 1.414L10 18l-6.364-6.364 1.414-1.414z"}})])}},AddIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M11 11V7h2v4h4v2h-4v4h-2v-4H7v-2h4zm1 11C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm0-2a8 8 0 100-16 8 8 0 000 16z",fill:"rgba(96,98,102,1)"}})])}},colors=["#000","#434343","#666666","#999999","#B7B7B7","#CCCCCC","#D9D9D9","#EFEFEF","#F3F3F3","#FFFFFF","#980000","#FF0000","#FF9900","#FFFF00","#00FF00","#00FFFF","#4A86E8","#0000FF","#9900FF","#FF00FF","#E6B8AF","#F4CCCC","#FCE5CD","#FFF2CC","#D9EAD3","#D0E0E3","#C9DAF8","#CFE2F3","#D9D2E9","#EAD1DC","#DD7E6B","#EA9999","#F9CB9C","#FFE599","#B6D7A8","#A2C4C9","#A4C2F4","#9FC5E8","#B4A7D6","#D5A6BD","#CC4125","#E06666","#F6B26B","#FFD966","#93C47D","#76A5AF","#6D9EEB","#6FA8DC","#8E7CC3","#C27BA0","#A61C00","#CC0000","#E69138","#F1C232","#6AA84F","#45818E","#3C78D8","#3D85C6","#674EA7","#A64D79","#85200C","#990000","#B45F06","#BF9000","#38761D","#134F5C","#1155CC","#0B5394","#351C75","#741B47","#5B0F00","#660000","#783F04","#7F6000","#274E13","#0C343D","#1C4587","#073763","#20124D","#4C1130"],script$7={props:["selectedColor","additionalColors","customColorPalette","type"],data(){return{visibility:!1,currentColor:null,customColor:null,templateColors:colors,colorList:[]}},components:{Popover:element_ui_common.Popover,Tick:Tick,ColorPicker:element_ui_common.ColorPicker,AddIcon:AddIcon},created(){this.currentColor=this.selectedColor;let{type:type}=this;this.getcolor(type)},computed:{colorPalette(){let{templateColors:templateColors}=this||{},{additionalColors:additionalColors=[],customColorPalette:customColorPalette}=this||{};return customColorPalette||[...additionalColors,...templateColors]}},methods:{async addColor(color){if(!isEmpty$a(color)){let{customColor:customColor,colorList:colorList,type:type}=this;isEmpty$a(color)||(customColor=color),this.saveColor(customColor);let presentColor=colorList.filter((colors=>colors.colorCode===customColor));isEmpty$a(presentColor)||this.deleteColor(presentColor);let params={colorPalette:{keyName:type,colorCode:customColor}},url="/v2/colorPalette/add",{error:error,data:data}=await api/* API */.bl.post(url,params);error?this.$message.error(error.message||"Error occured"):isEmpty$a(presentColor)?colorList.length>8?this.deleteColor(colorList):this.getcolor(type):this.deleteColor(colorList)}},async getcolor(type){let params={keys:[type]},url="/v2/colorPalette/list",{error:error,data:data}=await api/* API */.bl.get(url,params);if(error)this.$message.error(error.message||"Error occured");else{let{[`${type}`]:record}=data.colorPalette||{};this.colorList=record.reverse()}},async deleteColor(record){let{type:type}=this,value=record[record.length-1],params={id:value.id},url="/v2/colorPalette/delete",{data:data}=await api/* API */.bl.post(url,params);data&&this.getcolor(type)},isActive(color){let{selectedColor:selectedColor}=this||{};return color===selectedColor},openCustomColor(){this.$refs["custom-color-palette"].handleTrigger()},saveColor(color){this.currentColor=color,this.$emit("currentColor",{color:color}),this.close()},close(){this.visibility=!1}}};
/* script */
const __vue_script__$7=script$7;
/* template */var __vue_render__$6=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("Popover",{attrs:{placement:"bottom",width:"320",trigger:"manual","popper-class":"richtext-color-picker"},scopedSlots:_vm._u([{key:"reference",fn:function(){return[_c("div",{on:{click:function($event){_vm.visibility=!0}}},[_vm._t("reference")],2)]},proxy:!0}],null,!0),model:{value:_vm.visibility,callback:function($$v){_vm.visibility=$$v},expression:"visibility"}},[_c("div",{staticClass:"empty-div",on:{click:_vm.close}}),_vm._v(" "),_c("div",{staticClass:"popup-container"},[_c("div",{staticClass:"w-full h-20"},[_c("div",{staticClass:"w-full mb-2.5"},[_vm._v("Custom Color")]),_vm._v(" "),_c("div",{staticClass:"flex h-9 custom-colors"},[_vm._l(_vm.colorList,(function(color,index){return _c("div",{key:index,staticClass:"custom-color-shade",style:{"background-color":""+color.colorCode},on:{click:function($event){return _vm.addColor(color.colorCode)}}},[_vm.selectedColor==color.colorCode?_c("Tick",{staticClass:"h-4 w-6"}):_vm._e()],1)})),_vm._v(" "),_c("ColorPicker",{ref:"custom-color-palette",attrs:{"popper-class":"custom-color-picker"},on:{input:_vm.addColor},model:{value:_vm.customColor,callback:function($$v){_vm.customColor=$$v},expression:"customColor"}})],2)]),_vm._v(" "),_vm._l(_vm.colorPalette,(function(color,index){return[_vm.isActive(color)?_c("div",{key:"dropdown-"+index,on:{click:function($event){return _vm.saveColor(color)}}},[_c("Tick",{staticClass:"color-shade",style:{"background-color":""+color}})],1):_c("div",{key:index,staticClass:"color-shade",style:{"background-color":""+color},on:{click:function($event){return _vm.saveColor(color)}}})]}))],2)])},__vue_staticRenderFns__$6=[];
/* style */
const __vue_inject_styles__$7=function(inject){inject&&(inject("data-v-77b45a69_0",{source:".richtext-color-picker[data-v-77b45a69]{height:335px!important;width:320px!important}.richtext-color-picker .empty-div[data-v-77b45a69]{width:400%;z-index:-1!important;height:100vh;position:absolute;opacity:0;left:-110px;top:-120px}.richtext-color-picker .popup-container[data-v-77b45a69]{display:flex;flex-wrap:wrap;flex-direction:row;align-items:center;justify-content:center;width:300px}.richtext-color-picker .color-shade[data-v-77b45a69]{height:25px;width:25px;display:flex;margin:0 5px 5px 0;justify-content:flex-end;border-radius:50%;border:.5px solid #e6dede;cursor:pointer}.richtext-color-picker .color-shade[data-v-77b45a69]:hover{box-shadow:0 1px 5px grey}.richtext-color-picker .custom-colors[data-v-77b45a69]{border-bottom:1px solid grey}.richtext-color-picker .custom-color-shade[data-v-77b45a69]{height:25px;width:25px;margin-right:5px;border-radius:50%;display:flex;align-items:center;cursor:pointer;border:.5px solid #e6dede}.richtext-color-picker .custom-color-shade[data-v-77b45a69]:hover{box-shadow:0 1px 5px grey}.richtext-color-picker .add-custom-color[data-v-77b45a69]:hover{background-color:#d6d1d1;border-radius:3px}",map:void 0,media:void 0}),inject("data-v-77b45a69_1",{source:".richtext-color-picker .el-color-picker__trigger{width:25px!important;height:25px!important;border-radius:50%!important;border:2px solid #5f6266!important}.richtext-color-picker .el-color-picker__empty{color:#5f6266!important;font-size:16px;font-weight:700;transform:rotate(-45deg);top:-1px;left:-1px}.richtext-color-picker .el-color-picker__color{border:none!important}.richtext-color-picker .el-color-picker__color-inner{background-color:none!important}",map:void 0,media:void 0}))},__vue_scope_id__$7="data-v-77b45a69",__vue_module_identifier__$7=void 0,__vue_is_functional_template__$7=!1,__vue_component__$6=normalizeComponent$a({render:__vue_render__$6,staticRenderFns:__vue_staticRenderFns__$6},__vue_inject_styles__$7,__vue_script__$7,__vue_scope_id__$7,__vue_is_functional_template__$7,__vue_module_identifier__$7,!1,createInjector$7,void 0,void 0),toolOrder=[{format:"undo",content:"Undo",icon:"undo"},{format:"redo",content:"Redo",icon:"redo"},"separator",{format:"fontfamily"},"separator",{format:"fontsize"},"separator",{format:"bold",content:"Bold",icon:"bold"},{format:"italic",content:"Italic",icon:"italics"},{format:"underline",content:"Underline",icon:"underline"},{format:"strike",content:"Strikethrough",icon:"strike-through"},{format:"bulletList",content:"Bulleted list",icon:"bulletin"},{format:"orderedList",content:"Numbered list",icon:"number-list"},{format:"link",content:"Link",icon:"link"},{format:"highlight"},{format:"setColor"},"separator",{format:"textalign"},"separator",{format:"addimage"},{format:"table"},{format:"blockquote",content:"Blockquote",icon:"quote"},{format:"indent-less",content:"Indent Less",icon:"indent-left"},{format:"indent-more",content:"Indent More",icon:"indent-right"},{format:"line",content:"Line",icon:"divider"}],Document=Node$1.create({name:"doc",topNode:!0,content:"block+"}),Paragraph=Node$1.create({name:"paragraph",priority:1e3,addOptions(){return{HTMLAttributes:{}}},group:"block",content:"inline*",parseHTML(){return[{tag:"p"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["p",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setParagraph:()=>({commands:commands})=>commands.setNode(this.name)}},addKeyboardShortcuts(){return{"Mod-Alt-0":()=>this.editor.commands.setParagraph()}}}),Text$1=Node$1.create({name:"text",group:"inline"}),starInputRegex$1=/(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/,starPasteRegex$1=/(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g,underscoreInputRegex$1=/(?:^|\s)((?:__)((?:[^__]+))(?:__))$/,underscorePasteRegex$1=/(?:^|\s)((?:__)((?:[^__]+))(?:__))/g,Bold=Mark.create({name:"bold",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"strong"},{tag:"b",getAttrs:node=>"normal"!==node.style.fontWeight&&null},{style:"font-weight",getAttrs:value=>/^(bold(er)?|[5-9]\d{2,})$/.test(value)&&null}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["strong",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setBold:()=>({commands:commands})=>commands.setMark(this.name),toggleBold:()=>({commands:commands})=>commands.toggleMark(this.name),unsetBold:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-b":()=>this.editor.commands.toggleBold(),"Mod-B":()=>this.editor.commands.toggleBold()}},addInputRules(){return[markInputRule({find:starInputRegex$1,type:this.type}),markInputRule({find:underscoreInputRegex$1,type:this.type})]},addPasteRules(){return[markPasteRule({find:starPasteRegex$1,type:this.type}),markPasteRule({find:underscorePasteRegex$1,type:this.type})]}}),starInputRegex=/(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/,starPasteRegex=/(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g,underscoreInputRegex=/(?:^|\s)((?:_)((?:[^_]+))(?:_))$/,underscorePasteRegex=/(?:^|\s)((?:_)((?:[^_]+))(?:_))/g,Italic=Mark.create({name:"italic",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"em"},{tag:"i",getAttrs:node=>"normal"!==node.style.fontStyle&&null},{style:"font-style=italic"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["em",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setItalic:()=>({commands:commands})=>commands.setMark(this.name),toggleItalic:()=>({commands:commands})=>commands.toggleMark(this.name),unsetItalic:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-i":()=>this.editor.commands.toggleItalic(),"Mod-I":()=>this.editor.commands.toggleItalic()}},addInputRules(){return[markInputRule({find:starInputRegex,type:this.type}),markInputRule({find:underscoreInputRegex,type:this.type})]},addPasteRules(){return[markPasteRule({find:starPasteRegex,type:this.type}),markPasteRule({find:underscorePasteRegex,type:this.type})]}}),Underline=Mark.create({name:"underline",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"u"},{style:"text-decoration",consuming:!1,getAttrs:style=>!!style.includes("underline")&&{}}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["u",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setUnderline:()=>({commands:commands})=>commands.setMark(this.name),toggleUnderline:()=>({commands:commands})=>commands.toggleMark(this.name),unsetUnderline:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-u":()=>this.editor.commands.toggleUnderline(),"Mod-U":()=>this.editor.commands.toggleUnderline()}}}),inputRegex$5=/(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/,pasteRegex$1=/(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g,Strike=Mark.create({name:"strike",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"s"},{tag:"del"},{tag:"strike"},{style:"text-decoration",consuming:!1,getAttrs:style=>!!style.includes("line-through")&&{}}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["s",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setStrike:()=>({commands:commands})=>commands.setMark(this.name),toggleStrike:()=>({commands:commands})=>commands.toggleMark(this.name),unsetStrike:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-Shift-x":()=>this.editor.commands.toggleStrike()}},addInputRules(){return[markInputRule({find:inputRegex$5,type:this.type})]},addPasteRules(){return[markPasteRule({find:pasteRegex$1,type:this.type})]}}),ListItem$2=Node$1.create({name:"listItem",addOptions(){return{HTMLAttributes:{}}},content:"paragraph block*",defining:!0,parseHTML(){return[{tag:"li"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["li",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]},addKeyboardShortcuts(){return{Enter:()=>this.editor.commands.splitListItem(this.name),Tab:()=>this.editor.commands.sinkListItem(this.name),"Shift-Tab":()=>this.editor.commands.liftListItem(this.name)}}}),ListItem$1=Node$1.create({name:"listItem",addOptions(){return{HTMLAttributes:{}}},content:"paragraph block*",defining:!0,parseHTML(){return[{tag:"li"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["li",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]},addKeyboardShortcuts(){return{Enter:()=>this.editor.commands.splitListItem(this.name),Tab:()=>this.editor.commands.sinkListItem(this.name),"Shift-Tab":()=>this.editor.commands.liftListItem(this.name)}}}),TextStyle$2=Mark.create({name:"textStyle",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"span",getAttrs:element=>{const hasStyles=element.hasAttribute("style");return!!hasStyles&&{}}}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["span",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{removeEmptyTextStyle:()=>({state:state,commands:commands})=>{const attributes=getMarkAttributes(state,this.type),hasStyles=Object.entries(attributes).some((([,value])=>!!value));return!!hasStyles||commands.unsetMark(this.name)}}}}),inputRegex$4=/^\s*([-+*])\s$/,BulletList=Node$1.create({name:"bulletList",addOptions(){return{itemTypeName:"listItem",HTMLAttributes:{},keepMarks:!1,keepAttributes:!1}},group:"block list",content(){return`${this.options.itemTypeName}+`},parseHTML(){return[{tag:"ul"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["ul",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{toggleBulletList:()=>({commands:commands,chain:chain})=>this.options.keepAttributes?chain().toggleList(this.name,this.options.itemTypeName,this.options.keepMarks).updateAttributes(ListItem$1.name,this.editor.getAttributes(TextStyle$2.name)).run():commands.toggleList(this.name,this.options.itemTypeName,this.options.keepMarks)}},addKeyboardShortcuts(){return{"Mod-Shift-8":()=>this.editor.commands.toggleBulletList()}},addInputRules(){let inputRule=wrappingInputRule({find:inputRegex$4,type:this.type});return(this.options.keepMarks||this.options.keepAttributes)&&(inputRule=wrappingInputRule({find:inputRegex$4,type:this.type,keepMarks:this.options.keepMarks,keepAttributes:this.options.keepAttributes,getAttributes:()=>this.editor.getAttributes(TextStyle$2.name),editor:this.editor})),[inputRule]}}),TextStyle$1=Mark.create({name:"textStyle",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"span",getAttrs:element=>{const hasStyles=element.hasAttribute("style");return!!hasStyles&&{}}}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["span",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{removeEmptyTextStyle:()=>({state:state,commands:commands})=>{const attributes=getMarkAttributes(state,this.type),hasStyles=Object.entries(attributes).some((([,value])=>!!value));return!!hasStyles||commands.unsetMark(this.name)}}}}),FontFamily=Extension.create({name:"fontFamily",addOptions(){return{types:["textStyle"]}},addGlobalAttributes(){return[{types:this.options.types,attributes:{fontFamily:{default:null,parseHTML:element=>{var _a;return null===(_a=element.style.fontFamily)||void 0===_a?void 0:_a.replace(/['"]+/g,"")},renderHTML:attributes=>attributes.fontFamily?{style:`font-family: ${attributes.fontFamily}`}:{}}}}]},addCommands(){return{setFontFamily:fontFamily=>({chain:chain})=>chain().setMark("textStyle",{fontFamily:fontFamily}).run(),unsetFontFamily:()=>({chain:chain})=>chain().setMark("textStyle",{fontFamily:null}).removeEmptyTextStyle().run()}}}),ListItem=Node$1.create({name:"listItem",addOptions(){return{HTMLAttributes:{}}},content:"paragraph block*",defining:!0,parseHTML(){return[{tag:"li"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["li",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]},addKeyboardShortcuts(){return{Enter:()=>this.editor.commands.splitListItem(this.name),Tab:()=>this.editor.commands.sinkListItem(this.name),"Shift-Tab":()=>this.editor.commands.liftListItem(this.name)}}}),TextStyle=Mark.create({name:"textStyle",addOptions(){return{HTMLAttributes:{}}},parseHTML(){return[{tag:"span",getAttrs:element=>{const hasStyles=element.hasAttribute("style");return!!hasStyles&&{}}}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["span",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{removeEmptyTextStyle:()=>({state:state,commands:commands})=>{const attributes=getMarkAttributes(state,this.type),hasStyles=Object.entries(attributes).some((([,value])=>!!value));return!!hasStyles||commands.unsetMark(this.name)}}}}),inputRegex$3=/^(\d+)\.\s$/,OrderedList=Node$1.create({name:"orderedList",addOptions(){return{itemTypeName:"listItem",HTMLAttributes:{},keepMarks:!1,keepAttributes:!1}},group:"block list",content(){return`${this.options.itemTypeName}+`},addAttributes(){return{start:{default:1,parseHTML:element=>element.hasAttribute("start")?parseInt(element.getAttribute("start")||"",10):1}}},parseHTML(){return[{tag:"ol"}]},renderHTML({HTMLAttributes:HTMLAttributes}){const{start:start,...attributesWithoutStart}=HTMLAttributes;return 1===start?["ol",mergeAttributes(this.options.HTMLAttributes,attributesWithoutStart),0]:["ol",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{toggleOrderedList:()=>({commands:commands,chain:chain})=>this.options.keepAttributes?chain().toggleList(this.name,this.options.itemTypeName,this.options.keepMarks).updateAttributes(ListItem.name,this.editor.getAttributes(TextStyle.name)).run():commands.toggleList(this.name,this.options.itemTypeName,this.options.keepMarks)}},addKeyboardShortcuts(){return{"Mod-Shift-7":()=>this.editor.commands.toggleOrderedList()}},addInputRules(){let inputRule=wrappingInputRule({find:inputRegex$3,type:this.type,getAttributes:match=>({start:+match[1]}),joinPredicate:(match,node)=>node.childCount+node.attrs.start===+match[1]});return(this.options.keepMarks||this.options.keepAttributes)&&(inputRule=wrappingInputRule({find:inputRegex$3,type:this.type,keepMarks:this.options.keepMarks,keepAttributes:this.options.keepAttributes,getAttributes:match=>({start:+match[1],...this.editor.getAttributes(TextStyle.name)}),joinPredicate:(match,node)=>node.childCount+node.attrs.start===+match[1],editor:this.editor})),[inputRule]}});
/* scoped */
/**
Gap cursor selections are represented using this class. Its
`$anchor` and `$head` properties both point at the cursor position.
*/
class GapCursor extends Selection{
/**
    Create a gap cursor.
    */
constructor($pos){super($pos,$pos)}map(doc,mapping){let $pos=doc.resolve(mapping.map(this.head));return GapCursor.valid($pos)?new GapCursor($pos):Selection.near($pos)}content(){return Slice.empty}eq(other){return other instanceof GapCursor&&other.head==this.head}toJSON(){return{type:"gapcursor",pos:this.head}}
/**
    @internal
    */static fromJSON(doc,json){if("number"!=typeof json.pos)throw new RangeError("Invalid input for GapCursor.fromJSON");return new GapCursor(doc.resolve(json.pos))}
/**
    @internal
    */getBookmark(){return new GapBookmark(this.anchor)}
/**
    @internal
    */static valid($pos){let parent=$pos.parent;if(parent.isTextblock||!closedBefore($pos)||!closedAfter($pos))return!1;let override=parent.type.spec.allowGapCursor;if(null!=override)return override;let deflt=parent.contentMatchAt($pos.index()).defaultType;return deflt&&deflt.isTextblock}
/**
    @internal
    */static findGapCursorFrom($pos,dir,mustMove=!1){search:for(;;){if(!mustMove&&GapCursor.valid($pos))return $pos;let pos=$pos.pos,next=null;
// Scan up from this position
for(let d=$pos.depth;;d--){let parent=$pos.node(d);if(dir>0?$pos.indexAfter(d)<parent.childCount:$pos.index(d)>0){next=parent.child(dir>0?$pos.indexAfter(d):$pos.index(d)-1);break}if(0==d)return null;pos+=dir;let $cur=$pos.doc.resolve(pos);if(GapCursor.valid($cur))return $cur}
// And then down into the next node
for(;;){let inside=dir>0?next.firstChild:next.lastChild;if(!inside){if(next.isAtom&&!next.isText&&!NodeSelection.isSelectable(next)){$pos=$pos.doc.resolve(pos+next.nodeSize*dir),mustMove=!1;continue search}break}next=inside,pos+=dir;let $cur=$pos.doc.resolve(pos);if(GapCursor.valid($cur))return $cur}return null}}}GapCursor.prototype.visible=!1,GapCursor.findFrom=GapCursor.findGapCursorFrom,Selection.jsonID("gapcursor",GapCursor);class GapBookmark{constructor(pos){this.pos=pos}map(mapping){return new GapBookmark(mapping.map(this.pos))}resolve(doc){let $pos=doc.resolve(this.pos);return GapCursor.valid($pos)?new GapCursor($pos):Selection.near($pos)}}function closedBefore($pos){for(let d=$pos.depth;d>=0;d--){let index=$pos.index(d),parent=$pos.node(d);
// At the start of this parent, look at next one
if(0!=index)
// See if the node before (or its first ancestor) is closed
for(let before=parent.child(index-1);;before=before.lastChild){if(0==before.childCount&&!before.inlineContent||before.isAtom||before.type.spec.isolating)return!0;if(before.inlineContent)return!1}else if(parent.type.spec.isolating)return!0}
// Hit start of document
return!0}function closedAfter($pos){for(let d=$pos.depth;d>=0;d--){let index=$pos.indexAfter(d),parent=$pos.node(d);if(index!=parent.childCount)for(let after=parent.child(index);;after=after.firstChild){if(0==after.childCount&&!after.inlineContent||after.isAtom||after.type.spec.isolating)return!0;if(after.inlineContent)return!1}else if(parent.type.spec.isolating)return!0}return!0}
/**
Create a gap cursor plugin. When enabled, this will capture clicks
near and arrow-key-motion past places that don't have a normally
selectable position nearby, and create a gap cursor selection for
them. The cursor is drawn as an element with class
`ProseMirror-gapcursor`. You can either include
`style/gapcursor.css` from the package's directory or add your own
styles to make it visible.
*/function gapCursor(){return new Plugin({props:{decorations:drawGapCursor,createSelectionBetween(_view,$anchor,$head){return $anchor.pos==$head.pos&&GapCursor.valid($head)?new GapCursor($head):null},handleClick:handleClick,handleKeyDown:handleKeyDown$1,handleDOMEvents:{beforeinput:beforeinput}}})}const handleKeyDown$1=keydownHandler({ArrowLeft:arrow$3("horiz",-1),ArrowRight:arrow$3("horiz",1),ArrowUp:arrow$3("vert",-1),ArrowDown:arrow$3("vert",1)});function arrow$3(axis,dir){const dirStr="vert"==axis?dir>0?"down":"up":dir>0?"right":"left";return function(state,dispatch,view){let sel=state.selection,$start=dir>0?sel.$to:sel.$from,mustMove=sel.empty;if(sel instanceof TextSelection){if(!view.endOfTextblock(dirStr)||0==$start.depth)return!1;mustMove=!1,$start=state.doc.resolve(dir>0?$start.after():$start.before())}let $found=GapCursor.findGapCursorFrom($start,dir,mustMove);return!!$found&&(dispatch&&dispatch(state.tr.setSelection(new GapCursor($found))),!0)}}function handleClick(view,pos,event){if(!view||!view.editable)return!1;let $pos=view.state.doc.resolve(pos);if(!GapCursor.valid($pos))return!1;let clickPos=view.posAtCoords({left:event.clientX,top:event.clientY});return!(clickPos&&clickPos.inside>-1&&NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))&&(view.dispatch(view.state.tr.setSelection(new GapCursor($pos))),!0)}
// This is a hack that, when a composition starts while a gap cursor
// is active, quickly creates an inline context for the composition to
// happen in, to avoid it being aborted by the DOM selection being
// moved into a valid position.
function beforeinput(view,event){if("insertCompositionText"!=event.inputType||!(view.state.selection instanceof GapCursor))return!1;let{$from:$from}=view.state.selection,insert=$from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);if(!insert)return!1;let frag=Fragment.empty;for(let i=insert.length-1;i>=0;i--)frag=Fragment.from(insert[i].createAndFill(null,frag));let tr=view.state.tr.replace($from.pos,$from.pos,new Slice(frag,0,0));return tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos+1))),view.dispatch(tr),!1}function drawGapCursor(state){if(!(state.selection instanceof GapCursor))return null;let node=document.createElement("div");return node.className="ProseMirror-gapcursor",DecorationSet.create(state.doc,[Decoration.widget(state.selection.head,node,{key:"gapcursor"})])}const Gapcursor=Extension.create({name:"gapCursor",addProseMirrorPlugins(){return[gapCursor()]},extendNodeSchema(extension){var _a;const context={name:extension.name,options:extension.options,storage:extension.storage};return{allowGapCursor:null!==(_a=callOrReturn(getExtensionField(extension,"allowGapCursor",context)))&&void 0!==_a?_a:null}}}),Heading=Node$1.create({name:"heading",addOptions(){return{levels:[1,2,3,4,5,6],HTMLAttributes:{}}},content:"inline*",group:"block",defining:!0,addAttributes(){return{level:{default:1,rendered:!1}}},parseHTML(){return this.options.levels.map((level=>({tag:`h${level}`,attrs:{level:level}})))},renderHTML({node:node,HTMLAttributes:HTMLAttributes}){const hasLevel=this.options.levels.includes(node.attrs.level),level=hasLevel?node.attrs.level:this.options.levels[0];return[`h${level}`,mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setHeading:attributes=>({commands:commands})=>!!this.options.levels.includes(attributes.level)&&commands.setNode(this.name,attributes),toggleHeading:attributes=>({commands:commands})=>!!this.options.levels.includes(attributes.level)&&commands.toggleNode(this.name,"paragraph",attributes)}},addKeyboardShortcuts(){return this.options.levels.reduce(((items,level)=>({...items,[`Mod-Alt-${level}`]:()=>this.editor.commands.toggleHeading({level:level})})),{})},addInputRules(){return this.options.levels.map((level=>textblockTypeInputRule({find:new RegExp(`^(#{1,${level}})\\s$`),type:this.type,getAttributes:{level:level}})))}});var GOOD_LEAF_SIZE=200,RopeSequence=function(){};
// :: class<T> A rope sequence is a persistent sequence data structure
// that supports appending, prepending, and slicing without doing a
// full copy. It is represented as a mostly-balanced tree.
RopeSequence.prototype.append=function(other){return other.length?(other=RopeSequence.from(other),!this.length&&other||other.length<GOOD_LEAF_SIZE&&this.leafAppend(other)||this.length<GOOD_LEAF_SIZE&&other.leafPrepend(this)||this.appendInner(other)):this},
// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>
// Prepend an array or other rope to this one, returning a new rope.
RopeSequence.prototype.prepend=function(other){return other.length?RopeSequence.from(other).append(this):this},RopeSequence.prototype.appendInner=function(other){return new Append(this,other)},
// :: (?number, ?number) → RopeSequence<T>
// Create a rope repesenting a sub-sequence of this rope.
RopeSequence.prototype.slice=function(from,to){return void 0===from&&(from=0),void 0===to&&(to=this.length),from>=to?RopeSequence.empty:this.sliceInner(Math.max(0,from),Math.min(this.length,to))},
// :: (number) → T
// Retrieve the element at the given position from this rope.
RopeSequence.prototype.get=function(i){if(!(i<0||i>=this.length))return this.getInner(i)},
// :: ((element: T, index: number) → ?bool, ?number, ?number)
// Call the given function for each element between the given
// indices. This tends to be more efficient than looping over the
// indices and calling `get`, because it doesn't have to descend the
// tree for every element.
RopeSequence.prototype.forEach=function(f,from,to){void 0===from&&(from=0),void 0===to&&(to=this.length),from<=to?this.forEachInner(f,from,to,0):this.forEachInvertedInner(f,from,to,0)},
// :: ((element: T, index: number) → U, ?number, ?number) → [U]
// Map the given functions over the elements of the rope, producing
// a flat array.
RopeSequence.prototype.map=function(f,from,to){void 0===from&&(from=0),void 0===to&&(to=this.length);var result=[];return this.forEach((function(elt,i){return result.push(f(elt,i))}),from,to),result},
// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>
// Create a rope representing the given array, or return the rope
// itself if a rope was given.
RopeSequence.from=function(values){return values instanceof RopeSequence?values:values&&values.length?new Leaf(values):RopeSequence.empty};var Leaf=function(RopeSequence){function Leaf(values){RopeSequence.call(this),this.values=values}RopeSequence&&(Leaf.__proto__=RopeSequence),Leaf.prototype=Object.create(RopeSequence&&RopeSequence.prototype),Leaf.prototype.constructor=Leaf;var prototypeAccessors={length:{configurable:!0},depth:{configurable:!0}};return Leaf.prototype.flatten=function(){return this.values},Leaf.prototype.sliceInner=function(from,to){return 0==from&&to==this.length?this:new Leaf(this.values.slice(from,to))},Leaf.prototype.getInner=function(i){return this.values[i]},Leaf.prototype.forEachInner=function(f,from,to,start){for(var i=from;i<to;i++)if(!1===f(this.values[i],start+i))return!1},Leaf.prototype.forEachInvertedInner=function(f,from,to,start){for(var i=from-1;i>=to;i--)if(!1===f(this.values[i],start+i))return!1},Leaf.prototype.leafAppend=function(other){if(this.length+other.length<=GOOD_LEAF_SIZE)return new Leaf(this.values.concat(other.flatten()))},Leaf.prototype.leafPrepend=function(other){if(this.length+other.length<=GOOD_LEAF_SIZE)return new Leaf(other.flatten().concat(this.values))},prototypeAccessors.length.get=function(){return this.values.length},prototypeAccessors.depth.get=function(){return 0},Object.defineProperties(Leaf.prototype,prototypeAccessors),Leaf}(RopeSequence);
// :: RopeSequence
// The empty rope sequence.
RopeSequence.empty=new Leaf([]);var Append=function(RopeSequence){function Append(left,right){RopeSequence.call(this),this.left=left,this.right=right,this.length=left.length+right.length,this.depth=Math.max(left.depth,right.depth)+1}return RopeSequence&&(Append.__proto__=RopeSequence),Append.prototype=Object.create(RopeSequence&&RopeSequence.prototype),Append.prototype.constructor=Append,Append.prototype.flatten=function(){return this.left.flatten().concat(this.right.flatten())},Append.prototype.getInner=function(i){return i<this.left.length?this.left.get(i):this.right.get(i-this.left.length)},Append.prototype.forEachInner=function(f,from,to,start){var leftLen=this.left.length;return!(from<leftLen&&!1===this.left.forEachInner(f,from,Math.min(to,leftLen),start))&&(!(to>leftLen&&!1===this.right.forEachInner(f,Math.max(from-leftLen,0),Math.min(this.length,to)-leftLen,start+leftLen))&&void 0)},Append.prototype.forEachInvertedInner=function(f,from,to,start){var leftLen=this.left.length;return!(from>leftLen&&!1===this.right.forEachInvertedInner(f,from-leftLen,Math.max(to,leftLen)-leftLen,start+leftLen))&&(!(to<leftLen&&!1===this.left.forEachInvertedInner(f,Math.min(from,leftLen),to,start))&&void 0)},Append.prototype.sliceInner=function(from,to){if(0==from&&to==this.length)return this;var leftLen=this.left.length;return to<=leftLen?this.left.slice(from,to):from>=leftLen?this.right.slice(from-leftLen,to-leftLen):this.left.slice(from,leftLen).append(this.right.slice(0,to-leftLen))},Append.prototype.leafAppend=function(other){var inner=this.right.leafAppend(other);if(inner)return new Append(this.left,inner)},Append.prototype.leafPrepend=function(other){var inner=this.left.leafPrepend(other);if(inner)return new Append(inner,this.right)},Append.prototype.appendInner=function(other){return this.left.depth>=Math.max(this.right.depth,other.depth)+1?new Append(this.left,new Append(this.right,other)):new Append(this,other)},Append}(RopeSequence),ropeSequence=RopeSequence;
// ProseMirror's history isn't simply a way to roll back to a previous
// state, because ProseMirror supports applying changes without adding
// them to the history (for example during collaboration).
// To this end, each 'Branch' (one for the undo history and one for
// the redo history) keeps an array of 'Items', which can optionally
// hold a step (an actual undoable change), and always hold a position
// map (which is needed to move changes below them to apply to the
// current document).
// An item that has both a step and a selection bookmark is the start
// of an 'event' — a group of changes that will be undone or redone at
// once. (It stores only the bookmark, since that way we don't have to
// provide a document until the selection is actually applied, which
// is useful when compressing.)
// Used to schedule history compression
const max_empty_items=500;class Branch{constructor(items,eventCount){this.items=items,this.eventCount=eventCount}
// Pop the latest event off the branch's history and apply it
// to a document transform.
popEvent(state,preserveItems){if(0==this.eventCount)return null;let remap,mapFrom,end=this.items.length;for(;;end--){let next=this.items.get(end-1);if(next.selection){--end;break}}preserveItems&&(remap=this.remapping(end,this.items.length),mapFrom=remap.maps.length);let selection,remaining,transform=state.tr,addAfter=[],addBefore=[];return this.items.forEach(((item,i)=>{if(!item.step)return remap||(remap=this.remapping(end,i+1),mapFrom=remap.maps.length),mapFrom--,void addBefore.push(item);if(remap){addBefore.push(new Item(item.map));let map,step=item.step.map(remap.slice(mapFrom));step&&transform.maybeStep(step).doc&&(map=transform.mapping.maps[transform.mapping.maps.length-1],addAfter.push(new Item(map,void 0,void 0,addAfter.length+addBefore.length))),mapFrom--,map&&remap.appendMap(map,mapFrom)}else transform.maybeStep(item.step);return item.selection?(selection=remap?item.selection.map(remap.slice(mapFrom)):item.selection,remaining=new Branch(this.items.slice(0,end).append(addBefore.reverse().concat(addAfter)),this.eventCount-1),!1):void 0}),this.items.length,0),{remaining:remaining,transform:transform,selection:selection}}
// Create a new branch with the given transform added.
addTransform(transform,selection,histOptions,preserveItems){let newItems=[],eventCount=this.eventCount,oldItems=this.items,lastItem=!preserveItems&&oldItems.length?oldItems.get(oldItems.length-1):null;for(let i=0;i<transform.steps.length;i++){let merged,step=transform.steps[i].invert(transform.docs[i]),item=new Item(transform.mapping.maps[i],step,selection);(merged=lastItem&&lastItem.merge(item))&&(item=merged,i?newItems.pop():oldItems=oldItems.slice(0,oldItems.length-1)),newItems.push(item),selection&&(eventCount++,selection=void 0),preserveItems||(lastItem=item)}let overflow=eventCount-histOptions.depth;return overflow>DEPTH_OVERFLOW&&(oldItems=cutOffEvents(oldItems,overflow),eventCount-=overflow),new Branch(oldItems.append(newItems),eventCount)}remapping(from,to){let maps=new Mapping;return this.items.forEach(((item,i)=>{let mirrorPos=null!=item.mirrorOffset&&i-item.mirrorOffset>=from?maps.maps.length-item.mirrorOffset:void 0;maps.appendMap(item.map,mirrorPos)}),from,to),maps}addMaps(array){return 0==this.eventCount?this:new Branch(this.items.append(array.map((map=>new Item(map)))),this.eventCount)}
// When the collab module receives remote changes, the history has
// to know about those, so that it can adjust the steps that were
// rebased on top of the remote changes, and include the position
// maps for the remote changes in its array of items.
rebased(rebasedTransform,rebasedCount){if(!this.eventCount)return this;let rebasedItems=[],start=Math.max(0,this.items.length-rebasedCount),mapping=rebasedTransform.mapping,newUntil=rebasedTransform.steps.length,eventCount=this.eventCount;this.items.forEach((item=>{item.selection&&eventCount--}),start);let iRebased=rebasedCount;this.items.forEach((item=>{let pos=mapping.getMirror(--iRebased);if(null==pos)return;newUntil=Math.min(newUntil,pos);let map=mapping.maps[pos];if(item.step){let step=rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]),selection=item.selection&&item.selection.map(mapping.slice(iRebased+1,pos));selection&&eventCount++,rebasedItems.push(new Item(map,step,selection))}else rebasedItems.push(new Item(map))}),start);let newMaps=[];for(let i=rebasedCount;i<newUntil;i++)newMaps.push(new Item(mapping.maps[i]));let items=this.items.slice(0,start).append(newMaps).append(rebasedItems),branch=new Branch(items,eventCount);return branch.emptyItemCount()>max_empty_items&&(branch=branch.compress(this.items.length-rebasedItems.length)),branch}emptyItemCount(){let count=0;return this.items.forEach((item=>{item.step||count++})),count}
// Compressing a branch means rewriting it to push the air (map-only
// items) out. During collaboration, these naturally accumulate
// because each remote change adds one. The `upto` argument is used
// to ensure that only the items below a given level are compressed,
// because `rebased` relies on a clean, untouched set of items in
// order to associate old items with rebased steps.
compress(upto=this.items.length){let remap=this.remapping(0,upto),mapFrom=remap.maps.length,items=[],events=0;return this.items.forEach(((item,i)=>{if(i>=upto)items.push(item),item.selection&&events++;else if(item.step){let step=item.step.map(remap.slice(mapFrom)),map=step&&step.getMap();if(mapFrom--,map&&remap.appendMap(map,mapFrom),step){let selection=item.selection&&item.selection.map(remap.slice(mapFrom));selection&&events++;let merged,newItem=new Item(map.invert(),step,selection),last=items.length-1;(merged=items.length&&items[last].merge(newItem))?items[last]=merged:items.push(newItem)}}else item.map&&mapFrom--}),this.items.length,0),new Branch(ropeSequence.from(items.reverse()),events)}}function cutOffEvents(items,n){let cutPoint;return items.forEach(((item,i)=>{if(item.selection&&0==n--)return cutPoint=i,!1})),items.slice(cutPoint)}Branch.empty=new Branch(ropeSequence.empty,0);class Item{constructor(
// The (forward) step map for this item.
map,
// The inverted step
step,
// If this is non-null, this item is the start of a group, and
// this selection is the starting selection for the group (the one
// that was active before the first step was applied)
selection,
// If this item is the inverse of a previous mapping on the stack,
// this points at the inverse's offset
mirrorOffset){this.map=map,this.step=step,this.selection=selection,this.mirrorOffset=mirrorOffset}merge(other){if(this.step&&other.step&&!other.selection){let step=other.step.merge(this.step);if(step)return new Item(step.getMap().invert(),step,this.selection)}}}
// The value of the state field that tracks undo/redo history for that
// state. Will be stored in the plugin state when the history plugin
// is active.
class HistoryState{constructor(done,undone,prevRanges,prevTime){this.done=done,this.undone=undone,this.prevRanges=prevRanges,this.prevTime=prevTime}}const DEPTH_OVERFLOW=20;
// Record a transformation in undo history.
function applyTransaction(history,state,tr,options){let rebased,historyTr=tr.getMeta(historyKey);if(historyTr)return historyTr.historyState;tr.getMeta(closeHistoryKey)&&(history=new HistoryState(history.done,history.undone,null,0));let appended=tr.getMeta("appendedTransaction");if(0==tr.steps.length)return history;if(appended&&appended.getMeta(historyKey))return appended.getMeta(historyKey).redo?new HistoryState(history.done.addTransform(tr,void 0,options,mustPreserveItems(state)),history.undone,rangesFor(tr.mapping.maps[tr.steps.length-1]),history.prevTime):new HistoryState(history.done,history.undone.addTransform(tr,void 0,options,mustPreserveItems(state)),null,history.prevTime);if(!1===tr.getMeta("addToHistory")||appended&&!1===appended.getMeta("addToHistory"))return(rebased=tr.getMeta("rebased"))?new HistoryState(history.done.rebased(tr,rebased),history.undone.rebased(tr,rebased),mapRanges(history.prevRanges,tr.mapping),history.prevTime):new HistoryState(history.done.addMaps(tr.mapping.maps),history.undone.addMaps(tr.mapping.maps),mapRanges(history.prevRanges,tr.mapping),history.prevTime);{
// Group transforms that occur in quick succession into one event.
let newGroup=0==history.prevTime||!appended&&(history.prevTime<(tr.time||0)-options.newGroupDelay||!isAdjacentTo(tr,history.prevRanges)),prevRanges=appended?mapRanges(history.prevRanges,tr.mapping):rangesFor(tr.mapping.maps[tr.steps.length-1]);return new HistoryState(history.done.addTransform(tr,newGroup?state.selection.getBookmark():void 0,options,mustPreserveItems(state)),Branch.empty,prevRanges,tr.time)}}function isAdjacentTo(transform,prevRanges){if(!prevRanges)return!1;if(!transform.docChanged)return!0;let adjacent=!1;return transform.mapping.maps[0].forEach(((start,end)=>{for(let i=0;i<prevRanges.length;i+=2)start<=prevRanges[i+1]&&end>=prevRanges[i]&&(adjacent=!0)})),adjacent}function rangesFor(map){let result=[];return map.forEach(((_from,_to,from,to)=>result.push(from,to))),result}function mapRanges(ranges,mapping){if(!ranges)return null;let result=[];for(let i=0;i<ranges.length;i+=2){let from=mapping.map(ranges[i],1),to=mapping.map(ranges[i+1],-1);from<=to&&result.push(from,to)}return result}
// Apply the latest event from one branch to the document and shift the event
// onto the other branch.
function histTransaction(history,state,dispatch,redo){let preserveItems=mustPreserveItems(state),histOptions=historyKey.get(state).spec.config,pop=(redo?history.undone:history.done).popEvent(state,preserveItems);if(!pop)return;let selection=pop.selection.resolve(pop.transform.doc),added=(redo?history.done:history.undone).addTransform(pop.transform,state.selection.getBookmark(),histOptions,preserveItems),newHist=new HistoryState(redo?added:pop.remaining,redo?pop.remaining:added,null,0);dispatch(pop.transform.setSelection(selection).setMeta(historyKey,{redo:redo,historyState:newHist}).scrollIntoView())}let cachedPreserveItems=!1,cachedPreserveItemsPlugins=null;
// Check whether any plugin in the given state has a
// `historyPreserveItems` property in its spec, in which case we must
// preserve steps exactly as they came in, so that they can be
// rebased.
function mustPreserveItems(state){let plugins=state.plugins;if(cachedPreserveItemsPlugins!=plugins){cachedPreserveItems=!1,cachedPreserveItemsPlugins=plugins;for(let i=0;i<plugins.length;i++)if(plugins[i].spec.historyPreserveItems){cachedPreserveItems=!0;break}}return cachedPreserveItems}const historyKey=new PluginKey("history"),closeHistoryKey=new PluginKey("closeHistory");
/**
Returns a plugin that enables the undo history for an editor. The
plugin will track undo and redo stacks, which can be used with the
[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.

You can set an `"addToHistory"` [metadata
property](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction
to prevent it from being rolled back by undo.
*/
function forms_history(config={}){return config={depth:config.depth||100,newGroupDelay:config.newGroupDelay||500},new Plugin({key:historyKey,state:{init(){return new HistoryState(Branch.empty,Branch.empty,null,0)},apply(tr,hist,state){return applyTransaction(hist,state,tr,config)}},config:config,props:{handleDOMEvents:{beforeinput(view,e){let inputType=e.inputType,command="historyUndo"==inputType?undo:"historyRedo"==inputType?redo:null;return!!command&&(e.preventDefault(),command(view.state,view.dispatch))}}}})}
/**
A command function that undoes the last change, if any.
*/const undo=(state,dispatch)=>{let hist=historyKey.getState(state);return!(!hist||0==hist.done.eventCount)&&(dispatch&&histTransaction(hist,state,dispatch,!1),!0)},redo=(state,dispatch)=>{let hist=historyKey.getState(state);return!(!hist||0==hist.undone.eventCount)&&(dispatch&&histTransaction(hist,state,dispatch,!0),!0)},History=Extension.create({name:"history",addOptions(){return{depth:100,newGroupDelay:500}},addCommands(){return{undo:()=>({state:state,dispatch:dispatch})=>undo(state,dispatch),redo:()=>({state:state,dispatch:dispatch})=>redo(state,dispatch)}},addProseMirrorPlugins(){return[forms_history(this.options)]},addKeyboardShortcuts(){return{"Mod-z":()=>this.editor.commands.undo(),"Mod-y":()=>this.editor.commands.redo(),"Shift-Mod-z":()=>this.editor.commands.redo()
// Russian keyboard layouts
,"Mod-я":()=>this.editor.commands.undo(),"Shift-Mod-я":()=>this.editor.commands.redo()}}}),TextAlign=Extension.create({name:"textAlign",addOptions(){return{types:[],alignments:["left","center","right","justify"],defaultAlignment:"left"}},addGlobalAttributes(){return[{types:this.options.types,attributes:{textAlign:{default:this.options.defaultAlignment,parseHTML:element=>element.style.textAlign||this.options.defaultAlignment,renderHTML:attributes=>attributes.textAlign===this.options.defaultAlignment?{}:{style:`text-align: ${attributes.textAlign}`}}}}]},addCommands(){return{setTextAlign:alignment=>({commands:commands})=>!!this.options.alignments.includes(alignment)&&this.options.types.every((type=>commands.updateAttributes(type,{textAlign:alignment}))),unsetTextAlign:()=>({commands:commands})=>this.options.types.every((type=>commands.resetAttributes(type,"textAlign")))}},addKeyboardShortcuts(){return{"Mod-Shift-l":()=>this.editor.commands.setTextAlign("left"),"Mod-Shift-e":()=>this.editor.commands.setTextAlign("center"),"Mod-Shift-r":()=>this.editor.commands.setTextAlign("right"),"Mod-Shift-j":()=>this.editor.commands.setTextAlign("justify")}}});
/**
A command function that redoes the last undone change, if any.
*/
// src/index.ts
// src/tablemap.ts
var readFromCache,addToCache;if("undefined"!=typeof WeakMap){let cache=new WeakMap;readFromCache=key=>cache.get(key),addToCache=(key,value)=>(cache.set(key,value),value)}else{const cache=[],cacheSize=10;let cachePos=0;readFromCache=key=>{for(let i=0;i<cache.length;i+=2)if(cache[i]==key)return cache[i+1]},addToCache=(key,value)=>(cachePos==cacheSize&&(cachePos=0),cache[cachePos++]=key,cache[cachePos++]=value)}var TableMap=class{constructor(width,height,map,problems){this.width=width,this.height=height,this.map=map,this.problems=problems}findCell(pos){for(let i=0;i<this.map.length;i++){const curPos=this.map[i];if(curPos!=pos)continue;const left=i%this.width,top=i/this.width|0;let right=left+1,bottom=top+1;for(let j=1;right<this.width&&this.map[i+j]==curPos;j++)right++;for(let j=1;bottom<this.height&&this.map[i+this.width*j]==curPos;j++)bottom++;return{left:left,top:top,right:right,bottom:bottom}}throw new RangeError(`No cell with offset ${pos} found`)}colCount(pos){for(let i=0;i<this.map.length;i++)if(this.map[i]==pos)return i%this.width;throw new RangeError(`No cell with offset ${pos} found`)}nextCell(pos,axis,dir){const{left:left,right:right,top:top,bottom:bottom}=this.findCell(pos);return"horiz"==axis?(dir<0?0==left:right==this.width)?null:this.map[top*this.width+(dir<0?left-1:right)]:(dir<0?0==top:bottom==this.height)?null:this.map[left+this.width*(dir<0?top-1:bottom)]}rectBetween(a,b){const{left:leftA,right:rightA,top:topA,bottom:bottomA}=this.findCell(a),{left:leftB,right:rightB,top:topB,bottom:bottomB}=this.findCell(b);return{left:Math.min(leftA,leftB),top:Math.min(topA,topB),right:Math.max(rightA,rightB),bottom:Math.max(bottomA,bottomB)}}cellsInRect(rect){const result=[],seen={};for(let row=rect.top;row<rect.bottom;row++)for(let col=rect.left;col<rect.right;col++){const index=row*this.width+col,pos=this.map[index];seen[pos]||(seen[pos]=!0,col==rect.left&&col&&this.map[index-1]==pos||row==rect.top&&row&&this.map[index-this.width]==pos||result.push(pos))}return result}positionAt(row,col,table){for(let i=0,rowStart=0;;i++){const rowEnd=rowStart+table.child(i).nodeSize;if(i==row){let index=col+row*this.width;const rowEndIndex=(row+1)*this.width;while(index<rowEndIndex&&this.map[index]<rowStart)index++;return index==rowEndIndex?rowEnd-1:this.map[index]}rowStart=rowEnd}}static get(table){return readFromCache(table)||addToCache(table,computeMap(table))}};function computeMap(table){if("table"!=table.type.spec.tableRole)throw new RangeError("Not a table node: "+table.type.name);const width=findWidth(table),height=table.childCount,map=[];let mapPos=0,problems=null;const colWidths=[];for(let i=0,e=width*height;i<e;i++)map[i]=0;for(let row=0,pos=0;row<height;row++){const rowNode=table.child(row);pos++;for(let i=0;;i++){while(mapPos<map.length&&0!=map[mapPos])mapPos++;if(i==rowNode.childCount)break;const cellNode=rowNode.child(i),{colspan:colspan,rowspan:rowspan,colwidth:colwidth}=cellNode.attrs;for(let h=0;h<rowspan;h++){if(h+row>=height){(problems||(problems=[])).push({type:"overlong_rowspan",pos:pos,n:rowspan-h});break}const start=mapPos+h*width;for(let w=0;w<colspan;w++){0==map[start+w]?map[start+w]=pos:(problems||(problems=[])).push({type:"collision",row:row,pos:pos,n:colspan-w});const colW=colwidth&&colwidth[w];if(colW){const widthIndex=(start+w)%width*2,prev=colWidths[widthIndex];null==prev||prev!=colW&&1==colWidths[widthIndex+1]?(colWidths[widthIndex]=colW,colWidths[widthIndex+1]=1):prev==colW&&colWidths[widthIndex+1]++}}}mapPos+=colspan,pos+=cellNode.nodeSize}const expectedPos=(row+1)*width;let missing=0;while(mapPos<expectedPos)0==map[mapPos++]&&missing++;missing&&(problems||(problems=[])).push({type:"missing",row:row,n:missing}),pos++}const tableMap=new TableMap(width,height,map,problems);let badWidths=!1;for(let i=0;!badWidths&&i<colWidths.length;i+=2)null!=colWidths[i]&&colWidths[i+1]<height&&(badWidths=!0);return badWidths&&findBadColWidths(tableMap,colWidths,table),tableMap}function findWidth(table){let width=-1,hasRowSpan=!1;for(let row=0;row<table.childCount;row++){const rowNode=table.child(row);let rowWidth=0;if(hasRowSpan)for(let j=0;j<row;j++){const prevRow=table.child(j);for(let i=0;i<prevRow.childCount;i++){const cell=prevRow.child(i);j+cell.attrs.rowspan>row&&(rowWidth+=cell.attrs.colspan)}}for(let i=0;i<rowNode.childCount;i++){const cell=rowNode.child(i);rowWidth+=cell.attrs.colspan,cell.attrs.rowspan>1&&(hasRowSpan=!0)}-1==width?width=rowWidth:width!=rowWidth&&(width=Math.max(width,rowWidth))}return width}function findBadColWidths(map,colWidths,table){map.problems||(map.problems=[]);const seen={};for(let i=0;i<map.map.length;i++){const pos=map.map[i];if(seen[pos])continue;seen[pos]=!0;const node=table.nodeAt(pos);if(!node)throw new RangeError(`No cell with offset ${pos} found`);let updated=null;const attrs=node.attrs;for(let j=0;j<attrs.colspan;j++){const col=(i+j)%map.width,colWidth=colWidths[2*col];null==colWidth||attrs.colwidth&&attrs.colwidth[j]==colWidth||((updated||(updated=freshColWidth(attrs)))[j]=colWidth)}updated&&map.problems.unshift({type:"colwidth mismatch",pos:pos,colwidth:updated})}}function freshColWidth(attrs){if(attrs.colwidth)return attrs.colwidth.slice();const result=[];for(let i=0;i<attrs.colspan;i++)result.push(0);return result}function tableNodeTypes(schema){let result=schema.cached.tableNodeTypes;if(!result){result=schema.cached.tableNodeTypes={};for(const name in schema.nodes){const type=schema.nodes[name],role=type.spec.tableRole;role&&(result[role]=type)}}return result}
// src/util.ts
var tableEditingKey=new PluginKey("selectingCells");function cellAround($pos){for(let d=$pos.depth-1;d>0;d--)if("row"==$pos.node(d).type.spec.tableRole)return $pos.node(0).resolve($pos.before(d+1));return null}function cellWrapping($pos){for(let d=$pos.depth;d>0;d--){const role=$pos.node(d).type.spec.tableRole;if("cell"===role||"header_cell"===role)return $pos.node(d)}return null}function isInTable(state){const $head=state.selection.$head;for(let d=$head.depth;d>0;d--)if("row"==$head.node(d).type.spec.tableRole)return!0;return!1}function selectionCell(state){const sel=state.selection;if("$anchorCell"in sel&&sel.$anchorCell)return sel.$anchorCell.pos>sel.$headCell.pos?sel.$anchorCell:sel.$headCell;if("node"in sel&&sel.node&&"cell"==sel.node.type.spec.tableRole)return sel.$anchor;const $cell=cellAround(sel.$head)||cellNear(sel.$head);if($cell)return $cell;throw new RangeError(`No cell found around position ${sel.head}`)}function cellNear($pos){for(let after=$pos.nodeAfter,pos=$pos.pos;after;after=after.firstChild,pos++){const role=after.type.spec.tableRole;if("cell"==role||"header_cell"==role)return $pos.doc.resolve(pos)}for(let before=$pos.nodeBefore,pos=$pos.pos;before;before=before.lastChild,pos--){const role=before.type.spec.tableRole;if("cell"==role||"header_cell"==role)return $pos.doc.resolve(pos-before.nodeSize)}}function pointsAtCell($pos){return"row"==$pos.parent.type.spec.tableRole&&!!$pos.nodeAfter}function moveCellForward($pos){return $pos.node(0).resolve($pos.pos+$pos.nodeAfter.nodeSize)}function inSameTable($cellA,$cellB){return $cellA.depth==$cellB.depth&&$cellA.pos>=$cellB.start(-1)&&$cellA.pos<=$cellB.end(-1)}function nextCell($pos,axis,dir){const table=$pos.node(-1),map=TableMap.get(table),tableStart=$pos.start(-1),moved=map.nextCell($pos.pos-tableStart,axis,dir);return null==moved?null:$pos.node(0).resolve(tableStart+moved)}function removeColSpan(attrs,pos,n=1){const result={...attrs,colspan:attrs.colspan-n};return result.colwidth&&(result.colwidth=result.colwidth.slice(),result.colwidth.splice(pos,n),result.colwidth.some((w=>w>0))||(result.colwidth=null)),result}function addColSpan(attrs,pos,n=1){const result={...attrs,colspan:attrs.colspan+n};if(result.colwidth){result.colwidth=result.colwidth.slice();for(let i=0;i<n;i++)result.colwidth.splice(pos,0,0)}return result}function columnIsHeader(map,table,col){const headerCell=tableNodeTypes(table.type.schema).header_cell;for(let row=0;row<map.height;row++)if(table.nodeAt(map.map[col+row*map.width]).type!=headerCell)return!1;return!0}
// src/cellselection.ts
var CellSelection=class extends Selection{constructor($anchorCell,$headCell=$anchorCell){const table=$anchorCell.node(-1),map=TableMap.get(table),tableStart=$anchorCell.start(-1),rect=map.rectBetween($anchorCell.pos-tableStart,$headCell.pos-tableStart),doc=$anchorCell.node(0),cells=map.cellsInRect(rect).filter((p=>p!=$headCell.pos-tableStart));cells.unshift($headCell.pos-tableStart);const ranges=cells.map((pos=>{const cell=table.nodeAt(pos);if(!cell)throw RangeError(`No cell with offset ${pos} found`);const from=tableStart+pos+1;return new SelectionRange(doc.resolve(from),doc.resolve(from+cell.content.size))}));super(ranges[0].$from,ranges[0].$to,ranges),this.$anchorCell=$anchorCell,this.$headCell=$headCell}map(doc,mapping){const $anchorCell=doc.resolve(mapping.map(this.$anchorCell.pos)),$headCell=doc.resolve(mapping.map(this.$headCell.pos));if(pointsAtCell($anchorCell)&&pointsAtCell($headCell)&&inSameTable($anchorCell,$headCell)){const tableChanged=this.$anchorCell.node(-1)!=$anchorCell.node(-1);return tableChanged&&this.isRowSelection()?CellSelection.rowSelection($anchorCell,$headCell):tableChanged&&this.isColSelection()?CellSelection.colSelection($anchorCell,$headCell):new CellSelection($anchorCell,$headCell)}return TextSelection.between($anchorCell,$headCell)}content(){const table=this.$anchorCell.node(-1),map=TableMap.get(table),tableStart=this.$anchorCell.start(-1),rect=map.rectBetween(this.$anchorCell.pos-tableStart,this.$headCell.pos-tableStart),seen={},rows=[];for(let row=rect.top;row<rect.bottom;row++){const rowContent=[];for(let index=row*map.width+rect.left,col=rect.left;col<rect.right;col++,index++){const pos=map.map[index];if(seen[pos])continue;seen[pos]=!0;const cellRect=map.findCell(pos);let cell=table.nodeAt(pos);if(!cell)throw RangeError(`No cell with offset ${pos} found`);const extraLeft=rect.left-cellRect.left,extraRight=cellRect.right-rect.right;if(extraLeft>0||extraRight>0){let attrs=cell.attrs;if(extraLeft>0&&(attrs=removeColSpan(attrs,0,extraLeft)),extraRight>0&&(attrs=removeColSpan(attrs,attrs.colspan-extraRight,extraRight)),cellRect.left<rect.left){if(cell=cell.type.createAndFill(attrs),!cell)throw RangeError(`Could not create cell with attrs ${JSON.stringify(attrs)}`)}else cell=cell.type.create(attrs,cell.content)}if(cellRect.top<rect.top||cellRect.bottom>rect.bottom){const attrs={...cell.attrs,rowspan:Math.min(cellRect.bottom,rect.bottom)-Math.max(cellRect.top,rect.top)};cell=cellRect.top<rect.top?cell.type.createAndFill(attrs):cell.type.create(attrs,cell.content)}rowContent.push(cell)}rows.push(table.child(row).copy(Fragment.from(rowContent)))}const fragment=this.isColSelection()&&this.isRowSelection()?table:rows;return new Slice(Fragment.from(fragment),1,1)}replace(tr,content=Slice.empty){const mapFrom=tr.steps.length,ranges=this.ranges;for(let i=0;i<ranges.length;i++){const{$from:$from,$to:$to}=ranges[i],mapping=tr.mapping.slice(mapFrom);tr.replace(mapping.map($from.pos),mapping.map($to.pos),i?Slice.empty:content)}const sel=Selection.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),-1);sel&&tr.setSelection(sel)}replaceWith(tr,node){this.replace(tr,new Slice(Fragment.from(node),0,0))}forEachCell(f){const table=this.$anchorCell.node(-1),map=TableMap.get(table),tableStart=this.$anchorCell.start(-1),cells=map.cellsInRect(map.rectBetween(this.$anchorCell.pos-tableStart,this.$headCell.pos-tableStart));for(let i=0;i<cells.length;i++)f(table.nodeAt(cells[i]),tableStart+cells[i])}isColSelection(){const anchorTop=this.$anchorCell.index(-1),headTop=this.$headCell.index(-1);if(Math.min(anchorTop,headTop)>0)return!1;const anchorBottom=anchorTop+this.$anchorCell.nodeAfter.attrs.rowspan,headBottom=headTop+this.$headCell.nodeAfter.attrs.rowspan;return Math.max(anchorBottom,headBottom)==this.$headCell.node(-1).childCount}static colSelection($anchorCell,$headCell=$anchorCell){const table=$anchorCell.node(-1),map=TableMap.get(table),tableStart=$anchorCell.start(-1),anchorRect=map.findCell($anchorCell.pos-tableStart),headRect=map.findCell($headCell.pos-tableStart),doc=$anchorCell.node(0);return anchorRect.top<=headRect.top?(anchorRect.top>0&&($anchorCell=doc.resolve(tableStart+map.map[anchorRect.left])),headRect.bottom<map.height&&($headCell=doc.resolve(tableStart+map.map[map.width*(map.height-1)+headRect.right-1]))):(headRect.top>0&&($headCell=doc.resolve(tableStart+map.map[headRect.left])),anchorRect.bottom<map.height&&($anchorCell=doc.resolve(tableStart+map.map[map.width*(map.height-1)+anchorRect.right-1]))),new CellSelection($anchorCell,$headCell)}isRowSelection(){const table=this.$anchorCell.node(-1),map=TableMap.get(table),tableStart=this.$anchorCell.start(-1),anchorLeft=map.colCount(this.$anchorCell.pos-tableStart),headLeft=map.colCount(this.$headCell.pos-tableStart);if(Math.min(anchorLeft,headLeft)>0)return!1;const anchorRight=anchorLeft+this.$anchorCell.nodeAfter.attrs.colspan,headRight=headLeft+this.$headCell.nodeAfter.attrs.colspan;return Math.max(anchorRight,headRight)==map.width}eq(other){return other instanceof CellSelection&&other.$anchorCell.pos==this.$anchorCell.pos&&other.$headCell.pos==this.$headCell.pos}static rowSelection($anchorCell,$headCell=$anchorCell){const table=$anchorCell.node(-1),map=TableMap.get(table),tableStart=$anchorCell.start(-1),anchorRect=map.findCell($anchorCell.pos-tableStart),headRect=map.findCell($headCell.pos-tableStart),doc=$anchorCell.node(0);return anchorRect.left<=headRect.left?(anchorRect.left>0&&($anchorCell=doc.resolve(tableStart+map.map[anchorRect.top*map.width])),headRect.right<map.width&&($headCell=doc.resolve(tableStart+map.map[map.width*(headRect.top+1)-1]))):(headRect.left>0&&($headCell=doc.resolve(tableStart+map.map[headRect.top*map.width])),anchorRect.right<map.width&&($anchorCell=doc.resolve(tableStart+map.map[map.width*(anchorRect.top+1)-1]))),new CellSelection($anchorCell,$headCell)}toJSON(){return{type:"cell",anchor:this.$anchorCell.pos,head:this.$headCell.pos}}static fromJSON(doc,json){return new CellSelection(doc.resolve(json.anchor),doc.resolve(json.head))}static create(doc,anchorCell,headCell=anchorCell){return new CellSelection(doc.resolve(anchorCell),doc.resolve(headCell))}getBookmark(){return new CellBookmark(this.$anchorCell.pos,this.$headCell.pos)}};CellSelection.prototype.visible=!1,Selection.jsonID("cell",CellSelection);var CellBookmark=class{constructor(anchor,head){this.anchor=anchor,this.head=head}map(mapping){return new CellBookmark(mapping.map(this.anchor),mapping.map(this.head))}resolve(doc){const $anchorCell=doc.resolve(this.anchor),$headCell=doc.resolve(this.head);return"row"==$anchorCell.parent.type.spec.tableRole&&"row"==$headCell.parent.type.spec.tableRole&&$anchorCell.index()<$anchorCell.parent.childCount&&$headCell.index()<$headCell.parent.childCount&&inSameTable($anchorCell,$headCell)?new CellSelection($anchorCell,$headCell):Selection.near($headCell,1)}};function drawCellSelection(state){if(!(state.selection instanceof CellSelection))return null;const cells=[];return state.selection.forEachCell(((node,pos)=>{cells.push(Decoration.node(pos,pos+node.nodeSize,{class:"selectedCell"}))})),DecorationSet.create(state.doc,cells)}function isCellBoundarySelection({$from:$from,$to:$to}){if($from.pos==$to.pos||$from.pos<$from.pos-6)return!1;let afterFrom=$from.pos,beforeTo=$to.pos,depth=$from.depth;for(;depth>=0;depth--,afterFrom++)if($from.after(depth+1)<$from.end(depth))break;for(let d=$to.depth;d>=0;d--,beforeTo--)if($to.before(d+1)>$to.start(d))break;return afterFrom==beforeTo&&/row|table/.test($from.node(depth).type.spec.tableRole)}function isTextSelectionAcrossCells({$from:$from,$to:$to}){let fromCellBoundaryNode,toCellBoundaryNode;for(let i=$from.depth;i>0;i--){const node=$from.node(i);if("cell"===node.type.spec.tableRole||"header_cell"===node.type.spec.tableRole){fromCellBoundaryNode=node;break}}for(let i=$to.depth;i>0;i--){const node=$to.node(i);if("cell"===node.type.spec.tableRole||"header_cell"===node.type.spec.tableRole){toCellBoundaryNode=node;break}}return fromCellBoundaryNode!==toCellBoundaryNode&&0===$to.parentOffset}function normalizeSelection(state,tr,allowTableNodeSelection){const sel=(tr||state).selection,doc=(tr||state).doc;let normalize,role;if(sel instanceof NodeSelection&&(role=sel.node.type.spec.tableRole)){if("cell"==role||"header_cell"==role)normalize=CellSelection.create(doc,sel.from);else if("row"==role){const $cell=doc.resolve(sel.from+1);normalize=CellSelection.rowSelection($cell,$cell)}else if(!allowTableNodeSelection){const map=TableMap.get(sel.node),start=sel.from+1,lastCell=start+map.map[map.width*map.height-1];normalize=CellSelection.create(doc,start+1,lastCell)}}else sel instanceof TextSelection&&isCellBoundarySelection(sel)?normalize=TextSelection.create(doc,sel.from):sel instanceof TextSelection&&isTextSelectionAcrossCells(sel)&&(normalize=TextSelection.create(doc,sel.$from.start(),sel.$from.end()));return normalize&&(tr||(tr=state.tr)).setSelection(normalize),tr}var fixTablesKey=new PluginKey("fix-tables");function changedDescendants(old,cur,offset,f){const oldSize=old.childCount,curSize=cur.childCount;outer:for(let i=0,j=0;i<curSize;i++){const child=cur.child(i);for(let scan=j,e=Math.min(oldSize,i+3);scan<e;scan++)if(old.child(scan)==child){j=scan+1,offset+=child.nodeSize;continue outer}f(child,offset),j<oldSize&&old.child(j).sameMarkup(child)?changedDescendants(old.child(j),child,offset+1,f):child.nodesBetween(0,child.content.size,f,offset+1),offset+=child.nodeSize}}function fixTables(state,oldState){let tr;const check=(node,pos)=>{"table"==node.type.spec.tableRole&&(tr=fixTable(state,node,pos,tr))};return oldState?oldState.doc!=state.doc&&changedDescendants(oldState.doc,state.doc,0,check):state.doc.descendants(check),tr}function fixTable(state,table,tablePos,tr){const map=TableMap.get(table);if(!map.problems)return tr;tr||(tr=state.tr);const mustAdd=[];for(let i=0;i<map.height;i++)mustAdd.push(0);for(let i=0;i<map.problems.length;i++){const prob=map.problems[i];if("collision"==prob.type){const cell=table.nodeAt(prob.pos);if(!cell)continue;const attrs=cell.attrs;for(let j=0;j<attrs.rowspan;j++)mustAdd[prob.row+j]+=prob.n;tr.setNodeMarkup(tr.mapping.map(tablePos+1+prob.pos),null,removeColSpan(attrs,attrs.colspan-prob.n,prob.n))}else if("missing"==prob.type)mustAdd[prob.row]+=prob.n;else if("overlong_rowspan"==prob.type){const cell=table.nodeAt(prob.pos);if(!cell)continue;tr.setNodeMarkup(tr.mapping.map(tablePos+1+prob.pos),null,{...cell.attrs,rowspan:cell.attrs.rowspan-prob.n})}else if("colwidth mismatch"==prob.type){const cell=table.nodeAt(prob.pos);if(!cell)continue;tr.setNodeMarkup(tr.mapping.map(tablePos+1+prob.pos),null,{...cell.attrs,colwidth:prob.colwidth})}}let first,last;for(let i=0;i<mustAdd.length;i++)mustAdd[i]&&(null==first&&(first=i),last=i);for(let i=0,pos=tablePos+1;i<map.height;i++){const row=table.child(i),end=pos+row.nodeSize,add=mustAdd[i];if(add>0){let role="cell";row.firstChild&&(role=row.firstChild.type.spec.tableRole);const nodes=[];for(let j=0;j<add;j++){const node=tableNodeTypes(state.schema)[role].createAndFill();node&&nodes.push(node)}const side=0!=i&&first!=i-1||last!=i?end-1:pos+1;tr.insert(tr.mapping.map(side),nodes)}pos=end}return tr.setMeta(fixTablesKey,{fixTables:!0})}function pastedCells(slice){if(!slice.size)return null;let{content:content,openStart:openStart,openEnd:openEnd}=slice;while(1==content.childCount&&(openStart>0&&openEnd>0||"table"==content.child(0).type.spec.tableRole))openStart--,openEnd--,content=content.child(0).content;const first=content.child(0),role=first.type.spec.tableRole,schema=first.type.schema,rows=[];if("row"==role)for(let i=0;i<content.childCount;i++){let cells=content.child(i).content;const left=i?0:Math.max(0,openStart-1),right=i<content.childCount-1?0:Math.max(0,openEnd-1);(left||right)&&(cells=fitSlice(tableNodeTypes(schema).row,new Slice(cells,left,right)).content),rows.push(cells)}else{if("cell"!=role&&"header_cell"!=role)return null;rows.push(openStart||openEnd?fitSlice(tableNodeTypes(schema).row,new Slice(content,openStart,openEnd)).content:content)}return ensureRectangular(schema,rows)}function ensureRectangular(schema,rows){const widths=[];for(let i=0;i<rows.length;i++){const row=rows[i];for(let j=row.childCount-1;j>=0;j--){const{rowspan:rowspan,colspan:colspan}=row.child(j).attrs;for(let r=i;r<i+rowspan;r++)widths[r]=(widths[r]||0)+colspan}}let width=0;for(let r=0;r<widths.length;r++)width=Math.max(width,widths[r]);for(let r=0;r<widths.length;r++)if(r>=rows.length&&rows.push(Fragment.empty),widths[r]<width){const empty=tableNodeTypes(schema).cell.createAndFill(),cells=[];for(let i=widths[r];i<width;i++)cells.push(empty);rows[r]=rows[r].append(Fragment.from(cells))}return{height:rows.length,width:width,rows:rows}}function fitSlice(nodeType,slice){const node=nodeType.createAndFill(),tr=new Transform(node).replace(0,node.content.size,slice);return tr.doc}function clipCells({width:width,height:height,rows:rows},newWidth,newHeight){if(width!=newWidth){const added=[],newRows=[];for(let row=0;row<rows.length;row++){const frag=rows[row],cells=[];for(let col=added[row]||0,i=0;col<newWidth;i++){let cell=frag.child(i%frag.childCount);col+cell.attrs.colspan>newWidth&&(cell=cell.type.createChecked(removeColSpan(cell.attrs,cell.attrs.colspan,col+cell.attrs.colspan-newWidth),cell.content)),cells.push(cell),col+=cell.attrs.colspan;for(let j=1;j<cell.attrs.rowspan;j++)added[row+j]=(added[row+j]||0)+cell.attrs.colspan}newRows.push(Fragment.from(cells))}rows=newRows,width=newWidth}if(height!=newHeight){const newRows=[];for(let row=0,i=0;row<newHeight;row++,i++){const cells=[],source=rows[i%height];for(let j=0;j<source.childCount;j++){let cell=source.child(j);row+cell.attrs.rowspan>newHeight&&(cell=cell.type.create({...cell.attrs,rowspan:Math.max(1,newHeight-cell.attrs.rowspan)},cell.content)),cells.push(cell)}newRows.push(Fragment.from(cells))}rows=newRows,height=newHeight}return{width:width,height:height,rows:rows}}function growTable(tr,map,table,start,width,height,mapFrom){const schema=tr.doc.type.schema,types=tableNodeTypes(schema);let empty,emptyHead;if(width>map.width)for(let row=0,rowEnd=0;row<map.height;row++){const rowNode=table.child(row);rowEnd+=rowNode.nodeSize;const cells=[];let add;add=null==rowNode.lastChild||rowNode.lastChild.type==types.cell?empty||(empty=types.cell.createAndFill()):emptyHead||(emptyHead=types.header_cell.createAndFill());for(let i=map.width;i<width;i++)cells.push(add);tr.insert(tr.mapping.slice(mapFrom).map(rowEnd-1+start),cells)}if(height>map.height){const cells=[];for(let i=0,start2=(map.height-1)*map.width;i<Math.max(map.width,width);i++){const header=!(i>=map.width)&&table.nodeAt(map.map[start2+i]).type==types.header_cell;cells.push(header?emptyHead||(emptyHead=types.header_cell.createAndFill()):empty||(empty=types.cell.createAndFill()))}const emptyRow=types.row.create(null,Fragment.from(cells)),rows=[];for(let i=map.height;i<height;i++)rows.push(emptyRow);tr.insert(tr.mapping.slice(mapFrom).map(start+table.nodeSize-2),rows)}return!(!empty&&!emptyHead)}function isolateHorizontal(tr,map,table,start,left,right,top,mapFrom){if(0==top||top==map.height)return!1;let found=!1;for(let col=left;col<right;col++){const index=top*map.width+col,pos=map.map[index];if(map.map[index-map.width]==pos){found=!0;const cell=table.nodeAt(pos),{top:cellTop,left:cellLeft}=map.findCell(pos);tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos+start),null,{...cell.attrs,rowspan:top-cellTop}),tr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top,cellLeft,table)),cell.type.createAndFill({...cell.attrs,rowspan:cellTop+cell.attrs.rowspan-top})),col+=cell.attrs.colspan-1}}return found}function isolateVertical(tr,map,table,start,top,bottom,left,mapFrom){if(0==left||left==map.width)return!1;let found=!1;for(let row=top;row<bottom;row++){const index=row*map.width+left,pos=map.map[index];if(map.map[index-1]==pos){found=!0;const cell=table.nodeAt(pos),cellLeft=map.colCount(pos),updatePos=tr.mapping.slice(mapFrom).map(pos+start);tr.setNodeMarkup(updatePos,null,removeColSpan(cell.attrs,left-cellLeft,cell.attrs.colspan-(left-cellLeft))),tr.insert(updatePos+cell.nodeSize,cell.type.createAndFill(removeColSpan(cell.attrs,0,left-cellLeft))),row+=cell.attrs.rowspan-1}}return found}function insertCells(state,dispatch,tableStart,rect,cells){let table=tableStart?state.doc.nodeAt(tableStart-1):state.doc;if(!table)throw new Error("No table found");let map=TableMap.get(table);const{top:top,left:left}=rect,right=left+cells.width,bottom=top+cells.height,tr=state.tr;let mapFrom=0;function recomp(){if(table=tableStart?tr.doc.nodeAt(tableStart-1):tr.doc,!table)throw new Error("No table found");map=TableMap.get(table),mapFrom=tr.mapping.maps.length}growTable(tr,map,table,tableStart,right,bottom,mapFrom)&&recomp(),isolateHorizontal(tr,map,table,tableStart,left,right,top,mapFrom)&&recomp(),isolateHorizontal(tr,map,table,tableStart,left,right,bottom,mapFrom)&&recomp(),isolateVertical(tr,map,table,tableStart,top,bottom,left,mapFrom)&&recomp(),isolateVertical(tr,map,table,tableStart,top,bottom,right,mapFrom)&&recomp();for(let row=top;row<bottom;row++){const from=map.positionAt(row,left,table),to=map.positionAt(row,right,table);tr.replace(tr.mapping.slice(mapFrom).map(from+tableStart),tr.mapping.slice(mapFrom).map(to+tableStart),new Slice(cells.rows[row-top],0,0))}recomp(),tr.setSelection(new CellSelection(tr.doc.resolve(tableStart+map.positionAt(top,left,table)),tr.doc.resolve(tableStart+map.positionAt(bottom-1,right-1,table)))),dispatch(tr)}
// src/input.ts
var handleKeyDown=keydownHandler({ArrowLeft:arrow$2("horiz",-1),ArrowRight:arrow$2("horiz",1),ArrowUp:arrow$2("vert",-1),ArrowDown:arrow$2("vert",1),"Shift-ArrowLeft":shiftArrow("horiz",-1),"Shift-ArrowRight":shiftArrow("horiz",1),"Shift-ArrowUp":shiftArrow("vert",-1),"Shift-ArrowDown":shiftArrow("vert",1),Backspace:deleteCellSelection,"Mod-Backspace":deleteCellSelection,Delete:deleteCellSelection,"Mod-Delete":deleteCellSelection});function maybeSetSelection(state,dispatch,selection){return!selection.eq(state.selection)&&(dispatch&&dispatch(state.tr.setSelection(selection).scrollIntoView()),!0)}function arrow$2(axis,dir){return(state,dispatch,view)=>{if(!view)return!1;const sel=state.selection;if(sel instanceof CellSelection)return maybeSetSelection(state,dispatch,Selection.near(sel.$headCell,dir));if("horiz"!=axis&&!sel.empty)return!1;const end=atEndOfCell(view,axis,dir);if(null==end)return!1;if("horiz"==axis)return maybeSetSelection(state,dispatch,Selection.near(state.doc.resolve(sel.head+dir),dir));{const $cell=state.doc.resolve(end),$next=nextCell($cell,axis,dir);let newSel;return newSel=$next?Selection.near($next,1):dir<0?Selection.near(state.doc.resolve($cell.before(-1)),-1):Selection.near(state.doc.resolve($cell.after(-1)),1),maybeSetSelection(state,dispatch,newSel)}}}function shiftArrow(axis,dir){return(state,dispatch,view)=>{if(!view)return!1;const sel=state.selection;let cellSel;if(sel instanceof CellSelection)cellSel=sel;else{const end=atEndOfCell(view,axis,dir);if(null==end)return!1;cellSel=new CellSelection(state.doc.resolve(end))}const $head=nextCell(cellSel.$headCell,axis,dir);return!!$head&&maybeSetSelection(state,dispatch,new CellSelection(cellSel.$anchorCell,$head))}}function deleteCellSelection(state,dispatch){const sel=state.selection;if(!(sel instanceof CellSelection))return!1;if(dispatch){const tr=state.tr,baseContent=tableNodeTypes(state.schema).cell.createAndFill().content;sel.forEachCell(((cell,pos)=>{cell.content.eq(baseContent)||tr.replace(tr.mapping.map(pos+1),tr.mapping.map(pos+cell.nodeSize-1),new Slice(baseContent,0,0))})),tr.docChanged&&dispatch(tr)}return!0}function handleTripleClick(view,pos){const doc=view.state.doc,$cell=cellAround(doc.resolve(pos));return!!$cell&&(view.dispatch(view.state.tr.setSelection(new CellSelection($cell))),!0)}function handlePaste(view,_,slice){if(!isInTable(view.state))return!1;let cells=pastedCells(slice);const sel=view.state.selection;if(sel instanceof CellSelection){cells||(cells={width:1,height:1,rows:[Fragment.from(fitSlice(tableNodeTypes(view.state.schema).cell,slice))]});const table=sel.$anchorCell.node(-1),start=sel.$anchorCell.start(-1),rect=TableMap.get(table).rectBetween(sel.$anchorCell.pos-start,sel.$headCell.pos-start);return cells=clipCells(cells,rect.right-rect.left,rect.bottom-rect.top),insertCells(view.state,view.dispatch,start,rect,cells),!0}if(cells){const $cell=selectionCell(view.state),start=$cell.start(-1);return insertCells(view.state,view.dispatch,start,TableMap.get($cell.node(-1)).findCell($cell.pos-start),cells),!0}return!1}function handleMouseDown(view,startEvent){var _a;if(startEvent.ctrlKey||startEvent.metaKey)return;const startDOMCell=domInCell(view,startEvent.target);let $anchor;if(startEvent.shiftKey&&view.state.selection instanceof CellSelection)setCellSelection(view.state.selection.$anchorCell,startEvent),startEvent.preventDefault();else if(startEvent.shiftKey&&startDOMCell&&null!=($anchor=cellAround(view.state.selection.$anchor))&&(null==(_a=cellUnderMouse(view,startEvent))?void 0:_a.pos)!=$anchor.pos)setCellSelection($anchor,startEvent),startEvent.preventDefault();else if(!startDOMCell)return;function setCellSelection($anchor2,event){let $head=cellUnderMouse(view,event);const starting=null==tableEditingKey.getState(view.state);if(!$head||!inSameTable($anchor2,$head)){if(!starting)return;$head=$anchor2}const selection=new CellSelection($anchor2,$head);if(starting||!view.state.selection.eq(selection)){const tr=view.state.tr.setSelection(selection);starting&&tr.setMeta(tableEditingKey,$anchor2.pos),view.dispatch(tr)}}function stop(){view.root.removeEventListener("mouseup",stop),view.root.removeEventListener("dragstart",stop),view.root.removeEventListener("mousemove",move),null!=tableEditingKey.getState(view.state)&&view.dispatch(view.state.tr.setMeta(tableEditingKey,-1))}function move(_event){const event=_event,anchor=tableEditingKey.getState(view.state);let $anchor2;if(null!=anchor)$anchor2=view.state.doc.resolve(anchor);else if(domInCell(view,event.target)!=startDOMCell&&($anchor2=cellUnderMouse(view,startEvent),!$anchor2))return stop();$anchor2&&setCellSelection($anchor2,event)}view.root.addEventListener("mouseup",stop),view.root.addEventListener("dragstart",stop),view.root.addEventListener("mousemove",move)}function atEndOfCell(view,axis,dir){if(!(view.state.selection instanceof TextSelection))return null;const{$head:$head}=view.state.selection;for(let d=$head.depth-1;d>=0;d--){const parent=$head.node(d),index=dir<0?$head.index(d):$head.indexAfter(d);if(index!=(dir<0?0:parent.childCount))return null;if("cell"==parent.type.spec.tableRole||"header_cell"==parent.type.spec.tableRole){const cellPos=$head.before(d),dirStr="vert"==axis?dir>0?"down":"up":dir>0?"right":"left";return view.endOfTextblock(dirStr)?cellPos:null}}return null}function domInCell(view,dom){for(;dom&&dom!=view.dom;dom=dom.parentNode)if("TD"==dom.nodeName||"TH"==dom.nodeName)return dom;return null}function cellUnderMouse(view,event){const mousePos=view.posAtCoords({left:event.clientX,top:event.clientY});return mousePos&&mousePos?cellAround(view.state.doc.resolve(mousePos.pos)):null}
// src/tableview.ts
var TableView$1=class{constructor(node,cellMinWidth){this.node=node,this.cellMinWidth=cellMinWidth,this.dom=document.createElement("div"),this.dom.className="tableWrapper",this.table=this.dom.appendChild(document.createElement("table")),this.colgroup=this.table.appendChild(document.createElement("colgroup")),updateColumnsOnResize(node,this.colgroup,this.table,cellMinWidth),this.contentDOM=this.table.appendChild(document.createElement("tbody"))}update(node){return node.type==this.node.type&&(this.node=node,updateColumnsOnResize(node,this.colgroup,this.table,this.cellMinWidth),!0)}ignoreMutation(record){return"attributes"==record.type&&(record.target==this.table||this.colgroup.contains(record.target))}};function updateColumnsOnResize(node,colgroup,table,cellMinWidth,overrideCol,overrideValue){var _a;let totalWidth=0,fixedWidth=!0,nextDOM=colgroup.firstChild;const row=node.firstChild;if(row){for(let i=0,col=0;i<row.childCount;i++){const{colspan:colspan,colwidth:colwidth}=row.child(i).attrs;for(let j=0;j<colspan;j++,col++){const hasWidth=overrideCol==col?overrideValue:colwidth&&colwidth[j],cssWidth=hasWidth?hasWidth+"px":"";totalWidth+=hasWidth||cellMinWidth,hasWidth||(fixedWidth=!1),nextDOM?(nextDOM.style.width!=cssWidth&&(nextDOM.style.width=cssWidth),nextDOM=nextDOM.nextSibling):colgroup.appendChild(document.createElement("col")).style.width=cssWidth}}while(nextDOM){const after=nextDOM.nextSibling;null==(_a=nextDOM.parentNode)||_a.removeChild(nextDOM),nextDOM=after}fixedWidth?(table.style.width=totalWidth+"px",table.style.minWidth=""):(table.style.width="",table.style.minWidth=totalWidth+"px")}}
// src/columnresizing.ts
var columnResizingPluginKey=new PluginKey("tableColumnResizing");function columnResizing({handleWidth:handleWidth=5,cellMinWidth:cellMinWidth=25,View:View=TableView$1,lastColumnResizable:lastColumnResizable=!0}={}){const plugin=new Plugin({key:columnResizingPluginKey,state:{init(_,state){return plugin.spec.props.nodeViews[tableNodeTypes(state.schema).table.name]=(node,view)=>new View(node,cellMinWidth,view),new ResizeState(-1,!1)},apply(tr,prev){return prev.apply(tr)}},props:{attributes:state=>{const pluginState=columnResizingPluginKey.getState(state);return pluginState&&pluginState.activeHandle>-1?{class:"resize-cursor"}:{}},handleDOMEvents:{mousemove:(view,event)=>{handleMouseMove(view,event,handleWidth,cellMinWidth,lastColumnResizable)},mouseleave:view=>{handleMouseLeave(view)},mousedown:(view,event)=>{handleMouseDown2(view,event,cellMinWidth)}},decorations:state=>{const pluginState=columnResizingPluginKey.getState(state);if(pluginState&&pluginState.activeHandle>-1)return handleDecorations(state,pluginState.activeHandle)},nodeViews:{}}});return plugin}var ResizeState=class{constructor(activeHandle,dragging){this.activeHandle=activeHandle,this.dragging=dragging}apply(tr){const state=this,action=tr.getMeta(columnResizingPluginKey);if(action&&null!=action.setHandle)return new ResizeState(action.setHandle,!1);if(action&&void 0!==action.setDragging)return new ResizeState(state.activeHandle,action.setDragging);if(state.activeHandle>-1&&tr.docChanged){let handle=tr.mapping.map(state.activeHandle,-1);return pointsAtCell(tr.doc.resolve(handle))||(handle=-1),new ResizeState(handle,state.dragging)}return state}};function handleMouseMove(view,event,handleWidth,cellMinWidth,lastColumnResizable){const pluginState=columnResizingPluginKey.getState(view.state);if(pluginState&&!pluginState.dragging){const target=domCellAround(event.target);let cell=-1;if(target){const{left:left,right:right}=target.getBoundingClientRect();event.clientX-left<=handleWidth?cell=edgeCell(view,event,"left"):right-event.clientX<=handleWidth&&(cell=edgeCell(view,event,"right"))}if(cell!=pluginState.activeHandle){if(!lastColumnResizable&&-1!==cell){const $cell=view.state.doc.resolve(cell),table=$cell.node(-1),map=TableMap.get(table),tableStart=$cell.start(-1),col=map.colCount($cell.pos-tableStart)+$cell.nodeAfter.attrs.colspan-1;if(col==map.width-1)return}updateHandle(view,cell)}}}function handleMouseLeave(view){const pluginState=columnResizingPluginKey.getState(view.state);pluginState&&pluginState.activeHandle>-1&&!pluginState.dragging&&updateHandle(view,-1)}function handleMouseDown2(view,event,cellMinWidth){const pluginState=columnResizingPluginKey.getState(view.state);if(!pluginState||-1==pluginState.activeHandle||pluginState.dragging)return!1;const cell=view.state.doc.nodeAt(pluginState.activeHandle),width=currentColWidth(view,pluginState.activeHandle,cell.attrs);function finish(event2){window.removeEventListener("mouseup",finish),window.removeEventListener("mousemove",move);const pluginState2=columnResizingPluginKey.getState(view.state);(null==pluginState2?void 0:pluginState2.dragging)&&(updateColumnWidth(view,pluginState2.activeHandle,draggedWidth(pluginState2.dragging,event2,cellMinWidth)),view.dispatch(view.state.tr.setMeta(columnResizingPluginKey,{setDragging:null})))}function move(event2){if(!event2.which)return finish(event2);const pluginState2=columnResizingPluginKey.getState(view.state);if(pluginState2&&pluginState2.dragging){const dragged=draggedWidth(pluginState2.dragging,event2,cellMinWidth);displayColumnWidth(view,pluginState2.activeHandle,dragged,cellMinWidth)}}return view.dispatch(view.state.tr.setMeta(columnResizingPluginKey,{setDragging:{startX:event.clientX,startWidth:width}})),window.addEventListener("mouseup",finish),window.addEventListener("mousemove",move),event.preventDefault(),!0}function currentColWidth(view,cellPos,{colspan:colspan,colwidth:colwidth}){const width=colwidth&&colwidth[colwidth.length-1];if(width)return width;const dom=view.domAtPos(cellPos),node=dom.node.childNodes[dom.offset];let domWidth=node.offsetWidth,parts=colspan;if(colwidth)for(let i=0;i<colspan;i++)colwidth[i]&&(domWidth-=colwidth[i],parts--);return domWidth/parts}function domCellAround(target){while(target&&"TD"!=target.nodeName&&"TH"!=target.nodeName)target=target.classList&&target.classList.contains("ProseMirror")?null:target.parentNode;return target}function edgeCell(view,event,side){const found=view.posAtCoords({left:event.clientX,top:event.clientY});if(!found)return-1;const{pos:pos}=found,$cell=cellAround(view.state.doc.resolve(pos));if(!$cell)return-1;if("right"==side)return $cell.pos;const map=TableMap.get($cell.node(-1)),start=$cell.start(-1),index=map.map.indexOf($cell.pos-start);return index%map.width==0?-1:start+map.map[index-1]}function draggedWidth(dragging,event,cellMinWidth){const offset=event.clientX-dragging.startX;return Math.max(cellMinWidth,dragging.startWidth+offset)}function updateHandle(view,value){view.dispatch(view.state.tr.setMeta(columnResizingPluginKey,{setHandle:value}))}function updateColumnWidth(view,cell,width){const $cell=view.state.doc.resolve(cell),table=$cell.node(-1),map=TableMap.get(table),start=$cell.start(-1),col=map.colCount($cell.pos-start)+$cell.nodeAfter.attrs.colspan-1,tr=view.state.tr;for(let row=0;row<map.height;row++){const mapIndex=row*map.width+col;if(row&&map.map[mapIndex]==map.map[mapIndex-map.width])continue;const pos=map.map[mapIndex],attrs=table.nodeAt(pos).attrs,index=1==attrs.colspan?0:col-map.colCount(pos);if(attrs.colwidth&&attrs.colwidth[index]==width)continue;const colwidth=attrs.colwidth?attrs.colwidth.slice():zeroes(attrs.colspan);colwidth[index]=width,tr.setNodeMarkup(start+pos,null,{...attrs,colwidth:colwidth})}tr.docChanged&&view.dispatch(tr)}function displayColumnWidth(view,cell,width,cellMinWidth){const $cell=view.state.doc.resolve(cell),table=$cell.node(-1),start=$cell.start(-1),col=TableMap.get(table).colCount($cell.pos-start)+$cell.nodeAfter.attrs.colspan-1;let dom=view.domAtPos($cell.start(-1)).node;while(dom&&"TABLE"!=dom.nodeName)dom=dom.parentNode;dom&&updateColumnsOnResize(table,dom.firstChild,dom,cellMinWidth,col,width)}function zeroes(n){return Array(n).fill(0)}function handleDecorations(state,cell){const decorations=[],$cell=state.doc.resolve(cell),table=$cell.node(-1);if(!table)return DecorationSet.empty;const map=TableMap.get(table),start=$cell.start(-1),col=map.colCount($cell.pos-start)+$cell.nodeAfter.attrs.colspan;for(let row=0;row<map.height;row++){const index=col+row*map.width-1;if((col==map.width||map.map[index]!=map.map[index+1])&&(0==row||map.map[index-1]!=map.map[index-1-map.width])){const cellPos=map.map[index],pos=start+cellPos+table.nodeAt(cellPos).nodeSize-1,dom=document.createElement("div");dom.className="column-resize-handle",decorations.push(Decoration.widget(pos,dom))}}return DecorationSet.create(state.doc,decorations)}function selectedRect(state){const sel=state.selection,$pos=selectionCell(state),table=$pos.node(-1),tableStart=$pos.start(-1),map=TableMap.get(table),rect=sel instanceof CellSelection?map.rectBetween(sel.$anchorCell.pos-tableStart,sel.$headCell.pos-tableStart):map.findCell($pos.pos-tableStart);return{...rect,tableStart:tableStart,map:map,table:table}}function addColumn(tr,{map:map,tableStart:tableStart,table:table},col){let refColumn=col>0?-1:0;columnIsHeader(map,table,col+refColumn)&&(refColumn=0==col||col==map.width?null:0);for(let row=0;row<map.height;row++){const index=row*map.width+col;if(col>0&&col<map.width&&map.map[index-1]==map.map[index]){const pos=map.map[index],cell=table.nodeAt(pos);tr.setNodeMarkup(tr.mapping.map(tableStart+pos),null,addColSpan(cell.attrs,col-map.colCount(pos))),row+=cell.attrs.rowspan-1}else{const type=null==refColumn?tableNodeTypes(table.type.schema).cell:table.nodeAt(map.map[index+refColumn]).type,pos=map.positionAt(row,col,table);tr.insert(tr.mapping.map(tableStart+pos),type.createAndFill())}}return tr}function addColumnBefore(state,dispatch){if(!isInTable(state))return!1;if(dispatch){const rect=selectedRect(state);dispatch(addColumn(state.tr,rect,rect.left))}return!0}function addColumnAfter(state,dispatch){if(!isInTable(state))return!1;if(dispatch){const rect=selectedRect(state);dispatch(addColumn(state.tr,rect,rect.right))}return!0}function removeColumn(tr,{map:map,table:table,tableStart:tableStart},col){const mapStart=tr.mapping.maps.length;for(let row=0;row<map.height;){const index=row*map.width+col,pos=map.map[index],cell=table.nodeAt(pos),attrs=cell.attrs;if(col>0&&map.map[index-1]==pos||col<map.width-1&&map.map[index+1]==pos)tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart+pos),null,removeColSpan(attrs,col-map.colCount(pos)));else{const start=tr.mapping.slice(mapStart).map(tableStart+pos);tr.delete(start,start+cell.nodeSize)}row+=attrs.rowspan}}function deleteColumn(state,dispatch){if(!isInTable(state))return!1;if(dispatch){const rect=selectedRect(state),tr=state.tr;if(0==rect.left&&rect.right==rect.map.width)return!1;for(let i=rect.right-1;;i--){if(removeColumn(tr,rect,i),i==rect.left)break;const table=rect.tableStart?tr.doc.nodeAt(rect.tableStart-1):tr.doc;if(!table)throw RangeError("No table found");rect.table=table,rect.map=TableMap.get(table)}dispatch(tr)}return!0}function rowIsHeader(map,table,row){var _a;const headerCell=tableNodeTypes(table.type.schema).header_cell;for(let col=0;col<map.width;col++)if((null==(_a=table.nodeAt(map.map[col+row*map.width]))?void 0:_a.type)!=headerCell)return!1;return!0}function addRow(tr,{map:map,tableStart:tableStart,table:table},row){var _a;let rowPos=tableStart;for(let i=0;i<row;i++)rowPos+=table.child(i).nodeSize;const cells=[];let refRow=row>0?-1:0;rowIsHeader(map,table,row+refRow)&&(refRow=0==row||row==map.height?null:0);for(let col=0,index=map.width*row;col<map.width;col++,index++)if(row>0&&row<map.height&&map.map[index]==map.map[index-map.width]){const pos=map.map[index],attrs=table.nodeAt(pos).attrs;tr.setNodeMarkup(tableStart+pos,null,{...attrs,rowspan:attrs.rowspan+1}),col+=attrs.colspan-1}else{const type=null==refRow?tableNodeTypes(table.type.schema).cell:null==(_a=table.nodeAt(map.map[index+refRow*map.width]))?void 0:_a.type,node=null==type?void 0:type.createAndFill();node&&cells.push(node)}return tr.insert(rowPos,tableNodeTypes(table.type.schema).row.create(null,cells)),tr}function addRowBefore(state,dispatch){if(!isInTable(state))return!1;if(dispatch){const rect=selectedRect(state);dispatch(addRow(state.tr,rect,rect.top))}return!0}function addRowAfter(state,dispatch){if(!isInTable(state))return!1;if(dispatch){const rect=selectedRect(state);dispatch(addRow(state.tr,rect,rect.bottom))}return!0}function removeRow(tr,{map:map,table:table,tableStart:tableStart},row){let rowPos=0;for(let i=0;i<row;i++)rowPos+=table.child(i).nodeSize;const nextRow=rowPos+table.child(row).nodeSize,mapFrom=tr.mapping.maps.length;tr.delete(rowPos+tableStart,nextRow+tableStart);for(let col=0,index=row*map.width;col<map.width;col++,index++){const pos=map.map[index];if(row>0&&pos==map.map[index-map.width]){const attrs=table.nodeAt(pos).attrs;tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos+tableStart),null,{...attrs,rowspan:attrs.rowspan-1}),col+=attrs.colspan-1}else if(row<map.width&&pos==map.map[index+map.width]){const cell=table.nodeAt(pos),attrs=cell.attrs,copy=cell.type.create({...attrs,rowspan:cell.attrs.rowspan-1},cell.content),newPos=map.positionAt(row+1,col,table);tr.insert(tr.mapping.slice(mapFrom).map(tableStart+newPos),copy),col+=attrs.colspan-1}}}function deleteRow(state,dispatch){if(!isInTable(state))return!1;if(dispatch){const rect=selectedRect(state),tr=state.tr;if(0==rect.top&&rect.bottom==rect.map.height)return!1;for(let i=rect.bottom-1;;i--){if(removeRow(tr,rect,i),i==rect.top)break;const table=rect.tableStart?tr.doc.nodeAt(rect.tableStart-1):tr.doc;if(!table)throw RangeError("No table found");rect.table=table,rect.map=TableMap.get(rect.table)}dispatch(tr)}return!0}function isEmpty(cell){const c=cell.content;return 1==c.childCount&&c.child(0).isTextblock&&0==c.child(0).childCount}function cellsOverlapRectangle({width:width,height:height,map:map},rect){let indexTop=rect.top*width+rect.left,indexLeft=indexTop,indexBottom=(rect.bottom-1)*width+rect.left,indexRight=indexTop+(rect.right-rect.left-1);for(let i=rect.top;i<rect.bottom;i++){if(rect.left>0&&map[indexLeft]==map[indexLeft-1]||rect.right<width&&map[indexRight]==map[indexRight+1])return!0;indexLeft+=width,indexRight+=width}for(let i=rect.left;i<rect.right;i++){if(rect.top>0&&map[indexTop]==map[indexTop-width]||rect.bottom<height&&map[indexBottom]==map[indexBottom+width])return!0;indexTop++,indexBottom++}return!1}function mergeCells(state,dispatch){const sel=state.selection;if(!(sel instanceof CellSelection)||sel.$anchorCell.pos==sel.$headCell.pos)return!1;const rect=selectedRect(state),{map:map}=rect;if(cellsOverlapRectangle(map,rect))return!1;if(dispatch){const tr=state.tr,seen={};let mergedPos,mergedCell,content=Fragment.empty;for(let row=rect.top;row<rect.bottom;row++)for(let col=rect.left;col<rect.right;col++){const cellPos=map.map[row*map.width+col],cell=rect.table.nodeAt(cellPos);if(!seen[cellPos]&&cell)if(seen[cellPos]=!0,null==mergedPos)mergedPos=cellPos,mergedCell=cell;else{isEmpty(cell)||(content=content.append(cell.content));const mapped=tr.mapping.map(cellPos+rect.tableStart);tr.delete(mapped,mapped+cell.nodeSize)}}if(null==mergedPos||null==mergedCell)return!0;if(tr.setNodeMarkup(mergedPos+rect.tableStart,null,{...addColSpan(mergedCell.attrs,mergedCell.attrs.colspan,rect.right-rect.left-mergedCell.attrs.colspan),rowspan:rect.bottom-rect.top}),content.size){const end=mergedPos+1+mergedCell.content.size,start=isEmpty(mergedCell)?mergedPos+1:end;tr.replaceWith(start+rect.tableStart,end+rect.tableStart,content)}tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos+rect.tableStart))),dispatch(tr)}return!0}function splitCell(state,dispatch){const nodeTypes=tableNodeTypes(state.schema);return splitCellWithType((({node:node})=>nodeTypes[node.type.spec.tableRole]))(state,dispatch)}function splitCellWithType(getCellType){return(state,dispatch)=>{var _a;const sel=state.selection;let cellNode,cellPos;if(sel instanceof CellSelection){if(sel.$anchorCell.pos!=sel.$headCell.pos)return!1;cellNode=sel.$anchorCell.nodeAfter,cellPos=sel.$anchorCell.pos}else{if(cellNode=cellWrapping(sel.$from),!cellNode)return!1;cellPos=null==(_a=cellAround(sel.$from))?void 0:_a.pos}if(null==cellNode||null==cellPos)return!1;if(1==cellNode.attrs.colspan&&1==cellNode.attrs.rowspan)return!1;if(dispatch){let baseAttrs=cellNode.attrs;const attrs=[],colwidth=baseAttrs.colwidth;baseAttrs.rowspan>1&&(baseAttrs={...baseAttrs,rowspan:1}),baseAttrs.colspan>1&&(baseAttrs={...baseAttrs,colspan:1});const rect=selectedRect(state),tr=state.tr;for(let i=0;i<rect.right-rect.left;i++)attrs.push(colwidth?{...baseAttrs,colwidth:colwidth&&colwidth[i]?[colwidth[i]]:null}:baseAttrs);let lastCell;for(let row=rect.top;row<rect.bottom;row++){let pos=rect.map.positionAt(row,rect.left,rect.table);row==rect.top&&(pos+=cellNode.nodeSize);for(let col=rect.left,i=0;col<rect.right;col++,i++)col==rect.left&&row==rect.top||tr.insert(lastCell=tr.mapping.map(pos+rect.tableStart,1),getCellType({node:cellNode,row:row,col:col}).createAndFill(attrs[i]))}tr.setNodeMarkup(cellPos,getCellType({node:cellNode,row:rect.top,col:rect.left}),attrs[0]),sel instanceof CellSelection&&tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos),lastCell?tr.doc.resolve(lastCell):void 0)),dispatch(tr)}return!0}}function setCellAttr(name,value){return function(state,dispatch){if(!isInTable(state))return!1;const $cell=selectionCell(state);if($cell.nodeAfter.attrs[name]===value)return!1;if(dispatch){const tr=state.tr;state.selection instanceof CellSelection?state.selection.forEachCell(((node,pos)=>{node.attrs[name]!==value&&tr.setNodeMarkup(pos,null,{...node.attrs,[name]:value})})):tr.setNodeMarkup($cell.pos,null,{...$cell.nodeAfter.attrs,[name]:value}),dispatch(tr)}return!0}}function deprecated_toggleHeader(type){return function(state,dispatch){if(!isInTable(state))return!1;if(dispatch){const types=tableNodeTypes(state.schema),rect=selectedRect(state),tr=state.tr,cells=rect.map.cellsInRect("column"==type?{left:rect.left,top:0,right:rect.right,bottom:rect.map.height}:"row"==type?{left:0,top:rect.top,right:rect.map.width,bottom:rect.bottom}:rect),nodes=cells.map((pos=>rect.table.nodeAt(pos)));for(let i=0;i<cells.length;i++)nodes[i].type==types.header_cell&&tr.setNodeMarkup(rect.tableStart+cells[i],types.cell,nodes[i].attrs);if(0==tr.steps.length)for(let i=0;i<cells.length;i++)tr.setNodeMarkup(rect.tableStart+cells[i],types.header_cell,nodes[i].attrs);dispatch(tr)}return!0}}function isHeaderEnabledByType(type,rect,types){const cellPositions=rect.map.cellsInRect({left:0,top:0,right:"row"==type?rect.map.width:1,bottom:"column"==type?rect.map.height:1});for(let i=0;i<cellPositions.length;i++){const cell=rect.table.nodeAt(cellPositions[i]);if(cell&&cell.type!==types.header_cell)return!1}return!0}function toggleHeader(type,options){return options=options||{useDeprecatedLogic:!1},options.useDeprecatedLogic?deprecated_toggleHeader(type):function(state,dispatch){if(!isInTable(state))return!1;if(dispatch){const types=tableNodeTypes(state.schema),rect=selectedRect(state),tr=state.tr,isHeaderRowEnabled=isHeaderEnabledByType("row",rect,types),isHeaderColumnEnabled=isHeaderEnabledByType("column",rect,types),isHeaderEnabled="column"===type?isHeaderRowEnabled:"row"===type&&isHeaderColumnEnabled,selectionStartsAt=isHeaderEnabled?1:0,cellsRect="column"==type?{left:0,top:selectionStartsAt,right:1,bottom:rect.map.height}:"row"==type?{left:selectionStartsAt,top:0,right:rect.map.width,bottom:1}:rect,newType="column"==type?isHeaderColumnEnabled?types.cell:types.header_cell:"row"==type?isHeaderRowEnabled?types.cell:types.header_cell:types.cell;rect.map.cellsInRect(cellsRect).forEach((relativeCellPos=>{const cellPos=relativeCellPos+rect.tableStart,cell=tr.doc.nodeAt(cellPos);cell&&tr.setNodeMarkup(cellPos,newType,cell.attrs)})),dispatch(tr)}return!0}}toggleHeader("row",{useDeprecatedLogic:!0}),toggleHeader("column",{useDeprecatedLogic:!0});var toggleHeaderCell=toggleHeader("cell",{useDeprecatedLogic:!0});function findNextCell($cell,dir){if(dir<0){const before=$cell.nodeBefore;if(before)return $cell.pos-before.nodeSize;for(let row=$cell.index(-1)-1,rowEnd=$cell.before();row>=0;row--){const rowNode=$cell.node(-1).child(row),lastChild=rowNode.lastChild;if(lastChild)return rowEnd-1-lastChild.nodeSize;rowEnd-=rowNode.nodeSize}}else{if($cell.index()<$cell.parent.childCount-1)return $cell.pos+$cell.nodeAfter.nodeSize;const table=$cell.node(-1);for(let row=$cell.indexAfter(-1),rowStart=$cell.after();row<table.childCount;row++){const rowNode=table.child(row);if(rowNode.childCount)return rowStart+1;rowStart+=rowNode.nodeSize}}return null}function goToNextCell(direction){return function(state,dispatch){if(!isInTable(state))return!1;const cell=findNextCell(selectionCell(state),direction);if(null==cell)return!1;if(dispatch){const $cell=state.doc.resolve(cell);dispatch(state.tr.setSelection(TextSelection.between($cell,moveCellForward($cell))).scrollIntoView())}return!0}}function deleteTable(state,dispatch){const $pos=state.selection.$anchor;for(let d=$pos.depth;d>0;d--){const node=$pos.node(d);if("table"==node.type.spec.tableRole)return dispatch&&dispatch(state.tr.delete($pos.before(d),$pos.after(d)).scrollIntoView()),!0}return!1}
// src/index.ts
function tableEditing({allowTableNodeSelection:allowTableNodeSelection=!1}={}){return new Plugin({key:tableEditingKey,state:{init(){return null},apply(tr,cur){const set=tr.getMeta(tableEditingKey);if(null!=set)return-1==set?null:set;if(null==cur||!tr.docChanged)return cur;const{deleted:deleted,pos:pos}=tr.mapping.mapResult(cur);return deleted?null:pos}},props:{decorations:drawCellSelection,handleDOMEvents:{mousedown:handleMouseDown},createSelectionBetween(view){return null!=tableEditingKey.getState(view.state)?view.state.selection:null},handleTripleClick:handleTripleClick,handleKeyDown:handleKeyDown,handlePaste:handlePaste},appendTransaction(_,oldState,state){return normalizeSelection(state,fixTables(state,oldState),allowTableNodeSelection)}})}function updateColumns(node,colgroup,table,cellMinWidth,overrideCol,overrideValue){let totalWidth=0,fixedWidth=!0,nextDOM=colgroup.firstChild;const row=node.firstChild;for(let i=0,col=0;i<row.childCount;i+=1){const{colspan:colspan,colwidth:colwidth}=row.child(i).attrs;for(let j=0;j<colspan;j+=1,col+=1){const hasWidth=overrideCol===col?overrideValue:colwidth&&colwidth[j],cssWidth=hasWidth?`${hasWidth}px`:"";totalWidth+=hasWidth||cellMinWidth,hasWidth||(fixedWidth=!1),nextDOM?(nextDOM.style.width!==cssWidth&&(nextDOM.style.width=cssWidth),nextDOM=nextDOM.nextSibling):colgroup.appendChild(document.createElement("col")).style.width=cssWidth}}while(nextDOM){const after=nextDOM.nextSibling;nextDOM.parentNode.removeChild(nextDOM),nextDOM=after}fixedWidth?(table.style.width=`${totalWidth}px`,table.style.minWidth=""):(table.style.width="",table.style.minWidth=`${totalWidth}px`)}class TableView{constructor(node,cellMinWidth){this.node=node,this.cellMinWidth=cellMinWidth,this.dom=document.createElement("div"),this.dom.className="tableWrapper",this.table=this.dom.appendChild(document.createElement("table")),this.colgroup=this.table.appendChild(document.createElement("colgroup")),updateColumns(node,this.colgroup,this.table,cellMinWidth),this.contentDOM=this.table.appendChild(document.createElement("tbody"))}update(node){return node.type===this.node.type&&(this.node=node,updateColumns(node,this.colgroup,this.table,this.cellMinWidth),!0)}ignoreMutation(mutation){return"attributes"===mutation.type&&(mutation.target===this.table||this.colgroup.contains(mutation.target))}}function createCell(cellType,cellContent){return cellContent?cellType.createChecked(null,cellContent):cellType.createAndFill()}function getTableNodeTypes(schema){if(schema.cached.tableNodeTypes)return schema.cached.tableNodeTypes;const roles={};return Object.keys(schema.nodes).forEach((type=>{const nodeType=schema.nodes[type];nodeType.spec.tableRole&&(roles[nodeType.spec.tableRole]=nodeType)})),schema.cached.tableNodeTypes=roles,roles}function createTable(schema,rowsCount,colsCount,withHeaderRow,cellContent){const types=getTableNodeTypes(schema),headerCells=[],cells=[];for(let index=0;index<colsCount;index+=1){const cell=createCell(types.cell,cellContent);if(cell&&cells.push(cell),withHeaderRow){const headerCell=createCell(types.header_cell,cellContent);headerCell&&headerCells.push(headerCell)}}const rows=[];for(let index=0;index<rowsCount;index+=1)rows.push(types.row.createChecked(null,withHeaderRow&&0===index?headerCells:cells));return types.table.createChecked(null,rows)}function isCellSelection(value){return value instanceof CellSelection}const deleteTableWhenAllCellsSelected=({editor:editor})=>{const{selection:selection}=editor.state;if(!isCellSelection(selection))return!1;let cellCount=0;const table=findParentNodeClosestToPos(selection.ranges[0].$from,(node=>"table"===node.type.name));null===table||void 0===table||table.node.descendants((node=>{if("table"===node.type.name)return!1;["tableCell","tableHeader"].includes(node.type.name)&&(cellCount+=1)}));const allCellsSelected=cellCount===selection.ranges.length;return!!allCellsSelected&&(editor.commands.deleteTable(),!0)},Table=Node$1.create({name:"table",
// @ts-ignore
addOptions(){return{HTMLAttributes:{},resizable:!1,handleWidth:5,cellMinWidth:25,
// TODO: fix
View:TableView,lastColumnResizable:!0,allowTableNodeSelection:!1}},content:"tableRow+",tableRole:"table",isolating:!0,group:"block",parseHTML(){return[{tag:"table"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["table",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),["tbody",0]]},addCommands(){return{insertTable:({rows:rows=3,cols:cols=3,withHeaderRow:withHeaderRow=!0}={})=>({tr:tr,dispatch:dispatch,editor:editor})=>{const node=createTable(editor.schema,rows,cols,withHeaderRow);if(dispatch){const offset=tr.selection.anchor+1;tr.replaceSelectionWith(node).scrollIntoView().setSelection(TextSelection.near(tr.doc.resolve(offset)))}return!0},addColumnBefore:()=>({state:state,dispatch:dispatch})=>addColumnBefore(state,dispatch),addColumnAfter:()=>({state:state,dispatch:dispatch})=>addColumnAfter(state,dispatch),deleteColumn:()=>({state:state,dispatch:dispatch})=>deleteColumn(state,dispatch),addRowBefore:()=>({state:state,dispatch:dispatch})=>addRowBefore(state,dispatch),addRowAfter:()=>({state:state,dispatch:dispatch})=>addRowAfter(state,dispatch),deleteRow:()=>({state:state,dispatch:dispatch})=>deleteRow(state,dispatch),deleteTable:()=>({state:state,dispatch:dispatch})=>deleteTable(state,dispatch),mergeCells:()=>({state:state,dispatch:dispatch})=>mergeCells(state,dispatch),splitCell:()=>({state:state,dispatch:dispatch})=>splitCell(state,dispatch),toggleHeaderColumn:()=>({state:state,dispatch:dispatch})=>toggleHeader("column")(state,dispatch),toggleHeaderRow:()=>({state:state,dispatch:dispatch})=>toggleHeader("row")(state,dispatch),toggleHeaderCell:()=>({state:state,dispatch:dispatch})=>toggleHeaderCell(state,dispatch),mergeOrSplit:()=>({state:state,dispatch:dispatch})=>!!mergeCells(state,dispatch)||splitCell(state,dispatch),setCellAttribute:(name,value)=>({state:state,dispatch:dispatch})=>setCellAttr(name,value)(state,dispatch),goToNextCell:()=>({state:state,dispatch:dispatch})=>goToNextCell(1)(state,dispatch),goToPreviousCell:()=>({state:state,dispatch:dispatch})=>goToNextCell(-1)(state,dispatch),fixTables:()=>({state:state,dispatch:dispatch})=>(dispatch&&fixTables(state),!0),setCellSelection:position=>({tr:tr,dispatch:dispatch})=>{if(dispatch){const selection=CellSelection.create(tr.doc,position.anchorCell,position.headCell);
// @ts-ignore
tr.setSelection(selection)}return!0}}},addKeyboardShortcuts(){return{Tab:()=>!!this.editor.commands.goToNextCell()||!!this.editor.can().addRowAfter()&&this.editor.chain().addRowAfter().goToNextCell().run(),"Shift-Tab":()=>this.editor.commands.goToPreviousCell(),Backspace:deleteTableWhenAllCellsSelected,"Mod-Backspace":deleteTableWhenAllCellsSelected,Delete:deleteTableWhenAllCellsSelected,"Mod-Delete":deleteTableWhenAllCellsSelected}},addProseMirrorPlugins(){const isResizable=this.options.resizable&&this.editor.isEditable;return[...isResizable?[columnResizing({handleWidth:this.options.handleWidth,cellMinWidth:this.options.cellMinWidth,
// @ts-ignore (incorrect type)
View:this.options.View,
// TODO: PR for @types/prosemirror-tables
// @ts-ignore (incorrect type)
lastColumnResizable:this.options.lastColumnResizable})]:[],tableEditing({allowTableNodeSelection:this.options.allowTableNodeSelection})]},extendNodeSchema(extension){const context={name:extension.name,options:extension.options,storage:extension.storage};return{tableRole:callOrReturn(getExtensionField(extension,"tableRole",context))}}}),TableRow=Node$1.create({name:"tableRow",addOptions(){return{HTMLAttributes:{}}},content:"(tableCell | tableHeader)*",tableRole:"row",parseHTML(){return[{tag:"tr"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["tr",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]}}),TableCell=Node$1.create({name:"tableCell",addOptions(){return{HTMLAttributes:{}}},content:"block+",addAttributes(){return{colspan:{default:1},rowspan:{default:1},colwidth:{default:null,parseHTML:element=>{const colwidth=element.getAttribute("colwidth"),value=colwidth?[parseInt(colwidth,10)]:null;return value}}}},tableRole:"cell",isolating:!0,parseHTML(){return[{tag:"td"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["td",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]}}),TableHeader=Node$1.create({name:"tableHeader",addOptions(){return{HTMLAttributes:{}}},content:"block+",addAttributes(){return{colspan:{default:1},rowspan:{default:1},colwidth:{default:null,parseHTML:element=>{const colwidth=element.getAttribute("colwidth"),value=colwidth?[parseInt(colwidth,10)]:null;return value}}}},tableRole:"header_cell",isolating:!0,parseHTML(){return[{tag:"th"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["th",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]}}),Placeholder=Extension.create({name:"placeholder",addOptions(){return{emptyEditorClass:"is-editor-empty",emptyNodeClass:"is-empty",placeholder:"Write something …",showOnlyWhenEditable:!0,showOnlyCurrent:!0,includeChildren:!1}},addProseMirrorPlugins(){return[new Plugin({key:new PluginKey("placeholder"),props:{decorations:({doc:doc,selection:selection})=>{const active=this.editor.isEditable||!this.options.showOnlyWhenEditable,{anchor:anchor}=selection,decorations=[];if(!active)return null;
// only calculate isEmpty once due to its performance impacts (see issue #3360)
const emptyDocInstance=doc.type.createAndFill(),isEditorEmpty=(null===emptyDocInstance||void 0===emptyDocInstance?void 0:emptyDocInstance.sameMarkup(doc))&&null===emptyDocInstance.content.findDiffStart(doc.content);return doc.descendants(((node,pos)=>{const hasAnchor=anchor>=pos&&anchor<=pos+node.nodeSize,isEmpty=!node.isLeaf&&!node.childCount;if((hasAnchor||!this.options.showOnlyCurrent)&&isEmpty){const classes=[this.options.emptyNodeClass];isEditorEmpty&&classes.push(this.options.emptyEditorClass);const decoration=Decoration.node(pos,pos+node.nodeSize,{class:classes.join(" "),"data-placeholder":"function"===typeof this.options.placeholder?this.options.placeholder({editor:this.editor,node:node,pos:pos,hasAnchor:hasAnchor}):this.options.placeholder});decorations.push(decoration)}return this.options.includeChildren})),DecorationSet.create(doc,decorations)}}})]}}),inputRegex$2=/^\s*>\s$/,Blockquote=Node$1.create({name:"blockquote",addOptions(){return{HTMLAttributes:{}}},content:"block+",group:"block",defining:!0,parseHTML(){return[{tag:"blockquote"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["blockquote",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setBlockquote:()=>({commands:commands})=>commands.wrapIn(this.name),toggleBlockquote:()=>({commands:commands})=>commands.toggleWrap(this.name),unsetBlockquote:()=>({commands:commands})=>commands.lift(this.name)}},addKeyboardShortcuts(){return{"Mod-Shift-b":()=>this.editor.commands.toggleBlockquote()}},addInputRules(){return[wrappingInputRule({find:inputRegex$2,type:this.type})]}}),Color=Extension.create({name:"color",addOptions(){return{types:["textStyle"]}},addGlobalAttributes(){return[{types:this.options.types,attributes:{color:{default:null,parseHTML:element=>{var _a;return null===(_a=element.style.color)||void 0===_a?void 0:_a.replace(/['"]+/g,"")},renderHTML:attributes=>attributes.color?{style:`color: ${attributes.color}`}:{}}}}]},addCommands(){return{setColor:color=>({chain:chain})=>chain().setMark("textStyle",{color:color}).run(),unsetColor:()=>({chain:chain})=>chain().setMark("textStyle",{color:null}).removeEmptyTextStyle().run()}}}),HardBreak$1=Node$1.create({name:"hardBreak",addOptions(){return{keepMarks:!0,HTMLAttributes:{}}},inline:!0,group:"inline",selectable:!1,parseHTML(){return[{tag:"br"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["br",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes)]},renderText(){return"\n"},addCommands(){return{setHardBreak:()=>({commands:commands,chain:chain,state:state,editor:editor})=>commands.first([()=>commands.exitCode(),()=>commands.command((()=>{const{selection:selection,storedMarks:storedMarks}=state;if(selection.$from.parent.type.spec.isolating)return!1;const{keepMarks:keepMarks}=this.options,{splittableMarks:splittableMarks}=editor.extensionManager,marks=storedMarks||selection.$to.parentOffset&&selection.$from.marks();return chain().insertContent({type:this.name}).command((({tr:tr,dispatch:dispatch})=>{if(dispatch&&marks&&keepMarks){const filteredMarks=marks.filter((mark=>splittableMarks.includes(mark.type.name)));tr.ensureMarks(filteredMarks)}return!0})).run()}))])}},addKeyboardShortcuts(){return{"Mod-Enter":()=>this.editor.commands.setHardBreak(),"Shift-Enter":()=>this.editor.commands.setHardBreak()}}});var HardBreak=HardBreak$1.extend({addKeyboardShortcuts(){return{}}});const HorizontalRule=Node$1.create({name:"horizontalRule",addOptions(){return{HTMLAttributes:{}}},group:"block",parseHTML(){return[{tag:"hr"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["hr",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes)]},addCommands(){return{setHorizontalRule:()=>({chain:chain})=>chain().insertContent({type:this.name}).command((({tr:tr,dispatch:dispatch})=>{var _a;if(dispatch){const{$to:$to}=tr.selection,posAfter=$to.end();if($to.nodeAfter)tr.setSelection(TextSelection.create(tr.doc,$to.pos));else{
// add node after horizontal rule if it’s the end of the document
const node=null===(_a=$to.parent.type.contentMatch.defaultType)||void 0===_a?void 0:_a.create();node&&(tr.insert(posAfter,node),tr.setSelection(TextSelection.create(tr.doc,posAfter)))}tr.scrollIntoView()}return!0})).run()}},addInputRules(){return[nodeInputRule({find:/^(?:---|—-|___\s|\*\*\*\s)$/,type:this.type})]}}),inputRegex$1=/(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/,Image$1=Node$1.create({name:"image",addOptions(){return{inline:!1,allowBase64:!1,HTMLAttributes:{}}},inline(){return this.options.inline},group(){return this.options.inline?"inline":"block"},draggable:!0,addAttributes(){return{src:{default:null},alt:{default:null},title:{default:null}}},parseHTML(){return[{tag:this.options.allowBase64?"img[src]":'img[src]:not([src^="data:"])'}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["img",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes)]},addCommands(){return{setImage:options=>({commands:commands})=>commands.insertContent({type:this.name,attrs:options})}},addInputRules(){return[nodeInputRule({find:inputRegex$1,type:this.type,getAttributes:match=>{const[,,alt,src,title]=match;return{src:src,alt:alt,title:title}}})]}});var Image=Image$1.extend({addOptions(){return{inline:!1,allowBase64:!0,HTMLAttributes:{}}},addAttributes(){return{src:{default:null},alt:{default:null},title:{default:null},style:{default:null}}}});const FontSize=Extension.create({name:"fontSize",addOptions(){return{types:["textStyle"]}},addGlobalAttributes(){return[{types:this.options.types,attributes:{fontSize:{default:null,parseHTML:element=>element.style.fontSize.replace(/['"]+/g,""),renderHTML:attributes=>attributes.fontSize?{style:`font-size: ${attributes.fontSize}`}:{}}}}]},addCommands(){return{setFontSize:fontSize=>({chain:chain})=>chain().setMark("textStyle",{fontSize:fontSize+"px"}).run(),unsetFontSize:()=>({chain:chain})=>chain().setMark("textStyle",{fontSize:null}).removeEmptyTextStyle().run()}}}),inputRegex=/(?:^|\s)((?:==)((?:[^~=]+))(?:==))$/,pasteRegex=/(?:^|\s)((?:==)((?:[^~=]+))(?:==))/g,Highlight=Mark.create({name:"highlight",addOptions(){return{multicolor:!1,HTMLAttributes:{}}},addAttributes(){return this.options.multicolor?{color:{default:null,parseHTML:element=>element.getAttribute("data-color")||element.style.backgroundColor,renderHTML:attributes=>attributes.color?{"data-color":attributes.color,style:`background-color: ${attributes.color}; color: inherit`}:{}}}:{}},parseHTML(){return[{tag:"mark"}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["mark",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setHighlight:attributes=>({commands:commands})=>commands.setMark(this.name,attributes),toggleHighlight:attributes=>({commands:commands})=>commands.toggleMark(this.name,attributes),unsetHighlight:()=>({commands:commands})=>commands.unsetMark(this.name)}},addKeyboardShortcuts(){return{"Mod-Shift-h":()=>this.editor.commands.toggleHighlight()}},addInputRules(){return[markInputRule({find:inputRegex,type:this.type})]},addPasteRules(){return[markPasteRule({find:pasteRegex,type:this.type})]}});var TableHeaders=TableHeader.extend({addAttributes(){return{colspan:{default:1},rowspan:{default:1},colwidth:{default:null,parseHTML:element=>{const colwidth=element.getAttribute("colwidth"),value=colwidth?[parseInt(colwidth,10)]:null;return value},renderHTML:()=>({style:"border: 1px solid #d0d9e2;color: #2f4058;font-weight: 400;background-color: #fafbff;"})}}},parseHTML(){return[{tag:"th"}]}}),TableCells=TableCell.extend({addAttributes(){return{colspan:{default:1},rowspan:{default:1},colwidth:{default:null,parseHTML:element=>{const colwidth=element.getAttribute("colwidth"),value=colwidth?[parseInt(colwidth,10)]:null;return value},renderHTML:()=>({style:"border: 1px solid #d0d9e2;color: #2f4058;font-weight: 400;"})}}},parseHTML(){return[{tag:"td"}]}}),Paragraphs=Paragraph.extend({renderHTML({HTMLAttributes:HTMLAttributes}){return["p",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]}});
// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY
// See update-tlds.js for encoding/decoding format
// https://data.iana.org/TLD/tlds-alpha-by-domain.txt
const encodedTlds="aaa1rp3barth4b0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0faromeo7ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re2s2c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y0eats7k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking0channel11l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t0isalat7u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0at2delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d0network8tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntdoor4ier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5gtv3iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0eles2s3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1nder2le4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster5ia3d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4de2k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0cys3drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7serati6ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic3tual5v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rthwesternmutual14on4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3ssagens7y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cher3ks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w0time7i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ffany5ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0channel7ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lkswagen7vo3te1ing3o2yage5u0elos6wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2",encodedUtlds="ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5تصالات6رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2",forms_assign=(target,properties)=>{for(const key in properties)target[key]=properties[key];return target},numeric="numeric",ascii="ascii",alpha="alpha",asciinumeric="asciinumeric",alphanumeric="alphanumeric",domain="domain",emoji="emoji",scheme="scheme",slashscheme="slashscheme",whitespace="whitespace";
// Internationalized domain names containing non-ASCII
/**
 * @template T
 * @param {string} name
 * @param {Collections<T>} groups to register in
 * @returns {T[]} Current list of tokens in the given collection
 */
function registerGroup(name,groups){return name in groups||(groups[name]=[]),groups[name]}
/**
 * @template T
 * @param {T} t token to add
 * @param {Collections<T>} groups
 * @param {Flags} flags
 */function addToGroups(t,flags,groups){flags[numeric]&&(flags[asciinumeric]=!0,flags[alphanumeric]=!0),flags[ascii]&&(flags[asciinumeric]=!0,flags[alpha]=!0),flags[asciinumeric]&&(flags[alphanumeric]=!0),flags[alpha]&&(flags[alphanumeric]=!0),flags[alphanumeric]&&(flags[domain]=!0),flags[emoji]&&(flags[domain]=!0);for(const k in flags){const group=registerGroup(k,groups);group.indexOf(t)<0&&group.push(t)}}
/**
 * @template T
 * @param {T} t token to check
 * @param {Collections<T>} groups
 * @returns {Flags} group flags that contain this token
 */function flagsForToken(t,groups){const result={};for(const c in groups)groups[c].indexOf(t)>=0&&(result[c]=!0);return result}
/**
 * @template T
 * @typedef {null | T } Transition
 */
/**
 * Define a basic state machine state. j is the list of character transitions,
 * jr is the list of regex-match transitions, jd is the default state to
 * transition to t is the accepting token type, if any. If this is the terminal
 * state, then it does not emit a token.
 *
 * The template type T represents the type of the token this state accepts. This
 * should be a string (such as of the token exports in `text.js`) or a
 * MultiToken subclass (from `multi.js`)
 *
 * @template T
 * @param {T} [token] Token that this state emits
 */function State(token){void 0===token&&(token=null),
// this.n = null; // DEBUG: State name
/** @type {{ [input: string]: State<T> }} j */
this.j={},// IMPLEMENTATION 1
// this.j = []; // IMPLEMENTATION 2
/** @type {[RegExp, State<T>][]} jr */
this.jr=[],
/** @type {?State<T>} jd */
this.jd=null,
/** @type {?T} t */
this.t=token}
/**
 * Scanner token groups
 * @type Collections<string>
 */State.groups={},State.prototype={accepts(){return!!this.t},
/**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
go(input){const state=this,nextState=state.j[input];if(nextState)return nextState;for(let i=0;i<state.jr.length;i++){const regex=state.jr[i][0],nextState=state.jr[i][1];// note: might be empty to prevent default jump
if(nextState&&regex.test(input))return nextState}
// Nowhere left to jump! Return default, if any
return state.jd},
/**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
has(input,exactOnly){return void 0===exactOnly&&(exactOnly=!1),exactOnly?input in this.j:!!this.go(input)},
/**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
ta(inputs,next,flags,groups){for(let i=0;i<inputs.length;i++)this.tt(inputs[i],next,flags,groups)},
/**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
tr(regexp,next,flags,groups){let nextState;return groups=groups||State.groups,next&&next.j?nextState=next:(
// Token with maybe token groups
nextState=new State(next),flags&&groups&&addToGroups(next,flags,groups)),this.jr.push([regexp,nextState]),nextState},
/**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
ts(input,next,flags,groups){let state=this;const len=input.length;if(!len)return state;for(let i=0;i<len-1;i++)state=state.tt(input[i]);return state.tt(input[len-1],next,flags,groups)},
/**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
tt(input,next,flags,groups){groups=groups||State.groups;const state=this;
// Check if existing state given, just a basic transition
if(next&&next.j)return state.j[input]=next,next;const t=next;
// Take the transition with the usual default mechanisms and use that as
// a template for creating the next state
let nextState,templateState=state.go(input);if(templateState?(nextState=new State,forms_assign(nextState.j,templateState.j),nextState.jr.push.apply(nextState.jr,templateState.jr),nextState.jd=templateState.jd,nextState.t=templateState.t):nextState=new State,t){
// Ensure newly token is in the same groups as the old token
if(groups)if(nextState.t&&"string"===typeof nextState.t){const allFlags=forms_assign(flagsForToken(nextState.t,groups),flags);addToGroups(t,allFlags,groups)}else flags&&addToGroups(t,flags,groups);nextState.t=t}return state.j[input]=nextState,nextState}};
// Helper functions to improve minification (not exported outside linkifyjs module)
/**
 * @template T
 * @param {State<T>} state
 * @param {string | string[]} input
 * @param {Flags} [flags]
 * @param {Collections<T>} [groups]
 */
const ta=(state,input,next,flags,groups)=>state.ta(input,next,flags,groups)
/**
 * @template T
 * @param {State<T>} state
 * @param {RegExp} regexp
 * @param {T | State<T>} [next]
 * @param {Flags} [flags]
 * @param {Collections<T>} [groups]
 */,tr=(state,regexp,next,flags,groups)=>state.tr(regexp,next,flags,groups)
/**
 * @template T
 * @param {State<T>} state
 * @param {string | string[]} input
 * @param {T | State<T>} [next]
 * @param {Flags} [flags]
 * @param {Collections<T>} [groups]
 */,ts=(state,input,next,flags,groups)=>state.ts(input,next,flags,groups)
/**
 * @template T
 * @param {State<T>} state
 * @param {string} input
 * @param {T | State<T>} [next]
 * @param {Collections<T>} [groups]
 * @param {Flags} [flags]
 */,tt=(state,input,next,flags,groups)=>state.tt(input,next,flags,groups)
/******************************************************************************
Text Tokens
Identifiers for token outputs from the regexp scanner
******************************************************************************/
// A valid web domain token
,WORD="WORD",UWORD="UWORD",LOCALHOST="LOCALHOST",TLD="TLD",UTLD="UTLD",SCHEME="SCHEME",SLASH_SCHEME="SLASH_SCHEME",NUM="NUM",WS="WS",NL$1="NL",OPENBRACE="OPENBRACE",OPENBRACKET="OPENBRACKET",OPENANGLEBRACKET="OPENANGLEBRACKET",OPENPAREN="OPENPAREN",CLOSEBRACE="CLOSEBRACE",CLOSEBRACKET="CLOSEBRACKET",CLOSEANGLEBRACKET="CLOSEANGLEBRACKET",CLOSEPAREN="CLOSEPAREN",AMPERSAND="AMPERSAND",APOSTROPHE="APOSTROPHE",ASTERISK="ASTERISK",AT="AT",BACKSLASH="BACKSLASH",BACKTICK="BACKTICK",CARET="CARET",COLON="COLON",COMMA="COMMA",DOLLAR="DOLLAR",DOT="DOT",EQUALS="EQUALS",EXCLAMATION="EXCLAMATION",HYPHEN="HYPHEN",PERCENT="PERCENT",PIPE="PIPE",PLUS="PLUS",POUND="POUND",QUERY="QUERY",QUOTE="QUOTE",SEMI="SEMI",SLASH="SLASH",TILDE="TILDE",UNDERSCORE="UNDERSCORE",EMOJI$1="EMOJI",SYM="SYM";var tk=Object.freeze({__proto__:null,WORD:WORD,UWORD:UWORD,LOCALHOST:LOCALHOST,TLD:TLD,UTLD:UTLD,SCHEME:SCHEME,SLASH_SCHEME:SLASH_SCHEME,NUM:NUM,WS:WS,NL:NL$1,OPENBRACE:OPENBRACE,OPENBRACKET:OPENBRACKET,OPENANGLEBRACKET:OPENANGLEBRACKET,OPENPAREN:OPENPAREN,CLOSEBRACE:CLOSEBRACE,CLOSEBRACKET:CLOSEBRACKET,CLOSEANGLEBRACKET:CLOSEANGLEBRACKET,CLOSEPAREN:CLOSEPAREN,AMPERSAND:AMPERSAND,APOSTROPHE:APOSTROPHE,ASTERISK:ASTERISK,AT:AT,BACKSLASH:BACKSLASH,BACKTICK:BACKTICK,CARET:CARET,COLON:COLON,COMMA:COMMA,DOLLAR:DOLLAR,DOT:DOT,EQUALS:EQUALS,EXCLAMATION:EXCLAMATION,HYPHEN:HYPHEN,PERCENT:PERCENT,PIPE:PIPE,PLUS:PLUS,POUND:POUND,QUERY:QUERY,QUOTE:QUOTE,SEMI:SEMI,SLASH:SLASH,TILDE:TILDE,UNDERSCORE:UNDERSCORE,EMOJI:EMOJI$1,SYM:SYM});
// Note that these two Unicode ones expand into a really big one with Babel
const ASCII_LETTER=/[a-z]/,LETTER=/\p{L}/u,EMOJI=/\p{Emoji}/u,DIGIT=/\d/,SPACE=/\s/,NL="\n",EMOJI_VARIATION="️",EMOJI_JOINER="‍";// zero-width joiner
let tlds=null,utlds=null;// don't change so only have to be computed once
/**
 * Scanner output token:
 * - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')
 * - `v` is the value of the token (e.g., '123', '❤️', 'com')
 * - `s` is the start index of the token in the original string
 * - `e` is the end index of the token in the original string
 * @typedef {{t: string, v: string, s: number, e: number}} Token
 */
/**
 * @template T
 * @typedef {{ [collection: string]: T[] }} Collections
 */
/**
 * Initialize the scanner character-based state machine for the given start
 * state
 * @param {[string, boolean][]} customSchemes List of custom schemes, where each
 * item is a length-2 tuple with the first element set to the string scheme, and
 * the second element set to `true` if the `://` after the scheme is optional
 */function init$2(customSchemes){void 0===customSchemes&&(customSchemes=[]);
// Frequently used states (name argument removed during minification)
/** @type Collections<string> */const groups={};// of tokens
State.groups=groups;
/** @type State<string> */
const Start=new State;null==tlds&&(tlds=decodeTlds(encodedTlds)),null==utlds&&(utlds=decodeTlds(encodedUtlds)),
// States for special URL symbols that accept immediately after start
tt(Start,"'",APOSTROPHE),tt(Start,"{",OPENBRACE),tt(Start,"[",OPENBRACKET),tt(Start,"<",OPENANGLEBRACKET),tt(Start,"(",OPENPAREN),tt(Start,"}",CLOSEBRACE),tt(Start,"]",CLOSEBRACKET),tt(Start,">",CLOSEANGLEBRACKET),tt(Start,")",CLOSEPAREN),tt(Start,"&",AMPERSAND),tt(Start,"*",ASTERISK),tt(Start,"@",AT),tt(Start,"`",BACKTICK),tt(Start,"^",CARET),tt(Start,":",COLON),tt(Start,",",COMMA),tt(Start,"$",DOLLAR),tt(Start,".",DOT),tt(Start,"=",EQUALS),tt(Start,"!",EXCLAMATION),tt(Start,"-",HYPHEN),tt(Start,"%",PERCENT),tt(Start,"|",PIPE),tt(Start,"+",PLUS),tt(Start,"#",POUND),tt(Start,"?",QUERY),tt(Start,'"',QUOTE),tt(Start,"/",SLASH),tt(Start,";",SEMI),tt(Start,"~",TILDE),tt(Start,"_",UNDERSCORE),tt(Start,"\\",BACKSLASH);const Num=tr(Start,DIGIT,NUM,{[numeric]:!0});tr(Num,DIGIT,Num);
// State which emits a word token
const Word=tr(Start,ASCII_LETTER,WORD,{[ascii]:!0});tr(Word,ASCII_LETTER,Word);
// Same as previous, but specific to non-fsm.ascii alphabet words
const UWord=tr(Start,LETTER,UWORD,{[alpha]:!0});tr(UWord,ASCII_LETTER),// Non-accepting
tr(UWord,LETTER,UWord);
// Whitespace jumps
// Tokens of only non-newline whitespace are arbitrarily long
// If any whitespace except newline, more whitespace!
const Ws=tr(Start,SPACE,WS,{[whitespace]:!0});tt(Start,NL,NL$1,{[whitespace]:!0}),tt(Ws,NL),// non-accepting state to avoid mixing whitespaces
tr(Ws,SPACE,Ws);
// Emoji tokens. They are not grouped by the scanner except in cases where a
// zero-width joiner is present
const Emoji=tr(Start,EMOJI,EMOJI$1,{[emoji]:!0});tr(Emoji,EMOJI,Emoji),tt(Emoji,EMOJI_VARIATION,Emoji);
// tt(Start, EMOJI_VARIATION, Emoji); // This one is sketchy
const EmojiJoiner=tt(Emoji,EMOJI_JOINER);tr(EmojiJoiner,EMOJI,Emoji);
// tt(EmojiJoiner, EMOJI_VARIATION, Emoji); // also sketchy
// Generates states for top-level domains
// Note that this is most accurate when tlds are in alphabetical order
const wordjr=[[ASCII_LETTER,Word]],uwordjr=[[ASCII_LETTER,null],[LETTER,UWord]];for(let i=0;i<tlds.length;i++)fastts(Start,tlds[i],TLD,WORD,wordjr);for(let i=0;i<utlds.length;i++)fastts(Start,utlds[i],UTLD,UWORD,uwordjr);addToGroups(TLD,{tld:!0,ascii:!0},groups),addToGroups(UTLD,{utld:!0,alpha:!0},groups),
// Collect the states generated by different protocols. NOTE: If any new TLDs
// get added that are also protocols, set the token to be the same as the
// protocol to ensure parsing works as expected.
fastts(Start,"file",SCHEME,WORD,wordjr),fastts(Start,"mailto",SCHEME,WORD,wordjr),fastts(Start,"http",SLASH_SCHEME,WORD,wordjr),fastts(Start,"https",SLASH_SCHEME,WORD,wordjr),fastts(Start,"ftp",SLASH_SCHEME,WORD,wordjr),fastts(Start,"ftps",SLASH_SCHEME,WORD,wordjr),addToGroups(SCHEME,{scheme:!0,ascii:!0},groups),addToGroups(SLASH_SCHEME,{slashscheme:!0,ascii:!0},groups),
// Register custom schemes. Assumes each scheme is asciinumeric with hyphens
customSchemes=customSchemes.sort(((a,b)=>a[0]>b[0]?1:-1));for(let i=0;i<customSchemes.length;i++){const sch=customSchemes[i][0],optionalSlashSlash=customSchemes[i][1],flags=optionalSlashSlash?{[scheme]:!0}:{[slashscheme]:!0};sch.indexOf("-")>=0?flags[domain]=!0:ASCII_LETTER.test(sch)?DIGIT.test(sch)?flags[asciinumeric]=!0:flags[ascii]=!0:flags[numeric]=!0,ts(Start,sch,sch,flags)}
// Localhost token
return ts(Start,"localhost",LOCALHOST,{ascii:!0}),
// Set default transition for start state (some symbol)
Start.jd=new State(SYM),{start:Start,tokens:forms_assign({groups:groups},tk)}}
/**
	Given a string, returns an array of TOKEN instances representing the
	composition of that string.

	@method run
	@param {State<string>} start scanner starting state
	@param {string} str input string to scan
	@return {Token[]} list of tokens, each with a type and value
*/function run$1(start,str){
// State machine is not case sensitive, so input is tokenized in lowercased
// form (still returns regular case). Uses selective `toLowerCase` because
// lowercasing the entire string causes the length and character position to
// vary in some non-English strings with V8-based runtimes.
const iterable=stringToArray(str.replace(/[A-Z]/g,(c=>c.toLowerCase()))),charCount=iterable.length,tokens=[];// return value
// cursor through the string itself, accounting for characters that have
// width with length 2 such as emojis
let cursor=0,charCursor=0;
// Cursor through the array-representation of the string
// Tokenize the string
while(charCursor<charCount){let state=start,nextState=null,tokenLength=0,latestAccepting=null,sinceAccepts=-1,charsSinceAccepts=-1;while(charCursor<charCount&&(nextState=state.go(iterable[charCursor])))state=nextState,
// Keep track of the latest accepting state
state.accepts()?(sinceAccepts=0,charsSinceAccepts=0,latestAccepting=state):sinceAccepts>=0&&(sinceAccepts+=iterable[charCursor].length,charsSinceAccepts++),tokenLength+=iterable[charCursor].length,cursor+=iterable[charCursor].length,charCursor++;
// Roll back to the latest accepting state
cursor-=sinceAccepts,charCursor-=charsSinceAccepts,tokenLength-=sinceAccepts,
// No more jumps, just make a new token from the last accepting one
tokens.push({t:latestAccepting.t,
// token type/name
v:str.slice(cursor-tokenLength,cursor),
// string value
s:cursor-tokenLength,
// start index
e:cursor})}return tokens}
/**
 * Convert a String to an Array of characters, taking into account that some
 * characters like emojis take up two string indexes.
 *
 * Adapted from core-js (MIT license)
 * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js
 *
 * @function stringToArray
 * @param {string} str
 * @returns {string[]}
 */function stringToArray(str){const result=[],len=str.length;let index=0;while(index<len){let second,first=str.charCodeAt(index),char=first<55296||first>56319||index+1===len||(second=str.charCodeAt(index+1))<56320||second>57343?str[index]:str.slice(index,index+2);// two-index characters
result.push(char),index+=char.length}return result}
/**
 * Fast version of ts function for when transition defaults are well known
 * @param {State<string>} state
 * @param {string} input
 * @param {string} t
 * @param {string} defaultt
 * @param {[RegExp, State<string>][]} jr
 * @returns {State<string>}
 */function fastts(state,input,t,defaultt,jr){let next;const len=input.length;for(let i=0;i<len-1;i++){const char=input[i];state.j[char]?next=state.j[char]:(next=new State(defaultt),next.jr=jr.slice(),state.j[char]=next),state=next}return next=new State(t),next.jr=jr.slice(),state.j[input[len-1]]=next,next}
/**
 * Converts a string of Top-Level Domain names encoded in update-tlds.js back
 * into a list of strings.
 * @param {str} encoded encoded TLDs string
 * @returns {str[]} original TLDs list
 */function decodeTlds(encoded){const words=[],stack=[];let i=0,digits="0123456789";while(i<encoded.length){let popDigitCount=0;while(digits.indexOf(encoded[i+popDigitCount])>=0)popDigitCount++;// encountered some digits, have to pop to go one level up trie
if(popDigitCount>0){words.push(stack.join(""));// whatever preceded the pop digits must be a word
for(let popCount=parseInt(encoded.substring(i,i+popDigitCount),10);popCount>0;popCount--)stack.pop();i+=popDigitCount}else stack.push(encoded[i]),// drop down a level into the trie
i++}return words}
/**
 * An object where each key is a valid DOM Event Name such as `click` or `focus`
 * and each value is an event handler function.
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/Element#events
 * @typedef {?{ [event: string]: Function }} EventListeners
 */
/**
 * All formatted properties required to render a link, including `tagName`,
 * `attributes`, `content` and `eventListeners`.
 * @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,
 * eventListeners: EventListeners }} IntermediateRepresentation
 */
/**
 * Specify either an object described by the template type `O` or a function.
 *
 * The function takes a string value (usually the link's href attribute), the
 * link type (`'url'`, `'hashtag`', etc.) and an internal token representation
 * of the link. It should return an object of the template type `O`
 * @template O
 * @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj
 */
/**
 * Specify either a function described by template type `F` or an object.
 *
 * Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each
 * value should be a function with template type `F` that is called when the
 * corresponding link type is encountered.
 * @template F
 * @typedef {F | { [type: string]: F}} OptFn
 */
/**
 * Specify either a value with template type `V`, a function that returns `V` or
 * an object where each value resolves to `V`.
 *
 * The function takes a string value (usually the link's href attribute), the
 * link type (`'url'`, `'hashtag`', etc.) and an internal token representation
 * of the link. It should return an object of the template type `V`
 *
 * For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).
 * Each value should either have type `V` or a function that returns V. This
 * function similarly takes a string value and a token.
 *
 * Example valid types for `Opt<string>`:
 *
 * ```js
 * 'hello'
 * (value, type, token) => 'world'
 * { url: 'hello', email: (value, token) => 'world'}
 * ```
 * @template V
 * @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt
 */
/**
 * See available options: https://linkify.js.org/docs/options.html
 * @typedef {{
 * 	defaultProtocol?: string,
 *  events?: OptObj<EventListeners>,
 * 	format?: Opt<string>,
 * 	formatHref?: Opt<string>,
 * 	nl2br?: boolean,
 * 	tagName?: Opt<any>,
 * 	target?: Opt<string>,
 * 	rel?: Opt<string>,
 * 	validate?: Opt<boolean>,
 * 	truncate?: Opt<number>,
 * 	className?: Opt<string>,
 * 	attributes?: OptObj<({ [attr: string]: any })>,
 *  ignoreTags?: string[],
 * 	render?: OptFn<((ir: IntermediateRepresentation) => any)>
 * }} Opts
 */
/**
 * @type Required<Opts>
 */const defaults={defaultProtocol:"http",events:null,format:noop,formatHref:noop,nl2br:!1,tagName:"a",target:null,rel:null,validate:!0,truncate:1/0,className:null,attributes:null,ignoreTags:[],render:null};
/**
 * Utility class for linkify interfaces to apply specified
 * {@link Opts formatting and rendering options}.
 *
 * @param {Opts | Options} [opts] Option value overrides.
 * @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For
 *   internal use) default render function that determines how to generate an
 *   HTML element based on a link token's derived tagName, attributes and HTML.
 *   Similar to render option
 */function Options(opts,defaultRender){void 0===defaultRender&&(defaultRender=null);let o=forms_assign({},defaults);opts&&(o=forms_assign(o,opts instanceof Options?opts.o:opts));
// Ensure all ignored tags are uppercase
const ignoredTags=o.ignoreTags,uppercaseIgnoredTags=[];for(let i=0;i<ignoredTags.length;i++)uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());
/** @protected */this.o=o,defaultRender&&(this.defaultRender=defaultRender),this.ignoreTags=uppercaseIgnoredTags}function noop(val){return val}
/******************************************************************************
	Multi-Tokens
	Tokens composed of arrays of TextTokens
******************************************************************************/
/**
 * @param {string} value
 * @param {Token[]} tokens
 */function MultiToken(value,tokens){this.t="token",this.v=value,this.tk=tokens}
/**
 * Abstract class used for manufacturing tokens of text tokens. That is rather
 * than the value for a token being a small string of text, it's value an array
 * of text tokens.
 *
 * Used for grouping together URLs, emails, hashtags, and other potential
 * creations.
 * @class MultiToken
 * @property {string} t
 * @property {string} v
 * @property {Token[]} tk
 * @abstract
 */
/**
 * Create a new token that can be emitted by the parser state machine
 * @param {string} type readable type of the token
 * @param {object} props properties to assign or override, including isLink = true or false
 * @returns {new (value: string, tokens: Token[]) => MultiToken} new token class
 */
function createTokenClass(type,props){class Token extends MultiToken{constructor(value,tokens){super(value,tokens),this.t=type}}for(const p in props)Token.prototype[p]=props[p];return Token.t=type,Token}
/**
	Represents a list of tokens making up a valid email address
*/Options.prototype={o:defaults,
/**
   * @type string[]
   */
ignoreTags:[],
/**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
defaultRender(ir){return ir},
/**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
check(token){return this.get("validate",token.toString(),token)},
// Private methods
/**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
get(key,operator,token){const isCallable=null!=operator;let option=this.o[key];return option?("object"===typeof option?(option=token.t in option?option[token.t]:defaults[key],"function"===typeof option&&isCallable&&(option=option(operator,token))):"function"===typeof option&&isCallable&&(option=option(operator,token.t,token)),option):option},
/**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
getObj(key,operator,token){let obj=this.o[key];return"function"===typeof obj&&null!=operator&&(obj=obj(operator,token.t,token)),obj},
/**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
render(token){const ir=token.render(this),renderFn=this.get("render",null,token)||this.defaultRender;// intermediate representation
return renderFn(ir,token.t,token)}},MultiToken.prototype={isLink:!1,
/**
   * Return the string this token represents.
   * @return {string}
   */
toString(){return this.v},
/**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
  */
toHref(scheme){return this.toString()},
/**
   * @param {Options} options Formatting options
   * @returns {string}
   */
toFormattedString(options){const val=this.toString(),truncate=options.get("truncate",val,this),formatted=options.get("format",val,this);return truncate&&formatted.length>truncate?formatted.substring(0,truncate)+"…":formatted},
/**
   *
   * @param {Options} options
   * @returns {string}
   */
toFormattedHref(options){return options.get("formatHref",this.toHref(options.get("defaultProtocol")),this)},
/**
   * The start index of this token in the original input string
   * @returns {number}
   */
startIndex(){return this.tk[0].s},
/**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
endIndex(){return this.tk[this.tk.length-1].e},
/**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
toObject(protocol){return void 0===protocol&&(protocol=defaults.defaultProtocol),{type:this.t,value:this.toString(),isLink:this.isLink,href:this.toHref(protocol),start:this.startIndex(),end:this.endIndex()}},
/**
   *
   * @param {Options} options Formatting option
   */
toFormattedObject(options){return{type:this.t,value:this.toFormattedString(options),isLink:this.isLink,href:this.toFormattedHref(options),start:this.startIndex(),end:this.endIndex()}},
/**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
validate(options){return options.get("validate",this.toString(),this)},
/**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
render(options){const token=this,href=this.toHref(options.get("defaultProtocol")),formattedHref=options.get("formatHref",href,this),tagName=options.get("tagName",href,token),content=this.toFormattedString(options),attributes={},className=options.get("className",href,token),target=options.get("target",href,token),rel=options.get("rel",href,token),attrs=options.getObj("attributes",href,token),eventListeners=options.getObj("events",href,token);return attributes.href=formattedHref,className&&(attributes.class=className),target&&(attributes.target=target),rel&&(attributes.rel=rel),attrs&&forms_assign(attributes,attrs),{tagName:tagName,attributes:attributes,content:content,eventListeners:eventListeners}}};const Email=createTokenClass("email",{isLink:!0,toHref(){return"mailto:"+this.toString()}}),Text=createTokenClass("text"),Nl=createTokenClass("nl"),Url=createTokenClass("url",{isLink:!0,
/**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
toHref(scheme){
// Check if already has a prefix scheme
return void 0===scheme&&(scheme=defaults.defaultProtocol),this.hasProtocol()?this.v:`${scheme}://${this.v}`},
/**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
hasProtocol(){const tokens=this.tk;return tokens.length>=2&&tokens[0].t!==LOCALHOST&&tokens[1].t===COLON}}),makeState=arg=>new State(arg)
/**
 * Generate the parser multi token-based state machine
 * @param {{ groups: Collections<string> }} tokens
 */;
/**
	Represents some plain text
*/function init$1(_ref){let{groups:groups}=_ref;
// Types of characters the URL can definitely end in
const qsAccepting=groups.domain.concat([AMPERSAND,ASTERISK,AT,BACKSLASH,BACKTICK,CARET,DOLLAR,EQUALS,HYPHEN,NUM,PERCENT,PIPE,PLUS,POUND,SLASH,SYM,TILDE,UNDERSCORE]),qsNonAccepting=[APOSTROPHE,CLOSEANGLEBRACKET,CLOSEBRACE,CLOSEBRACKET,CLOSEPAREN,COLON,COMMA,DOT,EXCLAMATION,OPENANGLEBRACKET,OPENBRACE,OPENBRACKET,OPENPAREN,QUERY,QUOTE,SEMI],localpartAccepting=[AMPERSAND,APOSTROPHE,ASTERISK,BACKSLASH,BACKTICK,CARET,CLOSEBRACE,DOLLAR,EQUALS,HYPHEN,OPENBRACE,PERCENT,PIPE,PLUS,POUND,QUERY,SLASH,SYM,TILDE,UNDERSCORE],Start=makeState(),Localpart=tt(Start,TILDE);
// Types of tokens that can follow a URL and be part of the query string
// but cannot be the very last characters
// Characters that cannot appear in the URL at all should be excluded
// Local part of the email address
ta(Localpart,localpartAccepting,Localpart),ta(Localpart,groups.domain,Localpart);const Domain=makeState(),Scheme=makeState(),SlashScheme=makeState();ta(Start,groups.domain,Domain),// parsed string ends with a potential domain name (A)
ta(Start,groups.scheme,Scheme),// e.g., 'mailto'
ta(Start,groups.slashscheme,SlashScheme),// e.g., 'http'
ta(Domain,localpartAccepting,Localpart),ta(Domain,groups.domain,Domain);const LocalpartAt=tt(Domain,AT);// Local part of the email address plus @
tt(Localpart,AT,LocalpartAt),// close to an email address now
// Local part of an email address can be e.g. 'http' or 'mailto'
tt(Scheme,AT,LocalpartAt),tt(SlashScheme,AT,LocalpartAt);const LocalpartDot=tt(Localpart,DOT);// Local part of the email address plus '.' (localpart cannot end in .)
ta(LocalpartDot,localpartAccepting,Localpart),ta(LocalpartDot,groups.domain,Localpart);const EmailDomain=makeState();ta(LocalpartAt,groups.domain,EmailDomain),// parsed string starts with local email info + @ with a potential domain name
ta(EmailDomain,groups.domain,EmailDomain);const EmailDomainDot=tt(EmailDomain,DOT);// domain followed by DOT
ta(EmailDomainDot,groups.domain,EmailDomain);const Email$1=makeState(Email);// Possible email address (could have more tlds)
ta(EmailDomainDot,groups.tld,Email$1),ta(EmailDomainDot,groups.utld,Email$1),tt(LocalpartAt,LOCALHOST,Email$1);
// Hyphen can jump back to a domain name
const EmailDomainHyphen=tt(EmailDomain,HYPHEN);// parsed string starts with local email info + @ with a potential domain name
ta(EmailDomainHyphen,groups.domain,EmailDomain),ta(Email$1,groups.domain,EmailDomain),tt(Email$1,DOT,EmailDomainDot),tt(Email$1,HYPHEN,EmailDomainHyphen);
// Final possible email states
const EmailColon=tt(Email$1,COLON);// URL followed by colon (potential port number here)
/*const EmailColonPort = */ta(EmailColon,groups.numeric,Email);// URL followed by colon and port numner
// Account for dots and hyphens. Hyphens are usually parts of domain names
// (but not TLDs)
const DomainHyphen=tt(Domain,HYPHEN),DomainDot=tt(Domain,DOT);// domain followed by hyphen
// domain followed by DOT
ta(DomainHyphen,groups.domain,Domain),ta(DomainDot,localpartAccepting,Localpart),ta(DomainDot,groups.domain,Domain);const DomainDotTld=makeState(Url);// Simplest possible URL with no query string
ta(DomainDot,groups.tld,DomainDotTld),ta(DomainDot,groups.utld,DomainDotTld),ta(DomainDotTld,groups.domain,Domain),ta(DomainDotTld,localpartAccepting,Localpart),tt(DomainDotTld,DOT,DomainDot),tt(DomainDotTld,HYPHEN,DomainHyphen),tt(DomainDotTld,AT,LocalpartAt);const DomainDotTldColon=tt(DomainDotTld,COLON),DomainDotTldColonPort=makeState(Url);// URL followed by colon (potential port number here)
// TLD followed by a port number
ta(DomainDotTldColon,groups.numeric,DomainDotTldColonPort);
// Long URL with optional port and maybe query string
const Url$1=makeState(Url),UrlNonaccept=makeState();
// URL with extra symbols at the end, followed by an opening bracket
// URL followed by some symbols (will not be part of the final URL)
// Query strings
ta(Url$1,qsAccepting,Url$1),ta(Url$1,qsNonAccepting,UrlNonaccept),ta(UrlNonaccept,qsAccepting,Url$1),ta(UrlNonaccept,qsNonAccepting,UrlNonaccept),
// Become real URLs after `SLASH` or `COLON NUM SLASH`
// Here works with or without scheme:// prefix
tt(DomainDotTld,SLASH,Url$1),tt(DomainDotTldColonPort,SLASH,Url$1);
// Note that domains that begin with schemes are treated slighly differently
const SchemeColon=tt(Scheme,COLON),SlashSchemeColon=tt(SlashScheme,COLON),SlashSchemeColonSlash=tt(SlashSchemeColon,SLASH),UriPrefix=tt(SlashSchemeColonSlash,SLASH);// e.g., 'mailto:'
// e.g., 'http://'
// Scheme states can transition to domain states
ta(Scheme,groups.domain,Domain),tt(Scheme,DOT,DomainDot),tt(Scheme,HYPHEN,DomainHyphen),ta(SlashScheme,groups.domain,Domain),tt(SlashScheme,DOT,DomainDot),tt(SlashScheme,HYPHEN,DomainHyphen),
// Force URL with scheme prefix followed by anything sane
ta(SchemeColon,groups.domain,Url$1),tt(SchemeColon,SLASH,Url$1),ta(UriPrefix,groups.domain,Url$1),ta(UriPrefix,qsAccepting,Url$1),tt(UriPrefix,SLASH,Url$1);
// URL, followed by an opening bracket
const UrlOpenbrace=tt(Url$1,OPENBRACE),UrlOpenbracket=tt(Url$1,OPENBRACKET),UrlOpenanglebracket=tt(Url$1,OPENANGLEBRACKET),UrlOpenparen=tt(Url$1,OPENPAREN);// URL followed by {
// URL followed by (
tt(UrlNonaccept,OPENBRACE,UrlOpenbrace),tt(UrlNonaccept,OPENBRACKET,UrlOpenbracket),tt(UrlNonaccept,OPENANGLEBRACKET,UrlOpenanglebracket),tt(UrlNonaccept,OPENPAREN,UrlOpenparen),
// Closing bracket component. This character WILL be included in the URL
tt(UrlOpenbrace,CLOSEBRACE,Url$1),tt(UrlOpenbracket,CLOSEBRACKET,Url$1),tt(UrlOpenanglebracket,CLOSEANGLEBRACKET,Url$1),tt(UrlOpenparen,CLOSEPAREN,Url$1),tt(UrlOpenbrace,CLOSEBRACE,Url$1);
// URL that beings with an opening bracket, followed by a symbols.
// Note that the final state can still be `UrlOpenbrace` (if the URL only
// has a single opening bracket for some reason).
const UrlOpenbraceQ=makeState(Url),UrlOpenbracketQ=makeState(Url),UrlOpenanglebracketQ=makeState(Url),UrlOpenparenQ=makeState(Url);// URL followed by { and some symbols that the URL can end it
// URL followed by ( and some symbols that the URL can end it
ta(UrlOpenbrace,qsAccepting,UrlOpenbraceQ),ta(UrlOpenbracket,qsAccepting,UrlOpenbracketQ),ta(UrlOpenanglebracket,qsAccepting,UrlOpenanglebracketQ),ta(UrlOpenparen,qsAccepting,UrlOpenparenQ);const UrlOpenbraceSyms=makeState(),UrlOpenbracketSyms=makeState(),UrlOpenanglebracketSyms=makeState(),UrlOpenparenSyms=makeState();// UrlOpenbrace followed by some symbols it cannot end it
// single new line
// UrlOpenparenQ followed by some symbols it cannot end it
return ta(UrlOpenbrace,qsNonAccepting),ta(UrlOpenbracket,qsNonAccepting),ta(UrlOpenanglebracket,qsNonAccepting),ta(UrlOpenparen,qsNonAccepting),
// URL that begins with an opening bracket, followed by some symbols
ta(UrlOpenbraceQ,qsAccepting,UrlOpenbraceQ),ta(UrlOpenbracketQ,qsAccepting,UrlOpenbracketQ),ta(UrlOpenanglebracketQ,qsAccepting,UrlOpenanglebracketQ),ta(UrlOpenparenQ,qsAccepting,UrlOpenparenQ),ta(UrlOpenbraceQ,qsNonAccepting,UrlOpenbraceQ),ta(UrlOpenbracketQ,qsNonAccepting,UrlOpenbracketQ),ta(UrlOpenanglebracketQ,qsNonAccepting,UrlOpenanglebracketQ),ta(UrlOpenparenQ,qsNonAccepting,UrlOpenparenQ),ta(UrlOpenbraceSyms,qsAccepting,UrlOpenbraceSyms),ta(UrlOpenbracketSyms,qsAccepting,UrlOpenbracketQ),ta(UrlOpenanglebracketSyms,qsAccepting,UrlOpenanglebracketQ),ta(UrlOpenparenSyms,qsAccepting,UrlOpenparenQ),ta(UrlOpenbraceSyms,qsNonAccepting,UrlOpenbraceSyms),ta(UrlOpenbracketSyms,qsNonAccepting,UrlOpenbracketSyms),ta(UrlOpenanglebracketSyms,qsNonAccepting,UrlOpenanglebracketSyms),ta(UrlOpenparenSyms,qsNonAccepting,UrlOpenparenSyms),
// Close brace/bracket to become regular URL
tt(UrlOpenbracketQ,CLOSEBRACKET,Url$1),tt(UrlOpenanglebracketQ,CLOSEANGLEBRACKET,Url$1),tt(UrlOpenparenQ,CLOSEPAREN,Url$1),tt(UrlOpenbraceQ,CLOSEBRACE,Url$1),tt(UrlOpenbracketSyms,CLOSEBRACKET,Url$1),tt(UrlOpenanglebracketSyms,CLOSEANGLEBRACKET,Url$1),tt(UrlOpenparenSyms,CLOSEPAREN,Url$1),tt(UrlOpenbraceSyms,CLOSEPAREN,Url$1),tt(Start,LOCALHOST,DomainDotTld),// localhost is a valid URL state
tt(Start,NL$1,Nl),{start:Start,tokens:tk}}
/**
 * Run the parser state machine on a list of scanned string-based tokens to
 * create a list of multi tokens, each of which represents a URL, email address,
 * plain text, etc.
 *
 * @param {State<MultiToken>} start parser start state
 * @param {string} input the original input used to generate the given tokens
 * @param {Token[]} tokens list of scanned tokens
 * @returns {MultiToken[]}
 */function run(start,input,tokens){let len=tokens.length,cursor=0,multis=[],textTokens=[];while(cursor<len){let state=start,secondState=null,nextState=null,multiLength=0,latestAccepting=null,sinceAccepts=-1;while(cursor<len&&!(secondState=state.go(tokens[cursor].t)))
// Starting tokens with nowhere to jump to.
// Consider these to be just plain text
textTokens.push(tokens[cursor++]);while(cursor<len&&(nextState=secondState||state.go(tokens[cursor].t)))
// Get the next state
secondState=null,state=nextState,
// Keep track of the latest accepting state
state.accepts()?(sinceAccepts=0,latestAccepting=state):sinceAccepts>=0&&sinceAccepts++,cursor++,multiLength++;if(sinceAccepts<0)
// No accepting state was found, part of a regular text token add
// the first text token to the text tokens array and try again from
// the next
cursor-=multiLength,cursor<len&&(textTokens.push(tokens[cursor]),cursor++);else{
// Accepting state!
// First close off the textTokens (if available)
textTokens.length>0&&(multis.push(initMultiToken(Text,input,textTokens)),textTokens=[]),
// Roll back to the latest accepting state
cursor-=sinceAccepts,multiLength-=sinceAccepts;
// Create a new multitoken
const Multi=latestAccepting.t,subtokens=tokens.slice(cursor-multiLength,cursor);multis.push(initMultiToken(Multi,input,subtokens))}}
// Finally close off the textTokens (if available)
return textTokens.length>0&&multis.push(initMultiToken(Text,input,textTokens)),multis}
/**
 * Utility function for instantiating a new multitoken with all the relevant
 * fields during parsing.
 * @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate
 * @param {string} input original input string
 * @param {Token[]} tokens consecutive tokens scanned from input string
 * @returns {MultiToken}
 */function initMultiToken(Multi,input,tokens){const startIdx=tokens[0].s,endIdx=tokens[tokens.length-1].e,value=input.slice(startIdx,endIdx);return new Multi(value,tokens)}const warn="undefined"!==typeof console&&console&&console.warn||(()=>{}),warnAdvice="until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.",INIT={scanner:null,parser:null,tokenQueue:[],pluginQueue:[],customSchemes:[],initialized:!1};
/**
 * @typedef {{
 * 	start: State<string>,
 * 	tokens: { groups: Collections<string> } & typeof tk
 * }} ScannerInit
 */
/**
 * @typedef {{
 * 	start: State<MultiToken>,
 * 	tokens: typeof multi
 * }} ParserInit
 */
/**
 * @typedef {(arg: { scanner: ScannerInit }) => void} TokenPlugin
 */
/**
 * @typedef {(arg: { scanner: ScannerInit, parser: ParserInit }) => void} Plugin
 */
/**
 * De-register all plugins and reset the internal state-machine. Used for
 * testing; not required in practice.
 * @private
 */
function forms_reset(){State.groups={},INIT.scanner=null,INIT.parser=null,INIT.tokenQueue=[],INIT.pluginQueue=[],INIT.customSchemes=[],INIT.initialized=!1}
/**
 * Detect URLs with the following additional protocol. Anything with format
 * "protocol://..." will be considered a link. If `optionalSlashSlash` is set to
 * `true`, anything with format "protocol:..." will be considered a link.
 * @param {string} protocol
 * @param {boolean} [optionalSlashSlash]
 */function registerCustomProtocol(scheme,optionalSlashSlash){if(void 0===optionalSlashSlash&&(optionalSlashSlash=!1),INIT.initialized&&warn(`linkifyjs: already initialized - will not register custom scheme "${scheme}" ${warnAdvice}`),!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme))throw new Error('linkifyjs: incorrect scheme format.\n 1. Must only contain digits, lowercase ASCII letters or "-"\n 2. Cannot start or end with "-"\n 3. "-" cannot repeat');INIT.customSchemes.push([scheme,optionalSlashSlash])}
/**
 * Initialize the linkify state machine. Called automatically the first time
 * linkify is called on a string, but may be called manually as well.
 */function init(){
// Initialize scanner state machine and plugins
INIT.scanner=init$2(INIT.customSchemes);for(let i=0;i<INIT.tokenQueue.length;i++)INIT.tokenQueue[i][1]({scanner:INIT.scanner});
// Initialize parser state machine and plugins
INIT.parser=init$1(INIT.scanner.tokens);for(let i=0;i<INIT.pluginQueue.length;i++)INIT.pluginQueue[i][1]({scanner:INIT.scanner,parser:INIT.parser});INIT.initialized=!0}
/**
 * Parse a string into tokens that represent linkable and non-linkable sub-components
 * @param {string} str
 * @return {MultiToken[]} tokens
 */function tokenize(str){return INIT.initialized||init(),run(INIT.parser.start,str,run$1(INIT.scanner.start,str))}
/**
 * Find a list of linkable items in the given string.
 * @param {string} str string to find links in
 * @param {string | Opts} [type] either formatting options or specific type of
 * links to find, e.g., 'url' or 'email'
 * @param {Opts} [opts] formatting options for final output. Cannot be specified
 * if opts already provided in `type` argument
*/function find$2(str,type,opts){if(void 0===type&&(type=null),void 0===opts&&(opts=null),type&&"object"===typeof type){if(opts)throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);opts=type,type=null}const options=new Options(opts),tokens=tokenize(str),filtered=[];for(let i=0;i<tokens.length;i++){const token=tokens[i];!token.isLink||type&&token.t!==type||filtered.push(token.toFormattedObject(options))}return filtered}
/**
 * Is the given string valid linkable text of some sort. Note that this does not
 * trim the text for you.
 *
 * Optionally pass in a second `type` param, which is the type of link to test
 * for.
 *
 * For example,
 *
 *     linkify.test(str, 'email');
 *
 * Returns `true` if str is a valid email.
 * @param {string} str string to test for links
 * @param {string} [type] optional specific link type to look for
 * @returns boolean true/false
 */function test(str,type){void 0===type&&(type=null);const tokens=tokenize(str);return 1===tokens.length&&tokens[0].isLink&&(!type||tokens[0].t===type)}function autolink(options){return new Plugin({key:new PluginKey("autolink"),appendTransaction:(transactions,oldState,newState)=>{const docChanges=transactions.some((transaction=>transaction.docChanged))&&!oldState.doc.eq(newState.doc),preventAutolink=transactions.some((transaction=>transaction.getMeta("preventAutolink")));if(!docChanges||preventAutolink)return;const{tr:tr}=newState,transform=combineTransactionSteps(oldState.doc,[...transactions]),{mapping:mapping}=transform,changes=getChangedRanges(transform);return changes.forEach((({oldRange:oldRange,newRange:newRange})=>{
// at first we check if we have to remove links
getMarksBetween(oldRange.from,oldRange.to,oldState.doc).filter((item=>item.mark.type===options.type)).forEach((oldMark=>{const newFrom=mapping.map(oldMark.from),newTo=mapping.map(oldMark.to),newMarks=getMarksBetween(newFrom,newTo,newState.doc).filter((item=>item.mark.type===options.type));if(!newMarks.length)return;const newMark=newMarks[0],oldLinkText=oldState.doc.textBetween(oldMark.from,oldMark.to,void 0," "),newLinkText=newState.doc.textBetween(newMark.from,newMark.to,void 0," "),wasLink=test(oldLinkText),isLink=test(newLinkText);
// remove only the link, if it was a link before too
// because we don’t want to remove links that were set manually
wasLink&&!isLink&&tr.removeMark(newMark.from,newMark.to,options.type)}));
// now let’s see if we can add new links
const nodesInChangedRanges=findChildrenInRange(newState.doc,newRange,(node=>node.isTextblock));let textBlock,textBeforeWhitespace;if(nodesInChangedRanges.length>1?(
// Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter)
textBlock=nodesInChangedRanges[0],textBeforeWhitespace=newState.doc.textBetween(textBlock.pos,textBlock.pos+textBlock.node.nodeSize,void 0," ")):nodesInChangedRanges.length&&newState.doc.textBetween(newRange.from,newRange.to," "," ").endsWith(" ")&&(textBlock=nodesInChangedRanges[0],textBeforeWhitespace=newState.doc.textBetween(textBlock.pos,newRange.to,void 0," ")),textBlock&&textBeforeWhitespace){const wordsBeforeWhitespace=textBeforeWhitespace.split(" ").filter((s=>""!==s));if(wordsBeforeWhitespace.length<=0)return!1;const lastWordBeforeSpace=wordsBeforeWhitespace[wordsBeforeWhitespace.length-1],lastWordAndBlockOffset=textBlock.pos+textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);if(!lastWordBeforeSpace)return!1;find$2(lastWordBeforeSpace).filter((link=>link.isLink)).filter((link=>!options.validate||options.validate(link.value))).map((link=>({...link,from:lastWordAndBlockOffset+link.start+1,to:lastWordAndBlockOffset+link.end+1})
// add link mark
)).forEach((link=>{tr.addMark(link.from,link.to,options.type.create({href:link.href}))}))}})),tr.steps.length?tr:void 0}})}function clickHandler(options){return new Plugin({key:new PluginKey("handleClickLink"),props:{handleClick:(view,pos,event)=>{var _a,_b,_c;if(0!==event.button)return!1;const attrs=getAttributes(view.state,options.type.name),link=null===(_a=event.target)||void 0===_a?void 0:_a.closest("a"),href=null!==(_b=null===link||void 0===link?void 0:link.href)&&void 0!==_b?_b:attrs.href,target=null!==(_c=null===link||void 0===link?void 0:link.target)&&void 0!==_c?_c:attrs.target;return!(!link||!href)&&(window.open(href,target),!0)}}})}function pasteHandler(options){return new Plugin({key:new PluginKey("handlePasteLink"),props:{handlePaste:(view,event,slice)=>{const{state:state}=view,{selection:selection}=state,{empty:empty}=selection;if(empty)return!1;let textContent="";slice.content.forEach((node=>{textContent+=node.textContent}));const link=find$2(textContent).find((item=>item.isLink&&item.value===textContent));return!(!textContent||!link)&&(options.editor.commands.setMark(options.type,{href:link.href}),!0)}}})}const Link$1=Mark.create({name:"link",priority:1e3,keepOnSplit:!1,onCreate(){this.options.protocols.forEach((protocol=>{"string"!==typeof protocol?registerCustomProtocol(protocol.scheme,protocol.optionalSlashes):registerCustomProtocol(protocol)}))},onDestroy(){forms_reset()},inclusive(){return this.options.autolink},addOptions(){return{openOnClick:!0,linkOnPaste:!0,autolink:!0,protocols:[],HTMLAttributes:{target:"_blank",rel:"noopener noreferrer nofollow",class:null},validate:void 0}},addAttributes(){return{href:{default:null},target:{default:this.options.HTMLAttributes.target},class:{default:this.options.HTMLAttributes.class}}},parseHTML(){return[{tag:'a[href]:not([href *= "javascript:" i])'}]},renderHTML({HTMLAttributes:HTMLAttributes}){return["a",mergeAttributes(this.options.HTMLAttributes,HTMLAttributes),0]},addCommands(){return{setLink:attributes=>({chain:chain})=>chain().setMark(this.name,attributes).setMeta("preventAutolink",!0).run(),toggleLink:attributes=>({chain:chain})=>chain().toggleMark(this.name,attributes,{extendEmptyMarkRange:!0}).setMeta("preventAutolink",!0).run(),unsetLink:()=>({chain:chain})=>chain().unsetMark(this.name,{extendEmptyMarkRange:!0}).setMeta("preventAutolink",!0).run()}},addPasteRules(){return[markPasteRule({find:text=>find$2(text).filter((link=>!this.options.validate||this.options.validate(link.value))).filter((link=>link.isLink)).map((link=>({text:link.value,index:link.start,data:link}))),type:this.type,getAttributes:match=>{var _a;return{href:null===(_a=match.data)||void 0===_a?void 0:_a.href}}})]},addProseMirrorPlugins(){const plugins=[];return this.options.autolink&&plugins.push(autolink({type:this.type,validate:this.options.validate})),this.options.openOnClick&&plugins.push(clickHandler({type:this.type})),this.options.linkOnPaste&&plugins.push(pasteHandler({editor:this.editor,type:this.type})),plugins}});var Link=Link$1.extend({addAttributes(){return{href:{default:null},target:{default:this.options.HTMLAttributes.target},style:{default:null}}}});const applyIndent=direction=>()=>({tr:tr,state:state,dispatch:dispatch})=>{const{selection:selection}=state;return tr=tr.setSelection(selection),tr=updateIndentLevel(tr,direction),!!tr.docChanged&&(dispatch?.(tr),!0)},updateIndentLevel=(tr,delta)=>{const{doc:doc,selection:selection}=tr;if(doc&&selection&&(selection instanceof TextSelection||selection instanceof AllSelection)){const{from:from,to:to}=selection;doc.nodesBetween(from,to,((node,pos)=>!options.types.includes(node.type.name)||(tr=setNodeIndentMarkup(tr,pos,delta),!1)))}return tr},setNodeIndentMarkup=(tr,pos,delta)=>{const node=tr?.doc?.nodeAt(pos);if(node){const nextLevel=(node.attrs.indent||0)+delta,{minLevel:minLevel,maxLevel:maxLevel}=options,indent=nextLevel<minLevel?minLevel:nextLevel>maxLevel?maxLevel:nextLevel;if(indent!==node.attrs.indent){const{indent:oldIndent,...currentAttrs}=node.attrs,nodeAttrs=indent>minLevel?{...currentAttrs,indent:indent}:currentAttrs;return tr.setNodeMarkup(pos,node.type,nodeAttrs,node.marks)}}return tr},options={types:["listItem","paragraph"],minLevel:0,maxLevel:8},Indent=Extension.create({name:"indent",defaultOptions:options,addGlobalAttributes(){return[{types:options.types,attributes:{indent:{renderHTML:attributes=>attributes?.indent>options.minLevel?{"data-indent":attributes.indent,class:"indentMore",style:`margin-left: ${40*attributes.indent}px`}:null,parseHTML:element=>{const level=Number(element.getAttribute("data-indent"));return level&&level>options.minLevel?level:null}}}}]},addCommands(){return{indent:applyIndent(1),outdent:applyIndent(-1)}},addKeyboardShortcuts(){return{Tab:()=>this.editor.commands.indent(),"Shift-Tab":()=>this.editor.commands.outdent()}}});function _typeof(obj){return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof(obj)}function _toPrimitive(input,hint){if("object"!==_typeof(input)||null===input)return input;var prim=input[Symbol.toPrimitive];if(void 0!==prim){var res=prim.call(input,hint||"default");if("object"!==_typeof(res))return res;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===hint?String:Number)(input)}function _toPropertyKey(arg){var key=_toPrimitive(arg,"string");return"symbol"===_typeof(key)?key:String(key)}function _defineProperty$1(obj,key,value){return key=_toPropertyKey(key),key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,_toPropertyKey(descriptor.key),descriptor)}}function _createClass(Constructor,protoProps,staticProps){return protoProps&&_defineProperties(Constructor.prototype,protoProps),staticProps&&_defineProperties(Constructor,staticProps),Object.defineProperty(Constructor,"prototype",{writable:!1}),Constructor}
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */var isBrowser$2="undefined"!==typeof window&&"undefined"!==typeof document&&"undefined"!==typeof navigator,timeoutDuration$1=function(){for(var longerTimeoutBrowsers=["Edge","Trident","Firefox"],i=0;i<longerTimeoutBrowsers.length;i+=1)if(isBrowser$2&&navigator.userAgent.indexOf(longerTimeoutBrowsers[i])>=0)return 1;return 0}();function microtaskDebounce$1(fn){var called=!1;return function(){called||(called=!0,window.Promise.resolve().then((function(){called=!1,fn()})))}}function taskDebounce$1(fn){var scheduled=!1;return function(){scheduled||(scheduled=!0,setTimeout((function(){scheduled=!1,fn()}),timeoutDuration$1))}}var supportsMicroTasks$1=isBrowser$2&&window.Promise,debounce$2=supportsMicroTasks$1?microtaskDebounce$1:taskDebounce$1;
/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction$1(functionToCheck){var getType={};return functionToCheck&&"[object Function]"===getType.toString.call(functionToCheck)}
/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */function getStyleComputedProperty$1(element,property){if(1!==element.nodeType)return[];
// NOTE: 1 DOM access here
var window=element.ownerDocument.defaultView,css=window.getComputedStyle(element,null);return property?css[property]:css}
/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */function getParentNode$1(element){return"HTML"===element.nodeName?element:element.parentNode||element.host}
/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */function getScrollParent$1(element){
// Return body, `getScroll` will take care to get the correct `scrollTop` from it
if(!element)return document.body;switch(element.nodeName){case"HTML":case"BODY":return element.ownerDocument.body;case"#document":return element.body}
// Firefox want us to check `-x` and `-y` variations as well
var _getStyleComputedProp=getStyleComputedProperty$1(element),overflow=_getStyleComputedProp.overflow,overflowX=_getStyleComputedProp.overflowX,overflowY=_getStyleComputedProp.overflowY;return/(auto|scroll|overlay)/.test(overflow+overflowY+overflowX)?element:getScrollParent$1(getParentNode$1(element))}
/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */function getReferenceNode$1(reference){return reference&&reference.referenceNode?reference.referenceNode:reference}var isIE11$1=isBrowser$2&&!(!window.MSInputMethodContext||!document.documentMode),isIE10$1=isBrowser$2&&/MSIE 10/.test(navigator.userAgent);
/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE$3(version){return 11===version?isIE11$1:10===version?isIE10$1:isIE11$1||isIE10$1}
/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */function getOffsetParent$1(element){if(!element)return document.documentElement;var noOffsetParent=isIE$3(10)?document.body:null,offsetParent=element.offsetParent||null;
// NOTE: 1 DOM access here
// Skip hidden elements which don't have an offsetParent
while(offsetParent===noOffsetParent&&element.nextElementSibling)offsetParent=(element=element.nextElementSibling).offsetParent;var nodeName=offsetParent&&offsetParent.nodeName;return nodeName&&"BODY"!==nodeName&&"HTML"!==nodeName?
// .offsetParent will return the closest TH, TD or TABLE in case
// no offsetParent is present, I hate this job...
-1!==["TH","TD","TABLE"].indexOf(offsetParent.nodeName)&&"static"===getStyleComputedProperty$1(offsetParent,"position")?getOffsetParent$1(offsetParent):offsetParent:element?element.ownerDocument.documentElement:document.documentElement}function isOffsetContainer$1(element){var nodeName=element.nodeName;return"BODY"!==nodeName&&("HTML"===nodeName||getOffsetParent$1(element.firstElementChild)===element)}
/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */function getRoot$1(node){return null!==node.parentNode?getRoot$1(node.parentNode):node}
/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */function findCommonOffsetParent$1(element1,element2){
// This check is needed to avoid errors in case one of the elements isn't defined for any reason
if(!element1||!element1.nodeType||!element2||!element2.nodeType)return document.documentElement;
// Here we make sure to give as "start" the element that comes first in the DOM
var order=element1.compareDocumentPosition(element2)&Node.DOCUMENT_POSITION_FOLLOWING,start=order?element1:element2,end=order?element2:element1,range=document.createRange();range.setStart(start,0),range.setEnd(end,0);var commonAncestorContainer=range.commonAncestorContainer;
// Both nodes are inside #document
if(element1!==commonAncestorContainer&&element2!==commonAncestorContainer||start.contains(end))return isOffsetContainer$1(commonAncestorContainer)?commonAncestorContainer:getOffsetParent$1(commonAncestorContainer);
// one of the nodes is inside shadowDOM, find which one
var element1root=getRoot$1(element1);return element1root.host?findCommonOffsetParent$1(element1root.host,element2):findCommonOffsetParent$1(element1,getRoot$1(element2).host)}
/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */function getScroll$1(element){var side=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"top",upperSide="top"===side?"scrollTop":"scrollLeft",nodeName=element.nodeName;if("BODY"===nodeName||"HTML"===nodeName){var html=element.ownerDocument.documentElement,scrollingElement=element.ownerDocument.scrollingElement||html;return scrollingElement[upperSide]}return element[upperSide]}
/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */function includeScroll$1(rect,element){var subtract=arguments.length>2&&void 0!==arguments[2]&&arguments[2],scrollTop=getScroll$1(element,"top"),scrollLeft=getScroll$1(element,"left"),modifier=subtract?-1:1;return rect.top+=scrollTop*modifier,rect.bottom+=scrollTop*modifier,rect.left+=scrollLeft*modifier,rect.right+=scrollLeft*modifier,rect}
/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */function getBordersSize$1(styles,axis){var sideA="x"===axis?"Left":"Top",sideB="Left"===sideA?"Right":"Bottom";return parseFloat(styles["border"+sideA+"Width"])+parseFloat(styles["border"+sideB+"Width"])}function getSize$1(axis,body,html,computedStyle){return Math.max(body["offset"+axis],body["scroll"+axis],html["client"+axis],html["offset"+axis],html["scroll"+axis],isIE$3(10)?parseInt(html["offset"+axis])+parseInt(computedStyle["margin"+("Height"===axis?"Top":"Left")])+parseInt(computedStyle["margin"+("Height"===axis?"Bottom":"Right")]):0)}function getWindowSizes$1(document){var body=document.body,html=document.documentElement,computedStyle=isIE$3(10)&&getComputedStyle(html);return{height:getSize$1("Height",body,html,computedStyle),width:getSize$1("Width",body,html,computedStyle)}}var classCallCheck$1=function(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")},createClass$1=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),defineProperty$1=function(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj},_extends$2=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target};
/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect$1(offsets){return _extends$2({},offsets,{right:offsets.left+offsets.width,bottom:offsets.top+offsets.height})}
/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */function getBoundingClientRect$1(element){var rect={};
// IE10 10 FIX: Please, don't ask, the element isn't
// considered in DOM in some circumstances...
// This isn't reproducible in IE10 compatibility mode of IE11
try{if(isIE$3(10)){rect=element.getBoundingClientRect();var scrollTop=getScroll$1(element,"top"),scrollLeft=getScroll$1(element,"left");rect.top+=scrollTop,rect.left+=scrollLeft,rect.bottom+=scrollTop,rect.right+=scrollLeft}else rect=element.getBoundingClientRect()}catch(e){}var result={left:rect.left,top:rect.top,width:rect.right-rect.left,height:rect.bottom-rect.top},sizes="HTML"===element.nodeName?getWindowSizes$1(element.ownerDocument):{},width=sizes.width||element.clientWidth||result.width,height=sizes.height||element.clientHeight||result.height,horizScrollbar=element.offsetWidth-width,vertScrollbar=element.offsetHeight-height;
// subtract scrollbar size from sizes
// if an hypothetical scrollbar is detected, we must be sure it's not a `border`
// we make this check conditional for performance reasons
if(horizScrollbar||vertScrollbar){var styles=getStyleComputedProperty$1(element);horizScrollbar-=getBordersSize$1(styles,"x"),vertScrollbar-=getBordersSize$1(styles,"y"),result.width-=horizScrollbar,result.height-=vertScrollbar}return getClientRect$1(result)}function getOffsetRectRelativeToArbitraryNode$1(children,parent){var fixedPosition=arguments.length>2&&void 0!==arguments[2]&&arguments[2],isIE10=isIE$3(10),isHTML="HTML"===parent.nodeName,childrenRect=getBoundingClientRect$1(children),parentRect=getBoundingClientRect$1(parent),scrollParent=getScrollParent$1(children),styles=getStyleComputedProperty$1(parent),borderTopWidth=parseFloat(styles.borderTopWidth),borderLeftWidth=parseFloat(styles.borderLeftWidth);
// In cases where the parent is fixed, we must ignore negative scroll in offset calc
fixedPosition&&isHTML&&(parentRect.top=Math.max(parentRect.top,0),parentRect.left=Math.max(parentRect.left,0));var offsets=getClientRect$1({top:childrenRect.top-parentRect.top-borderTopWidth,left:childrenRect.left-parentRect.left-borderLeftWidth,width:childrenRect.width,height:childrenRect.height});
// Subtract margins of documentElement in case it's being used as parent
// we do this only on HTML because it's the only element that behaves
// differently when margins are applied to it. The margins are included in
// the box of the documentElement, in the other cases not.
if(offsets.marginTop=0,offsets.marginLeft=0,!isIE10&&isHTML){var marginTop=parseFloat(styles.marginTop),marginLeft=parseFloat(styles.marginLeft);offsets.top-=borderTopWidth-marginTop,offsets.bottom-=borderTopWidth-marginTop,offsets.left-=borderLeftWidth-marginLeft,offsets.right-=borderLeftWidth-marginLeft,
// Attach marginTop and marginLeft because in some circumstances we may need them
offsets.marginTop=marginTop,offsets.marginLeft=marginLeft}return(isIE10&&!fixedPosition?parent.contains(scrollParent):parent===scrollParent&&"BODY"!==scrollParent.nodeName)&&(offsets=includeScroll$1(offsets,parent)),offsets}function getViewportOffsetRectRelativeToArtbitraryNode$1(element){var excludeScroll=arguments.length>1&&void 0!==arguments[1]&&arguments[1],html=element.ownerDocument.documentElement,relativeOffset=getOffsetRectRelativeToArbitraryNode$1(element,html),width=Math.max(html.clientWidth,window.innerWidth||0),height=Math.max(html.clientHeight,window.innerHeight||0),scrollTop=excludeScroll?0:getScroll$1(html),scrollLeft=excludeScroll?0:getScroll$1(html,"left"),offset={top:scrollTop-relativeOffset.top+relativeOffset.marginTop,left:scrollLeft-relativeOffset.left+relativeOffset.marginLeft,width:width,height:height};return getClientRect$1(offset)}
/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */function isFixed$1(element){var nodeName=element.nodeName;if("BODY"===nodeName||"HTML"===nodeName)return!1;if("fixed"===getStyleComputedProperty$1(element,"position"))return!0;var parentNode=getParentNode$1(element);return!!parentNode&&isFixed$1(parentNode)}
/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */function getFixedPositionOffsetParent$1(element){
// This check is needed to avoid errors in case one of the elements isn't defined for any reason
if(!element||!element.parentElement||isIE$3())return document.documentElement;var el=element.parentElement;while(el&&"none"===getStyleComputedProperty$1(el,"transform"))el=el.parentElement;return el||document.documentElement}
/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */function getBoundaries$1(popper,reference,padding,boundariesElement){var fixedPosition=arguments.length>4&&void 0!==arguments[4]&&arguments[4],boundaries={top:0,left:0},offsetParent=fixedPosition?getFixedPositionOffsetParent$1(popper):findCommonOffsetParent$1(popper,getReferenceNode$1(reference));
// NOTE: 1 DOM access here
// Handle viewport case
if("viewport"===boundariesElement)boundaries=getViewportOffsetRectRelativeToArtbitraryNode$1(offsetParent,fixedPosition);else{
// Handle other cases based on DOM element used as boundaries
var boundariesNode=void 0;"scrollParent"===boundariesElement?(boundariesNode=getScrollParent$1(getParentNode$1(reference)),"BODY"===boundariesNode.nodeName&&(boundariesNode=popper.ownerDocument.documentElement)):boundariesNode="window"===boundariesElement?popper.ownerDocument.documentElement:boundariesElement;var offsets=getOffsetRectRelativeToArbitraryNode$1(boundariesNode,offsetParent,fixedPosition);
// In case of HTML, we need a different computation
if("HTML"!==boundariesNode.nodeName||isFixed$1(offsetParent))
// for all the other DOM elements, this one is good
boundaries=offsets;else{var _getWindowSizes=getWindowSizes$1(popper.ownerDocument),height=_getWindowSizes.height,width=_getWindowSizes.width;boundaries.top+=offsets.top-offsets.marginTop,boundaries.bottom=height+offsets.top,boundaries.left+=offsets.left-offsets.marginLeft,boundaries.right=width+offsets.left}}
// Add paddings
padding=padding||0;var isPaddingNumber="number"===typeof padding;return boundaries.left+=isPaddingNumber?padding:padding.left||0,boundaries.top+=isPaddingNumber?padding:padding.top||0,boundaries.right-=isPaddingNumber?padding:padding.right||0,boundaries.bottom-=isPaddingNumber?padding:padding.bottom||0,boundaries}function getArea$1(_ref){var width=_ref.width,height=_ref.height;return width*height}
/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function computeAutoPlacement$1(placement,refRect,popper,reference,boundariesElement){var padding=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(-1===placement.indexOf("auto"))return placement;var boundaries=getBoundaries$1(popper,reference,padding,boundariesElement),rects={top:{width:boundaries.width,height:refRect.top-boundaries.top},right:{width:boundaries.right-refRect.right,height:boundaries.height},bottom:{width:boundaries.width,height:boundaries.bottom-refRect.bottom},left:{width:refRect.left-boundaries.left,height:boundaries.height}},sortedAreas=Object.keys(rects).map((function(key){return _extends$2({key:key},rects[key],{area:getArea$1(rects[key])})})).sort((function(a,b){return b.area-a.area})),filteredAreas=sortedAreas.filter((function(_ref2){var width=_ref2.width,height=_ref2.height;return width>=popper.clientWidth&&height>=popper.clientHeight})),computedPlacement=filteredAreas.length>0?filteredAreas[0].key:sortedAreas[0].key,variation=placement.split("-")[1];return computedPlacement+(variation?"-"+variation:"")}
/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */function getReferenceOffsets$1(state,popper,reference){var fixedPosition=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,commonOffsetParent=fixedPosition?getFixedPositionOffsetParent$1(popper):findCommonOffsetParent$1(popper,getReferenceNode$1(reference));return getOffsetRectRelativeToArbitraryNode$1(reference,commonOffsetParent,fixedPosition)}
/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */function getOuterSizes$1(element){var window=element.ownerDocument.defaultView,styles=window.getComputedStyle(element),x=parseFloat(styles.marginTop||0)+parseFloat(styles.marginBottom||0),y=parseFloat(styles.marginLeft||0)+parseFloat(styles.marginRight||0),result={width:element.offsetWidth+y,height:element.offsetHeight+x};return result}
/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */function getOppositePlacement$1(placement){var hash={left:"right",right:"left",bottom:"top",top:"bottom"};return placement.replace(/left|right|bottom|top/g,(function(matched){return hash[matched]}))}
/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */function getPopperOffsets$1(popper,referenceOffsets,placement){placement=placement.split("-")[0];
// Get popper node sizes
var popperRect=getOuterSizes$1(popper),popperOffsets={width:popperRect.width,height:popperRect.height},isHoriz=-1!==["right","left"].indexOf(placement),mainSide=isHoriz?"top":"left",secondarySide=isHoriz?"left":"top",measurement=isHoriz?"height":"width",secondaryMeasurement=isHoriz?"width":"height";
// Add position, width and height to our offsets object
return popperOffsets[mainSide]=referenceOffsets[mainSide]+referenceOffsets[measurement]/2-popperRect[measurement]/2,popperOffsets[secondarySide]=placement===secondarySide?referenceOffsets[secondarySide]-popperRect[secondaryMeasurement]:referenceOffsets[getOppositePlacement$1(secondarySide)],popperOffsets}
/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */function find$1(arr,check){
// use native find if supported
return Array.prototype.find?arr.find(check):arr.filter(check)[0];
// use `filter` to obtain the same behavior of `find`
}
/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */function findIndex$1(arr,prop,value){
// use native findIndex if supported
if(Array.prototype.findIndex)return arr.findIndex((function(cur){return cur[prop]===value}));
// use `find` + `indexOf` if `findIndex` isn't supported
var match=find$1(arr,(function(obj){return obj[prop]===value}));return arr.indexOf(match)}
/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */function runModifiers$1(modifiers,data,ends){var modifiersToRun=void 0===ends?modifiers:modifiers.slice(0,findIndex$1(modifiers,"name",ends));return modifiersToRun.forEach((function(modifier){modifier["function"];var fn=modifier["function"]||modifier.fn;// eslint-disable-line dot-notation
modifier.enabled&&isFunction$1(fn)&&(
// Add properties to offsets to make them a complete clientRect object
// we do this before each modifier to make sure the previous one doesn't
// mess with these values
data.offsets.popper=getClientRect$1(data.offsets.popper),data.offsets.reference=getClientRect$1(data.offsets.reference),data=fn(data,modifier))})),data}
/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */function update$1(){
// if popper is destroyed, don't perform any further update
if(!this.state.isDestroyed){var data={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};
// compute reference element offsets
data.offsets.reference=getReferenceOffsets$1(this.state,this.popper,this.reference,this.options.positionFixed),
// compute auto placement, store placement inside the data object,
// modifiers will be able to edit `placement` if needed
// and refer to originalPlacement to know the original value
data.placement=computeAutoPlacement$1(this.options.placement,data.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),
// store the computed placement inside `originalPlacement`
data.originalPlacement=data.placement,data.positionFixed=this.options.positionFixed,
// compute the popper offsets
data.offsets.popper=getPopperOffsets$1(this.popper,data.offsets.reference,data.placement),data.offsets.popper.position=this.options.positionFixed?"fixed":"absolute",
// run the modifiers
data=runModifiers$1(this.modifiers,data),
// the first `update` will call `onCreate` callback
// the other ones will call `onUpdate` callback
this.state.isCreated?this.options.onUpdate(data):(this.state.isCreated=!0,this.options.onCreate(data))}}
/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */function isModifierEnabled$1(modifiers,modifierName){return modifiers.some((function(_ref){var name=_ref.name,enabled=_ref.enabled;return enabled&&name===modifierName}))}
/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */function getSupportedPropertyName$1(property){for(var prefixes=[!1,"ms","Webkit","Moz","O"],upperProp=property.charAt(0).toUpperCase()+property.slice(1),i=0;i<prefixes.length;i++){var prefix=prefixes[i],toCheck=prefix?""+prefix+upperProp:property;if("undefined"!==typeof document.body.style[toCheck])return toCheck}return null}
/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */function destroy$1(){return this.state.isDestroyed=!0,
// touch DOM only if `applyStyle` modifier is enabled
isModifierEnabled$1(this.modifiers,"applyStyle")&&(this.popper.removeAttribute("x-placement"),this.popper.style.position="",this.popper.style.top="",this.popper.style.left="",this.popper.style.right="",this.popper.style.bottom="",this.popper.style.willChange="",this.popper.style[getSupportedPropertyName$1("transform")]=""),this.disableEventListeners(),
// remove the popper if user explicitly asked for the deletion on destroy
// do not use `remove` because IE11 doesn't support it
this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}
/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */function getWindow$1(element){var ownerDocument=element.ownerDocument;return ownerDocument?ownerDocument.defaultView:window}function attachToScrollParents$1(scrollParent,event,callback,scrollParents){var isBody="BODY"===scrollParent.nodeName,target=isBody?scrollParent.ownerDocument.defaultView:scrollParent;target.addEventListener(event,callback,{passive:!0}),isBody||attachToScrollParents$1(getScrollParent$1(target.parentNode),event,callback,scrollParents),scrollParents.push(target)}
/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */function setupEventListeners$1(reference,options,state,updateBound){
// Resize event listener on window
state.updateBound=updateBound,getWindow$1(reference).addEventListener("resize",state.updateBound,{passive:!0});
// Scroll event listener on scroll parents
var scrollElement=getScrollParent$1(reference);return attachToScrollParents$1(scrollElement,"scroll",state.updateBound,state.scrollParents),state.scrollElement=scrollElement,state.eventsEnabled=!0,state}
/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */function enableEventListeners$1(){this.state.eventsEnabled||(this.state=setupEventListeners$1(this.reference,this.options,this.state,this.scheduleUpdate))}
/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */function removeEventListeners$1(reference,state){
// Remove resize event listener on window
return getWindow$1(reference).removeEventListener("resize",state.updateBound),
// Remove scroll event listener on scroll parents
state.scrollParents.forEach((function(target){target.removeEventListener("scroll",state.updateBound)})),
// Reset state
state.updateBound=null,state.scrollParents=[],state.scrollElement=null,state.eventsEnabled=!1,state}
/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */function disableEventListeners$1(){this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=removeEventListeners$1(this.reference,this.state))}
/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */function isNumeric$1(n){return""!==n&&!isNaN(parseFloat(n))&&isFinite(n)}
/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */function setStyles$1(element,styles){Object.keys(styles).forEach((function(prop){var unit="";
// add unit if the value is numeric and is one of the following
-1!==["width","height","top","right","bottom","left"].indexOf(prop)&&isNumeric$1(styles[prop])&&(unit="px"),element.style[prop]=styles[prop]+unit}))}
/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */function setAttributes$1(element,attributes){Object.keys(attributes).forEach((function(prop){var value=attributes[prop];!1!==value?element.setAttribute(prop,attributes[prop]):element.removeAttribute(prop)}))}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */function applyStyle$1(data){
// any property present in `data.styles` will be applied to the popper,
// in this way we can make the 3rd party modifiers add custom styles to it
// Be aware, modifiers could override the properties defined in the previous
// lines of this modifier!
return setStyles$1(data.instance.popper,data.styles),
// any property present in `data.attributes` will be applied to the popper,
// they will be set as HTML attributes of the element
setAttributes$1(data.instance.popper,data.attributes),
// if arrowElement is defined and arrowStyles has some properties
data.arrowElement&&Object.keys(data.arrowStyles).length&&setStyles$1(data.arrowElement,data.arrowStyles),data}
/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */function applyStyleOnLoad$1(reference,popper,options,modifierOptions,state){
// compute reference element offsets
var referenceOffsets=getReferenceOffsets$1(state,popper,reference,options.positionFixed),placement=computeAutoPlacement$1(options.placement,referenceOffsets,popper,reference,options.modifiers.flip.boundariesElement,options.modifiers.flip.padding);
// compute auto placement, store placement inside the data object,
// modifiers will be able to edit `placement` if needed
// and refer to originalPlacement to know the original value
return popper.setAttribute("x-placement",placement),
// Apply `position` to popper before anything else because
// without the position applied we can't guarantee correct computations
setStyles$1(popper,{position:options.positionFixed?"fixed":"absolute"}),options}
/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */function getRoundedOffsets$1(data,shouldRound){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,round=Math.round,floor=Math.floor,noRound=function(v){return v},referenceWidth=round(reference.width),popperWidth=round(popper.width),isVertical=-1!==["left","right"].indexOf(data.placement),isVariation=-1!==data.placement.indexOf("-"),sameWidthParity=referenceWidth%2===popperWidth%2,bothOddWidth=referenceWidth%2===1&&popperWidth%2===1,horizontalToInteger=shouldRound?isVertical||isVariation||sameWidthParity?round:floor:noRound,verticalToInteger=shouldRound?round:noRound;return{left:horizontalToInteger(bothOddWidth&&!isVariation&&shouldRound?popper.left-1:popper.left),top:verticalToInteger(popper.top),bottom:verticalToInteger(popper.bottom),right:horizontalToInteger(popper.right)}}var isFirefox$1=isBrowser$2&&/Firefox/i.test(navigator.userAgent);
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function computeStyle$1(data,options){var x=options.x,y=options.y,popper=data.offsets.popper,legacyGpuAccelerationOption=find$1(data.instance.modifiers,(function(modifier){return"applyStyle"===modifier.name})).gpuAcceleration,gpuAcceleration=void 0!==legacyGpuAccelerationOption?legacyGpuAccelerationOption:options.gpuAcceleration,offsetParent=getOffsetParent$1(data.instance.popper),offsetParentRect=getBoundingClientRect$1(offsetParent),styles={position:popper.position},offsets=getRoundedOffsets$1(data,window.devicePixelRatio<2||!isFirefox$1),sideA="bottom"===x?"top":"bottom",sideB="right"===y?"left":"right",prefixedProperty=getSupportedPropertyName$1("transform"),left=void 0,top=void 0;if(top="bottom"===sideA?
// when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
// and not the bottom of the html element
"HTML"===offsetParent.nodeName?-offsetParent.clientHeight+offsets.bottom:-offsetParentRect.height+offsets.bottom:offsets.top,left="right"===sideB?"HTML"===offsetParent.nodeName?-offsetParent.clientWidth+offsets.right:-offsetParentRect.width+offsets.right:offsets.left,gpuAcceleration&&prefixedProperty)styles[prefixedProperty]="translate3d("+left+"px, "+top+"px, 0)",styles[sideA]=0,styles[sideB]=0,styles.willChange="transform";else{
// othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
var invertTop="bottom"===sideA?-1:1,invertLeft="right"===sideB?-1:1;styles[sideA]=top*invertTop,styles[sideB]=left*invertLeft,styles.willChange=sideA+", "+sideB}
// Attributes
var attributes={"x-placement":data.placement};
// Update `data` attributes, styles and arrowStyles
return data.attributes=_extends$2({},attributes,data.attributes),data.styles=_extends$2({},styles,data.styles),data.arrowStyles=_extends$2({},data.offsets.arrow,data.arrowStyles),data}
/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */function isModifierRequired$1(modifiers,requestingName,requestedName){var requesting=find$1(modifiers,(function(_ref){var name=_ref.name;return name===requestingName})),isRequired=!!requesting&&modifiers.some((function(modifier){return modifier.name===requestedName&&modifier.enabled&&modifier.order<requesting.order}));if(!isRequired);return isRequired}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function arrow$1(data,options){var _data$offsets$arrow;
// arrow depends on keepTogether in order to work
if(!isModifierRequired$1(data.instance.modifiers,"arrow","keepTogether"))return data;var arrowElement=options.element;
// if arrowElement is a string, suppose it's a CSS selector
if("string"===typeof arrowElement){
// if arrowElement is not found, don't run the modifier
if(arrowElement=data.instance.popper.querySelector(arrowElement),!arrowElement)return data}else
// if the arrowElement isn't a query selector we must check that the
// provided DOM node is child of its popper node
if(!data.instance.popper.contains(arrowElement))return data;var placement=data.placement.split("-")[0],_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,isVertical=-1!==["left","right"].indexOf(placement),len=isVertical?"height":"width",sideCapitalized=isVertical?"Top":"Left",side=sideCapitalized.toLowerCase(),altSide=isVertical?"left":"top",opSide=isVertical?"bottom":"right",arrowElementSize=getOuterSizes$1(arrowElement)[len];
// extends keepTogether behavior making sure the popper and its
// reference have enough pixels in conjunction
// top/left side
reference[opSide]-arrowElementSize<popper[side]&&(data.offsets.popper[side]-=popper[side]-(reference[opSide]-arrowElementSize)),
// bottom/right side
reference[side]+arrowElementSize>popper[opSide]&&(data.offsets.popper[side]+=reference[side]+arrowElementSize-popper[opSide]),data.offsets.popper=getClientRect$1(data.offsets.popper);
// compute center of the popper
var center=reference[side]+reference[len]/2-arrowElementSize/2,css=getStyleComputedProperty$1(data.instance.popper),popperMarginSide=parseFloat(css["margin"+sideCapitalized]),popperBorderSide=parseFloat(css["border"+sideCapitalized+"Width"]),sideValue=center-data.offsets.popper[side]-popperMarginSide-popperBorderSide;
// Compute the sideValue using the updated popper offsets
// take popper margin in account because we don't have this info available
// prevent arrowElement from being placed not contiguously to its popper
return sideValue=Math.max(Math.min(popper[len]-arrowElementSize,sideValue),0),data.arrowElement=arrowElement,data.offsets.arrow=(_data$offsets$arrow={},defineProperty$1(_data$offsets$arrow,side,Math.round(sideValue)),defineProperty$1(_data$offsets$arrow,altSide,""),_data$offsets$arrow),data}
/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */function getOppositeVariation$1(variation){return"end"===variation?"start":"start"===variation?"end":variation}
/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */var placements$1=["auto-start","auto","auto-end","top-start","top","top-end","right-start","right","right-end","bottom-end","bottom","bottom-start","left-end","left","left-start"],validPlacements$1=placements$1.slice(3);
// Get rid of `auto` `auto-start` and `auto-end`
/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise$1(placement){var counter=arguments.length>1&&void 0!==arguments[1]&&arguments[1],index=validPlacements$1.indexOf(placement),arr=validPlacements$1.slice(index+1).concat(validPlacements$1.slice(0,index));return counter?arr.reverse():arr}var BEHAVIORS$1={FLIP:"flip",CLOCKWISE:"clockwise",COUNTERCLOCKWISE:"counterclockwise"};
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function flip$1(data,options){
// if `inner` modifier is enabled, we can't use the `flip` modifier
if(isModifierEnabled$1(data.instance.modifiers,"inner"))return data;if(data.flipped&&data.placement===data.originalPlacement)
// seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
return data;var boundaries=getBoundaries$1(data.instance.popper,data.instance.reference,options.padding,options.boundariesElement,data.positionFixed),placement=data.placement.split("-")[0],placementOpposite=getOppositePlacement$1(placement),variation=data.placement.split("-")[1]||"",flipOrder=[];switch(options.behavior){case BEHAVIORS$1.FLIP:flipOrder=[placement,placementOpposite];break;case BEHAVIORS$1.CLOCKWISE:flipOrder=clockwise$1(placement);break;case BEHAVIORS$1.COUNTERCLOCKWISE:flipOrder=clockwise$1(placement,!0);break;default:flipOrder=options.behavior}return flipOrder.forEach((function(step,index){if(placement!==step||flipOrder.length===index+1)return data;placement=data.placement.split("-")[0],placementOpposite=getOppositePlacement$1(placement);var popperOffsets=data.offsets.popper,refOffsets=data.offsets.reference,floor=Math.floor,overlapsRef="left"===placement&&floor(popperOffsets.right)>floor(refOffsets.left)||"right"===placement&&floor(popperOffsets.left)<floor(refOffsets.right)||"top"===placement&&floor(popperOffsets.bottom)>floor(refOffsets.top)||"bottom"===placement&&floor(popperOffsets.top)<floor(refOffsets.bottom),overflowsLeft=floor(popperOffsets.left)<floor(boundaries.left),overflowsRight=floor(popperOffsets.right)>floor(boundaries.right),overflowsTop=floor(popperOffsets.top)<floor(boundaries.top),overflowsBottom=floor(popperOffsets.bottom)>floor(boundaries.bottom),overflowsBoundaries="left"===placement&&overflowsLeft||"right"===placement&&overflowsRight||"top"===placement&&overflowsTop||"bottom"===placement&&overflowsBottom,isVertical=-1!==["top","bottom"].indexOf(placement),flippedVariationByRef=!!options.flipVariations&&(isVertical&&"start"===variation&&overflowsLeft||isVertical&&"end"===variation&&overflowsRight||!isVertical&&"start"===variation&&overflowsTop||!isVertical&&"end"===variation&&overflowsBottom),flippedVariationByContent=!!options.flipVariationsByContent&&(isVertical&&"start"===variation&&overflowsRight||isVertical&&"end"===variation&&overflowsLeft||!isVertical&&"start"===variation&&overflowsBottom||!isVertical&&"end"===variation&&overflowsTop),flippedVariation=flippedVariationByRef||flippedVariationByContent;(overlapsRef||overflowsBoundaries||flippedVariation)&&(
// this boolean to detect any flip loop
data.flipped=!0,(overlapsRef||overflowsBoundaries)&&(placement=flipOrder[index+1]),flippedVariation&&(variation=getOppositeVariation$1(variation)),data.placement=placement+(variation?"-"+variation:""),
// this object contains `position`, we want to preserve it along with
// any additional property we may add in the future
data.offsets.popper=_extends$2({},data.offsets.popper,getPopperOffsets$1(data.instance.popper,data.offsets.reference,data.placement)),data=runModifiers$1(data.instance.modifiers,data,"flip"))})),data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function keepTogether$1(data){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,placement=data.placement.split("-")[0],floor=Math.floor,isVertical=-1!==["top","bottom"].indexOf(placement),side=isVertical?"right":"bottom",opSide=isVertical?"left":"top",measurement=isVertical?"width":"height";return popper[side]<floor(reference[opSide])&&(data.offsets.popper[opSide]=floor(reference[opSide])-popper[measurement]),popper[opSide]>floor(reference[side])&&(data.offsets.popper[opSide]=floor(reference[side])),data}
/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */function toValue$1(str,measurement,popperOffsets,referenceOffsets){
// separate value from unit
var split=str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),value=+split[1],unit=split[2];
// If it's not a number it's an operator, I guess
if(!value)return str;if(0===unit.indexOf("%")){var element=void 0;switch(unit){case"%p":element=popperOffsets;break;case"%":case"%r":default:element=referenceOffsets}var rect=getClientRect$1(element);return rect[measurement]/100*value}if("vh"===unit||"vw"===unit){
// if is a vh or vw, we calculate the size based on the viewport
var size=void 0;return size="vh"===unit?Math.max(document.documentElement.clientHeight,window.innerHeight||0):Math.max(document.documentElement.clientWidth,window.innerWidth||0),size/100*value}
// if is an explicit pixel unit, we get rid of the unit and keep the value
// if is an implicit unit, it's px, and we return just the value
return value}
/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */function parseOffset$1(offset,popperOffsets,referenceOffsets,basePlacement){var offsets=[0,0],useHeight=-1!==["right","left"].indexOf(basePlacement),fragments=offset.split(/(\+|\-)/).map((function(frag){return frag.trim()})),divider=fragments.indexOf(find$1(fragments,(function(frag){return-1!==frag.search(/,|\s/)})));
// Use height if placement is left or right and index is 0 otherwise use width
// in this way the first offset will use an axis and the second one
// will use the other one
fragments[divider]&&fragments[divider].indexOf(",");
// If divider is found, we divide the list of values and operands to divide
// them by ofset X and Y.
var splitRegex=/\s*,\s*|\s+/,ops=-1!==divider?[fragments.slice(0,divider).concat([fragments[divider].split(splitRegex)[0]]),[fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider+1))]:[fragments];
// Convert the values with units to absolute pixels to allow our computations
return ops=ops.map((function(op,index){
// Most of the units rely on the orientation of the popper
var measurement=(1===index?!useHeight:useHeight)?"height":"width",mergeWithPrevious=!1;return op.reduce((function(a,b){return""===a[a.length-1]&&-1!==["+","-"].indexOf(b)?(a[a.length-1]=b,mergeWithPrevious=!0,a):mergeWithPrevious?(a[a.length-1]+=b,mergeWithPrevious=!1,a):a.concat(b)}),[]).map((function(str){return toValue$1(str,measurement,popperOffsets,referenceOffsets)}))})),
// Loop trough the offsets arrays and execute the operations
ops.forEach((function(op,index){op.forEach((function(frag,index2){isNumeric$1(frag)&&(offsets[index]+=frag*("-"===op[index2-1]?-1:1))}))})),offsets}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */function offset$1(data,_ref){var offset=_ref.offset,placement=data.placement,_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,basePlacement=placement.split("-")[0],offsets=void 0;return offsets=isNumeric$1(+offset)?[+offset,0]:parseOffset$1(offset,popper,reference,basePlacement),"left"===basePlacement?(popper.top+=offsets[0],popper.left-=offsets[1]):"right"===basePlacement?(popper.top+=offsets[0],popper.left+=offsets[1]):"top"===basePlacement?(popper.left+=offsets[0],popper.top-=offsets[1]):"bottom"===basePlacement&&(popper.left+=offsets[0],popper.top+=offsets[1]),data.popper=popper,data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function preventOverflow$1(data,options){var boundariesElement=options.boundariesElement||getOffsetParent$1(data.instance.popper);
// If offsetParent is the reference element, we really want to
// go one step up and use the next offsetParent as reference to
// avoid to make this modifier completely useless and look like broken
data.instance.reference===boundariesElement&&(boundariesElement=getOffsetParent$1(boundariesElement));
// NOTE: DOM access here
// resets the popper's position so that the document size can be calculated excluding
// the size of the popper element itself
var transformProp=getSupportedPropertyName$1("transform"),popperStyles=data.instance.popper.style,top=popperStyles.top,left=popperStyles.left,transform=popperStyles[transformProp];popperStyles.top="",popperStyles.left="",popperStyles[transformProp]="";var boundaries=getBoundaries$1(data.instance.popper,data.instance.reference,options.padding,boundariesElement,data.positionFixed);
// NOTE: DOM access here
// restores the original style properties after the offsets have been computed
popperStyles.top=top,popperStyles.left=left,popperStyles[transformProp]=transform,options.boundaries=boundaries;var order=options.priority,popper=data.offsets.popper,check={primary:function(placement){var value=popper[placement];return popper[placement]<boundaries[placement]&&!options.escapeWithReference&&(value=Math.max(popper[placement],boundaries[placement])),defineProperty$1({},placement,value)},secondary:function(placement){var mainSide="right"===placement?"left":"top",value=popper[mainSide];return popper[placement]>boundaries[placement]&&!options.escapeWithReference&&(value=Math.min(popper[mainSide],boundaries[placement]-("right"===placement?popper.width:popper.height))),defineProperty$1({},mainSide,value)}};return order.forEach((function(placement){var side=-1!==["left","top"].indexOf(placement)?"primary":"secondary";popper=_extends$2({},popper,check[side](placement))})),data.offsets.popper=popper,data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function shift$1(data){var placement=data.placement,basePlacement=placement.split("-")[0],shiftvariation=placement.split("-")[1];
// if shift shiftvariation is specified, run the modifier
if(shiftvariation){var _data$offsets=data.offsets,reference=_data$offsets.reference,popper=_data$offsets.popper,isVertical=-1!==["bottom","top"].indexOf(basePlacement),side=isVertical?"left":"top",measurement=isVertical?"width":"height",shiftOffsets={start:defineProperty$1({},side,reference[side]),end:defineProperty$1({},side,reference[side]+reference[measurement]-popper[measurement])};data.offsets.popper=_extends$2({},popper,shiftOffsets[shiftvariation])}return data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function hide$1(data){if(!isModifierRequired$1(data.instance.modifiers,"hide","preventOverflow"))return data;var refRect=data.offsets.reference,bound=find$1(data.instance.modifiers,(function(modifier){return"preventOverflow"===modifier.name})).boundaries;if(refRect.bottom<bound.top||refRect.left>bound.right||refRect.top>bound.bottom||refRect.right<bound.left){
// Avoid unnecessary DOM access if visibility hasn't changed
if(!0===data.hide)return data;data.hide=!0,data.attributes["x-out-of-boundaries"]=""}else{
// Avoid unnecessary DOM access if visibility hasn't changed
if(!1===data.hide)return data;data.hide=!1,data.attributes["x-out-of-boundaries"]=!1}return data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function inner$1(data){var placement=data.placement,basePlacement=placement.split("-")[0],_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,isHoriz=-1!==["left","right"].indexOf(basePlacement),subtractLength=-1===["top","left"].indexOf(basePlacement);return popper[isHoriz?"left":"top"]=reference[basePlacement]-(subtractLength?popper[isHoriz?"width":"height"]:0),data.placement=getOppositePlacement$1(placement),data.offsets.popper=getClientRect$1(popper),data}
/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */
/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */var modifiers$1={
/**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
shift:{
/** @prop {number} order=100 - Index used to define the order of execution */
order:100,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:shift$1},
/**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
offset:{
/** @prop {number} order=200 - Index used to define the order of execution */
order:200,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:offset$1,
/** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
offset:0},
/**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
preventOverflow:{
/** @prop {number} order=300 - Index used to define the order of execution */
order:300,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:preventOverflow$1,
/**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
priority:["left","right","top","bottom"],
/**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
padding:5,
/**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
boundariesElement:"scrollParent"},
/**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
keepTogether:{
/** @prop {number} order=400 - Index used to define the order of execution */
order:400,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:keepTogether$1},
/**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
arrow:{
/** @prop {number} order=500 - Index used to define the order of execution */
order:500,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:arrow$1,
/** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
element:"[x-arrow]"},
/**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
flip:{
/** @prop {number} order=600 - Index used to define the order of execution */
order:600,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:flip$1,
/**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
behavior:"flip",
/**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
padding:5,
/**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
boundariesElement:"viewport",
/**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
flipVariations:!1,
/**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
flipVariationsByContent:!1},
/**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
inner:{
/** @prop {number} order=700 - Index used to define the order of execution */
order:700,
/** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
enabled:!1,
/** @prop {ModifierFn} */
fn:inner$1},
/**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
hide:{
/** @prop {number} order=800 - Index used to define the order of execution */
order:800,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:hide$1},
/**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
computeStyle:{
/** @prop {number} order=850 - Index used to define the order of execution */
order:850,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:computeStyle$1,
/**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
gpuAcceleration:!0,
/**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
x:"bottom",
/**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
y:"right"},
/**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
applyStyle:{
/** @prop {number} order=900 - Index used to define the order of execution */
order:900,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:applyStyle$1,
/** @prop {Function} */
onLoad:applyStyleOnLoad$1,
/**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
gpuAcceleration:void 0}},Defaults$1={
/**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
placement:"bottom",
/**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
positionFixed:!1,
/**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
eventsEnabled:!0,
/**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
removeOnDestroy:!1,
/**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
onCreate:function(){},
/**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
onUpdate:function(){},
/**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
modifiers:modifiers$1},Popper$1=function(){
/**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
function Popper(reference,popper){var _this=this,options=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};classCallCheck$1(this,Popper),this.scheduleUpdate=function(){return requestAnimationFrame(_this.update)},
// make update() debounced, so that it only runs at most once-per-tick
this.update=debounce$2(this.update.bind(this)),
// with {} we create a new object with the options inside it
this.options=_extends$2({},Popper.Defaults,options),
// init state
this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},
// get reference and popper elements (allow jQuery wrappers)
this.reference=reference&&reference.jquery?reference[0]:reference,this.popper=popper&&popper.jquery?popper[0]:popper,
// Deep merge modifiers options
this.options.modifiers={},Object.keys(_extends$2({},Popper.Defaults.modifiers,options.modifiers)).forEach((function(name){_this.options.modifiers[name]=_extends$2({},Popper.Defaults.modifiers[name]||{},options.modifiers?options.modifiers[name]:{})})),
// Refactoring modifiers' list (Object => Array)
this.modifiers=Object.keys(this.options.modifiers).map((function(name){return _extends$2({name:name},_this.options.modifiers[name])})).sort((function(a,b){return a.order-b.order})),
// modifiers have the ability to execute arbitrary code when Popper.js get inited
// such code is executed in the same order of its modifier
// they could add new properties to their options configuration
// BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
this.modifiers.forEach((function(modifierOptions){modifierOptions.enabled&&isFunction$1(modifierOptions.onLoad)&&modifierOptions.onLoad(_this.reference,_this.popper,_this.options,modifierOptions,_this.state)})),
// fire the first update to position the popper in the right place
this.update();var eventsEnabled=this.options.eventsEnabled;eventsEnabled&&
// setup event listeners, they will take care of update the position in specific situations
this.enableEventListeners(),this.state.eventsEnabled=eventsEnabled}
// We can't use class properties because they don't get listed in the
// class prototype and break stuff like Sinon stubs
return createClass$1(Popper,[{key:"update",value:function(){return update$1.call(this)}},{key:"destroy",value:function(){return destroy$1.call(this)}},{key:"enableEventListeners",value:function(){return enableEventListeners$1.call(this)}},{key:"disableEventListeners",value:function(){return disableEventListeners$1.call(this)}
/**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */
/**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */}]),Popper}();
/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */
/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */
Popper$1.Utils=("undefined"!==typeof window?window:global).PopperUtils,Popper$1.placements=placements$1,Popper$1.Defaults=Defaults$1;var isIE$2,Popper$2=Popper$1;function getInternetExplorerVersion(){var ua=window.navigator.userAgent,msie=ua.indexOf("MSIE ");if(msie>0)
// IE 10 or older => return version number
return parseInt(ua.substring(msie+5,ua.indexOf(".",msie)),10);var trident=ua.indexOf("Trident/");if(trident>0){
// IE 11 => return version number
var rv=ua.indexOf("rv:");return parseInt(ua.substring(rv+3,ua.indexOf(".",rv)),10)}var edge=ua.indexOf("Edge/");return edge>0?parseInt(ua.substring(edge+5,ua.indexOf(".",edge)),10):-1;// other browser
}

function initCompat(){initCompat.init||(initCompat.init=!0,isIE$2=-1!==getInternetExplorerVersion())}var script$6={name:"ResizeObserver",props:{emitOnMount:{type:Boolean,default:!1},ignoreWidth:{type:Boolean,default:!1},ignoreHeight:{type:Boolean,default:!1}},mounted:function(){var _this=this;initCompat(),this.$nextTick((function(){_this._w=_this.$el.offsetWidth,_this._h=_this.$el.offsetHeight,_this.emitOnMount&&_this.emitSize()}));var object=document.createElement("object");this._resizeObject=object,object.setAttribute("aria-hidden","true"),object.setAttribute("tabindex",-1),object.onload=this.addResizeHandlers,object.type="text/html",isIE$2&&this.$el.appendChild(object),object.data="about:blank",isIE$2||this.$el.appendChild(object)},beforeDestroy:function(){this.removeResizeHandlers()},methods:{compareAndNotify:function(){(!this.ignoreWidth&&this._w!==this.$el.offsetWidth||!this.ignoreHeight&&this._h!==this.$el.offsetHeight)&&(this._w=this.$el.offsetWidth,this._h=this.$el.offsetHeight,this.emitSize())},emitSize:function(){this.$emit("notify",{width:this._w,height:this._h})},addResizeHandlers:function(){this._resizeObject.contentDocument.defaultView.addEventListener("resize",this.compareAndNotify),this.compareAndNotify()},removeResizeHandlers:function(){this._resizeObject&&this._resizeObject.onload&&(!isIE$2&&this._resizeObject.contentDocument&&this._resizeObject.contentDocument.defaultView.removeEventListener("resize",this.compareAndNotify),this.$el.removeChild(this._resizeObject),this._resizeObject.onload=null,this._resizeObject=null)}}};function normalizeComponent$2(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier
/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);// Vue.extend constructor export interop.
var hook,options="function"===typeof script?script.options:script;// render functions
if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,// functional template
isFunctionalTemplate&&(options.functional=!0)),// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),// inject component styles
style&&style.call(this,createInjectorSSR(context)),// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(context){style.call(this,createInjectorShadow(context,this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
var originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
var existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}
/* script */var __vue_script__$6=script$6,__vue_render__$5=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"resize-observer",attrs:{tabindex:"-1"}})},__vue_staticRenderFns__$5=[];
/* template */__vue_render__$5._withStripped=!0;
/* style */
var __vue_inject_styles__$6=void 0,__vue_scope_id__$6="data-v-8859cc6c",__vue_module_identifier__$6=void 0,__vue_is_functional_template__$6=!1,__vue_component__$5=normalizeComponent$2({render:__vue_render__$5,staticRenderFns:__vue_staticRenderFns__$5},__vue_inject_styles__$6,__vue_script__$6,__vue_scope_id__$6,__vue_is_functional_template__$6,__vue_module_identifier__$6,!1,void 0,void 0,void 0);
/* scoped */function install$1(Vue){
// eslint-disable-next-line vue/component-definition-name-casing
Vue.component("resize-observer",__vue_component__$5),Vue.component("ResizeObserver",__vue_component__$5)}var plugin$2={
// eslint-disable-next-line no-undef
version:"1.0.1",install:install$1},GlobalVue$1=null;"undefined"!==typeof window?GlobalVue$1=window.Vue:"undefined"!==typeof global&&(GlobalVue$1=global.Vue),GlobalVue$1&&GlobalVue$1.use(plugin$2);var SVGAnimatedString=function(){};function convertToArray(value){return"string"===typeof value&&(value=value.split(" ")),value}
/**
 * Add classes to an element.
 * This method checks to ensure that the classes don't already exist before adding them.
 * It uses el.className rather than classList in order to be IE friendly.
 * @param {object} el - The element to add the classes to.
 * @param {classes} string - List of space separated classes to be added to the element.
 */function addClasses(el,classes){var classList,newClasses=convertToArray(classes);classList=el.className instanceof SVGAnimatedString?convertToArray(el.className.baseVal):convertToArray(el.className),newClasses.forEach((function(newClass){-1===classList.indexOf(newClass)&&classList.push(newClass)})),el instanceof SVGElement?el.setAttribute("class",classList.join(" ")):el.className=classList.join(" ")}
/**
 * Remove classes from an element.
 * It uses el.className rather than classList in order to be IE friendly.
 * @export
 * @param {any} el The element to remove the classes from.
 * @param {any} classes List of space separated classes to be removed from the element.
 */function removeClasses(el,classes){var classList,newClasses=convertToArray(classes);classList=el.className instanceof SVGAnimatedString?convertToArray(el.className.baseVal):convertToArray(el.className),newClasses.forEach((function(newClass){var index=classList.indexOf(newClass);-1!==index&&classList.splice(index,1)})),el instanceof SVGElement?el.setAttribute("class",classList.join(" ")):el.className=classList.join(" ")}"undefined"!==typeof window&&(SVGAnimatedString=window.SVGAnimatedString);var supportsPassive=!1;if("undefined"!==typeof window){supportsPassive=!1;try{var opts=Object.defineProperty({},"passive",{get:function(){supportsPassive=!0}});window.addEventListener("test",null,opts)}catch(e){}}function ownKeys$2(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread$2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$2(Object(source),!0).forEach((function(key){_defineProperty$1(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$2(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}var DEFAULT_OPTIONS={container:!1,delay:0,html:!1,placement:"top",title:"",template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",offset:0},openTooltips=[],Tooltip=function(){
/**
   * Create a new Tooltip.js instance
   * @class Tooltip
   * @param {HTMLElement} reference - The DOM node used as reference of the tooltip (it can be a jQuery element).
   * @param {Object} options
   * @param {String} options.placement=bottom
   *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -end),
   *      left(-start, -end)`
   * @param {HTMLElement|String|false} options.container=false - Append the tooltip to a specific element.
   * @param {Number|Object} options.delay=0
   *      Delay showing and hiding the tooltip (ms) - does not apply to manual trigger type.
   *      If a number is supplied, delay is applied to both hide/show.
   *      Object structure is: `{ show: 500, hide: 100 }`
   * @param {Boolean} options.html=false - Insert HTML into the tooltip. If false, the content will inserted with `innerText`.
   * @param {String|PlacementFunction} options.placement='top' - One of the allowed placements, or a function returning one of them.
   * @param {String} [options.template='<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>']
   *      Base HTML to used when creating the tooltip.
   *      The tooltip's `title` will be injected into the `.tooltip-inner` or `.tooltip__inner`.
   *      `.tooltip-arrow` or `.tooltip__arrow` will become the tooltip's arrow.
   *      The outermost wrapper element should have the `.tooltip` class.
   * @param {String|HTMLElement|TitleFunction} options.title='' - Default title value if `title` attribute isn't present.
   * @param {String} [options.trigger='hover focus']
   *      How tooltip is triggered - click, hover, focus, manual.
   *      You may pass multiple triggers; separate them with a space. `manual` cannot be combined with any other trigger.
   * @param {HTMLElement} options.boundariesElement
   *      The element used as boundaries for the tooltip. For more information refer to Popper.js'
   *      [boundariesElement docs](https://popper.js.org/popper-documentation.html)
   * @param {Number|String} options.offset=0 - Offset of the tooltip relative to its reference. For more information refer to Popper.js'
   *      [offset docs](https://popper.js.org/popper-documentation.html)
   * @param {Object} options.popperOptions={} - Popper options, will be passed directly to popper instance. For more information refer to Popper.js'
   *      [options docs](https://popper.js.org/popper-documentation.html)
   * @param {string} [options.ariaId] Id used for accessibility
   * @return {Object} instance - The generated tooltip instance
   */
function Tooltip(_reference,_options){var _this=this;_classCallCheck(this,Tooltip),_defineProperty$1(this,"_events",[]),_defineProperty$1(this,"_setTooltipNodeEvent",(function(evt,reference,delay,options){var relatedreference=evt.relatedreference||evt.toElement||evt.relatedTarget,callback=function callback(evt2){var relatedreference2=evt2.relatedreference||evt2.toElement||evt2.relatedTarget;// Remove event listener after call
_this._tooltipNode.removeEventListener(evt.type,callback),// If the new reference is not the reference element
reference.contains(relatedreference2)||
// Schedule to hide tooltip
_this._scheduleHide(reference,options.delay,options,evt2)};return!!_this._tooltipNode.contains(relatedreference)&&(
// listen to mouseleave on the tooltip element to be able to hide the tooltip
_this._tooltipNode.addEventListener(evt.type,callback),!0)})),
// apply user options over default ones
_options=_objectSpread$2(_objectSpread$2({},DEFAULT_OPTIONS),_options),_reference.jquery&&(_reference=_reference[0]),this.show=this.show.bind(this),this.hide=this.hide.bind(this),// cache reference and options
this.reference=_reference,this.options=_options,// set initial state
this._isOpen=!1,this._init()}
// Public methods

/**
   * Reveals an element's tooltip. This is considered a "manual" triggering of the tooltip.
   * Tooltips with zero-length titles are never displayed.
   * @method Tooltip#show
   * @memberof Tooltip
   */return _createClass(Tooltip,[{key:"show",value:function(){this._show(this.reference,this.options)}
/**
     * Hides an element’s tooltip. This is considered a “manual” triggering of the tooltip.
     * @method Tooltip#hide
     * @memberof Tooltip
     */},{key:"hide",value:function(){this._hide()}
/**
     * Hides and destroys an element’s tooltip.
     * @method Tooltip#dispose
     * @memberof Tooltip
     */},{key:"dispose",value:function(){this._dispose()}
/**
     * Toggles an element’s tooltip. This is considered a “manual” triggering of the tooltip.
     * @method Tooltip#toggle
     * @memberof Tooltip
     */},{key:"toggle",value:function(){return this._isOpen?this.hide():this.show()}},{key:"setClasses",value:function(classes){this._classes=classes}},{key:"setContent",value:function(content){this.options.title=content,this._tooltipNode&&this._setContent(content,this.options)}},{key:"setOptions",value:function(options){var classesUpdated=!1,classes=options&&options.classes||directive.options.defaultClass;lodash_isEqual(this._classes,classes)||(this.setClasses(classes),classesUpdated=!0),options=getOptions(options);var needPopperUpdate=!1,needRestart=!1;for(var key in this.options.offset===options.offset&&this.options.placement===options.placement||(needPopperUpdate=!0),(this.options.template!==options.template||this.options.trigger!==options.trigger||this.options.container!==options.container||classesUpdated)&&(needRestart=!0),options)this.options[key]=options[key];if(this._tooltipNode)if(needRestart){var isOpen=this._isOpen;this.dispose(),this._init(),isOpen&&this.show()}else needPopperUpdate&&this.popperInstance.update()}
// Private methods

},{key:"_init",value:function(){
// get events list
var events="string"===typeof this.options.trigger?this.options.trigger.split(" "):[];this._isDisposed=!1,this._enableDocumentTouch=-1===events.indexOf("manual"),events=events.filter((function(trigger){return-1!==["click","hover","focus"].indexOf(trigger)})),// set event listeners
this._setEventListeners(this.reference,events,this.options),// title attribute
this.$_originalTitle=this.reference.getAttribute("title"),this.reference.removeAttribute("title"),this.reference.setAttribute("data-original-title",this.$_originalTitle)}
/**
     * Creates a new tooltip node
     * @memberof Tooltip
     * @private
     * @param {HTMLElement} reference
     * @param {String} template
     * @param {String|HTMLElement|TitleFunction} title
     * @param {Boolean} allowHtml
     * @return {HTMLelement} tooltipNode
     */},{key:"_create",value:function(reference,template){var _this2=this,tooltipGenerator=window.document.createElement("div");
// create tooltip element
tooltipGenerator.innerHTML=template.trim();var tooltipNode=tooltipGenerator.childNodes[0];// add unique ID to our tooltip (needed for accessibility reasons)
// return the generated tooltip node
return tooltipNode.id=this.options.ariaId||"tooltip_".concat(Math.random().toString(36).substr(2,10)),// Initially hide the tooltip
// The attribute will be switched in a next frame so
// CSS transitions can play
tooltipNode.setAttribute("aria-hidden","true"),this.options.autoHide&&-1!==this.options.trigger.indexOf("hover")&&(tooltipNode.addEventListener("mouseenter",(function(evt){return _this2._scheduleHide(reference,_this2.options.delay,_this2.options,evt)})),tooltipNode.addEventListener("click",(function(evt){return _this2._scheduleHide(reference,_this2.options.delay,_this2.options,evt)}))),tooltipNode}},{key:"_setContent",value:function(content,options){var _this3=this;this.asyncContent=!1,this._applyContent(content,options).then((function(){_this3.popperInstance&&_this3.popperInstance.update()}))}},{key:"_applyContent",value:function(title,options){var _this4=this;return new Promise((function(resolve,reject){var allowHtml=options.html,rootNode=_this4._tooltipNode;if(rootNode){var titleNode=rootNode.querySelector(_this4.options.innerSelector);if(1===title.nodeType){
// if title is a node, append it only if allowHtml is true
if(allowHtml){while(titleNode.firstChild)titleNode.removeChild(titleNode.firstChild);titleNode.appendChild(title)}}else{if("function"===typeof title){
// if title is a function, call it and set innerText or innerHtml depending by `allowHtml` value
var result=title();return void(result&&"function"===typeof result.then?(_this4.asyncContent=!0,options.loadingClass&&addClasses(rootNode,options.loadingClass),options.loadingContent&&_this4._applyContent(options.loadingContent,options),result.then((function(asyncResult){return options.loadingClass&&removeClasses(rootNode,options.loadingClass),_this4._applyContent(asyncResult,options)})).then(resolve).catch(reject)):_this4._applyContent(result,options).then(resolve).catch(reject))}
// if it's just a simple text, set innerText or innerHtml depending by `allowHtml` value
allowHtml?titleNode.innerHTML=title:titleNode.innerText=title}resolve()}}))}},{key:"_show",value:function(reference,options){if(options&&"string"===typeof options.container){var container=document.querySelector(options.container);if(!container)return}clearTimeout(this._disposeTimer),options=Object.assign({},options),delete options.offset;var updateClasses=!0;this._tooltipNode&&(addClasses(this._tooltipNode,this._classes),updateClasses=!1);var result=this._ensureShown(reference,options);return updateClasses&&this._tooltipNode&&addClasses(this._tooltipNode,this._classes),addClasses(reference,["v-tooltip-open"]),result}},{key:"_ensureShown",value:function(reference,options){var _this5=this;
// don't show if it's already visible
if(this._isOpen)return this;// if the tooltipNode already exists, just show it
if(this._isOpen=!0,openTooltips.push(this),this._tooltipNode)return this._tooltipNode.style.display="",this._tooltipNode.setAttribute("aria-hidden","false"),this.popperInstance.enableEventListeners(),this.popperInstance.update(),this.asyncContent&&this._setContent(options.title,options),this;// get title
var title=reference.getAttribute("title")||options.title;// don't show tooltip if no title is defined
if(!title)return this;// create tooltip node
var tooltipNode=this._create(reference,options.template);this._tooltipNode=tooltipNode,// Add `aria-describedby` to our reference element for accessibility reasons
reference.setAttribute("aria-describedby",tooltipNode.id);// append tooltip to container
var container=this._findContainer(options.container,reference);this._append(tooltipNode,container);var popperOptions=_objectSpread$2(_objectSpread$2({},options.popperOptions),{},{placement:options.placement});return popperOptions.modifiers=_objectSpread$2(_objectSpread$2({},popperOptions.modifiers),{},{arrow:{element:this.options.arrowSelector}}),options.boundariesElement&&(popperOptions.modifiers.preventOverflow={boundariesElement:options.boundariesElement}),this.popperInstance=new Popper$2(reference,tooltipNode,popperOptions),this._setContent(title,options),// Fix position
requestAnimationFrame((function(){!_this5._isDisposed&&_this5.popperInstance?(_this5.popperInstance.update(),// Show the tooltip
requestAnimationFrame((function(){_this5._isDisposed?_this5.dispose():_this5._isOpen&&tooltipNode.setAttribute("aria-hidden","false")}))):_this5.dispose()})),this}},{key:"_noLongerOpen",value:function(){var index=openTooltips.indexOf(this);-1!==index&&openTooltips.splice(index,1)}},{key:"_hide",value:function(){var _this6=this;
// don't hide if it's already hidden
if(!this._isOpen)return this;this._isOpen=!1,this._noLongerOpen(),// hide tooltipNode
this._tooltipNode.style.display="none",this._tooltipNode.setAttribute("aria-hidden","true"),this.popperInstance&&this.popperInstance.disableEventListeners(),clearTimeout(this._disposeTimer);var disposeTime=directive.options.disposeTimeout;return null!==disposeTime&&(this._disposeTimer=setTimeout((function(){_this6._tooltipNode&&(_this6._tooltipNode.removeEventListener("mouseenter",_this6.hide),_this6._tooltipNode.removeEventListener("click",_this6.hide),// Don't remove popper instance, just the HTML element
_this6._removeTooltipNode())}),disposeTime)),removeClasses(this.reference,["v-tooltip-open"]),this}},{key:"_removeTooltipNode",value:function(){if(this._tooltipNode){var parentNode=this._tooltipNode.parentNode;parentNode&&(parentNode.removeChild(this._tooltipNode),this.reference.removeAttribute("aria-describedby")),this._tooltipNode=null}}},{key:"_dispose",value:function(){var _this7=this;return this._isDisposed=!0,this.reference.removeAttribute("data-original-title"),this.$_originalTitle&&this.reference.setAttribute("title",this.$_originalTitle),// remove event listeners first to prevent any unexpected behaviour
this._events.forEach((function(_ref){var func=_ref.func,event=_ref.event;_this7.reference.removeEventListener(event,func)})),this._events=[],this._tooltipNode?(this._hide(),this._tooltipNode.removeEventListener("mouseenter",this.hide),this._tooltipNode.removeEventListener("click",this.hide),// destroy instance
this.popperInstance.destroy(),// destroy tooltipNode if removeOnDestroy is not set, as popperInstance.destroy() already removes the element
this.popperInstance.options.removeOnDestroy||this._removeTooltipNode()):this._noLongerOpen(),this}},{key:"_findContainer",value:function(container,reference){
// if container is a query, get the relative element
return"string"===typeof container?container=window.document.querySelector(container):!1===container&&(
// if container is `false`, set it to reference parent
container=reference.parentNode),container}
/**
     * Append tooltip to container
     * @memberof Tooltip
     * @private
     * @param {HTMLElement} tooltip
     * @param {HTMLElement|String|false} container
     */},{key:"_append",value:function(tooltipNode,container){container.appendChild(tooltipNode)}},{key:"_setEventListeners",value:function(reference,events,options){var _this8=this,directEvents=[],oppositeEvents=[];events.forEach((function(event){switch(event){case"hover":directEvents.push("mouseenter"),oppositeEvents.push("mouseleave"),_this8.options.hideOnTargetClick&&oppositeEvents.push("click");break;case"focus":directEvents.push("focus"),oppositeEvents.push("blur"),_this8.options.hideOnTargetClick&&oppositeEvents.push("click");break;case"click":directEvents.push("click"),oppositeEvents.push("click");break}})),// schedule show tooltip
directEvents.forEach((function(event){var func=function(evt){!0!==_this8._isOpen&&(evt.usedByTooltip=!0,_this8._scheduleShow(reference,options.delay,options,evt))};_this8._events.push({event:event,func:func}),reference.addEventListener(event,func)})),// schedule hide tooltip
oppositeEvents.forEach((function(event){var func=function(evt){!0!==evt.usedByTooltip&&_this8._scheduleHide(reference,options.delay,options,evt)};_this8._events.push({event:event,func:func}),reference.addEventListener(event,func)}))}},{key:"_onDocumentTouch",value:function(event){this._enableDocumentTouch&&this._scheduleHide(this.reference,this.options.delay,this.options,event)}},{key:"_scheduleShow",value:function(reference,delay,options
/*, evt */){var _this9=this,computedDelay=delay&&delay.show||delay||0;
// defaults to 0
clearTimeout(this._scheduleTimer),this._scheduleTimer=window.setTimeout((function(){return _this9._show(reference,options)}),computedDelay)}},{key:"_scheduleHide",value:function(reference,delay,options,evt){var _this10=this,computedDelay=delay&&delay.hide||delay||0;
// defaults to 0
clearTimeout(this._scheduleTimer),this._scheduleTimer=window.setTimeout((function(){if(!1!==_this10._isOpen&&_this10._tooltipNode.ownerDocument.body.contains(_this10._tooltipNode)){// if we are hiding because of a mouseleave, we must check that the new
// reference isn't the tooltip, because in this case we don't want to hide it
if("mouseleave"===evt.type){var isSet=_this10._setTooltipNodeEvent(evt,reference,delay,options);// if we set the new event, don't hide the tooltip yet
// the new event will take care to hide it if necessary
if(isSet)return}_this10._hide(reference,options)}}),computedDelay)}}]),Tooltip}();
/**
 * Placement function, its context is the Tooltip instance.
 * @memberof Tooltip
 * @callback PlacementFunction
 * @param {HTMLElement} tooltip - tooltip DOM node.
 * @param {HTMLElement} reference - reference DOM node.
 * @return {String} placement - One of the allowed placement options.
 */
/**
 * Title function, its context is the Tooltip instance.
 * @memberof Tooltip
 * @callback TitleFunction
 * @return {String} placement - The desired title.
 */
function ownKeys$1(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread$1(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$1(Object(source),!0).forEach((function(key){_defineProperty$1(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$1(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}// Hide tooltips on touch devices
"undefined"!==typeof document&&document.addEventListener("touchstart",(function(event){for(var i=0;i<openTooltips.length;i++)openTooltips[i]._onDocumentTouch(event)}),!supportsPassive||{passive:!0,capture:!0});var state={enabled:!0},positions=["top","top-start","top-end","right","right-start","right-end","bottom","bottom-start","bottom-end","left","left-start","left-end"],defaultOptions={
// Default tooltip placement relative to target element
defaultPlacement:"top",
// Default CSS classes applied to the tooltip element
defaultClass:"vue-tooltip-theme",
// Default CSS classes applied to the target element of the tooltip
defaultTargetClass:"has-tooltip",
// Is the content HTML by default?
defaultHtml:!0,
// Default HTML template of the tooltip element
// It must include `tooltip-arrow` & `tooltip-inner` CSS classes (can be configured, see below)
// Change if the classes conflict with other libraries (for example bootstrap)
defaultTemplate:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
// Selector used to get the arrow element in the tooltip template
defaultArrowSelector:".tooltip-arrow, .tooltip__arrow",
// Selector used to get the inner content element in the tooltip template
defaultInnerSelector:".tooltip-inner, .tooltip__inner",
// Delay (ms)
defaultDelay:0,
// Default events that trigger the tooltip
defaultTrigger:"hover focus",
// Default position offset (px)
defaultOffset:0,
// Default container where the tooltip will be appended
defaultContainer:"body",defaultBoundariesElement:void 0,defaultPopperOptions:{},
// Class added when content is loading
defaultLoadingClass:"tooltip-loading",
// Displayed when tooltip content is loading
defaultLoadingContent:"...",
// Hide on mouseover tooltip
autoHide:!0,
// Close tooltip on click on tooltip target?
defaultHideOnTargetClick:!0,
// Auto destroy tooltip DOM nodes (ms)
disposeTimeout:5e3,
// Options for popover
popover:{defaultPlacement:"bottom",
// Use the `popoverClass` prop for theming
defaultClass:"vue-popover-theme",
// Base class (change if conflicts with other libraries)
defaultBaseClass:"tooltip popover",
// Wrapper class (contains arrow and inner)
defaultWrapperClass:"wrapper",
// Inner content class
defaultInnerClass:"tooltip-inner popover-inner",
// Arrow class
defaultArrowClass:"tooltip-arrow popover-arrow",
// Class added when popover is open
defaultOpenClass:"open",defaultDelay:0,defaultTrigger:"click",defaultOffset:0,defaultContainer:"body",defaultBoundariesElement:void 0,defaultPopperOptions:{},
// Hides if clicked outside of popover
defaultAutoHide:!0,
// Update popper on content resize
defaultHandleResize:!0}};function getOptions(options){var result={placement:"undefined"!==typeof options.placement?options.placement:directive.options.defaultPlacement,delay:"undefined"!==typeof options.delay?options.delay:directive.options.defaultDelay,html:"undefined"!==typeof options.html?options.html:directive.options.defaultHtml,template:"undefined"!==typeof options.template?options.template:directive.options.defaultTemplate,arrowSelector:"undefined"!==typeof options.arrowSelector?options.arrowSelector:directive.options.defaultArrowSelector,innerSelector:"undefined"!==typeof options.innerSelector?options.innerSelector:directive.options.defaultInnerSelector,trigger:"undefined"!==typeof options.trigger?options.trigger:directive.options.defaultTrigger,offset:"undefined"!==typeof options.offset?options.offset:directive.options.defaultOffset,container:"undefined"!==typeof options.container?options.container:directive.options.defaultContainer,boundariesElement:"undefined"!==typeof options.boundariesElement?options.boundariesElement:directive.options.defaultBoundariesElement,autoHide:"undefined"!==typeof options.autoHide?options.autoHide:directive.options.autoHide,hideOnTargetClick:"undefined"!==typeof options.hideOnTargetClick?options.hideOnTargetClick:directive.options.defaultHideOnTargetClick,loadingClass:"undefined"!==typeof options.loadingClass?options.loadingClass:directive.options.defaultLoadingClass,loadingContent:"undefined"!==typeof options.loadingContent?options.loadingContent:directive.options.defaultLoadingContent,popperOptions:_objectSpread$1({},"undefined"!==typeof options.popperOptions?options.popperOptions:directive.options.defaultPopperOptions)};if(result.offset){var typeofOffset=_typeof(result.offset),offset=result.offset;// One value -> switch
("number"===typeofOffset||"string"===typeofOffset&&-1===offset.indexOf(","))&&(offset="0, ".concat(offset)),result.popperOptions.modifiers||(result.popperOptions.modifiers={}),result.popperOptions.modifiers.offset={offset:offset}}return result.trigger&&-1!==result.trigger.indexOf("click")&&(result.hideOnTargetClick=!1),result}function getPlacement(value,modifiers){for(var placement=value.placement,i=0;i<positions.length;i++){var pos=positions[i];modifiers[pos]&&(placement=pos)}return placement}function getContent(value){var type=_typeof(value);return"string"===type?value:!(!value||"object"!==type)&&value.content}function createTooltip(el,value){var modifiers=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},content=getContent(value),classes="undefined"!==typeof value.classes?value.classes:directive.options.defaultClass,opts=_objectSpread$1({title:content},getOptions(_objectSpread$1(_objectSpread$1({},"object"===_typeof(value)?value:{}),{},{placement:getPlacement(value,modifiers)}))),tooltip=el._tooltip=new Tooltip(el,opts);tooltip.setClasses(classes),tooltip._vueEl=el;// Class on target
var targetClasses="undefined"!==typeof value.targetClasses?value.targetClasses:directive.options.defaultTargetClass;return el._tooltipTargetClasses=targetClasses,addClasses(el,targetClasses),tooltip}function destroyTooltip(el){el._tooltip&&(el._tooltip.dispose(),delete el._tooltip,delete el._tooltipOldShow),el._tooltipTargetClasses&&(removeClasses(el,el._tooltipTargetClasses),delete el._tooltipTargetClasses)}function bind(el,_ref){var value=_ref.value;_ref.oldValue;var tooltip,modifiers=_ref.modifiers,content=getContent(value);content&&state.enabled?(el._tooltip?(tooltip=el._tooltip,// Content
tooltip.setContent(content),// Options
tooltip.setOptions(_objectSpread$1(_objectSpread$1({},value),{},{placement:getPlacement(value,modifiers)}))):tooltip=createTooltip(el,value,modifiers),// Manual show
"undefined"!==typeof value.show&&value.show!==el._tooltipOldShow&&(el._tooltipOldShow=value.show,value.show?tooltip.show():tooltip.hide())):destroyTooltip(el)}var directive={options:defaultOptions,bind:bind,update:bind,unbind:function(el){destroyTooltip(el)}};function addListeners(el){el.addEventListener("click",onClick),el.addEventListener("touchstart",onTouchStart,!!supportsPassive&&{passive:!0})}function removeListeners(el){el.removeEventListener("click",onClick),el.removeEventListener("touchstart",onTouchStart),el.removeEventListener("touchend",onTouchEnd),el.removeEventListener("touchcancel",onTouchCancel)}function onClick(event){var el=event.currentTarget;event.closePopover=!el.$_vclosepopover_touch,event.closeAllPopover=el.$_closePopoverModifiers&&!!el.$_closePopoverModifiers.all}function onTouchStart(event){if(1===event.changedTouches.length){var el=event.currentTarget;el.$_vclosepopover_touch=!0;var touch=event.changedTouches[0];el.$_vclosepopover_touchPoint=touch,el.addEventListener("touchend",onTouchEnd),el.addEventListener("touchcancel",onTouchCancel)}}function onTouchEnd(event){var el=event.currentTarget;if(el.$_vclosepopover_touch=!1,1===event.changedTouches.length){var touch=event.changedTouches[0],firstTouch=el.$_vclosepopover_touchPoint;event.closePopover=Math.abs(touch.screenY-firstTouch.screenY)<20&&Math.abs(touch.screenX-firstTouch.screenX)<20,event.closeAllPopover=el.$_closePopoverModifiers&&!!el.$_closePopoverModifiers.all}}function onTouchCancel(event){var el=event.currentTarget;el.$_vclosepopover_touch=!1}var vclosepopover={bind:function(el,_ref){var value=_ref.value,modifiers=_ref.modifiers;el.$_closePopoverModifiers=modifiers,("undefined"===typeof value||value)&&addListeners(el)},update:function(el,_ref2){var value=_ref2.value,oldValue=_ref2.oldValue,modifiers=_ref2.modifiers;el.$_closePopoverModifiers=modifiers,value!==oldValue&&("undefined"===typeof value||value?addListeners(el):removeListeners(el))},unbind:function(el){removeListeners(el)}};function ownKeys$3(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$3(Object(source),!0).forEach((function(key){_defineProperty$1(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$3(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}function getDefault(key){var value=directive.options.popover[key];return"undefined"===typeof value?directive.options[key]:value}var isIOS$1=!1;"undefined"!==typeof window&&"undefined"!==typeof navigator&&(isIOS$1=/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream);var openPopovers=[],Element$1=function(){};"undefined"!==typeof window&&(Element$1=window.Element);var script$5={name:"VPopover",components:{ResizeObserver:__vue_component__$5},props:{open:{type:Boolean,default:!1},disabled:{type:Boolean,default:!1},placement:{type:String,default:function(){return getDefault("defaultPlacement")}},delay:{type:[String,Number,Object],default:function(){return getDefault("defaultDelay")}},offset:{type:[String,Number],default:function(){return getDefault("defaultOffset")}},trigger:{type:String,default:function(){return getDefault("defaultTrigger")}},container:{type:[String,Object,Element$1,Boolean],default:function(){return getDefault("defaultContainer")}},boundariesElement:{type:[String,Element$1],default:function(){return getDefault("defaultBoundariesElement")}},popperOptions:{type:Object,default:function(){return getDefault("defaultPopperOptions")}},popoverClass:{type:[String,Array],default:function(){return getDefault("defaultClass")}},popoverBaseClass:{type:[String,Array],default:function(){return directive.options.popover.defaultBaseClass}},popoverInnerClass:{type:[String,Array],default:function(){return directive.options.popover.defaultInnerClass}},popoverWrapperClass:{type:[String,Array],default:function(){return directive.options.popover.defaultWrapperClass}},popoverArrowClass:{type:[String,Array],default:function(){return directive.options.popover.defaultArrowClass}},autoHide:{type:Boolean,default:function(){return directive.options.popover.defaultAutoHide}},handleResize:{type:Boolean,default:function(){return directive.options.popover.defaultHandleResize}},openGroup:{type:String,default:null},openClass:{type:[String,Array],default:function(){return directive.options.popover.defaultOpenClass}},ariaId:{default:null}},data:function(){return{isOpen:!1,id:Math.random().toString(36).substr(2,10)}},computed:{cssClass:function(){return _defineProperty$1({},this.openClass,this.isOpen)},popoverId:function(){return"popover_".concat(null!=this.ariaId?this.ariaId:this.id)}},watch:{open:function(val){val?this.show():this.hide()},disabled:function(val,oldVal){val!==oldVal&&(val?this.hide():this.open&&this.show())},container:function(val){if(this.isOpen&&this.popperInstance){var popoverNode=this.$refs.popover,reference=this.$refs.trigger,container=this.$_findContainer(this.container,reference);if(!container)return;container.appendChild(popoverNode),this.popperInstance.scheduleUpdate()}},trigger:function(val){this.$_removeEventListeners(),this.$_addEventListeners()},placement:function(val){var _this=this;this.$_updatePopper((function(){_this.popperInstance.options.placement=val}))},offset:"$_restartPopper",boundariesElement:"$_restartPopper",popperOptions:{handler:"$_restartPopper",deep:!0}},created:function(){this.$_isDisposed=!1,this.$_mounted=!1,this.$_events=[],this.$_preventOpen=!1},mounted:function(){var popoverNode=this.$refs.popover;popoverNode.parentNode&&popoverNode.parentNode.removeChild(popoverNode),this.$_init(),this.open&&this.show()},deactivated:function(){this.hide()},beforeDestroy:function(){this.dispose()},methods:{show:function(){var _this2=this,_ref2=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},event=_ref2.event;_ref2.skipDelay;var _ref2$force=_ref2.force,force=void 0!==_ref2$force&&_ref2$force;!force&&this.disabled||(this.$_scheduleShow(event),this.$emit("show")),this.$emit("update:open",!0),this.$_beingShowed=!0,requestAnimationFrame((function(){_this2.$_beingShowed=!1}))},hide:function(){var _ref3=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},event=_ref3.event;_ref3.skipDelay,this.$_scheduleHide(event),this.$emit("hide"),this.$emit("update:open",!1)},dispose:function(){if(this.$_isDisposed=!0,this.$_removeEventListeners(),this.hide({skipDelay:!0}),this.popperInstance&&(this.popperInstance.destroy(),!this.popperInstance.options.removeOnDestroy)){var popoverNode=this.$refs.popover;popoverNode.parentNode&&popoverNode.parentNode.removeChild(popoverNode)}this.$_mounted=!1,this.popperInstance=null,this.isOpen=!1,this.$emit("dispose")},$_init:function(){-1===this.trigger.indexOf("manual")&&this.$_addEventListeners()},$_show:function(){var _this3=this,reference=this.$refs.trigger,popoverNode=this.$refs.popover;// Already open
if(clearTimeout(this.$_disposeTimer),!this.isOpen){if(// Popper is already initialized
this.popperInstance&&(this.isOpen=!0,this.popperInstance.enableEventListeners(),this.popperInstance.scheduleUpdate()),!this.$_mounted){var container=this.$_findContainer(this.container,reference);if(!container)return;container.appendChild(popoverNode),this.$_mounted=!0,this.isOpen=!1,this.popperInstance&&requestAnimationFrame((function(){_this3.hidden||(_this3.isOpen=!0)}))}if(!this.popperInstance){var popperOptions=_objectSpread(_objectSpread({},this.popperOptions),{},{placement:this.placement});if(popperOptions.modifiers=_objectSpread(_objectSpread({},popperOptions.modifiers),{},{arrow:_objectSpread(_objectSpread({},popperOptions.modifiers&&popperOptions.modifiers.arrow),{},{element:this.$refs.arrow})}),this.offset){var offset=this.$_getOffset();popperOptions.modifiers.offset=_objectSpread(_objectSpread({},popperOptions.modifiers&&popperOptions.modifiers.offset),{},{offset:offset})}this.boundariesElement&&(popperOptions.modifiers.preventOverflow=_objectSpread(_objectSpread({},popperOptions.modifiers&&popperOptions.modifiers.preventOverflow),{},{boundariesElement:this.boundariesElement})),this.popperInstance=new Popper$2(reference,popoverNode,popperOptions),// Fix position
requestAnimationFrame((function(){if(_this3.hidden)return _this3.hidden=!1,void _this3.$_hide();!_this3.$_isDisposed&&_this3.popperInstance?(_this3.popperInstance.scheduleUpdate(),// Show the tooltip
requestAnimationFrame((function(){if(_this3.hidden)return _this3.hidden=!1,void _this3.$_hide();_this3.$_isDisposed?_this3.dispose():_this3.isOpen=!0}))):_this3.dispose()}))}var openGroup=this.openGroup;if(openGroup)for(var popover,i=0;i<openPopovers.length;i++)popover=openPopovers[i],popover.openGroup!==openGroup&&(popover.hide(),popover.$emit("close-group"));openPopovers.push(this),this.$emit("apply-show")}},$_hide:function(){var _this4=this;
// Already hidden
if(this.isOpen){var index=openPopovers.indexOf(this);-1!==index&&openPopovers.splice(index,1),this.isOpen=!1,this.popperInstance&&this.popperInstance.disableEventListeners(),clearTimeout(this.$_disposeTimer);var disposeTime=directive.options.popover.disposeTimeout||directive.options.disposeTimeout;null!==disposeTime&&(this.$_disposeTimer=setTimeout((function(){var popoverNode=_this4.$refs.popover;popoverNode&&(
// Don't remove popper instance, just the HTML element
popoverNode.parentNode&&popoverNode.parentNode.removeChild(popoverNode),_this4.$_mounted=!1)}),disposeTime)),this.$emit("apply-hide")}},$_findContainer:function(container,reference){
// if container is a query, get the relative element
return"string"===typeof container?container=window.document.querySelector(container):!1===container&&(
// if container is `false`, set it to reference parent
container=reference.parentNode),container},$_getOffset:function(){var typeofOffset=_typeof(this.offset),offset=this.offset;// One value -> switch
return("number"===typeofOffset||"string"===typeofOffset&&-1===offset.indexOf(","))&&(offset="0, ".concat(offset)),offset},$_addEventListeners:function(){var _this5=this,reference=this.$refs.trigger,directEvents=[],oppositeEvents=[],events="string"===typeof this.trigger?this.trigger.split(" ").filter((function(trigger){return-1!==["click","hover","focus"].indexOf(trigger)})):[];events.forEach((function(event){switch(event){case"hover":directEvents.push("mouseenter"),oppositeEvents.push("mouseleave");break;case"focus":directEvents.push("focus"),oppositeEvents.push("blur");break;case"click":directEvents.push("click"),oppositeEvents.push("click");break}})),// schedule show tooltip
directEvents.forEach((function(event){var func=function(event){_this5.isOpen||(event.usedByTooltip=!0,!_this5.$_preventOpen&&_this5.show({event:event}),_this5.hidden=!1)};_this5.$_events.push({event:event,func:func}),reference.addEventListener(event,func)})),// schedule hide tooltip
oppositeEvents.forEach((function(event){var func=function(event){event.usedByTooltip||(_this5.hide({event:event}),_this5.hidden=!0)};_this5.$_events.push({event:event,func:func}),reference.addEventListener(event,func)}))},$_scheduleShow:function(){var skipDelay=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(clearTimeout(this.$_scheduleTimer),skipDelay)this.$_show();else{
// defaults to 0
var computedDelay=parseInt(this.delay&&this.delay.show||this.delay||0);this.$_scheduleTimer=setTimeout(this.$_show.bind(this),computedDelay)}},$_scheduleHide:function(){var _this6=this,event=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,skipDelay=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(clearTimeout(this.$_scheduleTimer),skipDelay)this.$_hide();else{
// defaults to 0
var computedDelay=parseInt(this.delay&&this.delay.hide||this.delay||0);this.$_scheduleTimer=setTimeout((function(){if(_this6.isOpen){// if we are hiding because of a mouseleave, we must check that the new
// reference isn't the tooltip, because in this case we don't want to hide it
if(event&&"mouseleave"===event.type){var isSet=_this6.$_setTooltipNodeEvent(event);// if we set the new event, don't hide the tooltip yet
// the new event will take care to hide it if necessary
if(isSet)return}_this6.$_hide()}}),computedDelay)}},$_setTooltipNodeEvent:function(event){var _this7=this,reference=this.$refs.trigger,popoverNode=this.$refs.popover,relatedreference=event.relatedreference||event.toElement||event.relatedTarget,callback=function callback(event2){var relatedreference2=event2.relatedreference||event2.toElement||event2.relatedTarget;// Remove event listener after call
popoverNode.removeEventListener(event.type,callback),// If the new reference is not the reference element
reference.contains(relatedreference2)||
// Schedule to hide tooltip
_this7.hide({event:event2})};return!!popoverNode.contains(relatedreference)&&(
// listen to mouseleave on the tooltip element to be able to hide the tooltip
popoverNode.addEventListener(event.type,callback),!0)},$_removeEventListeners:function(){var reference=this.$refs.trigger;this.$_events.forEach((function(_ref4){var func=_ref4.func,event=_ref4.event;reference.removeEventListener(event,func)})),this.$_events=[]},$_updatePopper:function(cb){this.popperInstance&&(cb(),this.isOpen&&this.popperInstance.scheduleUpdate())},$_restartPopper:function(){if(this.popperInstance){var isOpen=this.isOpen;this.dispose(),this.$_isDisposed=!1,this.$_init(),isOpen&&this.show({skipDelay:!0,force:!0})}},$_handleGlobalClose:function(event){var _this8=this,touch=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.$_beingShowed||(this.hide({event:event}),event.closePopover?this.$emit("close-directive"):this.$emit("auto-hide"),touch&&(this.$_preventOpen=!0,setTimeout((function(){_this8.$_preventOpen=!1}),300)))},$_handleResize:function(){this.isOpen&&this.popperInstance&&(this.popperInstance.scheduleUpdate(),this.$emit("resize"))}}};function handleGlobalClick(event){handleGlobalClose(event)}function handleGlobalTouchend(event){handleGlobalClose(event,!0)}function handleGlobalClose(event){
// Delay so that close directive has time to set values
for(var touch=arguments.length>1&&void 0!==arguments[1]&&arguments[1],_loop=function(i){var popover=openPopovers[i];if(popover.$refs.popover){var contains=popover.$refs.popover.contains(event.target);requestAnimationFrame((function(){(event.closeAllPopover||event.closePopover&&contains||popover.autoHide&&!contains)&&popover.$_handleGlobalClose(event,touch)}))}},i=0;i<openPopovers.length;i++)_loop(i)}function normalizeComponent$1(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);
// Vue.extend constructor export interop.
const options="function"===typeof script?script.options:script;
// render functions
let hook;if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,
// functional template
isFunctionalTemplate&&(options.functional=!0)),
// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),
// inject component styles
style&&style.call(this,createInjectorSSR(context)),
// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},
// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(context){style.call(this,createInjectorShadow(context,this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
const originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
const existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}
/* script */"undefined"!==typeof document&&"undefined"!==typeof window&&(isIOS$1?document.addEventListener("touchend",handleGlobalTouchend,!supportsPassive||{passive:!0,capture:!0}):window.addEventListener("click",handleGlobalClick,!0));var __vue_script__$5=script$5,__vue_render__$4=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"v-popover",class:_vm.cssClass},[_c("div",{ref:"trigger",staticClass:"trigger",staticStyle:{display:"inline-block"},attrs:{"aria-describedby":_vm.isOpen?_vm.popoverId:void 0,tabindex:-1!==_vm.trigger.indexOf("focus")?0:void 0}},[_vm._t("default")],2),_vm._v(" "),_c("div",{ref:"popover",class:[_vm.popoverBaseClass,_vm.popoverClass,_vm.cssClass],style:{visibility:_vm.isOpen?"visible":"hidden"},attrs:{id:_vm.popoverId,"aria-hidden":_vm.isOpen?"false":"true",tabindex:_vm.autoHide?0:void 0},on:{keyup:function($event){if(!$event.type.indexOf("key")&&_vm._k($event.keyCode,"esc",27,$event.key,["Esc","Escape"]))return null;_vm.autoHide&&_vm.hide()}}},[_c("div",{class:_vm.popoverWrapperClass},[_c("div",{ref:"inner",class:_vm.popoverInnerClass,staticStyle:{position:"relative"}},[_c("div",[_vm._t("popover",null,{isOpen:_vm.isOpen})],2),_vm._v(" "),_vm.handleResize?_c("ResizeObserver",{on:{notify:_vm.$_handleResize}}):_vm._e()],1),_vm._v(" "),_c("div",{ref:"arrow",class:_vm.popoverArrowClass})])])])},__vue_staticRenderFns__$4=[];
/* template */__vue_render__$4._withStripped=!0;
/* style */
var __vue_inject_styles__$5=void 0,__vue_scope_id__$5=void 0,__vue_module_identifier__$5=void 0,__vue_is_functional_template__$5=!1,__vue_component__$4=normalizeComponent$1({render:__vue_render__$4,staticRenderFns:__vue_staticRenderFns__$4},__vue_inject_styles__$5,__vue_script__$5,__vue_scope_id__$5,__vue_is_functional_template__$5,__vue_module_identifier__$5,!1,void 0,void 0,void 0);
/* scoped */function styleInject(css,ref){void 0===ref&&(ref={});var insertAt=ref.insertAt;if(css&&"undefined"!==typeof document){var head=document.head||document.getElementsByTagName("head")[0],style=document.createElement("style");style.type="text/css","top"===insertAt&&head.firstChild?head.insertBefore(style,head.firstChild):head.appendChild(style),style.styleSheet?style.styleSheet.cssText=css:style.appendChild(document.createTextNode(css))}}var css_248z=".resize-observer[data-v-8859cc6c]{position:absolute;top:0;left:0;z-index:-1;width:100%;height:100%;border:none;background-color:transparent;pointer-events:none;display:block;overflow:hidden;opacity:0}.resize-observer[data-v-8859cc6c] object{display:block;position:absolute;top:0;left:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1}";function install(Vue){var options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!install.installed){install.installed=!0;var finalOptions={};merge(finalOptions,defaultOptions,options),plugin$1.options=finalOptions,directive.options=finalOptions,Vue.directive("tooltip",directive),Vue.directive("close-popover",vclosepopover),Vue.component("VPopover",__vue_component__$4)}}styleInject(css_248z);var VTooltip=directive,plugin$1={install:install,get enabled(){return state.enabled},set enabled(value){state.enabled=value}},GlobalVue=null;"undefined"!==typeof window?GlobalVue=window.Vue:"undefined"!==typeof global&&(GlobalVue=global.Vue),GlobalVue&&GlobalVue.use(plugin$1)
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */;var isBrowser="undefined"!==typeof window&&"undefined"!==typeof document&&"undefined"!==typeof navigator,timeoutDuration=function(){for(var longerTimeoutBrowsers=["Edge","Trident","Firefox"],i=0;i<longerTimeoutBrowsers.length;i+=1)if(isBrowser&&navigator.userAgent.indexOf(longerTimeoutBrowsers[i])>=0)return 1;return 0}();function microtaskDebounce(fn){var called=!1;return function(){called||(called=!0,window.Promise.resolve().then((function(){called=!1,fn()})))}}function taskDebounce(fn){var scheduled=!1;return function(){scheduled||(scheduled=!0,setTimeout((function(){scheduled=!1,fn()}),timeoutDuration))}}var supportsMicroTasks=isBrowser&&window.Promise,forms_debounce=supportsMicroTasks?microtaskDebounce:taskDebounce;
/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function forms_isFunction(functionToCheck){var getType={};return functionToCheck&&"[object Function]"===getType.toString.call(functionToCheck)}
/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */function getStyleComputedProperty(element,property){if(1!==element.nodeType)return[];
// NOTE: 1 DOM access here
var window=element.ownerDocument.defaultView,css=window.getComputedStyle(element,null);return property?css[property]:css}
/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */function getParentNode(element){return"HTML"===element.nodeName?element:element.parentNode||element.host}
/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */function getScrollParent(element){
// Return body, `getScroll` will take care to get the correct `scrollTop` from it
if(!element)return document.body;switch(element.nodeName){case"HTML":case"BODY":return element.ownerDocument.body;case"#document":return element.body}
// Firefox want us to check `-x` and `-y` variations as well
var _getStyleComputedProp=getStyleComputedProperty(element),overflow=_getStyleComputedProp.overflow,overflowX=_getStyleComputedProp.overflowX,overflowY=_getStyleComputedProp.overflowY;return/(auto|scroll|overlay)/.test(overflow+overflowY+overflowX)?element:getScrollParent(getParentNode(element))}
/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */function getReferenceNode(reference){return reference&&reference.referenceNode?reference.referenceNode:reference}var isIE11=isBrowser&&!(!window.MSInputMethodContext||!document.documentMode),isIE10=isBrowser&&/MSIE 10/.test(navigator.userAgent);
/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version){return 11===version?isIE11:10===version?isIE10:isIE11||isIE10}
/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */function getOffsetParent(element){if(!element)return document.documentElement;var noOffsetParent=isIE(10)?document.body:null,offsetParent=element.offsetParent||null;
// NOTE: 1 DOM access here
// Skip hidden elements which don't have an offsetParent
while(offsetParent===noOffsetParent&&element.nextElementSibling)offsetParent=(element=element.nextElementSibling).offsetParent;var nodeName=offsetParent&&offsetParent.nodeName;return nodeName&&"BODY"!==nodeName&&"HTML"!==nodeName?
// .offsetParent will return the closest TH, TD or TABLE in case
// no offsetParent is present, I hate this job...
-1!==["TH","TD","TABLE"].indexOf(offsetParent.nodeName)&&"static"===getStyleComputedProperty(offsetParent,"position")?getOffsetParent(offsetParent):offsetParent:element?element.ownerDocument.documentElement:document.documentElement}function isOffsetContainer(element){var nodeName=element.nodeName;return"BODY"!==nodeName&&("HTML"===nodeName||getOffsetParent(element.firstElementChild)===element)}
/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */function getRoot(node){return null!==node.parentNode?getRoot(node.parentNode):node}
/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */function findCommonOffsetParent(element1,element2){
// This check is needed to avoid errors in case one of the elements isn't defined for any reason
if(!element1||!element1.nodeType||!element2||!element2.nodeType)return document.documentElement;
// Here we make sure to give as "start" the element that comes first in the DOM
var order=element1.compareDocumentPosition(element2)&Node.DOCUMENT_POSITION_FOLLOWING,start=order?element1:element2,end=order?element2:element1,range=document.createRange();range.setStart(start,0),range.setEnd(end,0);var commonAncestorContainer=range.commonAncestorContainer;
// Both nodes are inside #document
if(element1!==commonAncestorContainer&&element2!==commonAncestorContainer||start.contains(end))return isOffsetContainer(commonAncestorContainer)?commonAncestorContainer:getOffsetParent(commonAncestorContainer);
// one of the nodes is inside shadowDOM, find which one
var element1root=getRoot(element1);return element1root.host?findCommonOffsetParent(element1root.host,element2):findCommonOffsetParent(element1,getRoot(element2).host)}
/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */function getScroll(element){var side=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"top",upperSide="top"===side?"scrollTop":"scrollLeft",nodeName=element.nodeName;if("BODY"===nodeName||"HTML"===nodeName){var html=element.ownerDocument.documentElement,scrollingElement=element.ownerDocument.scrollingElement||html;return scrollingElement[upperSide]}return element[upperSide]}
/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */function includeScroll(rect,element){var subtract=arguments.length>2&&void 0!==arguments[2]&&arguments[2],scrollTop=getScroll(element,"top"),scrollLeft=getScroll(element,"left"),modifier=subtract?-1:1;return rect.top+=scrollTop*modifier,rect.bottom+=scrollTop*modifier,rect.left+=scrollLeft*modifier,rect.right+=scrollLeft*modifier,rect}
/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */function getBordersSize(styles,axis){var sideA="x"===axis?"Left":"Top",sideB="Left"===sideA?"Right":"Bottom";return parseFloat(styles["border"+sideA+"Width"])+parseFloat(styles["border"+sideB+"Width"])}function getSize(axis,body,html,computedStyle){return Math.max(body["offset"+axis],body["scroll"+axis],html["client"+axis],html["offset"+axis],html["scroll"+axis],isIE(10)?parseInt(html["offset"+axis])+parseInt(computedStyle["margin"+("Height"===axis?"Top":"Left")])+parseInt(computedStyle["margin"+("Height"===axis?"Bottom":"Right")]):0)}function getWindowSizes(document){var body=document.body,html=document.documentElement,computedStyle=isIE(10)&&getComputedStyle(html);return{height:getSize("Height",body,html,computedStyle),width:getSize("Width",body,html,computedStyle)}}var classCallCheck=function(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")},createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),defineProperty=function(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj},_extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target};
/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets){return _extends({},offsets,{right:offsets.left+offsets.width,bottom:offsets.top+offsets.height})}
/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */function getBoundingClientRect(element){var rect={};
// IE10 10 FIX: Please, don't ask, the element isn't
// considered in DOM in some circumstances...
// This isn't reproducible in IE10 compatibility mode of IE11
try{if(isIE(10)){rect=element.getBoundingClientRect();var scrollTop=getScroll(element,"top"),scrollLeft=getScroll(element,"left");rect.top+=scrollTop,rect.left+=scrollLeft,rect.bottom+=scrollTop,rect.right+=scrollLeft}else rect=element.getBoundingClientRect()}catch(e){}var result={left:rect.left,top:rect.top,width:rect.right-rect.left,height:rect.bottom-rect.top},sizes="HTML"===element.nodeName?getWindowSizes(element.ownerDocument):{},width=sizes.width||element.clientWidth||result.width,height=sizes.height||element.clientHeight||result.height,horizScrollbar=element.offsetWidth-width,vertScrollbar=element.offsetHeight-height;
// subtract scrollbar size from sizes
// if an hypothetical scrollbar is detected, we must be sure it's not a `border`
// we make this check conditional for performance reasons
if(horizScrollbar||vertScrollbar){var styles=getStyleComputedProperty(element);horizScrollbar-=getBordersSize(styles,"x"),vertScrollbar-=getBordersSize(styles,"y"),result.width-=horizScrollbar,result.height-=vertScrollbar}return getClientRect(result)}function getOffsetRectRelativeToArbitraryNode(children,parent){var fixedPosition=arguments.length>2&&void 0!==arguments[2]&&arguments[2],isIE10=isIE(10),isHTML="HTML"===parent.nodeName,childrenRect=getBoundingClientRect(children),parentRect=getBoundingClientRect(parent),scrollParent=getScrollParent(children),styles=getStyleComputedProperty(parent),borderTopWidth=parseFloat(styles.borderTopWidth),borderLeftWidth=parseFloat(styles.borderLeftWidth);
// In cases where the parent is fixed, we must ignore negative scroll in offset calc
fixedPosition&&isHTML&&(parentRect.top=Math.max(parentRect.top,0),parentRect.left=Math.max(parentRect.left,0));var offsets=getClientRect({top:childrenRect.top-parentRect.top-borderTopWidth,left:childrenRect.left-parentRect.left-borderLeftWidth,width:childrenRect.width,height:childrenRect.height});
// Subtract margins of documentElement in case it's being used as parent
// we do this only on HTML because it's the only element that behaves
// differently when margins are applied to it. The margins are included in
// the box of the documentElement, in the other cases not.
if(offsets.marginTop=0,offsets.marginLeft=0,!isIE10&&isHTML){var marginTop=parseFloat(styles.marginTop),marginLeft=parseFloat(styles.marginLeft);offsets.top-=borderTopWidth-marginTop,offsets.bottom-=borderTopWidth-marginTop,offsets.left-=borderLeftWidth-marginLeft,offsets.right-=borderLeftWidth-marginLeft,
// Attach marginTop and marginLeft because in some circumstances we may need them
offsets.marginTop=marginTop,offsets.marginLeft=marginLeft}return(isIE10&&!fixedPosition?parent.contains(scrollParent):parent===scrollParent&&"BODY"!==scrollParent.nodeName)&&(offsets=includeScroll(offsets,parent)),offsets}function getViewportOffsetRectRelativeToArtbitraryNode(element){var excludeScroll=arguments.length>1&&void 0!==arguments[1]&&arguments[1],html=element.ownerDocument.documentElement,relativeOffset=getOffsetRectRelativeToArbitraryNode(element,html),width=Math.max(html.clientWidth,window.innerWidth||0),height=Math.max(html.clientHeight,window.innerHeight||0),scrollTop=excludeScroll?0:getScroll(html),scrollLeft=excludeScroll?0:getScroll(html,"left"),offset={top:scrollTop-relativeOffset.top+relativeOffset.marginTop,left:scrollLeft-relativeOffset.left+relativeOffset.marginLeft,width:width,height:height};return getClientRect(offset)}
/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */function isFixed(element){var nodeName=element.nodeName;if("BODY"===nodeName||"HTML"===nodeName)return!1;if("fixed"===getStyleComputedProperty(element,"position"))return!0;var parentNode=getParentNode(element);return!!parentNode&&isFixed(parentNode)}
/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */function getFixedPositionOffsetParent(element){
// This check is needed to avoid errors in case one of the elements isn't defined for any reason
if(!element||!element.parentElement||isIE())return document.documentElement;var el=element.parentElement;while(el&&"none"===getStyleComputedProperty(el,"transform"))el=el.parentElement;return el||document.documentElement}
/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */function getBoundaries(popper,reference,padding,boundariesElement){var fixedPosition=arguments.length>4&&void 0!==arguments[4]&&arguments[4],boundaries={top:0,left:0},offsetParent=fixedPosition?getFixedPositionOffsetParent(popper):findCommonOffsetParent(popper,getReferenceNode(reference));
// NOTE: 1 DOM access here
// Handle viewport case
if("viewport"===boundariesElement)boundaries=getViewportOffsetRectRelativeToArtbitraryNode(offsetParent,fixedPosition);else{
// Handle other cases based on DOM element used as boundaries
var boundariesNode=void 0;"scrollParent"===boundariesElement?(boundariesNode=getScrollParent(getParentNode(reference)),"BODY"===boundariesNode.nodeName&&(boundariesNode=popper.ownerDocument.documentElement)):boundariesNode="window"===boundariesElement?popper.ownerDocument.documentElement:boundariesElement;var offsets=getOffsetRectRelativeToArbitraryNode(boundariesNode,offsetParent,fixedPosition);
// In case of HTML, we need a different computation
if("HTML"!==boundariesNode.nodeName||isFixed(offsetParent))
// for all the other DOM elements, this one is good
boundaries=offsets;else{var _getWindowSizes=getWindowSizes(popper.ownerDocument),height=_getWindowSizes.height,width=_getWindowSizes.width;boundaries.top+=offsets.top-offsets.marginTop,boundaries.bottom=height+offsets.top,boundaries.left+=offsets.left-offsets.marginLeft,boundaries.right=width+offsets.left}}
// Add paddings
padding=padding||0;var isPaddingNumber="number"===typeof padding;return boundaries.left+=isPaddingNumber?padding:padding.left||0,boundaries.top+=isPaddingNumber?padding:padding.top||0,boundaries.right-=isPaddingNumber?padding:padding.right||0,boundaries.bottom-=isPaddingNumber?padding:padding.bottom||0,boundaries}function getArea(_ref){var width=_ref.width,height=_ref.height;return width*height}
/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function computeAutoPlacement(placement,refRect,popper,reference,boundariesElement){var padding=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(-1===placement.indexOf("auto"))return placement;var boundaries=getBoundaries(popper,reference,padding,boundariesElement),rects={top:{width:boundaries.width,height:refRect.top-boundaries.top},right:{width:boundaries.right-refRect.right,height:boundaries.height},bottom:{width:boundaries.width,height:boundaries.bottom-refRect.bottom},left:{width:refRect.left-boundaries.left,height:boundaries.height}},sortedAreas=Object.keys(rects).map((function(key){return _extends({key:key},rects[key],{area:getArea(rects[key])})})).sort((function(a,b){return b.area-a.area})),filteredAreas=sortedAreas.filter((function(_ref2){var width=_ref2.width,height=_ref2.height;return width>=popper.clientWidth&&height>=popper.clientHeight})),computedPlacement=filteredAreas.length>0?filteredAreas[0].key:sortedAreas[0].key,variation=placement.split("-")[1];return computedPlacement+(variation?"-"+variation:"")}
/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */function getReferenceOffsets(state,popper,reference){var fixedPosition=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,commonOffsetParent=fixedPosition?getFixedPositionOffsetParent(popper):findCommonOffsetParent(popper,getReferenceNode(reference));return getOffsetRectRelativeToArbitraryNode(reference,commonOffsetParent,fixedPosition)}
/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */function getOuterSizes(element){var window=element.ownerDocument.defaultView,styles=window.getComputedStyle(element),x=parseFloat(styles.marginTop||0)+parseFloat(styles.marginBottom||0),y=parseFloat(styles.marginLeft||0)+parseFloat(styles.marginRight||0),result={width:element.offsetWidth+y,height:element.offsetHeight+x};return result}
/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */function getOppositePlacement(placement){var hash={left:"right",right:"left",bottom:"top",top:"bottom"};return placement.replace(/left|right|bottom|top/g,(function(matched){return hash[matched]}))}
/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */function getPopperOffsets(popper,referenceOffsets,placement){placement=placement.split("-")[0];
// Get popper node sizes
var popperRect=getOuterSizes(popper),popperOffsets={width:popperRect.width,height:popperRect.height},isHoriz=-1!==["right","left"].indexOf(placement),mainSide=isHoriz?"top":"left",secondarySide=isHoriz?"left":"top",measurement=isHoriz?"height":"width",secondaryMeasurement=isHoriz?"width":"height";
// Add position, width and height to our offsets object
return popperOffsets[mainSide]=referenceOffsets[mainSide]+referenceOffsets[measurement]/2-popperRect[measurement]/2,popperOffsets[secondarySide]=placement===secondarySide?referenceOffsets[secondarySide]-popperRect[secondaryMeasurement]:referenceOffsets[getOppositePlacement(secondarySide)],popperOffsets}
/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */function find(arr,check){
// use native find if supported
return Array.prototype.find?arr.find(check):arr.filter(check)[0];
// use `filter` to obtain the same behavior of `find`
}
/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */function findIndex(arr,prop,value){
// use native findIndex if supported
if(Array.prototype.findIndex)return arr.findIndex((function(cur){return cur[prop]===value}));
// use `find` + `indexOf` if `findIndex` isn't supported
var match=find(arr,(function(obj){return obj[prop]===value}));return arr.indexOf(match)}
/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */function runModifiers(modifiers,data,ends){var modifiersToRun=void 0===ends?modifiers:modifiers.slice(0,findIndex(modifiers,"name",ends));return modifiersToRun.forEach((function(modifier){modifier["function"];var fn=modifier["function"]||modifier.fn;// eslint-disable-line dot-notation
modifier.enabled&&forms_isFunction(fn)&&(
// Add properties to offsets to make them a complete clientRect object
// we do this before each modifier to make sure the previous one doesn't
// mess with these values
data.offsets.popper=getClientRect(data.offsets.popper),data.offsets.reference=getClientRect(data.offsets.reference),data=fn(data,modifier))})),data}
/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */function update(){
// if popper is destroyed, don't perform any further update
if(!this.state.isDestroyed){var data={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};
// compute reference element offsets
data.offsets.reference=getReferenceOffsets(this.state,this.popper,this.reference,this.options.positionFixed),
// compute auto placement, store placement inside the data object,
// modifiers will be able to edit `placement` if needed
// and refer to originalPlacement to know the original value
data.placement=computeAutoPlacement(this.options.placement,data.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),
// store the computed placement inside `originalPlacement`
data.originalPlacement=data.placement,data.positionFixed=this.options.positionFixed,
// compute the popper offsets
data.offsets.popper=getPopperOffsets(this.popper,data.offsets.reference,data.placement),data.offsets.popper.position=this.options.positionFixed?"fixed":"absolute",
// run the modifiers
data=runModifiers(this.modifiers,data),
// the first `update` will call `onCreate` callback
// the other ones will call `onUpdate` callback
this.state.isCreated?this.options.onUpdate(data):(this.state.isCreated=!0,this.options.onCreate(data))}}
/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */function isModifierEnabled(modifiers,modifierName){return modifiers.some((function(_ref){var name=_ref.name,enabled=_ref.enabled;return enabled&&name===modifierName}))}
/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */function getSupportedPropertyName(property){for(var prefixes=[!1,"ms","Webkit","Moz","O"],upperProp=property.charAt(0).toUpperCase()+property.slice(1),i=0;i<prefixes.length;i++){var prefix=prefixes[i],toCheck=prefix?""+prefix+upperProp:property;if("undefined"!==typeof document.body.style[toCheck])return toCheck}return null}
/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */function destroy(){return this.state.isDestroyed=!0,
// touch DOM only if `applyStyle` modifier is enabled
isModifierEnabled(this.modifiers,"applyStyle")&&(this.popper.removeAttribute("x-placement"),this.popper.style.position="",this.popper.style.top="",this.popper.style.left="",this.popper.style.right="",this.popper.style.bottom="",this.popper.style.willChange="",this.popper.style[getSupportedPropertyName("transform")]=""),this.disableEventListeners(),
// remove the popper if user explicitly asked for the deletion on destroy
// do not use `remove` because IE11 doesn't support it
this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}
/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */function getWindow(element){var ownerDocument=element.ownerDocument;return ownerDocument?ownerDocument.defaultView:window}function attachToScrollParents(scrollParent,event,callback,scrollParents){var isBody="BODY"===scrollParent.nodeName,target=isBody?scrollParent.ownerDocument.defaultView:scrollParent;target.addEventListener(event,callback,{passive:!0}),isBody||attachToScrollParents(getScrollParent(target.parentNode),event,callback,scrollParents),scrollParents.push(target)}
/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */function setupEventListeners(reference,options,state,updateBound){
// Resize event listener on window
state.updateBound=updateBound,getWindow(reference).addEventListener("resize",state.updateBound,{passive:!0});
// Scroll event listener on scroll parents
var scrollElement=getScrollParent(reference);return attachToScrollParents(scrollElement,"scroll",state.updateBound,state.scrollParents),state.scrollElement=scrollElement,state.eventsEnabled=!0,state}
/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */function enableEventListeners(){this.state.eventsEnabled||(this.state=setupEventListeners(this.reference,this.options,this.state,this.scheduleUpdate))}
/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */function removeEventListeners(reference,state){
// Remove resize event listener on window
return getWindow(reference).removeEventListener("resize",state.updateBound),
// Remove scroll event listener on scroll parents
state.scrollParents.forEach((function(target){target.removeEventListener("scroll",state.updateBound)})),
// Reset state
state.updateBound=null,state.scrollParents=[],state.scrollElement=null,state.eventsEnabled=!1,state}
/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */function disableEventListeners(){this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=removeEventListeners(this.reference,this.state))}
/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */function isNumeric(n){return""!==n&&!isNaN(parseFloat(n))&&isFinite(n)}
/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */function setStyles(element,styles){Object.keys(styles).forEach((function(prop){var unit="";
// add unit if the value is numeric and is one of the following
-1!==["width","height","top","right","bottom","left"].indexOf(prop)&&isNumeric(styles[prop])&&(unit="px"),element.style[prop]=styles[prop]+unit}))}
/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */function setAttributes(element,attributes){Object.keys(attributes).forEach((function(prop){var value=attributes[prop];!1!==value?element.setAttribute(prop,attributes[prop]):element.removeAttribute(prop)}))}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */function applyStyle(data){
// any property present in `data.styles` will be applied to the popper,
// in this way we can make the 3rd party modifiers add custom styles to it
// Be aware, modifiers could override the properties defined in the previous
// lines of this modifier!
return setStyles(data.instance.popper,data.styles),
// any property present in `data.attributes` will be applied to the popper,
// they will be set as HTML attributes of the element
setAttributes(data.instance.popper,data.attributes),
// if arrowElement is defined and arrowStyles has some properties
data.arrowElement&&Object.keys(data.arrowStyles).length&&setStyles(data.arrowElement,data.arrowStyles),data}
/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */function applyStyleOnLoad(reference,popper,options,modifierOptions,state){
// compute reference element offsets
var referenceOffsets=getReferenceOffsets(state,popper,reference,options.positionFixed),placement=computeAutoPlacement(options.placement,referenceOffsets,popper,reference,options.modifiers.flip.boundariesElement,options.modifiers.flip.padding);
// compute auto placement, store placement inside the data object,
// modifiers will be able to edit `placement` if needed
// and refer to originalPlacement to know the original value
return popper.setAttribute("x-placement",placement),
// Apply `position` to popper before anything else because
// without the position applied we can't guarantee correct computations
setStyles(popper,{position:options.positionFixed?"fixed":"absolute"}),options}
/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */function getRoundedOffsets(data,shouldRound){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,round=Math.round,floor=Math.floor,noRound=function(v){return v},referenceWidth=round(reference.width),popperWidth=round(popper.width),isVertical=-1!==["left","right"].indexOf(data.placement),isVariation=-1!==data.placement.indexOf("-"),sameWidthParity=referenceWidth%2===popperWidth%2,bothOddWidth=referenceWidth%2===1&&popperWidth%2===1,horizontalToInteger=shouldRound?isVertical||isVariation||sameWidthParity?round:floor:noRound,verticalToInteger=shouldRound?round:noRound;return{left:horizontalToInteger(bothOddWidth&&!isVariation&&shouldRound?popper.left-1:popper.left),top:verticalToInteger(popper.top),bottom:verticalToInteger(popper.bottom),right:horizontalToInteger(popper.right)}}var isFirefox=isBrowser&&/Firefox/i.test(navigator.userAgent);
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function computeStyle(data,options){var x=options.x,y=options.y,popper=data.offsets.popper,legacyGpuAccelerationOption=find(data.instance.modifiers,(function(modifier){return"applyStyle"===modifier.name})).gpuAcceleration,gpuAcceleration=void 0!==legacyGpuAccelerationOption?legacyGpuAccelerationOption:options.gpuAcceleration,offsetParent=getOffsetParent(data.instance.popper),offsetParentRect=getBoundingClientRect(offsetParent),styles={position:popper.position},offsets=getRoundedOffsets(data,window.devicePixelRatio<2||!isFirefox),sideA="bottom"===x?"top":"bottom",sideB="right"===y?"left":"right",prefixedProperty=getSupportedPropertyName("transform"),left=void 0,top=void 0;if(top="bottom"===sideA?
// when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
// and not the bottom of the html element
"HTML"===offsetParent.nodeName?-offsetParent.clientHeight+offsets.bottom:-offsetParentRect.height+offsets.bottom:offsets.top,left="right"===sideB?"HTML"===offsetParent.nodeName?-offsetParent.clientWidth+offsets.right:-offsetParentRect.width+offsets.right:offsets.left,gpuAcceleration&&prefixedProperty)styles[prefixedProperty]="translate3d("+left+"px, "+top+"px, 0)",styles[sideA]=0,styles[sideB]=0,styles.willChange="transform";else{
// othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
var invertTop="bottom"===sideA?-1:1,invertLeft="right"===sideB?-1:1;styles[sideA]=top*invertTop,styles[sideB]=left*invertLeft,styles.willChange=sideA+", "+sideB}
// Attributes
var attributes={"x-placement":data.placement};
// Update `data` attributes, styles and arrowStyles
return data.attributes=_extends({},attributes,data.attributes),data.styles=_extends({},styles,data.styles),data.arrowStyles=_extends({},data.offsets.arrow,data.arrowStyles),data}
/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */function isModifierRequired(modifiers,requestingName,requestedName){var requesting=find(modifiers,(function(_ref){var name=_ref.name;return name===requestingName})),isRequired=!!requesting&&modifiers.some((function(modifier){return modifier.name===requestedName&&modifier.enabled&&modifier.order<requesting.order}));if(!isRequired);return isRequired}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function arrow(data,options){var _data$offsets$arrow;
// arrow depends on keepTogether in order to work
if(!isModifierRequired(data.instance.modifiers,"arrow","keepTogether"))return data;var arrowElement=options.element;
// if arrowElement is a string, suppose it's a CSS selector
if("string"===typeof arrowElement){
// if arrowElement is not found, don't run the modifier
if(arrowElement=data.instance.popper.querySelector(arrowElement),!arrowElement)return data}else
// if the arrowElement isn't a query selector we must check that the
// provided DOM node is child of its popper node
if(!data.instance.popper.contains(arrowElement))return data;var placement=data.placement.split("-")[0],_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,isVertical=-1!==["left","right"].indexOf(placement),len=isVertical?"height":"width",sideCapitalized=isVertical?"Top":"Left",side=sideCapitalized.toLowerCase(),altSide=isVertical?"left":"top",opSide=isVertical?"bottom":"right",arrowElementSize=getOuterSizes(arrowElement)[len];
// extends keepTogether behavior making sure the popper and its
// reference have enough pixels in conjunction
// top/left side
reference[opSide]-arrowElementSize<popper[side]&&(data.offsets.popper[side]-=popper[side]-(reference[opSide]-arrowElementSize)),
// bottom/right side
reference[side]+arrowElementSize>popper[opSide]&&(data.offsets.popper[side]+=reference[side]+arrowElementSize-popper[opSide]),data.offsets.popper=getClientRect(data.offsets.popper);
// compute center of the popper
var center=reference[side]+reference[len]/2-arrowElementSize/2,css=getStyleComputedProperty(data.instance.popper),popperMarginSide=parseFloat(css["margin"+sideCapitalized]),popperBorderSide=parseFloat(css["border"+sideCapitalized+"Width"]),sideValue=center-data.offsets.popper[side]-popperMarginSide-popperBorderSide;
// Compute the sideValue using the updated popper offsets
// take popper margin in account because we don't have this info available
// prevent arrowElement from being placed not contiguously to its popper
return sideValue=Math.max(Math.min(popper[len]-arrowElementSize,sideValue),0),data.arrowElement=arrowElement,data.offsets.arrow=(_data$offsets$arrow={},defineProperty(_data$offsets$arrow,side,Math.round(sideValue)),defineProperty(_data$offsets$arrow,altSide,""),_data$offsets$arrow),data}
/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */function getOppositeVariation(variation){return"end"===variation?"start":"start"===variation?"end":variation}
/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */var placements=["auto-start","auto","auto-end","top-start","top","top-end","right-start","right","right-end","bottom-end","bottom","bottom-start","left-end","left","left-start"],validPlacements=placements.slice(3);
// Get rid of `auto` `auto-start` and `auto-end`
/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement){var counter=arguments.length>1&&void 0!==arguments[1]&&arguments[1],index=validPlacements.indexOf(placement),arr=validPlacements.slice(index+1).concat(validPlacements.slice(0,index));return counter?arr.reverse():arr}var BEHAVIORS={FLIP:"flip",CLOCKWISE:"clockwise",COUNTERCLOCKWISE:"counterclockwise"};
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function flip(data,options){
// if `inner` modifier is enabled, we can't use the `flip` modifier
if(isModifierEnabled(data.instance.modifiers,"inner"))return data;if(data.flipped&&data.placement===data.originalPlacement)
// seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
return data;var boundaries=getBoundaries(data.instance.popper,data.instance.reference,options.padding,options.boundariesElement,data.positionFixed),placement=data.placement.split("-")[0],placementOpposite=getOppositePlacement(placement),variation=data.placement.split("-")[1]||"",flipOrder=[];switch(options.behavior){case BEHAVIORS.FLIP:flipOrder=[placement,placementOpposite];break;case BEHAVIORS.CLOCKWISE:flipOrder=clockwise(placement);break;case BEHAVIORS.COUNTERCLOCKWISE:flipOrder=clockwise(placement,!0);break;default:flipOrder=options.behavior}return flipOrder.forEach((function(step,index){if(placement!==step||flipOrder.length===index+1)return data;placement=data.placement.split("-")[0],placementOpposite=getOppositePlacement(placement);var popperOffsets=data.offsets.popper,refOffsets=data.offsets.reference,floor=Math.floor,overlapsRef="left"===placement&&floor(popperOffsets.right)>floor(refOffsets.left)||"right"===placement&&floor(popperOffsets.left)<floor(refOffsets.right)||"top"===placement&&floor(popperOffsets.bottom)>floor(refOffsets.top)||"bottom"===placement&&floor(popperOffsets.top)<floor(refOffsets.bottom),overflowsLeft=floor(popperOffsets.left)<floor(boundaries.left),overflowsRight=floor(popperOffsets.right)>floor(boundaries.right),overflowsTop=floor(popperOffsets.top)<floor(boundaries.top),overflowsBottom=floor(popperOffsets.bottom)>floor(boundaries.bottom),overflowsBoundaries="left"===placement&&overflowsLeft||"right"===placement&&overflowsRight||"top"===placement&&overflowsTop||"bottom"===placement&&overflowsBottom,isVertical=-1!==["top","bottom"].indexOf(placement),flippedVariationByRef=!!options.flipVariations&&(isVertical&&"start"===variation&&overflowsLeft||isVertical&&"end"===variation&&overflowsRight||!isVertical&&"start"===variation&&overflowsTop||!isVertical&&"end"===variation&&overflowsBottom),flippedVariationByContent=!!options.flipVariationsByContent&&(isVertical&&"start"===variation&&overflowsRight||isVertical&&"end"===variation&&overflowsLeft||!isVertical&&"start"===variation&&overflowsBottom||!isVertical&&"end"===variation&&overflowsTop),flippedVariation=flippedVariationByRef||flippedVariationByContent;(overlapsRef||overflowsBoundaries||flippedVariation)&&(
// this boolean to detect any flip loop
data.flipped=!0,(overlapsRef||overflowsBoundaries)&&(placement=flipOrder[index+1]),flippedVariation&&(variation=getOppositeVariation(variation)),data.placement=placement+(variation?"-"+variation:""),
// this object contains `position`, we want to preserve it along with
// any additional property we may add in the future
data.offsets.popper=_extends({},data.offsets.popper,getPopperOffsets(data.instance.popper,data.offsets.reference,data.placement)),data=runModifiers(data.instance.modifiers,data,"flip"))})),data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function keepTogether(data){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,placement=data.placement.split("-")[0],floor=Math.floor,isVertical=-1!==["top","bottom"].indexOf(placement),side=isVertical?"right":"bottom",opSide=isVertical?"left":"top",measurement=isVertical?"width":"height";return popper[side]<floor(reference[opSide])&&(data.offsets.popper[opSide]=floor(reference[opSide])-popper[measurement]),popper[opSide]>floor(reference[side])&&(data.offsets.popper[opSide]=floor(reference[side])),data}
/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */function toValue(str,measurement,popperOffsets,referenceOffsets){
// separate value from unit
var split=str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),value=+split[1],unit=split[2];
// If it's not a number it's an operator, I guess
if(!value)return str;if(0===unit.indexOf("%")){var element=void 0;switch(unit){case"%p":element=popperOffsets;break;case"%":case"%r":default:element=referenceOffsets}var rect=getClientRect(element);return rect[measurement]/100*value}if("vh"===unit||"vw"===unit){
// if is a vh or vw, we calculate the size based on the viewport
var size=void 0;return size="vh"===unit?Math.max(document.documentElement.clientHeight,window.innerHeight||0):Math.max(document.documentElement.clientWidth,window.innerWidth||0),size/100*value}
// if is an explicit pixel unit, we get rid of the unit and keep the value
// if is an implicit unit, it's px, and we return just the value
return value}
/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */function parseOffset(offset,popperOffsets,referenceOffsets,basePlacement){var offsets=[0,0],useHeight=-1!==["right","left"].indexOf(basePlacement),fragments=offset.split(/(\+|\-)/).map((function(frag){return frag.trim()})),divider=fragments.indexOf(find(fragments,(function(frag){return-1!==frag.search(/,|\s/)})));
// Use height if placement is left or right and index is 0 otherwise use width
// in this way the first offset will use an axis and the second one
// will use the other one
fragments[divider]&&fragments[divider].indexOf(",");
// If divider is found, we divide the list of values and operands to divide
// them by ofset X and Y.
var splitRegex=/\s*,\s*|\s+/,ops=-1!==divider?[fragments.slice(0,divider).concat([fragments[divider].split(splitRegex)[0]]),[fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider+1))]:[fragments];
// Convert the values with units to absolute pixels to allow our computations
return ops=ops.map((function(op,index){
// Most of the units rely on the orientation of the popper
var measurement=(1===index?!useHeight:useHeight)?"height":"width",mergeWithPrevious=!1;return op.reduce((function(a,b){return""===a[a.length-1]&&-1!==["+","-"].indexOf(b)?(a[a.length-1]=b,mergeWithPrevious=!0,a):mergeWithPrevious?(a[a.length-1]+=b,mergeWithPrevious=!1,a):a.concat(b)}),[]).map((function(str){return toValue(str,measurement,popperOffsets,referenceOffsets)}))})),
// Loop trough the offsets arrays and execute the operations
ops.forEach((function(op,index){op.forEach((function(frag,index2){isNumeric(frag)&&(offsets[index]+=frag*("-"===op[index2-1]?-1:1))}))})),offsets}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */function offset(data,_ref){var offset=_ref.offset,placement=data.placement,_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,basePlacement=placement.split("-")[0],offsets=void 0;return offsets=isNumeric(+offset)?[+offset,0]:parseOffset(offset,popper,reference,basePlacement),"left"===basePlacement?(popper.top+=offsets[0],popper.left-=offsets[1]):"right"===basePlacement?(popper.top+=offsets[0],popper.left+=offsets[1]):"top"===basePlacement?(popper.left+=offsets[0],popper.top-=offsets[1]):"bottom"===basePlacement&&(popper.left+=offsets[0],popper.top+=offsets[1]),data.popper=popper,data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function preventOverflow(data,options){var boundariesElement=options.boundariesElement||getOffsetParent(data.instance.popper);
// If offsetParent is the reference element, we really want to
// go one step up and use the next offsetParent as reference to
// avoid to make this modifier completely useless and look like broken
data.instance.reference===boundariesElement&&(boundariesElement=getOffsetParent(boundariesElement));
// NOTE: DOM access here
// resets the popper's position so that the document size can be calculated excluding
// the size of the popper element itself
var transformProp=getSupportedPropertyName("transform"),popperStyles=data.instance.popper.style,top=popperStyles.top,left=popperStyles.left,transform=popperStyles[transformProp];popperStyles.top="",popperStyles.left="",popperStyles[transformProp]="";var boundaries=getBoundaries(data.instance.popper,data.instance.reference,options.padding,boundariesElement,data.positionFixed);
// NOTE: DOM access here
// restores the original style properties after the offsets have been computed
popperStyles.top=top,popperStyles.left=left,popperStyles[transformProp]=transform,options.boundaries=boundaries;var order=options.priority,popper=data.offsets.popper,check={primary:function(placement){var value=popper[placement];return popper[placement]<boundaries[placement]&&!options.escapeWithReference&&(value=Math.max(popper[placement],boundaries[placement])),defineProperty({},placement,value)},secondary:function(placement){var mainSide="right"===placement?"left":"top",value=popper[mainSide];return popper[placement]>boundaries[placement]&&!options.escapeWithReference&&(value=Math.min(popper[mainSide],boundaries[placement]-("right"===placement?popper.width:popper.height))),defineProperty({},mainSide,value)}};return order.forEach((function(placement){var side=-1!==["left","top"].indexOf(placement)?"primary":"secondary";popper=_extends({},popper,check[side](placement))})),data.offsets.popper=popper,data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function shift(data){var placement=data.placement,basePlacement=placement.split("-")[0],shiftvariation=placement.split("-")[1];
// if shift shiftvariation is specified, run the modifier
if(shiftvariation){var _data$offsets=data.offsets,reference=_data$offsets.reference,popper=_data$offsets.popper,isVertical=-1!==["bottom","top"].indexOf(basePlacement),side=isVertical?"left":"top",measurement=isVertical?"width":"height",shiftOffsets={start:defineProperty({},side,reference[side]),end:defineProperty({},side,reference[side]+reference[measurement]-popper[measurement])};data.offsets.popper=_extends({},popper,shiftOffsets[shiftvariation])}return data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function hide(data){if(!isModifierRequired(data.instance.modifiers,"hide","preventOverflow"))return data;var refRect=data.offsets.reference,bound=find(data.instance.modifiers,(function(modifier){return"preventOverflow"===modifier.name})).boundaries;if(refRect.bottom<bound.top||refRect.left>bound.right||refRect.top>bound.bottom||refRect.right<bound.left){
// Avoid unnecessary DOM access if visibility hasn't changed
if(!0===data.hide)return data;data.hide=!0,data.attributes["x-out-of-boundaries"]=""}else{
// Avoid unnecessary DOM access if visibility hasn't changed
if(!1===data.hide)return data;data.hide=!1,data.attributes["x-out-of-boundaries"]=!1}return data}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */function inner(data){var placement=data.placement,basePlacement=placement.split("-")[0],_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference,isHoriz=-1!==["left","right"].indexOf(basePlacement),subtractLength=-1===["top","left"].indexOf(basePlacement);return popper[isHoriz?"left":"top"]=reference[basePlacement]-(subtractLength?popper[isHoriz?"width":"height"]:0),data.placement=getOppositePlacement(placement),data.offsets.popper=getClientRect(popper),data}
/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */
/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */var modifiers={
/**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
shift:{
/** @prop {number} order=100 - Index used to define the order of execution */
order:100,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:shift},
/**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
offset:{
/** @prop {number} order=200 - Index used to define the order of execution */
order:200,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:offset,
/** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
offset:0},
/**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
preventOverflow:{
/** @prop {number} order=300 - Index used to define the order of execution */
order:300,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:preventOverflow,
/**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
priority:["left","right","top","bottom"],
/**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
padding:5,
/**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
boundariesElement:"scrollParent"},
/**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
keepTogether:{
/** @prop {number} order=400 - Index used to define the order of execution */
order:400,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:keepTogether},
/**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
arrow:{
/** @prop {number} order=500 - Index used to define the order of execution */
order:500,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:arrow,
/** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
element:"[x-arrow]"},
/**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
flip:{
/** @prop {number} order=600 - Index used to define the order of execution */
order:600,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:flip,
/**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
behavior:"flip",
/**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
padding:5,
/**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
boundariesElement:"viewport",
/**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
flipVariations:!1,
/**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
flipVariationsByContent:!1},
/**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
inner:{
/** @prop {number} order=700 - Index used to define the order of execution */
order:700,
/** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
enabled:!1,
/** @prop {ModifierFn} */
fn:inner},
/**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
hide:{
/** @prop {number} order=800 - Index used to define the order of execution */
order:800,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:hide},
/**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
computeStyle:{
/** @prop {number} order=850 - Index used to define the order of execution */
order:850,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:computeStyle,
/**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
gpuAcceleration:!0,
/**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
x:"bottom",
/**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
y:"right"},
/**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
applyStyle:{
/** @prop {number} order=900 - Index used to define the order of execution */
order:900,
/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
enabled:!0,
/** @prop {ModifierFn} */
fn:applyStyle,
/** @prop {Function} */
onLoad:applyStyleOnLoad,
/**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
gpuAcceleration:void 0}},Defaults={
/**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
placement:"bottom",
/**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
positionFixed:!1,
/**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
eventsEnabled:!0,
/**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
removeOnDestroy:!1,
/**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
onCreate:function(){},
/**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
onUpdate:function(){},
/**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
modifiers:modifiers},Popper=function(){
/**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
function Popper(reference,popper){var _this=this,options=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};classCallCheck(this,Popper),this.scheduleUpdate=function(){return requestAnimationFrame(_this.update)},
// make update() debounced, so that it only runs at most once-per-tick
this.update=forms_debounce(this.update.bind(this)),
// with {} we create a new object with the options inside it
this.options=_extends({},Popper.Defaults,options),
// init state
this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},
// get reference and popper elements (allow jQuery wrappers)
this.reference=reference&&reference.jquery?reference[0]:reference,this.popper=popper&&popper.jquery?popper[0]:popper,
// Deep merge modifiers options
this.options.modifiers={},Object.keys(_extends({},Popper.Defaults.modifiers,options.modifiers)).forEach((function(name){_this.options.modifiers[name]=_extends({},Popper.Defaults.modifiers[name]||{},options.modifiers?options.modifiers[name]:{})})),
// Refactoring modifiers' list (Object => Array)
this.modifiers=Object.keys(this.options.modifiers).map((function(name){return _extends({name:name},_this.options.modifiers[name])})).sort((function(a,b){return a.order-b.order})),
// modifiers have the ability to execute arbitrary code when Popper.js get inited
// such code is executed in the same order of its modifier
// they could add new properties to their options configuration
// BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
this.modifiers.forEach((function(modifierOptions){modifierOptions.enabled&&forms_isFunction(modifierOptions.onLoad)&&modifierOptions.onLoad(_this.reference,_this.popper,_this.options,modifierOptions,_this.state)})),
// fire the first update to position the popper in the right place
this.update();var eventsEnabled=this.options.eventsEnabled;eventsEnabled&&
// setup event listeners, they will take care of update the position in specific situations
this.enableEventListeners(),this.state.eventsEnabled=eventsEnabled}
// We can't use class properties because they don't get listed in the
// class prototype and break stuff like Sinon stubs
return createClass(Popper,[{key:"update",value:function(){return update.call(this)}},{key:"destroy",value:function(){return destroy.call(this)}},{key:"enableEventListeners",value:function(){return enableEventListeners.call(this)}},{key:"disableEventListeners",value:function(){return disableEventListeners.call(this)}
/**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */
/**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */}]),Popper}();
/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */
/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */
Popper.Utils=("undefined"!==typeof window?window:global).PopperUtils,Popper.placements=placements,Popper.Defaults=Defaults;
/**!
* tippy.js v4.3.5
* (c) 2017-2019 atomiks
* MIT License
*/
var css='.tippy-iOS{cursor:pointer!important;-webkit-tap-highlight-color:transparent}.tippy-popper{transition-timing-function:cubic-bezier(.165,.84,.44,1);max-width:calc(100% - 8px);pointer-events:none;outline:0}.tippy-popper[x-placement^=top] .tippy-backdrop{border-radius:40% 40% 0 0}.tippy-popper[x-placement^=top] .tippy-roundarrow{bottom:-7px;bottom:-6.5px;-webkit-transform-origin:50% 0;transform-origin:50% 0;margin:0 3px}.tippy-popper[x-placement^=top] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(180deg);transform:rotate(180deg)}.tippy-popper[x-placement^=top] .tippy-arrow{border-top:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;bottom:-7px;margin:0 3px;-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=top] .tippy-backdrop{-webkit-transform-origin:0 25%;transform-origin:0 25%}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-55%);transform:scale(1) translate(-50%,-55%)}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%,-45%);transform:scale(.2) translate(-50%,-45%);opacity:0}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(-20px);transform:translateY(-20px)}.tippy-popper[x-placement^=top] [data-animation=perspective]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(-10px);transform:perspective(700px) translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateX(60deg);transform:perspective(700px) rotateX(60deg)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=top] [data-animation=scale]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px) scale(.5);transform:translateY(-10px) scale(.5)}.tippy-popper[x-placement^=bottom] .tippy-backdrop{border-radius:0 0 30% 30%}.tippy-popper[x-placement^=bottom] .tippy-roundarrow{top:-7px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%;margin:0 3px}.tippy-popper[x-placement^=bottom] .tippy-roundarrow svg{position:absolute;left:0}.tippy-popper[x-placement^=bottom] .tippy-arrow{border-bottom:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;top:-7px;margin:0 3px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%}.tippy-popper[x-placement^=bottom] .tippy-backdrop{-webkit-transform-origin:0 -50%;transform-origin:0 -50%}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-45%);transform:scale(1) translate(-50%,-45%)}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%);transform:scale(.2) translate(-50%);opacity:0}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(20px);transform:translateY(20px)}.tippy-popper[x-placement^=bottom] [data-animation=perspective]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(10px);transform:perspective(700px) translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateX(-60deg);transform:perspective(700px) rotateX(-60deg)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=bottom] [data-animation=scale]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px) scale(.5);transform:translateY(10px) scale(.5)}.tippy-popper[x-placement^=left] .tippy-backdrop{border-radius:50% 0 0 50%}.tippy-popper[x-placement^=left] .tippy-roundarrow{right:-12px;-webkit-transform-origin:33.33333333% 50%;transform-origin:33.33333333% 50%;margin:3px 0}.tippy-popper[x-placement^=left] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(90deg);transform:rotate(90deg)}.tippy-popper[x-placement^=left] .tippy-arrow{border-left:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;right:-7px;margin:3px 0;-webkit-transform-origin:0 50%;transform-origin:0 50%}.tippy-popper[x-placement^=left] .tippy-backdrop{-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-75%,-50%);transform:scale(.2) translate(-75%,-50%);opacity:0}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(-20px);transform:translateX(-20px)}.tippy-popper[x-placement^=left] [data-animation=perspective]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(-10px);transform:perspective(700px) translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateY(-60deg);transform:perspective(700px) rotateY(-60deg)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=left] [data-animation=scale]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px) scale(.5);transform:translateX(-10px) scale(.5)}.tippy-popper[x-placement^=right] .tippy-backdrop{border-radius:0 50% 50% 0}.tippy-popper[x-placement^=right] .tippy-roundarrow{left:-12px;-webkit-transform-origin:66.66666666% 50%;transform-origin:66.66666666% 50%;margin:3px 0}.tippy-popper[x-placement^=right] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.tippy-popper[x-placement^=right] .tippy-arrow{border-right:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;left:-7px;margin:3px 0;-webkit-transform-origin:100% 50%;transform-origin:100% 50%}.tippy-popper[x-placement^=right] .tippy-backdrop{-webkit-transform-origin:-50% 0;transform-origin:-50% 0}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-25%,-50%);transform:scale(.2) translate(-25%,-50%);opacity:0}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(20px);transform:translateX(20px)}.tippy-popper[x-placement^=right] [data-animation=perspective]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(10px);transform:perspective(700px) translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateY(60deg);transform:perspective(700px) rotateY(60deg)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=right] [data-animation=scale]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px) scale(.5);transform:translateX(10px) scale(.5)}.tippy-tooltip{position:relative;color:#fff;border-radius:.25rem;font-size:.875rem;padding:.3125rem .5625rem;line-height:1.4;text-align:center;background-color:#333}.tippy-tooltip[data-size=small]{padding:.1875rem .375rem;font-size:.75rem}.tippy-tooltip[data-size=large]{padding:.375rem .75rem;font-size:1rem}.tippy-tooltip[data-animatefill]{overflow:hidden;background-color:initial}.tippy-tooltip[data-interactive],.tippy-tooltip[data-interactive] .tippy-roundarrow path{pointer-events:auto}.tippy-tooltip[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-tooltip[data-inertia][data-state=hidden]{transition-timing-function:ease}.tippy-arrow,.tippy-roundarrow{position:absolute;width:0;height:0}.tippy-roundarrow{width:18px;height:7px;fill:#333;pointer-events:none}.tippy-backdrop{position:absolute;background-color:#333;border-radius:50%;width:calc(110% + 2rem);left:50%;top:50%;z-index:-1;transition:all cubic-bezier(.46,.1,.52,.98);-webkit-backface-visibility:hidden;backface-visibility:hidden}.tippy-backdrop:after{content:"";float:left;padding-top:100%}.tippy-backdrop+.tippy-content{transition-property:opacity;will-change:opacity}.tippy-backdrop+.tippy-content[data-state=hidden]{opacity:0}';function _extends$1(){return _extends$1=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},_extends$1.apply(this,arguments)}var version="4.3.5",isBrowser$1="undefined"!==typeof window&&"undefined"!==typeof document,ua=isBrowser$1?navigator.userAgent:"",isIE$1=/MSIE |Trident\//.test(ua),isUCBrowser=/UCBrowser\//.test(ua),isIOS=isBrowser$1&&/iPhone|iPad|iPod/.test(navigator.platform)&&!window.MSStream,defaultProps={a11y:!0,allowHTML:!0,animateFill:!0,animation:"shift-away",appendTo:function(){return document.body},aria:"describedby",arrow:!1,arrowType:"sharp",boundary:"scrollParent",content:"",delay:0,distance:10,duration:[325,275],flip:!0,flipBehavior:"flip",flipOnUpdate:!1,followCursor:!1,hideOnClick:!0,ignoreAttributes:!1,inertia:!1,interactive:!1,interactiveBorder:2,interactiveDebounce:0,lazy:!0,maxWidth:350,multiple:!1,offset:0,onHidden:function(){},onHide:function(){},onMount:function(){},onShow:function(){},onShown:function(){},onTrigger:function(){},placement:"top",popperOptions:{},role:"tooltip",showOnInit:!1,size:"regular",sticky:!1,target:"",theme:"dark",touch:!0,touchHold:!1,trigger:"mouseenter focus",triggerTarget:null,updateDuration:0,wait:null,zIndex:9999
/**
   * If the set() method encounters one of these, the popperInstance must be
   * recreated
   */},POPPER_INSTANCE_DEPENDENCIES=["arrow","arrowType","boundary","distance","flip","flipBehavior","flipOnUpdate","offset","placement","popperOptions"],elementProto=isBrowser$1?Element.prototype:{},matches=elementProto.matches||elementProto.matchesSelector||elementProto.webkitMatchesSelector||elementProto.mozMatchesSelector||elementProto.msMatchesSelector;
/**
 * Ponyfill for Array.from - converts iterable values to an array
 */
function arrayFrom(value){return[].slice.call(value)}
/**
 * Ponyfill for Element.prototype.closest
 */function closest(element,selector){return closestCallback(element,(function(el){return matches.call(el,selector)}))}
/**
 * Works like Element.prototype.closest, but uses a callback instead
 */function closestCallback(element,callback){while(element){if(callback(element))return element;element=element.parentElement}return null}
// Passive event listener config
var PASSIVE={passive:!0},PADDING=4,PLACEMENT_ATTRIBUTE="x-placement",OUT_OF_BOUNDARIES_ATTRIBUTE="x-out-of-boundaries",IOS_CLASS="tippy-iOS",ACTIVE_CLASS="tippy-active",POPPER_CLASS="tippy-popper",TOOLTIP_CLASS="tippy-tooltip",CONTENT_CLASS="tippy-content",BACKDROP_CLASS="tippy-backdrop",ARROW_CLASS="tippy-arrow",ROUND_ARROW_CLASS="tippy-roundarrow",POPPER_SELECTOR=".".concat(POPPER_CLASS),TOOLTIP_SELECTOR=".".concat(TOOLTIP_CLASS),CONTENT_SELECTOR=".".concat(CONTENT_CLASS),BACKDROP_SELECTOR=".".concat(BACKDROP_CLASS),ARROW_SELECTOR=".".concat(ARROW_CLASS),ROUND_ARROW_SELECTOR=".".concat(ROUND_ARROW_CLASS),isUsingTouch=!1;function onDocumentTouch(){isUsingTouch||(isUsingTouch=!0,isIOS&&document.body.classList.add(IOS_CLASS),window.performance&&document.addEventListener("mousemove",onDocumentMouseMove))}var lastMouseMoveTime=0;function onDocumentMouseMove(){var now=performance.now();// Chrome 60+ is 1 mousemove per animation frame, use 20ms time difference
now-lastMouseMoveTime<20&&(isUsingTouch=!1,document.removeEventListener("mousemove",onDocumentMouseMove),isIOS||document.body.classList.remove(IOS_CLASS)),lastMouseMoveTime=now}function onWindowBlur(){var _document=document,activeElement=_document.activeElement;activeElement&&activeElement.blur&&activeElement._tippy&&activeElement.blur()}
/**
 * Adds the needed global event listeners
 */function bindGlobalEventListeners(){document.addEventListener("touchstart",onDocumentTouch,PASSIVE),window.addEventListener("blur",onWindowBlur)}var keys=Object.keys(defaultProps);
/**
 * Returns an object of optional props from data-tippy-* attributes
 */function getDataAttributeOptions(reference){return keys.reduce((function(acc,key){var valueAsString=(reference.getAttribute("data-tippy-".concat(key))||"").trim();if(!valueAsString)return acc;if("content"===key)acc[key]=valueAsString;else try{acc[key]=JSON.parse(valueAsString)}catch(e){acc[key]=valueAsString}return acc}),{})}
/**
 * Polyfills the virtual reference (plain object) with Element.prototype props
 * Mutating because DOM elements are mutated, adds `_tippy` property
 */function polyfillElementPrototypeProperties(virtualReference){var polyfills={isVirtual:!0,attributes:virtualReference.attributes||{},contains:function(){},setAttribute:function(key,value){virtualReference.attributes[key]=value},getAttribute:function(key){return virtualReference.attributes[key]},removeAttribute:function(key){delete virtualReference.attributes[key]},hasAttribute:function(key){return key in virtualReference.attributes},addEventListener:function(){},removeEventListener:function(){},classList:{classNames:{},add:function(key){virtualReference.classList.classNames[key]=!0},remove:function(key){delete virtualReference.classList.classNames[key]},contains:function(key){return key in virtualReference.classList.classNames}}};for(var key in polyfills)virtualReference[key]=polyfills[key]}
/**
 * Determines if a value is a "bare" virtual element (before mutations done
 * by `polyfillElementPrototypeProperties()`). JSDOM elements show up as
 * [object Object], we can check if the value is "element-like" if it has
 * `addEventListener`
 */function isBareVirtualElement(value){return"[object Object]"==={}.toString.call(value)&&!value.addEventListener}
/**
 * Determines if the value is a reference element
 */function isReferenceElement(value){return!!value._tippy&&!matches.call(value,POPPER_SELECTOR)}
/**
 * Safe .hasOwnProperty check, for prototype-less objects
 */function forms_hasOwnProperty(obj,key){return{}.hasOwnProperty.call(obj,key)}
/**
 * Returns an array of elements based on the value
 */function getArrayOfElements(value){if(isSingular(value))
// TODO: VirtualReference is not compatible to type Element
return[value];if(value instanceof NodeList)return arrayFrom(value);if(Array.isArray(value))return value;try{return arrayFrom(document.querySelectorAll(value))}catch(e){return[]}}
/**
 * Returns a value at a given index depending on if it's an array or number
 */function getValue(value,index,defaultValue){if(Array.isArray(value)){var v=value[index];return null==v?defaultValue:v}return value}
/**
 * Debounce utility. To avoid bloating bundle size, we're only passing 1
 * argument here, a more generic function would pass all arguments. Only
 * `onMouseMove` uses this which takes the event object for now.
 */function debounce$1(fn,ms){
// Avoid wrapping in `setTimeout` if ms is 0 anyway
return 0===ms?fn:function(arg){clearTimeout(timeout),timeout=setTimeout((function(){fn(arg)}),ms)};var timeout}
/**
 * Prevents errors from being thrown while accessing nested modifier objects
 * in `popperOptions`
 */function getModifier(obj,key){return obj&&obj.modifiers&&obj.modifiers[key]}
/**
 * Determines if an array or string includes a value
 */function includes(a,b){return a.indexOf(b)>-1}
/**
 * Determines if the value is a real element
 */function isRealElement(value){return value instanceof Element}
/**
 * Determines if the value is singular-like
 */function isSingular(value){return!(!value||!forms_hasOwnProperty(value,"isVirtual"))||isRealElement(value)}
/**
 * Firefox extensions don't allow setting .innerHTML directly, this will trick it
 */function innerHTML(){return"innerHTML"}
/**
 * Evaluates a function if one, or returns the value
 */function invokeWithArgsOrReturn(value,args){return"function"===typeof value?value.apply(null,args):value}
/**
 * Sets a popperInstance `flip` modifier's enabled state
 */function setFlipModifierEnabled(modifiers,value){modifiers.filter((function(m){return"flip"===m.name}))[0].enabled=value}
/**
 * Determines if an element can receive focus
 * Always returns true for virtual objects
 */function canReceiveFocus(element){return!isRealElement(element)||matches.call(element,"a[href],area[href],button,details,input,textarea,select,iframe,[tabindex]")&&!element.hasAttribute("disabled")}
/**
 * Returns a new `div` element
 */function div(){return document.createElement("div")}
/**
 * Applies a transition duration to a list of elements
 */function setTransitionDuration(els,value){els.forEach((function(el){el&&(el.style.transitionDuration="".concat(value,"ms"))}))}
/**
 * Sets the visibility state to elements so they can begin to transition
 */function setVisibilityState(els,state){els.forEach((function(el){el&&el.setAttribute("data-state",state)}))}
/**
 * Evaluates the props object by merging data attributes and
 * disabling conflicting options where necessary
 */function evaluateProps(reference,props){var out=_extends$1({},props,{content:invokeWithArgsOrReturn(props.content,[reference])},props.ignoreAttributes?{}:getDataAttributeOptions(reference));return(out.arrow||isUCBrowser)&&(out.animateFill=!1),out}
/**
 * Validates an object of options with the valid default props object
 */function validateOptions(options,defaultProps){Object.keys(options).forEach((function(option){if(!forms_hasOwnProperty(defaultProps,option))throw new Error("[tippy]: `".concat(option,"` is not a valid option"))}))}
/**
 * Sets the innerHTML of an element
 */function setInnerHTML(element,html){element[innerHTML()]=isRealElement(html)?html[innerHTML()]:html}
/**
 * Sets the content of a tooltip
 */function setContent(contentEl,props){if(isRealElement(props.content))setInnerHTML(contentEl,""),contentEl.appendChild(props.content);else if("function"!==typeof props.content){var key=props.allowHTML?"innerHTML":"textContent";contentEl[key]=props.content}}
/**
 * Returns the child elements of a popper element
 */function getChildren(popper){return{tooltip:popper.querySelector(TOOLTIP_SELECTOR),backdrop:popper.querySelector(BACKDROP_SELECTOR),content:popper.querySelector(CONTENT_SELECTOR),arrow:popper.querySelector(ARROW_SELECTOR)||popper.querySelector(ROUND_ARROW_SELECTOR)}}
/**
 * Adds `data-inertia` attribute
 */function addInertia(tooltip){tooltip.setAttribute("data-inertia","")}
/**
 * Removes `data-inertia` attribute
 */function removeInertia(tooltip){tooltip.removeAttribute("data-inertia")}
/**
 * Creates an arrow element and returns it
 */function createArrowElement(arrowType){var arrow=div();return"round"===arrowType?(arrow.className=ROUND_ARROW_CLASS,setInnerHTML(arrow,'<svg viewBox="0 0 18 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z"/></svg>')):arrow.className=ARROW_CLASS,arrow}
/**
 * Creates a backdrop element and returns it
 */function createBackdropElement(){var backdrop=div();return backdrop.className=BACKDROP_CLASS,backdrop.setAttribute("data-state","hidden"),backdrop}
/**
 * Adds interactive-related attributes
 */function addInteractive(popper,tooltip){popper.setAttribute("tabindex","-1"),tooltip.setAttribute("data-interactive","")}
/**
 * Removes interactive-related attributes
 */function removeInteractive(popper,tooltip){popper.removeAttribute("tabindex"),tooltip.removeAttribute("data-interactive")}
/**
 * Add/remove transitionend listener from tooltip
 */function updateTransitionEndListener(tooltip,action,listener){
// UC Browser hasn't adopted the `transitionend` event despite supporting
// unprefixed transitions...
var eventName=isUCBrowser&&void 0!==document.body.style.webkitTransition?"webkitTransitionEnd":"transitionend";tooltip[action+"EventListener"](eventName,listener)}
/**
 * Returns the popper's placement, ignoring shifting (top-start, etc)
 */function getBasicPlacement(popper){var fullPlacement=popper.getAttribute(PLACEMENT_ATTRIBUTE);return fullPlacement?fullPlacement.split("-")[0]:""}
/**
 * Triggers reflow
 */function reflow(popper){popper.offsetHeight}
/**
 * Adds/removes theme from tooltip's classList
 */function updateTheme(tooltip,action,theme){theme.split(" ").forEach((function(themeName){tooltip.classList[action](themeName+"-theme")}))}
/**
 * Constructs the popper element and returns it
 */function createPopperElement(id,props){var popper=div();popper.className=POPPER_CLASS,popper.id="tippy-".concat(id),popper.style.zIndex=""+props.zIndex,popper.style.position="absolute",popper.style.top="0",popper.style.left="0",props.role&&popper.setAttribute("role",props.role);var tooltip=div();tooltip.className=TOOLTIP_CLASS,tooltip.style.maxWidth=props.maxWidth+("number"===typeof props.maxWidth?"px":""),tooltip.setAttribute("data-size",props.size),tooltip.setAttribute("data-animation",props.animation),tooltip.setAttribute("data-state","hidden"),updateTheme(tooltip,"add",props.theme);var content=div();return content.className=CONTENT_CLASS,content.setAttribute("data-state","hidden"),props.interactive&&addInteractive(popper,tooltip),props.arrow&&tooltip.appendChild(createArrowElement(props.arrowType)),props.animateFill&&(tooltip.appendChild(createBackdropElement()),tooltip.setAttribute("data-animatefill","")),props.inertia&&addInertia(tooltip),setContent(content,props),tooltip.appendChild(content),popper.appendChild(tooltip),popper}
/**
 * Updates the popper element based on the new props
 */function updatePopperElement(popper,prevProps,nextProps){var _getChildren=getChildren(popper),tooltip=_getChildren.tooltip,content=_getChildren.content,backdrop=_getChildren.backdrop,arrow=_getChildren.arrow;popper.style.zIndex=""+nextProps.zIndex,tooltip.setAttribute("data-size",nextProps.size),tooltip.setAttribute("data-animation",nextProps.animation),tooltip.style.maxWidth=nextProps.maxWidth+("number"===typeof nextProps.maxWidth?"px":""),nextProps.role?popper.setAttribute("role",nextProps.role):popper.removeAttribute("role"),prevProps.content!==nextProps.content&&setContent(content,nextProps),// animateFill
!prevProps.animateFill&&nextProps.animateFill?(tooltip.appendChild(createBackdropElement()),tooltip.setAttribute("data-animatefill","")):prevProps.animateFill&&!nextProps.animateFill&&(tooltip.removeChild(backdrop),tooltip.removeAttribute("data-animatefill")),// arrow
!prevProps.arrow&&nextProps.arrow?tooltip.appendChild(createArrowElement(nextProps.arrowType)):prevProps.arrow&&!nextProps.arrow&&tooltip.removeChild(arrow),// arrowType
prevProps.arrow&&nextProps.arrow&&prevProps.arrowType!==nextProps.arrowType&&tooltip.replaceChild(createArrowElement(nextProps.arrowType),arrow),// interactive
!prevProps.interactive&&nextProps.interactive?addInteractive(popper,tooltip):prevProps.interactive&&!nextProps.interactive&&removeInteractive(popper,tooltip),// inertia
!prevProps.inertia&&nextProps.inertia?addInertia(tooltip):prevProps.inertia&&!nextProps.inertia&&removeInertia(tooltip),// theme
prevProps.theme!==nextProps.theme&&(updateTheme(tooltip,"remove",prevProps.theme),updateTheme(tooltip,"add",nextProps.theme))}
/**
 * Hides all visible poppers on the document
 */function hideAll(){var _ref=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},excludedReferenceOrInstance=_ref.exclude,duration=_ref.duration;arrayFrom(document.querySelectorAll(POPPER_SELECTOR)).forEach((function(popper){var instance=popper._tippy;if(instance){var isExcluded=!1;excludedReferenceOrInstance&&(isExcluded=isReferenceElement(excludedReferenceOrInstance)?instance.reference===excludedReferenceOrInstance:popper===excludedReferenceOrInstance.popper),isExcluded||instance.hide(duration)}}))}
/**
 * Determines if the mouse cursor is outside of the popper's interactive border
 * region
 */function isCursorOutsideInteractiveBorder(popperPlacement,popperRect,event,props){if(!popperPlacement)return!0;var x=event.clientX,y=event.clientY,interactiveBorder=props.interactiveBorder,distance=props.distance,exceedsTop=popperRect.top-y>("top"===popperPlacement?interactiveBorder+distance:interactiveBorder),exceedsBottom=y-popperRect.bottom>("bottom"===popperPlacement?interactiveBorder+distance:interactiveBorder),exceedsLeft=popperRect.left-x>("left"===popperPlacement?interactiveBorder+distance:interactiveBorder),exceedsRight=x-popperRect.right>("right"===popperPlacement?interactiveBorder+distance:interactiveBorder);return exceedsTop||exceedsBottom||exceedsLeft||exceedsRight}
/**
 * Returns the distance offset, taking into account the default offset due to
 * the transform: translate() rule (10px) in CSS
 */function getOffsetDistanceInPx(distance){return-(distance-10)+"px"}var idCounter=1,mouseMoveListeners=[];// Workaround for IE11's lack of new MouseEvent constructor
/**
 * Creates and returns a Tippy object. We're using a closure pattern instead of
 * a class so that the exposed object API is clean without private members
 * prefixed with `_`.
 */
function createTippy(reference,collectionProps){var lastTriggerEventType,lastMouseMoveEvent,showTimeoutId,hideTimeoutId,scheduleHideAnimationFrameId,props=evaluateProps(reference,collectionProps);// If the reference shouldn't have multiple tippys, return null early
if(!props.multiple&&reference._tippy)return null;
/* ======================= 🔒 Private members 🔒 ======================= */var previousPlacement,currentMountCallback,currentTransitionEndListener,currentComputedPadding,isScheduledToShow=!1,isBeingDestroyed=!1,wasVisibleDuringPreviousUpdate=!1,hasMountCallbackRun=!1,listeners=[],debouncedOnMouseMove=debounce$1(onMouseMove,props.interactiveDebounce),id=idCounter++,popper=createPopperElement(id,props),popperChildren=getChildren(popper),popperInstance=null,state={
// Is the instance currently enabled?
isEnabled:!0,
// Is the tippy currently showing and not transitioning out?
isVisible:!1,
// Has the instance been destroyed?
isDestroyed:!1,
// Is the tippy currently mounted to the DOM?
isMounted:!1,
// Has the tippy finished transitioning in?
isShown:!1},instance={
// properties
id:id,reference:reference,popper:popper,popperChildren:popperChildren,popperInstance:popperInstance,props:props,state:state,
// methods
clearDelayTimeouts:clearDelayTimeouts,set:set,setContent:setContent,show:show,hide:hide,enable:enable,disable:disable,destroy:destroy
/* ==================== Initial instance mutations =================== */};return reference._tippy=instance,popper._tippy=instance,addTriggersToReference(),props.lazy||createPopperInstance(),props.showOnInit&&scheduleShow(),// Ensure the event listeners target can receive focus
!props.a11y||props.target||canReceiveFocus(getEventListenersTarget())||getEventListenersTarget().setAttribute("tabindex","0"),// Prevent a tippy with a delay from hiding if the cursor left then returned
// before it started hiding
popper.addEventListener("mouseenter",(function(event){instance.props.interactive&&instance.state.isVisible&&"mouseenter"===lastTriggerEventType&&
// We don't want props.onTrigger() to be called here, since the `event`
// object is not related to the reference element
scheduleShow(event,!0)})),popper.addEventListener("mouseleave",(function(){instance.props.interactive&&"mouseenter"===lastTriggerEventType&&document.addEventListener("mousemove",debouncedOnMouseMove)})),instance;
/* ======================= 🔒 Private methods 🔒 ======================= */
/**
   * Removes the follow cursor listener
   */function removeFollowCursorListener(){document.removeEventListener("mousemove",positionVirtualReferenceNearCursor)}
/**
   * Cleans up interactive mouse listeners
   */function cleanupInteractiveMouseListeners(){document.body.removeEventListener("mouseleave",scheduleHide),document.removeEventListener("mousemove",debouncedOnMouseMove),mouseMoveListeners=mouseMoveListeners.filter((function(listener){return listener!==debouncedOnMouseMove}))}
/**
   * Returns correct target used for event listeners
   */function getEventListenersTarget(){return instance.props.triggerTarget||reference}
/**
   * Adds the document click event listener for the instance
   */function addDocumentClickListener(){document.addEventListener("click",onDocumentClick,!0)}
/**
   * Removes the document click event listener for the instance
   */function removeDocumentClickListener(){document.removeEventListener("click",onDocumentClick,!0)}
/**
   * Returns transitionable inner elements used in show/hide methods
   */function getTransitionableElements(){return[instance.popperChildren.tooltip,instance.popperChildren.backdrop,instance.popperChildren.content]}
/**
   * Determines if the instance is in `followCursor` mode.
   * NOTE: in v5, touch devices will use `initial` behavior no matter the value.
   */function getIsInLooseFollowCursorMode(){var followCursor=instance.props.followCursor;return followCursor&&"focus"!==lastTriggerEventType||isUsingTouch&&"initial"===followCursor}
/**
   * Updates the tooltip's position on each animation frame
   */function makeSticky(){setTransitionDuration([popper],isIE$1?0:instance.props.updateDuration);var prevRefRect=reference.getBoundingClientRect();function updatePosition(){var currentRefRect=reference.getBoundingClientRect();// Only schedule an update if the reference rect has changed
prevRefRect.top===currentRefRect.top&&prevRefRect.right===currentRefRect.right&&prevRefRect.bottom===currentRefRect.bottom&&prevRefRect.left===currentRefRect.left||instance.popperInstance.scheduleUpdate(),prevRefRect=currentRefRect,instance.state.isMounted&&requestAnimationFrame(updatePosition)}updatePosition()}
/**
   * Invokes a callback once the tooltip has fully transitioned out
   */function onTransitionedOut(duration,callback){onTransitionEnd(duration,(function(){!instance.state.isVisible&&popper.parentNode&&popper.parentNode.contains(popper)&&callback()}))}
/**
   * Invokes a callback once the tooltip has fully transitioned in
   */function onTransitionedIn(duration,callback){onTransitionEnd(duration,callback)}
/**
   * Invokes a callback once the tooltip's CSS transition ends
   */function onTransitionEnd(duration,callback){var tooltip=instance.popperChildren.tooltip;
/**
     * Listener added as the `transitionend` handler
     */function listener(event){event.target===tooltip&&(updateTransitionEndListener(tooltip,"remove",listener),callback())}// Make callback synchronous if duration is 0
// `transitionend` won't fire otherwise
if(0===duration)return callback();updateTransitionEndListener(tooltip,"remove",currentTransitionEndListener),updateTransitionEndListener(tooltip,"add",listener),currentTransitionEndListener=listener}
/**
   * Adds an event listener to the reference and stores it in `listeners`
   */function on(eventType,handler){var options=arguments.length>2&&void 0!==arguments[2]&&arguments[2];getEventListenersTarget().addEventListener(eventType,handler,options),listeners.push({eventType:eventType,handler:handler,options:options})}
/**
   * Adds event listeners to the reference based on the `trigger` prop
   */function addTriggersToReference(){instance.props.touchHold&&!instance.props.target&&(on("touchstart",onTrigger,PASSIVE),on("touchend",onMouseLeave,PASSIVE)),instance.props.trigger.trim().split(" ").forEach((function(eventType){if("manual"!==eventType)// Non-delegates
if(instance.props.target)
// Delegates
switch(eventType){case"mouseenter":on("mouseover",onDelegateShow),on("mouseout",onDelegateHide);break;case"focus":on("focusin",onDelegateShow),on("focusout",onDelegateHide);break;case"click":on(eventType,onDelegateShow);break}else switch(on(eventType,onTrigger),eventType){case"mouseenter":on("mouseleave",onMouseLeave);break;case"focus":on(isIE$1?"focusout":"blur",onBlur);break}}))}
/**
   * Removes event listeners from the reference
   */function removeTriggersFromReference(){listeners.forEach((function(_ref){var eventType=_ref.eventType,handler=_ref.handler,options=_ref.options;getEventListenersTarget().removeEventListener(eventType,handler,options)})),listeners=[]}
/**
   * Positions the virtual reference near the cursor
   */function positionVirtualReferenceNearCursor(event){var _lastMouseMoveEvent=lastMouseMoveEvent=event,x=_lastMouseMoveEvent.clientX,y=_lastMouseMoveEvent.clientY;// Gets set once popperInstance `onCreate` has been called
if(currentComputedPadding){// If the instance is interactive, avoid updating the position unless it's
// over the reference element
var isCursorOverReference=closestCallback(event.target,(function(el){return el===reference})),rect=reference.getBoundingClientRect(),followCursor=instance.props.followCursor,isHorizontal="horizontal"===followCursor,isVertical="vertical"===followCursor,isVerticalPlacement=includes(["top","bottom"],getBasicPlacement(popper)),fullPlacement=popper.getAttribute(PLACEMENT_ATTRIBUTE),isVariation=!!fullPlacement&&!!fullPlacement.split("-")[1],size=isVerticalPlacement?popper.offsetWidth:popper.offsetHeight,halfSize=size/2,verticalIncrease=isVerticalPlacement?0:isVariation?size:halfSize,horizontalIncrease=isVerticalPlacement?isVariation?size:halfSize:0;!isCursorOverReference&&instance.props.interactive||(instance.popperInstance.reference=_extends$1({},instance.popperInstance.reference,{
// This will exist in next Popper.js feature release to fix #532
// @ts-ignore
referenceNode:reference,
// These `client` values don't get used by Popper.js if they are 0
clientWidth:0,clientHeight:0,getBoundingClientRect:function(){return{width:isVerticalPlacement?size:0,height:isVerticalPlacement?0:size,top:(isHorizontal?rect.top:y)-verticalIncrease,bottom:(isHorizontal?rect.bottom:y)+verticalIncrease,left:(isVertical?rect.left:x)-horizontalIncrease,right:(isVertical?rect.right:x)+horizontalIncrease}}}),instance.popperInstance.update()),"initial"===followCursor&&instance.state.isVisible&&removeFollowCursorListener()}}
/**
   * Creates the tippy instance for a delegate when it's been triggered
   */function createDelegateChildTippy(event){if(event){var targetEl=closest(event.target,instance.props.target);targetEl&&!targetEl._tippy&&createTippy(targetEl,_extends$1({},instance.props,{content:invokeWithArgsOrReturn(collectionProps.content,[targetEl]),appendTo:collectionProps.appendTo,target:"",showOnInit:!0}))}}
/**
   * Event listener invoked upon trigger
   */function onTrigger(event){instance.state.isEnabled&&!isEventListenerStopped(event)&&(instance.state.isVisible||(lastTriggerEventType=event.type,event instanceof MouseEvent&&(lastMouseMoveEvent=event,// If scrolling, `mouseenter` events can be fired if the cursor lands
// over a new target, but `mousemove` events don't get fired. This
// causes interactive tooltips to get stuck open until the cursor is
// moved
mouseMoveListeners.forEach((function(listener){return listener(event)})))),// Toggle show/hide when clicking click-triggered tooltips
"click"===event.type&&!1!==instance.props.hideOnClick&&instance.state.isVisible?scheduleHide():scheduleShow(event))}
/**
   * Event listener used for interactive tooltips to detect when they should
   * hide
   */function onMouseMove(event){var isCursorOverPopper=closest(event.target,POPPER_SELECTOR)===popper,isCursorOverReference=closestCallback(event.target,(function(el){return el===reference}));isCursorOverPopper||isCursorOverReference||isCursorOutsideInteractiveBorder(getBasicPlacement(popper),popper.getBoundingClientRect(),event,instance.props)&&(cleanupInteractiveMouseListeners(),scheduleHide())}
/**
   * Event listener invoked upon mouseleave
   */function onMouseLeave(event){if(!isEventListenerStopped(event))return instance.props.interactive?(document.body.addEventListener("mouseleave",scheduleHide),document.addEventListener("mousemove",debouncedOnMouseMove),void mouseMoveListeners.push(debouncedOnMouseMove)):void scheduleHide()}
/**
   * Event listener invoked upon blur
   */function onBlur(event){event.target===getEventListenersTarget()&&(instance.props.interactive&&event.relatedTarget&&popper.contains(event.relatedTarget)||scheduleHide())}
/**
   * Event listener invoked when a child target is triggered
   */function onDelegateShow(event){closest(event.target,instance.props.target)&&scheduleShow(event)}
/**
   * Event listener invoked when a child target should hide
   */function onDelegateHide(event){closest(event.target,instance.props.target)&&scheduleHide()}
/**
   * Determines if an event listener should stop further execution due to the
   * `touchHold` option
   */function isEventListenerStopped(event){var supportsTouch="ontouchstart"in window,isTouchEvent=includes(event.type,"touch"),touchHold=instance.props.touchHold;return supportsTouch&&isUsingTouch&&touchHold&&!isTouchEvent||isUsingTouch&&!touchHold&&isTouchEvent}
/**
   * Runs the mount callback
   */function runMountCallback(){!hasMountCallbackRun&&currentMountCallback&&(hasMountCallbackRun=!0,reflow(popper),currentMountCallback())}
/**
   * Creates the popper instance for the instance
   */function createPopperInstance(){var popperOptions=instance.props.popperOptions,_instance$popperChild=instance.popperChildren,tooltip=_instance$popperChild.tooltip,arrow=_instance$popperChild.arrow,preventOverflowModifier=getModifier(popperOptions,"preventOverflow");function applyMutations(data){instance.props.flip&&!instance.props.flipOnUpdate&&(data.flipped&&(instance.popperInstance.options.placement=data.placement),setFlipModifierEnabled(instance.popperInstance.modifiers,!1)),// Apply all of the popper's attributes to the tootip node as well.
// Allows users to avoid using the .tippy-popper selector for themes.
tooltip.setAttribute(PLACEMENT_ATTRIBUTE,data.placement),!1!==data.attributes[OUT_OF_BOUNDARIES_ATTRIBUTE]?tooltip.setAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE,""):tooltip.removeAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE),// Prevents a transition when changing placements (while tippy is visible)
// for scroll/resize updates
previousPlacement&&previousPlacement!==data.placement&&wasVisibleDuringPreviousUpdate&&(tooltip.style.transition="none",requestAnimationFrame((function(){tooltip.style.transition=""}))),previousPlacement=data.placement,wasVisibleDuringPreviousUpdate=instance.state.isVisible;var basicPlacement=getBasicPlacement(popper),styles=tooltip.style;// Account for the `distance` offset
styles.top=styles.bottom=styles.left=styles.right="",styles[basicPlacement]=getOffsetDistanceInPx(instance.props.distance);var padding=preventOverflowModifier&&void 0!==preventOverflowModifier.padding?preventOverflowModifier.padding:PADDING,isPaddingNumber="number"===typeof padding,computedPadding=_extends$1({top:isPaddingNumber?padding:padding.top,bottom:isPaddingNumber?padding:padding.bottom,left:isPaddingNumber?padding:padding.left,right:isPaddingNumber?padding:padding.right},!isPaddingNumber&&padding);computedPadding[basicPlacement]=isPaddingNumber?padding+instance.props.distance:(padding[basicPlacement]||0)+instance.props.distance,instance.popperInstance.modifiers.filter((function(m){return"preventOverflow"===m.name}))[0].padding=computedPadding,currentComputedPadding=computedPadding}var config=_extends$1({eventsEnabled:!1,placement:instance.props.placement},popperOptions,{modifiers:_extends$1({},popperOptions?popperOptions.modifiers:{},{preventOverflow:_extends$1({boundariesElement:instance.props.boundary,padding:PADDING},preventOverflowModifier),arrow:_extends$1({element:arrow,enabled:!!arrow},getModifier(popperOptions,"arrow")),flip:_extends$1({enabled:instance.props.flip,
// The tooltip is offset by 10px from the popper in CSS,
// we need to account for its distance
padding:instance.props.distance+PADDING,behavior:instance.props.flipBehavior},getModifier(popperOptions,"flip")),offset:_extends$1({offset:instance.props.offset},getModifier(popperOptions,"offset"))}),onCreate:function(data){applyMutations(data),runMountCallback(),popperOptions&&popperOptions.onCreate&&popperOptions.onCreate(data)},onUpdate:function(data){applyMutations(data),runMountCallback(),popperOptions&&popperOptions.onUpdate&&popperOptions.onUpdate(data)}});instance.popperInstance=new Popper(reference,popper,config)}
/**
   * Mounts the tooltip to the DOM
   */function mount(){hasMountCallbackRun=!1;var isInLooseFollowCursorMode=getIsInLooseFollowCursorMode();instance.popperInstance?(setFlipModifierEnabled(instance.popperInstance.modifiers,instance.props.flip),isInLooseFollowCursorMode||(instance.popperInstance.reference=reference,instance.popperInstance.enableEventListeners()),instance.popperInstance.scheduleUpdate()):(createPopperInstance(),isInLooseFollowCursorMode||instance.popperInstance.enableEventListeners());var appendTo=instance.props.appendTo,parentNode="parent"===appendTo?reference.parentNode:invokeWithArgsOrReturn(appendTo,[reference]);parentNode.contains(popper)||(parentNode.appendChild(popper),instance.props.onMount(instance),instance.state.isMounted=!0)}
/**
   * Setup before show() is invoked (delays, etc.)
   */function scheduleShow(event,shouldAvoidCallingOnTrigger){if(clearDelayTimeouts(),!instance.state.isVisible){// Is a delegate, create an instance for the child target
if(instance.props.target)return createDelegateChildTippy(event);if(isScheduledToShow=!0,event&&!shouldAvoidCallingOnTrigger&&instance.props.onTrigger(instance,event),instance.props.wait)return instance.props.wait(instance,event);// If the tooltip has a delay, we need to be listening to the mousemove as
// soon as the trigger event is fired, so that it's in the correct position
// upon mount.
// Edge case: if the tooltip is still mounted, but then scheduleShow() is
// called, it causes a jump.
getIsInLooseFollowCursorMode()&&!instance.state.isMounted&&(instance.popperInstance||createPopperInstance(),document.addEventListener("mousemove",positionVirtualReferenceNearCursor)),addDocumentClickListener();var delay=getValue(instance.props.delay,0,defaultProps.delay);delay?showTimeoutId=setTimeout((function(){show()}),delay):show()}}
/**
   * Setup before hide() is invoked (delays, etc.)
   */function scheduleHide(){if(clearDelayTimeouts(),!instance.state.isVisible)return removeFollowCursorListener(),void removeDocumentClickListener();isScheduledToShow=!1;var delay=getValue(instance.props.delay,1,defaultProps.delay);delay?hideTimeoutId=setTimeout((function(){instance.state.isVisible&&hide()}),delay):
// Fixes a `transitionend` problem when it fires 1 frame too
// late sometimes, we don't want hide() to be called.
scheduleHideAnimationFrameId=requestAnimationFrame((function(){hide()}))}
/**
   * Listener to handle clicks on the document to determine if the
   * instance should hide
   */function onDocumentClick(event){
// Clicked on interactive popper
if(!instance.props.interactive||!popper.contains(event.target)){// Clicked on the event listeners target
if(getEventListenersTarget().contains(event.target)){if(isUsingTouch)return;if(instance.state.isVisible&&includes(instance.props.trigger,"click"))return}!0===instance.props.hideOnClick&&(clearDelayTimeouts(),hide())}}
/* ======================= 🔑 Public methods 🔑 ======================= */
/**
   * Enables the instance to allow it to show or hide
   */function enable(){instance.state.isEnabled=!0}
/**
   * Disables the instance to disallow it to show or hide
   */function disable(){instance.state.isEnabled=!1}
/**
   * Clears pending timeouts related to the `delay` prop if any
   */function clearDelayTimeouts(){clearTimeout(showTimeoutId),clearTimeout(hideTimeoutId),cancelAnimationFrame(scheduleHideAnimationFrameId)}
/**
   * Sets new props for the instance and redraws the tooltip
   */function set(options){
// Backwards-compatible after TypeScript change
options=options||{},validateOptions(options,defaultProps),removeTriggersFromReference();var prevProps=instance.props,nextProps=evaluateProps(reference,_extends$1({},instance.props,{},options,{ignoreAttributes:!0}));nextProps.ignoreAttributes=forms_hasOwnProperty(options,"ignoreAttributes")?options.ignoreAttributes||!1:prevProps.ignoreAttributes,instance.props=nextProps,addTriggersToReference(),cleanupInteractiveMouseListeners(),debouncedOnMouseMove=debounce$1(onMouseMove,nextProps.interactiveDebounce),updatePopperElement(popper,prevProps,nextProps),instance.popperChildren=getChildren(popper),instance.popperInstance&&(POPPER_INSTANCE_DEPENDENCIES.some((function(prop){return forms_hasOwnProperty(options,prop)&&options[prop]!==prevProps[prop]}))?(instance.popperInstance.destroy(),createPopperInstance(),instance.state.isVisible&&instance.popperInstance.enableEventListeners(),instance.props.followCursor&&lastMouseMoveEvent&&positionVirtualReferenceNearCursor(lastMouseMoveEvent)):instance.popperInstance.update())}
/**
   * Shortcut for .set({ content: newContent })
   */function setContent(content){set({content:content})}
/**
   * Shows the tooltip
   */function show(){var duration=arguments.length>0&&void 0!==arguments[0]?arguments[0]:getValue(instance.props.duration,0,defaultProps.duration[1]);if(!instance.state.isDestroyed&&instance.state.isEnabled&&(!isUsingTouch||instance.props.touch)&&!getEventListenersTarget().hasAttribute("disabled")&&!1!==instance.props.onShow(instance)){addDocumentClickListener(),popper.style.visibility="visible",instance.state.isVisible=!0,instance.props.interactive&&getEventListenersTarget().classList.add(ACTIVE_CLASS);// Prevent a transition if the popper is at the opposite placement
var transitionableElements=getTransitionableElements();setTransitionDuration(transitionableElements.concat(popper),0),currentMountCallback=function(){if(instance.state.isVisible){var isInLooseFollowCursorMode=getIsInLooseFollowCursorMode();isInLooseFollowCursorMode&&lastMouseMoveEvent?positionVirtualReferenceNearCursor(lastMouseMoveEvent):isInLooseFollowCursorMode||
// Double update will apply correct mutations
instance.popperInstance.update(),instance.popperChildren.backdrop&&(instance.popperChildren.content.style.transitionDelay=Math.round(duration/12)+"ms"),instance.props.sticky&&makeSticky(),setTransitionDuration([popper],instance.props.updateDuration),setTransitionDuration(transitionableElements,duration),setVisibilityState(transitionableElements,"visible"),onTransitionedIn(duration,(function(){instance.props.aria&&getEventListenersTarget().setAttribute("aria-".concat(instance.props.aria),popper.id),instance.props.onShown(instance),instance.state.isShown=!0}))}},mount()}// Standardize `disabled` behavior across browsers.
// Firefox allows events on disabled elements, but Chrome doesn't.
// Using a wrapper element (i.e. <span>) is recommended.
}
/**
   * Hides the tooltip
   */function hide(){var duration=arguments.length>0&&void 0!==arguments[0]?arguments[0]:getValue(instance.props.duration,1,defaultProps.duration[1]);if(!instance.state.isDestroyed&&(instance.state.isEnabled||isBeingDestroyed)&&(!1!==instance.props.onHide(instance)||isBeingDestroyed)){removeDocumentClickListener(),popper.style.visibility="hidden",instance.state.isVisible=!1,instance.state.isShown=!1,wasVisibleDuringPreviousUpdate=!1,instance.props.interactive&&getEventListenersTarget().classList.remove(ACTIVE_CLASS);var transitionableElements=getTransitionableElements();setTransitionDuration(transitionableElements,duration),setVisibilityState(transitionableElements,"hidden"),onTransitionedOut(duration,(function(){isScheduledToShow||removeFollowCursorListener(),instance.props.aria&&getEventListenersTarget().removeAttribute("aria-".concat(instance.props.aria)),instance.popperInstance.disableEventListeners(),instance.popperInstance.options.placement=instance.props.placement,popper.parentNode.removeChild(popper),instance.props.onHidden(instance),instance.state.isMounted=!1}))}}
/**
   * Destroys the tooltip
   */function destroy(destroyTargetInstances){if(!instance.state.isDestroyed){isBeingDestroyed=!0,// If the popper is currently mounted to the DOM, we want to ensure it gets
// hidden and unmounted instantly upon destruction
instance.state.isMounted&&hide(0),removeTriggersFromReference(),delete reference._tippy;var target=instance.props.target;target&&destroyTargetInstances&&isRealElement(reference)&&arrayFrom(reference.querySelectorAll(target)).forEach((function(child){child._tippy&&child._tippy.destroy()})),instance.popperInstance&&instance.popperInstance.destroy(),isBeingDestroyed=!1,instance.state.isDestroyed=!0}}}
/**
 * Groups an array of instances by taking control of their props during
 * certain lifecycles.
 */function group(instances){var _ref=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_ref$delay=_ref.delay,delay=void 0===_ref$delay?instances[0].props.delay:_ref$delay,_ref$duration=_ref.duration,duration=void 0===_ref$duration?0:_ref$duration,isAnyTippyOpen=!1;function setIsAnyTippyOpen(value){isAnyTippyOpen=value,updateInstances()}function onShow(instance){instance._originalProps.onShow(instance),instances.forEach((function(instance){instance.set({duration:duration}),instance.state.isVisible&&instance.hide()})),setIsAnyTippyOpen(!0)}function onHide(instance){instance._originalProps.onHide(instance),setIsAnyTippyOpen(!1)}function onShown(instance){instance._originalProps.onShown(instance),instance.set({duration:instance._originalProps.duration})}function updateInstances(){instances.forEach((function(instance){instance.set({onShow:onShow,onShown:onShown,onHide:onHide,delay:isAnyTippyOpen?[0,Array.isArray(delay)?delay[1]:delay]:delay,duration:isAnyTippyOpen?duration:instance._originalProps.duration})}))}instances.forEach((function(instance){instance._originalProps?instance.set(instance._originalProps):instance._originalProps=_extends$1({},instance.props)})),updateInstances()}var globalEventListenersBound=!1;
/**
 * Exported module
 */function tippy(targets,options){validateOptions(options||{},defaultProps),globalEventListenersBound||(bindGlobalEventListeners(),globalEventListenersBound=!0);var props=_extends$1({},defaultProps,{},options);// If they are specifying a virtual positioning reference, we need to polyfill
// some native DOM props
isBareVirtualElement(targets)&&polyfillElementPrototypeProperties(targets);var instances=getArrayOfElements(targets).reduce((function(acc,reference){var instance=reference&&createTippy(reference,props);return instance&&acc.push(instance),acc}),[]);return isSingular(targets)?instances[0]:instances}
/**
 * Static props
 */
/**
 * Auto-init tooltips for elements with a `data-tippy="..."` attribute
 */
function autoInit(){arrayFrom(document.querySelectorAll("[data-tippy]")).forEach((function(el){var content=el.getAttribute("data-tippy");content&&tippy(el,{content:content})}))}
/**
 * Injects a string of CSS styles to a style node in <head>
 */
function injectCSS(css){if(isBrowser$1){var style=document.createElement("style");style.type="text/css",style.textContent=css,style.setAttribute("data-tippy-stylesheet","");var head=document.head,firstStyleOrLinkTag=head.querySelector("style,link");firstStyleOrLinkTag?head.insertBefore(style,firstStyleOrLinkTag):head.appendChild(style)}}tippy.version=version,tippy.defaults=defaultProps,
/**
 * Static methods
 */
tippy.setDefaults=function(partialDefaults){Object.keys(partialDefaults).forEach((function(key){
// @ts-ignore
defaultProps[key]=partialDefaults[key]}))},tippy.hideAll=hideAll,tippy.group=group,isBrowser$1&&setTimeout(autoInit),injectCSS(css);var commonjsGlobal="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof window?window:"undefined"!==typeof global?global:"undefined"!==typeof self?self:{};function createCommonjsModule(fn,module){return module={exports:{}},fn(module,module.exports),module.exports}var humps=createCommonjsModule((function(module){(function(global){var _processKeys=function(convert,obj,options){if(!_isObject(obj)||_isDate(obj)||_isRegExp(obj)||_isBoolean(obj)||_isFunction(obj))return obj;var output,i=0,l=0;if(_isArray(obj))for(output=[],l=obj.length;i<l;i++)output.push(_processKeys(convert,obj[i],options));else for(var key in output={},obj)Object.prototype.hasOwnProperty.call(obj,key)&&(output[convert(key,options)]=_processKeys(convert,obj[key],options));return output},separateWords=function(string,options){options=options||{};var separator=options.separator||"_",split=options.split||/(?=[A-Z])/;return string.split(split).join(separator)},camelize=function(string){return _isNumerical(string)?string:(string=string.replace(/[\-_\s]+(.)?/g,(function(match,chr){return chr?chr.toUpperCase():""})),string.substr(0,1).toLowerCase()+string.substr(1))},pascalize=function(string){var camelized=camelize(string);
// Ensure 1st char is always uppercase
return camelized.substr(0,1).toUpperCase()+camelized.substr(1)},decamelize=function(string,options){return separateWords(string,options).toLowerCase()},toString=Object.prototype.toString,_isFunction=function(obj){return"function"===typeof obj},_isObject=function(obj){return obj===Object(obj)},_isArray=function(obj){return"[object Array]"==toString.call(obj)},_isDate=function(obj){return"[object Date]"==toString.call(obj)},_isRegExp=function(obj){return"[object RegExp]"==toString.call(obj)},_isBoolean=function(obj){return"[object Boolean]"==toString.call(obj)},_isNumerical=function(obj){return obj-=0,obj===obj},_processor=function(convert,options){var callback=options&&"process"in options?options.process:options;return"function"!==typeof callback?convert:function(string,options){return callback(string,convert,options)}},humps={camelize:camelize,decamelize:decamelize,pascalize:pascalize,depascalize:decamelize,camelizeKeys:function(object,options){return _processKeys(_processor(camelize,options),object)},decamelizeKeys:function(object,options){return _processKeys(_processor(decamelize,options),object,options)},pascalizeKeys:function(object,options){return _processKeys(_processor(pascalize,options),object)},depascalizeKeys:function(){return this.decamelizeKeys.apply(this,arguments)}};
// String conversion methods
module.exports?module.exports=humps:global.humps=humps})(commonjsGlobal)}));function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach((function(key){_defineProperty(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}var booleanProps={a11y:!0,allowHTML:!0,animateFill:!0,arrow:!1,flip:!0,flipOnUpdate:!1,followCursor:!1,hideOnClick:!0,ignoreAttributes:!1,inertia:!1,interactive:!1,lazy:!0,multiple:!1,showOnInit:!1,sticky:!1,touch:!0,touchHold:!1},defaultProps$1=_objectSpread2({animation:"shift-away",appendTo:function(){return document.body},aria:"describedby",arrowType:"sharp",boundary:"scrollParent",content:"",delay:0,distance:10,duration:[325,275],flipBehavior:"flip",interactiveBorder:2,interactiveDebounce:0,maxWidth:350,offset:0,onHidden:function(){},onHide:function(){},onMount:function(){},onShow:function(){},onShown:function(){},placement:"top",popperOptions:{},role:"tooltip",size:"regular",target:"",theme:"dark",trigger:"mouseenter focus",updateDuration:0,wait:null,zIndex:9999},booleanProps),script$4={props:{to:void 0,toSelector:void 0,toElement:void 0,content:void 0,enabled:void 0,visible:void 0,triggerTarget:void 0,tag:{type:String,default:"div"},triggerTag:String,contentTag:String},data:function(){return{tip:null,options:{}}},mounted:function(){this.init()},watch:{content:function(){this.tip&&this.tip.set(this.getOptions())},enabled:function(val){this.tip&&(val?this.tip.enable():(this.tip.hide(),this.tip.disable()))},visible:function(val){this.tip&&(val?this.tip.show():this.tip.hide())}},updated:function(){this.tip&&!this.content&&this.tip.set(this.getOptions())},beforeDestroy:function(){this.tip&&this.tip.destroy()},computed:{isManualTrigger:function(){return"manual"===this.options.trigger}},methods:{init:function(){if(this.tip){try{this.tip.destroy()}catch(error){}this.tip=null}var elm=this.toElement;if(null==elm&&(elm=this.to?document.querySelector("[name='".concat(this.to,"']")):this.toSelector?document.querySelector(this.toSelector):this.$refs.trigger&&this.$refs.trigger.childElementCount>0?this.$refs.trigger:this.$el.parentElement),elm){var tip=tippy(elm,this.getOptions());if(tip){if(Array.isArray(tip)){if(!(tip.length>0))return;this.tip=tip[0]}this.tip=tip,this.$emit("onCreate",this.tip),this.$emit("init",this.tip),!1===this.enabled&&this.tip.disable(),this.isManualTrigger&&!0===this.visible&&this.tip.show()}}},tippy:function(){return this.tip},filterOptions:function(){for(var getValue=function(key,value){if(booleanProps.hasOwnProperty(key)){if(""===value)return!0;if("false"===value)return!1;if("true"===value)return!0}return value},_i=0,_Object$keys=Object.keys(this.options);_i<_Object$keys.length;_i++){var key=_Object$keys[_i];defaultProps$1.hasOwnProperty(key)?this.options[key]=getValue(key,this.options[key]):
// We're replacing this.options anyway, we don't have to worry about modifying the object
delete this.options[key]}return this.options},getOptions:function(){var _this=this;return this.options.content=this.content?this.content:this.$refs.content,Object.assign(this.options,humps.camelizeKeys(this.$attrs)),this.filterOptions(),!this.options.onShow&&this.$listeners&&this.$listeners["show"]&&(this.options.onShow=function(){var _this$$listeners$show;return(_this$$listeners$show=_this.$listeners["show"]).fns.apply(_this$$listeners$show,arguments)}),!this.options.onShow&&this.$listeners&&this.$listeners["shown"]&&(this.options.onShown=function(){var _this$$listeners$show2;return(_this$$listeners$show2=_this.$listeners["shown"]).fns.apply(_this$$listeners$show2,arguments)}),!this.options.onHidden&&this.$listeners&&this.$listeners["hidden"]&&(this.options.onHidden=function(){var _this$$listeners$hidd;return(_this$$listeners$hidd=_this.$listeners["hidden"]).fns.apply(_this$$listeners$hidd,arguments)}),!this.options.onHide&&this.$listeners&&this.$listeners["hide"]&&(this.options.onHide=function(){var _this$$listeners$hide;return(_this$$listeners$hide=_this.$listeners["hide"]).fns.apply(_this$$listeners$hide,arguments)}),!this.options.onMount&&this.$listeners&&this.$listeners["mount"]&&(this.options.onMount=function(){var _this$$listeners$moun;return(_this$$listeners$moun=_this.$listeners["mount"]).fns.apply(_this$$listeners$moun,arguments)}),this.options.triggerTarget=this.triggerTarget,this.options}}};function normalizeComponent(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier
/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);// Vue.extend constructor export interop.
var hook,options="function"===typeof script?script.options:script;// render functions
if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,// functional template
isFunctionalTemplate&&(options.functional=!0)),// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),// inject component styles
style&&style.call(this,createInjectorSSR(context)),// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(){style.call(this,createInjectorShadow(this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
var originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
var existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}var normalizeComponent_1=normalizeComponent,__vue_script__$4=script$4,__vue_render__$3=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c(_vm.tag,{tag:"component",attrs:{"data-tippy-component":""}},[_c(_vm.triggerTag||_vm.tag,{ref:"trigger",tag:"component",attrs:{"data-tippy-component-trigger":""}},[_vm._t("trigger")],2),_vm._v(" "),_c(_vm.contentTag||_vm.tag,{ref:"content",tag:"component"},[_vm._t("default")],2)],1)},__vue_staticRenderFns__$3=[];
/* script */__vue_render__$3._withStripped=!0;
/* style */
var __vue_inject_styles__$4=void 0,__vue_scope_id__$4=void 0,__vue_module_identifier__$4=void 0,__vue_is_functional_template__$4=!1,TippyComponent=normalizeComponent_1({render:__vue_render__$3,staticRenderFns:__vue_staticRenderFns__$3},__vue_inject_styles__$4,__vue_script__$4,__vue_scope_id__$4,__vue_is_functional_template__$4,__vue_module_identifier__$4,void 0,void 0),tippyDirective="tippy",forms_plugin={install:function(Vue){var options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};function createTippy(el,binding,vnode){var handlers=vnode.data&&vnode.data.on||vnode.componentOptions&&vnode.componentOptions.listeners;el.setAttribute("data-tippy-directive","");var opts=deriveOpts(binding),modifiers=Object.keys(binding.modifiers||{}),placement=modifiers.find((function(modifier){return"arrow"!==modifier})),withArrow=-1!==modifiers.findIndex((function(modifier){return"arrow"===modifier}));opts=Object.assign({},options,opts),placement&&(opts.placement=opts.placement||placement),withArrow&&(opts.arrow=void 0===opts.arrow||opts.arrow),handlers&&handlers["show"]&&(opts.onShow=function(){var _handlers$show;return(_handlers$show=handlers["show"]).fns.apply(_handlers$show,arguments)}),handlers&&handlers["shown"]&&(opts.onShown=function(){var _handlers$shown;(_handlers$shown=handlers["shown"]).fns.apply(_handlers$shown,arguments)}),handlers&&handlers["hidden"]&&(opts.onHidden=function(){var _handlers$hidden;(_handlers$hidden=handlers["hidden"]).fns.apply(_handlers$hidden,arguments)}),handlers&&handlers["hide"]&&(opts.onHide=function(){var _handlers$hide;return(_handlers$hide=handlers["hide"]).fns.apply(_handlers$hide,arguments)}),handlers&&handlers["mount"]&&(opts.onMount=function(){var _handlers$mount;(_handlers$mount=handlers["mount"]).fns.apply(_handlers$mount,arguments)}),el.getAttribute("title")&&!opts.content&&(opts.content=el.getAttribute("title"),el.removeAttribute("title")),el.getAttribute("content")&&!opts.content&&(opts.content=el.getAttribute("content")),tippy(el,opts),opts.showOnLoad&&el._tippy.show(),Vue.nextTick((function(){handlers&&handlers["init"]&&handlers["init"].fns(el._tippy,el)}))}function deriveOpts(binding){return"string"===typeof binding.value?{content:binding.value}:binding.value||{}}tippyDirective=options.directive||"tippy",tippy.setDefaults(options||{}),Vue.directive(tippyDirective,{inserted:function(el,binding,vnode){Vue.nextTick((function(){createTippy(el,binding,vnode)}))},unbind:function(el){el._tippy&&el._tippy.destroy()},componentUpdated:function(el,binding,vnode){if(el._tippy){var opts=deriveOpts(binding);el.getAttribute("title")&&!opts.content&&(opts.content=el.getAttribute("title"),el.removeAttribute("title")),el.getAttribute("content")&&!opts.content&&(opts.content=el.getAttribute("content")),el._tippy.set(opts)}}})}};
/* scoped */"undefined"!==typeof window&&window.Vue&&(window.Vue.use(forms_plugin),window.Vue.component("tippy",TippyComponent));var BoldIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M8 11h4.5a2.5 2.5 0 100-5H8v5zm10 4.5a4.5 4.5 0 01-4.5 4.5H6V4h6.5a4.5 4.5 0 013.256 7.606A4.498 4.498 0 0118 15.5zM8 13v5h5.5a2.5 2.5 0 100-5H8z",fill:"rgba(107,126,145,1)"}})])}},ItalicIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M15 20H7v-2h2.927l2.116-12H9V4h8v2h-2.927l-2.116 12H15z",fill:"rgba(107,126,145,1)"}})])}},UnderlineIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M8 3v9a4 4 0 108 0V3h2v9a6 6 0 11-12 0V3h2zM4 20h16v2H4v-2z",fill:"rgba(107,126,145,1)"}})])}},StrikeIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M13 9h-2V6H5V4h14v2h-6v3zm0 6v5h-2v-5h2zM3 11h18v2H3v-2z",fill:"rgba(107,126,145,1)"}})])}},UnorderListIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M8 4h13v2H8V4zM4.5 6.5a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm0 7a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm0 6.9a1.5 1.5 0 110-3 1.5 1.5 0 010 3zM8 11h13v2H8v-2zm0 7h13v2H8v-2z",fill:"rgba(107,126,145,1)"}})])}},OrderedListIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M8 4h13v2H8V4zM5 3v3h1v1H3V6h1V4H3V3h2zM3 14v-2.5h2V11H3v-1h3v2.5H4v.5h2v1H3zm2 5.5H3v-1h2V18H3v-1h3v4H3v-1h2v-.5zM8 11h13v2H8v-2zm0 7h13v2H8v-2z",fill:"rgba(107,126,145,1)"}})])}},LinkIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M18.364 15.536L16.95 14.12l1.414-1.414a5 5 0 10-7.071-7.071L9.879 7.05 8.464 5.636 9.88 4.222a7 7 0 019.9 9.9l-1.415 1.414zm-2.828 2.828l-1.415 1.414a7 7 0 01-9.9-9.9l1.415-1.414L7.05 9.88l-1.414 1.414a5 5 0 107.071 7.071l1.414-1.414 1.415 1.414zm-.708-10.607l1.415 1.415-7.071 7.07-1.415-1.414 7.071-7.07z",fill:"rgba(107,126,145,1)"}})])}},HighlightIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{viewBox:"0 0 20 20",fill:"none",xmlns:"http://www.w3.org/2000/svg"}},[_c("path",{attrs:{d:"M7.93 11.5h4.14L10 5.98 7.93 11.5zM18 0H2C.9 0 0 .9 0 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V2c0-1.1-.9-2-2-2zm-4.05 16.5l-1.14-3H7.17l-1.12 3H3.96l5.11-13h1.86l5.11 13h-2.09z",fill:"#6B7E91"}})])}},TextColorIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M15.246 14H8.754l-1.6 4H5l6-15h2l6 15h-2.154l-1.6-4zm-.8-2L12 5.885 9.554 12h4.892zM3 20h18v2H3v-2z",fill:"rgba(107,126,145,1)"}})])}},UndoIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M5.828 7l2.536 2.536L6.95 10.95 2 6l4.95-4.95 1.414 1.414L5.828 5H13a8 8 0 110 16H4v-2h9a6 6 0 100-12H5.828z",fill:"rgba(107,126,145,1)"}})])}},RedoIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M18.172 7H11a6 6 0 100 12h9v2h-9a8 8 0 110-16h7.172l-2.536-2.536L17.05 1.05 22 6l-4.95 4.95-1.414-1.414L18.172 7z",fill:"rgba(107,126,145,1)"}})])}},LeftAlignIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M3 4h18v2H3V4zm0 15h14v2H3v-2zm0-5h18v2H3v-2zm0-5h14v2H3V9z",fill:"rgba(107,126,145,1)"}})])}},LeftAlign={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M3 4h18v2H3V4zm0 15h14v2H3v-2zm0-5h18v2H3v-2zm0-5h14v2H3V9z",fill:"rgba(107,126,145,1)"}})])}},CenterAlignIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M3 4h18v2H3V4zm2 15h14v2H5v-2zm-2-5h18v2H3v-2zm2-5h14v2H5V9z",fill:"rgba(107,126,145,1)"}})])}},RightAlignIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M3 4h18v2H3V4zm4 15h14v2H7v-2zm-4-5h18v2H3v-2zm4-5h14v2H7V9z",fill:"rgba(107,126,145,1)"}})])}},UnsetAlignIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",width:"24",height:"24"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M3 4h18v2H3V4zm0 15h18v2H3v-2zm0-5h18v2H3v-2zm0-5h18v2H3V9z",fill:"rgba(107,126,145,1)"}})])}},TableIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M13 10v4h6v-4h-6zm-2 0H5v4h6v-4zm2 9h6v-3h-6v3zm-2 0v-3H5v3h6zm2-14v3h6V5h-6zm-2 0H5v3h6V5zM4 3h16a1 1 0 011 1v16a1 1 0 01-1 1H4a1 1 0 01-1-1V4a1 1 0 011-1z",fill:"rgba(107,126,145,1)"}})])}},ImageIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M5 11.1l2-2 5.5 5.5 3.5-3.5 3 3V5H5v6.1zm0 2.829V19h3.1l2.986-2.985L7 11.929l-2 2zM10.929 19H19v-2.071l-3-3L10.929 19zM4 3h16a1 1 0 011 1v16a1 1 0 01-1 1H4a1 1 0 01-1-1V4a1 1 0 011-1zm11.5 7a1.5 1.5 0 110-3 1.5 1.5 0 010 3z",fill:"rgba(107,126,145,1)"}})])}},BlockquoteIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M19.417 6.679C20.447 7.773 21 9 21 10.989c0 3.5-2.457 6.637-6.03 8.188l-.893-1.378c3.335-1.804 3.987-4.145 4.247-5.621-.537.278-1.24.375-1.929.311-1.804-.167-3.226-1.648-3.226-3.489a3.5 3.5 0 013.5-3.5c1.073 0 2.099.49 2.748 1.179zm-10 0C10.447 7.773 11 9 11 10.989c0 3.5-2.457 6.637-6.03 8.188l-.893-1.378c3.335-1.804 3.987-4.145 4.247-5.621-.537.278-1.24.375-1.929.311C4.591 12.322 3.17 10.841 3.17 9a3.5 3.5 0 013.5-3.5c1.073 0 2.099.49 2.748 1.179z",fill:"rgba(107,126,145,1)"}})])}},LineIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",width:"24",height:"24"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M2 11h2v2H2v-2zm4 0h12v2H6v-2zm14 0h2v2h-2v-2z",fill:"rgba(107,126,145,1)"}})])}},FontSizeIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 110-6.93zM19 18a2 2 0 100-4 2 2 0 000 4z",fill:"rgba(107,126,145,1)"}})])}},IndentLessIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M3 4h18v2H3V4zm0 15h18v2H3v-2zm8-5h10v2H11v-2zm0-5h10v2H11V9zm-8 3.5L7 9v7l-4-3.5z",fill:"rgba(107,126,145,1)"}})])}},IndentMoreIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M3 4h18v2H3V4zm0 15h18v2H3v-2zm8-5h10v2H11v-2zm0-5h10v2H11V9zm-4 3.5L3 16V9l4 3.5z",fill:"rgba(107,126,145,1)"}})])}},UploadImageIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M4 19h16v-7h2v8a1 1 0 01-1 1H3a1 1 0 01-1-1v-8h2v7zm9-10v7h-2V9H6l6-6 6 6h-5z",fill:"rgba(107,126,145,1)"}})])}};
const MAX_ROW_COL=10,delay=1e3,FORMAT_CHAIN_HASH={italic:"toggleItalic",bold:"toggleBold",underline:"toggleUnderline",strike:"toggleStrike",bulletList:"toggleBulletList",orderedList:"toggleOrderedList",blockquote:"toggleBlockquote","indent-less":"unsetBlockquote","indent-more":"setBlockquote",line:"setHorizontalRule",heading:"toggleHeading",link:"setLink",unlink:"unsetLink",undo:"undo",redo:"redo",fontfamily:"setFontFamily",textalign:"setTextAlign",addimage:"setImage",table:"insertTable",setColor:"setColor",unsetColor:"setColor",highlight:"toggleHighlight",unsetHighlight:"unsetHighlight"},FORMAT_COMMAND_HASH={small:"setFontSize",unsetSmall:"unsetFontSize"},FONT_FAMILY={Inter:"Inter","Comic Sans":"Comic Sans MS, Comic Sans",Serif:"serif",Monospace:"monospace",Cursive:"cursive",Garamond:"Garamond",Georgia:"georgia","Sans-Serif":"sans-serif",Tahoma:"tahoma","trebuchet ms":"trebuchet ms",Verdana:"verdana",Default:""},TABLE_FORMAT={"Add Column Before":"addColumnBefore","Add Column After":"addColumnAfter","Delete Column":"deleteColumn","Add Row Before":"addRowBefore","Add Row After":"addRowAfter","Delete Row":"deleteRow","Delete Table":"deleteTable","Merge Cells":"mergeCells","Split Cell":"splitCell","Toggle Header Column":"toggleHeaderColumn","Toggle Header Row":"toggleHeaderRow","Toggle Header Cell":"toggleHeaderCell","Merge Or Split":"mergeOrSplit","Fix Tables":"fixTables"},SMALL_FONT_SIZE=12;Boolean,Boolean,Boolean,Boolean,Boolean,Boolean,Boolean,Boolean,element_ui_common.Dropdown,element_ui_common.DropdownMenu,element_ui_common.DropdownItem,element_ui_common.Popover,element_ui_common.Tooltip,element_ui_common.Dialog;
/* script */var CameraIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{width:"512",height:"512",viewBox:"0 0 512 512",xmlns:"http://www.w3.org/2000/svg"}},[_c("g",{attrs:{transform:"translate(0 48)","fill-rule":"nonzero"}},[_c("path",{attrs:{d:"M0 127.3v226.148C0 387.967 28.003 416 62.485 416h387.03C483.997 416 512 387.967 512 353.448V127.3c0-32.845-26.645-59.518-59.455-59.518h-83.174l-1.985-8.682C359.34 24.268 328.725 0 292.99 0h-74.083c-35.63 0-66.246 24.268-74.397 59.1l-1.985 8.682h-83.07C26.645 67.782 0 94.56 0 127.3zm152.764-33.89c5.956 0 11.076-4.08 12.434-9.938l4.284-18.62c5.434-23.116 25.705-39.225 49.424-39.225h74.083c23.72 0 43.99 16.109 49.424 39.226l4.284 18.619c1.359 5.753 6.479 9.937 12.434 9.937h93.31c18.703 0 33.855 15.167 33.855 33.891v226.148c0 20.398-16.51 36.925-36.885 36.925H62.485c-20.376 0-36.885-16.527-36.885-36.925V127.3c0-18.724 15.151-33.89 33.855-33.89h93.31z"}}),_c("circle",{attrs:{cx:"87",cy:"148",r:"17"}}),_c("path",{attrs:{d:"M256.5 350c59.235 0 107.5-48.265 107.5-107.5S315.735 135 256.5 135 149 183.16 149 242.5 197.265 350 256.5 350zm0-189.405c45.131 0 81.905 36.774 81.905 81.905s-36.774 81.905-81.905 81.905-81.905-36.774-81.905-81.905 36.774-81.905 81.905-81.905z"}})])])}},DeleteIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{viewBox:"0 0 512 512",xmlns:"http://www.w3.org/2000/svg"}},[_c("path",{attrs:{d:"M213.6 0c-11.228 0-22.707 3.917-30.834 12-8.128 8.083-12.066 19.5-12.066 30.667V64H42v42.667h21.45V448c0 35.083 29.075 64 64.35 64h257.4c35.275 0 64.35-28.917 64.35-64V106.667H471V64H342.3V42.667c0-11.167-3.938-22.584-12.066-30.667-8.127-8.083-19.606-12-30.834-12h-85.8zm0 42.667h85.8V64h-85.8V42.667zm-107.25 64h300.3V448c0 11.833-9.552 21.333-21.45 21.333H127.8c-11.898 0-21.45-9.5-21.45-21.333V106.667zm42.9 64v234.666h42.9V170.667h-42.9zm85.8 0v234.666h42.9V170.667h-42.9zm85.8 0v234.666h42.9V170.667h-42.9z"}})])}},FolderIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"16",height:"16"}},[_c("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),_c("path",{attrs:{d:"M15 4H5v16h14V8h-4V4zM3 2.992C3 2.444 3.447 2 3.999 2H16l5 5v13.993A1 1 0 0120.007 22H3.993A1 1 0 013 21.008V2.992zM13 12v4h-2v-4H8l4-4 4 4h-3z",fill:"rgba(107,126,145,1)"}})])}};element_ui_common.Upload,element_ui_common.Dialog;
var script$1={props:{value:{type:void 0,default:void 0},field:{type:Object,default:()=>({})},filter:{type:Object,default:()=>({})},disabled:{type:Boolean,default:!1},isEdit:{type:Boolean,default:!1},resetFields:{type:Boolean,default:!1},currentSite:{type:void 0,default:void 0}},components:{Select:__vue_component__$r},data:()=>({sites:[],loading:!1,selectText:""}),computed:{modelValue:{get(){return this.value},set(value){this.$emit("input",value),this.$emit("update:filter",{site:Number(value)})}},sitesList(){let{sites:sites={}}=this,sitesList=Object.entries(sites||{}).map((([value,label])=>({label:label,value:parseInt(value)})));return sitesList||[]},disableSiteField(){let{isCurrentSiteSelected:isCurrentSiteSelected,disabled:disabled,isEdit:isEdit}=this;return isCurrentSiteSelected||disabled||isEdit},currentSiteId(){let{currentSite:currentSite,sitesList:sitesList}=this||{};if(isEmpty$a(currentSite)&&1===sitesList.length&&isEmpty$a(selectText)){let[site]=sitesList||[],{value:value}=site||{};return value||null}return currentSite},isCurrentSiteSelected(){let{currentSiteId:currentSiteId}=this;return!isEmpty$a(currentSiteId)}},watch:{currentSiteId(newVal,oldVal){isEqual(newVal,oldVal)||this.setSite()},field:{handler(){this.loadSites()},deep:!0}},created(){this.loadSites(),this.setSite()},methods:{async loadSites(){let{field:field,modelVal:modelVal}=this||{},params={field:{...field,lookupModuleName:"site",skipDeserialize:!0}};isEmpty$a(modelVal)||(params["defaultIds"]=[modelVal]);let{options:options,error:error}=await getFieldOptions$3(params);isEmpty$a(error)&&(this.sites=options)},remoteMethod:debounce((async function(query){this.loading=!0;let{field:field}=this||{};isEmpty$a(query)?this.selectText=null:this.selectText=query;let{options:options,error:error}=await getFieldOptions$3({field:{...field,lookupModuleName:"site",skipDeserialize:!0},searchText:query});isEmpty$a(error)&&(this.sites=options),this.loading=!1}),1e3),setSite(){let{modelVal:modelVal,currentSiteId:currentSiteId,isEdit:isEdit}=this;
// Skip setting site id for edit case
isEdit||isEmpty$a(currentSiteId)||Number(modelVal)===currentSiteId||(this.$set(this,"modelVal",currentSiteId),this.$emit("handleChange"))},onSiteChange(){
// Here model returns the previous site id
let{resetFields:resetFields,value:value}=this,siteId=isEmpty$a(value)?null:value;resetFields&&this.$emit("handleSiteSwitch",siteId),this.$emit("handleChange")}}};
/* script */const __vue_script__$1=script$1;
/* template */var __vue_render__=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("Select",{attrs:{options:_vm.sitesList,placeholder:"Select Site",disabled:_vm.disableSiteField,clearable:!0,filterable:!0,remoteMethod:_vm.remoteMethod,loading:_vm.loading},on:{change:_vm.onSiteChange},model:{value:_vm.modelValue,callback:function($$v){_vm.modelValue=$$v},expression:"modelValue"}})},__vue_staticRenderFns__=[];
/* style */
const __vue_inject_styles__$1=void 0,__vue_scope_id__$1="data-v-2ef2d8aa",__vue_module_identifier__$1=void 0,__vue_is_functional_template__$1=!1,__vue_component__$1=normalizeComponent$a({render:__vue_render__,staticRenderFns:__vue_staticRenderFns__},__vue_inject_styles__$1,__vue_script__$1,__vue_scope_id__$1,__vue_is_functional_template__$1,__vue_module_identifier__$1,!1,void 0,void 0,void 0),FIELD_VALUE_HASH={site_header(field){const h=this.$createElement;let{name:name}=field;return h(__vue_component__$1,{attrs:{field:field,resetFields:!0},on:{"update:filter":siteObj=>this.handleSiteSwitch(siteObj,field)},model:{value:this.lookupValues[name],callback:$$v=>{this.$set(this.lookupValues,name,$$v)}}})},enum_header(field){const h=this.$createElement;let{name:name,field:fieldObj}=field||{},{enumMap:enumMap}=fieldObj||{},options=[];for(let[value,label]of Object.entries(enumMap))options.push({label:label,value:value});return h(__vue_component__$r,{class:"fc-input-full-border-select2 fc-tag w-full",attrs:{options:options,labelName:"label",valueName:"value",clearable:!0,multiple:!0},model:{value:this.filters[name].value,callback:$$v=>{this.$set(this.filters[name],"value",$$v)}}})},date_header(field,type){const h=this.$createElement;let{name:name}=field||{};return h(__vue_component__$7,{class:"w-full",attrs:{type:`${type}range`,disabled:this.disableValueContainer,placeholder:"Select a date",account:this.account,hideClear:!1},model:{value:this.filters[name].value,callback:$$v=>{this.$set(this.filters[name],"value",$$v)}}})},input_header(field,type){const h=this.$createElement;let{name:name}=field;return h(__vue_component__$u,{attrs:{clearable:!0,type:type},model:{value:this.filters[name].value,callback:$$v=>{this.$set(this.filters[name],"value",$$v)}}})},boolean_header(field){const h=this.$createElement;let{name:name}=field,falseVal=field.falseVal?field.falseVal:"No",trueVal=field.trueVal?field.trueVal:"Yes",options=[{label:trueVal,value:!0},{label:falseVal,value:!1}];return h(__vue_component__$r,{class:"fc-input-full-border-select2 fc-tag w-full",key:`${field.name} Value`,attrs:{options:options,labelName:"label",valueName:"value",clearable:!0},model:{value:this.filters[name].value,callback:$$v=>{this.$set(this.filters[name],"value",$$v)}}})},lookup_header(field){const h=this.$createElement;let{name:name}=field;return h("div",{class:"width-full"},[h(__vue_component__$s,{class:"width-full",key:`${field.name} Value`,attrs:{field:field,hideLookupIcon:this.canHidePopupIcon(field),hideDropDown:this.hideDropDown(field),disabled:!1,popperAppendToBody:!0},on:{showLookupWizard:(field,val)=>{this.showLookupWizard(field,val)},recordSelected:this.recordSelected},model:{value:this.lookupValues[name],callback:$$v=>{this.$set(this.lookupValues,name,$$v)}}}),this.canShowLookupWizard&&this.currentWizardField===name&&h(__vue_component__$8,{attrs:{canShowLookupWizard:this.canShowLookupWizard,quickSearchEnabled:!0,field:field},on:{"update:canShowLookupWizard":val=>this.canShowLookupWizard=val,setLookupFieldValue:prop=>this.setLookupFieldValue(prop)}})])}},DISPLAY_TYPE={DURATION_header(field){return this["input_header"](field,"number")},ENUM_header(field){return this["enum_header"](field)},MULTI_ENUM_header(field){return this["enum_header"](field)},DATE_header(field){return this["date_header"](field,"date")},DATE_TIME_header(field){return this["date_header"](field,"datetime")},STRING_header(field){return this["input_header"](field,"text")},NUMBER_header(field){return this["input_header"](field,"number")},ID_header(field){return this["input_header"](field,"number")},DECIMAL_header(field){return this["input_header"](field,"number")},CURRENCY_header(field){return this["input_header"](field,"number")},MULTI_CURRENCY_header(field){return this["input_header"](field,"number")},BOOLEAN_header(field){return this["boolean_header"](field)},BIG_STRING_header(field){return this["input_header"](field,"text")},LOOKUP_header(field){return this["lookup_header"](field)},MULTI_LOOKUP_header(field){return this["lookup_header"](field)},SITE_header(field){return this["site_header"](field)}};
/* scoped */vue_runtime_esm["default"].component(element_ui_common.Checkbox.name,element_ui_common.Checkbox);const formatDate=(date,excludeTime,onlyTime)=>{let dateformat="DD-MMM-YYYY",timeformat="HH:mm";
// let orgformatArray = orgformat.match(/DD-MMM-YYYY (HH:mm)/)
return onlyTime?moment_timezone(date).format(timeformat):excludeTime?moment_timezone(date).format(dateformat):moment_timezone(date).format(dateformat+" "+timeformat)},getFormattedDuration=(value,format="milliseconds",skipDurationCreation=!1)=>{if(!value)return"00:00 Hrs";let duration;duration=skipDurationCreation?value:moment_timezone.duration(parseInt(value,10),format);let days=parseInt(duration.asDays(),10),hours=duration.hours(),minutes=duration.minutes(),seconds=duration.seconds();return days>0?1===days?hours?`${days} Day ${hours} Hrs`:`${days} Day`:hours?`${days} Days ${hours} Hrs`:`${days} Days`:hours>0?minutes?`${hours} Hrs ${minutes} Mins`:`${hours} Hrs`:minutes>0?seconds?`${minutes} Mins ${seconds} Secs`:`${minutes} Mins`:`${seconds} Secs`},DATA_TYPE_VALUE_HASH={LOOKUP(field,data){let{name:fieldName}=field,{primaryValue:primaryValue,name:name,displayName:displayName,subject:subject}=data[fieldName]||{},value=displayName||name||subject;return isEmpty$a(primaryValue)?value:primaryValue},FILE(field,data){let filename=data[`${field.name}FileName`];return filename},DATE(field,data){let{name:name}=field||{},value=data[name];return value&&-1!==value?formatDate(value,!0):""},DATE_TIME(field,data){let{name:name}=field||{},value=data[name];return value&&-1!==value?formatDate(value):""},ENUM(field,data){let{name:name}=field||{},value=data[name],fieldObj=field.field;return value=value?fieldObj.enumMap[data[fieldObj.name]]:value,value},SYSTEM_ENUM(field,data){let{name:name}=field||{},value=data[name],fieldObj=field.field;return value=value?fieldObj.enumMap[data[fieldObj.name]]:value,value},MULTI_ENUM(field,data){let{name:name,enumMap:enumMap}=field.field||{},values=data[name]||[],valueStr=values.reduce(((accStr,value)=>{let str=enumMap[value]||"";return isEmpty$a(accStr)?`${str}`:`${accStr}, ${str}`}),"");return isEmpty$a(valueStr)?"---":valueStr},BOOLEAN(field,data){let{name:name}=field||{},value=data[name]?field.trueVal||"Yes":field.falseVal||"No";return value},MULTI_LOOKUP(field,data){let{name:name}=field,value=data[name]||[],lookupRecordNames=(value||[]).map((currRecord=>currRecord.displayName||currRecord.name||currRecord.subject));return lookupRecordNames.length>2?`${lookupRecordNames.slice(0,2).join(", ")} +${Math.abs(lookupRecordNames.length-2)}`:isEmpty$a(lookupRecordNames)?"---":`${lookupRecordNames.join(", ")}`},OTHERS(field,data){let{name:name}=field||{};if(!isObject$5(data[name]))return data[name];{let{name:name}=data[name]||{};if(!isEmpty$a(name))return name;data[name]}}},DISPLAY_TYPE_HASH={DURATION(field,record){const h=this.$createElement;let{name:name}=field,value=record[name]||[];return h("div",[isEmpty$a(value)||"---"===value?"---":getFormattedDuration(value,isEmpty$a(field.unit)?"s":field.unit)])},URL_FIELD(field,record){const h=this.$createElement;let{name:name}=field||{};if(isEmpty$a(record[name]))return"---";{let{name:displayName,href:href,target:target}=record[name]||{},value=isEmpty$a(displayName)?href:displayName;return h(element_ui_common.Tooltip,{attrs:{effect:"dark",content:value,placement:"bottom-start"}},[h("a",{attrs:{rel:"nofollow",referrerpolicy:"no-referrer",href:href,target:target},class:"url-field-display truncate-text"},[h("span",{class:"textoverflow-ellipsis"},[value])])])}},OTHERS(field,record){const h=this.$createElement;return h("div",{class:"truncate-text"},[this.getColumnDisplayValue(field,record)])}};
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.unshift.js
__webpack_require__(891719);
// EXTERNAL MODULE: ./node_modules/@vue/babel-helper-vue-jsx-merge-props/dist/helper.js
var dist_helper=__webpack_require__(36568),esm_browser_v4=__webpack_require__(58180),uniqBy=__webpack_require__(545578);__webpack_require__(85415);// CONCATENATED MODULE: ./node_modules/@facilio/criteria/dist/index.mjs
function dist_typeof(o){return dist_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},dist_typeof(o)}function dist_toPrimitive(input,hint){if("object"!==dist_typeof(input)||null===input)return input;var prim=input[Symbol.toPrimitive];if(void 0!==prim){var res=prim.call(input,hint||"default");if("object"!==dist_typeof(res))return res;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===hint?String:Number)(input)}function dist_toPropertyKey(arg){var key=dist_toPrimitive(arg,"string");return"symbol"===dist_typeof(key)?key:String(key)}function dist_defineProperty(obj,key,value){return key=dist_toPropertyKey(key),key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function dist_ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}function dist_objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?dist_ownKeys(Object(t),!0).forEach((function(r){dist_defineProperty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):dist_ownKeys(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function dist_arrayLikeToArray(arr,len){(null==len||len>arr.length)&&(len=arr.length);for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2}function dist_arrayWithoutHoles(arr){if(Array.isArray(arr))return dist_arrayLikeToArray(arr)}function dist_iterableToArray(iter){if("undefined"!==typeof Symbol&&null!=iter[Symbol.iterator]||null!=iter["@@iterator"])return Array.from(iter)}function dist_unsupportedIterableToArray(o,minLen){if(o){if("string"===typeof o)return dist_arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);return"Object"===n&&o.constructor&&(n=o.constructor.name),"Map"===n||"Set"===n?Array.from(o):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?dist_arrayLikeToArray(o,minLen):void 0}}function dist_nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function dist_toConsumableArray(arr){return dist_arrayWithoutHoles(arr)||dist_iterableToArray(arr)||dist_unsupportedIterableToArray(arr)||dist_nonIterableSpread()}function dist_regeneratorRuntime(){dist_regeneratorRuntime=function(){return e};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t[e]=r.value},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{define({},"")}catch(t){define=function(t,e,r){return t[e]=r}}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a}function tryCatch(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,(function(){return this}));var d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach((function(e){define(t,e,(function(t){return this._invoke(e,t)}))}))}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;return h&&"object"==dist_typeof(h)&&n.call(h,"__await")?e.resolve(h.__await).then((function(t){invoke("next",t,i,a)}),(function(t){invoke("throw",t,i,a)})):e.resolve(h).then((function(t){u.value=t,i(u)}),(function(t){return invoke("throw",t,i,a)}))}a(c.arg)}var r;o(this,"_invoke",{value:function(t,n){function callInvokeWithMethodAndArg(){return new e((function(e,r){invoke(t,n,e,r)}))}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw new Error("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0}}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(o===h)throw o=s,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done}}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg)}}}function maybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator["return"]&&(r.method="return",r.arg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n+"' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function resetTryEntry(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0)}function values(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){for(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next};return i.next=i}}throw new TypeError(dist_typeof(e)+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create(g),t},e.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,(function(){return this})),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);return e.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},defineIteratorMethods(g),define(g,u,"Generator"),define(g,a,(function(){return this})),define(g,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next}return next.done=!0,next}},e.values=values,Context.prototype={constructor:Context,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("root"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0)}else{if(!u)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),y}},e}function dist_asyncGeneratorStep(gen,resolve,reject,_next,_throw,key,arg){try{var info=gen[key](arg),value=info.value}catch(error){return void reject(error)}info.done?resolve(value):Promise.resolve(value).then(_next,_throw)}function dist_asyncToGenerator(fn){return function(){var self=this,args=arguments;return new Promise((function(resolve,reject){var gen=fn.apply(self,args);function _next(value){dist_asyncGeneratorStep(gen,resolve,reject,_next,_throw,"next",value)}function _throw(err){dist_asyncGeneratorStep(gen,resolve,reject,_next,_throw,"throw",err)}_next(void 0)}))}}function dist_arrayWithHoles(arr){if(Array.isArray(arr))return arr}function dist_iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t["return"]&&(u=t["return"](),Object(u)!==u))return}finally{if(o)throw n}}return a}}function dist_nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function dist_slicedToArray(arr,i){return dist_arrayWithHoles(arr)||dist_iterableToArrayLimit(arr,i)||dist_unsupportedIterableToArray(arr,i)||dist_nonIterableRest()}var dist_isLookupTypeField=function(field){var _ref=field||{},displayType=_ref.displayType;return["LOOKUP_SIMPLE","MULTI_LOOKUP_SIMPLE"].includes(displayType)},dist_isLookupPopupField=function(field){var _ref2=field||{},displayType=_ref2.displayType;return["LOOKUP_POPUP"].includes(displayType)},isPicklistTypeField=function(field){var _ref3=field||{},displayType=_ref3.displayType;return["SELECTBOX","MULTI_SELECTBOX"].includes(displayType)},isBooleanTypeField=function(field){var _ref4=field||{},displayType=_ref4.displayType;return["DECISION_BOX"].includes(displayType)},dist_isLookupField=function(field){var _ref5=field||{},displayType=_ref5.displayType;return["LOOKUP_SIMPLE"].includes(displayType)},dist_isMultiLookupField=function(field){var _ref6=field||{},displayType=_ref6.displayType;return["MULTI_LOOKUP_SIMPLE"].includes(displayType)},dist_isDateTypeField=function(field){var _ref7=field||{},displayType=_ref7.displayType;return["DATETIME","DATE"].includes(displayType)},dist_FIELD_VALUE_HASH={time:function(_ref){var _this=this,field=_ref.field,h=this.$createElement;return h(__vue_component__$t,{attrs:{timeFormat:this.getTimeFormat(),field:field,disabled:this.disableValueContainer,placeholder:"Select Time"},key:"".concat(field.name," Value"),class:"el-select fc-input-full-border-select2 width100",model:{value:_this.fieldValue,callback:function($$v){_this.fieldValue=$$v}}})},lookup:function(_ref2){var _this2=this,field=_ref2.field,h=this.$createElement;return h("div",{class:"w-full"},[h(__vue_component__$s,{class:"width-full",key:"".concat(field.name," Value"),attrs:{field:field,hideLookupIcon:this.canHidePopupIcon,hideDropDown:this.hideDropDown,disabled:this.disableValueContainer,customOptions:this.getCustomOption()},on:dist_objectSpread2(dist_objectSpread2({},{input:function(val){return _this2.$set(_this2,"fieldValue",(0,validation/* isEmpty */.xb)(val)?null:val)}}),{},{showLookupWizard:this.showLookupWizard}),model:{value:_this2.fieldValue,callback:function($$v){_this2.fieldValue=$$v}}}),this.canShowLookupWizard&&h(__vue_component__$8,{attrs:{quickSearchEnabled:this.quickSearchEnabled,canShowLookupWizard:this.canShowLookupWizard,field:field},on:dist_objectSpread2({},{"update:canShowLookupWizard":function(val){return _this2.canShowLookupWizard=val},setLookupFieldValue:this.setLookupFieldValue})})])},select:function(_ref3){var _this3=this,field=_ref3.field,isMultiple=_ref3.isMultiple,h=this.$createElement;return h(__vue_component__$r,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:isMultiple,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:field.options},model:{value:_this3.fieldValue,callback:function($$v){_this3.fieldValue=$$v}}})},input:function(){var _this4=this,_ref4=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},_ref4$type=_ref4.type,type=void 0===_ref4$type?"":_ref4$type,h=this.$createElement;return h(__vue_component__$u,{class:"w-full",attrs:{placeholder:this.inputPlaceHolder,type:type,disabled:this.disableValueContainer},model:{value:_this4.fieldValue,callback:function($$v){_this4.fieldValue=$$v}}})},currency:function(){var _this5=this,h=this.$createElement;return h(element_ui_common.Input,{class:"fc-input-full-border2 fc-slot-input-prepend",attrs:{disabled:this.disableValueContainer},model:{value:_this5.fieldValue,callback:function($$v){_this5.fieldValue=$$v}}},[h("div",{class:"currency-symbol",slot:"prepend"},[this.orgCurrency])])},multi_currency:function(){var _this6=this,h=this.$createElement;return h(element_ui_common.Input,{class:"fc-input-full-border2 fc-slot-input-prepend",attrs:{disabled:this.disableValueContainer},model:{value:_this6.fieldValue,callback:function($$v){_this6.fieldValue=$$v}}},[h("div",{class:"currency-symbol",slot:"prepend"},[this.orgCurrency])])},date:function(_ref5){var _this7=this,type=_ref5.type,hasTime=_ref5.hasTime,h=this.$createElement;return h(__vue_component__$7,{class:"w-full",attrs:{type:type,disabled:this.disableValueContainer,placeholder:"Select a date ".concat(hasTime?"time":""),account:this.account},model:{value:_this7.fieldValue,callback:function($$v){_this7.fieldValue=$$v}}})}},dist_FIELD_DISPLAY_TYPE_HASH={NUMBER:function(){return this["input"]({type:"number"})},DECIMAL:function(){return this["input"]({type:"number"})},SELECTBOX:function(field){return this["select"]({field:field,isMultiple:!0})},MULTI_SELECTBOX:function(field){return this["select"]({field:field,isMultiple:!0})},DECISION_BOX:function(field){return this["select"]({field:field,isMultiple:!1})},DATE:function(){return this["date"]({type:"date"})},DATETIME:function(){return this["date"]({type:"datetime",hasTime:!0})},DURATION:function(){return this["input"]({type:"number"})},LOOKUP_SIMPLE:function(field){return this["lookup"]({field:field})},MULTI_LOOKUP_SIMPLE:function(field){return this["lookup"]({field:field})},LOOKUP_POPUP:function(field){return this["lookup"]({field:field})},DEFAULT:function(){return this["input"]()},CURRENCY:function(){return this["currency"]()},MULTI_CURRENCY:function(){return this["multi_currency"]()},TIME:function(field){return this["time"]({field:field})}},dist_WEEK_DAYS_OPTIONS=[{label:"Monday",value:1},{label:"Tuesday",value:2},{label:"Wednesday",value:3},{label:"Thursday",value:4},{label:"Friday",value:5},{label:"Saturday",value:6},{label:"Sunday",value:7}],dist_MONTH_OPTIONS=[{label:"January",value:1},{label:"February",value:2},{label:"March",value:3},{label:"April",value:4},{label:"May",value:5},{label:"June",value:6},{label:"July",value:7},{label:"August",value:8},{label:"September",value:9},{label:"October",value:10},{label:"November",value:11},{label:"December",value:12}],dist_dateTimeOperator={84:"Month",85:"Day of Week",101:"Day of Month",102:"Day of Year",103:"Hours of Day",106:"Before N Days",107:"After N Days",108:"Week of Year"},dist_WEEK_DAYS={1:"Monday",2:"Tuesday",3:"Wednesday",4:"Thursday",5:"Friday",6:"Saturday",7:"Sunday"},dist_MONTHS=[{label:"January",value:1},{label:"February",value:2},{label:"March",value:3},{label:"April",value:4},{label:"May",value:5},{label:"June",value:6},{label:"July",value:7},{label:"August",value:8},{label:"September",value:9},{label:"October",value:10},{label:"November",value:11},{label:"December",value:12}],dist_ordinalSuffixOf=function(day){var j=day%10,k=day%100;return"".concat(day,1==j&&11!=k?"st":2==j&&12!=k?"nd":3==j&&13!=k?"rd":"th")},dist_SPECIAL_VALUE_HASH={SPECIAL_20:function(field){var _this=this,h=this.$createElement,_ref=field||{},_ref$displayType=_ref.displayType,displayType=void 0===_ref$displayType?"":_ref$displayType,hasTime="DATETIME"===displayType,type=displayType.toLowerCase();return h(__vue_component__$7,{class:"w-full",attrs:{type:"".concat(type,"range"),disabled:this.disableValueContainer,placeholder:"Select a date ".concat(hasTime?"time":""),account:this.account},model:{value:_this.fieldValue,callback:function($$v){_this.fieldValue=$$v}}})},SPECIAL_81:function(){var _this2=this,h=this.$createElement;
// Number - between
return h("div",{class:"flex w-full"},[h(__vue_component__$u,{class:"flex flex-grow pr-1",attrs:{type:"number",placeholder:"Enter start value"},model:{value:_this2.fieldValue0,callback:function($$v){_this2.fieldValue0=$$v}}}),h(__vue_component__$u,{class:"flex flex-grow pl-1",attrs:{type:"number",placeholder:"Enter end value"},model:{value:_this2.fieldValue1,callback:function($$v){_this2.fieldValue1=$$v}}})])},SPECIAL_84:function(field){var _this3=this,h=this.$createElement;
// Month
return h(__vue_component__$r,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:dist_MONTH_OPTIONS},model:{value:_this3.fieldValue,callback:function($$v){_this3.fieldValue=$$v}}})},SPECIAL_85:function(field){var _this4=this,h=this.$createElement;
// Date - day of week
return h(__vue_component__$r,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:dist_WEEK_DAYS_OPTIONS},model:{value:_this4.fieldValue,callback:function($$v){_this4.fieldValue=$$v}}})},SPECIAL_101:function(field){var _this5=this,h=this.$createElement,options=Array(30).fill().map((function(_,index){return{label:"".concat(dist_ordinalSuffixOf(index+1)," day"),value:index+1}}));return h(__vue_component__$r,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:options},model:{value:_this5.fieldValue,callback:function($$v){_this5.fieldValue=$$v}}})},SPECIAL_103:function(field){var _this6=this,h=this.$createElement,options=Array(24).fill().map((function(_,index){return{label:"".concat(index+1," hour").concat(index>0?"s":""),value:index+1}}));return h(__vue_component__$r,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:options},model:{value:_this6.fieldValue,callback:function($$v){_this6.fieldValue=$$v}}})},SPECIAL_106:function(){var _this7=this,h=this.$createElement;
// Date - n days
return h(__vue_component__$u,{class:"flex flex-grow pr-1 w-full",attrs:{type:"number",placeholder:"Enter number of days"},model:{value:_this7.fieldValue,callback:function($$v){_this7.fieldValue=$$v}}})},SPECIAL_61:function(){var _this8=this,h=this.$createElement,operatorObj=this.operatorObj,id=operatorObj.id,isDefaultValuePresent="61-7"===id||"61-2"===id,isDisabled=!!isDefaultValuePresent;return h(__vue_component__$u,{class:"flex flex-grow pr-1 w-full",attrs:{type:"number",placeholder:"Enter number of days",disabled:isDisabled},model:{value:_this8.fieldValue,callback:function($$v){_this8.fieldValue=$$v}}})},SPECIAL_108:function(field){var _this9=this,h=this.$createElement,options=Array(52).fill().map((function(_,index){return{label:"".concat(index+1," week").concat(index>0?"s":""),value:index+1}}));return h(__vue_component__$r,{class:"fc-input-full-border-select2 fc-tag w-full",key:"".concat(field.name," Value"),attrs:{multiple:!0,"collapse-tags":!0,disabled:this.disableValueContainer,labelName:"label",valueName:"value",options:options},model:{value:_this9.fieldValue,callback:function($$v){_this9.fieldValue=$$v}}})},CURRENCY_122:function(){var _this10=this,h=this.$createElement;return h("div",{class:"currency-range-container"},[h(element_ui_common.Input,{class:"fc-input-full-border2 fc-slot-input-prepend",attrs:{disabled:this.disableValueContainer},model:{value:_this10.fieldValue0,callback:function($$v){_this10.fieldValue0=$$v}}},[h("div",{class:"currency-symbol",slot:"prepend"},[this.orgCurrency])]),h("div",{class:"seperator"},["-"]),h(element_ui_common.Input,{class:"fc-input-full-border2 fc-slot-input-prepend",attrs:{disabled:this.disableValueContainer},model:{value:_this10.fieldValue1,callback:function($$v){_this10.fieldValue1=$$v}}},[h("div",{class:"currency-symbol",slot:"prepend"},[this.orgCurrency])])])},CURRENCY_123:function(){var _this11=this,h=this.$createElement;return h("div",{class:"currency-range-container"},[h(element_ui_common.Input,{class:"fc-input-full-border2 fc-slot-input-prepend",attrs:{disabled:this.disableValueContainer},model:{value:_this11.fieldValue0,callback:function($$v){_this11.fieldValue0=$$v}}},[h("div",{class:"currency-symbol",slot:"prepend"},[this.orgCurrency])]),h("div",{class:"seperator"},["-"]),h(element_ui_common.Input,{class:"fc-input-full-border2 fc-slot-input-prepend",attrs:{disabled:this.disableValueContainer},model:{value:_this11.fieldValue1,callback:function($$v){_this11.fieldValue1=$$v}}},[h("div",{class:"currency-symbol",slot:"prepend"},[this.orgCurrency])])])},MULTI_CURRENCY_140:function(){var _this12=this,h=this.$createElement;return h("div",{class:"outer-currency el-input__inner"},[h("div",{class:"currency-range-container-input"},[this.orgCurrency]),h("input",dist_helper([{on:{input:function($event){$event.target.composing||(_this12.fieldValue0=$event.target.value)}},attrs:{disabled:this.disableValueContainer,type:"number"},class:"currency-range-input",domProps:{value:_this12.fieldValue0}},{directives:[{name:"model",value:_this12.fieldValue0,modifiers:{}}]}])),h("div",{class:"seperator"},["-"]),h("input",dist_helper([{on:{input:function($event){$event.target.composing||(_this12.fieldValue1=$event.target.value)}},attrs:{disabled:this.disableValueContainer,type:"number"},class:"currency-range-input",domProps:{value:_this12.fieldValue1}},{directives:[{name:"model",value:_this12.fieldValue1,modifiers:{}}]}]))])},MULTI_CURRENCY_141:function(){var _this13=this,h=this.$createElement;return h("div",{class:"outer-currency el-input__inner"},[h("div",{class:"currency-range-container-input"},[this.orgCurrency]),h("input",dist_helper([{on:{input:function($event){$event.target.composing||(_this13.fieldValue0=$event.target.value)}},attrs:{disabled:this.disableValueContainer,type:"number"},class:"currency-range-input",domProps:{value:_this13.fieldValue0}},{directives:[{name:"model",value:_this13.fieldValue0,modifiers:{}}]}])),h("div",{class:"seperator"},["-"]),h("input",dist_helper([{on:{input:function($event){$event.target.composing||(_this13.fieldValue1=$event.target.value)}},attrs:{disabled:this.disableValueContainer,type:"number"},class:"currency-range-input",domProps:{value:_this13.fieldValue1}},{directives:[{name:"model",value:_this13.fieldValue1,modifiers:{}}]}]))])}},dist_SPECIAL_OPERATOR_HASH={DATETIME_61:function(field){return this["SPECIAL_61"](field)},DATETIME_20:function(field){return this["SPECIAL_20"](field)},DATETIME_84:function(field){return this["SPECIAL_84"](field)},DATETIME_85:function(field){return this["SPECIAL_85"](field)},DATETIME_101:function(field){return this["SPECIAL_101"](field)},DATETIME_103:function(field){return this["SPECIAL_103"](field)},DATETIME_106:function(field){return this["SPECIAL_106"](field)},DATETIME_107:function(field){return this["SPECIAL_106"](field)},DATETIME_108:function(field){return this["SPECIAL_108"](field)},DATE_61:function(field){return this["SPECIAL_61"](field)},DATE_20:function(field){return this["SPECIAL_20"](field)},DATE_84:function(field){return this["SPECIAL_84"](field)},DATE_85:function(field){return this["SPECIAL_85"](field)},DATE_101:function(field){return this["SPECIAL_101"](field)},DATE_103:function(field){return this["SPECIAL_103"](field)},DATE_106:function(field){return this["SPECIAL_106"](field)},DATE_107:function(field){return this["SPECIAL_106"](field)},DATE_108:function(field){return this["SPECIAL_108"](field)},NUMBER_81:function(){return this["SPECIAL_81"]()},NUMBER_82:function(){return this["SPECIAL_81"]()}},dist_LOOKUP_FIELD_PLACEHOLDER_MAP={people:{value:"${LOGGED_PEOPLE}",label:"Current User"},users:{value:"${LOGGED_USER}",label:"Current User"}},dist_SPECIAL_KEY=["DATETIME_20","DATETIME_84","DATETIME_85","DATETIME_101","DATETIME_103","DATETIME_108","DATE_20","DATE_84","DATE_85","DATE_101","DATE_103","DATE_108"],CURRENCY_KEY=["CURRENCY_122","CURRENCY_123"],MULTI_CURRENCY_KEY=["MULTI_CURRENCY_140","MULTI_CURRENCY_141"],dist_script$b={name:"ConditionValue",props:["field","disableValueContainer","account","isSpecialOperator","operatorObj"],data:function(){return{canShowLookupWizard:!1,quickSearchEnabled:!1}},computed:{fieldValue:{get:function(){var _ref=this||{},$attrs=_ref.$attrs,field=_ref.field,operatorObj=_ref.operatorObj,_ref2=$attrs||{},value=_ref2.value,_ref3=operatorObj||{},operatorId=_ref3.operatorId,_ref4=field||{},displayType=_ref4.displayType,specialKey="".concat(displayType,"_").concat(operatorId);if(dist_SPECIAL_KEY.includes(specialKey)&&!(0,validation/* isEmpty */.xb)(value))return this.serializeDateValues(value);if(CURRENCY_KEY.includes(specialKey)&&(0,validation/* isEmpty */.xb)(value))return[];if(MULTI_CURRENCY_KEY.includes(specialKey)){if((0,validation/* isEmpty */.xb)(value))return[];var valueArray=String(value).split(",");return valueArray}return value},set:function(value){this.$emit("input",value)}},fieldValue0:{get:function(){var _this$fieldValue=this.fieldValue,fieldValue=void 0===_this$fieldValue?[]:_this$fieldValue;return(0,validation/* isEmpty */.xb)(fieldValue)?null:fieldValue[0]},set:function(value){var fieldValue=this.fieldValue,_ref5=fieldValue||["",""],_ref6=dist_slicedToArray(_ref5,2),secondIndexValue=_ref6[1];secondIndexValue?this.$set(this,"fieldValue",[value,secondIndexValue]):this.$set(this,"fieldValue",[value,""])}},fieldValue1:{get:function(){var _this$fieldValue2=this.fieldValue,fieldValue=void 0===_this$fieldValue2?[]:_this$fieldValue2;return(0,validation/* isEmpty */.xb)(fieldValue)?null:fieldValue[1]},set:function(value){var fieldValue=this.fieldValue,_ref7=fieldValue||["",""],_ref8=dist_slicedToArray(_ref7,1),firstIndexValue=_ref8[0];firstIndexValue?this.$set(this,"fieldValue",[firstIndexValue,value]):this.$set(this,"fieldValue",["",value])}},
// lookup properties
canHidePopupIcon:function(){var field=this.field,_ref9=field||{},lookupModule=_ref9.lookupModule,_ref10=lookupModule||{},_ref10$showPopup=_ref10.showPopup,showPopup=void 0===_ref10$showPopup||_ref10$showPopup;return!showPopup},hideDropDown:function(){
// Have to hide dropdown for resource type fields
var field=this.field,name=field.name;return"resource"===name},inputPlaceHolder:function(){var field=this.field;return(0,validation/* isEmpty */.xb)(field)?"N/A":"Enter a value"},key:function(){var field=this.field;return(0,validation/* isEmpty */.xb)(field)?"empty":null===field||void 0===field?void 0:field.name},orgCurrency:function(){var account=this.account,data=account.data,currencyInfo=data.currencyInfo,_ref11=currencyInfo||{},displaySymbol=_ref11.displaySymbol;return displaySymbol}},methods:dist_objectSpread2(dist_objectSpread2(dist_objectSpread2(dist_objectSpread2({serializeDateValues:function(value){var dateArray=String(value).split(","),dates=dateArray.map((function(date){return parseInt(date)}));return dates},getFieldValueDisplay:function(){var isQuickSearchEnabled=JSON.parse(window.localStorage.getItem("QUICK_SEARCH"));isQuickSearchEnabled&&(this.quickSearchEnabled=!0);var field=this.field,isSpecialOperator=this.isSpecialOperator,operatorObj=this.operatorObj,fieldObj=field.field||field,_ref12=fieldObj||{},displayType=_ref12.displayType,_ref13=operatorObj||{},operatorId=_ref13.operatorId,specialHashKey="".concat(displayType,"_").concat(operatorId);return isSpecialOperator&&!(0,validation/* isEmpty */.xb)(dist_SPECIAL_OPERATOR_HASH[specialHashKey])?this[specialHashKey](field):"CURRENCY"===displayType?122===operatorId||123===operatorId?this[specialHashKey]():this["CURRENCY"]():"MULTI_CURRENCY"===displayType?140===operatorId||141===operatorId?this[specialHashKey]():this["MULTI_CURRENCY"]():(0,validation/* isEmpty */.xb)(dist_FIELD_DISPLAY_TYPE_HASH[displayType])?this["DEFAULT"](field):this[displayType](field)},getCustomOption:function(){var _ref14=this||{},field=_ref14.field,_ref15=field||{},lookupModule=_ref15.lookupModule,filterObj=_ref15.filterObj,_ref16=filterObj||{},operatorId=_ref16.operatorId;if((0,validation/* isEmpty */.xb)(lookupModule))return[];var _ref17=lookupModule||{},name=_ref17.name;
// 87 is a with role operator id so can't show current user
return(0,validation/* isEmpty */.xb)(dist_LOOKUP_FIELD_PLACEHOLDER_MAP[name])||87===operatorId?[]:[dist_LOOKUP_FIELD_PLACEHOLDER_MAP[name]]},getTimeFormat:function(){var timeformat=this.account.org.timeFormat;return timeformat},resetValue:function(){this.$set(this,"fieldValue",null)},
// lookup methods
showLookupWizard:function(){this.canShowLookupWizard=!0},setLookupFieldValue:function(props){var selectedLookupField=this.field,field=props.field;(0,validation/* isEmpty */.xb)(selectedLookupField)&&(this.selectedLookupField=field);var _ref18=field||{},selectedItems=_ref18.selectedItems,_ref18$options=_ref18.options,options=void 0===_ref18$options?[]:_ref18$options,multiple=_ref18.multiple,selectedItemIds=[];if(!(0,validation/* isEmpty */.xb)(selectedItems))if(selectedItemIds=selectedItems.map((function(item){return item.value})),(0,validation/* isEmpty */.xb)(options))options=dist_toConsumableArray(selectedItems);else{var _options,ids=options.map((function(item){return item.value})),newOptions=selectedItems.filter((function(item){return!ids.includes(item.value)}));(_options=options).unshift.apply(_options,dist_toConsumableArray(newOptions))}this.$set(this.field,"options",options),this.fieldValue=multiple?selectedItemIds:selectedItemIds[0]}},dist_FIELD_VALUE_HASH),dist_FIELD_DISPLAY_TYPE_HASH),dist_SPECIAL_OPERATOR_HASH),dist_SPECIAL_VALUE_HASH),render:function(){var h=arguments[0];return h("div",{key:this.key,class:"criteria-value-container ml-2 w-full flex items-center"},[this.getFieldValueDisplay()])}};function dist_normalizeComponent(template,style,script,scopeId,isFunctionalTemplate,moduleIdentifier/* server only */,shadowMode,createInjector,createInjectorSSR,createInjectorShadow){"boolean"!==typeof shadowMode&&(createInjectorSSR=createInjector,createInjector=shadowMode,shadowMode=!1);
// Vue.extend constructor export interop.
const options="function"===typeof script?script.options:script;
// render functions
let hook;if(template&&template.render&&(options.render=template.render,options.staticRenderFns=template.staticRenderFns,options._compiled=!0,
// functional template
isFunctionalTemplate&&(options.functional=!0)),
// scopedId
scopeId&&(options._scopeId=scopeId),moduleIdentifier?(
// server build
hook=function(context){
// 2.3 injection
context=context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,// functional
// 2.2 with runInNewContext: true
context||"undefined"===typeof __VUE_SSR_CONTEXT__||(context=__VUE_SSR_CONTEXT__),
// inject component styles
style&&style.call(this,createInjectorSSR(context)),
// register component module identifier for async chunk inference
context&&context._registeredComponents&&context._registeredComponents.add(moduleIdentifier)},
// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook):style&&(hook=shadowMode?function(context){style.call(this,createInjectorShadow(context,this.$root.$options.shadowRoot))}:function(context){style.call(this,createInjector(context))}),hook)if(options.functional){
// register for functional component in vue file
const originalRender=options.render;options.render=function(h,context){return hook.call(context),originalRender(h,context)}}else{
// inject component registration as beforeCreate hook
const existing=options.beforeCreate;options.beforeCreate=existing?[].concat(existing,hook):[hook]}return script}const dist_isOldIE="undefined"!==typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());function dist_createInjector(context){return(id,style)=>dist_addStyle(id,style)}let dist_HEAD;const dist_styles={};function dist_addStyle(id,css){const group=dist_isOldIE?css.media||"default":id,style=dist_styles[group]||(dist_styles[group]={ids:new Set,styles:[]});if(!style.ids.has(id)){style.ids.add(id);let code=css.source;if(css.map&&(
// https://developer.chrome.com/devtools/docs/javascript-debugging
// this makes source maps inside style tags work properly in Chrome
code+="\n/*# sourceURL="+css.map.sources[0]+" */",
// http://stackoverflow.com/a/26603875
code+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(css.map))))+" */"),style.element||(style.element=document.createElement("style"),style.element.type="text/css",css.media&&style.element.setAttribute("media",css.media),void 0===dist_HEAD&&(dist_HEAD=document.head||document.getElementsByTagName("head")[0]),dist_HEAD.appendChild(style.element)),"styleSheet"in style.element)style.styles.push(code),style.element.styleSheet.cssText=style.styles.filter(Boolean).join("\n");else{const index=style.ids.size-1,textNode=document.createTextNode(code),nodes=style.element.childNodes;nodes[index]&&style.element.removeChild(nodes[index]),nodes.length?style.element.insertBefore(textNode,nodes[index]):style.element.appendChild(textNode)}}}
/* script */const dist_vue_script_$b=dist_script$b,dist_vue_inject_styles_$b=function(inject){inject&&inject("data-v-734654fc_0",{source:".criteria-value-container .f-ui-forms input.el-input__inner::placeholder{color:#c0c4cc!important}.criteria-value-container .fc-slot-input-prepend .el-input__inner{border-top-left-radius:0!important;border-bottom-left-radius:0!important}.criteria-value-container .fc-slot-input-prepend .el-input-group__prepend{padding:0 15px;font-size:12px;border-top-right-radius:0;border-bottom-right-radius:0;border-right:0}.criteria-value-container .currency-range-container{display:flex;gap:4px;align-items:center}.criteria-value-container .currency-range-container-input{display:flex;align-items:center;background-color:#f5f7fa;height:38px;border-right:1px solid #d0d9e2;color:#909399;vertical-align:middle;position:relative;border-radius:4px;font-size:12px;padding:0 15px;white-space:nowrap}.criteria-value-container .currency-range-input{appearance:none;border:none;outline:0;display:inline-block;height:100%;margin:0;padding:0;width:50%;text-align:center;font-size:14px;color:#606266}.criteria-value-container .outer-currency{display:inline-flex;align-items:center;padding:0 0}.criteria-value-container .outer-currency input::-webkit-inner-spin-button,.criteria-value-container .outer-currency input::-webkit-outer-spin-button{display:none}",map:void 0,media:void 0})},dist_vue_scope_id_$b=void 0,dist_vue_module_identifier_$b=void 0,dist_vue_is_functional_template_$b=void 0,dist_vue_component_$b=dist_normalizeComponent({},dist_vue_inject_styles_$b,dist_vue_script_$b,dist_vue_scope_id_$b,dist_vue_is_functional_template_$b,dist_vue_module_identifier_$b,!1,dist_createInjector,void 0,void 0);
/* template */
/* style */
var dist_script$a={props:{isLoading:{type:Boolean,required:!0}}};
/* script */const dist_vue_script_$a=dist_script$a;
/* template */var dist_vue_render_$7=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _vm.isLoading?_c("div",{staticClass:"field-loading loading-shimmer"}):_vm._e()},dist_vue_staticRenderFns_$7=[];
/* style */
const dist_vue_inject_styles_$a=function(inject){inject&&inject("data-v-dce331f4_0",{source:".field-loading[data-v-dce331f4]{height:40px;display:flex;flex:1;border-radius:3px}.loading-shimmer[data-v-dce331f4]{background:#f6f7f8;background-image:linear-gradient(to right,#f6f7f8 0,#edeef1 20%,#f6f7f8 40%,#f6f7f8 100%);background-repeat:no-repeat;background-size:800px 104px;display:inline-block;position:relative;animation-duration:1s;animation-fill-mode:forwards;animation-iteration-count:infinite;animation-name:shimmer;animation-timing-function:linear}",map:void 0,media:void 0})},dist_vue_scope_id_$a="data-v-dce331f4",dist_vue_module_identifier_$a=void 0,dist_vue_is_functional_template_$a=!1,dist_vue_component_$a=dist_normalizeComponent({render:dist_vue_render_$7,staticRenderFns:dist_vue_staticRenderFns_$7},dist_vue_inject_styles_$a,dist_vue_script_$a,dist_vue_scope_id_$a,dist_vue_is_functional_template_$a,dist_vue_module_identifier_$a,!1,dist_createInjector,void 0,void 0);
/* scoped */var dist_Date={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20"}},[_c("path",{attrs:{d:"M17.25 3H15.5v-.82c0-.17-.14-.31-.31-.31h-.64c-.17 0-.31.14-.31.31V3h-3.69v-.82c0-.17-.14-.31-.31-.31H9.6c-.17 0-.31.14-.31.31V3H5.6v-.82c0-.17-.14-.31-.31-.31h-.64c-.17 0-.31.14-.31.31V3H2.72c-.83 0-1.5.67-1.5 1.5v12.12c0 .83.67 1.5 1.5 1.5h14.5c.83 0 1.5-.67 1.5-1.5V4.5c0-.83-.67-1.5-1.5-1.5zM2.75 4.25h1.62v.82c0 .17.14.31.31.31h.64c.17 0 .31-.14.31-.31v-.82h3.69v.82c0 .17.14.31.31.31h.64c.17 0 .31-.14.31-.31v-.82h3.69v.82c0 .17.14.31.31.31h.64c.17 0 .31-.14.31-.31v-.82h1.75c.14 0 .25.11.25.25v2.38H2.5V4.5c0-.14.11-.25.25-.25zm14.5 12.62H2.75c-.14 0-.25-.11-.25-.25v-8.5h15v8.5c0 .14-.11.25-.25.25z"}})])}},Decimal={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20"}},[_c("path",{attrs:{d:"M15.29 4.6c-1.91 0-3.46 1.55-3.46 3.46v3.88a3.461 3.461 0 006.92 0V8.06c0-1.91-1.55-3.46-3.46-3.46zm2.21 7.34a2.21 2.21 0 01-4.42 0V8.06a2.21 2.21 0 014.42 0v3.88zM7.46 4.6C5.55 4.6 4 6.15 4 8.06v3.88a3.461 3.461 0 006.92 0V8.06c0-1.91-1.55-3.46-3.46-3.46zm2.21 7.34a2.21 2.21 0 01-4.42 0V8.06a2.21 2.21 0 014.42 0v3.88z"}}),_c("circle",{attrs:{cx:"2.12",cy:"14.52",r:".88"}})])}},Duration={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20"}},[_c("path",{attrs:{d:"M18.5 3.88h-.75c-.14 0-.25.11-.25.25v1.13c-1.6-2.45-4.36-4-7.4-4C5.22 1.25 1.25 5.18 1.25 10s3.97 8.75 8.85 8.75c3.75 0 7.05-2.3 8.32-5.76a.299.299 0 00-.2-.39l-.6-.2a.298.298 0 00-.38.19c-1.09 2.95-3.92 4.91-7.13 4.91-4.19 0-7.6-3.36-7.6-7.5s3.41-7.5 7.6-7.5c2.93 0 5.56 1.67 6.82 4.22h-1.92c-.14 0-.25.11-.25.25v.76c0 .14.11.25.25.25h3.5c.14 0 .25-.11.25-.25V4.12c0-.14-.11-.25-.25-.25z"}}),_c("path",{attrs:{d:"M12.9 7.13v-.86h.93c.15 0 .28-.12.28-.28v-.7a.28.28 0 00-.28-.28H6.16a.28.28 0 00-.28.28v.7c0 .15.12.28.28.28h.9v.86c0 .89.4 1.72 1.09 2.27l.83.66-.83.66c-.69.56-1.09 1.38-1.09 2.27v.74h-.9a.28.28 0 00-.28.28v.7c0 .15.12.28.28.28h7.67c.15 0 .28-.12.28-.28v-.7a.28.28 0 00-.28-.28h-.93v-.74c0-.89-.4-1.72-1.09-2.27l-.83-.66.83-.66c.69-.56 1.09-1.38 1.09-2.27zm-1.87 4.57c.4.32.62.79.62 1.3v.74H8.31V13c0-.51.23-.98.62-1.3l1.05-.84 1.05.84zm0-3.28l-1.05.84-1.05-.84c-.4-.32-.62-.79-.62-1.3v-.86h3.34v.86c0 .51-.23.98-.62 1.3z"}})])}},Http={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 192 192"}},[_c("defs"),_c("g",{attrs:{id:"trim_area","data-name":"trim area"}},[_c("path",{staticClass:"cls-1",attrs:{d:"M169.92 8.06H22.08a14 14 0 00-14 14v147.88a14 14 0 0014 14h147.84a14 14 0 0014-14V22.06a14 14 0 00-14-14zm-147.84 8h147.84a6 6 0 016 6v18H16.08v-18a6 6 0 016-6zm147.84 159.88H22.08a6 6 0 01-6-6V48.07h159.84v121.87a6 6 0 01-6 6z"}}),_c("circle",{staticClass:"cls-1",attrs:{cx:"28.19",cy:"28.13",r:"4.15"}}),_c("circle",{staticClass:"cls-1",attrs:{cx:"48.14",cy:"28.11",r:"4.15"}}),_c("circle",{staticClass:"cls-1",attrs:{cx:"68.12",cy:"28.13",r:"4.15"}}),_c("path",{staticClass:"cls-2",attrs:{d:"M38.46 88.18v11.44a8.79 8.79 0 013.19-2.75 8.59 8.59 0 013.81-.87q3.95 0 5.85 2.06t1.9 6.49v15.29H47v-14.47c0-1.62-.31-2.73-.93-3.32a3.45 3.45 0 00-2.48-.88 5.32 5.32 0 00-2.06.35 5.8 5.8 0 00-1.62 1 5.53 5.53 0 00-1 1.48 4.29 4.29 0 00-.42 1.89v13.91h-6.2V88.18zM56.27 101.52v-4.83h3.63v-6.16h6.2v6.16h5.32v4.83H66.1v10.68a3.17 3.17 0 00.75 2.46 2.92 2.92 0 002 .64 10.93 10.93 0 001.27-.07 6.83 6.83 0 001.26-.24l.89 4.56a15.19 15.19 0 01-2.51.56 19 19 0 01-2.32.15c-2.54 0-4.43-.6-5.65-1.81s-1.84-3.25-1.84-6.12v-10.81zM73.05 101.52v-4.83h3.64v-6.16h6.2v6.16h5.32v4.83h-5.32v10.68a3.17 3.17 0 00.75 2.46 2.88 2.88 0 002 .64 10.64 10.64 0 001.26-.07 6.94 6.94 0 001.27-.24l.88 4.56a14.87 14.87 0 01-2.5.56 19.07 19.07 0 01-2.33.15q-3.81 0-5.64-1.81c-1.23-1.22-1.84-3.25-1.84-6.12v-10.81zM98.08 96.69v3.06a8.45 8.45 0 017.27-3.75c3.22 0 5.63 1.1 7.22 3.28s2.39 5.18 2.39 9a17.44 17.44 0 01-.68 5 11.41 11.41 0 01-2 3.88 9 9 0 01-3.17 2.5 9.66 9.66 0 01-4.2.89 10.08 10.08 0 01-3.44-.62 7.63 7.63 0 01-3.21-2.48v11h-6.2V96.69zm.51 15.31a5 5 0 001.22 2.2 4.52 4.52 0 001.8 1 7.07 7.07 0 001.83.24 4.83 4.83 0 002-.4 4.07 4.07 0 001.62-1.26 6.5 6.5 0 001.09-2.24 12.24 12.24 0 00.39-3.32 13.15 13.15 0 00-.37-3.41 6.47 6.47 0 00-1-2.24 3.82 3.82 0 00-1.58-1.24 4.94 4.94 0 00-1.92-.38 6 6 0 00-2 .31 5.89 5.89 0 00-1.64 1 5 5 0 00-1.3 2.12 10.76 10.76 0 00-.42 3.28v.71a14 14 0 00.28 3.63zM125.55 96.69v7.13h-6.34v-7.13zm0 16v7.14h-6.34v-7.14zM128.6 119.82l10.28-32.52H145l-10.28 32.52zM143.31 119.82l10.28-32.52h6.15l-10.27 32.52z"}})])])}},Lookup={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20"}},[_c("path",{attrs:{d:"M18.43 14.57c-.46-.56-2.14-2.41-4.33-2.41S10.24 14 9.77 14.57c-.41.5-.41 1.23 0 1.73.46.56 2.14 2.41 4.33 2.41s3.86-1.84 4.33-2.41c.41-.5.41-1.23 0-1.73zm-.97.94c-.3.36-1.69 1.95-3.36 1.95s-3.06-1.58-3.36-1.95c-.04-.04-.04-.1 0-.15.3-.36 1.69-1.95 3.36-1.95s3.06 1.58 3.36 1.95c.04.04.04.1 0 .15z"}}),_c("circle",{attrs:{cx:"14.11",cy:"15.44",r:"1.43"}}),_c("rect",{attrs:{x:"4.38",y:"4.38",width:"8.25",height:"1.25",rx:".25",ry:".25"}}),_c("path",{attrs:{d:"M8.76 17.5H2.9c-.22 0-.4-.18-.4-.4V2.9c0-.22.18-.4.4-.4h11.21c.22 0 .4.18.4.4V11c0 .14.12.26.26.26h.73c.14 0 .26-.12.26-.26V2.9c0-.91-.74-1.65-1.65-1.65H2.9c-.91 0-1.65.74-1.65 1.65v14.21c0 .91.74 1.65 1.65 1.65h5.86c.14 0 .26-.12.26-.26v-.73c0-.14-.12-.26-.26-.26z"}}),_c("rect",{attrs:{x:"4.38",y:"7.38",width:"8.25",height:"1.25",rx:".25",ry:".25"}}),_c("rect",{attrs:{x:"4.38",y:"10.38",width:"8.24",height:"1.25",rx:".25",ry:".25"}})])}},MultiSelect={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20"}},[_c("path",{attrs:{d:"M5.46 3.42c-.1-.1-.26-.1-.35 0l-2.1 2.1-.8-.8c-.1-.1-.26-.1-.35 0l-.53.53c-.1.1-.1.26 0 .35l.98.98.53.53c.1.1.26.1.35 0l.53-.53L6 4.3c.1-.1.1-.26 0-.35l-.53-.53z"}}),_c("rect",{attrs:{x:"7.38",y:"4.38",width:"11.38",height:"1.25",rx:".25",ry:".25"}}),_c("path",{attrs:{d:"M5.46 8.93c-.1-.1-.26-.1-.35 0l-2.1 2.1-.8-.8c-.1-.1-.26-.1-.35 0l-.53.53c-.1.1-.1.26 0 .35l1.51 1.51c.1.1.26.1.35 0L6 9.81c.1-.1.1-.26 0-.35l-.53-.53z"}}),_c("rect",{attrs:{x:"7.38",y:"9.89",width:"11.38",height:"1.25",rx:".25",ry:".25"}}),_c("rect",{attrs:{x:"7.38",y:"15.4",width:"11.38",height:"1.25",rx:".25",ry:".25"}})])}},Numbers={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20"}},[_c("path",{attrs:{d:"M18.75 8.87V7.44c0-1.2-.97-2.18-2.18-2.18h-1.71c-1.2 0-2.18.97-2.18 2.18v.69c0 .14.12.26.26.26h.73c.14 0 .26-.12.26-.26V7.5c0-.54.44-.99.98-.99h1.6c.54 0 .99.44.99.99v1.31c0 .54-.44.6-.99.6h-1.23c-.14 0-.26.12-.26.26v.75c0 .14.12.26.26.26h1.23c.54 0 .99.23.99.77v1.05c0 .54-.44.99-.99.99h-1.6c-.54 0-.98-.44-.98-.99v-.63c0-.14-.12-.26-.26-.26h-.73c-.14 0-.26.12-.26.26v.69c0 1.2.97 2.18 2.18 2.18h1.71c1.2 0 2.18-.97 2.18-2.18v-1.17c0-.53-.2-.97-.51-1.3.31-.29.51-.7.51-1.23zM3.82 5.26h-.76s-.02.01-.03.01a.24.24 0 00-.21.06l-1.5 1.5c-.1.1-.1.25 0 .35l.53.53c.1.1.25.1.35 0l.61-.61v7.38c0 .14.11.25.25.25h.76c.14 0 .25-.11.25-.25V5.51c0-.14-.11-.25-.25-.25zM9.3 5.26H7.87c-1.14 0-2.1.87-2.28 1.96-.05.16-.02.91-.02.91 0 .14.11.25.25.25h.75c.14 0 .25-.11.25-.25v-.56c0-.58.47-1.05 1.05-1.05H9.3c.58 0 1.05.47 1.05 1.05v.87c0 .64-.52 1.15-1.15 1.15H7.91c-1.3 0-2.35 1.05-2.35 2.35v2.54c0 .15.12.27.27.27h5.51c.15 0 .27-.12.27-.27v-.72c0-.15-.12-.27-.27-.27H6.82v-1.5c0-.64.52-1.15 1.15-1.15h1.29c1.3 0 2.35-1.05 2.35-2.35v-.93a2.3 2.3 0 00-2.3-2.3z"}})])}},OneLevel={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20"}},[_c("rect",{attrs:{x:"4.38",y:"4.37",width:"8.25",height:"1.25",rx:".25",ry:".25"}}),_c("path",{attrs:{d:"M8.75 17.5H2.9c-.22 0-.4-.18-.4-.4V2.9c0-.22.18-.4.4-.4h11.21c.22 0 .4.18.4.4v5.97c0 .14.12.26.26.26h.73c.14 0 .26-.12.26-.26V2.9c0-.91-.74-1.65-1.65-1.65H2.9c-.91 0-1.65.74-1.65 1.65v14.21c0 .91.74 1.65 1.65 1.65h5.85c.14 0 .26-.12.26-.26v-.73c0-.14-.12-.26-.26-.26z"}}),_c("rect",{attrs:{x:"4.38",y:"7.31",width:"8.25",height:"1.25",rx:".25",ry:".25"}}),_c("rect",{attrs:{x:"4.38",y:"10.25",width:"4.24",height:"1.25",rx:".25",ry:".25"}}),_c("path",{attrs:{d:"M18.67 17.79l-1.65-1.65a4 4 0 00.59-2.08c0-2.24-1.82-4.06-4.06-4.06s-4.06 1.82-4.06 4.06 1.82 4.06 4.06 4.06a4 4 0 002.66-1.02l1.57 1.57c.1.1.25.1.35 0l.53-.53c.1-.1.1-.25 0-.35zm-5.11-.92c-1.55 0-2.81-1.26-2.81-2.81s1.26-2.81 2.81-2.81 2.81 1.26 2.81 2.81-1.26 2.81-2.81 2.81z"}})])}},Picklist={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20"}},[_c("path",{attrs:{d:"M17.25 5.06H2.75c-.83 0-1.5.67-1.5 1.5v6.88c0 .83.67 1.5 1.5 1.5h14.5c.83 0 1.5-.67 1.5-1.5V6.56c0-.83-.67-1.5-1.5-1.5zm.25 8.38c0 .14-.11.25-.25.25H2.75c-.14 0-.25-.11-.25-.25V6.56c0-.14.11-.25.25-.25h14.5c.14 0 .25.11.25.25v6.88z"}}),_c("path",{attrs:{d:"M15.63 8.57a.235.235 0 00-.33 0l-1.25 1.25-1.25-1.25a.235.235 0 00-.33 0l-.55.55c-.09.09-.09.24 0 .33l1.97 1.97c.09.09.24.09.33 0l1.97-1.97c.09-.09.09-.24 0-.33l-.55-.55z"}})])}},Boolean$1={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20"}},[_c("path",{attrs:{d:"M14.02 6.24c-.1-.1-.26-.1-.35 0l-5.21 5.21-2.12-2.12c-.1-.1-.26-.1-.35 0l-.89.89c-.1.1-.1.26 0 .35l3.18 3.18c.05.05.12.07.19.07s.14-.02.19-.07l6.28-6.28c.1-.1.1-.26 0-.35l-.89-.89z"}}),_c("path",{attrs:{d:"M17.29 1.25H2.71c-.81 0-1.46.66-1.46 1.46v14.57c0 .81.66 1.46 1.46 1.46h14.57c.81 0 1.46-.66 1.46-1.46V2.71c0-.81-.66-1.46-1.46-1.46zm.21 16.04c0 .12-.1.21-.21.21H2.71c-.12 0-.21-.1-.21-.21V2.71c0-.12.1-.21.21-.21h14.57c.12 0 .21.1.21.21v14.57z"}})])}},TimeDate={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20"}},[_c("path",{attrs:{d:"M15.13 8V3.5c0-.79-.65-1.44-1.44-1.44h-.81v-.51c0-.17-.14-.31-.31-.31h-.64c-.17 0-.31.14-.31.31v.51H8.81v-.51c0-.17-.14-.31-.31-.31h-.64c-.17 0-.31.14-.31.31v.51H4.74v-.51c0-.17-.14-.31-.31-.31h-.64c-.17 0-.31.14-.31.31v.51h-.81c-.79 0-1.44.65-1.44 1.44v9.19c0 .79.65 1.44 1.44 1.44h5.04c.45 2.61 2.73 4.61 5.47 4.61 3.06 0 5.55-2.49 5.55-5.55 0-2.38-1.51-4.41-3.62-5.2zM2.5 3.5c0-.1.08-.19.19-.19h.81v.62c0 .17.14.31.31.31h.64c.17 0 .31-.14.31-.31v-.62h2.81v.62c0 .17.14.31.31.31h.64c.17 0 .31-.14.31-.31v-.62h2.81v.62c0 .17.14.31.31.31h.64c.17 0 .31-.14.31-.31v-.62h.81c.1 0 .19.08.19.19v1.43H2.5V3.5zm5.16 9.38H2.69a.19.19 0 01-.19-.19V6.17h11.38v1.51c-.22-.03-.45-.05-.68-.05-2.96 0-5.38 2.33-5.54 5.25zm5.54 4.61a4.3 4.3 0 01-4.19-3.36c-.07-.3-.11-.62-.11-.94 0-.11.02-.2.03-.31.16-2.23 2-4 4.27-4 .23 0 .46.03.68.07.44.07.86.21 1.25.41 1.4.71 2.38 2.15 2.38 3.83a4.3 4.3 0 01-4.3 4.3z"}}),_c("path",{attrs:{d:"M15.76 12.5h-1.87V9.75c0-.14-.11-.25-.25-.25h-.75c-.14 0-.25.11-.25.25v3.75c0 .14.11.25.25.25h2.87c.14 0 .25-.11.25-.25v-.75c0-.14-.11-.25-.25-.25z"}})])}},String$1={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20"}},[_c("path",{attrs:{d:"M1.26 10.38v.18c0 .13.11.24.24.24h.78c.13 0 .24-.11.24-.24v-.16c0-.22.18-.4.4-.4h2.07c.22 0 .4.18.4.4v.18c0 .18-.13.34-.31.39l-2.83.69c-.59.14-1 .67-1 1.28v.51c0 .72.59 1.31 1.31 1.31h2.76c.72 0 1.31-.59 1.31-1.31v-3.06c0-.9-.73-1.63-1.63-1.63H2.89c-.9 0-1.63.73-1.63 1.63zm1.25 2.78c0-.16.11-.29.26-.33l2.62-.65v.98c0 .19-.15.34-.34.34H2.86c-.19 0-.34-.15-.34-.34zM13.5 11.23v1.04a2.48 2.48 0 002.48 2.48h1c.98 0 1.77-.79 1.77-1.77v-.02c0-.14-.12-.26-.26-.26h-.73c-.14 0-.26.12-.26.26 0 .3-.24.54-.54.54h-1.08c-.62 0-1.13-.5-1.13-1.13v-1.25c0-.62.5-1.13 1.13-1.13h1.08c.3 0 .54.24.54.54 0 .14.12.26.26.26h.73c.14 0 .26-.12.26-.26v-.02c0-.98-.79-1.77-1.77-1.77h-1a2.48 2.48 0 00-2.48 2.48zM8.95 8.73c-.09 0-.17-.08-.17-.17V5.5c0-.14-.11-.25-.25-.25h-.74c-.14 0-.25.11-.25.25v8.97c0 .14.11.25.25.25h2.51a2.59 2.59 0 002.59-2.59v-.83a2.59 2.59 0 00-2.59-2.59H8.96zm1.18 4.75H8.95c-.09 0-.17-.08-.17-.17v-3.16c0-.09.08-.17.17-.17h1.18c.83 0 1.49.67 1.49 1.49v.51c0 .83-.67 1.49-1.49 1.49z"}})])}},Currency={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20"}},[_c("path",{attrs:{d:"M14.47 7.61h.76c.14 0 .25-.11.25-.25V6.12s0-.02-.01-.03a3.459 3.459 0 00-3.45-3.36h-1.39V1.48c0-.14-.11-.25-.25-.25h-.76c-.14 0-.25.11-.25.25v1.25H7.98c-1.91 0-3.46 1.55-3.46 3.46v.95c0 1.91 1.55 3.46 3.46 3.46H12c1.22 0 2.21.99 2.21 2.21v.95c0 1.22-.99 2.21-2.21 2.21H7.98a2.21 2.21 0 01-2.21-2.21V12.6c0-.14-.11-.25-.25-.25h-.76c-.14 0-.25.11-.25.25v1.24s.01.02.01.03a3.457 3.457 0 003.45 3.35h1.39v1.28c0 .14.11.25.25.25h.76c.14 0 .25-.11.25-.25v-1.28h1.39c1.91 0 3.46-1.55 3.46-3.46v-.95c0-1.91-1.55-3.46-3.46-3.46H7.99a2.21 2.21 0 01-2.21-2.21v-.95c0-1.22.99-2.21 2.21-2.21h4.02c1.22 0 2.21.99 2.21 2.21v1.16c0 .14.11.25.25.25z"}})])}},Down={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20"}},[_c("path",{attrs:{d:"M16.45 6.95l-.53-.53c-.1-.1-.25-.1-.35 0L10 11.99 4.43 6.42c-.1-.1-.25-.1-.35 0l-.53.53c-.1.1-.1.25 0 .35l6.28 6.28c.1.1.25.1.35 0l6.28-6.28c.1-.1.1-.25 0-.35z"}})])}},Right={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20"}},[_c("path",{attrs:{d:"M14.05 9.83L7.77 3.55c-.1-.1-.25-.1-.35 0l-.53.53c-.1.1-.1.25 0 .35L12.46 10l-5.57 5.57c-.1.1-.1.25 0 .35l.53.53c.1.1.25.1.35 0l6.28-6.28c.1-.1.1-.25 0-.35z"}})])}},dist_script$9={props:["src"],data:function(){return{svgContent:""}},methods:{getComponent:function(){var h=this.$createElement,src=this.src;if((0,validation/* isEmpty */.xb)(src))return"";src=src.toUpperCase();var MAP={"ONE-LEVEL-LOOKUP":h(OneLevel,{class:"inline-icon"}),DURATION:h(Duration,{class:"inline-icon"}),LOOKUP:h(Lookup,{class:"inline-icon"}),DATE:h(dist_Date,{class:"inline-icon"}),"TIME-DATE":h(TimeDate,{class:"inline-icon"}),STRING:h(String$1,{class:"inline-icon"}),NUMBERS:h(Numbers,{class:"inline-icon"}),DECIMAL:h(Decimal,{class:"inline-icon"}),SELECT:h(Boolean$1,{class:"inline-icon"}),PICKLIST:h(Picklist,{class:"inline-icon"}),"MULTI-SELECT":h(MultiSelect,{class:"inline-icon"}),HTTP:h(Http,{class:"inline-icon"}),CURRENCY:h(Currency,{class:"inline-icon"}),MULTI_CURRENCY:h(Currency,{class:"inline-icon"}),DOWN:h(Down,{class:"inline-icon"}),RIGHT:h(Right,{class:"inline-icon"})};return MAP[src]}},render:function(){return this.getComponent()}};
/* script */
const dist_vue_script_$9=dist_script$9,dist_vue_inject_styles_$9=function(inject){inject&&inject("data-v-f77d85ea_0",{source:".inline-icon[data-v-f77d85ea]{height:16px;width:16px}",map:void 0,media:void 0})},dist_vue_scope_id_$9="data-v-f77d85ea",dist_vue_module_identifier_$9=void 0,dist_vue_is_functional_template_$9=void 0,dist_vue_component_$9=dist_normalizeComponent({},dist_vue_inject_styles_$9,dist_vue_script_$9,dist_vue_scope_id_$9,dist_vue_is_functional_template_$9,dist_vue_module_identifier_$9,!1,dist_createInjector,void 0,void 0);
/* template */
/* style */var DEFAULT_CRITERIA={fieldName:null,operatorId:null,value:null},CONDITION_PROP_HASH=["fieldName","operatorId","value","prevOperator","fieldNameStr","criteriaValue"],dist_script$8={name:"condition",props:["index","condition","fields","operators","account","filterOperators","isLastIndex","showValueType","customValues","disabled","conditionsKeys","cachedModule","advancedFields"],components:{Select:__vue_component__$r,ConditionValue:dist_vue_component_$b,Cascader:element_ui_common.Cascader,FieldLoader:dist_vue_component_$a,FieldIcons:dist_vue_component_$9},data:function(){return{childLoading:!1,conditionObj:{fieldName:null,operatorId:null,value:null},field:{},valueTypeOptions:[{label:"Value",value:"value"}],valueType:"value",typeBasedValues:{},isLoading:!1,isEmpty:validation/* isEmpty */.xb}},computed:{checkOperatorDisabled:function(){var disabled=this.disabled,conditionObj=this.conditionObj;return!!disabled||!!(0,validation/* isEmpty */.xb)(conditionObj.fieldName)},allowCreate:function(){var customValues=this.customValues,fieldObj=customValues.find((function(item){return"Field"===item.label})),_ref=fieldObj||{},allowCreate=_ref.allowCreate;return!!allowCreate},showLineTop:function(){var conditionsKeys=this.conditionsKeys,isLastIndex=this.isLastIndex;return!(0,validation/* isEmpty */.xb)(conditionsKeys)&&!isLastIndex},currentOperatorObj:function(){var _ref2=this||{},conditionObj=_ref2.conditionObj,fieldOperators=_ref2.fieldOperators,_ref3=conditionObj||{},operatorId=_ref3.operatorId,currentOperator=fieldOperators.find((function(operator){return operator.id===operatorId}));return currentOperator},isSpecialOperator:function(){var _ref4=this||{},currentOperatorObj=_ref4.currentOperatorObj,_ref5=currentOperatorObj||{},specialOperator=_ref5.specialOperator;return specialOperator},fieldOperators:function(){var operators=this.operators,filterOperators=this.filterOperators,field=this.field,_ref6=field||{},dataType=_ref6.dataType,fieldOperators=_ref6.operators;if(!(0,validation/* isEmpty */.xb)(operators)){var list=operators[dataType]||[];(0,validation/* isEmpty */.xb)(fieldOperators)||(list=list.concat(fieldOperators))
/*
           Since some operator like next 7 days, next 2 days have same operatorId,
           we have to construct a unique id in client.
        */;var finalList=list.map((function(operator){var operatorId=operator.operatorId,defaultValue=operator.defaultValue,unqiueClientId=operatorId;return(0,validation/* isEmpty */.xb)(defaultValue)||(unqiueClientId="".concat(operatorId,"-").concat(defaultValue)),dist_objectSpread2(dist_objectSpread2({},operator),{},{id:unqiueClientId})}));
// filter out special operator if special ui is not present
return finalList=finalList.filter((function(operator){var _ref7=operator||{},specialOperator=_ref7.specialOperator,operatorId=_ref7.id,_ref8=field||{},displayType=_ref8.displayType,specialHashPropName="".concat(displayType,"_").concat(operatorId);return"61-7"===operatorId||"61-2"===operatorId||!specialOperator||!(0,validation/* isEmpty */.xb)(dist_SPECIAL_OPERATOR_HASH[specialHashPropName])})),!(0,validation/* isEmpty */.xb)(filterOperators)&&(0,validation/* isFunction */.mf)(filterOperators)&&(finalList=(finalList||[]).filter((function(operator){return filterOperators(operator,field)}))),finalList}return[]},defaultOperatorId:function(){var fieldOperators=this.fieldOperators,defaultOperator=fieldOperators.find((function(operator){var _ref9=operator||{},defaultSelection=_ref9.defaultSelection;return defaultSelection})),_ref10=defaultOperator||{},operatorId=_ref10.operatorId;return operatorId||null},fieldValue:{get:function(){var conditionObj=this.conditionObj,_ref11=conditionObj||{},value=_ref11.value;return value},set:function(value){var conditionObj=this.conditionObj;this.$set(conditionObj,"value",value)}},fieldValue0:{get:function(){var fieldValue=this.fieldValue;return(0,validation/* isEmpty */.xb)(fieldValue)?null:fieldValue[0]||null},set:function(value){var fieldValue=this.fieldValue,_ref12=fieldValue||[],_ref13=dist_slicedToArray(_ref12,2),_ref13$=_ref13[1],secondIndexValue=void 0===_ref13$?null:_ref13$;secondIndexValue?this.$set(this,"fieldValue",[value,secondIndexValue]):this.$set(this,"fieldValue",[value])}},fieldValue1:{get:function(){var fieldValue=this.fieldValue;return(0,validation/* isEmpty */.xb)(fieldValue)?null:fieldValue[1]||null},set:function(value){var fieldValue=this.fieldValue,_ref14=fieldValue||[],_ref15=dist_slicedToArray(_ref14,1),_ref15$=_ref15[0],firstIndexValue=void 0===_ref15$?null:_ref15$;this.$set(this,"fieldValue",[firstIndexValue,value])}},canHidePopupIcon:function(){var field=this.field,_ref16=field||{},lookupModule=_ref16.lookupModule,_ref17=lookupModule||{},_ref17$showPopup=_ref17.showPopup,showPopup=void 0===_ref17$showPopup||_ref17$showPopup;return!showPopup},hideDropDown:function(){
// Have to hide dropdown for resource type fields
var field=this.field,name=field.name;return"resource"===name},disableValueContainer:function(){var conditionObj=this.conditionObj,fieldOperators=this.fieldOperators,disabled=this.disabled,_ref18=conditionObj||{},operatorId=_ref18.operatorId,canDisable=!0,selectedOperator=fieldOperators.find((function(operator){return operator.id===operatorId}));return(0,validation/* isEmpty */.xb)(selectedOperator)||(canDisable=!(selectedOperator||{}).valueNeeded),canDisable||disabled},
// condition error handling
selectedFieldExists:function(){var _ref19=this||{},conditionObj=_ref19.conditionObj,fields=_ref19.fields,_ref20=conditionObj||{},fieldName=_ref20.fieldName,fieldNameStr=_ref20.fieldNameStr;if((0,validation/* isEmpty */.xb)(fieldNameStr)||(fieldNameStr=fieldNameStr.split("_")||[],fieldName=fieldNameStr[0]||null),(0,validation/* isEmpty */.xb)(fieldName)||(0,validation/* isArray */.kJ)(fieldName))return!0;var _fieldName,actualFieldName=fieldName,multilookupRegex=/^([a-z]+_?[a-z]+\.)/,multilookupArray=(null===(_fieldName=fieldName)||void 0===_fieldName?void 0:_fieldName.match(multilookupRegex))||[];if(!(0,validation/* isEmpty */.xb)(multilookupArray)){var splitArray=fieldName.split(".");actualFieldName=splitArray[1]}
// if (!isEmpty(actualFieldName) && actualFieldName.match(/#parent$/)) {
//   actualFieldName = actualFieldName.split('#')[0]
// }
var selectedField=(fields||[]).some((function(field){return field.name===actualFieldName}));return selectedField},selectedOperatorExists:function(){var _ref21=this||{},currentOperatorObj=_ref21.currentOperatorObj,conditionObj=_ref21.conditionObj,_ref22=conditionObj||{},operatorId=_ref22.operatorId;return!!(0,validation/* isEmpty */.xb)(operatorId)||!(0,validation/* isEmpty */.xb)(currentOperatorObj)},canShowError:function(){var _ref23=this||{},selectedFieldExists=_ref23.selectedFieldExists,selectedOperatorExists=_ref23.selectedOperatorExists;return!selectedFieldExists||!selectedOperatorExists},operatorPlaceholder:function(){var _ref24=this||{},conditionObj=_ref24.conditionObj,fieldName=conditionObj.fieldName;return(0,validation/* isEmpty */.xb)(fieldName)?"N/A":"Select"}},watch:{conditionObj:{handler:function(newVal){var index=this.index,value=newVal.value,clonedValue=cloneDeep(newVal);!(0,validation/* isEmpty */.xb)(value)&&(0,validation/* isArray */.kJ)(value)&&(clonedValue.value="".concat(value));var _ref25=this.currentOperatorObj||{},valueNeeded=_ref25.valueNeeded;clonedValue.valueNeeded=valueNeeded,this.$emit("updateCondition",{condition:clonedValue,index:index})},deep:!0}},created:function(){this.initFieldUtilMethods(),this.initCondition()},methods:{getIcon:function(data,children){var dataType=data.dataType,displayType=data.displayType;if(!(0,validation/* isEmpty */.xb)(children))return"one-level-lookup";if("DURATION"===displayType)return"duration";var MAP={LOOKUP:"lookup",MULTI_LOOKUP:"lookup",BIG_STRING:"string",DATE:"date",DATE_TIME:"time-date",STRING:"string",NUMBER:"numbers",ID:"numbers",DECIMAL:"decimal",BOOLEAN:"select",ENUM:"picklist",MULTI_ENUM:"multi-select",URL_FIELD:"http",SYSTEM_ENUM:"picklist",CURRENCY_FIELD:"currency",MULTI_CURRENCY_FIELD:"multi_currency"},iconName=MAP[dataType];return(0,validation/* isEmpty */.xb)(iconName)?"":iconName},updateCustomValue:function(value){this.valueType=value,this.conditionObj.value=""},filterFields:function(node,search){var _parentLabelLowerCase,_parentLabel,parentLabelLowerCase,parentLabel,_ref26=node||{},label=_ref26.label,lowerCaseLabel=label.toLowerCase(),parent=node.parent;return(0,validation/* isEmpty */.xb)(parent)||(parentLabelLowerCase=parent.label.toLowerCase(),parentLabel=parent.label),label.includes(search)||lowerCaseLabel.includes(search)||(null===(_parentLabelLowerCase=parentLabelLowerCase)||void 0===_parentLabelLowerCase?void 0:_parentLabelLowerCase.includes(search))||(null===(_parentLabel=parentLabel)||void 0===_parentLabel?void 0:_parentLabel.includes(search))},initFieldUtilMethods:function(){this.isPicklistTypeField=isPicklistTypeField,this.isBooleanTypeField=isBooleanTypeField,this.isLookupTypeField=dist_isLookupTypeField,this.isLookupPopupField=dist_isLookupPopupField},initCondition:function(){var _this=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee(){var condition,showValueType,advancedFields,cachedModule,clonedCondition,deserializedCondition,_this$field,_ref27,fieldName,value,operatorId,prevOperator,_fieldName2,parentFieldName,childFieldName,parentFieldObj,_lookupModule,name,_yield$API$get,data,error,fields,childFields,childFieldObj,conditionValue,actualFieldName,selectedField,selectedOperator,_ref28,lookupModule;return dist_regeneratorRuntime().wrap((function(_context){while(1)switch(_context.prev=_context.next){case 0:if(_this.isLoading=!0,condition=_this.condition,showValueType=_this.showValueType,advancedFields=_this.advancedFields,cachedModule=_this.cachedModule,clonedCondition=cloneDeep(condition),deserializedCondition={},Object.keys(clonedCondition).map((function(key){CONDITION_PROP_HASH.includes(key)&&(deserializedCondition[key]=clonedCondition[key])})),(0,validation/* isEmpty */.xb)(deserializedCondition)){_context.next=39;break}// check for one level lookup
if(_ref27=deserializedCondition||{},fieldName=_ref27.fieldName,value=_ref27.value,operatorId=_ref27.operatorId,prevOperator=_ref27.prevOperator,!(0,validation/* isArray */.kJ)(fieldName)){_context.next=28;break}if(_fieldName2=dist_slicedToArray(fieldName,2),parentFieldName=_fieldName2[0],childFieldName=_fieldName2[1],parentFieldObj=advancedFields.find((function(field){return field.name===parentFieldName})),_lookupModule=parentFieldObj.lookupModule,name=_lookupModule.name,!(0,validation/* isEmpty */.xb)(cachedModule[name])){_context.next=19;break}return _context.next=15,api/* API */.bl.get("/v2/filter/advanced/fields/".concat(name));case 15:_yield$API$get=_context.sent,data=_yield$API$get.data,error=_yield$API$get.error,error||(fields=data.fields,cachedModule[name]=fields);case 19:childFields=cachedModule[name],childFieldName=_this.getFieldName(childFieldName),childFieldObj=childFields.find((function(field){return field.name===childFieldName})),_this.setField(childFieldObj),fieldName[1]=childFieldName,conditionValue=_this.getConditionValue(childFieldObj,value),_this.conditionObj={fieldName:fieldName,operatorId:operatorId,value:conditionValue,prevOperator:prevOperator},_context.next=36;break;case 28:actualFieldName=_this.getFieldName(fieldName),deserializedCondition.fieldName=actualFieldName,!(0,validation/* isEmpty */.xb)(actualFieldName)&&actualFieldName.match(/#parent$/)&&(actualFieldName=actualFieldName.split("#")[0]),selectedField=_this.getSelectedField(actualFieldName),_this.setField(selectedField),showValueType&&_this.setValueType(value),deserializedCondition.value=_this.getConditionValue(selectedField,value),_this.conditionObj=deserializedCondition;case 36:selectedOperator=((null===(_this$field=_this.field)||void 0===_this$field?void 0:_this$field.operators)||[]).find((function(operator){return(null===operator||void 0===operator?void 0:operator.operatorId)===operatorId})),_ref28=selectedOperator||{},lookupModule=_ref28.lookupModule,_this.$set(_this.field,"operatorLookupModule",lookupModule);case 39:showValueType&&_this.initCustomValues(),_this.isLoading=!1;case 41:case"end":return _context.stop()}}),_callee)})))()},getFieldName:function(fieldName){var multilookupRegex=/^([a-z]+_?.+\.)/,multilookupArray=!(0,validation/* isArray */.kJ)(fieldName)&&(null===fieldName||void 0===fieldName?void 0:fieldName.match(multilookupRegex))||[];if(!(0,validation/* isEmpty */.xb)(multilookupArray)){var splitArray=fieldName.split(".");return splitArray[1]}return fieldName},getConditionValue:function(field,value){var isLookupTypeField=this.isLookupTypeField,isPicklistTypeField=this.isPicklistTypeField,isLookupPopupField=this.isLookupPopupField,valueType=this.valueType;if("value"!==valueType)return value;if("value"===valueType&&!(0,validation/* isEmpty */.xb)(value)&&(isLookupTypeField(field)||isLookupPopupField(field)||isPicklistTypeField(field))){var valueArr=String(value).split(",")||[];return(0,validation/* isEmpty */.xb)(valueArr)||(valueArr=valueArr.map((function(value){return value.includes("${")?value:Number(value)}))),valueArr}return value},initCustomValues:function(){var _ref29=this||{},customValues=_ref29.customValues,valueTypeOptions=_ref29.valueTypeOptions,conditionObj=_ref29.conditionObj,value=conditionObj.value,modifiedOptions=customValues.map((function(valueOption){var _ref30=valueOption||{},label=_ref30.label,value=_ref30.value;return{label:label,value:value}}));this.valueTypeOptions=[].concat(dist_toConsumableArray(valueTypeOptions),dist_toConsumableArray(modifiedOptions));var typeBasedValues={};customValues.forEach((function(valueOption){var _ref31=valueOption||{},value=_ref31.value,options=_ref31.options;typeBasedValues[value]=options||[]})),(0,validation/* isEmpty */.xb)(value)||this.setValueType(value),this.typeBasedValues=typeBasedValues},setValueType:function(value){var _this2=this,_ref32=this||{},customValues=_ref32.customValues;customValues.forEach((function(customObj){var options=customObj.options,customValueField=customObj.value,_customObj$matcher=customObj.matcher,matcher=void 0===_customObj$matcher?null:_customObj$matcher;options.forEach((function(option){var optionValue=option.value;value===optionValue&&(_this2.valueType=customValueField)})),(0,validation/* isFunction */.mf)(matcher)&&matcher(value)&&(_this2.valueType=customValueField)}))},setField:function(field){this.$set(this,"field",field)},resetValue:function(){var ref=this.$refs.conditionValue,_ref33=this||{},showValueType=_ref33.showValueType,conditionObj=_ref33.conditionObj;(0,validation/* isEmpty */.xb)(ref)||ref.resetValue(),showValueType&&(this.conditionObj=dist_objectSpread2(dist_objectSpread2({},conditionObj),{},{value:""}),this.valueType="value")},resetOperator:function(){var conditionObj=this.conditionObj;this.$set(conditionObj,"operatorId",null)},resetCondition:function(){var condition=DEFAULT_CRITERIA;this.conditionObj=cloneDeep(condition)},setFieldValue:function(value){this.handleFieldChange(value)},handleFieldChange:function(value){var _this3=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee2(){var advancedFields,cachedModule,parentfield,lookupModule,name,childField,childFields,_yield$API$get2,data,_childFields,parentfieldName,childFieldName,fieldName,selectedField,field,_ref34,displayType;return dist_regeneratorRuntime().wrap((function(_context2){while(1)switch(_context2.prev=_context2.next){case 0:// need to refactor this code
if(advancedFields=_this3.advancedFields,cachedModule=_this3.cachedModule,!(0,validation/* isArray */.kJ)(value)||2!==value.length){_context2.next=25;break}if(parentfield=advancedFields.find((function(field){return field.name===value[0]})),lookupModule=parentfield.lookupModule,name=lookupModule.name,(0,validation/* isEmpty */.xb)(cachedModule[name])){_context2.next=10;break}childFields=cachedModule[name],childField=childFields.find((function(field){return field.name===value[1]})),_context2.next=18;break;case 10:return _context2.next=12,api/* API */.bl.get("/v2/filter/advanced/fields/".concat(name));case 12:_yield$API$get2=_context2.sent,data=_yield$API$get2.data,_childFields=data.fields,_childFields=_childFields.map((function(field){return dist_objectSpread2(dist_objectSpread2({},field),{},{multiple:dist_isLookupPopupField(field)||dist_isLookupTypeField(field)})})),_this3.$set(_this3.cachedModule,name,_childFields),childField=_childFields.find((function(field){return field.name===value[1]}));case 18:
// check whether the field is prefilled or not
_this3.setField(childField),parentfieldName=value[0],childFieldName=childField.name,fieldName=[parentfieldName,childFieldName],_this3.$set(_this3.conditionObj,"fieldName",fieldName),_context2.next=26;break;case 25:(0,validation/* isEmpty */.xb)(value)?(0,validation/* isEmpty */.xb)(value)&&_this3.setField({}):(selectedField={},field=advancedFields.find((function(field){return field.name===value[0]})),_ref34=field||{},displayType=_ref34.displayType,
/**
                Array will be like :-
                [fieldId, rowId, colId] for matrix field
                fieldId, colId] for multiQuestion field
                [fieldName] for all other fields
                **/
["MATRIX","MULTI_QUESTION"].includes(displayType)?(_this3.$set(_this3.conditionObj,"fieldName",value),_this3.$set(_this3.conditionObj,"fieldNameStr",value.join("_"))):2==value.length?_this3.$set(_this3.conditionObj,"fieldName",value):_this3.$set(_this3.conditionObj,"fieldName",value[0]),selectedField=_this3.getSelectedField(value),_this3.setField(selectedField));case 26:_this3.resetOperator(),_this3.resetValue();case 28:case"end":return _context2.stop()}}),_callee2)})))()},getSelectedField:function(value){var advancedFields=this.advancedFields,selectedField={};if(!(0,validation/* isEmpty */.xb)(value)){var field,selectedValue=value;(0,validation/* isArray */.kJ)(value)?(selectedValue=value[0]||{},selectedValue.match(/#parent$/)&&(selectedValue=selectedValue.split("#")[0])):selectedValue.match(/#parent$/)&&(selectedValue=selectedValue.split("#")[0]),field=advancedFields.find((function(field){return field.name===selectedValue}));var _ref35=field||{},displayType=_ref35.displayType;if(["MATRIX","MULTI_QUESTION"].includes(displayType)){var rowId=value[1]||{},colId=value[2]||{},_ref36=field||{},rows=_ref36.children,selectedRow=rows.find((function(row){return row.id===parseInt(rowId)})),_ref37=selectedRow||{},columns=_ref37.children,selectedColumn=columns.find((function(column){return column.id===parseInt(colId)}))||{};selectedField=selectedColumn}else selectedField=field}var clonedField={};return(0,validation/* isEmpty */.xb)(selectedField)||(clonedField=cloneDeep(selectedField)),clonedField},handleOperatorChange:function(value){var field=this.field,fieldOperators=this.fieldOperators,selectedOperator=fieldOperators.find((function(operator){return operator.operatorId===value}));
// Special handling for role is operator, have to fetch roles list in right side
if(!(0,validation/* isEmpty */.xb)(selectedOperator)){
// Have to reset selected items array in field, if field is lookup type
(dist_isLookupTypeField(field)||dist_isLookupPopupField(field))&&this.$set(field,"selectedItems",[]),this.resetValue();var _ref38=selectedOperator||{},_ref38$lookupModule=_ref38.lookupModule,lookupModule=void 0===_ref38$lookupModule?{}:_ref38$lookupModule;this.$set(field,"operatorLookupModule",lookupModule)}}}};
/* script */
const dist_vue_script_$8=dist_script$8;
/* template */var dist_vue_render_$6=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"w-full"},[_vm.isLoading?_c("div",{staticClass:"flex"},[_c("FieldLoader",{staticClass:"mr-2 my-2",attrs:{isLoading:_vm.isLoading}}),_vm._v(" "),_c("FieldLoader",{staticClass:"mr-2 my-2",attrs:{isLoading:_vm.isLoading}}),_vm._v(" "),_c("FieldLoader",{staticClass:"mr-2 my-2",attrs:{isLoading:_vm.isLoading}}),_vm._v(" "),_c("FieldLoader",{attrs:{isLoading:_vm.showValueType&&_vm.isLoading}})],1):_vm._e(),_vm._v(" "),_vm.isLoading?_vm._e():_c("div",{staticClass:"flex w-full flex-nowrap relative h-14"},[_c("div",{staticClass:"index-container self-center"},[_c("div",{staticClass:"alphabet-circle",class:[1!==_vm.index?"circle-line-bottom":"",_vm.showLineTop?"circle-line-top":"",_vm.condition.prevOperator?"and-line":"or-line"]},[_vm._v("\n        "+_vm._s(_vm.index)+"\n      ")])]),_vm._v(" "),_c("div",{staticClass:"criteria-fields-container self-center w-full relative f-ui-forms"},[_c("Cascader",{ref:_vm.index,staticClass:"w-full f-ui-select f-cascader",attrs:{options:_vm.fields,label:"displayName",value:"name",filterable:"",clearable:"",props:{value:"name",label:"displayName",expandTrigger:"click"},"filter-method":_vm.filterFields,disabled:_vm.disabled},on:{clear:_vm.resetCondition,change:_vm.setFieldValue},scopedSlots:_vm._u([{key:"default",fn:function(ref){var node=ref.node,data=ref.data;return[_c("div",{staticStyle:{display:"flex",gap:"8px","align-items":"center"}},[_c("field-icons",{attrs:{src:_vm.getIcon(data,node.children)}}),_vm._v(" "),_c("span",[_vm._v(_vm._s(data.displayName))])],1)]}}],null,!1,2907273552),model:{value:_vm.conditionObj.fieldName,callback:function($$v){_vm.$set(_vm.conditionObj,"fieldName",$$v)},expression:"conditionObj.fieldName"}}),_vm._v(" "),_c("div",{directives:[{name:"show",rawName:"v-show",value:_vm.childLoading,expression:"childLoading"}],staticClass:"child-field-loader"},[_c("FieldLoader",{staticClass:"my-2 mx-2",attrs:{isLoading:!0}}),_vm._v(" "),_c("FieldLoader",{staticClass:"my-2 mx-2",attrs:{isLoading:!0}}),_vm._v(" "),_c("FieldLoader",{staticClass:"my-2 mx-2",attrs:{isLoading:!0}})],1),_vm._v(" "),_vm.canShowError?_c("div",{staticClass:"condition-error"},[_vm._v("\n        "+_vm._s(_vm.selectedFieldExists?"Selected operator doesn't exists":"Selected field doesn't exist")+"\n      ")]):_vm._e()],1),_vm._v(" "),_c("div",{staticClass:"criteria-operator-container self-center w-full"},[_c("Select",{key:"index "+_vm.conditionObj.fieldName+" Operator",ref:"index-"+_vm.conditionObj.fieldName+"-operator",staticClass:"width-full",attrs:{options:_vm.fieldOperators,labelName:"displayName",valueName:"id",filterable:"",clearable:"",placeholder:_vm.operatorPlaceholder,disabled:_vm.checkOperatorDisabled},on:{clear:_vm.resetValue,change:_vm.handleOperatorChange},model:{value:_vm.conditionObj.operatorId,callback:function($$v){_vm.$set(_vm.conditionObj,"operatorId",$$v)},expression:"conditionObj.operatorId"}})],1),_vm._v(" "),_vm.showValueType?_c("div",{staticClass:"criteria-operator-container self-center w-full"},[_c("Select",{key:"index "+_vm.conditionObj.fieldName+" Operator",ref:"index-"+_vm.conditionObj.fieldName+"-operator",staticClass:"width-full",attrs:{options:_vm.valueTypeOptions,filterable:"",clearable:"",disabled:_vm.checkOperatorDisabled||_vm.disableValueContainer},on:{clear:_vm.resetValue,change:_vm.updateCustomValue},model:{value:_vm.valueType,callback:function($$v){_vm.valueType=$$v},expression:"valueType"}})],1):_vm._e(),_vm._v(" "),_vm.showValueType&&"value"===_vm.valueType||"value"===_vm.valueType?_c("ConditionValue",{ref:"conditionValue",attrs:{field:_vm.field,disableValueContainer:_vm.disableValueContainer,account:_vm.account,isSpecialOperator:_vm.isSpecialOperator,operatorObj:_vm.currentOperatorObj},on:{"update:field":function($event){_vm.field=$event}},model:{value:_vm.conditionObj.value,callback:function($$v){_vm.$set(_vm.conditionObj,"value",$$v)},expression:"conditionObj.value"}}):"value"!==_vm.valueType&&"custom"!==_vm.valueType?_c("div",{staticClass:"criteria-fields-container self-center w-full"},[_c("Select",{key:"index "+_vm.conditionObj.fieldName+" field",ref:"index-"+_vm.conditionObj.fieldName+"-field",staticClass:"width-full",attrs:{options:_vm.typeBasedValues[_vm.valueType],filterable:!!_vm.isEmpty(_vm.allowCreate)||_vm.allowCreate,clearable:"",allowCreate:_vm.allowCreate},model:{value:_vm.conditionObj.value,callback:function($$v){_vm.$set(_vm.conditionObj,"value",$$v)},expression:"conditionObj.value"}})],1):_vm._e()],1)])},dist_vue_staticRenderFns_$6=[];
/* style */
const dist_vue_inject_styles_$8=function(inject){inject&&(inject("data-v-1ed63bb1_0",{source:'.child-field-loader[data-v-1ed63bb1]{height:150px;width:100%;display:flex;flex-direction:column;position:absolute;margin-top:10px;border-radius:4px;box-shadow:0 2px 12px 0 rgba(0,0,0,.1);z-index:20;background:#fff}.alphabet-circle[data-v-1ed63bb1]{width:30px;height:30px;border:solid 1px #a3bdc0;border-radius:100%;text-align:center;font-size:14px;font-weight:700;letter-spacing:.5px;line-height:24.7px;color:#91b3b6;display:flex;justify-content:center;align-items:center}.circle-line-bottom[data-v-1ed63bb1]::before{border-left:1px solid #a3bdc0;content:"";position:absolute;top:0;height:12px}.circle-line-top[data-v-1ed63bb1]::after{border-left:1px solid #a3bdc0;content:"";position:absolute;bottom:0;height:12px}.criteria-fields-container[data-v-1ed63bb1]{position:relative}.criteria-fields-container[data-v-1ed63bb1],.criteria-index-container[data-v-1ed63bb1],.criteria-operator-container[data-v-1ed63bb1]{margin-left:.5rem}.condition-error[data-v-1ed63bb1]{display:flex;justify-content:start;margin-left:15px;margin-top:8px;font-size:13px;color:#f56c6c;position:absolute;line-height:11px}',map:void 0,media:void 0}),inject("data-v-1ed63bb1_1",{source:".el-cascader-node.in-active-path{color:#000;font-weight:bolder}.el-cascader-node.in-active-path i.el-icon-arrow-right.el-cascader-node__postfix{font-weight:bolder}.el-cascader-node.is-active,.el-cascader-node.is-selectable.in-checked-path{color:#ff3184}.el-cascader-node.is-active .el-icon-check,.el-cascader-node.is-selectable.in-checked-path .el-icon-check{display:none}",map:void 0,media:void 0}))},dist_vue_scope_id_$8="data-v-1ed63bb1",dist_vue_module_identifier_$8=void 0,dist_vue_is_functional_template_$8=!1,dist_vue_component_$8=dist_normalizeComponent({render:dist_vue_render_$6,staticRenderFns:dist_vue_staticRenderFns_$6},dist_vue_inject_styles_$8,dist_vue_script_$8,dist_vue_scope_id_$8,dist_vue_is_functional_template_$8,dist_vue_module_identifier_$8,!1,dist_createInjector,void 0,void 0);
/* scoped */function dist_styleInject(css,ref){void 0===ref&&(ref={});var insertAt=ref.insertAt;if(css&&"undefined"!==typeof document){var head=document.head||document.getElementsByTagName("head")[0],style=document.createElement("style");style.type="text/css","top"===insertAt&&head.firstChild?head.insertBefore(style,head.firstChild):head.appendChild(style),style.styleSheet?style.styleSheet.cssText=css:style.appendChild(document.createTextNode(css))}}var dist_css_248z="*, ::before, ::after {\n  --tw-border-opacity: 1;\n  border-color: rgba(229, 231, 235, var(--tw-border-opacity))\n}\n\n.container {\n  width: 100%\n}\n\n@media (min-width: 640px) {\n  .container {\n    max-width: 640px\n  }\n}\n\n@media (min-width: 768px) {\n  .container {\n    max-width: 768px\n  }\n}\n\n@media (min-width: 1024px) {\n  .container {\n    max-width: 1024px\n  }\n}\n\n@media (min-width: 1280px) {\n  .container {\n    max-width: 1280px\n  }\n}\n\n@media (min-width: 1536px) {\n  .container {\n    max-width: 1536px\n  }\n}\n\n.relative {\n  position: relative\n}\n\n.m-2 {\n  margin: 0.5rem\n}\n\n.mx-2 {\n  margin-left: 0.5rem;\n  margin-right: 0.5rem\n}\n\n.my-2 {\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem\n}\n\n.mt-0 {\n  margin-top: 0px\n}\n\n.mt-5 {\n  margin-top: 1.25rem\n}\n\n.mt-0\\.5 {\n  margin-top: 0.125rem\n}\n\n.mr-2 {\n  margin-right: 0.5rem\n}\n\n.mb-2 {\n  margin-bottom: 0.5rem\n}\n\n.ml-1 {\n  margin-left: 0.25rem\n}\n\n.ml-2 {\n  margin-left: 0.5rem\n}\n\n.ml-3 {\n  margin-left: 0.75rem\n}\n\n.flex {\n  display: flex\n}\n\n.table {\n  display: table\n}\n\n.h-14 {\n  height: 3.5rem\n}\n\n.w-full {\n  width: 100%\n}\n\n.flex-grow {\n  flex-grow: 1\n}\n\n.transform {\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  transform: translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))\n}\n\n@keyframes spin {\n  to {\n    transform: rotate(360deg)\n  }\n}\n\n@keyframes ping {\n  75%, 100% {\n    transform: scale(2);\n    opacity: 0\n  }\n}\n\n@keyframes pulse {\n  50% {\n    opacity: .5\n  }\n}\n\n@keyframes bounce {\n  0%, 100% {\n    transform: translateY(-25%);\n    animation-timing-function: cubic-bezier(0.8,0,1,1)\n  }\n\n  50% {\n    transform: none;\n    animation-timing-function: cubic-bezier(0,0,0.2,1)\n  }\n}\n\n.cursor-pointer {\n  cursor: pointer\n}\n\n.cursor-not-allowed {\n  cursor: not-allowed\n}\n\n.flex-col {\n  flex-direction: column\n}\n\n.flex-wrap {\n  flex-wrap: wrap\n}\n\n.flex-nowrap {\n  flex-wrap: nowrap\n}\n\n.items-center {\n  align-items: center\n}\n\n.justify-center {\n  justify-content: center\n}\n\n.self-center {\n  align-self: center\n}\n\n.border {\n  border-width: 1px\n}\n\n.text-center {\n  text-align: center\n}\n\n.leading-5 {\n  line-height: 1.25rem\n}\n\n*, ::before, ::after {\n  --tw-shadow: 0 0 #0000\n}\n\n*, ::before, ::after {\n  --tw-ring-inset: var(--tw-empty,/*!*/ /*!*/);\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgba(59, 130, 246, 0.5);\n  --tw-ring-offset-shadow: 0 0 #0000;\n  --tw-ring-shadow: 0 0 #0000\n}\n\n.filter {\n  --tw-blur: var(--tw-empty,/*!*/ /*!*/);\n  --tw-brightness: var(--tw-empty,/*!*/ /*!*/);\n  --tw-contrast: var(--tw-empty,/*!*/ /*!*/);\n  --tw-grayscale: var(--tw-empty,/*!*/ /*!*/);\n  --tw-hue-rotate: var(--tw-empty,/*!*/ /*!*/);\n  --tw-invert: var(--tw-empty,/*!*/ /*!*/);\n  --tw-saturate: var(--tw-empty,/*!*/ /*!*/);\n  --tw-sepia: var(--tw-empty,/*!*/ /*!*/);\n  --tw-drop-shadow: var(--tw-empty,/*!*/ /*!*/);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)\n}\n\n.transition {\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\n  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms\n}\n\n.ease-in-out {\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1)\n}\n\n@media (min-width: 640px) {\n}\n\n@media (min-width: 768px) {\n}\n\n@media (min-width: 1024px) {\n}\n\n@media (min-width: 1280px) {\n}\n\n@media (min-width: 1536px) {\n}\n";dist_styleInject(dist_css_248z);var dist_AddIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{width:"18",height:"18",xmlns:"http://www.w3.org/2000/svg"}},[_c("g",{attrs:{fill:"none"}},[_c("path",{attrs:{d:"M9 .7C4.424.7.7 4.424.7 9c0 4.576 3.724 8.3 8.3 8.3 4.576 0 8.3-3.724 8.3-8.3C17.3 4.424 13.576.7 9 .7z",stroke:"#31C583","stroke-width":"1.4",fill:"#FFF"}}),_c("path",{attrs:{d:"M12.486 8.24H9.697V5.452a.697.697 0 10-1.394 0V8.24H5.514a.697.697 0 100 1.394h2.789v2.789a.697.697 0 101.394 0V9.634h2.789a.697.697 0 100-1.394z",fill:"#31C583"}})])])}},RemoveIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{width:"18",height:"18",xmlns:"http://www.w3.org/2000/svg"}},[_c("g",{attrs:{fill:"none"}},[_c("path",{attrs:{d:"M9 .7C4.424.7.7 4.424.7 9c0 4.576 3.724 8.3 8.3 8.3 4.576 0 8.3-3.724 8.3-8.3C17.3 4.424 13.576.7 9 .7z",stroke:"#EC7C7C","stroke-width":"1.4",fill:"#FFF"}}),_c("path",{attrs:{d:"M12.836 8.1H5.164a.767.767 0 100 1.534h7.672a.767.767 0 100-1.534z",fill:"#EC7C7C"}})])])}},dist_script$7={computed:{isBracketBalanced:function(){for(
// check if brackets are balanced
var _ref=this||{},criteria=_ref.criteria,_ref2=criteria||{},pattern=_ref2.pattern,stack=[],valid=!0,i=0;i<pattern.length;i++){var character=pattern[i];if("("!==character){if(")"===character){var check=stack.pop();"("!==check&&(valid=!1)}}else stack.push(character)}return(0,validation/* isEmpty */.xb)(stack)||(valid=!1),{valid:valid,validationMessage:"Brackets are not balanced"}},isCountValid:function(){
// Condition keys should match the pattern
var _ref3=this||{},criteria=_ref3.criteria,conditionsKeys=_ref3.conditionsKeys,_ref4=criteria||{},pattern=_ref4.pattern,numberRegex=/\d+/g,patternKeys=pattern.match(numberRegex),valid=lodash_isEqual(patternKeys,conditionsKeys);return{valid:valid,validationMessage:"Condition keys are not matching"}},areOperatorsValid:function(){
// operator should be only or / and
var _ref5=this||{},criteria=_ref5.criteria,_ref6=criteria||{},pattern=_ref6.pattern,modifiedPattern=pattern.replace(/[{()}]/g,"");modifiedPattern=modifiedPattern.replace(/\d+/g,"");var operatorArray=modifiedPattern.split(" ").filter((function(token){return""!==token})),valid=operatorArray.every((function(operator){return["or","and"].includes(operator)}));return{valid:valid,validationMessage:"Invalid operator value"}},isOperatorCountValid:function(){
// operator count should not be extra should be one less than conditions
var _ref7=this||{},criteria=_ref7.criteria,conditionsKeys=_ref7.conditionsKeys,_ref8=criteria||{},pattern=_ref8.pattern,modifiedPattern=pattern.replace(/[{()}]/g,"");modifiedPattern=modifiedPattern.replace(/\d+/g,"");var operatorArray=modifiedPattern.split(" ").filter((function(token){return""!==token})),operatorLength=(operatorArray||[]).length,conditionsLength=(conditionsKeys||[]).length,valid=operatorLength===conditionsLength-1;return{valid:valid,validationMessage:"Operator is invalid"}},validations:function(){var _ref9=this||{},isBracketBalanced=_ref9.isBracketBalanced,isCountValid=_ref9.isCountValid,areOperatorsValid=_ref9.areOperatorsValid,isOperatorCountValid=_ref9.isOperatorCountValid;return[areOperatorsValid,isOperatorCountValid,isCountValid,isBracketBalanced]},isValidPattern:function(){var _ref10=this||{},validations=_ref10.validations;return validations.every((function(check){return(check||{}).valid||!1}))},validationMessage:function(){var _ref11=this||{},validations=_ref11.validations,message="";return validations.forEach((function(validationObj){var _ref12=validationObj||{},valid=_ref12.valid,validationMessage=_ref12.validationMessage;valid||(message=validationMessage)})),message}},methods:{validate:function(){return this.isValidPattern}}};
/* script */
const dist_vue_script_$7=dist_script$7,dist_vue_inject_styles_$7=void 0,dist_vue_scope_id_$7=void 0,dist_vue_module_identifier_$7=void 0,dist_vue_is_functional_template_$7=void 0,dist_vue_component_$7=dist_normalizeComponent({},dist_vue_inject_styles_$7,dist_vue_script_$7,dist_vue_scope_id_$7,dist_vue_is_functional_template_$7,dist_vue_module_identifier_$7,!1,void 0,void 0,void 0);
/* template */
/* style */
var dist_script$6={props:["value","conditionKey","isPatternReadonly"],computed:{operatorValue:{get:function(){return this.value},set:function(){var _ref=this||{},conditionKey=_ref.conditionKey,value=_ref.value;this.$emit("input",!value),this.$emit("change",{key:conditionKey,value:!value})}}},methods:{toggleOperator:function(){var operatorValue=this.operatorValue,isPatternReadonly=this.isPatternReadonly;isPatternReadonly?this.operatorValue=!operatorValue:this.$message.error("Please save your pattern to edit criteria")}}};
/* script */const dist_vue_script_$6=dist_script$6;
/* template */var dist_vue_render_$5=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"flex cursor-pointer justify-center operator-pill items-center",class:_vm.operatorValue?"and-container":"or-container",on:{click:_vm.toggleOperator}},[_c("div",{staticClass:"flex items-center justify-center mt-0.5"},[_vm._v("\n    "+_vm._s(_vm.operatorValue?"AND":"OR")+"\n  ")]),_vm._v(" "),_vm._m(0)])},dist_vue_staticRenderFns_$5=[function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"flex flex-col justify-center ml-1",staticStyle:{"font-size":"9px","font-weight":"900"}},[_c("i",{staticClass:"el-icon-arrow-up"}),_c("i",{staticClass:"el-icon-arrow-down"})])}];
/* style */
const dist_vue_inject_styles_$6=function(inject){inject&&inject("data-v-a7b804ea_0",{source:".operator-pill[data-v-a7b804ea]{border-radius:25px;font-size:13px;padding-top:5px;padding-bottom:5px;width:60px;font-weight:700;user-select:none;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;line-height:20px;margin-left:-12px}.and-container[data-v-a7b804ea]{background-color:#fef1e1;color:#ffb666}.or-container[data-v-a7b804ea]{background-color:#eaefff;color:#668cff}",map:void 0,media:void 0})},dist_vue_scope_id_$6="data-v-a7b804ea",dist_vue_module_identifier_$6=void 0,dist_vue_is_functional_template_$6=!1,dist_vue_component_$6=dist_normalizeComponent({render:dist_vue_render_$5,staticRenderFns:dist_vue_staticRenderFns_$5},dist_vue_inject_styles_$6,dist_vue_script_$6,dist_vue_scope_id_$6,dist_vue_is_functional_template_$6,dist_vue_module_identifier_$6,!1,dist_createInjector,void 0,void 0);
/* scoped */function _createForOfIteratorHelper(o,allowArrayLike){var it="undefined"!==typeof Symbol&&o[Symbol.iterator]||o["@@iterator"];if(!it){if(Array.isArray(o)||(it=dist_unsupportedIterableToArray(o))||allowArrayLike&&o&&"number"===typeof o.length){it&&(o=it);var i=0,F=function(){};return{s:F,n:function(){return i>=o.length?{done:!0}:{done:!1,value:o[i++]}},e:function(_e){throw _e},f:F}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var err,normalCompletion=!0,didErr=!1;return{s:function(){it=it.call(o)},n:function(){var step=it.next();return normalCompletion=step.done,step},e:function(_e2){didErr=!0,err=_e2},f:function(){try{normalCompletion||null==it["return"]||it["return"]()}finally{if(didErr)throw err}}}}var dist_script$5={methods:{sanitizeCriteria:function(criteria){for(var clonedCriteria=cloneDeep(criteria),pattern=clonedCriteria.pattern,conditions=clonedCriteria.conditions,conditionsObj={},index=1,_i=0,_Object$entries=Object.entries(conditions);_i<_Object$entries.length;_i++){var _Object$entries$_i=dist_slicedToArray(_Object$entries[_i],2),key=_Object$entries$_i[0],value=_Object$entries$_i[1];key===index?conditions[key]=value:conditionsObj[index]=value,index++}var sanitizedPattern=this.injectSpace(pattern),patternIndex=0,replacedPattern=sanitizedPattern.replace(/[0-9]+/g,(function(){return patternIndex++,patternIndex}));return{conditions:conditionsObj,pattern:replacedPattern}},sanitizePattern:function(pattern){var str=pattern.split(" "),stack=this.generatePatternStack(str),n=stack.length;if(0!==n){for(var check=[],i=0;i<n;i++)check[i]=!0;for(var record=[],resultantPattern="",_i2=0;_i2<n;++_i2)if(")"===stack[_i2]){if(0===record.length)return;if("("===stack[record[record.length-1]])check[_i2]=!1,check[record[record.length-1]]=!1,record.pop();else{while(0!==record.length&&"("!=stack[record[record.length-1]])
// Remove element until not get open parentheses
record.pop();if(0===record.length)
// Expression are not valid
return;record.pop()}}else record.push(_i2);for(var j=0;j<n;++j)check[j]&&("("===stack[j]||")"===stack[j]?resultantPattern+=stack[j]:resultantPattern=resultantPattern+" "+stack[j]+" ");return resultantPattern}},removeInvalidOperators:function(pattern){for(var str=pattern.split(" "),resultantPattern="",stack=this.generatePatternStack(str),i=0;i<stack.length;i++)"and"!==stack[i]&&"or"!==stack[i]||i-1!==0&&"("===stack[i-1]&&(stack[i]="");var _step,_iterator=_createForOfIteratorHelper(stack);try{for(_iterator.s();!(_step=_iterator.n()).done;){var token=_step.value;"("===token||")"==token?resultantPattern+=token:""!==token&&(resultantPattern=resultantPattern+" "+token+" ")}}catch(err){_iterator.e(err)}finally{_iterator.f()}return resultantPattern},deserializePattern:function(){var _step2,criteria=this.criteria,conditionsKeys=this.conditionsKeys,serializedPattern=criteria.serializedPattern,spacedPattern="",_iterator2=_createForOfIteratorHelper(serializedPattern);try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var token=_step2.value;spacedPattern+="("===token||")"==token?" "+token+" ":token}}catch(err){_iterator2.e(err)}finally{_iterator2.f()}var str=spacedPattern.split(" "),stack=this.generatePatternStack(str),deserializedPattern="";for(var i in stack){var key=parseInt(stack[i]);isNaN(key)||(stack[i]=conditionsKeys[key-1])}var _step3,resultantPattern="",_iterator3=_createForOfIteratorHelper(stack);try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var _token=_step3.value;"("===_token||")"==_token?resultantPattern+=_token:""!==_token&&(resultantPattern=resultantPattern+" "+_token+" ")}}catch(err){_iterator3.e(err)}finally{_iterator3.f()}return deserializedPattern=resultantPattern,deserializedPattern},injectSpace:function(pattern){var _step4,stringArray=pattern.split(" "),resultantPattern="",_iterator4=_createForOfIteratorHelper(stringArray);try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var s=_step4.value;if("and"===s||"or"===s)resultantPattern+=s+" ";else if(""!==s){var arr=s.split("").join(" ");resultantPattern+=arr+" "}}}catch(err){_iterator4.e(err)}finally{_iterator4.f()}return resultantPattern},generatePatternStack:function(pattern){var _step5,stack=[],_iterator5=_createForOfIteratorHelper(pattern);try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var s=_step5.value;if("and"===s||"or"===s)stack.push(s);else if(s.length>1)if(isNaN(parseInt(s))){var _step6,sub=s.split(""),_iterator6=_createForOfIteratorHelper(sub);try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var i=_step6.value;stack.push(i)}}catch(err){_iterator6.e(err)}finally{_iterator6.f()}}else stack.push(s);else""!==s&&stack.push(s)}}catch(err){_iterator5.e(err)}finally{_iterator5.f()}return stack}}};
/* script */const dist_vue_script_$5=dist_script$5,dist_vue_inject_styles_$5=void 0,dist_vue_scope_id_$5=void 0,dist_vue_module_identifier_$5=void 0,dist_vue_is_functional_template_$5=void 0,dist_vue_component_$5=dist_normalizeComponent({},dist_vue_inject_styles_$5,dist_vue_script_$5,dist_vue_scope_id_$5,dist_vue_is_functional_template_$5,dist_vue_module_identifier_$5,!1,void 0,void 0,void 0);
/* template */
/* style */var defaultCriteria={fieldName:null,operatorId:null,value:null,prevOperator:!0},specialOperator={DATE_CUSTOM:20,NUMBER_BETWEEN:81,NUMBER_NOT_BETWEEN:82,CURRENCY_FIELD_BETWEEN:122,CURRENCY_FIELD_NOT_BETWEEN:123,MULTI_CURRENCY_BETWEEN:140,MULTI_CURRENCY_NOT_BETWEEN:141},dist_script$4={name:"CriteriaBuilder",mixins:[dist_vue_component_$7,dist_vue_component_$5],props:{moduleName:{type:String,required:!0},value:{type:Object},filterFields:{type:Function},filterOperators:{type:Function},showValueType:{type:Boolean},customValues:{type:Array},disabled:{type:Boolean},isOneLevelEnabled:{type:Boolean,default:!1},getFields:{type:Function}},components:{Condition:dist_vue_component_$8,AddIcon:dist_AddIcon,RemoveIcon:RemoveIcon,FieldLoader:dist_vue_component_$a,OperatorToggle:dist_vue_component_$6,Input:element_ui_common.Input},data:function(){return{operators:[],fields:[],selectedField:null,isLoading:!0,account:null,isEmpty:validation/* isEmpty */.xb,isPatternReadonly:!0,previousPattern:"",dummyCriteria:null,serializedConditions:[],serializedPattern:"",cachedModule:{},oneLevelModules:[],advancedFields:[],lookupModuleFieldList:[]}},computed:{showRemoveIcon:function(){var conditionsKeys=this.conditionsKeys,conditionsLength=this.conditionsLength;return!(0,validation/* isEmpty */.xb)(conditionsKeys)&&!(1==conditionsLength)},
//  to check if criteria is configured
ifCriteriaExists:function(){var value=this.value;return!(0,validation/* isEmpty */.xb)(value)},criteria:{get:function(){var value=this.value;return value||{}},set:function(value){this.$emit("input",value)}},conditionsKeys:function(){var _ref=this||{},serializedConditions=_ref.serializedConditions,conditionsKeys=Object.keys(serializedConditions).map((function(key){return"".concat(parseInt(key)+1)}));return conditionsKeys||[]},conditionsLength:function(){var _ref2=this||{},conditionsKeys=_ref2.conditionsKeys,_ref3=conditionsKeys||{},_ref3$length=_ref3.length,length=void 0===_ref3$length?0:_ref3$length;return length},filteredFields:function(){var _ref4=this||{},fields=_ref4.fields,filterFields=_ref4.filterFields;return!(0,validation/* isEmpty */.xb)(filterFields)&&isFunction(filterFields)?(fields||[]).filter(filterFields):fields||[]},patternOperatorList:function(){var _ref5=this||{},criteria=_ref5.criteria,_ref6=criteria||{},_ref6$conditions=_ref6.conditions,conditions=void 0===_ref6$conditions?[]:_ref6$conditions,operatorList={};return Object.entries(conditions).forEach((function(_ref7){var _ref8=dist_slicedToArray(_ref7,2),key=_ref8[0],value=_ref8[1],_ref9=value||{},prevOperator=_ref9.prevOperator;(0,validation/* isEmpty */.xb)(prevOperator)||(operatorList[key]=prevOperator)})),operatorList}},created:function(){this.init()},watch:{conditionsLength:function(value){value<=2&&(this.disablePattern=!1)}},methods:{init:function(){var _this=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee(){var criteria,sanitizedCriteria;return dist_regeneratorRuntime().wrap((function(_context){while(1)switch(_context.prev=_context.next){case 0:return criteria=_this.criteria,_this.isLoading=!0,(0,validation/* isEmpty */.xb)(criteria)||(sanitizedCriteria=_this.sanitizeCriteria(_this.criteria),_this.criteria=sanitizedCriteria),_context.next=5,Promise.all([_this.loadOperators(),_this.loadFields(),_this.fetchAccount()]);case 5:return _context.next=7,_this.constructCriteria();case 7:return _context.next=9,_this.serializeConditions();case 9:return _context.next=11,_this.fetchOneLevelModules();case 11:_this.isLoading=!1;case 12:case"end":return _context.stop()}}),_callee)})))()},fetchOneLevelModules:function(){var _this2=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee2(){var oneLevelModules,response,i,modulename,data,oneLevelFields;return dist_regeneratorRuntime().wrap((function(_context2){while(1)switch(_context2.prev=_context2.next){case 0:if(oneLevelModules=_this2.oneLevelModules,_this2.oneLevelModules=dist_toConsumableArray(new Set(oneLevelModules)),!(0,validation/* isEmpty */.xb)(oneLevelModules)){_context2.next=4;break}return _context2.abrupt("return");case 4:return _context2.next=6,Promise.all(oneLevelModules.map((function(lookupModuleName){return api/* API */.bl.get("/v2/filter/advanced/fields/".concat(lookupModuleName))})));case 6:for(i in response=_context2.sent,oneLevelModules)modulename=oneLevelModules[i],data=response[i].data,oneLevelFields=data.fields,oneLevelFields=oneLevelFields.filter((function(field){return"MULTI_LOOKUP"!==field.dataType&&"siteId"!==field.name})),oneLevelFields=oneLevelFields.map((function(field){return dist_objectSpread2(dist_objectSpread2({},field),{},{multiple:dist_isLookupPopupField(field)||dist_isLookupTypeField(field)})})),_this2.cachedModule[modulename]=oneLevelFields;case 8:case"end":return _context2.stop()}}),_callee2)})))()},serializeConditions:function(){var _this3=this,criteria=this.criteria,advancedFields=this.advancedFields;if(!(0,validation/* isEmpty */.xb)(criteria)){var conditions=criteria.conditions,pattern=criteria.pattern,arr=[],_loop=function(){var _conditions$key=conditions[key],operatorId=_conditions$key.operatorId,criteriaValue=_conditions$key.criteriaValue,parentFieldName=_conditions$key.fieldName,prevOperator=_conditions$key.prevOperator;if(35===operatorId){parentFieldName=_this3.getFieldName(parentFieldName);var newCondition,_conditions=criteriaValue.conditions,condition=_conditions["1"],oneLevelId=condition.operatorId,oneLevelValue=condition.value,childFieldName=condition.fieldName,conditionObj={fieldName:[parentFieldName,childFieldName],operatorId:oneLevelId,value:oneLevelValue,prevOperator:prevOperator};if([50,61].includes(oneLevelId)){var _this3$specialDateOpe=_this3.specialDateOperatorValue(condition),_this3$specialDateOpe2=dist_slicedToArray(_this3$specialDateOpe,2),conditionValue=_this3$specialDateOpe2[0],_operatorId=_this3$specialDateOpe2[1];newCondition={condition:dist_objectSpread2(dist_objectSpread2({},conditionObj),{},{operatorId:_operatorId,value:conditionValue}),id:(0,esm_browser_v4/* default */.Z)()}}else newCondition={condition:conditionObj,id:(0,esm_browser_v4/* default */.Z)()};arr.push(newCondition);var parentField=advancedFields.find((function(field){return field.name===parentFieldName})),_ref10=parentField||{},lookupModule=_ref10.lookupModule,_ref11=lookupModule||{},name=_ref11.name;_this3.oneLevelModules=[].concat(dist_toConsumableArray(_this3.oneLevelModules),[name])}else{var _newCondition,_conditionObj=conditions[key],fieldName=_conditionObj.fieldName;if(null!==fieldName&&(_conditionObj.fieldName="".concat(fieldName,"#parent")),[50,61].includes(operatorId)){var _this3$specialDateOpe3=_this3.specialDateOperatorValue(_conditionObj),_this3$specialDateOpe4=dist_slicedToArray(_this3$specialDateOpe3,2),_conditionValue=_this3$specialDateOpe4[0],_operatorId2=_this3$specialDateOpe4[1];_newCondition={condition:dist_objectSpread2(dist_objectSpread2({},_conditionObj),{},{operatorId:_operatorId2,value:_conditionValue}),id:(0,esm_browser_v4/* default */.Z)()}}else _newCondition={condition:_conditionObj,id:(0,esm_browser_v4/* default */.Z)()};arr.push(_newCondition)}};for(var key in conditions)_loop();this.serializedConditions=arr,this.serializedPattern=this.injectSpace(pattern)}},isOneLevelPresent:function(fieldName){var advancedFields=this.advancedFields,lookupModuleFieldList=this.lookupModuleFieldList,fieldObj=advancedFields.find((function(field){return field.name===fieldName})),_ref12=fieldObj||{},dataType=_ref12.dataType,lookupModule=_ref12.lookupModule;if("LOOKUP"===dataType){var _ref13=lookupModule||{},name=_ref13.name;return!(0,validation/* isEmpty */.xb)(lookupModuleFieldList[name])}return!1},specialDateOperatorValue:function(condition){var conditionValue,operatorId=condition.operatorId,value=condition.value,operatorid="";return 61===operatorId&&"7"===value||61===operatorId&&"2"===value||50===operatorId?(operatorid="".concat(operatorId,"-").concat(value),conditionValue=null):(operatorid=operatorId,conditionValue=value),[conditionValue,operatorid]},fetchAccount:function(){var _this4=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee3(){var _yield$API$get,data,error,_ref14,account;return dist_regeneratorRuntime().wrap((function(_context3){while(1)switch(_context3.prev=_context3.next){case 0:return _context3.next=2,api/* API */.bl.get("/v2/fetchAccount");case 2:_yield$API$get=_context3.sent,data=_yield$API$get.data,error=_yield$API$get.error,error?_this4.$message.error(error||"Error Occured"):(_ref14=data||{},account=_ref14.account,_this4.account=account);case 6:case"end":return _context3.stop()}}),_callee3)})))()},loadOperators:function(){var _this5=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee4(){var url,_yield$API$get2,data,error,_ref15,_ref15$message,message,_ref16,operators;return dist_regeneratorRuntime().wrap((function(_context4){while(1)switch(_context4.prev=_context4.next){case 0:return url="v2/filter/advanced/operators",_context4.next=3,api/* API */.bl.get(url);case 3:_yield$API$get2=_context4.sent,data=_yield$API$get2.data,error=_yield$API$get2.error,error?(_ref15=error||{},_ref15$message=_ref15.message,message=void 0===_ref15$message?"Error Occured":_ref15$message,_this5.$message.error(message)):(_ref16=data||{},operators=_ref16.operators,(0,validation/* isEmpty */.xb)(operators)||(_this5.operators=operators));case 7:case"end":return _context4.stop()}}),_callee4)})))()},loadFields:function(){var _this6=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee5(){var moduleName,isOneLevelEnabled,url,oneLevelUrl,response,_response,advancedFields,oneLevelFields,advancedData,advancedFieldsError,advancedFieldsList,oneLevelFieldsData,oneLevelFieldsError,_ref17,_ref17$message,message,fields,lookupModuleFields,moduleFields;return dist_regeneratorRuntime().wrap((function(_context5){while(1)switch(_context5.prev=_context5.next){case 0:if(!isFunction(_this6.getFields)){_context5.next=12;break}return _context5.prev=1,_context5.next=4,_this6.getFields();case 4:_this6.fields=_context5.sent,_this6.advancedFields=_this6.fields,_context5.next=11;break;case 8:_context5.prev=8,_context5.t0=_context5["catch"](1),_this6.$message.error(_context5.t0.message||"Error occured");case 11:return _context5.abrupt("return");case 12:return moduleName=_this6.moduleName,isOneLevelEnabled=_this6.isOneLevelEnabled,url="/v2/filter/advanced/fields/".concat(moduleName),oneLevelUrl="/v2/lookupFields/list?moduleName=".concat(moduleName,"&OneLevelFields=true"),_context5.next=17,Promise.all([api/* API */.bl.get(url),api/* API */.bl.get(oneLevelUrl)]);case 17:response=_context5.sent,_response=dist_slicedToArray(response,2),advancedFields=_response[0],oneLevelFields=_response[1],advancedData=advancedFields.data,advancedFieldsError=advancedFields.error,advancedFieldsList=advancedData.fields,_this6.advancedFields=advancedFieldsList.map((function(field){return dist_objectSpread2(dist_objectSpread2({},field),{},{multiple:dist_isLookupPopupField(field)||dist_isLookupTypeField(field)})})),oneLevelFieldsData=oneLevelFields.data,oneLevelFieldsError=oneLevelFields.error,advancedFieldsError||oneLevelFieldsError?(_ref17=advancedFieldsError||oneLevelFieldsError||{},_ref17$message=_ref17.message,message=void 0===_ref17$message?"Error occured":_ref17$message,_this6.$message.error(message)):(fields=oneLevelFieldsData.fields,lookupModuleFields=fields.lookupModuleFields,moduleFields=fields.moduleFields,_this6.lookupModuleFieldList=lookupModuleFields,_this6.fields=moduleFields.reduce((function(acc,field){var children,_ref18=field||{},lookupModuleName=_ref18.lookupModuleName,dataType=_ref18.dataType,name=_ref18.name;return!isOneLevelEnabled||(0,validation/* isEmpty */.xb)(lookupModuleName)||(0,validation/* isEmpty */.xb)(lookupModuleFields[lookupModuleName])||"MULTI_LOOKUP"===dataType||"siteId"===name?[].concat(dist_toConsumableArray(acc),[dist_objectSpread2(dist_objectSpread2({},field),{},{name:"".concat(field.name,"#parent"),multiple:dist_isLookupPopupField(field)||dist_isLookupTypeField(field)})]):(children=lookupModuleFields[lookupModuleName].filter((function(field){return"MULTI_LOOKUP"!==field.dataType&&"siteId"!==field.name})),[].concat(dist_toConsumableArray(acc),[dist_objectSpread2(dist_objectSpread2({},field),{},{name:"".concat(field.name,"#parent"),multiple:dist_isLookupPopupField(field)||dist_isLookupTypeField(field)}),dist_objectSpread2(dist_objectSpread2({},field),{},{children:children})]))}),[]));case 24:case"end":return _context5.stop()}}),_callee5,null,[[1,8]])})))()},constructCriteria:function(){var value=this.value;if((0,validation/* isEmpty */.xb)(value)){
// if the criteria is empty, then we're configurig a dummy criteria
var defaultCriteriaObj=cloneDeep(defaultCriteria);delete defaultCriteriaObj.prevOperator,this.criteria={conditions:{1:defaultCriteria},pattern:"1"}}else this.constructOperatorFromPattern()},onPatternOperatorChange:function(_ref19){var _this7=this,key=_ref19.key,value=_ref19.value,_ref20=this||{},criteria=_ref20.criteria,disabled=_ref20.disabled;if(disabled)this.$message.error("Criteria is disabled.");else{var _ref21=criteria||{},conditions=_ref21.conditions;(0,validation/* isEmpty */.xb)(conditions[key])||(conditions[key]=dist_objectSpread2(dist_objectSpread2({},conditions[key]),{},{prevOperator:value})),this.criteria=dist_objectSpread2(dist_objectSpread2({},criteria),{},{conditions:conditions}),this.$nextTick((function(){_this7.constructPatternFromOperator()}))}},constructPatternFromOperator:function(){var _ref22=this||{},criteria=_ref22.criteria,patternOperatorList=_ref22.patternOperatorList,conditionsKeys=_ref22.conditionsKeys,_ref23=criteria||{},pattern=_ref23.pattern,modifiedPatternArr=pattern.split(/and|or/g),finalPattern="";modifiedPatternArr.forEach((function(pattern){var currentKey=pattern.match(/\d+/g)[0],index=conditionsKeys.findIndex((function(el){return el==currentKey})),targetOperator=patternOperatorList[currentKey];(0,validation/* isEmpty */.xb)(targetOperator)||0===index?finalPattern+=pattern:finalPattern+="".concat(targetOperator?"and":"or").concat(pattern)})),this.criteria=dist_objectSpread2(dist_objectSpread2({},criteria),{},{pattern:finalPattern})},constructOperatorFromPattern:function(){var _this8=this,_ref24=this||{},criteria=_ref24.criteria,_ref25=criteria||{},pattern=_ref25.pattern,conditions=_ref25.conditions;if(!(0,validation/* isEmpty */.xb)(pattern)){var operatorList=pattern.match(/and|or/g),serializedConditions={};Object.entries(conditions).forEach((function(_ref26){var _ref27=dist_slicedToArray(_ref26,2),key=_ref27[0],value=_ref27[1];1!=key?(serializedConditions[key]=dist_objectSpread2(dist_objectSpread2({},value),{},{prevOperator:"and"===operatorList[key-2]}),(0,validation/* isEmpty */.xb)(_this8.serializedConditions)||(_this8.serializedConditions[key-1].condition.prevOperator="and"===operatorList[key-2])):serializedConditions[key]=value}));var spacedPattern=this.injectSpace(pattern);this.criteria={conditions:serializedConditions,pattern:spacedPattern}}},toggleInputReadonly:function(_ref28){var readonly=_ref28.readonly,resetPattern=_ref28.resetPattern,_ref29=this||{},criteria=_ref29.criteria,previousPattern=_ref29.previousPattern,disabled=_ref29.disabled;if(disabled)this.$message.error("Crtieria is disabled");else{this.isPatternReadonly=readonly;var _ref30=criteria||{},pattern=_ref30.pattern;readonly?document.getElementById("criteria-pattern-input-field").setAttribute("readonly",""):(document.getElementById("criteria-pattern-input-field").removeAttribute("readonly"),this.previousPattern=pattern,this.$refs["criteria-pattern-input"].focus()),resetPattern&&(this.criteria=dist_objectSpread2(dist_objectSpread2({},criteria),{},{pattern:previousPattern}),this.previousPattern="")}},savePattern:function(){var _ref31=this||{},isValidPattern=_ref31.isValidPattern,validationMessage=_ref31.validationMessage;isValidPattern?(this.constructOperatorFromPattern(),this.toggleInputReadonly({readonly:!0}),this.$message.success("Pattern edited successfully")):(this.$message.error(validationMessage),this.$refs["criteria-pattern-input"].focus())},addCriteria:function(){var criteria=this.criteria,isPatternReadonly=this.isPatternReadonly,disabled=this.disabled;if(disabled)this.$message.error("Criteria is disabled");else if(isPatternReadonly){var pattern=criteria.pattern,newCondition=cloneDeep(defaultCriteria),condition={condition:newCondition,id:(0,esm_browser_v4/* default */.Z)()};this.serializedConditions.push(condition),this.serializedPattern="( ".concat(pattern," and ").concat(this.serializedConditions.length," )"),this.setCriteria()}else this.$message.warning("Please save your pattern to edit the criteria")},getFieldName:function(fieldName){var multilookupRegex=/^([a-z]+_?.+\.)/,multilookupArray=!(0,validation/* isArray */.kJ)(fieldName)&&(null===fieldName||void 0===fieldName?void 0:fieldName.match(multilookupRegex))||[];if(!(0,validation/* isEmpty */.xb)(multilookupArray)){var splitArray=fieldName.split(".");return splitArray[1]}return fieldName},setCriteria:function(){var serializedConditions=this.serializedConditions,criteria=this.criteria,serializedPattern=this.serializedPattern,conditionsLength=this.conditionsLength,conditions={};for(var i in serializedConditions){var condition=dist_objectSpread2({},serializedConditions[i].condition),_condition=condition,operatorId=_condition.operatorId,fieldName=_condition.fieldName,prevOperator=_condition.prevOperator;
// checking for next_7_days,next_2_days and last_2_weeks
if("string"===typeof operatorId){var _operatorId$split=operatorId.split("-"),_operatorId$split2=dist_slicedToArray(_operatorId$split,2),id=_operatorId$split2[0],defaultValue=_operatorId$split2[1];["50","61"].includes(id)&&(condition=dist_objectSpread2(dist_objectSpread2({},condition),{},{operatorId:Number(id),value:defaultValue}))}var index=parseInt(i)+1;if(!(0,validation/* isEmpty */.xb)(fieldName)&&(0,validation/* isArray */.kJ)(fieldName)){var parentCondition={fieldName:fieldName[0],operatorId:35,prevOperator:prevOperator,criteriaValue:{conditions:{1:dist_objectSpread2(dist_objectSpread2({},condition),{},{fieldName:fieldName[1]})},pattern:"( 1 )"}};conditions[index]=parentCondition}else{var actualFieldName=this.checkParentLookup(fieldName);(0,validation/* isEmpty */.xb)(actualFieldName)?conditions[index]=condition:conditions[index]=dist_objectSpread2(dist_objectSpread2({},condition),{},{fieldName:actualFieldName})}}1===conditionsLength&&(serializedPattern="( 1 )");var modifiedCriteria=dist_objectSpread2(dist_objectSpread2({},criteria),{},{conditions:conditions,pattern:serializedPattern});if(1===conditionsLength){var _conditions$=conditions[1],_fieldName=_conditions$.fieldName,_operatorId3=_conditions$.operatorId,value=_conditions$.value;(0,validation/* isEmpty */.xb)(_fieldName)&&(0,validation/* isEmpty */.xb)(_operatorId3)&&(0,validation/* isEmpty */.xb)(value)&&(modifiedCriteria=null)}this.$set(this,"criteria",modifiedCriteria)},checkParentLookup:function(fieldName){if((0,validation/* isEmpty */.xb)(fieldName))return"";var regex=/#parent$/,lookupNameArray=fieldName.match(regex);if(!(0,validation/* isEmpty */.xb)(lookupNameArray)){var actualFieldName=fieldName.split("#");return actualFieldName[0]}return""},updateCondition:function(props){var _ref32=props||{},condition=_ref32.condition,index=_ref32.index,key=parseInt(index)-1;this.serializedConditions[key].condition=condition,this.setCriteria()},checkNullCondition:function(condition){var fieldName=condition.fieldName,operatorId=condition.operatorId,value=condition.value,isEmptyCondition=(0,validation/* isEmpty */.xb)(fieldName)&&(0,validation/* isEmpty */.xb)(operatorId)&&(0,validation/* isEmpty */.xb)(value);return isEmptyCondition},deleteCriteria:function(index){var isPatternReadonly=this.isPatternReadonly,disabled=this.disabled;disabled?this.$message.error("Criteria is disabled"):isPatternReadonly?(this.deleteKeyFromPattern(index),this.serializedConditions=this.serializedConditions.filter((function(item,itemIndex){return itemIndex!=index})),this.setCriteria()):this.$message.warning("Please save your pattern to edit the criteria")},deleteKeyFromPattern:function(index){var _ref33=this||{},criteria=_ref33.criteria,_ref34=criteria||{},pattern=_ref34.pattern,sanitizedPattern=this.sanitizePattern(pattern),stackString=sanitizedPattern.split(" "),stack=this.generatePatternStack(stackString),keyIndex=stack.findIndex((function(el){return el=="".concat(index+1)}));"and"===stack[keyIndex-1]||"or"===stack[keyIndex-1]?stack[keyIndex-1]="":"and"!==stack[keyIndex+1]&&"or"!==stack[keyIndex+1]||(stack[keyIndex+1]=""),stack[keyIndex]="";var newPattern=stack.join(" "),serializedPattern=this.serializePattern(newPattern);serializedPattern=this.sanitizePattern(serializedPattern);var validPattern=this.removeInvalidOperators(serializedPattern);this.serializedPattern=this.injectSpace(validPattern)},serializePattern:function(pattern){var conditionsKeys=this.conditionsKeys,str=pattern.split(" "),stack=this.generatePatternStack(str),index=0;for(var i in stack){var key=parseInt(stack[i]);isNaN(key)||(stack[i]=parseInt(conditionsKeys[index]),index++)}return stack.join(" ")},validate:function(){var criteria=this.criteria;if((0,validation/* isEmpty */.xb)(criteria))return!0;var _ref35=this||{},isValidPattern=_ref35.isValidPattern,isPatternReadonly=_ref35.isPatternReadonly,isCriteriaValid=isPatternReadonly&&isValidPattern;return isCriteriaValid?this.validateCriteria():isCriteriaValid},validateCriteria:function(){var serializedConditions=this.serializedConditions;if(1===serializedConditions.length){var condition=serializedConditions[0].condition,fieldName=condition.fieldName,operatorId=condition.operatorId,value=condition.value,isNullCriteria=(0,validation/* isEmpty */.xb)(fieldName)&&(0,validation/* isEmpty */.xb)(operatorId)&&(0,validation/* isEmpty */.xb)(value);if(isNullCriteria)return this.criteria=null,!0}for(var _i=0,_Object$entries=Object.entries(serializedConditions);_i<_Object$entries.length;_i++){var _Object$entries$_i=dist_slicedToArray(_Object$entries[_i],2),index=_Object$entries$_i[0],_condition2=_Object$entries$_i[1],_ref36=_condition2||{},conditionObj=_ref36.condition,_fieldName2=conditionObj.fieldName,_operatorId4=conditionObj.operatorId,_value=conditionObj.value,valueNeeded=conditionObj.valueNeeded,isValueEmpty=valueNeeded&&!_value,hasSpecialOperatorId=Object.values(specialOperator).includes(_operatorId4),isNotEmptySpecial=null;if(_operatorId4&&hasSpecialOperatorId){var valueArray=Array.isArray(_value)?_value:null===_value||void 0===_value?void 0:_value.split(",");isNotEmptySpecial=null===valueArray||void 0===valueArray?void 0:valueArray.every((function(val){return!(0,validation/* isEmpty */.xb)(val)})),isValueEmpty=!0,isNotEmptySpecial&&(isValueEmpty=!1)}var isConditionEmpty=(0,validation/* isEmpty */.xb)(_fieldName2)||(0,validation/* isEmpty */.xb)(_operatorId4)||isValueEmpty;if(isConditionEmpty){var key=parseInt(index)+1;return this.$message.warning("Condition at row ".concat(key," cannot be empty")),!1}}return!0}}};
/* script */
const dist_vue_script_$4=dist_script$4;
/* template */var dist_vue_render_$4=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _vm.isLoading?_c("div",{staticClass:"flex"},[_c("FieldLoader",{staticClass:"mr-2",attrs:{isLoading:_vm.isLoading}}),_vm._v(" "),_c("FieldLoader",{staticClass:"mr-2",attrs:{isLoading:_vm.isLoading}}),_vm._v(" "),_c("FieldLoader",{staticClass:"mr-2",attrs:{isLoading:_vm.isLoading}}),_vm._v(" "),_c("FieldLoader",{attrs:{isLoading:_vm.showValueType&&_vm.isLoading}})],1):_c("div",{staticClass:"flex flex-col self-center criteria-builder m-2"},[_vm._l(_vm.serializedConditions,(function(ref,index){var condition=ref.condition,id=ref.id;return _c("div",{key:id},[index+1!=1?_c("OperatorToggle",{key:index+1,class:_vm.disabled?"cursor-not-allowed\t":"",attrs:{conditionKey:index+1,isPatternReadonly:_vm.isPatternReadonly},on:{change:_vm.onPatternOperatorChange},model:{value:condition.prevOperator,callback:function($$v){_vm.$set(condition,"prevOperator",$$v)},expression:"condition.prevOperator"}}):_vm._e(),_vm._v(" "),_c("div",{staticClass:"condition"},[_c("Condition",{key:"condition-"+id,ref:"condition-"+id,refInFor:!0,attrs:{condition:condition,operators:_vm.operators,index:Number(index+1),fields:_vm.filteredFields,account:_vm.account,filterOperators:_vm.filterOperators,isLastIndex:_vm.conditionsLength==index+1,showValueType:_vm.showValueType,customValues:_vm.customValues,disabled:_vm.disabled,conditionsKeys:_vm.conditionsKeys,cachedModule:_vm.cachedModule,advancedFields:_vm.advancedFields},on:{updateCondition:_vm.updateCondition}}),_vm._v(" "),_vm.ifCriteriaExists?_c("div",{staticClass:"add-remove-container"},[_vm.conditionsLength==index+1?_c("span",{staticClass:"flex items-center",on:{click:_vm.addCriteria}},[_c("AddIcon",{staticClass:"delete-icon ml-3 cursor-pointer",class:_vm.disabled?"cursor-not-allowed\t":""})],1):_vm._e(),_vm._v(" "),_c("span",{staticClass:"flex items-center",on:{click:function(){return _vm.deleteCriteria(index)}}},[_vm.showRemoveIcon?_c("RemoveIcon",{staticClass:"delete-icon ml-2 cursor-pointer",class:_vm.disabled?"cursor-not-allowed\t":""}):_vm._e()],1)]):_vm._e()],1)],1)})),_vm._v(" "),_vm.conditionsLength>2?_c("div",{staticClass:"mt-5"},[_c("div",{staticClass:"flex mb-2 leading-5"},[_vm._v("Match Pattern")]),_vm._v(" "),_c("div",{staticClass:"flex flex-nowrap"},[_c("Input",{ref:"criteria-pattern-input",staticClass:"w-full",class:[_vm.isPatternReadonly?"pattern-readonly-input":""],attrs:{id:"criteria-pattern-input-field",readonly:"",disabled:_vm.disabled},model:{value:_vm.criteria.pattern,callback:function($$v){_vm.$set(_vm.criteria,"pattern",$$v)},expression:"criteria.pattern"}}),_vm._v(" "),_c("div",{staticClass:"pattern-actions-container"},[_vm.isPatternReadonly?_c("div",{staticClass:"pattern-actions save-pattern-action",class:_vm.disabled?"cursor-not-allowed\t":"cursor-pointer",on:{click:function($event){return _vm.toggleInputReadonly({readonly:!1})}}},[_c("i",{staticClass:"el-icon-edit"})]):[_c("div",{staticClass:"pattern-actions save-pattern-action cursor-pointer",on:{click:_vm.savePattern}},[_vm._v("\n            Save\n          ")]),_vm._v(" "),_c("div",{staticClass:"pattern-actions cancel-pattern-action cursor-pointer",on:{click:function($event){return _vm.toggleInputReadonly({readonly:!0,resetPattern:!0})}}},[_vm._v("\n            Cancel\n          ")])]],2)],1)]):_vm._e()],2)},dist_vue_staticRenderFns_$4=[];
/* style */
const dist_vue_inject_styles_$4=function(inject){inject&&(inject("data-v-6e9c8de2_0",{source:".criteria-builder input:not([disabled=disabled])+span.el-input__suffix i.el-input__icon.el-icon-arrow-down,.criteria-builder input:not([disabled=disabled])+span.el-input__suffix i.el-select__caret.el-input__icon.el-icon-arrow-up{color:#000!important;font-weight:bolder!important}.criteria-builder input::placeholder{color:#000}.criteria-builder input[disabled=disabled]+span.el-input__suffix i.el-select__caret.el-input__icon.el-icon-arrow-up{color:#c0c4cc!important}.criteria-builder input+span.el-input__suffix i.el-select__caret.el-input__icon.el-icon-arrow-up{font-size:14px!important}.criteria-builder .el-radio__label{font-size:14px}.criteria-builder .el-radio__inner{width:20px;height:20px}.criteria-builder .el-radio__input.is-checked .el-radio__inner{border-color:#39b2c2;background:#39b2c2}.criteria-builder .el-radio__input .el-radio__inner:hover{border-color:#39b2c2}.criteria-builder .el-radio__input.is-checked+.el-radio__label{color:#39b2c2}.criteria-builder .condition{display:flex;align-items:center}.criteria-builder .condition .add-remove-container{display:flex;width:55px}.criteria-builder .pattern-error{display:flex;justify-content:start;margin-top:8px;font-size:13px;color:#f56c6c}.criteria-builder .f-ui-forms .f-ui-lookup-container .el-select__tags-text,.criteria-builder .f-ui-forms .f-ui-select-tag .el-select__tags-text{max-width:55px!important}",map:void 0,media:void 0}),inject("data-v-6e9c8de2_1",{source:".pattern-actions-container[data-v-6e9c8de2]{width:150px;display:flex;align-items:center;padding-left:5px}.pattern-actions[data-v-6e9c8de2]{padding:5px 8px;line-height:15px}.save-pattern-action[data-v-6e9c8de2]{color:#39b2c2}.cancel-pattern-action[data-v-6e9c8de2]{color:#888}",map:void 0,media:void 0}))},dist_vue_scope_id_$4="data-v-6e9c8de2",dist_vue_module_identifier_$4=void 0,dist_vue_is_functional_template_$4=!1,dist_vue_component_$4=dist_normalizeComponent({render:dist_vue_render_$4,staticRenderFns:dist_vue_staticRenderFns_$4},dist_vue_inject_styles_$4,dist_vue_script_$4,dist_vue_scope_id_$4,dist_vue_is_functional_template_$4,dist_vue_module_identifier_$4,!1,dist_createInjector,void 0,void 0);
/* scoped */var dist_script$3={props:["field","operators","value","account"],components:{Select:__vue_component__$r,ConditionValue:dist_vue_component_$b},computed:{conditionValue:{get:function(){var _this$value;return null===(_this$value=this.value)||void 0===_this$value?void 0:_this$value.value},set:function(newVal){var inputValue=this.value,updatedObj=dist_objectSpread2(dist_objectSpread2({},inputValue),{},{value:newVal});this.$emit("input",updatedObj),this.$emit("updateFilter",updatedObj)}},errorText:function(){var field=this.field,_ref=field||{},displayName=_ref.displayName;return"Please input ".concat(displayName)},disableValueContainer:function(){var operatorId=this.operatorId,fieldOperators=this.fieldOperators,disabled=this.disabled,canDisable=!0,selectedOperator=fieldOperators.find((function(operator){return operator.id===operatorId}));return(0,validation/* isEmpty */.xb)(selectedOperator)||(canDisable=!(selectedOperator||{}).valueNeeded),canDisable||disabled},currentOperatorObj:function(){var _ref2=this||{},fieldOperators=_ref2.fieldOperators,operatorId=_ref2.operatorId,currentOperator=fieldOperators.find((function(operator){return operator.id===operatorId}));return currentOperator},isSpecialOperator:function(){var _ref3=this||{},currentOperatorObj=_ref3.currentOperatorObj,_ref4=currentOperatorObj||{},specialOperator=_ref4.specialOperator;return specialOperator},fieldOperators:function(){var operators=this.operators,filterOperators=this.filterOperators,field=this.field,_ref5=field||{},dataType=_ref5.dataType,fieldOperators=_ref5.operators;if(!(0,validation/* isEmpty */.xb)(operators)){var list=operators[dataType]||[];(0,validation/* isEmpty */.xb)(fieldOperators)||(list=list.concat(fieldOperators));var finalList=list.map((function(operator){var operatorId=operator.operatorId,defaultValue=operator.defaultValue,unqiueClientId=operatorId;return(0,validation/* isEmpty */.xb)(defaultValue)||(unqiueClientId="".concat(operatorId,"-").concat(defaultValue)),dist_objectSpread2(dist_objectSpread2({},operator),{},{id:unqiueClientId})}));
// filter out special operator if special ui is not present
return finalList=finalList.filter((function(operator){var _ref6=operator||{},specialOperator=_ref6.specialOperator,operatorId=_ref6.id,_ref7=field||{},displayType=_ref7.displayType,specialHashPropName="".concat(displayType,"_").concat(operatorId);return!specialOperator||!(0,validation/* isEmpty */.xb)(dist_SPECIAL_OPERATOR_HASH[specialHashPropName])})),!(0,validation/* isEmpty */.xb)(filterOperators)&&(0,validation/* isFunction */.mf)(filterOperators)&&(finalList=(finalList||[]).filter((function(operator){return filterOperators(operator,field)}))),finalList}return[]}},watch:{
// if an operator is selected which does not need value, then value container is disabled
disableValueContainer:function(value){value&&(this.conditionValue=null)},operatorId:function(newVal){var value=this.value,updatedObj=dist_objectSpread2(dist_objectSpread2({},value),{},{operatorId:newVal});this.$emit("input",updatedObj),this.$emit("updateFilter",updatedObj)}},created:function(){this.init()},data:function(){return{operatorId:null}},methods:{init:function(){var value=this.value,fieldOperators=this.fieldOperators,_ref8=value||{},operatorId=_ref8.operatorId,conditionValue=_ref8.value;
// if the operator id is empty, then we need to set default operator
if((0,validation/* isEmpty */.xb)(operatorId)){var defaultOperatorId=null;if(!(0,validation/* isEmpty */.xb)(fieldOperators)){var defaultOperator=fieldOperators.find((function(operator){return operator.defaultSelection}))||{};defaultOperatorId=defaultOperator.operatorId}this.operatorId=defaultOperatorId}else this.operatorId=operatorId;if(!(0,validation/* isEmpty */.xb)(conditionValue)){this.conditionValue=conditionValue;var selectedOperator=(this.fieldOperators||[]).find((function(operator){return(null===operator||void 0===operator?void 0:operator.operatorId)===operatorId})),_ref9=selectedOperator||{},lookupModule=_ref9.lookupModule;this.$set(this.field,"operatorLookupModule",lookupModule)}var clonedCondition=cloneDeep(value);this.filterObj=clonedCondition},resetValue:function(){var ref=this.$refs.conditionValue;(0,validation/* isEmpty */.xb)(ref)||ref.resetValue()},validate:function(){var disableValueContainer=this.disableValueContainer,conditionValue=this.conditionValue,field=this.field,isValid=!0;return disableValueContainer||(isValid=!(0,validation/* isEmpty */.xb)(conditionValue)),this.$emit("isError",{field:field,isError:!isValid}),isValid},handleOperatorChange:function(value){var field=this.field,fieldOperators=this.fieldOperators,selectedOperator=fieldOperators.find((function(operator){return operator.operatorId===value}));
// Special handling for role is operator, have to fetch roles list in right side
if(!(0,validation/* isEmpty */.xb)(selectedOperator)){
// Have to reset selected items array in field, if field is lookup type
(dist_isLookupTypeField(field)||dist_isLookupPopupField(field))&&this.$set(field,"selectedItems",[]),this.resetValue();var _ref10=selectedOperator||{},_ref10$lookupModule=_ref10.lookupModule,lookupModule=void 0===_ref10$lookupModule?{}:_ref10$lookupModule;this.$set(field,"operatorLookupModule",lookupModule)}this.conditionValue=null}}};
/* script */const dist_vue_script_$3=dist_script$3;
/* template */var dist_vue_render_$3=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"operator-value-container"},[_c("div",{staticClass:"criteria-operator-container"},[_c("Select",{staticClass:"width-full",attrs:{options:_vm.fieldOperators,labelName:"displayName",valueName:"id",filterable:!0,disabled:!1},on:{clear:_vm.resetValue,change:_vm.handleOperatorChange},model:{value:_vm.operatorId,callback:function($$v){_vm.operatorId=$$v},expression:"operatorId"}})],1),_vm._v(" "),_c("div",{staticClass:"value-container",staticStyle:{display:"flex","flex-direction":"column"}},[_c("ConditionValue",{ref:"conditionValue",attrs:{account:_vm.account,field:_vm.field,operatorObj:_vm.currentOperatorObj,isSpecialOperator:_vm.isSpecialOperator,disableValueContainer:_vm.disableValueContainer},model:{value:_vm.conditionValue,callback:function($$v){_vm.conditionValue=$$v},expression:"conditionValue"}}),_vm._v(" "),_vm.field.isError?_c("div",{staticClass:"err-txt"},[_vm._v(_vm._s(_vm.errorText))]):_vm._e()],1)])},dist_vue_staticRenderFns_$3=[];
/* style */
const dist_vue_inject_styles_$3=function(inject){inject&&inject("data-v-b112a114_0",{source:".operator-value-container[data-v-b112a114]{display:flex;flex-wrap:nowrap}.operator-value-container .criteria-operator-container[data-v-b112a114]{flex:0 0 35%}.operator-value-container .value-container[data-v-b112a114]{flex-grow:.8}.operator-value-container .value-container .err-txt[data-v-b112a114]{color:#f56c6c;font-size:12px;line-height:1;margin-top:4px;padding-left:8px}",map:void 0,media:void 0})},dist_vue_scope_id_$3="data-v-b112a114",dist_vue_module_identifier_$3=void 0,dist_vue_is_functional_template_$3=!1,dist_vue_component_$3=dist_normalizeComponent({render:dist_vue_render_$3,staticRenderFns:dist_vue_staticRenderFns_$3},dist_vue_inject_styles_$3,dist_vue_script_$3,dist_vue_scope_id_$3,dist_vue_is_functional_template_$3,dist_vue_module_identifier_$3,!1,dist_createInjector,void 0,void 0);
/* scoped */
var dist_script$2={name:"spinner",props:["show","size","colour"],computed:{spinnerSize:function(){return this.size?this.size+"px":"50px"},strokeColor:function(){return this.colour?this.colour:"#fd4b92"}}};
/* script */const dist_vue_script_$2=dist_script$2;
/* template */var dist_vue_render_$2=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("transition",[_c("svg",{directives:[{name:"show",rawName:"v-show",value:_vm.show,expression:"show"}],staticClass:"spinner",class:{show:_vm.show},attrs:{width:_vm.spinnerSize,height:_vm.spinnerSize,viewBox:"0 0 44 44"}},[_c("circle",{staticClass:"path",style:{stroke:_vm.strokeColor},attrs:{fill:"none","stroke-width":"4","stroke-linecap":"round",cx:"22",cy:"22",r:"20"}})])])},dist_vue_staticRenderFns_$2=[];
/* style */
const dist_vue_inject_styles_$2=function(inject){inject&&inject("data-v-688b5254_0",{source:".spinner[data-v-688b5254]{transition:opacity 50ms ease;animation:rotator-data-v-688b5254 1.4s linear infinite;animation-play-state:paused}.spinner.show[data-v-688b5254]{animation-play-state:running}.spinner.v-enter[data-v-688b5254],.spinner.v-leave-active[data-v-688b5254]{opacity:0}.spinner.v-enter-active[data-v-688b5254],.spinner.v-leave[data-v-688b5254]{opacity:1}.spinner .path[data-v-688b5254]{stroke-dasharray:126;stroke-dashoffset:0;transform-origin:center;animation:dash-data-v-688b5254 1.4s ease-in-out infinite}@-moz-keyframes rotator-data-v-688b5254{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-webkit-keyframes rotator-data-v-688b5254{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-o-keyframes rotator-data-v-688b5254{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@keyframes rotator-data-v-688b5254{0%{transform:scale(.5) rotate(0)}100%{transform:scale(.5) rotate(270deg)}}@-moz-keyframes dash-data-v-688b5254{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@-webkit-keyframes dash-data-v-688b5254{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@-o-keyframes dash-data-v-688b5254{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}@keyframes dash-data-v-688b5254{0%{stroke-dashoffset:126}50%{stroke-dashoffset:63;transform:rotate(135deg)}100%{stroke-dashoffset:126;transform:rotate(450deg)}}",map:void 0,media:void 0})},dist_vue_scope_id_$2="data-v-688b5254",dist_vue_module_identifier_$2=void 0,dist_vue_is_functional_template_$2=!1,dist_vue_component_$2=dist_normalizeComponent({render:dist_vue_render_$2,staticRenderFns:dist_vue_staticRenderFns_$2},dist_vue_inject_styles_$2,dist_vue_script_$2,dist_vue_scope_id_$2,dist_vue_is_functional_template_$2,dist_vue_module_identifier_$2,!1,dist_createInjector,void 0,void 0);
/* scoped */var dist_script$1={components:{Checkbox:element_ui_common.Checkbox,OperatorValues:dist_vue_component_$3,Input:element_ui_common.Input,Button:element_ui_common.Button,Spinner:dist_vue_component_$2,FieldIcons:dist_vue_component_$9,FieldLoader:dist_vue_component_$a,Tooltip:element_ui_common.Tooltip},props:["moduleName","searchParam","onSave","hideQuery","filterList","showAdvWizard"],data:function(){return{operators:[],fields:[],account:null,searchFilter:{},search:"",searchtext:"",filterObj:{},oneLevelFields:[],filtersFields:[],loading:!1,cachedModules:{},advancedFields:[],toggleEvent:!1,isLookupInView:!1,debounceSearch:function(){}}},created:function(){var _this=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee(){return dist_regeneratorRuntime().wrap((function(_context){while(1)switch(_context.prev=_context.next){case 0:return _context.next=2,_this.init();case 2:case"end":return _context.stop()}}),_callee)})))()},computed:{isOneLevelPresent:function(){var oneLevelFilteredFields=this.oneLevelFilteredFields;return oneLevelFilteredFields.length>0},floatingTooltip:function(){var isLookupInView=this.isLookupInView;return isLookupInView?"Go to 'filter by fields'":"Go to 'filter by lookup'"},floatingIcon:function(){var isLookupInView=this.isLookupInView;return isLookupInView?"el-icon-arrow-up":"el-icon-arrow-down"},simpleFilteredFields:function(){var searchtext=this.searchtext,simpleFields=this.simpleFields;return(0,validation/* isEmpty */.xb)(searchtext)?simpleFields:simpleFields.filter((function(field){var displayName=field.displayName,lowerCasedText=searchtext.toLowerCase(),canShow=displayName.toLowerCase().includes(lowerCasedText);return canShow}))},oneLevelFilteredFields:function(){var _this2=this,searchtext=this.searchtext,_this$oneLevelFields=this.oneLevelFields,oneLevelFields=void 0===_this$oneLevelFields?[]:_this$oneLevelFields;if((0,validation/* isEmpty */.xb)(searchtext))return oneLevelFields;var filteredFields=oneLevelFields.filter((function(field){var displayName=field.displayName,lowerCasedText=searchtext.toLowerCase(),canShow=displayName.toLowerCase().includes(lowerCasedText);return canShow})),childFilters=oneLevelFields.map((function(field){var children=field.children;return children=children.filter((function(field){var displayName=field.displayName,lowerCasedText=searchtext.toLowerCase(),canShow=displayName.toLowerCase().includes(lowerCasedText);return canShow})),dist_objectSpread2(dist_objectSpread2({},field),{},{children:children,canShowChildren:!_this2.toggleEvent||!field.toggled||field.canShowChildren})})).filter((function(field){return!(0,validation/* isEmpty */.xb)(field.children)}));return uniqBy([].concat(dist_toConsumableArray(childFilters),dist_toConsumableArray(filteredFields)),"name")},appliedFilters:function(){var searchParam=this.searchParam,hideQuery=this.hideQuery,filterList=this.filterList;return hideQuery?filterList:(0,validation/* isEmpty */.xb)(searchParam)?null:JSON.parse(searchParam)},oneLevelFilters:function(){for(var appliedFilters=this.appliedFilters,_ref=appliedFilters||{},_ref$oneLevelLookup=_ref.oneLevelLookup,oneLevelLookup=void 0===_ref$oneLevelLookup?{}:_ref$oneLevelLookup,obj={},_i=0,_Object$keys=Object.keys(oneLevelLookup);_i<_Object$keys.length;_i++){var key=_Object$keys[_i],fieldFilterArray=oneLevelLookup[key];obj[key]={};var _step,_iterator=_createForOfIteratorHelper(fieldFilterArray);try{for(_iterator.s();!(_step=_iterator.n()).done;){var childField=_step.value;obj[key]=dist_objectSpread2(dist_objectSpread2({},obj[key]),childField.criteriaValue)}}catch(err){_iterator.e(err)}finally{_iterator.f()}}return obj},simpleFields:function(){var advancedFields=this.advancedFields;return advancedFields||[]}},watch:{moduleName:function(){this.init()},filterList:function(){this.constructFilters()},showAdvWizard:function(){this.constructFilters()}},mounted:function(){var _this3=this,observer=new window.IntersectionObserver((function(_ref2){var _ref3=dist_slicedToArray(_ref2,1),entry=_ref3[0];entry.isIntersecting?_this3.isLookupInView=!0:_this3.isLookupInView=!1}),{root:null,threshold:.1});observer.observe(this.$refs["lookup-fields"])},methods:{init:function(){var _this4=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee2(){var _yield$Promise$all,_yield$Promise$all2,account,operators;return dist_regeneratorRuntime().wrap((function(_context2){while(1)switch(_context2.prev=_context2.next){case 0:return _this4.loading=!0,_context2.next=3,Promise.all([_this4.loadFields(),_this4.fetchAccount(),_this4.loadOperators()]);case 3:_yield$Promise$all=_context2.sent,_yield$Promise$all2=dist_slicedToArray(_yield$Promise$all,3),account=_yield$Promise$all2[1],operators=_yield$Promise$all2[2],_this4.account=account,_this4.operators=operators,_this4.constructFilters(),_this4.loading=!1,_this4.debounceSearch=debounce((function(text){_this4.searchtext=text,_this4.toggleEvent=!1}),300);case 12:case"end":return _context2.stop()}}),_callee2)})))()},fetchAccount:function(){var _this5=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee3(){var _yield$API$get,data,error,_ref4,account;return dist_regeneratorRuntime().wrap((function(_context3){while(1)switch(_context3.prev=_context3.next){case 0:return _context3.next=2,api/* API */.bl.get("/v2/fetchAccount");case 2:if(_yield$API$get=_context3.sent,data=_yield$API$get.data,error=_yield$API$get.error,!error){_context3.next=9;break}_this5.$message.error(error||"Error Occured"),_context3.next=11;break;case 9:return _ref4=data||{},account=_ref4.account,_context3.abrupt("return",account);case 11:case"end":return _context3.stop()}}),_callee3)})))()},loadOperators:function(){var _this6=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee4(){var url,_yield$API$get2,data,error,_ref5,_ref5$message,message,_ref6,operators;return dist_regeneratorRuntime().wrap((function(_context4){while(1)switch(_context4.prev=_context4.next){case 0:return url="v2/filter/advanced/operators",_context4.next=3,api/* API */.bl.get(url);case 3:if(_yield$API$get2=_context4.sent,data=_yield$API$get2.data,error=_yield$API$get2.error,!error){_context4.next=11;break}_ref5=error||{},_ref5$message=_ref5.message,message=void 0===_ref5$message?"Error Occured":_ref5$message,_this6.$message.error(message),_context4.next=14;break;case 11:if(_ref6=data||{},operators=_ref6.operators,(0,validation/* isEmpty */.xb)(operators)){_context4.next=14;break}return _context4.abrupt("return",operators);case 14:case"end":return _context4.stop()}}),_callee4)})))()},loadFields:function(){var _this7=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee5(){var moduleName,url,oneLevelUrl,_yield$Promise$all3,_yield$Promise$all4,advancedFieldResponse,oneLevelFieldResponse,advancedFieldData,advancedFieldError,oneLevelFieldData,oneLevelFieldError,_ref7,_ref7$message,message,_ref8,advancedFields,_ref9,fields,_ref10,lookupModuleFields,moduleFields,oneLevelFields;return dist_regeneratorRuntime().wrap((function(_context5){while(1)switch(_context5.prev=_context5.next){case 0:return moduleName=_this7.moduleName,url="/v2/fields/advancedFilter/".concat(moduleName),oneLevelUrl="/v2/fields/advancedFilter/drilldown/".concat(moduleName,"?OneLevelFields=true"),_context5.next=5,Promise.all([api/* API */.bl.get(url),api/* API */.bl.get(oneLevelUrl)]);case 5:_yield$Promise$all3=_context5.sent,_yield$Promise$all4=dist_slicedToArray(_yield$Promise$all3,2),advancedFieldResponse=_yield$Promise$all4[0],oneLevelFieldResponse=_yield$Promise$all4[1],advancedFieldData=advancedFieldResponse.data,advancedFieldError=advancedFieldResponse.error,oneLevelFieldData=oneLevelFieldResponse.data,oneLevelFieldError=oneLevelFieldResponse.error,advancedFieldError||oneLevelFieldError?(_ref7=oneLevelFieldError||advancedFieldError||{},_ref7$message=_ref7.message,message=void 0===_ref7$message?"Error occured":_ref7$message,_this7.$message.error(message)):(_ref8=advancedFieldData||{},advancedFields=_ref8.fields,_this7.advancedFields=advancedFields.map((function(field){return dist_isLookupPopupField(field)||dist_isLookupTypeField(field)?dist_objectSpread2(dist_objectSpread2({},field),{},{multiple:!0,canShowCriteria:!1}):field})),_ref9=oneLevelFieldData||{},fields=_ref9.fields,_ref10=fields||{},lookupModuleFields=_ref10.lookupModuleFields,moduleFields=_ref10.moduleFields,oneLevelFields=moduleFields.filter((function(field){return!(0,validation/* isEmpty */.xb)(field.lookupModuleName)&&"siteId"!==field.name&&"MULTI_LOOKUP"!==field.dataType})),oneLevelFields=oneLevelFields.map((function(field){var lookupModuleName=field.lookupModuleName,children=cloneDeep(lookupModuleFields[lookupModuleName]);return(0,validation/* isEmpty */.xb)(children)?dist_objectSpread2(dist_objectSpread2({},field),{},{children:[]}):(children=children.filter((function(field){return"MULTI_LOOKUP"!==field.dataType})),dist_objectSpread2(dist_objectSpread2({},field),{},{children:children,canShowChildren:!1}))})),oneLevelFields=oneLevelFields.filter((function(field){return!(0,validation/* isEmpty */.xb)(field.children)})),_this7.oneLevelFields=oneLevelFields);case 12:case"end":return _context5.stop()}}),_callee5)})))()},scrollToLookup:function(){var $refs=this.$refs;$refs["lookup-fields"].scrollIntoView({behaviour:"smooth"})},toggleIcon:function(field){return field.canShowChildren?"down":"right"},getIcon:function(field){var dataType=field.dataType,displayType=field.displayType,children=field.children;if(!(0,validation/* isEmpty */.xb)(children))return"one-level-lookup";if("DURATION"===displayType)return"duration";var MAP={LOOKUP:"lookup",MULTI_LOOKUP:"lookup",BIG_STRING:"string",DATE:"date",DATE_TIME:"time-date",STRING:"string",NUMBER:"numbers",ID:"numbers",DECIMAL:"decimal",BOOLEAN:"select",ENUM:"picklist",MULTI_ENUM:"multi-select",URL_FIELD:"http",SYSTEM_ENUM:"picklist",CURRENCY_FIELD:"currency",MULTI_CURRENCY_FIELD:"multi_currency"},iconName=MAP[dataType];return(0,validation/* isEmpty */.xb)(iconName)?"":iconName},setError:function(prop){var field=prop.field,isError=prop.isError,parentField=prop.parentField,oneLevelFields=this.oneLevelFields;(0,validation/* isEmpty */.xb)(parentField)?this.advancedFields=this.advancedFields.map((function(searchField){return searchField.name===field.name?dist_objectSpread2(dist_objectSpread2({},searchField),{},{isError:isError}):searchField})):(oneLevelFields=oneLevelFields.map((function(oneLevelField){if(oneLevelField.name===parentField.name){var children=parentField.children.map((function(childField){return childField.name===field.name?dist_objectSpread2(dist_objectSpread2({},childField),{},{isError:isError}):childField}));return dist_objectSpread2(dist_objectSpread2({},oneLevelField),{},{children:children})}return oneLevelField})),this.$set(this,"oneLevelFields",oneLevelFields))},removeAddFilter:function(prop){var _this8=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee6(){var oneLevelFields,advancedFields,searchtext,checked,field,parentField,_prop$oneLevel,oneLevel;return dist_regeneratorRuntime().wrap((function(_context6){while(1)switch(_context6.prev=_context6.next){case 0:if(oneLevelFields=_this8.oneLevelFields,advancedFields=_this8.advancedFields,searchtext=_this8.searchtext,checked=prop.checked,field=prop.field,parentField=prop.parentField,_prop$oneLevel=prop.oneLevel,oneLevel=void 0===_prop$oneLevel||_prop$oneLevel,checked||((0,validation/* isEmpty */.xb)(parentField)?(advancedFields=advancedFields.map((function(fieldObj){return fieldObj.name===field.name?dist_objectSpread2(dist_objectSpread2({},fieldObj),{},{filterObj:{}}):fieldObj})),_this8.$set(_this8,"advancedFields",advancedFields)):(oneLevelFields=oneLevelFields.map((function(oneLevelfield){if(parentField.name===oneLevelfield.name){var children=oneLevelfield.children.map((function(childField){return childField.name===field.name?dist_objectSpread2(dist_objectSpread2({},field),{},{filterObj:{}}):childField}));return dist_objectSpread2(dist_objectSpread2({},oneLevelfield),{},{children:children})}return oneLevelfield})),_this8.$set(_this8,"oneLevelFields",oneLevelFields))),!checked||(0,validation/* isEmpty */.xb)(searchtext)||!oneLevel){_context6.next=6;break}return _context6.next=6,_this8.toggleChildren(parentField,field,!0);case 6:case"end":return _context6.stop()}}),_callee6)})))()},toggleChildren:function(field,childField){var _arguments=arguments,_this9=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee7(){var searchEnabled,oneLevelFields,cachedModules,canShowChildren,_field$filterAppended,filterAppended,oneLevelFieldsFilled,toggledValue,children,lookupModuleName,url,_yield$API$get3,data,error,fields,index,updatedOneLevelFields;return dist_regeneratorRuntime().wrap((function(_context7){while(1)switch(_context7.prev=_context7.next){case 0:if(searchEnabled=_arguments.length>2&&void 0!==_arguments[2]&&_arguments[2],oneLevelFields=_this9.oneLevelFields,cachedModules=_this9.cachedModules,canShowChildren=field.canShowChildren,_field$filterAppended=field.filterAppended,filterAppended=void 0!==_field$filterAppended&&_field$filterAppended,oneLevelFieldsFilled=field.oneLevelFieldsFilled,toggledValue=!canShowChildren,!toggledValue&&!searchEnabled||filterAppended||oneLevelFieldsFilled){_context7.next=26;break}if(lookupModuleName=field.lookupModuleName,(0,validation/* isEmpty */.xb)(cachedModules[lookupModuleName])){_context7.next=11;break}children=cloneDeep(cachedModules[lookupModuleName]),(0,validation/* isEmpty */.xb)(childField)||(children=children.map((function(fieldObj){return fieldObj.name===childField.name&&(fieldObj.canShowCriteria=!0),fieldObj}))),_context7.next=24;break;case 11:return url="/v2/fields/advancedFilter/".concat(lookupModuleName),_context7.next=14,api/* API */.bl.get(url);case 14:if(_yield$API$get3=_context7.sent,data=_yield$API$get3.data,error=_yield$API$get3.error,!error){_context7.next=20;break}return _this9.$message.error(error),_context7.abrupt("return");case 20:fields=data.fields,children=(fields||[]).filter((function(field){return"MULTI_LOOKUP"!==field.dataType})),_this9.cachedModules[lookupModuleName]=cloneDeep(children),children=(children||[]).map((function(field){return dist_objectSpread2(dist_objectSpread2({},field),{},{multiple:dist_isLookupTypeField(field)||dist_isLookupPopupField(field),canShowCriteria:!(0,validation/* isEmpty */.xb)(childField)&&(null===childField||void 0===childField?void 0:childField.name)===field.name,filterObj:(0,validation/* isEmpty */.xb)(childField)||(null===childField||void 0===childField?void 0:childField.name)!==field.name?{}:childField.filterObj})}));case 24:index=oneLevelFields.findIndex((function(fieldObj){return fieldObj.name===field.name})),_this9.$set(_this9.oneLevelFields,index,dist_objectSpread2(dist_objectSpread2({},field),{},{children:children,oneLevelFieldsFilled:!0}));case 26:updatedOneLevelFields=oneLevelFields.map((function(oneLevelField){return searchEnabled&&!(0,validation/* isEmpty */.xb)(childField)&&(toggledValue=!0),oneLevelField.name===field.name?dist_objectSpread2(dist_objectSpread2({},oneLevelField),{},{canShowChildren:toggledValue,toggled:!0}):oneLevelField})),_this9.$set(_this9,"oneLevelFields",updatedOneLevelFields),_this9.toggleEvent=!0;case 29:case"end":return _context7.stop()}}),_callee7)})))()},constructFilters:function(){var _this10=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee8(){var appliedFilters,advancedFields,oneLevelFields,oneLevelFilters,_ref11,oneLevelLookup,oneLevelModules,response,index,moduleName,data;return dist_regeneratorRuntime().wrap((function(_context8){while(1)switch(_context8.prev=_context8.next){case 0:if(appliedFilters=_this10.appliedFilters,advancedFields=_this10.advancedFields,oneLevelFields=_this10.oneLevelFields,oneLevelFilters=_this10.oneLevelFilters,_ref11=appliedFilters||{},oneLevelLookup=_ref11.oneLevelLookup,(0,validation/* isEmpty */.xb)(oneLevelLookup)){_context8.next=9;break}return oneLevelModules=Object.keys(oneLevelLookup).map((function(oneLevelParentName){var fieldObj=advancedFields.find((function(fieldObj){return fieldObj.name==oneLevelParentName})),_ref12=fieldObj||{},lookupModule=_ref12.lookupModule,_ref13=lookupModule||{},name=_ref13.name;return name})),oneLevelModules=dist_toConsumableArray(new Set(oneLevelModules)),_context8.next=7,Promise.all(oneLevelModules.map((function(lookupModuleName){return api/* API */.bl.get("/v2/fields/advancedFilter/".concat(lookupModuleName))})));case 7:for(index in response=_context8.sent,response)moduleName=oneLevelModules[index],data=response[index].data,_this10.cachedModules[moduleName]=null===data||void 0===data?void 0:data.fields;case 9:_this10.$nextTick((function(){_this10.advancedFields=_this10.appendFiltersToField(appliedFilters,advancedFields)||[],_this10.oneLevelFields=_this10.appendFiltersToField(oneLevelFilters,oneLevelFields,!0)||[]}));case 10:case"end":return _context8.stop()}}),_callee8)})))()},appendFiltersToField:function(appliedFilters,fields,oneLevel){var _this11=this,updatedFields=[];return updatedFields=oneLevel?fields.map((function(field){var children=field.children,name=field.name,lookupModuleName=field.lookupModuleName;return(0,validation/* isEmpty */.xb)(appliedFilters[name])?field:(children=_this11.addFilterToFields(_this11.cachedModules[lookupModuleName.toLowerCase()]||[],appliedFilters[name]),dist_objectSpread2(dist_objectSpread2({},field),{},{children:children,canShowChildren:!0,filterAppended:!0}))})):this.addFilterToFields(fields,appliedFilters),updatedFields},addFilterToFields:function(fields,appliedFilters){var _this12=this;return fields.map((function(field){var clonedField=JSON.parse(JSON.stringify(field)),isMultiSupported=dist_isLookupField(field)||dist_isLookupPopupField(field)||dist_isMultiLookupField(field);
// Have to open multi support
if(isMultiSupported&&(
// To allow user to pick multiple values
clonedField.multiple=!0),(0,validation/* isEmpty */.xb)(appliedFilters))clonedField.canShowCriteria=!1,clonedField.filterObj={operatorId:null,value:null};else{var name=clonedField.name,filter=appliedFilters[name];if(clonedField.canShowCriteria=!1,(0,validation/* isEmpty */.xb)(filter))clonedField.filterObj={operatorId:null,value:null};else{if(clonedField.filterObj={},isMultiSupported){var _filter$value=filter.value,value=void 0===_filter$value?[]:_filter$value,placeHolderRegex=/\$\{[A-Z]+_[A-Z]+\}/,filterValues=(value||[]).map((function(val){var placeHolderArray=String(value).match(placeHolderRegex);return(0,validation/* isEmpty */.xb)(placeHolderArray)?Number(val):val}));clonedField.filterObj=dist_objectSpread2(dist_objectSpread2({},filter),{},{value:filterValues})}else{var filterValue,dataType=field.dataType;"STRING"===dataType||"BOOLEAN"===dataType?filterValue=null!==filter&&void 0!==filter&&filter.value?filter.value.toString():null:"SYSTEM_ENUM"===dataType||"ENUM"===dataType||"MULTI_ENUM"===dataType?(filterValue=null===filter||void 0===filter?void 0:filter.value,filterValue=filterValue.map((function(val){return Number(val)}))):filterValue=null===filter||void 0===filter?void 0:filter.value,clonedField.filterObj=dist_objectSpread2(dist_objectSpread2({},filter),{},{value:filterValue});var _ref14=filter||{},operatorId=_ref14.operatorId;if([50,61].includes(operatorId)){var _this12$specialDateOp=_this12.specialDateOperatorValue(filter),_this12$specialDateOp2=dist_slicedToArray(_this12$specialDateOp,2),conditionValue=_this12$specialDateOp2[0],_operatorId=_this12$specialDateOp2[1];clonedField.filterObj={operatorId:_operatorId,value:conditionValue}}}clonedField.canShowCriteria=!0}}return clonedField}))},scollToPostion:function(){var $refs=this.$refs,isLookupInView=this.isLookupInView;isLookupInView?$refs["fields-header"].scrollIntoView({behaviour:"smooth"}):$refs["lookup-fields-header"].scrollIntoView({behaviour:"smooth"})},applyFilter:function(){var _this13=this,advancedFields=this.advancedFields,$refs=this.$refs,oneLevelFields=this.oneLevelFields,filters={},oneLevelFilters={},isNotValid=!1;advancedFields.forEach((function(field){var filterObj=field.filterObj,name=field.name,sanitizedObj=_this13.getFilter(filterObj);if(!(0,validation/* isEmpty */.xb)(filterObj)){var _ref15=filterObj||{},operatorId=_ref15.operatorId;if(!(0,validation/* isEmpty */.xb)(operatorId)){var specialSerialize=_this13.serializeSpecialDateOperatorValue(operatorId);specialSerialize&&(sanitizedObj=specialSerialize),filters=dist_objectSpread2(dist_objectSpread2({},filters),{},dist_defineProperty({},name,sanitizedObj))}}var _ref16=$refs["".concat(name)]||[],_ref17=dist_slicedToArray(_ref16,1),criteriaComp=_ref17[0];(0,validation/* isEmpty */.xb)(criteriaComp)||(isNotValid=!criteriaComp.validate()||isNotValid)})),oneLevelFields.forEach((function(parentField){var _parentField$children=parentField.children,children=void 0===_parentField$children?[]:_parentField$children,parentName=parentField.name,childFilters=[];children.forEach((function(childField){var name=childField.name,filterObj=childField.filterObj,sanitizedObj=_this13.getFilter(filterObj);if(!(0,validation/* isEmpty */.xb)(filterObj)){var _ref18=filterObj||{},operatorId=_ref18.operatorId;if(!(0,validation/* isEmpty */.xb)(operatorId)){var specialSerialize=_this13.serializeSpecialDateOperatorValue(operatorId);specialSerialize&&(sanitizedObj=specialSerialize),childFilters=[].concat(dist_toConsumableArray(childFilters),[{operatorId:35,criteriaValue:dist_defineProperty({},name,sanitizedObj)}])}}var _ref19=$refs["".concat(name,"-").concat(parentField.name)]||[],_ref20=dist_slicedToArray(_ref19,1),criteriaComp=_ref20[0];(0,validation/* isEmpty */.xb)(criteriaComp)||(isNotValid=!criteriaComp.validate()||isNotValid)})),(0,validation/* isEmpty */.xb)(childFilters)||(oneLevelFilters=dist_objectSpread2(dist_objectSpread2({},oneLevelFilters),{},dist_defineProperty({},parentName,childFilters)))})),filters=dist_objectSpread2(dist_objectSpread2({},filters),{},{oneLevelLookup:oneLevelFilters}),isNotValid||this.$emit("applyFilters",filters)},getFilter:function(filterObj){var sanitizedObj;if(!(0,validation/* isEmpty */.xb)(filterObj)){var filterValue,_filterObj$value=filterObj.value,value=void 0===_filterObj$value?{}:_filterObj$value;return(0,validation/* isEmpty */.xb)(value)?sanitizedObj=dist_objectSpread2({},filterObj):((0,validation/* isArray */.kJ)(value)?filterValue=value.map(String):("string"!==typeof value&&(value="".concat(value)),filterValue=[value]),sanitizedObj=dist_objectSpread2(dist_objectSpread2({},filterObj),{},{value:filterValue})),sanitizedObj}},specialDateOperatorValue:function(condition){var operatorId=condition.operatorId,value=condition.value;value=value[0];var conditionValue,operatorid="";return 61===operatorId&&"7"===value||61===operatorId&&"2"===value||50===operatorId?(operatorid="".concat(operatorId,"-").concat(value),conditionValue=null):(operatorid=operatorId,conditionValue=value),[conditionValue,operatorid]},serializeSpecialDateOperatorValue:function(operatorId){if("string"===typeof operatorId){var _operatorId$split=operatorId.split("-"),_operatorId$split2=dist_slicedToArray(_operatorId$split,2),id=_operatorId$split2[0],defaultValue=_operatorId$split2[1];if(["50","61"].includes(id))return{operatorId:Number(id),value:[defaultValue]}}}}};
/* script */const dist_vue_script_$1=dist_script$1;
/* template */var dist_vue_render_$1=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("div",{staticClass:"f-advanced-search"},[_c("div",{directives:[{name:"show",rawName:"v-show",value:_vm.loading,expression:"loading"}],staticClass:"loading-container"},[_c("Spinner",{attrs:{show:_vm.loading,size:60}})],1),_vm._v(" "),_c("div",{directives:[{name:"show",rawName:"v-show",value:!_vm.loading,expression:"!loading"}],staticClass:"f-advanced-search-container"},[_vm.isOneLevelPresent?_c("div",{staticClass:"floating-btn-container"},[_c("Tooltip",{staticClass:"item",attrs:{effect:"dark",content:_vm.floatingTooltip,placement:"top-start"}},[_c("Button",{attrs:{circle:"",icon:_vm.floatingIcon},on:{click:_vm.scollToPostion}})],1)],1):_vm._e(),_vm._v(" "),_c("div",{staticClass:"f-dialog-search-container"},[_c("Input",{staticClass:"f-search-box",attrs:{type:"search",autofocus:!1,placeholder:"Search Fields","prefix-icon":"el-icon-search"},on:{input:_vm.debounceSearch},model:{value:_vm.search,callback:function($$v){_vm.search=$$v},expression:"search"}})],1),_vm._v(" "),_c("div",{staticClass:"f-field-container"},[_c("div",{ref:"fields-header",staticClass:"field-header-section"},[_vm._v("\n        Filter by fields\n      ")]),_vm._v(" "),_vm._l(_vm.simpleFilteredFields,(function(field){return _c("div",{key:field.name+"-"+field.displayName,staticClass:"field-item"},[_c("div",{staticClass:"field-label"},[_c("Checkbox",{on:{change:function(checked){return _vm.removeAddFilter({checked:checked,field:field,oneLevel:!1})}},model:{value:field.canShowCriteria,callback:function($$v){_vm.$set(field,"canShowCriteria",$$v)},expression:"field.canShowCriteria"}},[_c("div",{staticClass:"name"},[_c("FieldIcons",{attrs:{src:_vm.getIcon(field)}}),_vm._v("\n              "+_vm._s(field.displayName)+"\n            ")],1)]),_vm._v(" "),field.canShowCriteria?_c("div",{staticClass:"field-search-criteria"},[_c("OperatorValues",{ref:""+field.name,refInFor:!0,attrs:{field:field,operators:_vm.operators,account:_vm.account},on:{isError:_vm.setError},model:{value:field.filterObj,callback:function($$v){_vm.$set(field,"filterObj",$$v)},expression:"field.filterObj"}})],1):_vm._e()],1)])})),_vm._v(" "),_c("div",{ref:"lookup-fields-header",staticClass:"lookup-header-section"},[_vm._v("\n        "+_vm._s(_vm.isOneLevelPresent?"Filter by Lookup":"")+"\n      ")]),_vm._v(" "),_c("div",{ref:"lookup-fields"},_vm._l(_vm.oneLevelFilteredFields,(function(field){return _c("div",{key:"oneLevel-"+field.name,staticClass:"field-item one-level-parent"},[_c("div",{staticStyle:{display:"flex",gap:"8px"}},[_c("div",{staticStyle:{cursor:"pointer"},on:{click:function(){return _vm.toggleChildren(field)}}},[_c("FieldIcons",{attrs:{src:field.canShowChildren||field.loading?"down":"right"}})],1),_vm._v(" "),_c("div",{staticClass:"one-level-name"},[_c("FieldIcons",{attrs:{src:"one-level-lookup"}}),_vm._v(" "+_vm._s(field.displayName)+"\n            ")],1)]),_vm._v(" "),field.canShowChildren?[_c("div",{staticClass:"one-level-child-item"},_vm._l(field.children,(function(childField){return _c("div",{key:childField.name+"-"+field.name,staticClass:"field-item one-level-field-item"},[_c("div",{staticClass:"field-label"},[_c("Checkbox",{on:{change:function(checked){return _vm.removeAddFilter({checked:checked,field:childField,parentField:field,oneLevel:!0})}},model:{value:childField.canShowCriteria,callback:function($$v){_vm.$set(childField,"canShowCriteria",$$v)},expression:"childField.canShowCriteria"}},[_c("div",{staticClass:"name"},[_c("FieldIcons",{attrs:{src:_vm.getIcon(childField)}}),_vm._v("\n                      "+_vm._s(childField.displayName)+"\n                    ")],1)]),_vm._v(" "),childField.canShowCriteria?_c("div",{staticClass:"field-search-criteria"},[field.loading?[_c("div",{staticStyle:{width:"100%","text-align":"left"}},[_c("FieldLoader",{staticStyle:{height:"20px",width:"60%","border-radius":"8px"},attrs:{isLoading:!0}}),_vm._v(" "),_c("FieldLoader",{staticStyle:{height:"20px",width:"60%","border-radius":"8px"},attrs:{isLoading:!0}})],1)]:_c("OperatorValues",{ref:childField.name+"-"+field.name,refInFor:!0,attrs:{field:childField,operators:_vm.operators,account:_vm.account},on:{isError:function(prop){return _vm.setError(Object.assign({},prop,{parentField:field}))}},model:{value:childField.filterObj,callback:function($$v){_vm.$set(childField,"filterObj",$$v)},expression:"childField.filterObj"}})],2):_vm._e()],1)])})),0)]:_vm._e()],2)})),0)],2),_vm._v(" "),_c("div",{staticClass:"btn-container"},[_c("Button",{staticClass:"form-btn f13 bold secondary text-center text-uppercase",on:{click:function($event){return _vm.$emit("closeDialog")}}},[_vm._v("Cancel")]),_vm._v(" "),_c("Button",{staticClass:"form-btn f13 bold primary m0 text-center text-uppercase",attrs:{type:"primary"},on:{click:function($event){return _vm.applyFilter()}}},[_vm._v("\n        Apply\n      ")])],1)])])},dist_vue_staticRenderFns_$1=[];
/* style */
const dist_vue_inject_styles_$1=function(inject){inject&&inject("data-v-85de73ea_0",{source:".loading-container{display:flex;justify-content:center;align-items:center;height:100px}.f-advanced-search{width:100%;height:100%}.f-advanced-search .floating-btn-container{position:absolute;right:16px;bottom:72px;z-index:20}.f-advanced-search .f-advanced-search-container{width:100%;height:100%;display:flex;flex-direction:column;flex-wrap:nowrap;position:relative}.f-advanced-search .f-advanced-search-container .lookup-header-section{font-size:14px;font-weight:bolder;text-align:left;margin:30px 0 18px 0;padding-left:20px;color:#ff3184}.f-advanced-search .f-advanced-search-container .field-header-section{font-size:14px;font-weight:bolder;text-align:left;margin:18px 0;padding-left:20px;color:#ff3184}.f-advanced-search .f-advanced-search-container .f-dialog-search-container{margin:8px 0}.f-advanced-search .f-advanced-search-container .f-dialog-search-container .f-search-box .el-input__inner{height:40px;border-radius:0;padding:15px 40px!important;font-size:14px;letter-spacing:.4px;color:#324056;text-overflow:ellipsis;white-space:nowrap;background:#fff!important;width:100%!important;outline:0;border:1px solid #dcdfe6}.f-advanced-search .f-advanced-search-container .f-dialog-search-container .f-search-box .el-input__prefix{left:15px}.f-advanced-search .f-advanced-search-container .f-dialog-search-container .f-search-box .el-input__prefix .el-input__icon{line-height:28px!important}.f-advanced-search .f-advanced-search-container .f-field-container{overflow:scroll;height:90%!important;margin:8px 0}.f-advanced-search .f-advanced-search-container .f-field-container .field-search-criteria{margin:8px 0}.f-advanced-search .f-advanced-search-container .f-field-container .field-item{margin-bottom:25px}.f-advanced-search .f-advanced-search-container .f-field-container .field-item .field-label{display:flex;margin-bottom:10px;flex-direction:column;padding-left:20px}.f-advanced-search .f-advanced-search-container .f-field-container .field-item .field-label .el-checkbox{display:flex;cursor:pointer!important;align-items:center}.f-advanced-search .f-advanced-search-container .f-field-container .field-item .field-label .name{padding-left:8px;font-size:14px;letter-spacing:.5px;color:#324056;display:flex;gap:8px}.f-advanced-search .f-advanced-search-container .f-field-container .field-item .field-label .name svg{align-self:center}.f-advanced-search .f-advanced-search-container .btn-container{display:flex}.f-advanced-search .f-advanced-search-container .btn-container .form-btn{flex:1 1 100%;padding-top:20px;padding-bottom:20px;border:none;letter-spacing:1.1px;text-align:center;text-transform:uppercase}.f-advanced-search .f-advanced-search-container .btn-container .form-btn.primary{background-color:#39b2c2;color:#fff;border-radius:0}.f-advanced-search .f-advanced-search-container .btn-container .form-btn.secondary{background-color:#f4f4f4;color:#8f8f8f}.f-advanced-search .f-advanced-search-container .one-level-name{font-size:14px;display:flex;gap:8px;padding-left:8px}.f-advanced-search .f-advanced-search-container .one-level-child-item{padding-left:28px;margin:20px 0}.f-advanced-search .f-advanced-search-container .one-level-child-item .one-level-field-item .field-label{padding-left:5px}.f-advanced-search .f-advanced-search-container .one-level-parent{padding-left:20px}",map:void 0,media:void 0})},dist_vue_scope_id_$1=void 0,dist_vue_module_identifier_$1=void 0,dist_vue_is_functional_template_$1=!1,dist_vue_component_$1=dist_normalizeComponent({render:dist_vue_render_$1,staticRenderFns:dist_vue_staticRenderFns_$1},dist_vue_inject_styles_$1,dist_vue_script_$1,dist_vue_scope_id_$1,dist_vue_is_functional_template_$1,dist_vue_module_identifier_$1,!1,dist_createInjector,void 0,void 0);
/* scoped */var dist_CloseIcon={render:function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _c("svg",{attrs:{viewBox:"0 0 512 512",xmlns:"http://www.w3.org/2000/svg"}},[_c("path",{attrs:{d:"M309.582 257.554l185.1-188.733c14.782-15.057 14.782-39.478 0-54.534-14.767-15.072-38.702-15.072-53.484 0l-185.1 188.733L70.98 14.286c-14.75-15.073-38.718-15.073-53.484 0-14.767 15.057-14.767 39.478 0 54.534l185.116 188.734L17.088 446.721c-14.782 15.072-14.782 39.478 0 54.534 7.383 7.544 17.066 11.308 26.75 11.308 9.667 0 19.35-3.764 26.735-11.308L256.097 312.09l185.101 188.735c7.4 7.528 17.067 11.308 26.75 11.308 9.668 0 19.351-3.78 26.735-11.308 14.782-15.057 14.782-39.462 0-54.534l-185.1-188.736z"}})])}},dist_script=dist_objectSpread2(dist_objectSpread2({components:{CloseIcon:dist_CloseIcon,Tooltip:element_ui_common.Tooltip,Dropdown:element_ui_common.Dropdown,DropdownMenu:element_ui_common.DropdownMenu,DropdownItem:element_ui_common.DropdownItem},props:["moduleName","searchParam","filters","hideQuery","hideSaveAs"],computed:{checkDropDownExists:function(){var dropDownTags=this.dropDownTags;return!(0,validation/* isEmpty */.xb)(dropDownTags)},showTags:function(){var tagsArr=this.tagsArr;return!(0,validation/* isEmpty */.xb)(tagsArr)},firstThreeTags:function(){var tagsArr=this.tagsArr;return tagsArr.slice(0,3)},dropDownTags:function(){var tagsArr=this.tagsArr;return tagsArr.slice(3)},appliedFilters:function(){var searchParam=this.searchParam,hideQuery=this.hideQuery,filters=this.filters;return hideQuery?filters:(0,validation/* isEmpty */.xb)(searchParam)?null:JSON.parse(searchParam)}},watch:{appliedFilters:function(val){this.constructTags(val)}},data:function(){return{tagsArr:[],fields:[],account:null,operatorsList:[],advancedFields:[],oneLevelFields:[],cachedModule:{}}},created:function(){var _this=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee(){return dist_regeneratorRuntime().wrap((function(_context){while(1)switch(_context.prev=_context.next){case 0:_this.init();case 1:case"end":return _context.stop()}}),_callee)})))()},methods:{init:function(){var _this2=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee2(){var _yield$Promise$all,_yield$Promise$all2,fields,account,operators;return dist_regeneratorRuntime().wrap((function(_context2){while(1)switch(_context2.prev=_context2.next){case 0:return _context2.next=2,Promise.all([_this2.loadFields(),_this2.fetchAccount(),_this2.loadOperators()]);case 2:_yield$Promise$all=_context2.sent,_yield$Promise$all2=dist_slicedToArray(_yield$Promise$all,3),fields=_yield$Promise$all2[0],account=_yield$Promise$all2[1],operators=_yield$Promise$all2[2],_this2.fields=fields,_this2.account=account,_this2.operatorsList=operators,_this2.constructTags(_this2.appliedFilters);case 11:case"end":return _context2.stop()}}),_callee2)})))()},loadFields:function(){var _this3=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee3(){var moduleName,url,oneLevelUrl,_yield$Promise$all3,_yield$Promise$all4,advancedFieldResponse,oneLevelFieldResponse,advancedFieldData,advancedFieldError,oneLevelFieldData,oneLevelFieldError,_ref,_ref$message,message,_ref2,advancedFields,_ref3,fields,_ref4,lookupModuleFields,moduleFields,oneLevelFields;return dist_regeneratorRuntime().wrap((function(_context3){while(1)switch(_context3.prev=_context3.next){case 0:return moduleName=_this3.moduleName,url="/v2/filter/advanced/fields/".concat(moduleName),oneLevelUrl="/v2/lookupFields/list?moduleName=".concat(moduleName,"&OneLevelFields=true"),_context3.next=5,Promise.all([api/* API */.bl.get(url),api/* API */.bl.get(oneLevelUrl)]);case 5:_yield$Promise$all3=_context3.sent,_yield$Promise$all4=dist_slicedToArray(_yield$Promise$all3,2),advancedFieldResponse=_yield$Promise$all4[0],oneLevelFieldResponse=_yield$Promise$all4[1],advancedFieldData=advancedFieldResponse.data,advancedFieldError=advancedFieldResponse.error,oneLevelFieldData=oneLevelFieldResponse.data,oneLevelFieldError=oneLevelFieldResponse.error,advancedFieldError||oneLevelFieldError?(_ref=oneLevelFieldError||advancedFieldError||{},_ref$message=_ref.message,message=void 0===_ref$message?"Error occured":_ref$message,_this3.$message.error(message)):(_ref2=advancedFieldData||{},advancedFields=_ref2.fields,_this3.advancedFields=advancedFields.map((function(field){return dist_isLookupPopupField(field)||dist_isLookupTypeField(field)?dist_objectSpread2(dist_objectSpread2({},field),{},{multiple:!0,canShowCriteria:!1}):field})),_ref3=oneLevelFieldData||{},fields=_ref3.fields,_ref4=fields||{},lookupModuleFields=_ref4.lookupModuleFields,moduleFields=_ref4.moduleFields,oneLevelFields=moduleFields.filter((function(field){return!(0,validation/* isEmpty */.xb)(field.lookupModuleName)})),oneLevelFields=oneLevelFields.map((function(field){var lookupModuleName=field.lookupModuleName,children=lookupModuleFields[lookupModuleName];return dist_objectSpread2(dist_objectSpread2({},field),{},{children:children,canShowChildren:!1})})),_this3.oneLevelFields=oneLevelFields);case 12:case"end":return _context3.stop()}}),_callee3)})))()},constructTags:function(filters){var _this4=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee4(){var operatorsList,showOnlyExisting,existingFilters,advancedFields,oneLevelFields,fields,copiedFilters,oneLevelFilters,oneLevelModules,simpleFilters,_oneLevelFilters,tagsArr,list,tags,labelMeta,lookupFieldsArr,_loop,_i,_Object$entries;return dist_regeneratorRuntime().wrap((function(_context5){while(1)switch(_context5.prev=_context5.next){case 0:if(operatorsList=_this4.operatorsList,showOnlyExisting=_this4.showOnlyExisting,existingFilters=_this4.existingFilters,advancedFields=_this4.advancedFields,oneLevelFields=_this4.oneLevelFields,fields=_this4.fields,(0,validation/* isEmpty */.xb)(advancedFields)&&(_this4.advancedFields=fields),!(0,validation/* isEmpty */.xb)(filters)){_context5.next=4;break}return _context5.abrupt("return");case 4:return copiedFilters=cloneDeep(filters),oneLevelFilters=copiedFilters["oneLevelLookup"],oneLevelFilters=Object.entries(oneLevelFilters).reduce((function(acc,curr){var _curr=dist_slicedToArray(curr,2),parentLookup=_curr[0],childFilters=_curr[1];return childFilters=childFilters.map((function(filters){var criteriaValue=filters.criteriaValue;return criteriaValue})),dist_objectSpread2(dist_objectSpread2({},acc),{},dist_defineProperty({},parentLookup,childFilters))}),{}),_this4.oneLevelFilters=oneLevelFilters,oneLevelModules=Object.keys(oneLevelFilters),oneLevelModules=dist_toConsumableArray(new Set(oneLevelModules)),_context5.next=12,_this4.populateOneLevelModules(oneLevelModules);case 12:if(delete copiedFilters["oneLevelLookup"],_this4.simpleFilters=copiedFilters,showOnlyExisting&&(simpleFilters=Object.entries(existingFilters).filter((function(obj){var _obj=dist_slicedToArray(obj,2),value=_obj[1];if(Array.isArray(value)){var child=value.filter((function(obj){return 35!=obj.operatorId}));return child.length>0}return 35!=value.operatorId})),simpleFilters=simpleFilters.map((function(obj){var _obj2=dist_slicedToArray(obj,2),key=_obj2[0],value=_obj2[1];if(Array.isArray(value)){var updatedValue=value.filter((function(filter){return 35!=filter.operatorId}));return[key,updatedValue[0]]}return obj})),_this4.simpleFilters=Object.fromEntries(simpleFilters),_oneLevelFilters=Object.entries(existingFilters).filter((function(obj){var _obj3=dist_slicedToArray(obj,2),value=_obj3[1];if(Array.isArray(value)){var child=value.filter((function(obj){return 35==obj.operatorId}));return child.length>0}return!1})),_oneLevelFilters=_oneLevelFilters.map((function(obj){var _obj4=dist_slicedToArray(obj,2),key=_obj4[0],value=_obj4[1];if(Array.isArray(value)){var updatedValue=value.filter((function(filter){return 35==filter.operatorId}));return updatedValue=updatedValue.map((function(obj){return obj.value})),[key,updatedValue]}return obj})),_this4.oneLevelFilters=Object.fromEntries(_oneLevelFilters)),tagsArr=[],(0,validation/* isEmpty */.xb)(_this4.simpleFilters)||(0,validation/* isEmpty */.xb)(operatorsList)||(0,validation/* isEmpty */.xb)(advancedFields)){_context5.next=24;break}if(list=_this4.getTagsList(_this4.simpleFilters,advancedFields),tags=list.tagsArr,labelMeta=list.labelMeta,lookupFieldsArr=list.lookupFieldsArr,tagsArr=tags,(0,validation/* isEmpty */.xb)(labelMeta)){_context5.next=24;break}return _context5.next=23,_this4.fetchLookupLabels({labelMeta:labelMeta,lookupFieldsArr:lookupFieldsArr,tagsArr:tagsArr,fields:_this4.advancedFields,appliedFilters:_this4.simpleFilters});case 23:tagsArr=_context5.sent;case 24:if((0,validation/* isEmpty */.xb)(_this4.oneLevelFilters)||(0,validation/* isEmpty */.xb)(operatorsList)||(0,validation/* isEmpty */.xb)(oneLevelFields)){_context5.next=32;break}_loop=dist_regeneratorRuntime().mark((function _loop(){var _Object$entries$_i,key,value,childFilters,_oneLevelFields$find,lookupModuleName,displayName,list,oneLevelChildTags,labelMeta,lookupFieldsArr,oneLevelTags;return dist_regeneratorRuntime().wrap((function(_context4){while(1)switch(_context4.prev=_context4.next){case 0:if(_Object$entries$_i=dist_slicedToArray(_Object$entries[_i],2),key=_Object$entries$_i[0],value=_Object$entries$_i[1],childFilters=value.reduce((function(acc,curr){var _Object$keys=Object.keys(curr),_Object$keys2=dist_slicedToArray(_Object$keys,1),firstKey=_Object$keys2[0];return dist_objectSpread2(dist_objectSpread2({},acc),{},dist_defineProperty({},firstKey,curr[firstKey]))}),{}),_oneLevelFields$find=oneLevelFields.find((function(field){return field.name===key})),lookupModuleName=_oneLevelFields$find.lookupModuleName,displayName=_oneLevelFields$find.displayName,list=_this4.getTagsList(childFilters,_this4.cachedModule[lookupModuleName]),oneLevelChildTags=list.tagsArr,labelMeta=list.labelMeta,lookupFieldsArr=list.lookupFieldsArr,(0,validation/* isEmpty */.xb)(labelMeta)){_context4.next=9;break}return _context4.next=8,_this4.fetchLookupLabels({labelMeta:labelMeta,lookupFieldsArr:lookupFieldsArr,tagsArr:oneLevelChildTags,fields:_this4.cachedModule[lookupModuleName],appliedFilters:childFilters});case 8:oneLevelChildTags=_context4.sent;case 9:oneLevelTags=oneLevelChildTags.map((function(tag){return dist_objectSpread2(dist_objectSpread2({},tag),{},{parentFieldName:key,parentDisplayName:displayName})})),tagsArr=[].concat(dist_toConsumableArray(tagsArr),dist_toConsumableArray(oneLevelTags));case 11:case"end":return _context4.stop()}}),_loop)})),_i=0,_Object$entries=Object.entries(_this4.oneLevelFilters);case 27:if(!(_i<_Object$entries.length)){_context5.next=32;break}return _context5.delegateYield(_loop(),"t0",29);case 29:_i++,_context5.next=27;break;case 32:_this4.$set(_this4,"tagsArr",tagsArr);case 33:case"end":return _context5.stop()}}),_callee4)})))()},populateOneLevelModules:function(oneLevelModules){var _this5=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee5(){var oneLevelFields,lookupModuleNames,response,i,lookupModuleName,data,_oneLevelFields;return dist_regeneratorRuntime().wrap((function(_context6){while(1)switch(_context6.prev=_context6.next){case 0:if(oneLevelFields=_this5.oneLevelFields,(0,validation/* isEmpty */.xb)(oneLevelModules)){_context6.next=7;break}return lookupModuleNames=oneLevelModules.map((function(fieldName){var field=oneLevelFields.find((function(field){return field.name===fieldName})),_ref5=field||{},lookupModuleName=_ref5.lookupModuleName;return lookupModuleName})),_context6.next=5,Promise.all(lookupModuleNames.map((function(lookupModuleName){return api/* API */.bl.get("/v2/filter/advanced/fields/".concat(lookupModuleName))})));case 5:for(i in response=_context6.sent,lookupModuleNames)lookupModuleName=lookupModuleNames[i],data=response[i].data,_oneLevelFields=data.fields,_this5.cachedModule[lookupModuleName]=_oneLevelFields;case 7:case"end":return _context6.stop()}}),_callee5)})))()},getTagsList:function(filters,fields){var _this6=this,tagsArr=[],labelMeta={},lookupFieldsArr=[];return Object.entries(filters).forEach((function(_ref6){var _ref7=dist_slicedToArray(_ref6,2),key=_ref7[0],value=_ref7[1],tagObj={};key=key.split("__")[0];var valueStr="",_ref8=value||{},valueArr=_ref8.value,operatorId=_ref8.operatorId,selectedField=_this6.getSelectedField({fields:fields,fieldName:key}),isLookupField$1=dist_isLookupField(selectedField)||dist_isLookupPopupField(selectedField)||dist_isMultiLookupField(selectedField),selectedOperator=_this6.getSelectedOperator({selectedField:selectedField,operatorId:operatorId});isLookupField$1&&(labelMeta=_this6.constructLabelMeta({selectedField:selectedField,lookupFieldsArr:lookupFieldsArr,labelMeta:labelMeta,valueArr:valueArr,selectedOperator:selectedOperator}));var operatorDisplayName=_this6.getOperatorDisplayName({operator:selectedOperator}),isDefaultOperator=!(0,validation/* isEmpty */.xb)(selectedOperator.defaultValue),fieldDisplayName=selectedField.displayName;isDefaultOperator||(valueStr=_this6.getValueString({valueArr:valueArr,selectedField:selectedField,isLookupField:isLookupField$1,operator:selectedOperator})),tagObj={fieldName:key,fieldDisplayName:fieldDisplayName,operatorDisplayName:operatorDisplayName,valueStr:valueStr},"drillDownPattern"!=key&&tagsArr.push(tagObj)})),{tagsArr:tagsArr,labelMeta:labelMeta,lookupFieldsArr:lookupFieldsArr}},fetchAccount:function(){var _this7=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee6(){var _yield$API$get,data,error,_ref9,account;return dist_regeneratorRuntime().wrap((function(_context7){while(1)switch(_context7.prev=_context7.next){case 0:return _context7.next=2,api/* API */.bl.get("/v2/fetchAccount");case 2:if(_yield$API$get=_context7.sent,data=_yield$API$get.data,error=_yield$API$get.error,!error){_context7.next=9;break}_this7.$message.error(error||"Error Occured"),_context7.next=11;break;case 9:return _ref9=data||{},account=_ref9.account,_context7.abrupt("return",account);case 11:case"end":return _context7.stop()}}),_callee6)})))()},loadOperators:function(){var _this8=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee7(){var url,_yield$API$get2,data,error,_ref10,_ref10$message,message,_ref11,operators;return dist_regeneratorRuntime().wrap((function(_context8){while(1)switch(_context8.prev=_context8.next){case 0:return url="v2/filter/advanced/operators",_context8.next=3,api/* API */.bl.get(url);case 3:if(_yield$API$get2=_context8.sent,data=_yield$API$get2.data,error=_yield$API$get2.error,!error){_context8.next=11;break}_ref10=error||{},_ref10$message=_ref10.message,message=void 0===_ref10$message?"Error Occured":_ref10$message,_this8.$message.error(message),_context8.next=14;break;case 11:if(_ref11=data||{},operators=_ref11.operators,(0,validation/* isEmpty */.xb)(operators)){_context8.next=14;break}return _context8.abrupt("return",operators);case 14:case"end":return _context8.stop()}}),_callee7)})))()},checkSize:function(tag){var string="".concat(tag.fieldDisplayName," ").concat(tag.operatorDisplayName," ").concat(tag.valueStr),font="13px Arial",canvas=document.createElement("canvas"),context=canvas.getContext("2d");context.font=font;var width=context.measureText(string+", ").width,formattedWidth=Math.ceil(width);return!(formattedWidth>250)},isValueArray:function(tag){var _ref12=tag||{},valueStr=_ref12.valueStr;return(0,validation/* isArray */.kJ)(valueStr)&&1!==valueStr.length},tagValue:function(tag){var _ref13=tag||{},valueStr=_ref13.valueStr;return(0,validation/* isArray */.kJ)(valueStr)?valueStr[0]:valueStr},getSelectedField:function(props){var fields=props.fields,fieldName=props.fieldName,selectedField=fields.find((function(field){return field.name===fieldName}));return selectedField||{}},getSelectedOperator:function(props){var operatorsList=this.operatorsList,operatorId=props.operatorId,selectedField=props.selectedField,_ref14=selectedField||{},dataType=_ref14.dataType,_ref14$operators=_ref14.operators,operators=void 0===_ref14$operators?[]:_ref14$operators,selectedOperator=operatorsList[dataType]||[];return(0,validation/* isEmpty */.xb)(operators)||(selectedOperator=selectedOperator.concat(operators)),selectedOperator.find((function(operator){return operator.operatorId===operatorId}))||{}},constructLabelMeta:function(props){var selectedField=props.selectedField,lookupFieldsArr=props.lookupFieldsArr,labelMeta=props.labelMeta,valueArr=props.valueArr,_props$selectedOperat=props.selectedOperator,selectedOperator=void 0===_props$selectedOperat?{}:_props$selectedOperat,name=this.getLookupModuleName({field:selectedField,operator:selectedOperator});
// Have to construct the label meta keys from lookup module name
// either from the operator or from the field
lookupFieldsArr.push(selectedField);var selectedModule=labelMeta[name];if((0,validation/* isEmpty */.xb)(selectedModule))labelMeta[name]=valueArr||[];else{var ids=labelMeta[name];labelMeta[name]=ids.concat(valueArr)}return labelMeta},getLookupModuleName:function(_ref15){var operator=_ref15.operator,field=_ref15.field,fieldLookupModule=dlv_umd(field,"lookupModule.name"),operatorLookupModule=dlv_umd(operator,"lookupModule.name");return(0,validation/* isEmpty */.xb)(operatorLookupModule)?fieldLookupModule:operatorLookupModule},getOperatorDisplayName:function(props){var operator=props.operator,_ref16=operator||{},tagDisplayName=_ref16.tagDisplayName,displayName=_ref16.displayName,operatorId=_ref16.operatorId;return[dist_dateTimeOperator[operatorId]].includes(displayName)?"is":tagDisplayName||displayName},getValueString:function(props){var _this9=this,valueArr=props.valueArr,selectedField=props.selectedField,isLookupField=props.isLookupField,operator=props.operator,operatorId=operator.operatorId,operatorDisplayName=operator.displayName;if(!(0,validation/* isEmpty */.xb)(valueArr)){var valueStr="",isPicklistOrBoolean=this.isPicklistOrBoolean(selectedField),isDateTypeField$1=dist_isDateTypeField(selectedField);if(isDateTypeField$1){if(valueStr=valueArr.reduce((function(acc,value,index){if([dist_dateTimeOperator[operatorId]].includes(operatorDisplayName)){if([106,107,84,85].includes(operatorId))if(84===operatorId){var currentMonth=_this9.MONTHS.find((function(month){month.value==value&&currentMonth.push(month.label)}));acc+="".concat(currentMonth)}else acc+=85===operatorId?"".concat(_this9.WEEK_DAYS[value]):value;else acc+="".concat(value).concat(1==value?"st":2==value?"nd":3==value?"rd":"th");return acc+=index!==valueArr.length-1?", ":" ",acc}var dateStr=_this9.formatDate(Number(value),!0,!1);return(0,validation/* isEmpty */.xb)(acc)?"".concat(dateStr):"".concat(acc,", ").concat(dateStr)}),""),[dist_dateTimeOperator[operatorId]].includes(operatorDisplayName))if([106,107].includes(operatorId)){var operatorIdKey={106:"Before",107:"After"};valueStr="".concat(operatorIdKey[operatorId]||""," ").concat(valueStr," days")}else[84,85].includes(operatorId)||(valueStr+="".concat(operatorDisplayName))}else if(isPicklistOrBoolean){var options=selectedField.options;(0,validation/* isEmpty */.xb)(options)||(valueStr=this.constructLabelString(valueArr,options))}else{if(isLookupField)return valueArr;valueStr=valueArr.reduce((function(acc,value){return(0,validation/* isEmpty */.xb)(acc)?"".concat(value):"".concat(acc,", ").concat(value)}),"")}return'"'.concat(valueStr,'"')}return""},getTagName:function(tag){var fieldDisplayName=tag.fieldDisplayName,parentDisplayName=tag.parentDisplayName;return(0,validation/* isEmpty */.xb)(parentDisplayName)?fieldDisplayName:"".concat(parentDisplayName,"/").concat(fieldDisplayName)},isPicklistOrBoolean:function(field){var _ref17=field||{},displayType=_ref17.displayType;return["SELECTBOX","DECISION_BOX"].includes(displayType)},constructLabelString:function(){var valueArr=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],options=arguments.length>1?arguments[1]:void 0,valueStr="";return(0,validation/* isArray */.kJ)(valueArr)&&(valueStr=valueArr.reduce((function(acc,value){var _ref18=options.find((function(option){return String(option.value)===value}))||{},_ref18$label=_ref18.label,label=void 0===_ref18$label?"Invalid":_ref18$label;return(0,validation/* isEmpty */.xb)(acc)?"".concat(label):"".concat(acc,", ").concat(label)}),"")),valueStr},fetchLookupLabels:function(props){var _this10=this;return dist_asyncToGenerator(dist_regeneratorRuntime().mark((function _callee8(){var labelMeta,lookupFieldsArr,tagsArr,fields,appliedFilters,_yield$API$post,data,error,_error$message,message,_ref19,label;return dist_regeneratorRuntime().wrap((function(_context9){while(1)switch(_context9.prev=_context9.next){case 0:return labelMeta=props.labelMeta,lookupFieldsArr=props.lookupFieldsArr,tagsArr=props.tagsArr,fields=props.fields,appliedFilters=props.appliedFilters,_context9.next=3,api/* API */.bl.post("/v2/picklist/label",{labelMeta:labelMeta});case 3:return _yield$API$post=_context9.sent,data=_yield$API$post.data,error=_yield$API$post.error,error?(_error$message=error.message,message=void 0===_error$message?"Error Occurred":_error$message,_this10.$message.error(message)):(_ref19=data||{},label=_ref19.label,tagsArr=tagsArr.map((function(tag){var fieldName=tag.fieldName,valueStr=tag.valueStr,lookupField=lookupFieldsArr.find((function(field){return field.name===fieldName}));if(lookupField){
// Have to get the value labels from lookup module name
// either from the operator or from the field
var field=_this10.getSelectedField({fields:fields,fieldName:fieldName}),currentFiter=appliedFilters[fieldName],operatorId=currentFiter.operatorId,operator=_this10.getSelectedOperator({selectedField:field,operatorId:operatorId}),name=_this10.getLookupModuleName({operator:operator,field:field}),moduleLabels=label[name]||[],labelStr=_this10.constructLabelString(valueStr,moduleLabels);tag.valueStr=labelStr}return tag}))),_context9.abrupt("return",tagsArr);case 8:case"end":return _context9.stop()}}),_callee8)})))()},formatDate:function(date,excludeTime,onlyTime){var dateformat=this.account.org.dateFormat,timeformat=this.account.org.timeFormat,timezone=this.account.org.timezone?this.account.org.timezone:"Etc/UTC";return onlyTime?moment_timezone(date).tz(timezone).format(timeformat):excludeTime?moment_timezone(date).tz(timezone).format(dateformat):moment_timezone(date).tz(timezone).format(dateformat+" "+timeformat)},clearFilter:function(tag){var appliedFilters=this.appliedFilters,hideQuery=this.hideQuery,filterList=this.filterList,filters=cloneDeep(appliedFilters)||{},isPivotPatternPresent=filters["drillDownPattern"];if(!(0,validation/* isEmpty */.xb)(isPivotPatternPresent)){delete filters["drillDownPattern"];for(var newFilter={},regex=/([-]+1)+$/,_i2=0,_Object$keys3=Object.keys(filters);_i2<_Object$keys3.length;_i2++){var key=_Object$keys3[_i2],isDuplicateField=String(key).match(regex);(0,validation/* isEmpty */.xb)(isDuplicateField)&&(newFilter[key]=filters[key])}filters=newFilter}var fieldName=tag.fieldName,parentFieldName=tag.parentFieldName;if((0,validation/* isEmpty */.xb)(parentFieldName))delete filters[fieldName];else{var filter=filters["oneLevelLookup"],parentFilter=filter[parentFieldName];parentFilter=parentFilter.filter((function(filterObj){var criteriaValue=filterObj.criteriaValue,_Object$keys4=Object.keys(criteriaValue),_Object$keys5=dist_slicedToArray(_Object$keys4,1),name=_Object$keys5[0];return name!==fieldName})),(0,validation/* isEmpty */.xb)(parentFilter)?delete filter[parentFieldName]:filter[parentFieldName]=parentFilter}if(hideQuery&&!(0,validation/* isEmpty */.xb)(filterList))this.$emit("updateFilters",{filters:filters});else{var keys=Object.keys(filters);1==keys.length&&"oneLevelLookup"===keys[0]&&(0,validation/* isEmpty */.xb)(filters["oneLevelLookup"])?(this.$emit("clearFilters",!0),this.tagsArr=[]):(0,validation/* isEmpty */.xb)(filters)||this.$emit("updateFilters",{filters:filters})}}}},dist_MONTHS),dist_WEEK_DAYS);
/* script */
const dist_vue_script_=dist_script;
/* template */var dist_vue_render_=function(){var _vm=this,_h=_vm.$createElement,_c=_vm._self._c||_h;return _vm.showTags?_c("div",{staticClass:"f-filter-tags-container"},[_vm._l(_vm.firstThreeTags,(function(tag,index){return _c("div",{key:index,ref:index,refInFor:!0},[_c("Tooltip",{attrs:{placement:"bottom-start",disabled:_vm.checkSize(tag)}},[_c("div",{staticClass:"f-tag-content",attrs:{slot:"content"},slot:"content"},[_vm._v("\n        "+_vm._s(_vm.getTagName(tag))+" "+_vm._s(tag.operatorDisplayName)+"\n        "+_vm._s(tag.valueStr)+"\n      ")]),_vm._v(" "),_c("div",{staticClass:"tag"},[_c("div",[_vm._v(_vm._s(_vm.getTagName(tag)))]),_vm._v(" "),_c("div",{staticClass:"ftag-operator"},[_vm._v("\n          "+_vm._s(tag.operatorDisplayName)+"\n        ")]),_vm._v(" "),_c("div",{staticClass:"ftag-value-container"},[_vm._v("\n          "+_vm._s(tag.valueStr)+"\n        ")]),_vm._v(" "),_c("span",{on:{click:function($event){return _vm.clearFilter(tag)}}},[_c("CloseIcon",{staticClass:"ftag-close-icon"})],1)])])],1)})),_vm._v(" "),_vm.checkDropDownExists?_c("div",[_c("Dropdown",[_c("div",{staticClass:"tag"},[_vm._v("+"+_vm._s(_vm.dropDownTags.length))]),_vm._v(" "),_c("DropdownMenu",{staticClass:"f-tags-dropdown",attrs:{slot:"dropdown"},slot:"dropdown"},_vm._l(_vm.dropDownTags,(function(tag,index){return _c("DropdownItem",{key:index},[_c("Tooltip",{attrs:{placement:"right",disabled:_vm.checkSize(tag)}},[_c("div",{staticClass:"f-tag-content",attrs:{slot:"content"},slot:"content"},[_vm._v("\n              "+_vm._s(_vm.getTagName(tag))+" "+_vm._s(tag.operatorDisplayName)+"\n              "+_vm._s(tag.valueStr)+"\n            ")]),_vm._v(" "),_c("div",{staticClass:"dropdown-tag"},[_c("div",{staticClass:"f-tag-operator-value-container"},[_c("div",[_vm._v(_vm._s(_vm.getTagName(tag)))]),_vm._v(" "),_c("div",{staticClass:"ftag-operator"},[_vm._v("\n                  "+_vm._s(tag.operatorDisplayName)+"\n                ")]),_vm._v(" "),_c("div",{staticClass:"ftag-value-container"},[_vm._v("\n                  "+_vm._s(tag.valueStr)+"\n                ")])]),_vm._v(" "),_c("span",{on:{click:function($event){return _vm.clearFilter(tag)}}},[_c("CloseIcon",{staticClass:"ftag-close-icon"})],1)])])],1)})),1)],1)],1):_vm._e(),_vm._v(" "),_c("div",{staticClass:"btn-container"},[_c("Button",{staticClass:"tag-btn",on:{click:function($event){return _vm.$emit("clearFilters",!0)}}},[_vm._v("Clear all")]),_vm._v(" "),_c("Button",{directives:[{name:"show",rawName:"v-show",value:!_vm.hideSaveAs,expression:"!hideSaveAs"}],staticClass:"tag-btn"},[_vm._v("Save As")])],1)],2):_vm._e()},dist_vue_staticRenderFns_=[];
/* style */
const dist_vue_inject_styles_=function(inject){inject&&inject("data-v-630402e3_0",{source:".ftag-value-container[data-v-630402e3]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ftag-close-icon[data-v-630402e3]{height:10px;width:10px;margin-left:8px;cursor:pointer}.f-tag-content[data-v-630402e3]{max-width:250px;font-size:13px;background:#303133;color:#fff;padding:4px 8px;border-radius:4px}.ftag-operator[data-v-630402e3]{margin:0 4px;color:#324056;font-size:13px;font-weight:400}.f-filter-tags-container[data-v-630402e3]{background:#fff;margin:10px;padding:8px 4px;display:flex;flex-wrap:wrap;box-sizing:border-box;gap:12px}.f-filter-tags-container .tag[data-v-630402e3]{cursor:pointer;display:flex;border-radius:14px;border:solid 1px rgba(58,178,193,.4705882353);background-color:#fff;color:#324056;font-size:13px;font-weight:500;height:24px;align-items:center;padding:6px 10px;box-sizing:border-box;margin-bottom:0!important;margin-right:0!important;max-width:330px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.f-filter-tags-container .tag[data-v-630402e3]:hover{border-color:#3ab2c1}.f-filter-tags-container .tag-btn[data-v-630402e3]{height:24px;margin:0 8px;padding:0 8px;border-radius:14px;border:solid 1px rgba(58,178,193,.4705882353);background-color:#f7feff;cursor:pointer}.f-filter-tags-container .tag-btn[data-v-630402e3]:hover{border-color:#3ab2c1}.el-dropdown-link[data-v-630402e3]{cursor:pointer}.el-dropdown-menu.el-popper.f-tags-dropdown[data-v-630402e3]{list-style:none;width:250px;max-height:165px;overflow:scroll;box-shadow:0 1px 5px 0 rgba(0,0,0,.16);background-color:#fff;padding-inline-start:0}.el-dropdown-menu.el-popper.f-tags-dropdown li.el-dropdown-menu__item[data-v-630402e3]{padding:0!important}.el-dropdown-menu.el-popper.f-tags-dropdown li .dropdown-tag[data-v-630402e3]{background-color:#fff;color:#324056;font-size:13px;font-weight:500;cursor:pointer;box-sizing:border-box;width:100%;height:40px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:13px;background-color:#fff;display:flex;align-items:center;justify-content:space-between;padding:4px}.el-dropdown-menu.el-popper.f-tags-dropdown li .dropdown-tag[data-v-630402e3]:hover{background-color:#fafafa}.el-dropdown-menu.el-popper.f-tags-dropdown li .dropdown-tag .f-tag-operator-value-container[data-v-630402e3]{display:flex;justify-content:space-evenly;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}",map:void 0,media:void 0})},dist_vue_scope_id_="data-v-630402e3",dist_vue_module_identifier_=void 0,dist_vue_is_functional_template_=!1,dist_vue_component_=dist_normalizeComponent({render:dist_vue_render_,staticRenderFns:dist_vue_staticRenderFns_},dist_vue_inject_styles_,dist_vue_script_,dist_vue_scope_id_,dist_vue_is_functional_template_,dist_vue_module_identifier_,!1,dist_createInjector,void 0,void 0);
/* scoped */var CriteriaBuilder=dist_vue_component_$4,dist_AdvancedSearch=dist_vue_component_$1,dist_FTags=dist_vue_component_,Condition=dist_vue_component_$8}}]);
//# sourceMappingURL=http://localhost:5050/sourcemaps/js/91853.js.map