{
   "0": {
        "description" : "sample",
        "usage" : "test",
        "workflow" : "Number getSquareOf(Number i)
                      {
                      		return i * i;
                      }"
        },
   "1": {
    	"description" : "woAverageResponseTime",
        "usage" : "pmSummary",
        "workflow" : "Map test(Number pmId) 
        			  	{ 
        			  		woModule = Module(\"workorder\"); 
        			  		res = woModule.fetch([pm == pmId && actualWorkStart > 0]); 
        			  		if (res == null) 
        			  		{ 
        			  			return 0; 
        			  		} 
  							date = NameSpace(\"date\");
    						temp = date.getPreviousMonthEndDate();
  							previousMonthRes = woModule.fetch([pm == pmId && actualWorkStart > 0 && createdTime <= temp]);
  							previousMonthresponseTime = 0; 
  							if (previousMonthRes != null) {	
	        			  		b = previousMonthRes.size(); 
	                              for each index,value in previousMonthRes { 
	        			  			wd =  (value.actualWorkStart - value.createdTime); 
	        			  			previousMonthresponseTime = (previousMonthresponseTime + wd);
	        			  		}
                                previousMonthresponseTime = previousMonthresponseTime/b; 
                            }
        			  		responseTime = 0; 
        			  		a = res.size(); 
        			  		for each index,value in res { 
        			  			wd =  (value.actualWorkStart - value.createdTime); 
        			  			responseTime = (responseTime + wd);
        			  		} 
        			  		responseTime = responseTime/a; 
                            resMap = {};
                            resMap[\"responseTime\"] = responseTime;
                            resMap[\"previousMonthresponseTime\"] = previousMonthresponseTime;
         					return resMap; 
        			  	}"
        },
		"2": {
			"description" : "fetchGraphicsData",
			"usage" : "graphics",
			"workflow" : "Map fetchGraphicsData(List variables,List conditionalFormattings) 
							  {
								  resultMap = {};
								  resultMapValues = {};
								  if (variables == null) {
									  return resultMap;
								  }
								  recordMap = {};
								  for each index, variableObj in variables {
								  	  variableParentId = variableObj.parentId;
								  	  if (variableObj.fetchType == \"field\") {
									  	  recordKey = variableObj.module + \"_\" + variableParentId;
									  	  recordObj = {};
									  	  if (recordMap.get(recordKey) != null) {
									  	  	  recordObj = recordMap.get(recordKey);
									  	  }
									  	  else {
									  	      fetchModule = Module(variableObj.module);
									  	      recordObj = fetchModule.fetch([id == (variableParentId)]);
									  	      recordMap[recordKey] = recordObj;
									  	  }
									  	  
									  	  valueStr = null;
									  	  if (recordObj != null && recordObj.size() > 0) {
									  	  	  rec = recordObj[0];
									  	  	  valueStr = rec.get(variableObj.select);
									  	  }
									  	  	  
								  	  	  valueMap = {};
										  valueMap[\"value\"] = valueStr;
                                          resultMapValues[variableObj.key] = valueStr;
                                          resultMap[variableObj.key] = valueMap;
									  }
									  else if (variableObj.fetchType == \"space\") {
									  	fetchModule = Module(variableObj.module);
									  	recordObj = fetchModule.fetch([id == (variableParentId)]);
									  	
									  	valueMap = {};
										valueMap[\"value\"] = recordObj;
										resultMapValues[variableObj.key] = recordObj;
										resultMap[variableObj.key] = valueMap;
									  }
									  else if (variableObj.fetchType == \"liveValue\") {
									  	  fieldObj = NameSpace(\"module\").getField(variableObj.select, variableObj.module);
									  	  if (fieldObj != null) {
										  	  fieldid = fieldObj.id();
										  	  fieldMapInfo = fieldObj.asMap();
										  	  
										  	  date = NameSpace(\"date\");
											  month = date.getDateRange(\"Current Month\");
											  if (variableParentId == 1145442) {
											  	db = {
													criteria : [parentId == (variableParentId)],
													field : variableObj.select,
													aggregation : \"lastValue\"
												 };
											  }
											  else {
												  db = {
													criteria : [parentId == (variableParentId) && ttime == month],
													field : variableObj.select,
													aggregation : \"lastValue\"
												  };
											  }
											
											  fetchModule = Module(variableObj.module);
											  lastVal = fetchModule.fetch(db);
											  
										  	  enumMap = Reading(fieldid, variableParentId).getEnumMap();
											  
											  valueMap = {};
											  valueMap[\"value\"] = lastVal;
											  valueMap[\"fieldid\"] = fieldid;
											  if (enumMap != null) {
											      valueMap[\"enumMap\"] = enumMap;
											  }
											  if (fieldMapInfo != null) {
											  	valueMap[\"unit\"] = fieldMapInfo.get(\"unit\");
											  }
											  resultMapValues[variableObj.key] = lastVal;
											  resultMap[variableObj.key] = valueMap;
									     }
									     else {
									     	  valueMap = {};
											  valueMap[\"value\"] = null;
											  resultMapValues[variableObj.key] = null;
									          resultMap[variableObj.key] = valueMap;
									     }
									  }
									  else if (variableObj.fetchType == \"aggrValue\") {
									  	fieldObj = NameSpace(\"module\").getField(variableObj.select, variableObj.module);
									  	if (fieldObj != null) {
									  	  fetchModule = Module(variableObj.module);
										  
										  date = NameSpace(\"date\");
										  month = date.getDateRange(variableObj.dateRange);
										  db = {
											criteria : [parentId == (variableParentId) && ttime == month],
											field : variableObj.select,
											aggregation : variableObj.aggr
										  };
										
										  res = fetchModule.fetch(db);
										
										  valueMap = {};
										  valueMap[\"value\"] = res;
										
										  fieldid = fieldObj.id();
										  enumMap = Reading(fieldid, variableParentId).getEnumMap();
                                        
                                          valueMap[\"fieldid\"] = fieldid;
                                          if (enumMap != null) {
                                            valueMap[\"enumMap\"] = enumMap;
                                          }
                                        
                                         fieldMapInfo = fieldObj.asMap();
                                         valueMap[\"unit\"] = fieldMapInfo.get(\"unit\");
                                         resultMapValues[variableObj.key] = res;
                                         resultMap[variableObj.key] = valueMap;
                                       }
                                       else {
								     	  valueMap = {};
										  valueMap[\"value\"] = null;
										  resultMapValues[variableObj.key] = null;
								          resultMap[variableObj.key] = valueMap;
								        }
									  }
								  }
								  for each index, variableObj in variables {
								  	if (variableObj.fetchType == \"function\") {
									  	res = NameSpace(variableObj.namespace).executeFunc(resultMapValues);
									  	if (res != null) {
									  		resultMapValues[variableObj.key] = res.get(\"value\");
								          	resultMap[variableObj.key] = res;
									  	}
									  	else {
									  		valueMap = {};
										    valueMap[\"value\"] = null;
									  		resultMapValues[variableObj.key] = null;
								          	resultMap[variableObj.key] = valueMap;
									  	}
									  }
								  }
								if(conditionalFormattings != null) {
   	 
								    for each index,conditionalFormatting in conditionalFormattings {
								      
								      if(conditionalFormatting.conditionalFormatting != null) {
								        
								        formatings = conditionalFormatting.conditionalFormatting;
								        
								        for each index,formating in formatings {
								        
								          if(formating.get(\"criteria\") != null && formating.get(\"actions\") != null) {
								          
								             json = formating.get(\"criteria\");
											 criteria1 = NameSpace(\"criteria\").get(json); 
								             res = criteria1.evaluate(resultMapValues);
								             if(res) {
								               actionMap = formating.actions;
								               NameSpace(\"default\").mergeJson(conditionalFormatting,actionMap);
								             }
								          }
								        }
								      }
								    }
								    
								    resultWithCF = {};
								    resultWithCF[\"data\"] = resultMap;
								    resultWithCF[\"conditionalFormatting\"] = conditionalFormattings;
								    
								    return resultWithCF;
								}
								else {
									return resultMap;
								} 
							}"
		},
		"3": {
			"description" : "fetchConsumptionDetailsForMVSummary",
			"usage" : "total consumption,baseline consumption,carbon saved for MV summary",
			"workflow" : "Map mvsummary(Number projectId) 
				{ 
				    resultMap = {};
				    carbonConstant = 0.41;
				    costConstant = 0.44;
				  
				  	energyConstants = default().getOrgInfo(\"energyCostConstant, energyCarbonConstant\");
				    if(energyConstants != null) {
				       if (energyConstants.energyCostConstant != null) {
				         costConstant = energyConstants.energyCostConstant;
				       }
				       if (energyConstants.energyCarbonConstant != null) {
				         carbonConstant = energyConstants.energyCarbonConstant;
				       }
				    }
				  
				    mvProject = Module(\"mvproject\").fetch([id == projectId])[0];
				  
				    lastMonthEndTime = NameSpace(\"date\").getDateRange(\"Last Month\").getEndTime();
				    if (mvProject.frequency == 1) {
				    	lastMonthEndTime = NameSpace(\"date\").getDateRange(\"Yesterday\").getEndTime();
				    }
				    db = {
				      criteria : [parentId == (mvProject.meter.id) && ttime >= (mvProject.reportingPeriodStartTime) && ttime < lastMonthEndTime],
				      field : \"totalEnergyConsumptionDelta\",
				      aggregation : \"sum\"
				    };
				    thisMonthActualConsumption = Module(\"energydata\").fetch(db);
				    if(thisMonthActualConsumption == null) {
				    	thisMonthActualConsumption = 0;
				    }
				    resultMap[\"thisMonthActualConsumption\"] = thisMonthActualConsumption;
				    db = {
				      criteria : [parentId == projectId && ttime >= (mvProject.reportingPeriodStartTime) && ttime < lastMonthEndTime],
				      field : \"adjustedBaseline\",
				      aggregation : \"sum\"
				    };
				    thisMonthBaselineConsumption = Module(\"mvbaselinewithadjustmentreading\").fetch(db);
				    if(thisMonthBaselineConsumption == null) {
				    	thisMonthBaselineConsumption = 0;
				    }
				    resultMap[\"thisMonthBaselineConsumption\"] = thisMonthBaselineConsumption;
				  
				  	db = {
				      criteria : [parentId == projectId && ttime >= (mvProject.reportingPeriodStartTime) && ttime < lastMonthEndTime],
				      field : \"actualsaving\",
				      aggregation : \"sum\"
				    };
				    savedConsumption = Module(\"mvactualsaving\").fetch(db);
				    if(savedConsumption == null) {
				    	savedConsumption = 0;
				    }
				
				    costSaved = savedConsumption * costConstant;
				    resultMap[\"costSaved\"] = costSaved;
				  
					carbonEmissionSaved = savedConsumption * carbonConstant;
				    resultMap[\"carbonEmissionSaved\"] = carbonEmissionSaved;
				
				  	db = {
				      criteria : [parentId == projectId && ttime >= (mvProject.reportingPeriodStartTime) && ttime < lastMonthEndTime],
				      field : \"targetsaving\",
				      aggregation : \"sum\"
				    };
				    targetSavedConsumption = Module(\"mvtargetsaving\").fetch(db);
				    if(targetSavedConsumption == null) {
				    	targetSavedConsumption = 0;
				    }
				    
				    targetCost = targetSavedConsumption * costConstant;
				    resultMap[\"targetCost\"] = targetCost;
				    return resultMap;
				}"
		},
		"4": {
			"description" : "portfolioAlarmCardData",
			"usage" : "total consumption,baseline consumption,carbon saved for MV summary",
			"workflow" : "Map openalarms()
		     {
                clearCondition = {
                   criteria :[severity == \"Clear\" ],
                 };
                 alarmSevrityModule = Module(\"alarmseverity\");
                 clearSeverityContext = alarmSevrityModule.fetch(clearCondition);
                 clearId = clearSeverityContext.get(0).get(\"id\");
                 activeAssetcri = {
					criteria : [severity != clearId  ],
                    field : \"id\",
                   	aggregation : \"count\",
				  };
               	unAcknowledgedCri = {
                 	criteria : [severity != clearId && acknowledged == false  ] ,
                 	field : \"id\",
                   	aggregation : \"count\",
               	};
		        readingAlarmModule = Module(\"newreadingalarm\");
		        activeRecord = readingAlarmModule.fetch(activeAssetcri);
               	unAckRecord = readingAlarmModule.fetch(unAcknowledgedCri);
                resultMap = {};
                resultMap[\"active\"] = activeRecord;
               	resultMap[\"unacknowledged\"] = unAckRecord;
                return resultMap;
		    }"
		},
		"5" : {
			"description" : "Most Common Alarm for asset",
			"usage" : "AssetSummary",
			"workflow" : "Map assetAlarmDetails(Number resourceId) {
				date = NameSpace(\"date\");
				durtaion = 0;
				 durationInMilli = 0;
				thisCurrentYear = date.getDateRange(\"Current Year\");
				readingAlarmOccurrence = Module(\"readingalarmoccurrence\");
				occurenceThisMonthCrit = null;
				resMap = {};
				occurenceThisYearCrit = {
					criteria: [resource == resourceId],
					field: \"rule\",
					aggregation: \"count, rule\",
					groupBy: \"rule\"
				};
				thisYearOccurrence = readingAlarmOccurrence.fetch(occurenceThisYearCrit);
				occurrenceCount = 0;
				ruleId = 0;
				mcName = null;
				if (thisYearOccurrence != null) {
					for each index, value in thisYearOccurrence {
						if (value.rule != null && occurrenceCount < value.rule) {
							ruleId = value.result.id;
							occurrenceCount = value.rule;
						}
					}
				}
				if (ruleId > 0) {
					readingRuleModule = Module(\"workflowrule\");
					readingRuleCrite = {
						criteria: [id == ruleId]
					};
					ruleDurationCriteria = {
						criteria: [rule == ruleId],
						field: \"duration\",
						aggregation: \"sum, duration\"
					};
					durationrecord = readingAlarmOccurrence.fetch(ruleDurationCriteria);
					if (durationrecord != null) {
						duration = durationrecord ;
						durationInMilli = duration * 1000 ;
					} else {
						newReadingAlarmModule = Module(\"newreadingalarm\");
						ruleDurationCriteria = {
							criteria: [rule == ruleId && resource == resourceId]
						};
						durationRecord = newReadingAlarmModule.fetch(ruleDurationCriteria);
						if (durationRecord != null && durationRecord.get(0).lastOccurredTime > 0) {
							duration = date().now() - durationRecord.get(0).lastOccurredTime;
						}
					}
					ruleObj = readingRuleModule.fetch(readingRuleCrite);
					if (ruleObj != null) {
					firstRes =ruleObj[0];
					commonRule = firstRes.name;
					}
				}
				resMap[\"commonRule\"] = commonRule;
				resMap[\"duration\"] = durationInMilli;
				resMap[\"durationInSeconds\"] = duration;
				log resMap;
				return resMap;
				}"
		},
		"6": {
			"description": "",
			"usage": "",
			"workflow": "Map assetAlarmDetails(Number resourceId) {
				date = NameSpace(\"date\");
				thisCurrentYear = date.getDateRange(\"Current Year\");
				readingAlarmOccurrence = Module(\"readingalarm\");
				occurenceThisMonthCrit = null;
				resMap = {};
				durationForYear =0;
				durationInSeconds = 0;
				occurenceThisYearCrit = {
					criteria: [resource == resourceId && createdTime ==  thisCurrentYear],
					field: \"ruleId\",
					aggregation: \"count, ruleId\",
					groupBy: \"ruleId\"
				};
				thisYearOccurrence = readingAlarmOccurrence.fetch(occurenceThisYearCrit);
				occurrenceCount = 0;
				ruleId = 0;
				mcName = null;
				if (thisYearOccurrence != null) {
					for each index, value in thisYearOccurrence {
						if (occurrenceCount < value.ruleId) {
							ruleId = value.result;
							occurrenceCount = value.ruleId;
						}
					}
				}
				if (ruleId > 0) {
					readingRuleModule = Module(\"workflowrule\");
					readingRuleCrite = {
						criteria: [id == ruleId]
					};
					ruleObj = readingRuleModule.fetch(readingRuleCrite);

					if (ruleObj != null) {
						firstRes =ruleObj[0];
						commonRule = firstRes.name;
					}
					sumOfCreatedTime = {
						criteria : [ createdTime == thisCurrentYear && ruleId == ruleId ],
						aggregation : \"sum, createdTime\",
						field: \"createdTime\"
					};

					createdTimeSum = readingAlarmOccurrence.fetch(sumOfCreatedTime);
					sumClearedTime = {
						criteria : [ createdTime == thisCurrentYear && ruleId == ruleId ],
						aggregation : \"sum, clearedTime\",
						field: \"clearedTime\"
					};

					clearedTimeSum = readingAlarmOccurrence.fetch(sumClearedTime);
					durationForYear = (clearedTimeSum - createdTimeSum);
					durationInSeconds = durationForYear / 1000;
					log durationForYear;
				}
				resMap[\"commonRule\"] = commonRule;
				resMap[\"duration\"] = durationForYear;
				resMap[\"durationInSeconds\"] = durationInSeconds;
				return resMap;
				}"
		},
		"7": {
			"description": "KPI Violations",
			"usage": "KPISummary",
			"workflow": "Map fetchKpiViolations(List formulaIds, Number startTime, Number endTime) {
			  violations = {};
			  violationModule = Module(\"violationalarmoccurrence\");
			  date = NameSpace(\"date\");
			  if (startTime != null) {
			    ttimes = date.dateRange(startTime, endTime);
			    db = {
			      criteria: [formulaField == formulaIds && createdTime == ttimes],
			      field: \"formulaField\",
			      aggregation: \"count, formulaField\",
			      groupBy: \"formulaField\"
			    };
			    violationsCount = violationModule.fetch(db);
			    if (violationsCount != null) {
			      for each index, value in violationsCount {
			        violations[value.result.id] = value.formulaField;
			      }
			    }
			  }
			  else {
			    thisMonthRanges = date.getDateRange(\"Current Month\");
			    
			    db = {
			      criteria: [formulaField == formulaIds && createdTime == thisMonthRanges],
			      field: \"formulaField\",
			      aggregation: \"count, formulaField\",
			      groupBy: \"formulaField\"
			    };
			    violationsThisMonth = violationModule.fetch(db);
			    if (violationsThisMonth != null) {
			      for each index, value in violationsThisMonth {
			        res = {};
			        res.thisMonth = value.formulaField;
			        violations[value.result.id] = res;
			      }
			    }
			    
				lastMonthRanges = date.getDateRange(\"Last Month\");
			    db = {
			      criteria: [formulaField == formulaIds && createdTime == lastMonthRanges],
			      field: \"formulaField\",
			      aggregation: \"count, formulaField\",
			      groupBy: \"formulaField\"
			    };
			    violationsLastMonth = violationModule.fetch(db);
			    if (violationsLastMonth != null) {
			      for each index, value in violationsLastMonth {
			        res = {};
					if (violations.get(value.result.id) != null) {
			          res = violations.get(value.result.id);
			        }
			        else {
			          violations[value.result.id] = res;
			        }
			        res.lastMonth = value.formulaField;
			      }
			    }
			  }
			  return violations;
			}"
		},
		"8": {
			"description" : "Alarm Details",
			"usage" : "AlarmInsight",
			"workflow" : "Map alarmMeanMetrics(Number alarmId){
				date = NameSpace(\"date\");
				thisMonthRanges = date.getDateRange(\"Current Month\");
				lastMonthRanges = date.getDateRange(\"Last Month\");
				alarmoccurrenceModule = Module(\"alarmoccurrence\");
				occurenceThisMonthCrit = null;
				occurenceLastMonthCrit = null;
				resMap = {};
				occurenceThisMonthCrit = {
					criteria: [alarm == alarmId && createdTime == thisMonthRanges],
					orderBy : \"createdTime\" asc
				};
				occurenceLastMonthCrit = {
					criteria: [alarm == alarmId && createdTime == lastMonthRanges],
					orderBy : \"createdTime\" asc
				};
				mtba = 0;
				mtbaCount=0;
				mttc = 0;
				mttcCount=0;
				previousClearedTime = 0;
				noOfOccurrence = 0;
				lstNoOfOccurrence = 0;
				thisMonthOccurence =  alarmoccurrenceModule.fetch(occurenceThisMonthCrit);
				if (thisMonthOccurence != null) {
					noOfOccurrence = thisMonthOccurence.size();
					for each index,value in thisMonthOccurence {
						createdTime = value.createdTime;
						if (previousClearedTime != 0) {
							mtba = mtba+(createdTime - previousClearedTime);
							mtbaCount = mtbaCount+1;
						}
						if (value.clearedTime != null) {
							previousClearedTime = value.clearedTime;
							mttc = mttc + (previousClearedTime - createdTime);
							mttcCount = mttcCount+1;
						}
					}
				}
				if (mtbaCount > 0) {
				mtba = mtba / (mtbaCount * 1000);
				}
				if (mttcCount > 0) {
				mttc = mttc / (mttcCount * 1000);
				}
				resMap[\"mtba\"] = mtba;
				resMap[\"mttc\"] = mttc;
				resMap[\"noOfOcc\"] = noOfOccurrence;
				mtba = 0;
				mtbaCount=0;
				mttc = 0;
				mttcCount=0;
				previousClearedTime = 0;
				lastMonthOccurence =  alarmoccurrenceModule.fetch(occurenceLastMonthCrit);
				if (lastMonthOccurence != null) {
					lstNoOfOccurrence = lastMonthOccurence.size();
					for each index,value in lastMonthOccurence {
						createdTime = value.createdTime;
						if (previousClearedTime != 0) {
							mtba = mtba+(createdTime - previousClearedTime);
							mtbaCount = mtbaCount+1;
						}
						if (value.clearedTime != null) {
							previousClearedTime = value.clearedTime;
							mttc = mttc + (previousClearedTime - createdTime);
							mttcCount = mttcCount+1;
						}
					}
				}
				if (mtbaCount > 0) {
					mtba = mtba / (mtbaCount * 1000);
				}
				if (mttcCount > 0) {
					mttc = mttc / (mttcCount * 1000);
				}
				resMap[\"mtbaLastMonth\"] = mtba;
				resMap[\"mttcLastMonth\"] = mttc;
				resMap[\"noOfOccLastMonth\"] = lstNoOfOccurrence;
				log resMap;
				return resMap;
				}"
		},
		"9": {
		"description" : "Alarm Overview",
		"usage" : "Alarm Rank widget",
		"workflow" : "Map newAlrmRankWorkflow(Number alarmId) {
				date = NameSpace(\"date\");
				monthRanges = date.getDateRange(\"Current Year\");
				db = {
					criteria: [lastCreatedTime == monthRanges],
					field:\"id\",
					aggregation:\"sum, noOfOccurrences\",
					groupBy: \"id\",
					orderBy:\"noOfOccurrences\" desc
				};
				readingAlarmModule = Module(\"baseAlarm\");
				activeRecord = readingAlarmModule.fetch(db);
				ranking = 0;
				if (activeRecord != null) {
					for each index, value in activeRecord {
						temp = value.result;
						temp = value.result + 0;
						if (temp == alarmId) {
							ranking = index + 1;
						}
					}
				}
				resultMap = {};
				if (activeRecord != null) {
					resultMap[\"ranks\"] = activeRecord;
					resultMap[\"ranking\"] = ranking;
					resultMap[\"outOfRule\"] = activeRecord.size();
				}
				log resultMap;
				return resultMap;
			}"
		},
		"10": {
			"description" : "Conditional Formatting",
			"usage" : "ApplyConditionalFormatting",
			"workflow" : "Map applyConditionalFormatting(List variables,Map conditionalFormattings,Map cardState){
				if(conditionalFormattings != null) {
				
					for each index,formating in conditionalFormattings.conditionalFormatting {
								        
						if(formating.get(\"criteria\") != null && formating.get(\"styles\") != null) {
							json = formating.get(\"criteria\");
                            conditions = json.get(\"conditions\");
                          	validCondition = false;
                          	if (conditions != null && conditions.size() > 0) {
	                          	for each cidx, condition in conditions {
    	                          if (condition != null && condition.size() > 0) {
        	                        validCondition = true;
            	                  }
                	            }
                            }
                          	if (validCondition) {
								criteria1 = NameSpace(\"criteria\").get(json); 
								res = criteria1.evaluate(variables);
								if(res) {
									returnMap = {};
									returnMap[\"styles\"] = formating.styles;
									return returnMap;
								}
                            }
						}
					}
				}
				return null;
			}"
		},
		"11": {
			"description" : "Agent Alarm Insight",
			"usage" : "Agent Alarm Summary",
			"workflow" : "Map agentMetrics(Number alarmId) {
				date = NameSpace(\"date\");
				thisMonthRanges = date.getDateRange(\"Current Month\");
				lastMonthRanges = date.getDateRange(\"Last Month\");
				alarmoccurrenceModule = Module(\"alarmoccurrence\");
				occurenceThisMonthCrit = null;
				occurenceLastMonthCrit = null;
				resMap = {};
				occurenceThisMonthCrit = {
					criteria: [alarm == alarmId && createdTime == thisMonthRanges],
					orderBy : \"createdTime\" asc
				};
				occurenceLastMonthCrit = {
					criteria: [alarm == alarmId && createdTime == lastMonthRanges],
					orderBy : \"createdTime\" asc
				};
				mtba = 0;
				previousClearedTime = 0;
				noOfOccurrence = 0;
				lstNoOfOccurrence = 0;
				maxDuration = 0;
				maxDurationTime = 0;
				duration = 0;
				thisMonthOccurence =  alarmoccurrenceModule.fetch(occurenceThisMonthCrit);
				if (thisMonthOccurence != null) {
					noOfOccurrence = thisMonthOccurence.size();
					for each index,value in thisMonthOccurence {
						createdTime = value.createdTime;
						if (value.clearedTime != null) {
							duration = value.duration;
						} else {
							duration = (date().now() - createdTime);
						}
						mtba = mtba + duration;
						if (maxDuration < duration) {
							maxDuration = duration;
							maxDurationTime = value.createdTime;
						}
					}
				}
				resMap[\"durationCurrentMonth\"] = mtba / 1000;
				resMap[\"noOfOcc\"] = noOfOccurrence;
				resMap[\"maxDurationThisMonth\"] = maxDuration / 1000;
				resMap[\"maxDurationCurrentTime\"] = maxDurationTime;
				mtba = 0;
				maxDuration = 0;
				maxTimeDuration = null;
				previousClearedTime = 0;
				duration = 0;
				maxDurationTime = 0;
				lastMonthOccurence =  alarmoccurrenceModule.fetch(occurenceLastMonthCrit);
				if (lastMonthOccurence != null) {
					lstNoOfOccurrence = lastMonthOccurence.size();
						for each index,value in lastMonthOccurence {
						createdTime = value.createdTime;
						if (value.clearedTime != null) {
							duration = value.duration;
						} else {
							duration = (date().now() - createdTime);
						}
						mtba = mtba + duration;
						if (maxDuration < duration) {
							maxDuration = duration;
							maxDurationTime = value.createdTime;
						}
					}
				}
				resMap[\"durationLastMonth\"] = mtba / 1000;
				resMap[\"noOfOccLastMonth\"] = lstNoOfOccurrence;
				resMap[\"maxDurationLastMonth\"] = maxDuration / 1000;
				resMap[\"maxDurationLastTime\"] = maxDurationTime;
				log resMap;
				return resMap;
				}"
		},
		"46": {
			"description" : "ML Deviation",
			"usage" : "AnomalySummary",
			"workflow" : "Map calculateDeviation(List resourceIds, Number alarmId){
			  resultMap = {};
			  mlReadings = Module(\"anomalydetectionmllogreadings\");
			  date = NameSpace(\"date\");
			  thisMonthRanges = date.getDateRange(\"Current Month\");
			  thisMonthStartTime = dateRange().getStartTime(thisMonthRanges);
			  thisMonthEndTime = dateRange().getEndTime(thisMonthRanges);
			  lastMonthRanges = date.getDateRange(\"Last Month\");
			  lastMonthStartTime = dateRange().getStartTime(lastMonthRanges);
			  lastMonthEndTime = dateRange().getEndTime(lastMonthRanges);
			
			  occurenceThisMonthCrit = {
			    criteria: [alarm == alarmId && createdTime < thisMonthEndTime && (clearedTime == null || clearedTime > thisMonthStartTime)]
			  };
			  occurenceLastMonthCrit = {
			    criteria: [alarm == alarmId && createdTime < lastMonthEndTime && (clearedTime == null || clearedTime > lastMonthStartTime)]
			  };
			  thismothoccurence =  Module(\"alarmoccurrence\").fetch(occurenceThisMonthCrit);
			  lastmonthoccurrence = Module(\"alarmoccurrence\").fetch(occurenceLastMonthCrit);
			  adjustedUpperBoundField = NameSpace(\"module\").getField(\"adjustedUpperBound\", \"anomalydetectionmllogreadings\");
			  for each rindex,resourceId in resourceIds {
			    result = {};
			    deviation = 0;
			    deviationCount = 0;
			    if (thismothoccurence != null) {
			      for each index,value in thismothoccurence {
			        startTime = value.createdTime;
			        if (value.createdTime < thisMonthStartTime) {
			          startTime = thisMonthStartTime;
			        }
			        endTime = value.clearedTime;
			        if (endTime == null) {
			          endTime = thisMonthEndTime;
			        }
			        ttimes = date.dateRange(startTime, endTime);
			        thisMonthEnergy = {
			          criteria: [parentId == resourceId && ttime == ttimes && adjustedUpperBound > 0 && actualValue > adjustedUpperBoundField]
			        };
			        currentMonthReadings =  mlReadings.fetch(thisMonthEnergy);
			        if (currentMonthReadings != null) {
			          for each index,value in currentMonthReadings {
			            diff =  value.actualValue - value.adjustedUpperBound;
			            deviation = deviation + (diff / value.adjustedUpperBound) * 100;
			            deviationCount = deviationCount + 1;
			          }
			        }
			      }
			      if (deviationCount > 0) {
			        deviation = deviation / deviationCount;
			      }
			    }
			    result[\"deviation\"] = deviation;
			
			    deviation = 0;
			    deviationCount = 0;
			    if (lastmonthoccurrence != null) {
			      for each index,value in lastmonthoccurrence {
			      	startTime = value.createdTime;
			        if (value.createdTime < lastMonthStartTime) {
			          startTime = lastMonthStartTime;
			        }
			        endTime = value.clearedTime;
			        if (endTime == null || endTime > lastMonthEndTime) {
			          endTime = lastMonthEndTime;
			        }
			        ttimes = date.dateRange(startTime, endTime);
			        lastMonthEnergy = {
			          criteria: [parentId == resourceId && ttime == ttimes && adjustedUpperBound > 0 && actualValue > adjustedUpperBoundField],
			        };
			        lastMonthReadings =  mlReadings.fetch(lastMonthEnergy);
			        if (lastMonthReadings != null) {
			          for each index,value in lastMonthReadings {
			            diff =  value.actualValue - value.adjustedUpperBound;
			            deviation = deviation + (diff / value.adjustedUpperBound) * 100;
			            deviationCount = deviationCount + 1;
			          }
			        }
			      }
			      if (deviationCount > 0) {
			        deviation = deviation / deviationCount;
			      }
			    }
			    result[\"deviationLastMonth\"] = deviation;
			
			    resultMap[resourceId] = result;
			  }
			  return resultMap;
			}"
		},
		"47": {
			"description" : "Mean Time Anomaly Metrics",
			"usage" : "AnomalySummary",
			"workflow" : "Map anomalyMeanMetrics(Number alarmId){
			  date = NameSpace(\"date\");
			  thisMonthRanges = date.getDateRange(\"Current Month\");
			  lastMonthRanges = date.getDateRange(\"Last Month\");
			  alarmoccurrenceModule = Module(\"anomalyalarmoccurrence\");
			  occurenceThisMonthCrit = null;
			  occurenceLastMonthCrit = null;
			  resMap = {};
			  occurenceThisMonthCrit = {
			    criteria: [alarm == alarmId && createdTime == thisMonthRanges],
			    orderBy : \"createdTime\" asc
			  };
			  occurenceLastMonthCrit = {
			    criteria: [alarm == alarmId && createdTime == lastMonthRanges],
			    orderBy : \"createdTime\" asc
			  };
			  mtba = 0;
			  mtbaCount=0;
			  mttc = 0;
			  mttcCount=0;
			  previousClearedTime = 0;
			  thisMonthOccurence =  alarmoccurrenceModule.fetch(occurenceThisMonthCrit);
			  if (thisMonthOccurence != null) {
			    for each index,value in thisMonthOccurence {
			      createdTime = value.createdTime;
			      if (previousClearedTime != 0) {
			        mtba = mtba+(createdTime - previousClearedTime);
			        mtbaCount = mtbaCount+1;
			      }
			      if (value.clearedTime != null) {
			        previousClearedTime = value.clearedTime;
			        mttc = mttc + (previousClearedTime - createdTime);
					mttcCount = mttcCount+1;
			      }
			    }
			  }
			  if (mtbaCount > 0) {
			      mtba = mtba / (mtbaCount * 1000);
			  }
			  if (mttcCount > 0) {
			      mttc = mttc / (mttcCount * 1000);
			  }
			  resMap[\"mtba\"] = mtba;
			  resMap[\"mttc\"] = mttc;

			  mtba = 0;
			  mtbaCount=0;
			  mttc = 0;
			  mttcCount=0;
			  previousClearedTime = 0;
			  lastMonthOccurence =  alarmoccurrenceModule.fetch(occurenceLastMonthCrit);
			  if (lastMonthOccurence != null) {
			    for each index,value in lastMonthOccurence {
			      createdTime = value.createdTime;
			      if (previousClearedTime != 0) {
			        mtba = mtba+(createdTime - previousClearedTime);
			        mtbaCount = mtbaCount+1;
			      }
			      if (value.clearedTime != null) {
			        previousClearedTime = value.clearedTime;
			        mttc = mttc + (previousClearedTime - createdTime);
					mttcCount = mttcCount+1;
			      }
			    }
			  }
			  if (mtbaCount > 0) {
			      mtba = mtba / (mtbaCount * 1000);
			  }
			  if (mttcCount > 0) {
			      mttc = mttc / (mttcCount * 1000);
			  }
			  resMap[\"mtbaLastMonth\"] = mtba;
			  resMap[\"mttcLastMonth\"] = mttc;
			  return resMap;
			}"
		},
		"48": {
			"description": "Sub Meter",
			"usage": "AnomalySummary",
			"workflow": "Map getSubMeterForAnomaly( Number alarmId){
			  resultMap = {};
			  mlReadings = Module(\"anomalyalarmoccurrence\");
  			  resourceModule = Module(\"resource\");
			  date = NameSpace(\"date\");			
			  occurenceThisMonthCrit = {
			    criteria: [parentAlarm == alarmId]
			  };
			  thismothoccurence = Module(\"anomalyalarmoccurrence\").fetch(occurenceThisMonthCrit);
  			subMeters =[];
			  result = {};
			    if (thismothoccurence != null) {
			      for each index,value in thismothoccurence {
			   		 subMeters.add(value.resource.id);
			      }
			  }
  				if (subMeters.size() > 0 ) {
                  resourceCriteria = {criteria: [id == subMeters] };
                  subMeters = resourceModule.fetch(resourceCriteria);
                }
			  resultMap[\"subMeter\"] = subMeters;
  				return resultMap;
			}"
		},
		"49": {
			"description": "Energy By CDD",
			"usage": "AnomalySummary",
			"workflow": "Map energyByCDD(List resourceIds, Number siteId){
			  resourceIds.sort();
			  result = {};
			  date = NameSpace(\"date\");
			  thisMonthRanges = date.getDateRange(\"Current Month\");
			  lastMonthRanges = date.getDateRange(\"Last Month\");
			  db = {
			    criteria : [parentId == resourceIds && ttime == thisMonthRanges],
			    field : \"totalEnergyConsumptionDelta\",
				aggregation : \"sum, totalEnergyConsumptionDelta\",
			    groupBy: \"parentId\",
			    orderBy: \"parentId\" asc
			  };
			  thisMonthActualConsumption = Module(\"energydata\").fetch(db);
			  db = {
			    criteria : [parentId == resourceIds && ttime == lastMonthRanges],
			    field : \"totalEnergyConsumptionDelta\",
			    aggregation : \"sum, totalEnergyConsumptionDelta\",
			    groupBy: \"parentId\",
			    orderBy: \"parentId\" asc
			  };
			  lastMonthActualConsumption = Module(\"energydata\").fetch(db);
			    log \"\"+lastMonthActualConsumption;
			  db = {
			    criteria : [parentId == siteId && ttime == thisMonthRanges],
			    field : \"cdd\",
			    aggregation : \"sum\"
			  };
			  thisMonthCdd = Module(\"cdd\").fetch(db);
			  db = {
			    criteria : [parentId == siteId && ttime == lastMonthRanges],
			    field : \"cdd\",
			    aggregation : \"sum\"
			  };
			  lastMonthCdd = Module(\"cdd\").fetch(db);
			  for each index,resourceId in resourceIds {
			    resultMap = {};
			    resultMap[\"totalThisMonth\"] = 0;
			    if (thisMonthCdd != null) {
			      consumption = thisMonthActualConsumption[index];
			      consumption = consumption.totalEnergyConsumptionDelta;
			      resultMap[\"totalThisMonth\"] = consumption/thisMonthCdd;
			    }
			    if (lastMonthCdd != null) {
			      consumption = lastMonthActualConsumption[index];
			      consumption = consumption.totalEnergyConsumptionDelta;
			      resultMap[\"totalLastMonth\"] = consumption/lastMonthCdd;
			    }
			    result[resourceId] = resultMap;
			  }
			  return result;
			}"
		},
		"50": {
        	"description" : "ruleNewAlarmsDetails",
        	"usage" : "rulesNewSummary",
        	"workflow": "Map newAlarmDetails(Number ruleId)
		     {
                  clearCondition = {
                    criteria :[severity == \"Clear\" ]
                  };
            	date = NameSpace(\"date\");
            	ranges = date.getDateRange(\"Current Week\");
                monthRanges = date.getDateRange(\"Current Month\");
		    	alarmsCurrWeekCri = {
              		criteria : [rule == ruleId && lastOccurredTime == ranges ]
            	};
                  alarmSevrityModule = Module(\"alarmseverity\");
                  clearSeverityContext = alarmSevrityModule.fetch(clearCondition);
                  clearId = clearSeverityContext.get(0).get(\"id\");
                  activeAssetcri = {
					criteria : [rule == ruleId && severity != clearId  ]
				};
		        readingAlarmModule = Module(\"newreadingalarm\");
                workOrderModule = Module(\"ticket\");
		        activeRecord = readingAlarmModule.fetch(activeAssetcri);
              	activeAlarms = 0;
                  activeAlarmResources = [];
              	if (activeRecord != null) {
                  for each index,value in activeRecord {
		                        if (value != null) {
                                  if (value.get(\"resource\") != null) {
                                    activeAlarmResources.add(value.get(\"resource\").get(\"id\"));
                                  }
		                        }                                
		                }
                      activeAlarms = activeRecord.size();
                 }
              	currWeekAlarmRec = readingAlarmModule.fetch(alarmsCurrWeekCri);
              	currWeekAlarms = 0;
              	alarmThisWeekResources = [];
              	if (currWeekAlarmRec != null) {
              		for each index,value in currWeekAlarmRec {
		                        if (value != null) {
                                  if (value.get(\"resource\") != null) {
                                    alarmThisWeekResources.add(value.get(\"resource\").get(\"id\"));
                                  }
		                        }                                
		                }
                	currWeekAlarms = currWeekAlarmRec.size();
             	}
                  resultMap = {};
                  resultMap[\"activeAlarms\"] = activeAlarms;
                  resultMap[\"alarmRuleThisWeek\"] = currWeekAlarms;
                  resultMap[\"activeAlarmResources\"] = activeAlarmResources;
                  resultMap[\"alarmThisWeekResources\"] = alarmThisWeekResources;
                  return resultMap;
		    }"
        },
        "51": {
        "description" : "newAlarmRuleWoDetails",
        	"usage" : "rulesSummary",
        	"workflow": "Map ruleWoDetails(Number ruleId) {
				  date = NameSpace(\"date\");
				  ranges = date.getDateRange(\"Current Week\");
				  monthRanges = date.getDateRange(\"Current Month\");
				  alarmsCurrWeekCri = {
				    criteria: [rule == ruleId && lastOccurredTime == ranges]
				  };
				  readingAlarmModule = Module(\"newreadingalarm\");
				  workOrderModule = Module(\"workorder\");
				  alarmoccurrenceModule = Module(\"alarmoccurrence\");
				  woThisWeek = {
				    criteria: [rule == ruleId && lastOccurredTime == ranges]
				  };
				  woThisMonth = {
				    criteria: [rule == ruleId && lastOccurredTime == monthRanges]
				  };
				  currWeekOccurence = readingAlarmModule.fetch(woThisWeek);
				  occurencesID = [];
				  if (currWeekOccurence != null) {
				    for each index, value in currWeekOccurence {
				      occurencesID.add(value.lastOccurrenceId);
				    }
				  }
				  alarmOccurrencesCri = {
				    criteria: [id == occurencesID && woId != null]
				  };
				  currenWeekAlarmOccurrences = alarmoccurrenceModule.fetch(alarmOccurrencesCri);
				  currentWeekWo = 0; currentWeekWoId = [];
				  if (currenWeekAlarmOccurrences != null) {
				    currentWeekWo = currenWeekAlarmOccurrences.size();
				    for each index, value in currenWeekAlarmOccurrences {
				      if (value != null) {
				        currentWeekWoId.add(value.get(\"woId\"));
				      }
				    }
				  }
				  woThisMonth = {
				    criteria: [rule == ruleId && lastOccurredTime == monthRanges]
				  };
				  currMonthOccurence = readingAlarmModule.fetch(woThisMonth);
				  occurencesMonthID = [];
				  if (currMonthOccurence != null) {
				    for each index, value in currMonthOccurence {
				      occurencesMonthID.add(value.lastOccurrenceId);
				    }
				  }
				  alarmMonthOccurrencesCri = {
				    criteria: [id == occurencesMonthID && woId != null]
				  };
				  currenMonthAlarmOccurrences = alarmoccurrenceModule.fetch(alarmMonthOccurrencesCri);
				  currentMonthWo = 0; currentMonthWoId = [];
				  if (currenMonthAlarmOccurrences != null) {
				    currentMonthWo = currenMonthAlarmOccurrences.size();
				    for each index, value in currenMonthAlarmOccurrences {
				      if (value != null) {
				        currentMonthWoId.add(value.get(\"woId\"));
				      }
				    }
				  }
				  ticketContextRespondTime = {
				    criteria: [id == currentMonthWoId && actualWorkStart > 0]
				  };
				  ticketContextResolutionTime = {
				    criteria: [id == currentMonthWoId && actualWorkDuration > 0]
				  };
				  ticketsResponse = workOrderModule.fetch(ticketContextRespondTime);
				  ticketsResolution = workOrderModule.fetch(ticketContextResolutionTime);
				  previousMonthresponseTime = 0;
				  previousMonthresolutionTime = 0;
				  if (ticketsResponse != null) {
				    b = ticketsResponse.size();
				    for each index, value in ticketsResponse {
				      wd = (value.actualWorkStart - value.createdTime);
				      previousMonthresponseTime = (previousMonthresponseTime + wd);
				    }
				    previousMonthresponseTime = previousMonthresponseTime / b;
				  }
				  if (ticketsResolution != null) {
				    c = ticketsResolution.size();
				    for each index, value in ticketsResolution {
				      pd = value.actualWorkDuration;
				      previousMonthresolutionTime = (previousMonthresolutionTime + pd);
				
				    }
				    previousMonthresolutionTime = previousMonthresolutionTime / c;
				  }
				  resultMap = {};
				  resultMap[\"currentMonthWo\"] = currentMonthWo;
				  resultMap[\"currentWeekWo\"] = currentWeekWo;
				  resultMap[\"currentWeekWoId\"] = currentWeekWoId;
				  resultMap[\"currentMonthWoID\"] = currentMonthWoId;
				  resultMap[\"previousMonthresponseTime\"] = previousMonthresponseTime;
				  resultMap[\"previousMonthresolutionTime\"] = previousMonthresolutionTime;
				  return resultMap;
				}"
        
        },
         "52": {
        	"description" : "newAlarmRuleRank",
        	"usage" : "ruleRank",
        	"workflow": "Map newAlrmRankWorkflow(Number ruleId) {
				date = NameSpace(\"date\");
				monthRanges = date.getDateRange(\"Current Year\");
				db = {
					criteria: [createdTime == monthRanges],
					field:\"rule\",
					aggregation:\"count, id\",
					groupBy:\"rule\",
					orderBy:\"id\" desc
				};
				readingAlarmModule = Module(\"readingalarmoccurrence\");
				activeRecord = readingAlarmModule.fetch(db);
				ranking = 0;
				if (activeRecord != null) {
					for each index, value in activeRecord {
						temp = value.result.id;
						temp = value.result.id + 0;
						if (temp == ruleId) {
							ranking = index + 1;
						}
					}
				}
				resultMap = {};
				if (activeRecord != null) {
					resultMap[\"ranks\"] = activeRecord;
					resultMap[\"ranking\"] = ranking;
					resultMap[\"outOfRule\"] = activeRecord.size();
				}
					return resultMap;
				}",
        },
         "53": {
        	"description" : "newAlarmMeanTimeBetweenTriggers",
        	"usage" : "newAlarmrulesSummary",
        	"workflow": "Map getNewAlarmRuleTriggerDetials(Number ruleId)
			{
			date = NameSpace(\"date\");
			tillLastMonthranges = date.getDateRange(\"Current year upto last month\");
			currentMonthranges = date.getDateRange(\"Current Month\");
			tillLastMonthcri = {
				criteria : [rule == ruleId && createdTime == tillLastMonthranges ],
				orderBy : \"createdTime\" asc
			};
			currentMonthCri = {
				criteria : [rule == ruleId && createdTime == currentMonthranges ],
				orderBy : \"createdTime\" asc
			};
			alarmoccurrenceModule = Module(\"readingalarmoccurrence\");

			alarmMonthOccurenceList = alarmoccurrenceModule.fetch(currentMonthCri);
			alarmOccurenceTillLMonthList = alarmoccurrenceModule.fetch(tillLastMonthcri);


			mtbt = 0;
			pmtbt = 0;
			mttc = 0;
			mOverAllDuration = 0;
			pmttc = 0;
			pmOverAllDuration = 0;
			noOfOccurrence = 0;
			acknowledgedDuration = 0;
			tillLstMntAcknowledgedDuration = 0;
			if (alarmMonthOccurenceList != null) {
				noOfOccurrence = alarmMonthOccurenceList.size();
				previousClearedTime = 0;
				previousCreatedTime = 0;
				sumMtbt = 0;
				sumMttc = 0;
				countOfClearedOccurence = 0;
				mttcCount = 0;
				for each index,occurrence in alarmMonthOccurenceList {
					if (occurrence.acknowledgedTime != null) {
						acknowledgedDuration = acknowledgedDuration + ( occurrence.acknowledgedTime - occurrence.createdTime);
					}
					if (previousClearedTime != 0) {
						if (previousClearedTime > occurrence.createdTime) {
							previousClearedTime = previousCreatedTime;
						}
						sumMtbt = sumMtbt + (occurrence.createdTime - previousClearedTime);
						mttcCount = mttcCount + 1;
					}
					previousCreatedTime = occurrence.createdTime;
					if (occurrence.clearedTime != null) {
						previousClearedTime = occurrence.clearedTime ;
						countOfClearedOccurence = countOfClearedOccurence + 1;
						sumMttc = sumMttc + (occurrence.clearedTime - occurrence.createdTime);
					}
				}
				mOverAllDuration = sumMttc;
				if (countOfClearedOccurence > 0 ) {
					mttc = sumMttc /countOfClearedOccurence;
				}
				if (mttcCount > 0) {
					mtbt = sumMtbt / mttcCount;
				}
			}
			noOfOccurrenceTillLstMnt = 0;
			if (alarmOccurenceTillLMonthList != null) {
				noOfOccurrenceTillLstMnt = alarmOccurenceTillLMonthList.size();
				previousClearedTime = 0;
				previousCreatedTime = 0;
				sumPmtbt = 0;
				sumPmttc = 0;
				countOfClearedOccurence = 0;
				acknowledgedDuration = 0;
				pttcCount = 0;
				for each index,occurrence in alarmOccurenceTillLMonthList {
					if (occurrence.acknowledgedTime != null) {
						tillLstMntAcknowledgedDuration = acknowledgedDuration + ( occurrence.acknowledgedTime - occurrence.createdTime);
					}
					if (previousClearedTime != 0) {
						if (previousClearedTime > occurrence.createdTime) {
							previousClearedTime = previousCreatedTime;
						}
						sumPmtbt = sumPmtbt + (occurrence.createdTime - previousClearedTime);
						pttcCount = pttcCount + 1;
					}
					previousCreatedTime = occurrence.createdTime;
					if (occurrence.clearedTime != null) {
						previousClearedTime = occurrence.clearedTime ;
						countOfClearedOccurence = countOfClearedOccurence + 1;
						sumMttc = sumMttc + (occurrence.clearedTime - occurrence.createdTime);
					}
				}
				mOverAllDuration = sumPmttc;
				if (countOfClearedOccurence > 0 ) {
					pmttc = sumPmttc /countOfClearedOccurence;
				}
				if (pttcCount > 0) {
					pmtbt = sumPmtbt / pttcCount;
				}
			}
			resMap = {};
			resMap[\"mtbt\"] = mtbt;
			resMap[\"timeToClear\"] = mOverAllDuration;
			resMap[\"mttc\"] = mttc;
			resMap[\"pmtbt\"] = pmtbt;
			resMap[\"previousMonthTimeToClear\"] = pmOverAllDuration;
			resMap[\"pmttc\"] = pmttc;
			resMap[\"noOfOccurrence\"] = noOfOccurrence;
			resMap[\"noOfOccurrenceTillLstMnt\"] = noOfOccurrenceTillLstMnt;
			resMap[\"tillLstMntAcknowledgedDuration\"] = tillLstMntAcknowledgedDuration;
			resMap[\"acknowledgedDuration\"] =  acknowledgedDuration;
			log resMap;
			return resMap;
			}"
        },
		"99":{
			"description" : "mlpredictedEnergyWastage",
			"usage" : "AnomalySummary",
			"workflow": "Map calculateEnergyWastage(List resourceIds, Number alarmId){
			  resultMap = {};
			  lsMnRs = {};
			  mlReadings = Module(\"anomalydetectionmllogreadings\");
			  date = NameSpace(\"date\");
			  thisMonthRanges = date.getDateRange(\"Current Month\");
			  thisMonthStartTime = dateRange().getStartTime(thisMonthRanges);
			  thisMonthEndTime = dateRange().getEndTime(thisMonthRanges);
			  lastMonthRanges = date.getDateRange(\"Last Month\");
			  lastMonthStartTime = dateRange().getStartTime(lastMonthRanges);
			  lastMonthEndTime = dateRange().getEndTime(lastMonthRanges);
			
			  occurenceThisMonthCrit = {
			    criteria: [alarm == alarmId && createdTime < thisMonthEndTime && (clearedTime == null || clearedTime > thisMonthStartTime)]
			  };
			  occurenceLastMonthCrit = {
			    criteria: [alarm == alarmId && createdTime < lastMonthEndTime && (clearedTime == null || clearedTime > lastMonthStartTime)]
			  };
			  thismothoccurence =  Module(\"alarmoccurrence\").fetch(occurenceThisMonthCrit);
			  lastmonthoccurrence = Module(\"alarmoccurrence\").fetch(occurenceLastMonthCrit);
			  adjustedUpperBoundField = NameSpace(\"module\").getField(\"adjustedUpperBound\", \"anomalydetectionmllogreadings\");
			  result = {};
			  for each rindex,resourceId in resourceIds {
			    energyWastage = 0;
			    lstMntWastage= 0;
			    if (thismothoccurence != null) {
			      for each index,value in thismothoccurence {
			        startTime = value.createdTime;
			        if (value.createdTime < thisMonthStartTime) {
			          startTime = thisMonthStartTime;
			        }
			        endTime = value.clearedTime;
			        if (endTime == null) {
			          endTime = thisMonthEndTime;
			        }
			        ttimes = date.dateRange(startTime, endTime);
			        thisMonthEnergy = {
			          criteria: [parentId == resourceId && ttime == ttimes && adjustedUpperBound > 0 && actualValue > adjustedUpperBoundField],
			        };
			        currentMonthWastage =  mlReadings.fetch(thisMonthEnergy);
			        if (currentMonthWastage != null) {
			          for each index,value in currentMonthWastage {
			            energyWastage =  energyWastage + value.actualValue - value.adjustedUpperBound;
			          }
			        }
			      }
			    }
			    result[resourceId] = energyWastage;
			    if (lastmonthoccurrence != null) {
			      for each index,value in lastmonthoccurrence {
			        startTime = value.createdTime;
			        if (value.createdTime < lastMonthStartTime) {
			          startTime = lastMonthStartTime;
			        }
			        endTime = value.clearedTime;
			        if (endTime == null || endTime > lastMonthEndTime) {
			          endTime = lastMonthEndTime;
			        }
			        ttimes = date.dateRange(startTime, endTime);
			        lastMonthEnergy = {
			          criteria: [parentId == resourceId && ttime == ttimes && adjustedUpperBound > 0 && actualValue > adjustedUpperBoundField],
			        };
			        lastMonthWastage =  mlReadings.fetch(lastMonthEnergy);
			        if (lastMonthWastage != null) {
			          for each index,value in lastMonthWastage {
			            lstMntWastage =  lstMntWastage + value.actualValue - value.adjustedUpperBound;
			          }
			        }
			      }			   
			    }
			    lsMnRs[resourceId] = lstMntWastage;
			  }
			  resultMap[\"currentMonthWastage\"] = result;
			  resultMap[\"lastMonthWastage\"] = lsMnRs;
			  return resultMap;
			}"
		},
		"100" : {
        	"description" : "noOfAnomalies",
        	"usage" : "AnomalySummary",
        	"workflow": "Map test(List resourceIds, Number alarmId, Boolean isRCA){
			  date = NameSpace(\"date\");
			  thisMonthRanges = date.getDateRange(\"Current Month\");
			  lastMonthRanges = date.getDateRange(\"Last Month\");
			  alarmoccurrenceModule = Module(\"anomalyalarmoccurrence\");
			  occurenceThisMonthCrit = null;
			  occurenceLastMonthCrit = null;
			  resMap = {};
			  if (!isRCA) {
			    occurenceThisMonthCrit = {
			      criteria: [alarm == alarmId && createdTime == thisMonthRanges],
			      field: \"resource\",
			      aggregation: \"count,id\",
			      groupBy: \"resource\"
			    };
			    occurenceLastMonthCrit = {
			      criteria: [alarm == alarmId && createdTime == lastMonthRanges],
			      field: \"resource\",
			      aggregation: \"count, id\",
			      groupBy: \"resource\"
			    };
			  }
			  else {
			    occurenceThisMonthCrit = {
			      criteria: [parentAlarm == alarmId && resource == resourceIds && type == 2 && createdTime == thisMonthRanges],
			      field: \"resource\",
			      aggregation: \"count,id\",
			      groupBy: \"resource\"
			    };
			    occurenceLastMonthCrit = {
			      criteria: [parentAlarm == alarmId && resource == resourceIds && type == 2 && createdTime == lastMonthRanges],
			      field: \"resource\",
			      aggregation: \"count,id\",
			      groupBy: \"resource\"
			    };
			  }
			
			  thismothoccurence =  alarmoccurrenceModule.fetch(occurenceThisMonthCrit);
			  if (thismothoccurence != null) {
			    for each index,value in thismothoccurence {
			      res = resMap.get(value.result.id);
			      if (res == null) {
			        res = {};
			        resMap[value.result.id] = res;
			      }
			      res[\"anomaliesThisMonth\"] = value.id;
			    }
			  }
			  lastmothoccurence =  alarmoccurrenceModule.fetch(occurenceLastMonthCrit);
			  if (lastmothoccurence != null) {
			    for each index,value in lastmothoccurence {
			      res = resMap.get(value.result.id);
			      if (res == null) {
			        res = {};
			        resMap[value.result.id] = res;
			      }
			      res[\"anomaliesLastMonth\"] = value.id;
			    }
			  }
			  log resMap;
			  return resMap;
			}"
        },
        "101": {
        	"description" : "meanTimeBetweenTriggers",
        	"usage" : "rulesSummary",
        	"workflow": "Map getRuleTriggerDetials(Number ruleId) 
		    { 
		            cri = {
						criteria : [ruleId == ruleId && clearedTime > 0 ],
		        		orderBy : \"createdTime\" asc
					};
		            date = NameSpace(\"date\");
		            ranges = date.getDateRange(\"Last Month\");
		        	readingAlarmModule = Module(\"readingalarm\"); 
		        	res = readingAlarmModule.fetch(cri);
		            previousMonthDetails = readingAlarmModule.fetch([ruleId == ruleId  && createdTime == ranges]);
		            meanTimeBetweenTigger = 0;
		            timeToClear = 0;
		            meanTimeToClear = 0;
		            if (res != null) {
		                firstRes =res[0];
		                previousClearedTime = 0 ;
		                if (firstRes.clearedTime != null ) {
		                  previousClearedTime = firstRes.createdTime;
		                }
		                meanTimeToTriggerSize = 0;
		                for each index,value in res {
							if(index > 0) {
		                        if (value != null) {
		                            createdTime = value.createdTime;
                                  if (createdTime > previousClearedTime) {
                                  		meanTimeToTriggerSize  = meanTimeToTriggerSize + 1;
                                   		meanTimeBetweenTigger = meanTimeBetweenTigger + (createdTime - previousClearedTime); 
                                  }
		      						if (value.createdTime != null) {
		      							previousClearedTime = value.createdTime ;
		      						
		      						}
		                        }                                
							}
		                }
					    meanTimeBetweenTigger = meanTimeBetweenTigger / meanTimeToTriggerSize;	
		                for each index,value in res {
					        if(index > 0) {
		                        if (value != null) {
		      				        timeToClear = timeToClear + (value.clearedTime - value.createdTime); 
		                        }                                
					        }
		                } 
		                 meanTimeToClear =   timeToClear / res.size();
		            }
		            previousMonthMeanTimeBetweenTigger = 0;
		            previousMonthTimeToClear = 0;
		            previousMonthmeanTimeToClear = 0;
                	previousMonthClearedTime = 0;
		            if (previousMonthDetails != null ) {
		                previousRes =previousMonthDetails[0];
                      if (previousRes.clearedTime != null ) {
                        previousMonthClearedTime = previousRes.clearedTime;
                      }
		                for each index,value in previousMonthDetails {
						    if(index > 0) {
		                        if (value != null) {
		                            createdTime = value.createdTime;
		      						previousMonthMeanTimeBetweenTigger = previousMonthMeanTimeBetweenTigger + (createdTime -previousMonthClearedTime); 
                                  if (value.clearedTime  != null ) {
                                    previousMonthClearedTime = value.clearedTime ;
                                  }
		                        }                                
							}
		                }
						previousMonthMeanTimeBetweenTigger = previousMonthMeanTimeBetweenTigger / previousMonthDetails.size();
		                for each index,value in previousMonthDetails {
							if(index > 0) {
		                        if (value != null) {
                                  previousCreatedTime = 0;
                                  previousClearedTime = 0;
                                  if (value.clearedTime != null) {
                                    previousClearedTime = value.clearedTime;
                                  } 
                                  if (value.createdTime != null) {
                                    previousCreatedTime = value.createdTime;

                                  }
		      						previousMonthTimeToClear = previousMonthTimeToClear + (previousClearedTime - previousCreatedTime); 
		                        }                                
							}
		                } 
		                previousMonthmeanTimeToClear =   previousMonthTimeToClear / previousMonthDetails.size();
		            }
					resMap = {};
		            resMap[\"mtbt\"] = meanTimeBetweenTigger;
		            resMap[\"timeToClear\"] = timeToClear;
		            resMap[\"mttc\"] = meanTimeToClear;
		            resMap[\"pmtbt\"] = previousMonthMeanTimeBetweenTigger;
		            resMap[\"previousMonthTimeToClear\"] = previousMonthTimeToClear;
		            resMap[\"pmttc\"] = previousMonthmeanTimeToClear;
              		log resMap;
		         	return resMap;
		        
		    }"
        },
        "102" : {
        	"description" : "ruleAlarmsDetails",
        	"usage" : "rulesSummary",
        	"workflow": "Map alarmDetails(Number ruleId)
				{
					clearCondition = {
						criteria :[severity == \"Clear\" ]
					};
					date = NameSpace(\"date\");
					ranges = date.getDateRange(\"Current Week\");
					monthRanges = date.getDateRange(\"Current Month\");
					alarmsCurrWeekCri = {
						criteria : [ruleId == ruleId && createdTime == ranges ]
					};
					alarmCurrentWeekResourceCri = {
						criteria : [ruleId == ruleId && createdTime == ranges ],
						groupBy: \"resource\"
					};
					alarmSevrityModule = Module(\"alarmseverity\");
					clearSeverityContext = alarmSevrityModule.fetch(clearCondition);
					clearId = clearSeverityContext.get(0).get(\"id\");
					activeAssetcri = {
						criteria : [ruleId == ruleId && severity != clearId  ]
					};
					readingAlarmModule = Module(\"readingalarm\");
					workOrderModule = Module(\"ticket\");
					activeRecord = readingAlarmModule.fetch(activeAssetcri);
					activeAlarms = 0;
					activeAlarmResources = [];
					if (activeRecord != null) {
						for each index,value in activeRecord {
						if (value != null) {
							if (value.get(\"resource\") != null) {
 								activeAlarmResources.add(value.get(\"resource\").get(\"id\"));
							}
						}
					}
					activeAlarms = activeRecord.size();
					}
					currWeekAlarmRec = readingAlarmModule.fetch(alarmsCurrWeekCri);
					currWeekAlarms = 0;
					alarmThisWeekResources = [];
					if (currWeekAlarmRec != null) {
						currWeekAlarms = currWeekAlarmRec.size();
					}
					curretweekResourceRec = readingAlarmModule.fetch(alarmCurrentWeekResourceCri);
					if (curretweekResourceRec != null) {
						for each index,value in curretweekResourceRec {
							if (value != null) {
								if (value.get(\"resource\") != null) {
								alarmThisWeekResources.add(value.get(\"resource\").get(\"id\"));
								}
							}
						}
					}
					resultMap = {};
					resultMap[\"activeAlarms\"] = activeAlarms;
					resultMap[\"alarmRuleThisWeek\"] = currWeekAlarms;
					resultMap[\"activeAlarmResources\"] = activeAlarmResources;
					resultMap[\"alarmThisWeekResources\"] = alarmThisWeekResources;
					return resultMap;
				}"
        },
          "103" : {
        	"description" : "ruleWoDetails",
        	"usage" : "rulesSummary",
        	"workflow": "Map ruleWoDetails(Number ruleId) {
		    date = NameSpace(\"date\");
		        ranges = date.getDateRange(\"Current Week\");
		          monthRanges = date.getDateRange(\"Current Month\");
		            alarmsCurrWeekCri = {
		              criteria: [ruleId == ruleId && createdTime == ranges]
		            }; readingAlarmModule = Module(\"readingalarm\");
		              workOrderModule = Module(\"workorder\");
		                woThisWeek = {
		                  criteria: [ruleId == ruleId && createdTime == ranges && woId != null],
		                  groupBy: \"woId\",
		                };
		
		                currWeekWo = readingAlarmModule.fetch(woThisWeek); currentWeekWo = 0; currentWeekWoId = [];
		                if (currWeekWo != null) {
		                  currentWeekWo = currWeekWo.size();
		                  for each index, value in currWeekWo {
		                    if (value != null) {
		                      currentWeekWoId.add(value.get(\"woId\"));
		                     }
		                  }
		                }
		               woThisMonth = {
		                 criteria: [ruleId == ruleId && createdTime == monthRanges && woId != null],
		                 groupBy: \"woId\",
		               };
                      monthWO = readingAlarmModule.fetch(woThisMonth);
                      currentMonthWo = 0;
                      currentMonthWoID = [];
                      if (monthWO != null) {
                        currentMonthWo = monthWO.size();
                        for each index, value in monthWO {
                            if (value != null) {
                              	   currentMonthWoID.add(value.get(\"woId\"));
                                }
                              }
                            }
                            ticketContextRespondTime = {
                              criteria: [id == currentMonthWoID && actualWorkStart > 0 ]
                            };
                            ticketContextResolutionTime = {
                              criteria: [id == currentMonthWoID && actualWorkDuration > 0 ]
                            };
                            ticketsResponse = workOrderModule.fetch(ticketContextRespondTime);
                            ticketsResolution = workOrderModule.fetch(ticketContextResolutionTime);
                            previousMonthresponseTime = 0;
                            previousMonthresolutionTime = 0;
                            if (ticketsResponse != null) {
                              b = ticketsResponse.size();
                              for each index, value in ticketsResponse {
                                      wd = (value.actualWorkStart - value.createdTime); previousMonthresponseTime = (previousMonthresponseTime + wd);
                                    }
                                    previousMonthresponseTime = previousMonthresponseTime / b;
                                  }
                                   if (ticketsResolution != null) {
                             		 c = ticketsResolution.size();
                             	    for each index, value in ticketsResolution {
                             	        pd = value.actualWorkDuration;
                                        previousMonthresolutionTime = (previousMonthresolutionTime + pd);

                                    }
                                    previousMonthresolutionTime = previousMonthresolutionTime / c;
                                  }
                                  resultMap = {};
                                  resultMap[\"currentMonthWo\"] = currentMonthWo;
                                  resultMap[\"currentWeekWo\"] = currentWeekWo;
                                  resultMap[\"currentWeekWoId\"] = currentWeekWoId;
                                  resultMap[\"currentMonthWoID\"] = currentMonthWoID;
                                  resultMap[\"previousMonthresponseTime\"] = previousMonthresponseTime;
                                  resultMap[\"previousMonthresolutionTime\"] = previousMonthresolutionTime;
                                  log resultMap;
                                  return resultMap;
			}"
        },
         "104" : {
        	"description" : "ruleRank",
        	"usage" : "ruleRank",
        	"workflow": "Map rankWorkflow (Number ruleId){
				  date = NameSpace(\"date\");
				   monthRanges = date.getDateRange(\"Current Year\");
				  db = {
						criteria : [createdTime == monthRanges],
					    field : \"ruleId\",
				    	aggregation : \"count, ruleId\",
				    	groupBy: \"ruleId\",
				    	orderBy : \"ruleId\" desc
					};
				    readingAlarmModule = Module(\"readingalarm\");
				    activeRecord = readingAlarmModule.fetch(db);
  					 ranking = 0;
  					if (activeRecord != null ) {
                       for each index,value in activeRecord { 
							temp = value.result;
                         temp = value.result+0;
                         if(temp == ruleId) {
        					ranking = index + 1;
                           log \"test -- \"+index;
                         }
                         
                         
                       }
                    }
          			resultMap = {};
          			if (activeRecord != null) {
          				resultMap[\"ranks\"] = activeRecord;
  						resultMap[\"ranking\"] = ranking;
						resultMap[\"outOfRule\"] = activeRecord.size();
          			}
				   	return resultMap;
				}"
        },
    "105": {
    	"description" : "assetMaintenanceCost",
        "usage" : "assetSummary",
        "workflow" : "Map maintenanceCost(Number assetId) 
        			  	{ 
        			  		 woModule = Module(\"workorder\"); 
						     date = NameSpace(\"date\");
							 ranges = date.getDateRange(\"Current Year\");
						     res = woModule.fetch([totalCost !=null && resource == assetId && createdTime == ranges]); 
						    
						     maintenanceCostThisYear = 0;
						     plannedMaintenanceCostThisYear = 0;
						     unplannedMaintenanceCostThisYear = 0;
						  if(res !=null) {
						      for each index,value in res{
						         if(value.sourceType == 5){
						           plannedMaintenanceCostThisYear = plannedMaintenanceCostThisYear + value.totalCost;
						         }
						         else{
						           unplannedMaintenanceCostThisYear = unplannedMaintenanceCostThisYear + value.totalCost;
						         }
						     } 
						  }
						     resMap = {};
						     resMap[\"plannedMaintenanceCostThisYear\"] = plannedMaintenanceCostThisYear;
						     resMap[\"unplannedMaintenanceCostThisYear\"] = unplannedMaintenanceCostThisYear;
						     resMap[\"maintenanceCostThisYear\"] = plannedMaintenanceCostThisYear + unplannedMaintenanceCostThisYear;
						     
						     maintenanceCostLastYear = 0;
						     plannedMaintenanceCostLastYear = 0;
						     unplannedMaintenanceCostLastYear = 0;
						     
						     ranges = date.getDateRange(\"Last Year\");
						     res = woModule.fetch([totalCost !=null && resource == assetId && createdTime == ranges]); 
						     if(res !=null) {
							      for each index,value in res{
							         if(value.sourceType == 5){
							           plannedMaintenanceCostLastYear = plannedMaintenanceCostLastYear + value.totalCost;
							         }
							         else{
							           unplannedMaintenanceCostLastYear = unplannedMaintenanceCostLastYear + value.totalCost;
							         }
							     } 
							  }
						 	 resMap[\"plannedMaintenanceCostLastYear\"] = plannedMaintenanceCostLastYear;
						     resMap[\"unplannedMaintenanceCostLastYear\"] = unplannedMaintenanceCostLastYear;
						     resMap[\"maintenanceCostLastYear\"] = plannedMaintenanceCostLastYear + unplannedMaintenanceCostLastYear;
						     
						     return resMap; 
        			  	}"
        },
    "106": {
    	"description" : "costWorkorderIds",
        "usage" : "assetSummary",
        "workflow" : "Map costWorkorderIds(Number assetId,Number costType) 
        			  	{ 
        			  		 woModule = Module(\"workorder\"); 
							 date = NameSpace(\"date\");
		                     ranges = date.getDateRange(\"Current Year\");
						    if(costType == 1){
						      crit= [resource == assetId && createdTime == ranges];
						    }else if(costType == 2){
						       crit= [resource == assetId && createdTime == ranges && sourceType == 5];
						    }else if(costType == 3){
						       crit= [resource == assetId && createdTime == ranges && sourceType != 5];
						    }
                             res = woModule.fetch(crit); 
                             ids = \"\";
                            if(res !=null) {
                            for each index,value in res{
                                ids = ids + value.id +\",\";
                                }
                            }
                           resMap = {};
                           resMap[\"workorderIds\"] = ids;
                           return resMap; 
        			  	}"
        },
       "107": {
			"description": "smartmap",
			"usage": "smart map data",
			"workflow": "Map smartMap (Map paramsMap) {
    if (markerValue.type == \"noOfWorkorders\") {
        ticketCriteria = {
            criteria: [typeCode == 2 && parentModuleId == markerValue.id]
        };
        closedStatus = Module(\"ticketstatus\").fetch(ticketCriteria)[0];

    }

    date = NameSpace(\"date\");
    fetchModule = Module(paramsMap.module);
    if (paramsMap.module == \"asset\") {
        records = fetchModule.fetch([geoLocation != null]);
    } else {
        records = fetchModule.fetch([location != null]);
    }

    locations = [];
    for each index, record in records {
        locationEntry = {};
        locationEntry[\"id\"] = record.get(\"id\");
        locationEntry[\"label\"] = record.get(\"name\");
        locationEntry[\"name\"] = record.get(\"name\");
        locationEntry[\"image\"] = \"url\";
        if (paramsMap.module == \"site\" || paramsMap.module == \"building\") {
            locationEntry[\"location\"] = Module(\"location\").fetch([id == record.location.id]);
        }
        if (paramsMap.module == \"asset\") {
            locationEntry[\"location\"] = record.geoLocation;
        }

        markerActualValue = null;
        if (paramsMap.markerValue.type == \"noOfAlarms\") {
            count = 0;
            if (paramsMap.module == \"asset\") {
                occurenceCount = {
                    criteria: [resource == record.id]
                    field: \"id\",
                    aggregation: \"count\"
                };
                alamcount1 = Module(\"alarm\").fetch(occurenceCount);
                if (alamcount1 != null) {
                    count = count + alamcount1;
                }
                markerActualValue = count;

            } else {
                db1 = {
                    criteria: [space == record.id]
                };
                result = Module(\"asset\").fetch(db1);
                if (result != null) {
                    for each index, value in result {
                        occurenceCount = {
                            criteria: [resource == value.id],
                            field: \"id\",
                            aggregation: \"count\"
                        };
                        alamcount = Module(\"alarm\").fetch(occurenceCount);
                        if (alamcount != null) {
                            count = count + alamcount;
                        }
                    }
                }

                markerActualValue = count;
            }


        } else if (paramsMap.markerValue.type == \"noOfWorkorders\") {
            db = {
                criteria: [resource == record.id && status != closedStatus.id]
                field: \"subject\",
                aggregation: \"count\"
            };
            markerActualValue = Module(\"workorder\").fetch(db);
        } else if (paramsMap.markerValue.type == \"noOfAssets\") {
            db = {
                criteria: [space == record.id]
                field: \"id\",
                aggregation: \"count\"
            };
            markerActualValue = Module(\"asset\").fetch(db);
        } else if (paramsMap.markerValue.type == \"reading\") {

        }
        if (markerActualValue == null) {
            markerActualValue = 0;
        }
        locationEntry[\"markerValue\"] = markerActualValue;
        locations.add(locationEntry);
    }

    resultMap = {};
    resultMap[\"locations\"] = locations;
    return resultMap;
}"
}
    "108": {
    	"description" : "overallAlarmDuration",
        "usage" : "alarmSummary",
        "workflow" : "Map overallAlarmDuration(Number alarmId,Number cardId) 
        			  	{ 
        			  	module = Module(\"alarmoccurrence\"); 
						     date = NameSpace(\"date\");
							 thisMonthRange = date.getDateRange(\"Current Month\");
						     lastMonthRange = date.getDateRange(\"Last Month\");
						     
        			  	     resMap = {};
						     if(cardId == 1){
	        			  	  	db = {
								    criteria : [alarm == alarmId && createdTime == thisMonthRange],
								    field : \"alarm\",
								    aggregation : \"count\"
								  };
								  
							     res = module.fetch(db); 
							     thisMonth = res;
							     db = {
								    criteria : [alarm == alarmId && createdTime == lastMonthRange],
								    field : \"alarm\",
								    aggregation : \"count\"
								  };
								  res = module.fetch(db); 
							      LastMonth = res;
							      
						       	  resMap[\"noOfOcc\"] = thisMonth;
								  resMap[\"noOfOccLastMonth\"] = LastMonth;
							  }else if(cardId == 2) {
							      db = {
								    criteria : [alarm == alarmId && createdTime == thisMonthRange],
								    field : \"duration\",
								    aggregation : \"avg\"
								  };
								  
							     res = module.fetch(db); 
							     thisMonth = res;
							     db = {
								    criteria : [alarm == alarmId && createdTime == lastMonthRange],
								    field : \"duration\",
								    aggregation : \"avg\"
								  };
								  res = module.fetch(db); 
							      LastMonth = res;
	
						       	  resMap[\"mttc\"] = thisMonth;
								  resMap[\"mttcLastMonth\"] = LastMonth;
							  }else if(cardId == 3) {
							     db = {
										criteria: [alarm == alarmId && createdTime == thisMonthRange],
										field:\"timeBetweeenOccurrence\",
								        aggregation : \"avg\"
									};
									res = module.fetch(db); 
							        thisMonth = res;
									db = {
										criteria: [alarm == alarmId && createdTime == lastMonthRange],
										field:\"timeBetweeenOccurrence\",
										aggregation : \"avg\"
									};
									res = module.fetch(db); 
							        LastMonth = res;
						       	  resMap[\"mtba\"] = thisMonth;
								  resMap[\"mtbaLastMonth\"] = LastMonth;
							  }
						     return resMap; 
        			  	}"
        }
        
}