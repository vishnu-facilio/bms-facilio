'0':
  description: 'sample'
  usage: 'test'
  workflow: 'Number getCubeOf(Number i)
                   {
                   		return i * i * i;
                   }'
'1': 
   description: 'woAverageResponseTime'
   usage: 'pmSummary'
   workflow: 'Map test(Number pmId) 
     			  	{ 
     			  		woModule = Module("workorder"); 
     			  		res = woModule.fetch([pm == pmId && actualWorkStart > 0]); 
     			  		if (res == null) 
     			  		{ 
     			  			return null; 
     			  		} 
							date = new NameSpace("date");
 						temp = date.getPreviousMonthEndDate();
							previousMonthRes = woModule.fetch([pm == pmId && actualWorkStart > 0 && createdTime <= temp]);
							previousMonthresponseTime = 0; 
							if (previousMonthRes != null) {	
	        			  		b = previousMonthRes.size(); 
	                            for each index,value in previousMonthRes { 
	        			  			wd =  (value.actualWorkStart - value.createdTime); 
	        			  			previousMonthresponseTime = (previousMonthresponseTime + wd);
	        			  		}
                             previousMonthresponseTime = previousMonthresponseTime/b; 
                         }
     			  		responseTime = 0; 
     			  		a = res.size(); 
     			  		for each index,value in res { 
     			  			wd =  (value.actualWorkStart - value.createdTime); 
     			  			responseTime = (responseTime + wd);
     			  		} 
     			  		responseTime = responseTime/a; 
                         resMap = {};
                         resMap["responseTime"] = responseTime;
                         resMap["previousMonthresponseTime"] = previousMonthresponseTime;
      					return resMap; 
     			  	}'
'54':
  description: 'energy star score average'
  usage: 'energy star main summary'
  workflow: 'Number scoreAvg() {
              db = {
                criteria : [score != null],
                field : "score",
                aggregation : "avg",
              };
              return Module("energyStarPropertyData").fetch(db);
            }'
'55':
  description: 'energy star energy consumption card'
  usage: 'energy star property summary'
  workflow: 'Map energyCons(Number meterId,Number lastDataRecivedTime,Number baseline){
  
                 st = new NameSpace("date").getMonthStartTime(lastDataRecivedTime);
                 et = new NameSpace("date").getMonthEndTime(lastDataRecivedTime);
                 
                 max = 0;
                 db = {
                   	criteria : [parentId == meterId && ttime >= st && ttime <=et],
                   	field : "totalEnergyConsumptionDelta",
                   	aggregation : "sum",
                 };
                 
                 current = Module("energydata").fetch(db);
                 
                 if(current > max) {
                   max = current;
                 }
                 
                 if(baseline != null) {
                   st = new NameSpace("date").getMonthStartTime(baseline);
                   et = new NameSpace("date").getMonthEndTime(baseline);
                 
                  db = {
                   	criteria : [parentId == meterId && ttime >= st && ttime <=et],
                   	field : "totalEnergyConsumptionDelta",
                   	aggregation : "sum",
                  };
                 
                   baseline = Module("energydata").fetch(db);
                   if(baseline > max) {
                   	max = baseline;
                   }
                 }
                 res = {};
                 res.current = current;
                 res.baseline = baseline;
                 res.maxValue = max;
                 return res;
               }'

'199':
  description: 'check in check out weekly digest'
  usage: 'week digest'
  workflow: 'Map weeklyDigest() {
              result = {};
  math = new NameSpace("math");
  date = new NameSpace("date"); 
  dateRange = new NameSpace("dateRange"); 
  
  thisWeek = date.getDateRange("Current Week");
  startTime = (thisWeek.getStartTime() - (86400000 * 3));
  endTime = (thisWeek.getEndTime() - (86400000 * 3));

  thisWeek = dateRange().create(startTime, endTime);
  
  lastWeek = date.getDateRange("Last Week");
  lastWeekstartTime = (lastWeek.getStartTime() - (86400000 * 3));
  lastWeekendTime = (lastWeek.getEndTime() - (86400000 * 3));
  
  lastWeek = dateRange().create(lastWeekstartTime, lastWeekendTime);
  
  result.startTime = date().getFormattedTime(startTime,"dd-MM-yyyy");
  result.endTime = date().getFormattedTime(endTime,"dd-MM-yyyy");
  result.lastWeekstartTime = date().getFormattedTime(lastWeekstartTime,"dd-MM-yyyy");
  result.lastWeekendTime = date().getFormattedTime(lastWeekendTime,"dd-MM-yyyy");

  now = date.now();
  moduleId = 98566;
  
  db = {
    criteria: [parentModuleId == moduleId && typeCode == 1],
    field: "id"
  }; 
  openticketStatus = Module("ticketstatus").fetch(db); 	
  db = {
        criteria: [parentModuleId == moduleId && typeCode == 2],
    field: "id"
  }; 
  closeticketStatus = Module("ticketstatus").fetch(db); 	
  holdticketStatus = [13410];
  db = {
        criteria: [category == 2004],
        field: "id",
        aggregation: "count"
  }; 
  result.totalWorkorder = Module("workorder").fetch(db); 
  db = {
        criteria: [category == 2004 && moduleState != null && moduleState == closeticketStatus],
        field: "id",
        aggregation: "count"
  };  
  result.totalClosedWorkorder = Module("workorder").fetch(db); 
  db = {
        criteria: [category == 2004 && moduleState != null && moduleState == closeticketStatus],
        field: "actualWorkDuration",
        aggregation: "avg"
  };  
  avgSeconds = Module("workorder").fetch(db);
  result.totalWoAvgComp = 0;
      if (avgSeconds != null){
      avgMin = date.secToHour(avgSeconds);
      avgdays = date.hourToDay(avgMin);
      result.totalWoAvgComp = math().setPrecision(avgdays, 0);
      }
  db = {
        criteria: [category == 2004 && createdTime == thisWeek && moduleState != null && moduleState == closeticketStatus],
        field: "actualWorkDuration",
        aggregation: "avg"
  };  
  avgSeconds = Module("workorder").fetch(db);
  result.totalWoAvgCompThisWeek = 0;
      if (avgSeconds != null){
      avgMin = date.secToHour(avgSeconds);
      avgdays = date.hourToDay(avgMin);
      result.totalWoAvgCompThisWeek = math().setPrecision(avgdays, 0);
      }
      result.totalWoAvgCompThisWeekValue = avgMin;
  db = {
        criteria: [category == 2004 && createdTime == lastWeek && moduleState != null && moduleState == closeticketStatus],
        field: "actualWorkDuration",
        aggregation: "avg"
  };  
  avgSeconds = Module("workorder").fetch(db);
  result.totalWoAvgCompLastWeek = 0;
      if (avgSeconds != null) {
      avgMin = date.secToHour(avgSeconds);
      avgdays = date.hourToDay(avgMin);
      result.totalWoAvgCompLastWeek = math().setPrecision(avgdays, 0);
      }
      result.totalWoAvgCompLastWeekValue = avgMin;
   db = {
        criteria: [category == 2004 && createdTime == thisWeek && moduleState != null && moduleState == closeticketStatus],
        field: "actualWorkDuration",
  }; 
  list =  Module("workorder").fetch(db);
  result.maxdaysThisWeek = 0;
  result.mindaysThisWeek = 0;
        if (list != null) {
        max = 0;
        min = list[0];
            for each index,value in list{
              if ( max < value ) {
                  max = value;
              }
              if (value < min) {
                min = value;
             }
            }
        maxMinu = date.secToHour(max);
        maxdays = date.hourToDay(maxMinu);
        result.maxdaysThisWeek = math().setPrecision(maxdays, 0);
        minMinu = date.secToHour(min);
        mindays = date.hourToDay(minMinu);
        result.mindaysThisWeek = math().setPrecision(mindays, 0);
        }
  
  db = {
        criteria: [category == 2004 && createdTime == lastWeek && moduleState != null && moduleState == closeticketStatus],
        field: "actualWorkDuration",
  }; 
  list =  Module("workorder").fetch(db);
  result.maxdaysLastWeek = 0;
  result.mindaysLastWeek = 0;
        if (list != null) {
        max = 0;
        min = list[0];
            for each index,value in list{
              if ( max < value ) {
                  max = value;
              }
              if (value < min) {
                min = value;
             }
            }
        maxMinu = date.secToHour(max);
        maxdays = date.hourToDay(maxMinu);
        result.maxdaysLastWeek = math().setPrecision(maxdays, 0);
        minMinu = date.secToHour(min);
        mindays = date.hourToDay(minMinu);
        result.mindaysLastWeek = math().setPrecision(mindays, 0);
        }

  db = {
        criteria: [category == 2004 && createdTime == thisWeek],
        field: "id",
        aggregation: "count"
  }; 
  result.totalWorkordersThisWeek = Module("workorder").fetch(db);
  db = {
         criteria: [category == 2004 && createdTime == thisWeek && moduleState == 13410],
         field: "id",
         aggregation: "count"
  }; 
  result.totalWoOnHoldThisWeek = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0) {
      result.totalWoOnHoldThisWeek = ((Module("workorder").fetch(db)/result.totalWorkordersThisWeek)*100);
  }
  



  db = {
         criteria: [picklist == 2],
    	 field: "id"
  }; 
  buildings = Module("building").fetch(db);
   db = {
        criteria: [category == 2004 && resource == buildings],
     	field: "id",
        aggregation: "count"
  };
  result.totalAlWahaibiWo = Module("workorder").fetch(db);
  total = Module("workorder").fetch(db);
  
  db = {
        criteria: [category == 2004 && actualWorkStart == thisWeek && resource == buildings && moduleState != null && moduleState == openticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalAlWahaibiWoOpen = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalAlWahaibiWoOpen = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalAlWahaibiWoOpen > 0) {
        result.totalAlWahaibiWoOpen = math().setPrecision(result.totalAlWahaibiWoOpen, 0); 
      }
  }
  
   db = {
        criteria: [category == 2004 && resource == buildings && moduleState != null && moduleState == holdticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalAlWahaibiWoClose = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalAlWahaibiWoClose = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalAlWahaibiWoClose > 0) {
        result.totalAlWahaibiWoClose = math().setPrecision(result.totalAlWahaibiWoClose, 0); 
      }
  }

  db = {
        criteria: [category == 2004 && resource == buildings && moduleState != null && moduleState == closeticketStatus],
        field: "actualWorkDuration",
        aggregation: "avg"
  };  
  avgSeconds = Module("workorder").fetch(db);
  result.totalAlWahaibiWoAvgComp = 0;
      if (avgSeconds != null){
      avgMin = date.secToHour(avgSeconds);
      avgdays = date.hourToDay(avgMin);
      result.totalAlWahaibiWoAvgComp = math().setPrecision(avgdays, 0);
      }

  db = {
         criteria: [picklist == 3],
    	 field: "id"
  }; 
  buildings = Module("building").fetch(db);
   db = {
        criteria: [category == 2004 && resource == buildings],
     	field: "id",
        aggregation: "count"
  };
  result.totalBdPropertiesWo = Module("workorder").fetch(db);
  
  total = Module("workorder").fetch(db);
  
  db = {
        criteria: [category == 2004 && actualWorkStart == thisWeek && resource == buildings && moduleState != null && moduleState == openticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalBdPropertiesWoOpen = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalBdPropertiesWoOpen = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalBdPropertiesWoOpen > 0) {
        result.totalBdPropertiesWoOpen = math().setPrecision(result.totalBdPropertiesWoOpen, 0); 
      }
  }
  
   db = {
        criteria: [category == 2004 && resource == buildings && moduleState != null && moduleState == holdticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalBdPropertiesWoClose = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalBdPropertiesWoClose = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalBdPropertiesWoClose > 0) {
        result.totalBdPropertiesWoClose = math().setPrecision(result.totalBdPropertiesWoClose, 0); 
      }
  }

  db = {
        criteria: [category == 2004 && resource == buildings && moduleState != null && moduleState == closeticketStatus],
        field: "actualWorkDuration",
        aggregation: "avg"
  };  
  avgSeconds = Module("workorder").fetch(db);
  result.totalBdPropertiesWoAvgComp = 0;
      if (avgSeconds != null){
      avgMin = date.secToHour(avgSeconds);
      avgdays = date.hourToDay(avgMin);
      result.totalBdPropertiesWoAvgComp = math().setPrecision(avgdays, 0);
      }

  db = {
         criteria: [picklist == 1],
    	 field: "id"
  }; 
  buildings = Module("building").fetch(db);
   db = {
        criteria: [category == 2004 && resource == buildings],
     	field: "id",
        aggregation: "count"
  };
  result.totalAmPropertiesWo = Module("workorder").fetch(db);
   
  total = Module("workorder").fetch(db);
  
  db = {
        criteria: [category == 2004 && actualWorkStart == thisWeek && resource == buildings && moduleState != null && moduleState == openticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalAmPropertiesWoOpen = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalAmPropertiesWoOpen = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalAmPropertiesWoOpen > 0) {
        result.totalAmPropertiesWoOpen = math().setPrecision(result.totalAmPropertiesWoOpen, 0); 
      }
  }
  
   db = {
        criteria: [category == 2004 && resource == buildings && moduleState != null && moduleState == holdticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalAmPropertiesWoClose = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalAmPropertiesWoClose = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalAmPropertiesWoClose > 0) {
        result.totalAmPropertiesWoClose = math().setPrecision(result.totalAmPropertiesWoClose, 0); 
      }
  }

  db = {
        criteria: [category == 2004 && resource == buildings && moduleState != null && moduleState == closeticketStatus],
        field: "actualWorkDuration",
        aggregation: "avg"
  };  
  avgSeconds = Module("workorder").fetch(db);
  result.totalAmPropertiesWoAvgComp = 0;
      if (avgSeconds != null){
      avgMin = date.secToHour(avgSeconds);
      avgdays = date.hourToDay(avgMin);
      result.totalAmPropertiesWoAvgComp = math().setPrecision(avgdays, 0);
      }

  db = {
         criteria: [picklist == 5],
    	 field: "id"
  }; 
  buildings = Module("building").fetch(db);
   db = {
        criteria: [category == 2004 && resource == buildings],
     	field: "id",
        aggregation: "count"
  };
  result.totalEqaratPropertiesWo = Module("workorder").fetch(db);
  total = Module("workorder").fetch(db);
  
  db = {
        criteria: [category == 2004 && actualWorkStart == thisWeek && resource == buildings && moduleState != null && moduleState == openticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalEqaratPropertiesWoOpen = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalEqaratPropertiesWoOpen = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalEqaratPropertiesWoOpen > 0) {
        result.totalEqaratPropertiesWoOpen = math().setPrecision(result.totalEqaratPropertiesWoOpen, 0); 
      }
  }
   db = {
        criteria: [category == 2004 && resource == buildings && moduleState != null && moduleState == holdticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalEqaratPropertiesWoClose = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalEqaratPropertiesWoClose = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalEqaratPropertiesWoClose > 0) {
        result.totalEqaratPropertiesWoClose = math().setPrecision(result.totalEqaratPropertiesWoClose, 0); 
      }
  }

   db = {
        criteria: [category == 2004 && resource == buildings && moduleState != null && moduleState == closeticketStatus],
        field: "actualWorkDuration",
        aggregation: "avg"
  };  
  avgSeconds = Module("workorder").fetch(db);
  result.totalEqaratPropertiessWoAvgComp = 0;
      if (avgSeconds != null){
      avgMin = date.secToHour(avgSeconds);
      avgdays = date.hourToDay(avgMin);
      result.totalEqaratPropertiessWoAvgComp = math().setPrecision(avgdays, 0);
      }

  db = {
         criteria: [picklist == 4],
    	 field: "id"
  }; 
  buildings = Module("building").fetch(db);
   db = {
        criteria: [category == 2004 && resource == buildings],
     	field: "id",
        aggregation: "count"
  };
  result.totalDgPropertiesWo = Module("workorder").fetch(db);

  total = Module("workorder").fetch(db);
  
  db = {
        criteria: [category == 2004 && actualWorkStart == thisWeek && resource == buildings && moduleState != null && moduleState == openticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalDgPropertiesWoOpen = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalDgPropertiesWoOpen = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalDgPropertiesWoOpen > 0) {
        result.totalDgPropertiesWoOpen = math().setPrecision(result.totalDgPropertiesWoOpen, 0); 
      }
  }
  
   db = {
        criteria: [category == 2004&& resource == buildings && moduleState != null && moduleState == holdticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalDgPropertiesWoClose = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalDgPropertiesWoClose = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalDgPropertiesWoClose > 0) {
        result.totalDgPropertiesWoClose = math().setPrecision(result.totalDgPropertiesWoClose, 0); 
      }
  }

  db = {
        criteria: [category == 2004 && resource == buildings && moduleState != null && moduleState == closeticketStatus],
        field: "actualWorkDuration",
        aggregation: "avg"
  };  
  avgSeconds = Module("workorder").fetch(db);
  result.totalDgPropertiessWoAvgComp = 0;
      if (avgSeconds != null){
      avgMin = date.secToHour(avgSeconds);
      avgdays = date.hourToDay(avgMin);
      result.totalDgPropertiessWoAvgComp = math().setPrecision(avgdays, 0);
      }

   db = {
        criteria: [category == 2004],
     	field: "id",
        aggregation: "count"
  };
  result.totalWoInProperties = Module("workorder").fetch(db);
  
  total = Module("workorder").fetch(db);
  
  db = {
        criteria: [category == 2004 && actualWorkStart == thisWeek && moduleState != null && moduleState == openticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalOpenWoInProperties = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalOpenWoInProperties = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalOpenWoInProperties > 0) {
        result.totalOpenWoInProperties = math().setPrecision(result.totalOpenWoInProperties, 0); 
      }
  }
  
   db = {
        criteria: [category == 2004 && moduleState != null && moduleState == holdticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalClosedWoInProperties = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalClosedWoInProperties = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalClosedWoInProperties > 0) {
        result.totalClosedWoInProperties = math().setPrecision(result.totalClosedWoInProperties, 0); 
      }
  }

    db = {
        criteria: [category == 2004 && moduleState != null && moduleState == closeticketStatus],
        field: "actualWorkDuration",
        aggregation: "avg"
  };  
  avgSeconds = Module("workorder").fetch(db);
  result.totalAllWoAvgComp = 0;
      if (avgSeconds != null){
      avgMin = date.secToHour(avgSeconds);
      avgdays = date.hourToDay(avgMin);
      result.totalAllWoAvgComp = math().setPrecision(avgdays, 0);
  }

  buildingsList = Module("building").fetch([id != null]);
  buildings = [];
  alWahaibiList = [];
  bipinDharamseyNensey = [];
  ahmedBinAbdulNabiMack = [];
  aliHussainAlRahma = [];
  akramZarrouf = [];
  remainingList = [];
  buildingVsUnitList = [];
  buildingVsUnitFirstItem = [];
  buildingVsUnitListForClosed = [];
  buildingVsUnitFirstItemForClosed = [];
        if (buildingsList != null) {
              for each index,value in buildingsList{  
                buildingVsMap = {};
                mapObj = {};
                building = {};
                building.id = value.id;
                building.name = value.name;      
                db = {
                  criteria: [category == 2004 && resource == value.id],
                  field: "id",
                  aggregation: "count"
                };
                totalWo = Module("workorder").fetch(db);
                if (totalWo > 0) {
                  building.totalWo = Module("workorder").fetch(db);
                db = {
                  criteria: [category == 2004 && resource == value.id && moduleState != null && moduleState == closeticketStatus],
                  field: "id",
                  aggregation: "count"
                };      
                building.totalClosedWo = Module("workorder").fetch(db);
                db = {
                criteria: [category == 2004 && resource == value.id && moduleState != null && moduleState == closeticketStatus],
                field: "actualWorkDuration",
                aggregation: "avg"
  				};  
                avgSec = Module("workorder").fetch(db);
                building.WoAvgComp = 0;               
                if (avgSec != null && avgSec > 0){
                avgMinu = date.secToHour(avgSec);
                avgday = date.hourToDay(avgMinu);
                building.WoAvgComp = math().setPrecision(avgday, 0);   
                }
                
                   if (value.client != null) {
                if (value.client.id == 11) {
                  alWahaibiList.push(building);
                }else if (value.client.id == 12) {
                  bipinDharamseyNensey.push(building);
                }else if (value.client.id == 13) {
                  ahmedBinAbdulNabiMack.push(building);
                }else if (value.client.id == 14) {
                  aliHussainAlRahma.push(building);
                }else if (value.client.id == 15) {
                  akramZarrouf.push(building);
                }
                }else {
                  remainingList.push(building);
                }
            
                
                db = {
                criteria: [category == 2004 && resource == value.id && moduleState != null && moduleState == openticketStatus],
  				};  
  				openWorkorders = Module("workorder").fetch(db);
                  if (openWorkorders != null){
                    unitList = [];
                      for each ind,wo in openWorkorders{
                        obj = {};
                        daysInOpen = 0;
                           if (wo.unit != null){
                              db = {
                                criteria: [id == wo.unit.id],
                              };
                           unitArr = Module("tenantunit").fetch(db);
                           unitObj = unitArr[0];

                             if (wo.date != null){
                               obj.date = date().getFormattedTime(wo.date,"dd-MM-yyyy");
                               constFiveDays = 432000000;
                               handOver = (wo.date + constFiveDays);
                               obj.handOverDate = date().getFormattedTime(handOver,"dd-MM-yyyy");
                               daysInOpen = (now - wo.date)/86400000;
                               if (wo.actualWorkDuration > 0) {
                                 actualWorkDurationInMs = (wo.actualWorkDuration * 1000);
                                 resolvedTime = (wo.actualWorkStart + actualWorkDurationInMs);
                                 daysInOpen = (resolvedTime - wo.date)/86400000;
                               }
                             }    
                             
                             if (daysInOpen == null) {
                                 daysInOpen = (now - wo.actualWorkStart)/86400000; 
                             }
                             
                             if (daysInOpen == null) {
                             obj.daysInOpen = 0;
                             }else {
                               obj.daysInOpen = math().setPrecision(daysInOpen, 0);
                             }
                    
                             
                           if (wo.actualWorkDuration > 0 && handOver > 0) {
                             actualWorkDurationInMs = (wo.actualWorkDuration * 1000);
                             resolvedTime = (wo.actualWorkStart + actualWorkDurationInMs);
                             
                             resolvedTimeInSec = (resolvedTime/1000);
                             handOverInSec = (handOver/1000);
                             
                             if (resolvedTimeInSec > handOverInSec) {
                             variationInSec = (resolvedTimeInSec - handOverInSec);
                             inHr = date.secToHour(variationInSec);
      						           inDays = date.hourToDay(inHr);
                             obj.variationindays = math().setPrecision(inDays, 0);
                             obj.variation = "+" + math().setPrecision(inDays, 0);
                             }
                             else {
                             variationInSec = (handOverInSec - resolvedTimeInSec);
                             inHr = date.secToHour(variationInSec);
      						           inDays = date.hourToDay(inHr);
                             obj.variationindays = math().setPrecision(inDays, 0);
                             obj.variation = "-" + math().setPrecision(inDays, 0);
                             }
                           
                             startDate = date().getFormattedTime(wo.actualWorkStart,"dd-MM-yyyy");
                             resolvedDate = date().getFormattedTime(resolvedTime,"dd-MM-yyyy");
          
                         
                           }
                           else if ( handOver > 0  &&  obj.daysInOpen > 0) {
                             if (daysInOpen > 5) {
                               indays = (daysInOpen - 5);
                               obj.variationindays = math().setPrecision(indays, 0);
                               obj.variation = "+" + math().setPrecision(indays, 0);
                             }else if (daysInOpen > 0 && daysInOpen < 5) {
                               indays = (5 - daysInOpen);
                               obj.variationindays = math().setPrecision(indays, 0);
                               obj.variation = "-" + math().setPrecision(indays, 0);
                             }
                           }

                            dbCri = {
        						          criteria: [parent == wo.id && fromStatus == 13410],
 								             }; 
                              now = date.now();
                             duration = 0;
                             if (Module("workorderTimeLog").fetch(dbCri) != null) {
                               timelogs = Module("workorderTimeLog").fetch(dbCri);
                                for each index,timelog in timelogs{
                                  if (timelog.duration != null) {
                                    duration = (duration + timelog.duration);
                                  }
                                  else {
                                  
                                  milliSec = (now - timelog.startTime);
                                  inSec = (milliSec/1000);
                                  duration = (duration + inSec);
                                }        
                                }
                               
                               inHr = date.secToHour(duration);
                                inDays = date.hourToDay(inHr);
                               duration = math().setPrecision(inDays, 0);
                             }         
                           
                           obj.onHoldDuration = duration;
                           
                           obj.unitName = unitObj.name;
                           unitList.push(obj);
                           }
                        
                      }
                        if (unitList != []) {
                          mapObj["lists"] = unitList;
                          mapObj["name"] = building.name;
                        
                         if (mapObj != null && firstItemopen == null) {
                              buildingVsUnitFirstItem.push(mapObj);
                             firstItemopen = mapObj;
                        	}
                          else {
                            buildingVsUnitList.push(mapObj);
                          }    


                        }
                  }
   
                mapObj = {};
                db = {
                criteria: [category == 2004 && resource == value.id && moduleState != null && moduleState == closeticketStatus && actualWorkEnd == thisWeek],
  				};  
  				closeWorkorders = Module("workorder").fetch(db);
                  if (closeWorkorders != null){
                    unitList = [];
                      for each ind,wo in closeWorkorders{
                        obj = {};
                        daysInOpen = 0;
                           if (wo.unit != null){
                              db = {
                                criteria: [id == wo.unit.id],
                              };
                           unitArr = Module("tenantunit").fetch(db);
                           unitObj = unitArr[0];

                             if (wo.date != null){
                               obj.date = date().getFormattedTime(wo.date,"dd-MM-yyyy");
                               constFiveDays = 432000000;
                               handOver = (wo.date + constFiveDays);
                               obj.handOverDate = date().getFormattedTime(handOver,"dd-MM-yyyy");
                               daysInOpen = (now - wo.date)/86400000;
                               if (wo.actualWorkDuration > 0) {
                                 actualWorkDurationInMs = (wo.actualWorkDuration * 1000);
                                 resolvedTime = (wo.actualWorkStart + actualWorkDurationInMs);
                                 daysInOpen = (resolvedTime - wo.date)/86400000;
                               }
                             }
                             
                              if (daysInOpen == null) {
                                 daysInOpen = (now - wo.actualWorkStart)/86400000; 
                              }
                          
                           if (daysInOpen == null) {
                             obj.daysInOpen = 0;
                            }else {
                              obj.daysInOpen = math().setPrecision(daysInOpen, 0);
                            }
    
                           if (wo.actualWorkDuration > 0 && handOver > 0) {
                             actualWorkDurationInMs = (wo.actualWorkDuration * 1000);
                             resolvedTime = (wo.actualWorkStart + actualWorkDurationInMs);
                             
                             resolvedTimeInSec = (resolvedTime/1000);
                             handOverInSec = (handOver/1000);
                             
                             if (resolvedTimeInSec > handOverInSec) {
                             variationInSec = (resolvedTimeInSec - handOverInSec);
                             inHr = date.secToHour(variationInSec);
      						 inDays = date.hourToDay(inHr);
                   obj.variationindays = math().setPrecision(inDays, 0);
                             obj.variation = "+" + math().setPrecision(inDays, 0);
                             }
                             else if (handOverInSec > resolvedTimeInSec) {
                             variationInSec = (handOverInSec - resolvedTimeInSec);
                             inHr = date.secToHour(variationInSec);
      						 inDays = date.hourToDay(inHr);
                   obj.variationindays = math().setPrecision(inDays, 0);
                             obj.variation = "-" + math().setPrecision(inDays, 0);
                             }
                           
                             startDate = date().getFormattedTime(wo.actualWorkStart,"dd-MM-yyyy");
                             resolvedDate = date().getFormattedTime(resolvedTime,"dd-MM-yyyy");
                         
                           }
                            else if ( handOver > 0  &&  obj.daysInOpen > 0) {
                             if (daysInOpen > 5) {
                               indays = (daysInOpen - 5);
                               obj.variationindays = math().setPrecision(indays, 0);
                               obj.variation = "+" + math().setPrecision(indays, 0);
                             }else if (daysInOpen > 0 && daysInOpen < 5) {
                               indays = (5 - daysInOpen);
                               obj.variationindays = math().setPrecision(indays, 0);
                               obj.variation = "-" + math().setPrecision(indays, 0);
                             }
                           }

                            dbCri = {
        					          	criteria: [parent == wo.id && fromStatus == 13410],
 								            }; 
                              now = date.now();
                             duration = 0;
                             if (Module("workorderTimeLog").fetch(dbCri) != null) {
                               timelogs = Module("workorderTimeLog").fetch(dbCri);
                                for each index,timelog in timelogs{
                                  if (timelog.duration != null) {
                                    duration = (duration + timelog.duration);
                                  }
                                  else {
                                  
                                  milliSec = (now - timelog.startTime);
                                  inSec = (milliSec/1000);
                                  duration = (duration + inSec);
                                }        
                                }
                               
                               inHr = date.secToHour(duration);
                                inDays = date.hourToDay(inHr);
                               duration = math().setPrecision(inDays, 0);
                             }         
                           
                           obj.onHoldDuration = duration;
                           
                           obj.unitName = unitObj.name;
                           unitList.push(obj);
                           }
                        
                      }
                        if (unitList != []) {
                        mapObj["lists"] = unitList;
                        mapObj["name"] = building.name;
                           if (mapObj != null && firstItem == null) {
                              buildingVsUnitFirstItemForClosed.push(mapObj);
                             firstItem = mapObj;
                        	}
                          else {
                            buildingVsUnitListForClosed.push(mapObj);
                          }    

                      	}
                  }                  
               }
             } 
          }  
   
   if (alWahaibiList != null) {
   for each ind,bu in alWahaibiList{
      buildings.push(bu);
   }  
  }
  if (bipinDharamseyNensey != null) {
   for each ind,bu in bipinDharamseyNensey{
      buildings.push(bu);
   }  
  }
  if (ahmedBinAbdulNabiMack != null) {
   for each ind,bu in ahmedBinAbdulNabiMack{
      buildings.push(bu);
   }  
  }
  if (aliHussainAlRahma != null) {
   for each ind,bu in aliHussainAlRahma{
      buildings.push(bu);
   }  
  }
  if (akramZarrouf != null) {
   for each ind,bu in akramZarrouf{
      buildings.push(bu);
   }  
  }
  if (remainingList != null) {
   for each ind,bu in remainingList{
      buildings.push(bu);
   }  
  }
  
   result.buildings = buildings;
   result.buildingVsUnitList = buildingVsUnitList;
   result.buildingVsUnitFirstItem = buildingVsUnitFirstItem;
   result.buildingVsUnitListForClosed = buildingVsUnitListForClosed;
   result.buildingVsUnitFirstItemForClosed = buildingVsUnitFirstItemForClosed;
  org ={};
  org.domain = "thequalitygroup";
  org.timezone = "Asia/Muscat";
  result.org = org;
  
  return result;
}'

'200':
  description: 'check in check out monthly digest'
  usage: 'week digest'
  workflow: 'Map monthlyDigest() {

     result = {};
  
  math = new NameSpace("math");
  date = new NameSpace("date");  
  thisMonth = date().getDateRange("Last Month");
  startTime = thisMonth.getStartTime();
  endTime = thisMonth.getEndTime();
  last2Month = date.getDateRange("Last N Months", 3);
  lastMonth = date.dateRange(last2Month.getStartTime(), startTime - 1);
  
  
  lastMonthstartTime = lastMonth.getStartTime();
  lastMonthendTime = lastMonth.getEndTime();
  
  result.startTime = date().getFormattedTime(startTime,"dd-MM-yyyy");
  result.endTime = date().getFormattedTime(endTime,"dd-MM-yyyy");
  result.lastMonthstartTime = date().getFormattedTime(lastMonthstartTime,"dd-MM-yyyy");
  result.lastMonthendTime = date().getFormattedTime(lastMonthendTime,"dd-MM-yyyy");
  
  
  
  
  now = date.now();
  moduleId = 98566;
  
  db = {
    criteria: [parentModuleId == moduleId && typeCode == 1],
    field: "id"
  }; 
  openticketStatus = Module("ticketstatus").fetch(db); 	
  db = {
        criteria: [parentModuleId == moduleId && typeCode == 2],
    field: "id"
  }; 
  closeticketStatus = Module("ticketstatus").fetch(db); 	
  holdticketStatus = [13410];
  db = {
        criteria: [category == 2004],
        field: "id",
        aggregation: "count"
  }; 
  result.totalWorkorder = Module("workorder").fetch(db); 
  db = {
        criteria: [category == 2004 && moduleState != null && moduleState == closeticketStatus],
        field: "id",
        aggregation: "count"
  };  
  result.totalClosedWorkorder = Module("workorder").fetch(db); 
  db = {
        criteria: [category == 2004 && moduleState != null && moduleState == closeticketStatus],
        field: "actualWorkDuration",
        aggregation: "avg"
  };  
  avgSeconds = Module("workorder").fetch(db);
  result.totalWoAvgComp = 0;
      if (avgSeconds != null){
      avgMin = date.secToHour(avgSeconds);
      avgdays = date.hourToDay(avgMin);
      result.totalWoAvgComp =  math().setPrecision(avgdays, 0);
      }
  db = {
        criteria: [category == 2004 && createdTime == thisMonth && moduleState != null && moduleState == closeticketStatus],
        field: "actualWorkDuration",
        aggregation: "avg"
  };  
  avgSeconds = Module("workorder").fetch(db);
  result.totalWoAvgCompThisMonth = 0;
      if (avgSeconds != null){
      avgMin = date.secToHour(avgSeconds);
      avgdays = date.hourToDay(avgMin);
      result.totalWoAvgCompThisMonth = math().setPrecision(avgdays, 0);
      }
  db = {
        criteria: [category == 2004 && createdTime == lastMonth && moduleState != null && moduleState == closeticketStatus],
        field: "actualWorkDuration",
        aggregation: "avg"
  };  
  avgSeconds = Module("workorder").fetch(db);
  result.totalWoAvgCompLastMonth = 0;
      if (avgSeconds != null) {
      avgMin = date.secToHour(avgSeconds);
      avgdays = date.hourToDay(avgMin);
      result.totalWoAvgCompLastMonth =  math().setPrecision(avgdays, 0);
      }
   db = {
        criteria: [category == 2004 && createdTime == thisMonth && moduleState != null && moduleState == closeticketStatus],
        field: "actualWorkDuration",
  }; 
  list =  Module("workorder").fetch(db);
  result.maxdaysThisMonth = 0;
  result.mindaysThisMonth = 0;
        if (list != null) {
        max = 0;
        min = list[0];
            for each index,value in list{
              if ( max < value ) {
                  max = value;
              }
              if (value < min) {
                min = value;
             }
            }
        maxMinu = date.secToHour(max);
        maxdays = date.hourToDay(maxMinu);
        result.maxdaysThisMonth =  math().setPrecision(maxdays, 0);
        minMinu = date.secToHour(min);
        mindays = date.hourToDay(minMinu);
        result.mindaysThisMonth =  math().setPrecision(mindays, 0);
        }
  
  db = {
        criteria: [category == 2004 && createdTime == lastMonth && moduleState != null && moduleState == closeticketStatus],
        field: "actualWorkDuration",
  }; 
  list =  Module("workorder").fetch(db);
  result.maxdaysLastMonth = 0;
  result.mindaysLastMonth = 0;
        if (list != null) {
        max = 0;
        min = list[0];
            for each index,value in list{
              if ( max < value ) {
                  max = value;
              }
              if (value < min) {
                min = value;
             }
            }
        maxMinu = date.secToHour(max);
        maxdays = date.hourToDay(maxMinu);
        result.maxdaysLastMonth = math().setPrecision(maxdays, 0);
        minMinu = date.secToHour(min);
        mindays = date.hourToDay(minMinu);
        result.mindaysLastMonth = math().setPrecision(mindays, 0);
        }
  
  
  db = {
        criteria: [category == 2004 && createdTime == thisMonth],
        field: "id",
        aggregation: "count"
  }; 
  result.totalWorkordersThisMonth = Module("workorder").fetch(db);
  db = {
         criteria: [category == 2004 && createdTime == thisMonth && moduleState == 13410],
         field: "id",
         aggregation: "count"
  }; 
  result.totalWoOnHoldThisMonth = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0) {
      result.totalWoOnHoldThisMonth = ((Module("workorder").fetch(db)/result.totalWorkordersThisMonth)*100);
  }
  
  db = {
         criteria: [picklist == 2],
    	 field: "id"
  }; 
  buildings = Module("building").fetch(db);
   db = {
        criteria: [category == 2004 && resource == buildings],
     	field: "id",
        aggregation: "count"
  };
  result.totalAlWahaibiWo = Module("workorder").fetch(db);
  total = Module("workorder").fetch(db);
 
  
  db = {
        criteria: [category == 2004 && actualWorkStart == thisMonth && resource == buildings && moduleState != null && moduleState == openticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalAlWahaibiWoOpen = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalAlWahaibiWoOpen = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalAlWahaibiWoOpen > 0) {
        result.totalAlWahaibiWoOpen = math().setPrecision(result.totalAlWahaibiWoOpen, 0); 
      }
  }
  
   db = {
        criteria: [category == 2004 && resource == buildings && moduleState != null && moduleState == holdticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalAlWahaibiWoClose = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalAlWahaibiWoClose = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalAlWahaibiWoClose > 0) {
        result.totalAlWahaibiWoClose = math().setPrecision(result.totalAlWahaibiWoClose, 0); 
      }
  }
  
  
  
  
  db = {
         criteria: [picklist == 3],
    	 field: "id"
  }; 
  buildings = Module("building").fetch(db);
   db = {
        criteria: [category == 2004 && resource == buildings],
     	field: "id",
        aggregation: "count"
  };
  result.totalBdPropertiesWo = Module("workorder").fetch(db);
  total = Module("workorder").fetch(db);
  
  db = {
        criteria: [category == 2004 && actualWorkStart == thisMonth && resource == buildings && moduleState != null && moduleState == openticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalBdPropertiesWoOpen = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalBdPropertiesWoOpen = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalBdPropertiesWoOpen > 0) {
        result.totalBdPropertiesWoOpen = math().setPrecision(result.totalBdPropertiesWoOpen, 0); 
      }
  }
  
   db = {
        criteria: [category == 2004 && resource == buildings && moduleState != null && moduleState == holdticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalBdPropertiesWoClose = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalBdPropertiesWoClose = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalBdPropertiesWoClose > 0) {
        result.totalBdPropertiesWoClose = math().setPrecision(result.totalBdPropertiesWoClose, 0); 
      }
  }
  
  

  
  
  db = {
         criteria: [picklist == 1],
    	 field: "id"
  }; 
  buildings = Module("building").fetch(db);
   db = {
        criteria: [category == 2004 && resource == buildings],
     	field: "id",
        aggregation: "count"
  };
  result.totalAmPropertiesWo = Module("workorder").fetch(db);
  total = Module("workorder").fetch(db);
  
  db = {
        criteria: [category == 2004 && actualWorkStart == thisMonth && resource == buildings && moduleState != null && moduleState == openticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalAmPropertiesWoOpen = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalAmPropertiesWoOpen = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalAmPropertiesWoOpen > 0) {
        result.totalAmPropertiesWoOpen = math().setPrecision(result.totalAmPropertiesWoOpen, 0); 
      }
  }
  
   db = {
        criteria: [category == 2004 && resource == buildings && moduleState != null && moduleState == holdticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalAmPropertiesWoClose = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalAmPropertiesWoClose = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalAmPropertiesWoClose > 0) {
        result.totalAmPropertiesWoClose = math().setPrecision(result.totalAmPropertiesWoClose, 0); 
      }
  }
  
  
 
  db = {
         criteria: [picklist == 5],
    	 field: "id"
  }; 
  buildings = Module("building").fetch(db);
   db = {
        criteria: [category == 2004 && resource == buildings],
     	field: "id",
        aggregation: "count"
  };
  result.totalEqaratPropertiesWo = Module("workorder").fetch(db);
  total = Module("workorder").fetch(db);
  
  db = {
        criteria: [category == 2004 && actualWorkStart == thisMonth && resource == buildings && moduleState != null && moduleState == openticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalEqaratPropertiesWoOpen = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalEqaratPropertiesWoOpen = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalEqaratPropertiesWoOpen > 0) {
        result.totalEqaratPropertiesWoOpen = math().setPrecision(result.totalEqaratPropertiesWoOpen, 0); 
      }
  }
  
   db = {
        criteria: [category == 2004 && resource == buildings && moduleState != null && moduleState == holdticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalEqaratPropertiesWoClose = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalEqaratPropertiesWoClose = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalEqaratPropertiesWoClose > 0) {
        result.totalEqaratPropertiesWoClose = math().setPrecision(result.totalEqaratPropertiesWoClose, 0); 
      }
  }
  
  
  
  db = {
         criteria: [picklist == 4],
    	 field: "id"
  }; 
  buildings = Module("building").fetch(db);
   db = {
        criteria: [category == 2004 && resource == buildings],
     	field: "id",
        aggregation: "count"
  };
  result.totalDgPropertiesWo = Module("workorder").fetch(db);
  
  total = Module("workorder").fetch(db);
  
  db = {
        criteria: [category == 2004 && actualWorkStart == thisMonth && resource == buildings && moduleState != null && moduleState == openticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalDgPropertiesWoOpen = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalDgPropertiesWoOpen = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalDgPropertiesWoOpen > 0) {
        result.totalDgPropertiesWoOpen = math().setPrecision(result.totalDgPropertiesWoOpen, 0); 
      }
  }
  
   db = {
        criteria: [category == 2004 && resource == buildings && moduleState != null && moduleState == holdticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalDgPropertiesWoClose = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalDgPropertiesWoClose = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalDgPropertiesWoClose > 0) {
        result.totalDgPropertiesWoClose = math().setPrecision(result.totalDgPropertiesWoClose, 0); 
      }
  }
  
  
   db = {
        criteria: [category == 2004],
     	field: "id",
        aggregation: "count"
  };
  result.totalWoInProperties = Module("workorder").fetch(db);
  
  total = Module("workorder").fetch(db);
  
  db = {
        criteria: [category == 2004 && actualWorkStart == thisMonth && moduleState != null && moduleState == openticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalOpenWoInProperties = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalOpenWoInProperties = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalOpenWoInProperties > 0) {
        result.totalOpenWoInProperties = math().setPrecision(result.totalOpenWoInProperties, 0); 
      }
  }
  
   db = {
        criteria: [category == 2004 && moduleState != null && moduleState == holdticketStatus],
     	field: "id",
        aggregation: "count"
  };
  result.totalClosedWoInProperties = 0;
  if (Module("workorder").fetch(db) != null && Module("workorder").fetch(db) > 0 && total > 0) {
      result.totalClosedWoInProperties = ((Module("workorder").fetch(db)/total)*100);
      if (result.totalClosedWoInProperties > 0) {
        result.totalClosedWoInProperties = math().setPrecision(result.totalClosedWoInProperties, 0); 
      }
  }
  
  
  

  buildingsList = Module("building").fetch([id != null]);
  buildings = [];
  alWahaibiList = [];
  bipinDharamseyNensey = [];
  ahmedBinAbdulNabiMack = [];
  aliHussainAlRahma = [];
  akramZarrouf = [];
  remainingList = [];
  buildingVsUnitList = [];
  buildingVsUnitFirstItem = [];
  buildingVsUnitListForClosed = [];
  buildingVsUnitFirstItemForClosed = [];

        if (buildingsList != null) {
              for each index,value in buildingsList{  
                buildingVsMap = {};
                mapObj = {};
                building = {};
                building.id = value.id;
                building.name = value.name;      
                db = {
                  criteria: [category == 2004 && resource == value.id],
                  field: "id",
                  aggregation: "count"
                };
                totalWo = Module("workorder").fetch(db);
                if (totalWo > 0) {
                  building.totalWo = Module("workorder").fetch(db); 
                db = {
                  criteria: [category == 2004 && resource == value.id && moduleState != null && moduleState == closeticketStatus],
                  field: "id",
                  aggregation: "count"
                };      
                building.totalClosedWo = Module("workorder").fetch(db); 
                db = {
                criteria: [category == 2004 && resource == value.id && moduleState != null && moduleState == closeticketStatus],
                field: "actualWorkDuration",
                aggregation: "avg"
  				};  
                avgSec = Module("workorder").fetch(db);
                 building.WoAvgComp = 0;              
                if (avgSec != null && avgSec > 0){
                avgMinu = date.secToHour(avgSec);
                avgday = date.hourToDay(avgMinu);
                 building.WoAvgComp = math().setPrecision(avgday, 0);  
                  
                }
                if (value.client != null) {
                if (value.client.id == 11) {
                  alWahaibiList.push(building);
                }else if (value.client.id == 12) {
                  bipinDharamseyNensey.push(building);
                }else if (value.client.id == 13) {
                  ahmedBinAbdulNabiMack.push(building);
                }else if (value.client.id == 14) {
                  aliHussainAlRahma.push(building);
                }else if (value.client.id == 15) {
                  akramZarrouf.push(building);
                }
                }else {
                  remainingList.push(building);
                }
          
           
                
                db = {
                criteria: [category == 2004 && resource == value.id && moduleState != null && moduleState == openticketStatus],
  				};  
  				openWorkorders = Module("workorder").fetch(db);
                  if (openWorkorders != null){
                    unitList = [];
                      for each ind,wo in openWorkorders{
                        obj = {};
                        daysInOpen = 0;
                           if (wo.unit != null){
                              db = {
                                criteria: [id == wo.unit.id],
                              };
                           unitArr = Module("tenantunit").fetch(db);
                           unitObj = unitArr[0];

                             if (wo.date != null){
                               obj.date = date().getFormattedTime(wo.date,"dd-MM-yyyy");
                               constFiveDays = 432000000;
                               handOver = (wo.date + constFiveDays);
                               obj.handOverDate = date().getFormattedTime(handOver,"dd-MM-yyyy");
                               daysInOpen = (now - wo.date)/86400000;
                               if (wo.actualWorkDuration > 0) {
                                 actualWorkDurationInMs = (wo.actualWorkDuration * 1000);
                                 resolvedTime = (wo.actualWorkStart + actualWorkDurationInMs);
                                 daysInOpen = (resolvedTime - wo.date)/86400000;
                               }
                             }
                             
                              if (daysInOpen == null) {
                                 daysInOpen = (now - wo.actualWorkStart)/86400000; 
                              }
                          
                           if (daysInOpen == null) {
                             obj.daysInOpen = 0;
                            }else {
                              obj.daysInOpen = math().setPrecision(daysInOpen, 0);
                            }
                             
                             
                             
                             
                           if (wo.actualWorkDuration > 0 && handOver > 0) {
                             actualWorkDurationInMs = (wo.actualWorkDuration * 1000);
                             resolvedTime = (wo.actualWorkStart + actualWorkDurationInMs);
                             
                             resolvedTimeInSec = (resolvedTime/1000);
                             handOverInSec = (handOver/1000);
                             
                             if (resolvedTimeInSec > handOverInSec) {
                             variationInSec = (resolvedTimeInSec - handOverInSec);
                             inHr = date.secToHour(variationInSec);
      						 inDays = date.hourToDay(inHr);
                             obj.variation = "+" + math().setPrecision(inDays, 0);
                             }
                             else {
                             variationInSec = (handOverInSec - resolvedTimeInSec);
                             inHr = date.secToHour(variationInSec);
      						 inDays = date.hourToDay(inHr);
                             obj.variation = "-" + math().setPrecision(inDays, 0);
                             }
                           
                             startDate = date().getFormattedTime(wo.actualWorkStart,"dd-MM-yyyy");
                             resolvedDate = date().getFormattedTime(resolvedTime,"dd-MM-yyyy");
          
                         
                           }
                            else if ( handOver > 0  &&  obj.daysInOpen > 0) {
                             if (daysInOpen > 5) {
                               indays = (daysInOpen - 5);
                               obj.variation = "+" + math().setPrecision(indays, 0);
                             }else if (daysInOpen > 0 && daysInOpen < 5) {
                               indays = (5 - daysInOpen);
                               obj.variation = "-" + math().setPrecision(indays, 0);
                             }
                           }



                           obj.unitName = unitObj.name;
                           unitList.push(obj);
                           }
                        
                      }
                        if (unitList != []) {
                         mapObj["lists"] = unitList;
                        mapObj["name"] = building.name;
                        if (index == 0) {
                          buildingVsUnitFirstItem.push(mapObj);
                        }
                        if (index > 0) {
                          buildingVsUnitList.push(mapObj);
                        }

                      	}
                  }
                  
                mapObj = {};
                db = {
                criteria: [category == 2004 && resource == value.id && moduleState != null && moduleState == closeticketStatus && actualWorkEnd == thisMonth],
  				};  
  				closeWorkorders = Module("workorder").fetch(db);
                  
                  
                  if (closeWorkorders != null){
                    unitList = [];
                      for each ind,wo in closeWorkorders{
                        obj = {};
                        daysInOpen = 0;
                           if (wo.unit != null){
                              db = {
                                criteria: [id == wo.unit.id],
                              };
                           unitArr = Module("tenantunit").fetch(db);
                           unitObj = unitArr[0];

                             if (wo.date != null){
                               obj.date = date().getFormattedTime(wo.date,"dd-MM-yyyy");
                               constFiveDays = 432000000;
                               handOver = (wo.date + constFiveDays);
                               obj.handOverDate = date().getFormattedTime(handOver,"dd-MM-yyyy");
                               daysInOpen = (now - wo.date)/86400000;
                               if (wo.actualWorkDuration > 0) {
                                 actualWorkDurationInMs = (wo.actualWorkDuration * 1000);
                                 resolvedTime = (wo.actualWorkStart + actualWorkDurationInMs);
                                 daysInOpen = (resolvedTime - wo.date)/86400000;
                               }
                             }
                             
                              if (daysInOpen == null) {
                                 daysInOpen = (now - wo.actualWorkStart)/86400000; 
                              }
                          
                           if (daysInOpen == null) {
                             obj.daysInOpen = 0;
                            }else {
                              obj.daysInOpen = math().setPrecision(daysInOpen, 0);
                            }
                             
                             
                             
                           if (wo.actualWorkDuration > 0 && handOver > 0) {
                             actualWorkDurationInMs = (wo.actualWorkDuration * 1000);
                             resolvedTime = (wo.actualWorkStart + actualWorkDurationInMs);
                             
                             resolvedTimeInSec = (resolvedTime/1000);
                             handOverInSec = (handOver/1000);
                             
                             if (resolvedTimeInSec > handOverInSec) {
                             variationInSec = (resolvedTimeInSec - handOverInSec);
                             inHr = date.secToHour(variationInSec);
      						 inDays = date.hourToDay(inHr);
                             obj.variation = "+" + math().setPrecision(inDays, 0);
                             }
                             else if (handOverInSec > resolvedTimeInSec)  {
                             variationInSec = (handOverInSec - resolvedTimeInSec);
                             inHr = date.secToHour(variationInSec);
      						 inDays = date.hourToDay(inHr);
                             obj.variation = "-" + math().setPrecision(inDays, 0);
                             }
                           
                             startDate = date().getFormattedTime(wo.actualWorkStart,"dd-MM-yyyy");
                             resolvedDate = date().getFormattedTime(resolvedTime,"dd-MM-yyyy");
                           }
                            else if ( handOver > 0  &&  obj.daysInOpen > 0) {
                             if (daysInOpen > 5) {
                               indays = (daysInOpen - 5);
                               obj.variation = "+" + math().setPrecision(indays, 0);
                             }else if (daysInOpen > 0 && daysInOpen < 5) {
                               indays = (5 - daysInOpen);
                               obj.variation = "-" + math().setPrecision(indays, 0);
                             }
                           }
                           
                           obj.unitName = unitObj.name;
                           unitList.push(obj);
                           }
                        
                      }
                        if (unitList != []) {
                        mapObj["lists"] = unitList;
                        mapObj["name"] = building.name;
                        if (index == 0) {
                          buildingVsUnitFirstItemForClosed.push(mapObj);
                        }
                        if (index > 0) {
                          buildingVsUnitListForClosed.push(mapObj);
                        }

                      	}
                  }
                  
                 
                  
                  
                  
              } 
            }
          } 
  
  if (alWahaibiList != null) {
   for each ind,bu in alWahaibiList{
      buildings.push(bu);
   }  
  }
  if (bipinDharamseyNensey != null) {
   for each ind,bu in bipinDharamseyNensey{
      buildings.push(bu);
   }  
  }
  if (ahmedBinAbdulNabiMack != null) {
   for each ind,bu in ahmedBinAbdulNabiMack{
      buildings.push(bu);
   }  
  }
  if (aliHussainAlRahma != null) {
   for each ind,bu in aliHussainAlRahma{
      buildings.push(bu);
   }  
  }
  if (akramZarrouf != null) {
   for each ind,bu in akramZarrouf{
      buildings.push(bu);
   }  
  }
  if (remainingList != null) {
   for each ind,bu in remainingList{
      buildings.push(bu);
   }  
  }
   
  	
   result.buildings = buildings;
   result.buildingVsUnitList = buildingVsUnitList;
   result.buildingVsUnitFirstItem = buildingVsUnitFirstItem;
   result.buildingVsUnitListForClosed = buildingVsUnitListForClosed;
   result.buildingVsUnitFirstItemForClosed = buildingVsUnitFirstItemForClosed;

  
   org ={};
   org.domain = "thequalitygroup";
   org.timezone = "Asia/Muscat";
   result.org = org;
  
  
   return result;

  }'
'201':
  description: 'workorder daily digest'
  usage: 'daily digest'
  workflow: 'Map dailyDigest() {
	log "Inside Daily digest workflow";
	result = {};
  
  	moduleId = 118728;
  	area1purple = 1314416;
    area2green = 1314417;
    area3orange = 1314418;
  	
  	woTillYesterday = 0;
  	woOpenTillYesterdayPercentage = 0;
	totalWo = 0;
  	totalWoOpen = 0;
    totalWoOpenPercentage = 0;
    totalWoPlanned = 0;
    totalWoUnplanned = 0;
  	totalWoPlannedOpen = 0;
    totalWoUnplannedOpen = 0;
    totalWoPlannedOpenPercentage = 0;
    totalWoUnplannedOpenPercentage = 0;
    totalWoArea1Purple = 0;
    totalWoArea2Green = 0;
    totalWoArea3Orange = 0;
  	services = [];
  
	db = {
		criteria: [parentModuleId == moduleId && typeCode == 1],
        field: "id"
	}; 
    openticketStatus = Module("ticketstatus").fetch(db); 	
 	 
  	date = new NameSpace("date"); 
	today = date.getDateRange("Today");
  	
  	db = {
        criteria: [createdTime != today]
        field: "id",
        aggregation: "count"
    };
  
    woTillYesterday = Module("workorder").fetch(db);
  
  	if(woTillYesterday != 0){
      db = {
          criteria: [createdTime != today && moduleState != null && moduleState == openticketStatus]
          field: "id",
          aggregation: "count"
      };

      woOpenTillYesterday = Module("workorder").fetch(db);
      woOpenTillYesterdayPercentage = (woOpenTillYesterday/woTillYesterday)*100;
      if (woOpenTillYesterdayPercentage > 0) {
        woOpenTillYesterdayPercentage = math().setPrecision(woOpenTillYesterdayPercentage, 0); 
      }
    }
  
  	
	db = {
        criteria: [createdTime == today]
	};
    totalWoToday = Module("workorder").fetch(db);
  	log "Daily digest totalWoToday";
  
    if(totalWoToday != null){
      
        totalWo = totalWoToday.size();
      
        db = {
          criteria: [createdTime == today && sourceType == 5],
          field: "id",
          aggregation: "count"
        };  
      	totalWoPlanned = Module("workorder").fetch(db);
      
      	totalWoUnplanned = totalWo - totalWoPlanned;
     	
      	db = {
          criteria: [createdTime == today && moduleState != null && moduleState == openticketStatus],
          field: "id",
          aggregation: "count"
        };  
      	totalWoOpen = Module("workorder").fetch(db);
       	totalWoOpenPercentage = (totalWoOpen/totalWo)*100;
      	if (totalWoOpenPercentage > 0) {
          totalWoOpenPercentage = math().setPrecision(totalWoOpenPercentage, 0); 
        }
      
      	if(totalWoPlanned != 0){
        	db = {
              criteria: [createdTime == today && sourceType == 5 && moduleState != null && moduleState == openticketStatus],
              field: "id",
              aggregation: "count"
             };  
            totalWoPlannedOpen = Module("workorder").fetch(db);
            totalWoPlannedOpenPercentage = (totalWoPlannedOpen/totalWoPlanned)*100;
            if (totalWoPlannedOpenPercentage > 0) {
              totalWoPlannedOpenPercentage = math().setPrecision(totalWoPlannedOpenPercentage, 0); 
            }
        }
      	
      	if(totalWoUnplanned != 0){
            totalWoUnplannedOpen = totalWoOpen - totalWoPlannedOpen;
            totalWoUnplannedOpenPercentage = (totalWoUnplannedOpen/totalWoUnplanned)*100;
          	if (totalWoUnplannedOpenPercentage > 0) {
              totalWoUnplannedOpenPercentage = math().setPrecision(totalWoUnplannedOpenPercentage, 0); 
            }
        }
      	
      	
        db ={
          criteria:[name != null]
        };

        custom_services = Module("custom_services").fetch(db);

        for each index,s in custom_services{
        
          service = {};
          service.id = s.id;
          service.name = s.name;
          db ={
              criteria:[createdTime == today && servicesnew == s.id]
              field: "id",
              aggregation: "count"
          };
          service.totalWo = Module("workorder").fetch(db);

          db = {
              criteria: [parentModuleId == moduleId && typeCode == 2],
              field: "id"
          }; 
      	  closeticketStatus = Module("ticketstatus").fetch(db); 	
        
          db = {
              criteria: [createdTime == today && servicesnew == s.id && moduleState != null && moduleState == closeticketStatus],
              field: "id",
              aggregation: "count"
          };  
          service.totalWoClose = Module("workorder").fetch(db);
          
          if(service.totalWoClose == 0){
          		service.avgWorkDuration = 0;
          }else{

              db = {
                  criteria: [createdTime == today && servicesnew == s.id && moduleState != null && moduleState == closeticketStatus],
                  field: "actualWorkDuration",
                  aggregation: "avg"
              };
              avgSeconds = Module("workorder").fetch(db);
              service.avgWorkDuration = 0;

              if (avgSeconds != null){
                  avgMin = avgSeconds/60;
                  avgHour = date.minsToHour(avgMin);
                  avgdays = date.hourToDay(avgHour);
                
                  if(avgMin < 60){
                    avgWork = math().setPrecision(avgMin, 0);
                    service.avgWorkDuration = avgWork + " Minutes";
                  }else if(avgHour < 24){
                    avgWork = math().setPrecision(avgHour, 0);
                    service.avgWorkDuration = avgWork + " Hours";
                  }else{
                    avgWork = math().setPrecision(avgdays, 0);
                    service.avgWorkDuration = avgWork + " Days";
                  }
                  
              }

          }
        
          services.add(service);
      }
      
      area1list = BaseSpace().getSubordinates(area1purple);
      db = {
            criteria: [createdTime == today && resource == area1list],
            field: "id",
            aggregation: "count"
      };
      totalWoArea1Purple = Module("workorder").fetch(db);
      
      area2list = BaseSpace().getSubordinates(area2green);
      db = {
            criteria: [createdTime == today && resource == area2list],
            field: "id",
            aggregation: "count"
      };
      totalWoArea2Green = Module("workorder").fetch(db);
      
      area3list = BaseSpace().getSubordinates(area3orange);
      db = {
            criteria: [createdTime == today && resource == area3list],
            field: "id",
            aggregation: "count"
      };
      totalWoArea3Orange = Module("workorder").fetch(db);
       
	}else{
      db ={
          criteria:[name != null]
        };
    	
      custom_services = Module("custom_services").fetch(db);
      for each index,s in custom_services{
        service = {};
        service.id = s.id;
        service.name = s.name;
        service.totalWo = 0;
        service.totalWoClose = 0;
        service.avgWorkDuration = 0;
        services.add(service);
      }
    }
	 
  	result.woTillYesterday = woTillYesterday;
  	result.woOpenTillYesterdayPercentage = woOpenTillYesterdayPercentage;
	result.totalWo = totalWo;
    result.totalWoOpenPercentage = totalWoOpenPercentage;
    result.totalWoPlanned = totalWoPlanned;
    result.totalWoUnplanned = totalWoUnplanned;
    result.totalWoPlannedOpenPercentage = totalWoPlannedOpenPercentage;
    result.totalWoUnplannedOpenPercentage = totalWoUnplannedOpenPercentage;
    result.totalWoArea1Purple = totalWoArea1Purple;
    result.totalWoArea2Green = totalWoArea2Green;
    result.totalWoArea3Orange = totalWoArea3Orange;
  	result.services = services;
  
  	log "Daily digest workflow completed";
	//log result;
    
	return result;
}'

'202':
  description: 'service request open,close,all count'
  usage: 'Tenant portal'
  workflow: 'Map getServiceRequestCount(Number userId){
  
  mapRes = {};
  
  allStates = Module("serviceRequest").getAllStates();
  
  openStateIds = [];
  closedStateIds = [];
  
  for each index,state in allStates {
    
   	if(state.typeCode == 1) {
      openStateIds.add(state.id);
    }
    else if (state.typeCode == 2) {
      closedStateIds.add(state.id);
    }
  }
  db = {};
  if(userId != null) {
     db.put("criteria",[id > 0 && requester == userId]);
  }
  else {
   	 db.put("criteria",[id > 0]); 
  }
    
  db.put("field","id");
  db.put("aggregation","count");
  mapRes.put("total",Module("serviceRequest").fetch(db));
  
  if(userId != null) {
     db.put("criteria",[moduleState == openStateIds && requester == userId]);
  }
  else {
   	 db.put("criteria",[moduleState == openStateIds]);
  }
  
  mapRes.put("open",Module("serviceRequest").fetch(db));
  
  
  if(userId != null) {
     db.put("criteria",[moduleState == closedStateIds && requester == userId]);
  }
  else {
   	 db.put("criteria",[moduleState == closedStateIds]);
  }
  
  mapRes.put("closed",Module("serviceRequest").fetch(db));

  return mapRes;
}'

'203':
  description: 'meter monthly consumption card'
  usage: 'meter summary'
  workflow: 'Map monthlyConsumption(Number meterId, String utilityTypeName){ 
  currentMonth = new NameSpace("date").getDateRange("Current Month upto now");
  diff = currentMonth.getEndTime() - currentMonth.getStartTime();
  lastMonth = new NameSpace("dateRange").create(currentMonth.getStartTime(), currentMonth.getEndTime() ,"Previous Period",2);
  lastMonth = new NameSpace("dateRange").create(lastMonth.getStartTime(),lastMonth.getStartTime() + diff);
  res = {};
  if(utilityTypeName == "Gas Meter") {
      db = {
        criteria : [parentId == meterId && ttime == currentMonth],
        field : "gasVolumeAccumulatorDelta",
        aggregation : "sum",
      };
      thisMonthTotal = Module("gasdata").fetch(db);
      res.put("thisMonthConsumption",thisMonthTotal);
      
      db1 = {
        criteria : [parentId == meterId && ttime == lastMonth],
        field : "gasVolumeAccumulatorDelta",
        aggregation : "sum",
      };
      lastMonthTotal = Module("gasdata").fetch(db1);
      res.put("lastMonthConsumption",lastMonthTotal);
      
      percentDiff = 0;
      scaleVal = 0;
      if(lastMonthTotal != 0 && thisMonthTotal != 0 && thisMonthTotal > lastMonthTotal){
      percentDiff = ((thisMonthTotal - lastMonthTotal)/lastMonthTotal)*100;
      scaleVal = 1;
      }
      else if(lastMonthTotal != 0 && thisMonthTotal !=0 && lastMonthTotal > thisMonthTotal){
      percentDiff = ((lastMonthTotal - thisMonthTotal)/lastMonthTotal)*100;
      }
      res.put("percentDifference",percentDiff);
      res.put("scale",scaleVal );
      res.put("readingName", "gasVolumeAccumulatorDelta");
  }
  else if(utilityTypeName == "Water Meter") {
      db = {
        criteria : [parentId == meterId && ttime == currentMonth],
        field : "waterVolumeAccumulatorDelta",
        aggregation : "sum",
      };
      thisMonthTotal = Module("waterdata").fetch(db);
      res.put("thisMonthConsumption",thisMonthTotal);
      
      db1 = {
        criteria : [parentId == meterId && ttime == lastMonth],
        field : "waterVolumeAccumulatorDelta",
        aggregation : "sum",
      };
      lastMonthTotal = Module("waterdata").fetch(db1);
      res.put("lastMonthConsumption",lastMonthTotal);
      
      percentDiff = 0;
      scaleVal = 0;
      if(lastMonthTotal != 0 && thisMonthTotal != 0 && thisMonthTotal > lastMonthTotal){
      percentDiff = ((thisMonthTotal - lastMonthTotal)/lastMonthTotal)*100;
      scaleVal = 1;
      }
      else if(lastMonthTotal != 0 && thisMonthTotal !=0 && lastMonthTotal > thisMonthTotal){
      percentDiff = ((lastMonthTotal - thisMonthTotal)/lastMonthTotal)*100;
      }
      res.put("percentDifference",percentDiff);
      res.put("scale",scaleVal );
      res.put("readingName", "waterVolumeAccumulatorDelta");
  }
  else if(utilityTypeName == "Electricity Meter") {
      db = {
        criteria : [parentId == meterId && ttime == currentMonth],
        field : "totalEnergyConsumptionDelta",
        aggregation : "sum",
      };
      thisMonthTotal = Module("electricitydata").fetch(db);
      res.put("thisMonthConsumption",thisMonthTotal);
      
      db1 = {
        criteria : [parentId == meterId && ttime == lastMonth],
        field : "totalEnergyConsumptionDelta",
        aggregation : "sum",
      };
      lastMonthTotal = Module("electricitydata").fetch(db1);
      res.put("lastMonthConsumption",lastMonthTotal);
      
      percentDiff = 0;
      scaleVal = 0;
      if(lastMonthTotal != 0 && thisMonthTotal != 0 && thisMonthTotal > lastMonthTotal){
      percentDiff = ((thisMonthTotal - lastMonthTotal)/lastMonthTotal)*100;
      scaleVal = 1;
      }
      else if(lastMonthTotal != 0 && thisMonthTotal !=0 && lastMonthTotal > thisMonthTotal){
      percentDiff = ((lastMonthTotal - thisMonthTotal)/lastMonthTotal)*100;
      }
      res.put("percentDifference",percentDiff);
      res.put("scale",scaleVal );
      res.put("readingName", "totalEnergyConsumptionDelta");
  }
  else if(utilityTypeName == "Heat Meter") {
      db = {
        criteria : [parentId == meterId && ttime == currentMonth],
        field : "thermalEnergyAccumulatorDelta",
        aggregation : "sum",
      };
      thisMonthTotal = Module("heatdata").fetch(db);
      res.put("thisMonthConsumption",thisMonthTotal);
      
      db1 = {
        criteria : [parentId == meterId && ttime == lastMonth],
        field : "thermalEnergyAccumulatorDelta",
        aggregation : "sum",
      };
      lastMonthTotal = Module("heatdata").fetch(db1);
      res.put("lastMonthConsumption",lastMonthTotal);
      
      percentDiff = 0;
      scaleVal = 0;
      if(lastMonthTotal != 0 && thisMonthTotal != 0 && thisMonthTotal > lastMonthTotal){
      percentDiff = ((thisMonthTotal - lastMonthTotal)/lastMonthTotal)*100;
      scaleVal = 1;
      }
      else if(lastMonthTotal != 0 && thisMonthTotal !=0 && lastMonthTotal > thisMonthTotal){
      percentDiff = ((lastMonthTotal - thisMonthTotal)/lastMonthTotal)*100;
      }
      res.put("percentDifference",percentDiff);
      res.put("scale",scaleVal );
      res.put("readingName", "thermalEnergyAccumulatorDelta");
  }
  else if(utilityTypeName == "BTU Meter") {
      db = {
        criteria : [parentId == meterId && ttime == currentMonth],
        field : "CHWConsumptionAccumulatorDelta",
        aggregation : "sum",
      };
      thisMonthTotal = Module("btudata").fetch(db);
      res.put("thisMonthConsumption",thisMonthTotal);
      
      db1 = {
        criteria : [parentId == meterId && ttime == lastMonth],
        field : "CHWConsumptionAccumulatorDelta",
        aggregation : "sum",
      };
      lastMonthTotal = Module("btudata").fetch(db1);
      res.put("lastMonthConsumption",lastMonthTotal);
      
      percentDiff = 0;
      scaleVal = 0;
      if(lastMonthTotal != 0 && thisMonthTotal != 0 && thisMonthTotal > lastMonthTotal){
      percentDiff = ((thisMonthTotal - lastMonthTotal)/lastMonthTotal)*100;
      scaleVal = 1;
      }
      else if(lastMonthTotal != 0 && thisMonthTotal !=0 && lastMonthTotal > thisMonthTotal){
      percentDiff = ((lastMonthTotal - thisMonthTotal)/lastMonthTotal)*100;
      }
      res.put("percentDifference",percentDiff);
      res.put("scale",scaleVal );
      res.put("readingName", "CHWConsumptionAccumulatorDelta");
  }
  return res;                
}'

'204':
  description: 'meter total consumption card'
  usage: 'meter summary'
  workflow: 'Map totalConsumption(Number meterId, String utilityTypeName){ 
  currentYear = new NameSpace("date").getDateRange("Current Year upto now");
  diff = currentYear.getEndTime() - currentYear.getStartTime();
  lastYear = new NameSpace("dateRange").create(currentYear.getStartTime(), currentYear.getEndTime() ,"Previous Period",2);
  lastYear = new NameSpace("dateRange").create(lastYear.getStartTime(),lastYear.getStartTime() + diff);
 
  res = {};
  if(utilityTypeName == "Gas Meter") {
      db = {
        criteria : [parentId == meterId && ttime == currentYear],
        field : "gasVolumeAccumulatorDelta",
        aggregation : "sum",
      };
      thisYearTotal = Module("gasdata").fetch(db);
      res.put("totalConsumption",thisYearTotal);
      
      db1 = {
        criteria : [parentId == meterId && ttime == lastYear],
        field : "gasVolumeAccumulatorDelta",
        aggregation : "sum",
      };
      lastYearTotal = Module("gasdata").fetch(db1);
      res.put("lastYearConsumption",lastYearTotal);
      
      percentDiff = 0;
      scaleVal = 0;
      if(lastYearTotal != 0 && thisYearTotal != 0 && thisYearTotal > lastYearTotal){
      percentDiff = ((thisYearTotal - lastYearTotal)/lastYearTotal)*100;
      scaleVal = 1;
      }
      else if(lastYearTotal != 0 && thisYearTotal !=0 && lastYearTotal > thisYearTotal){
      percentDiff = ((lastYearTotal - thisYearTotal)/lastYearTotal)*100;
      }
      res.put("percentDifference",percentDiff);
      res.put("scale",scaleVal );
      
      db2 = {
        criteria : [parentId == meterId && gasVolumeAccumulatorDelta != null],
        field : "ttime",
      };
      date = Module("gasdata").fetch(db2);
      if(date != null) {
        datetime = date[0];
        format = "MMM dd, yyyy hh:mm a";
        formattedTime = new NameSpace("date").getFormattedTime(datetime, format);
        res.put("dateTime",formattedTime);
      }
      else {
        res.put("dateTime",date);
      }
      res.put("readingName", "gasVolumeAccumulatorDelta");
  }
  else if(utilityTypeName == "Water Meter") {
      db = {
        criteria : [parentId == meterId && ttime == currentYear],
        field : "waterVolumeAccumulatorDelta",
        aggregation : "sum",
      };
      thisYearTotal = Module("waterdata").fetch(db);
      res.put("totalConsumption",thisYearTotal);
      
      db1 = {
        criteria : [parentId == meterId && ttime == lastYear],
        field : "waterVolumeAccumulatorDelta",
        aggregation : "sum",
      };
      lastYearTotal = Module("waterdata").fetch(db1);
      res.put("lastYearConsumption",lastYearTotal);
      
      percentDiff = 0;
      scaleVal = 0;
      if(lastYearTotal != 0 && thisYearTotal != 0 && thisYearTotal > lastYearTotal){
      percentDiff = ((thisYearTotal - lastYearTotal)/lastYearTotal)*100;
      scaleVal = 1;
      }
      else if(lastYearTotal != 0 && thisYearTotal !=0 && lastYearTotal > thisYearTotal){
      percentDiff = ((lastYearTotal - thisYearTotal)/lastYearTotal)*100;
      }
      res.put("percentDifference",percentDiff);
      res.put("scale",scaleVal );
      
      db2 = {
        criteria : [parentId == meterId && waterVolumeAccumulatorDelta != null],
        field : "ttime",
      };
      date = Module("waterdata").fetch(db2);
      if(date != null) {
        datetime = date[0];
        format = "MMM dd, yyyy hh:mm a";
        formattedTime = new NameSpace("date").getFormattedTime(datetime, format);
        res.put("dateTime",formattedTime);
      }
      else {
        res.put("dateTime",date);
      }
      res.put("readingName", "waterVolumeAccumulatorDelta");
  }
  else if(utilityTypeName == "Electricity Meter") {
      db = {
        criteria : [parentId == meterId && ttime == currentYear],
        field : "totalEnergyConsumptionDelta",
        aggregation : "sum",
      };
      thisYearTotal = Module("electricitydata").fetch(db);
      res.put("totalConsumption",thisYearTotal);
      
      db1 = {
        criteria : [parentId == meterId && ttime == lastYear],
        field : "totalEnergyConsumptionDelta",
        aggregation : "sum",
      };
      lastYearTotal = Module("electricitydata").fetch(db1);
      res.put("lastYearConsumption",lastYearTotal);
      
      percentDiff = 0;
      scaleVal = 0;
      if(lastYearTotal != 0 && thisYearTotal != 0 && thisYearTotal > lastYearTotal){
      percentDiff = ((thisYearTotal - lastYearTotal)/lastYearTotal)*100;
      scaleVal = 1;
      }
      else if(lastYearTotal != 0 && thisYearTotal !=0 && lastYearTotal > thisYearTotal){
      percentDiff = ((lastYearTotal - thisYearTotal)/lastYearTotal)*100;
      }
      res.put("percentDifference",percentDiff);
      res.put("scale",scaleVal );
      
      db2 = {
        criteria : [parentId == meterId && totalEnergyConsumptionDelta != null],
        field : "ttime",
      };
      date = Module("electricitydata").fetch(db2);
      if(date != null) {
        datetime = date[0];
        format = "MMM dd, yyyy hh:mm a";
        formattedTime = new NameSpace("date").getFormattedTime(datetime, format);
        res.put("dateTime",formattedTime);
      }
      else {
        res.put("dateTime",date);
      }
      res.put("readingName", "totalEnergyConsumptionDelta");
  }
  else if(utilityTypeName == "Heat Meter") {
      db = {
        criteria : [parentId == meterId && ttime == currentYear],
        field : "thermalEnergyAccumulatorDelta",
        aggregation : "sum",
      };
      thisYearTotal = Module("heatdata").fetch(db);
      res.put("totalConsumption",thisYearTotal);
      
      db1 = {
        criteria : [parentId == meterId && ttime == lastYear],
        field : "thermalEnergyAccumulatorDelta",
        aggregation : "sum",
      };
      lastYearTotal = Module("heatdata").fetch(db1);
      res.put("lastYearConsumption",lastYearTotal);
      
      percentDiff = 0;
      scaleVal = 0;
      if(lastYearTotal != 0 && thisYearTotal != 0 && thisYearTotal > lastYearTotal){
      percentDiff = ((thisYearTotal - lastYearTotal)/lastYearTotal)*100;
      scaleVal = 1;
      }
      else if(lastYearTotal != 0 && thisYearTotal !=0 && lastYearTotal > thisYearTotal){
      percentDiff = ((lastYearTotal - thisYearTotal)/lastYearTotal)*100;
      }
      res.put("percentDifference",percentDiff);
      res.put("scale",scaleVal );
      
      db2 = {
        criteria : [parentId == meterId && thermalEnergyAccumulatorDelta != null],
        field : "ttime",
      };
      date = Module("heatdata").fetch(db2);
      if(date != null) {
        datetime = date[0];
        format = "MMM dd, yyyy hh:mm a";
        formattedTime = new NameSpace("date").getFormattedTime(datetime, format);
        res.put("dateTime",formattedTime);
      }
      else {
        res.put("dateTime",date);
      }
      res.put("readingName", "thermalEnergyAccumulatorDelta");
  }
  else if(utilityTypeName == "BTU Meter") {
      db = {
        criteria : [parentId == meterId && ttime == currentYear],
        field : "CHWConsumptionAccumulatorDelta",
        aggregation : "sum",
      };
      thisYearTotal = Module("btudata").fetch(db);
      res.put("totalConsumption",thisYearTotal);
      
      db1 = {
        criteria : [parentId == meterId && ttime == lastYear],
        field : "CHWConsumptionAccumulatorDelta",
        aggregation : "sum",
      };
      lastYearTotal = Module("btudata").fetch(db1);
      res.put("lastYearConsumption",lastYearTotal);
      
      percentDiff = 0;
      scaleVal = 0;
      if(lastYearTotal != 0 && thisYearTotal != 0 && thisYearTotal > lastYearTotal){
      percentDiff = ((thisYearTotal - lastYearTotal)/lastYearTotal)*100;
      scaleVal = 1;
      }
      else if(lastYearTotal != 0 && thisYearTotal !=0 && lastYearTotal > thisYearTotal){
      percentDiff = ((lastYearTotal - thisYearTotal)/lastYearTotal)*100;
      }
      res.put("percentDifference",percentDiff);
      res.put("scale",scaleVal );
      
      db2 = {
        criteria : [parentId == meterId && CHWConsumptionAccumulatorDelta != null],
        field : "ttime",
      };
      date = Module("btudata").fetch(db2);
      if(date != null) {
        datetime = date[0];
        format = "MMM dd, yyyy hh:mm a";
        formattedTime = new NameSpace("date").getFormattedTime(datetime, format);
        res.put("dateTime",formattedTime);
      }
      else {
        res.put("dateTime",date);
      }
      res.put("readingName", "CHWConsumptionAccumulatorDelta");
  }
  return res;                
}'

'205':
  description: 'meter peak demand card'
  usage: 'meter summary'
  workflow: 'Map peakDemand(Number meterId, String utilityTypeName){ 
  currentYear = new NameSpace("date").getDateRange("Current Year");
  res = {};
  if(utilityTypeName == "Gas Meter") {
      db = {
        criteria : [parentId == meterId && ttime == currentYear],
        field : "flowRate",
        aggregation : "max",
      };
      peak = Module("gasdata").fetch(db);
      res.put("peakDemand",peak);
      
      if(peak != null) {
        db1 = {
          criteria : [parentId == meterId && flowRate == peak && ttime == currentYear],
          field : "ttime",
        };
        date = Module("gasdata").fetch(db1);
        if(date != null) {
          datetime = date[0];
          format = "MMM dd, yyyy hh:mm a";
          formattedTime = new NameSpace("date").getFormattedTime(datetime, format);
          res.put("peakTime",formattedTime);
        }
      }
      res.put("readingName", "flowRate");
      res.put("widgetName", "Maximum Flow");
  }
  else if(utilityTypeName == "Water Meter") {
      db = {
        criteria : [parentId == meterId && ttime == currentYear],
        field : "flowRate",
        aggregation : "max",
      };
      peak = Module("waterdata").fetch(db);
      res.put("peakDemand",peak);
      
      if(peak != null) {
        db1 = {
          criteria : [parentId == meterId && flowRate == peak && ttime == currentYear],
          field : "ttime",
        };
        date = Module("waterdata").fetch(db1);
        if(date != null) {
          datetime = date[0];
          format = "MMM dd, yyyy hh:mm a";
          formattedTime = new NameSpace("date").getFormattedTime(datetime, format);
          res.put("peakTime",formattedTime);
        }
      }
      res.put("readingName", "flowRate");
      res.put("widgetName", "Maximum Flow");
  }
  else if(utilityTypeName == "Electricity Meter") {
      db = {
        criteria : [parentId == meterId && ttime == currentYear],
        field : "totalDemand",
        aggregation : "max",
      };
      peak = Module("electricitydata").fetch(db);
      res.put("peakDemand",peak);
      
      if(peak != null) {
        db1 = {
          criteria : [parentId == meterId && totalDemand == peak && ttime == currentYear],
          field : "ttime",
        };
        date = Module("electricitydata").fetch(db1);
        if(date != null) {
          datetime = date[0];
          format = "MMM dd, yyyy hh:mm a";
          formattedTime = new NameSpace("date").getFormattedTime(datetime, format);
          res.put("peakTime",formattedTime);
        }
      }
      res.put("readingName", "totalDemand");
      res.put("widgetName", "Peak Demand");
  }
  else if(utilityTypeName == "Heat Meter") {
      db = {
        criteria : [parentId == meterId && ttime == currentYear],
        field : "thermalPower",
        aggregation : "max",
      };
      peak = Module("heatdata").fetch(db);
      res.put("peakDemand",peak);
      
      if(peak != null) {
        db1 = {
          criteria : [parentId == meterId && thermalPower == peak && ttime == currentYear],
          field : "ttime",
        };
        date = Module("heatdata").fetch(db1);
        if(date != null) {
          datetime = date[0];
          format = "MMM dd, yyyy hh:mm a";
          formattedTime = new NameSpace("date").getFormattedTime(datetime, format);
          res.put("peakTime",formattedTime);
        }
      }
      res.put("readingName", "thermalPower");
      res.put("widgetName", "Peak Thermal Power");
  }
  else if(utilityTypeName == "BTU Meter") {
      db = {
        criteria : [parentId == meterId && ttime == currentYear],
        field : "flowRate",
        aggregation : "max",
      };
      peak = Module("btudata").fetch(db);
      res.put("peakDemand",peak);
      
      if(peak != null) {
        db1 = {
          criteria : [parentId == meterId && flowRate == peak && ttime == currentYear],
          field : "ttime",
        };
        date = Module("btudata").fetch(db1);
        if(date != null) {
          datetime = date[0];
          format = "MMM dd, yyyy hh:mm a";
          formattedTime = new NameSpace("date").getFormattedTime(datetime, format);
          res.put("peakTime",formattedTime);
        }
      }
      res.put("readingName", "flowRate");
      res.put("widgetName", "Maximum Flow");
  }
  return res;                
}'